        If the user deletes the key and then re-creates it,
 *          the opened key will go stale and will become useless.
 *          You have to close the key and reopen it.
 *          To avoid worrying about that case, merely open it every time.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick number.
 *
 *  @parm   DWORD | sam |
 *
 *          Access level desired.
 *
 *  @parm   IN PJOYCAPS | pcaps |
 *
 *          Receives joystick capabilities information.
 *          If this parameter is <c NULL>, then joystick
 *          capabilities information is not returned.
 *
 *  @parm   IN DWORD  | dwOptions |
 *          Option flags to RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          hresLe(ERROR_FILE_NOT_FOUND): The key does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_OpenConfigKey(UINT idJoy, DWORD sam, PJOYCAPS pcaps, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    MMRESULT mmrc = MMSYSERR_ERROR;
    JOYCAPS caps;
    EnterProc(JoyReg_OpenConfigKey, (_ "uxp", idJoy, sam, pcaps));

    /*
     *  If caller doesn't care, then just dump the caps into our
     *  private buffer.
     */
    if(pcaps == NULL)
    {
        pcaps = &caps;
    }

    /*
     *  If we can't get the dev caps for the specified joystick,
     *  then use the magic joystick id "-1" to get non-specific
     *  caps.
     */
    if( fWinnt )
    {
        ZeroX(*pcaps);
        lstrcpy(pcaps->szRegKey, REGSTR_SZREGKEY );
        mmrc = JOYERR_NOERROR;
    } else 
    {
        mmrc = joyGetDevCaps(idJoy, pcaps, cbX(*pcaps));
        if( mmrc != JOYERR_NOERROR ) {
            mmrc = joyGetDevCaps((DWORD)-1, pcaps, cbX(*pcaps));
        }
    }

    if(mmrc == JOYERR_NOERROR)
    {

        TCHAR tsz[cA(REGSTR_PATH_JOYCONFIG) +
                  1 +                           /* backslash */
                  cA(pcaps->szRegKey) +
                  1 +                           /* backslash */
                  cA(REGSTR_KEY_JOYCURR) + 1];        

        /* tsz = MediaResources\Joystick\<drv>\CurrentJoystickSettings */
        wsprintf(tsz, TEXT("%s\\%s\\") REGSTR_KEY_JOYCURR,
                 REGSTR_PATH_JOYCONFIG, pcaps->szRegKey);


        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tsz, sam, REG_OPTION_VOLATILE, phk);

    } else
    {
        hres = E_FAIL;
    }

    ExitBenignOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenSaveKey |
 *
 *          Open the registry key that accesses joystick saved configurations
 *
 *          Warning!  Do not cache this regkey.
 *
 *          If the user deletes the key and then re-creates it,
 *          the opened key will go stale and will become useless.
 *          You have to close the key and reopen it.
 *          To avoid worrying about that case, merely open it every time.
 *
 *  @parm   DWORD | dwType |
 *
 *          Joystick type.
 *
 *          This is either one of the standard ones in the range
 *
 *  @parm   IN LPCDIJOYCONFIG | pcfg |
 *
 *          If the dwType represents an OEM type, this should point to a
 *          configuration data structure containing a valid wszType.
 *
 *  @parm   DWORD | sam |
 *
 *          Access level desired.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          hresLe(ERROR_FILE_NOT_FOUND): The key does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_OpenSaveKey(DWORD dwType, LPCDIJOYCONFIG pcfg, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    MMRESULT mmrc = MMSYSERR_ERROR;
    JOYCAPS caps;
    DWORD   dwOptions = 0;
    EnterProc(JoyReg_OpenSaveKey, (_ "upx", dwType, pcfg, sam));

    /*
     *  use the magic joystick id "-1" to get non-specific caps.
     */

    if( fWinnt )
    {
        ZeroX(caps);
        lstrcpy(caps.szRegKey, REGSTR_SZREGKEY );
        mmrc = JOYERR_NOERROR;
    } else 
    {
        mmrc = joyGetDevCaps((DWORD)-1, &caps, cbX(caps));
    }

    if(mmrc == JOYERR_NOERROR)
    {
        TCHAR tsz[cA(REGSTR_PATH_JOYCONFIG) +
                  1 +                           /* backslash */
                  cA(caps.szRegKey) +
                  1 +                           /* backslash */
                  cA(REGSTR_KEY_JOYSETTINGS) +
                  1 +                           /* backslash */
                  max( cA(REGSTR_KEY_JOYPREDEFN), cA(pcfg->wszType) ) + 1 ];

        /* tsz = MediaResources\Joystick\<drv>\JoystickSettings\<Type> */
        if( dwType >= JOY_HW_PREDEFMAX )
        {
            wsprintf(tsz, TEXT("%s\\%s\\%s\\%ls"),
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey, REGSTR_KEY_JOYSETTINGS, pcfg->wszType);
        } else
        {
            /*
             *  We will probably never have more than the current 11 predefined
             *  joysticks.  Assume no more than 99 so %d is as many characters.
             */
            wsprintf(tsz, TEXT("%s\\%s\\%s\\" REGSTR_KEY_JOYPREDEFN),
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey, REGSTR_KEY_JOYSETTINGS, dwType );
        }


        if( pcfg->hwc.dwUsageSettings & JOY_US_VOLATILE )
            dwOptions = REG_OPTION_VOLATILE;
        else
            dwOptions = REG_OPTION_NON_VOLATILE;

        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tsz, sam, dwOptions, phk);

    } else
    {
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetSetConfigValue |
 *
 *          Retrieve or update configuration information about a joystick,
 *          as stored in the registry instance key.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @parm   LPCTSTR | ptszNValue |
 *
 *          Registry value name, with "%d" where a joystick number
 *          should be.
 *
 *  @parm   UINT | idJoy |
 *
 *          Zero-based joystick number.
 *
 *  @parm   DWORD | reg |
 *
 *          Registry data type expected.
 *
 *  @parm   LPVOID | pvBuf |
 *
 *          Buffer to receive information from registry (if getting)
 *          or containing value to set.
 *
 *  @parm   DWORD | cb |
 *
 *          Size of buffer, in bytes.
 *
 *  @parm   BOOL | fSet |
 *
 *          Nonzer if the value should be set; otherwise, it will be
 *          retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_FAIL>: Error reading/writing value to/from registry.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_GetSetConfigValue(HKEY hk, LPCTSTR ptszNValue, UINT idJoy,
                             DWORD reg, PV pvBuf, DWORD cb, BOOL fSet)
{
    HRESULT hres;
    int ctch;

    /* Extra +12 because a UINT can be as big as 4 billion */
    TCHAR tsz[max(
                 max(
                    max(cA(REGSTR_VAL_JOYNCONFIG),
                        cA(REGSTR_VAL_JOYNOEMNAME)),
                    cA(REGSTR_VAL_JOYNOEMCALLOUT)),
                 cA(REGSTR_VAL_JOYNFFCONFIG)) + 12 + 1];

    ctch = wsprintf(tsz, ptszNValue, idJoy + 1);
    AssertF(ctch < cA(tsz));

    if(fSet)
    {
        hres = JoyReg_SetValue(hk, tsz, reg, pvBuf, cb);
    } else
    {
        hres = JoyReg_GetValue(hk, tsz, reg, pvBuf, cb);
    }

    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresIdJoypInstanceGUID |
 *
 *          Given a joystick ID obtain the corresponding GUID.
 *          This routine differs in implementation on WINNT and WIN9x
 *          On WINNT there are no predefined GUID for Joystick IDs.
 *
 *  @parm   IN UINT | idJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   OUT LPGUID | lpguid |
 *
 *          Receives the joystick GUID. If no mapping exists,
 *          GUID_NULL is passed back
 *
 *  On Windows NT all joysticks are HID devices. The corresponding function
 *  for WINNT is defined in diWinnt.c
 *
 *****************************************************************************/

HRESULT EXTERNAL hResIdJoypInstanceGUID_95
    (
    UINT    idJoy,
    LPGUID  lpguid
    )
{
    HRESULT hRes;

    hRes = S_OK;
    if( idJoy < cA(rgGUID_Joystick) )
    {
        *lpguid = rgGUID_Joystick[idJoy];
    } else
    {
        hRes = DIERR_NOTFOUND;
        ZeroX(*lpguid);
    }
    return hRes;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetConfigInternal |
 *
 *          Obtain information about a joystick's configuration.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   PJOYCAPS | pcaps |
 *
 *          Receives information about the joystick capabilities.
 *          If this parameter is <c NULL>, then joystick
 *          capabilities information is not returned.
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg |
 *
 *          Receives information about the joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_GetConfigInternal(UINT idJoy, PJOYCAPS pcaps,
                             LPDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres = E_FAIL;

    EnterProc(JoyReg_GetConfigInternal, (_ "upx", idJoy, pcaps, pcfg, fl));

    AssertF((fl & ~DIJC_GETVALID) == 0);

    /* We only support (0/16) joysticks */
    if( idJoy < cJoyMax )
    {
        /* Force a rescan of all HID device list
         * Some device may have been attached
         * since we last looked
         */
        DIHid_BuildHidList(FALSE);

        if(fl & DIJC_GUIDINSTANCE)
        {
            hres = hResIdJoypInstanceGUID_WDM(idJoy, &pcfg->guidInstance);

            if( (hres != S_OK) && !fWinnt) {
                hres = hResIdJoypInstanceGUID_95(idJoy, &pcfg->guidInstance);
            }
            
            if( FAILED(hres) )
            {
                goto done;
            }
        }

        if( fl & DIJC_INREGISTRY )
        {
            HKEY hk;

            /* Does the registry entry exist ? */
            hres = JoyReg_OpenConfigKey(idJoy, KEY_QUERY_VALUE, pcaps,REG_OPTION_NON_VOLATILE , &hk);
            if(SUCCEEDED(hres))
            {
                if(fl & DIJC_REGHWCONFIGTYPE)
                {
                    hres = JoyReg_GetConfigValue(
                                                hk, REGSTR_VAL_JOYNCONFIG,
                                                idJoy, REG_BINARY,
                                                &pcfg->hwc, cbX(pcfg->hwc));
                    if(FAILED(hres))
                    {
                        goto closedone;
                    }

                    pcfg->wszType[0] = TEXT('\0');
                    if( (pcfg->hwc.dwUsageSettings & JOY_US_ISOEM) ||
                        ( !fWinnt && (pcfg->hwc.dwType >= JOY_HW_PREDEFMIN) 
                                  && (pcfg->hwc.dwType < JOY_HW_PREDEFMAX) ) )
                    {
                        hres = JoyReg_GetConfigValue(
                                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                                    pcfg->wszType, cbX(pcfg->wszType));
                        if(FAILED(hres))
                        {
                            goto closedone;
                        }
                    }
                }


                if(fl & DIJC_CALLOUT)
                {
                    pcfg->wszCallout[0] = TEXT('\0');
                    hres = JoyReg_GetConfigValue(
                                                hk, REGSTR_VAL_JOYNOEMCALLOUT, idJoy, REG_SZ,
                                                pcfg->wszCallout, cbX(pcfg->wszCallout));
                    if(FAILED(hres))
                    {
                        ZeroX(pcfg->wszCallout);
                        hres = S_FALSE;
                        /* Note that we fall through and let hres = S_OK */
                    }
                }


                if(fl & DIJC_GAIN)
                {
                    /*
                     *  If there is no FF configuration, then
                     *  default to DI_FFNOMINALMAX gain.
                     */
                    hres = JoyReg_GetConfigValue(hk,
                                                 REGSTR_VAL_JOYNFFCONFIG,
                                                 idJoy, REG_BINARY,
                                                 &pcfg->dwGain, cbX(pcfg->dwGain));

                    if(SUCCEEDED(hres) && ISVALIDGAIN(pcfg->dwGain))
                    {
                        /* Leave it alone; it's good */
                    } else
                    {
                        pcfg->dwGain = DI_FFNOMINALMAX;
                        hres = S_FALSE;
                    }
                }

                if( fl & DIJC_WDMGAMEPORT )
                {
                    PBUSDEVICEINFO pbdi;
                    /*
                     * If there is no Gameport Associated with this device
                     * then it must be a USB device
                     */

                    DllEnterCrit();
                    if( pbdi = pbdiFromJoyId(idJoy) )
                    {
                        pcfg->guidGameport = pbdi->guid;
                        //lstrcpyW(pcfg->wszGameport, pbdi->wszDisplayName);
                    } else
                    {
                        ZeroX(pcfg->guidGameport);
                        hres = S_FALSE;
                    }

                    DllLeaveCrit();
                }
            }

        closedone:
            if( FAILED(hres) ) {
                DIJOYTYPEINFO       dijti;

                AssertF( pcfg->dwSize == sizeof(DIJOYCONFIG_DX5) 
                      || pcfg->dwSize == sizeof(DIJOYCONFIG_DX6) );
                hres = DIWdm_JoyHidMapping(idJoy, NULL, pcfg, &dijti );
                if( FAILED(hres) ) {
                    hres = E_FAIL;
                }
            }

            RegCloseKey(hk);
        }
    } else
    {
        hres = DIERR_NOMOREITEMS;
    }

done:
    ExitBenignOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetConfig |
 *
 *          Obtain information about a joystick's configuration,
 *          taking the MSGAME.VXD driver into account.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   PJOYCAPS | pcaps |
 *
 *          Receives information about the joystick capabilities.
 *          If this parameter is <c NULL>, then joystick
 *          capabilities information is not returned.
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg |
 *
 *          Receives information about the joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_GetConfig(UINT idJoy, PJOYCAPS pcaps, LPDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    GUID    guid;

    EnterProc(JoyReg_GetConfig, (_ "upx", idJoy, pcaps, pcfg, fl));

    AssertF((fl & ~DIJC_GETVALID) == 0);

    /* 
     * First determine if the joystick exits 
     * On NT, we use WDM driver.
     * On Win9x, if WDM fails, use static guids.
     */
    hres = hResIdJoypInstanceGUID_WDM(idJoy, &guid);

    if( (hres != S_OK) && !fWinnt ) {
        hres = hResIdJoypInstanceGUID_95(idJoy, &guid);
    }

    if( SUCCEEDED( hres) )
    {

        hres = JoyReg_GetConfigInternal(idJoy, pcaps, pcfg, fl);

      #ifndef WINNT
        /***************************************************
         *
         *  Beginning of hack for Sidewinder Gamepad.
         *
         *  The gamepad needs to be polled six times before
         *  it realizes what is going on.
         *
         ***************************************************/

        if(SUCCEEDED(hres) && (fl & DIJC_CALLOUT))
        {

            static WCHAR s_wszMSGAME[] = L"MSGAME.VXD";

            if(memcmp(pcfg->wszCallout, s_wszMSGAME, cbX(s_wszMSGAME)) == 0)
            {
                JOYINFOEX ji;
                int i;
                DWORD dwWait;

                SquirtSqflPtszV(sqfl,
                                TEXT("Making bonus polls for Sidewinder"));

                /*
                 *  It's a Sidewinder.  Make six
                 *  bonus polls to shake the stick into submission.
                 *
                 *  Actually, we make 16 bonus polls.  The Sidewinder
                 *  guys said that five or six would be enough.
                 *  They're wrong.
                 *
                 *  I also sleep 10ms between each poll because that
                 *  seems to help a bit.
                 */
                ji.dwSize = cbX(ji);
                ji.dwFlags = JOY_RETURNALL;
                for(i = 0; i < 16; i++)
                {
                    MMRESULT mmrc = joyGetPosEx(idJoy, &ji);
                    SquirtSqflPtszV(sqfl,
                                    TEXT("joyGetPosEx(%d) = %d"),
                                    idJoy, mmrc);
                    Sleep(10);
                }

                /*
                 *  Now sleep for some time.  They forgot to tell us
                 *  this.
                 *
                 *  Bonus hack!  The amount of time we need to sleep
                 *  is CPU-speed dependent, so we'll grab the sleep
                 *  time from the registry to allow us to tweak it
                 *  later.
                 *
                 *  What a bunch of lamers.
                 */
                dwWait = RegQueryDIDword(NULL, REGSTR_VAL_GAMEPADDELAY, 100);
                if(dwWait > 10 * 1000)
                {
                    dwWait = 10 * 1000;
                }

                Sleep(dwWait);

                /*
                 *  And then check again.
                 */
                hres = JoyReg_GetConfigInternal(idJoy, pcaps, pcfg, fl);
            }
        }

        /***************************************************
         *
         *  End of hack for Sidewinder Gamepad.
         *
         ***************************************************/
      #endif //#ifndef WINNT    
      
    }

    return hres;
}

/* This never happens on NT */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_JoyIdToDeviceInterface_95 |
 *
 *          Given a joystick ID number, obtain the device interface
 *          corresponding to it.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick ID number, zero-based.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives init parameters from the driver.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          A buffer of size <c MAX_PATH> in which the device interface
 *          path is built.  Note that we can get away with a buffer of
 *          this size, since the code path exists only on Windows 95,
 *          and Windows 95 does not support paths longer than <c MAX_PATH>.
 *          (I.e., there ain't no \\?\ support in Win95.)
 *
 *  @returns
 *
 *          A pointer to the part of the <p ptszBuf> buffer that
 *          contains the actual device interface path.
 *
 *****************************************************************************/

LPSTR EXTERNAL
    JoyReg_JoyIdToDeviceInterface_95(UINT idJoy, PVXDINITPARMS pvip, LPSTR ptszBuf)
{
    UINT cwch;
    HRESULT hres;
    LPSTR ptszRc;

    if( fWinnt )
        return NULL;

    hres = Hel_Joy_GetInitParms(idJoy, pvip);
    if(SUCCEEDED(hres))
    {

        /*
         *  The length counter includes the terminating null.
         */
        cwch = LOWORD(pvip->dwFilenameLengths);

        /*
         *  The name that comes from HID is "\DosDevices\blah"
         *  but we want to use "\\.\blah".  So check if it indeed
         *  of the form "\DosDevices\blah" and if so, convert it.
         *  If not, then give up.
         *
         *  For the string to possibly be a "\DosDevices\", it
         *  needs to be of length 12 or longer.
         */

        if(cwch >= 12 && cwch < MAX_PATH)
        {

            /*
             *  WideCharToMultiByte does parameter validation so we
             *  don't have to.
             */
            WideCharToMultiByte(CP_ACP, 0, pvip->pFilenameBuffer, cwch,
                                ptszBuf, MAX_PATH, 0, 0);

            /*
             *  The 11th (zero-based) character must be a backslash.
             *  And the value of cwch had better be right.
             */
            if(ptszBuf[cwch-1] == ('\0') && ptszBuf[11] == ('\\'))
            {

                /*
                 *  Wipe out the backslash and make sure the lead-in
                 *  is "\DosDevices".
                 */
                ptszBuf[11] = ('\0');
                if(lstrcmpiA(ptszBuf, ("\\DosDevices")) == 0)
                {
                    /*
                     *  Create a "\\.\" at the start of the string.
                     *  Note!  This code never runs on Alphas so we
                     *  can do evil unaligned data accesses.
                     *
                     *  (Actually, 8 is a multiple of 4, so everything
                     *  is aligned after all.)
                     */
                    *(LPDWORD)&ptszBuf[8] = 0x5C2E5C5C;

                    ptszRc = &ptszBuf[8];
                } else
                {
                    ptszRc = NULL;
                }
            } else
            {
                ptszRc = NULL;
            }
        } else
        {
            ptszRc = NULL;
        }
    } else
    {
        ptszRc = NULL;
    }

    return ptszRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | JoyReg_SetCalibration |
 *
 *          Store information about a joystick's configuration,
 *          shadowing the information back into the HID side of
 *          things as well.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *****************************************************************************/

STDMETHODIMP
    TFORM(CDIObj_FindDevice)(PV pdiT, REFGUID rguid,
                             LPCTSTR ptszName, LPGUID pguidOut);

void EXTERNAL
    JoyReg_SetCalibration(UINT idJoy, LPJOYREGHWCONFIG phwc)
{
    HRESULT hres;
    VXDINITPARMS vip;
    GUID guid;
    CHAR tsz[MAX_PATH];
    LPSTR pszPath;
    TCHAR ptszPath[MAX_PATH];
    EnterProc(JoyReg_SetCalibration, (_ "up", idJoy, phwc));

    pszPath = JoyReg_JoyIdToDeviceInterface_95(idJoy, &vip, tsz);

    if( pszPath )
#ifdef UNICODE
        AToU( ptszPath, MAX_PATH, pszPath );
#else
        lstrcpy( (LPSTR)ptszPath, pszPath );
#endif

    if(pszPath &&
       SUCCEEDED(CDIObj_FindDeviceInternal(ptszPath, &guid)))
    {
        IDirectInputDeviceCallback *pdcb;
#ifdef DEBUG
        CREATEDCB CreateDcb;
#endif

#ifdef DEBUG
        /*
         *  If the associated HID device got unplugged, then
         *  the instance GUID is no more.  So don't get upset
         *  if we can't find it.  But if we do find it, then
         *  it had better be a HID device.
         *
         *  CHid_New will properly fail if the associated
         *  device is not around.
         */
        hres = hresFindInstanceGUID(&guid, &CreateDcb, 1);
        AssertF(fLimpFF(SUCCEEDED(hres), CreateDcb == CHid_New));
#endif

        if(SUCCEEDED(hres = CHid_New(0, &guid,
                                     &IID_IDirectInputDeviceCallback,
                                     (PPV)&pdcb)))
        {
            LPDIDATAFORMAT pdf;

            /*
             *  The VXDINITPARAMS structure tells us where JOYHID
             *  decided to place each of the axes.  Follow that
             *  table to put them into their corresponding location
             *  in the HID side.
             */
            hres = pdcb->lpVtbl->GetDataFormat(pdcb, &pdf);
            if(SUCCEEDED(hres))
            {
                UINT uiAxis;
                DIPROPINFO propi;

                propi.pguid = DIPROP_SPECIFICCALIBRATION;

                /*
                 *  For each axis...
                 */
                for(uiAxis = 0; uiAxis < 6; uiAxis++)
                {
                    DWORD dwUsage = vip.Usages[uiAxis];
                    /*
                     *  If the axis is mapped to a usage...
                     */
                    if(dwUsage)
                    {
                        /*
                         *  Convert the usage into an object index.
                         */
                        hres = pdcb->lpVtbl->MapUsage(pdcb, dwUsage,
                                                      &propi.iobj);
                        if(SUCCEEDED(hres))
                        {
                            DIPROPCAL cal;

                            /*
                             *  Convert the old-style calibration into
                             *  a new-style calibration.
                             */
#define CopyCalibration(f, ui) \
                cal.l##f = (&phwc->hwv.jrvHardware.jp##f.dwX)[ui]

                            CopyCalibration(Min, uiAxis);
                            CopyCalibration(Max, uiAxis);
                            CopyCalibration(Center, uiAxis);

#undef CopyCalibration

                            /*
                             *  Set the calibration property on the object.
                             */
                            propi.dwDevType =
                                pdf->rgodf[propi.iobj].dwType;
                            hres = pdcb->lpVtbl->SetProperty(pdcb, &propi,
                                                             &cal.diph);
                        }
                    }
                }
            }

            Invoke_Release(&pdcb);
        }
    }

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetHWConfig |
 *
 *          Store information about a joystick's <t JOYREGHWCONFIG>.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *  @parm   HKEY | hk |
 *
 *          The type key we are munging.
 *
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

HRESULT INTERNAL
    JoyReg_SetHWConfig(UINT idJoy, LPJOYREGHWCONFIG phwc, LPCDIJOYCONFIG pcfg,
                       HKEY hk)
{
    HRESULT hres;
    HKEY hkSave;
    DWORD dwSam;

    /*
     *  The caller has set phwc->dwType, so use it to determine
     *  where the data comes from or goes to.
     */
    if( phwc->dwType == JOY_HW_NONE )
    {
        /*
         *  Nothing to do
         */
    } else if( phwc->dwType == JOY_HW_CUSTOM )
    {
        /*  ISSUE-2001/03/29-timgill Custom HWConfig not handled correctly
         *  We don't know the type name and the only time we can look
         *  it up is when were modifying an existing config so although we
         *  could store the config, we'd never be able to get it back.
         *  Should return no better than S_FALSE.  This will have to wait.
         */
    } else
    {
        /*
         *  Try to access saved values
         */

        // ISSUE-2001/03/29-timgill Dangerous type cast
        PDWORD pdw = (PDWORD)&phwc->hwv;

        dwSam = KEY_QUERY_VALUE;

        while( pdw < &phwc->dwType )
        {
            if( *pdw )
            {
                /*
                 *  Real config data so write it
                 */
                dwSam = KEY_SET_VALUE;
                break;
            }
            pdw++;
        }

        /*
         *  If the device is autoloaded and yet the user is manually assigning it
         *  to an ID, set the volatile flag.  The flag will be set to the driver
         *  defined value if a driver ever gets hotplug assigned to this ID but if
         *  not, this makes sure that the settings are removed on next reboot.
         */
        if(phwc->hws.dwFlags & JOY_HWS_AUTOLOAD)
        {
            phwc->dwUsageSettings |= JOY_US_VOLATILE;
        }

        hres = JoyReg_OpenSaveKey( phwc->dwType, pcfg, dwSam, &hkSave );

        if( SUCCEEDED(hres) )
        {
            if( dwSam == KEY_SET_VALUE )
            {
                hres = JoyReg_SetConfigValue(hkSave, REGSTR_VAL_JOYNCONFIG,
                                             idJoy, REG_BINARY,
                                             phwc, cbX(*phwc));
                if( FAILED(hres) )
                {
                    // Report the error but live with it
                    RPF("JoyReg_SetConfig: failed to set saved config %08x", hres );
                }
            } else
            {
                JOYREGHWCONFIG hwc;

                /*
                 *  Read it into an extra buffer because we only want it
                 *  if it's complete.
                 */
                hres = JoyReg_GetConfigValue(hkSave, REGSTR_VAL_JOYNCONFIG,
                                             idJoy, REG_BINARY,
                                             &hwc, cbX(hwc));
                if( hres == S_OK )
                {
                    // Assert hws is first and no gap before dwUsageSettings
                    CAssertF( FIELD_OFFSET( JOYREGHWCONFIG, hws ) == 0 );
                    CAssertF( FIELD_OFFSET( JOYREGHWCONFIG, dwUsageSettings ) == sizeof( hwc.hws ) );

                    // Copy the whole structure except the hws
                    memcpy( &phwc->dwUsageSettings, &hwc.dwUsageSettings, 
                        sizeof( hwc ) - sizeof( hwc.hws ) );
                }
            }

            RegCloseKey( hkSave );
        }
        /*
         *  If we failed to read, there's probably nothing there and the
         *  structure is set up already for a blank config.
         *  If we failed to write there probably not much we can do
         */
    }


    hres = JoyReg_SetConfigValue(hk, REGSTR_VAL_JOYNCONFIG,
                                 idJoy, REG_BINARY,
                                 phwc, cbX(*phwc));
    if(FAILED(hres))
    {
        goto done;
    }

    if(phwc->dwUsageSettings & JOY_US_ISOEM)
    {

        hres = JoyReg_SetConfigValue(
                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                    pcfg->wszType, cbX(pcfg->wszType));

    } else
    {
        hres = JoyReg_SetConfigValue(
                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                    0, 0);
    }

    done:;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetConfig |
 *
 *          Store information about a joystick's configuration.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   JOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *          It may be modified if we needed to load the config
 *          info from the saved settings.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structures pointed
 *          to by <p phwc> and <p pjc> are to be written out.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

JOYREGHWVALUES      null_hwv = { 0};

STDMETHODIMP
    JoyReg_SetConfig(UINT idJoy, LPJOYREGHWCONFIG phwc,
                     LPCDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    EnterProc(JoyReg_SetConfig, (_ "uppx", idJoy, phwc, pcfg, fl));

    AssertF((fl & ~DIJC_INTERNALSETVALID) == 0);

    if(idJoy < cJoyMax )
    {

        if(fl & DIJC_INREGISTRY)
        {
            HKEY hk;
            DWORD dwOptions = 0;

            hres = JoyReg_OpenConfigKey(idJoy, KEY_SET_VALUE, NULL, dwOptions, &hk);

            if(SUCCEEDED(hres))
            {

                if(fl & DIJC_REGHWCONFIGTYPE)
                {
                    hres = JoyReg_SetHWConfig(idJoy, phwc, pcfg, hk);

                    if(FAILED(hres))
                    {
                        goto closedone;
                    }

                    if(fl & DIJC_UPDATEALIAS)
                    {
                        JoyReg_SetCalibration(idJoy, phwc);
                    }

                }

                if(fl & DIJC_CALLOUT)
                {
                    hres = JoyReg_SetConfigValue(
                                                hk, REGSTR_VAL_JOYNOEMCALLOUT, idJoy, REG_SZ,
                                                pcfg->wszCallout, cbX(pcfg->wszCallout));
                    if(FAILED(hres))
                    {
                        hres = S_FALSE;
                        //continue to go
                    }
                }

                if(fl & DIJC_GAIN)
                {
                    if(ISVALIDGAIN(pcfg->dwGain))
                    {

                        /*
                         *  If restoring to nominal, then the key
                         *  can be deleted; the default value will
                         *  be assumed subsequently.
                         */
                        if(pcfg->dwGain == DI_FFNOMINALMAX)
                        {
                            hres = JoyReg_SetConfigValue(hk,
                                                         TEXT("Joystick%dFFConfiguration"),
                                                         idJoy, REG_SZ, 0, 0);
                        } else
                        {
                            hres = JoyReg_SetConfigValue(hk,
                                                         TEXT("Joystick%dFFConfiguration"),
                                                         idJoy, REG_BINARY,
                                                         &pcfg->dwGain, cbX(pcfg->dwGain));
                        }

                        if(FAILED(hres))
                        {
                            hres = S_FALSE;
                            goto closedone;
                        }
                    } else
                    {
                        RPF("ERROR: SetConfig: Invalid dwGain");
                        hres = E_INVALIDARG;
                        goto closedone;
                    }
                }

                hres = S_OK;

                closedone:;
                RegCloseKey(hk);
            }
        } else
        {
            hres = S_OK;
        }

    } else
    {
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | ibJoyPosAxis |
 *
 *          Returns the offset of the <p iAxis>'th joystick axis
 *          in the <t JOYPOS> structure.
 *
 *  @parm   int | iAxis |
 *
 *          The index of the requested axis.  X, Y, Z, R, U and V are
 *          respctively zero through five.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

#define ibJoyPosAxis(iAxis)                                         \
        (FIELD_OFFSET(JOYPOS, dwX) + cbX(DWORD) * (iAxis))          \

#define pJoyValue(jp, i)                                            \
        (LPDWORD)pvAddPvCb(&(jp), ibJoyPosAxis(i))                  \

/*
 *  The following doesn't do anything at runtime.  It is a compile-time
 *  check that everything is okay.
 */
void INLINE
    JoyReg_CheckJoyPosAxis(void)
{
#define CheckAxis(x)    \
        CAssertF(ibJoyPosAxis(iJoyPosAxis##x) == FIELD_OFFSET(JOYPOS, dw##x))

    CheckAxis(X);
    CheckAxis(Y);
    CheckAxis(Z);
    CheckAxis(R);
    CheckAxis(U);
    CheckAxis(V);

#undef CheckAxis
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_IsValidUserValues |
 *
 *          Retermine whether the values are ostensibly valid.
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the user joystick configuration.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:
 *          Something looks bad.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_IsValidUserValues(LPCDIJOYUSERVALUES pjuv)
{
    HRESULT hres;
    int iAxis;

    /*
     *  First set up the values to values that are out of range so
     *  that we will fall back to defaults.
     */
    for(iAxis = 0; iAxis < cJoyPosAxisMax; iAxis++)
    {
        if((int)*pJoyValue(pjuv->ruv.jrvRanges.jpMax, iAxis) < 0)
        {
            RPF("JOYUSERVALUES: Negative jpMax not a good idea");
            goto bad;
        }
        if(*pJoyValue(pjuv->ruv.jrvRanges.jpMin, iAxis) >
           *pJoyValue(pjuv->ruv.jrvRanges.jpMax, iAxis))
        {
            RPF("JOYUSERVALUES: Min > Max not a good idea");
            goto bad;
        }

        if(!fInOrder(0, *pJoyValue(pjuv->ruv.jpDeadZone, iAxis), 100))
        {
            RPF("JOYUSERVALUES: DeadZone > 100 not a good idea");
            goto bad;
        }
    }

    hres = S_OK;

    return hres;

    bad:;
    hres = E_INVALIDARG;
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetUserValues |
 *
 *          Obtain information about user settings for the joystick.
 *
 *
 *  @parm   IN OUT LPDIJOYUSERVALUES | pjuv |
 *
 *          Receives information about the user joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYUSERVALUES.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_GetUserValues(LPDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres;
    HKEY hk;
    LONG lRc;
    EnterProc(JoyReg_GetUserValues, (_ "px", pjuv, fl));

    hres = S_OK;                    /* If nothing happens, then success */

    if(fl & DIJU_USERVALUES)
    {

        /*
         *  Okay, now get the user settings.
         *
         *  If anything goes wrong, then just limp with the default values.
         */
        lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYCONFIG,
                           0, KEY_QUERY_VALUE, &hk);
        if(lRc == ERROR_SUCCESS)
        {

            hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYUSERVALUES,
                                   REG_BINARY, &pjuv->ruv, cbX(pjuv->ruv));
            if(SUCCEEDED(hres))
            {
                /*
                 *  Sanity-check the values.  If anything is screwy,
                 *  then fall back to the defaults.
                 */
                hres = JoyReg_IsValidUserValues(pjuv);

            }

            if(FAILED(hres))
            {
                /*
                 *  Oh well.  Just use the default values, then.
                 *
                 *  Stolen from ibmjoy\msjstick.c.
                 */
                ZeroMemory(&pjuv->ruv, cbX(pjuv->ruv));

#define DEFAULT_RANGE_MAX 65535
#define DEFAULT_TIMEOUT   5000
#define DEFAULT_DEADZONE  5

                pjuv->ruv.jrvRanges.jpMax.dwX = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwY = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwZ = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwR = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwU = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwV = DEFAULT_RANGE_MAX;
                pjuv->ruv.jpDeadZone.dwX = DEFAULT_DEADZONE;
                pjuv->ruv.jpDeadZone.dwY = DEFAULT_DEADZONE;
                pjuv->ruv.dwTimeOut = DEFAULT_TIMEOUT;
            }

            RegCloseKey(hk);
        }
    }

    if(fl & DIJU_INDRIVERREGISTRY)
    {
        hres = JoyReg_OpenConfigKey((UINT)-1, KEY_QUERY_VALUE, NULL, FALSE, &hk);

        if(SUCCEEDED(hres))
        {

            if(fl & DIJU_GLOBALDRIVER)
            {
                /*
                 *  If it doesn't work, then return the default value
                 *  of "MSANALOG.VXD".  We can't blindly use
                 *  JoyReg_GetValue, because that treats a nonexistent
                 *  value as having a default of the null string.
                 */
                lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                      0, 0, 0, 0);
                if((lRc == ERROR_SUCCESS || lRc == ERROR_MORE_DATA) &&
                   SUCCEEDED(
                            hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                                   REG_SZ, pjuv->wszGlobalDriver,
                                                   cbX(pjuv->wszGlobalDriver))))
                {
                    /* Yay, it worked */
                } else
                {
                    CopyMemory(pjuv->wszGlobalDriver,
                               c_wszDefPortDriver,
                               cbX(c_wszDefPortDriver));
                }

            }

            if(fl & DIJU_GAMEPORTEMULATOR)
            {

                /*
                 *  If it doesn't work, then just return a null string.
                 */
                hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYGAMEPORTEMULATOR,
                                       REG_SZ, pjuv->wszGameportEmulator,
                                       cbX(pjuv->wszGameportEmulator));
                if(FAILED(hres))
                {
                    pjuv->wszGameportEmulator[0] = TEXT('\0');
                }

            }

            RegCloseKey(hk);
        }

    }

    /*
     *  Warning!  CJoy_InitRanges() assumes this never fails.
     */
    hres = S_OK;

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetUserValues |
 *
 *          Store information about user settings for the joystick.
 *
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the user joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYUSERVALUES.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_SetUserValues(LPCDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres = E_FAIL;
    HKEY hk;
    EnterProc(JoyReg_SetUserValues, (_ "px", pjuv, fl));

    if(fl & DIJU_USERVALUES)
    {

        /*
         *  See if the values are sane.
         */
        if(fl & DIJU_USERVALUES)
        {
            hres = JoyReg_IsValidUserValues(pjuv);
            if(FAILED(hres))
            {
                goto done;
            }
        }

        /*
         *  Off to the registry we go.
         */

        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                               REGSTR_PATH_JOYCONFIG, 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &hk);

        if(SUCCEEDED(hres))
        {

            hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYUSERVALUES,
                                   REG_BINARY, &pjuv->ruv,
                                   cbX(pjuv->ruv));
            RegCloseKey(hk);

            if(FAILED(hres))
            {
                goto done;
            }
        } else
        {
            goto done;
        }
    }

    if(fl & DIJU_INDRIVERREGISTRY)
    {

        hres = JoyReg_OpenConfigKey((UINT)-1, KEY_SET_VALUE, NULL, FALSE, &hk);

        if(SUCCEEDED(hres))
        {

            if(fl & DIJU_GLOBALDRIVER)
            {
                /*
                 *  This is a weird key.  The default value is
                 *  "MSANALOG.VXD", so if we get a null string, we
                 *  can't use JoyReg_SetValue, because that will
                 *  delete the key.
                 */
                if(pjuv->wszGlobalDriver[0])
                {
                    hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                           REG_SZ, pjuv->wszGlobalDriver,
                                           cbX(pjuv->wszGlobalDriver));
                } else
                {
                    LONG lRc;
                    lRc = RegSetValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT, 0,
                                        REG_SZ, (PV)TEXT(""), cbCtch(1));
                    if(lRc == ERROR_SUCCESS)
                    {
                        hres = S_OK;
                    } else
                    {
                        RPF("Unable to write %s to registry",
                            REGSTR_VAL_JOYOEMCALLOUT);
                        hres = E_FAIL;  /* Else, something bad happened */
                    }
                }
                if(FAILED(hres))
                {
                    goto regdone;
                }
            }

            if(fl & DIJU_GAMEPORTEMULATOR)
            {

                hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYGAMEPORTEMULATOR,
                                       REG_SZ, pjuv->wszGameportEmulator,
                                       cbX(pjuv->wszGameportEmulator));
                if(FAILED(hres))
                {
                    goto regdone;
                }
            }

            regdone:;
            RegCloseKey(hk);

        } else
        {
            goto done;
        }
    }

    done:;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenFFKey |
 *
 *          Given a type key, move to its force feedback subkey.
 *
 *  @parm   HKEY | hkType |
 *
 *          The parent type key.
 *
 *  @parm   REGSAM | sam |
 *
 *          Access level desired.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: Couldn't open the key.
 *
 *****************************************************************************/

STDMETHODIMP
    JoyReg_OpenFFKey(HKEY hkType, REGSAM sam, PHKEY phk)
{
    HRESULT hres;
    EnterProc(JoyReg_OpenFFKey, (_ "xx", hkType, sam));

    *phk = 0;

    if(hkType)
    {
        if(RegOpenKeyEx(hkType, TEXT("OEMForceFeedback"), 0, sam, phk) == 0)
        {
            hres = S_OK;
        } else
        {
            hres = E_FAIL;
        }
    } else
    {
        hres = DIERR_NOTFOUND;
    }

    ExitBenignOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   TCHAR | CJoyCfg_CharFromType |
 *
 *          Convert a predefined type number to a character.
 *
 *  @func   UINT | CJoyCfg_TypeFromChar |
 *
 *          Convert a character back to a predefined type number.
 *
 *****************************************************************************/

#define JoyCfg_CharFromType(t)     ((TCHAR)(L'0' + t))
#define JoyCfg_TypeFromChar(tch)   ((tch) - L'0')

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | JoyReg_GetPredefTypeInfo |
 *
 *          Obtain information about a predefined joystick type.
 *
 *  @parm   LPCWSTR | pwszType |
 *
 *          Points to the name of the type.  It is known to begin
 *          with a "#".  The remainder has not yet been parsed.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pjti |
 *
 *          Receives information about the joystick type,
 *          already validated.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    JoyReg_GetPredefTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres;
    UINT itype;
    EnterProcI(JoyReg_GetPredefTypeInfo, (_ "Wpx", pwszType, pjti, fl));

    //(MarcAnd) These TEXT('blah') things should be L'blah' as the string is always wide
    AssertF(pwszType[0] == TEXT('#'));

    itype = JoyCfg_TypeFromChar(pwszType[1]);

    if(fInOrder(JOY_HW_PREDEFMIN, itype, JOY_HW_PREDEFMAX) &&
       pwszType[2] == TEXT('\0'))
    {
        /*
         *  No real point in checking the bits in fl, since
         *  setting it up is so easy.
         */
        pjti->hws = c_rghwsPredef[itype - JOY_HW_PREDEFMIN];
        LoadStringW(g_hinst, IDS_PREDEFJOYTYPE + itype,
                    pjti->wszDisplayName, cA(pjti->wszDisplayName));
        pjti->wszCallout[0] = TEXT('\0');
        
        ZeroX(pjti->clsidConfig);

        if(fl & DITC_FLAGS1 )
        {
            pjti->dwFlags1 = 0x0;
        }

        if( fl & DITC_HARDWAREID )
        {
            lstrcpyW(pjti->wszHardwareId, c_rghwIdPredef[itype-JOY_HW_PREDEFMIN] );
        }

        hres = S_OK;
    } else
    {
        hres = DIERR_NOTFOUND;
    }

    ExitOleProc();
    return hres;
}


#if 0  //don't delete it now.
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_GetIDByOemName |
 *
 *          Get the Id by OEMNAME
 *
 *  @parm   IN LPTSTR | szOEMNAME |
 *
 *          String used to find the ID.
 *
 *  @parm   IN LPUNIT | lpID |
 *
 *          The ID to get.
 *
 *  @returns
 *
 *          A COM success code unless the current configuration key could not
 *          be opened, or could not find the OEMNAME.
 *
 *****************************************************************************/

HRESULT EXTERNAL JoyReg_GetIDByOemName( LPTSTR szOemName, PUINT pId )
{
    HRESULT hres = E_FAIL;
    LONG    lRc;
    HKEY    hkCurrCfg;
    UINT    JoyId;
    TCHAR   szTestName[MAX_JOYSTRING];
    TCHAR   szOemNameKey[MAX_JOYSTRING];
    DWORD   cb;

    EnterProcI(JoyReg_GetIDByOemName, (_ "sp", szOemName, pId ));

    hres = JoyReg_OpenConfigKey( (UINT)(-1), KEY_WRITE, NULL, REG_OPTION_NON_VOLATILE, &hkCurrCfg );

    if( SUCCEEDED( hres ) )
    {
        for( JoyId = 0; (JoyId < 16) || ( lRc == ERROR_SUCCESS ); JoyId++ )
        {
            wsprintf( szOemNameKey, REGSTR_VAL_JOYNOEMNAME, JoyId+1 );
            cb = sizeof( szTestName );
            lRc = RegQueryValueEx( hkCurrCfg, szOemNameKey, 0, NULL, (PBYTE)szTestName, &cb );
            if( lRc == ERROR_SUCCESS )
            {
                if( !lstrcmpi( szOemName, szTestName ) )
                {
                    *pId = JoyId;
                    pId ++;
                    hres = S_OK;
                    break;
                }
            }
        }

    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("JoyReg_OpenConfigKey failed code 0x%08x"), hres );
    }

    ExitOleProc();

    return hres;

} /* JoyReg_GetIDByOemName */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dijoyhid.c ===
/*****************************************************************************
 *
 *  DIHid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      WINNT implementation of JOYHID.
 *
 *  Contents:
 *
 *      DIWdm_JoyHidMapping
 *      JoyReg_JoyIdToDeviceInterface
 *
 *****************************************************************************/

#include "dinputpr.h"

#undef  sqfl
#define sqfl sqflWDM

#include "dijoyhid.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT EXTERNAL | DIWdm_JoyHidMapping |
 *
 *          Does the work done by JoyHid on Win9x. This function
 *          maps the Joystick ID to a HID device and talks to the
 *          HID device to obtain its capabilities.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Id of the joystick to be located.
 *
 *  @parm   OUT PVXDINITPARAMS | pvip | OPTIONAL
 *          Address of a VXDINITPARAMS structure that is filled out
 *          by this function. This is an optional parameter
 *          and can be NULL
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg  |
 *          Address of a DIJOYCONFIG structure that is filled out
 *          by this function. This is an optional parameter.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pdijti | 
 *          Address of a DIJOYTYPEINFO structure that is filled out
 *          by this function. This is an optional parameter.
 *          If passed in, the hws.dwFlags is used to initialize the 
 *          same flags in the DIJOYCONFIG structure.
 *
 *  @returns    HRESULT
 *          Returns a COM error code
 *
 *****************************************************************************/
/*
 *  ISSUE-2001/03/29-timgill function uses too much stack space
 *  This function uses over 4K of stack space! 
 *  This causes the Win9x build to choke looking for _chkstk.
 *  Hack by forcing caller to pass pcfg and pdijti
 */
HRESULT EXTERNAL
    DIWdm_JoyHidMapping
    (
    IN  int             idJoy,
    OUT PVXDINITPARMS   pvip,   OPTIONAL
    OUT LPDIJOYCONFIG   pcfg,   OPTIONAL
    IN OUT LPDIJOYTYPEINFO pdijti 
    )
{
    HRESULT         hres;
    PHIDDEVICEINFO  phdi;
    VXDINITPARMS    vip;
    DWORD           wCaps = 0;
    DIPROPINFO      propi;                            
    DIPROPSTRING    dips;
    DIPROPDWORD     dipd;
    BOOL            fBadCalData = FALSE;

    EnterProc(DIWdm_JoyHidMapping, (_ "uxx", idJoy, pvip, pcfg));

    // AssertF(InCrit());

    if( pvip == NULL )
    {
        ZeroX(vip);
        vip.dwSize = cbX(vip);
        pvip = &vip;
    }

    AssertF(pdijti != NULL );

    /*
     *  Copy the type info because JOY_HWS_ISYOKE, JOY_HWS_ISCARCTRL and 
     *  JOY_HWS_ISHEADTRACKER have no simple equivalents in HID so would 
     *  otherwise get lost.  No harm done if it's zero.
     *  Note, the dwFlags is built in pvip then copied elsewhere.
     */
    pvip->dwFlags = pdijti->hws.dwFlags;

    phdi = phdiFindJoyId(idJoy);
    if( phdi != NULL )
    {
        IDirectInputDeviceCallback *pdcb;

        hres = CHid_New(0, &phdi->guid,
                        &IID_IDirectInputDeviceCallback,
                        (PPV)&pdcb);
        if( SUCCEEDED(hres) )
        {
            DIDEVCAPS dc;

            hres = pdcb->lpVtbl->GetCapabilities(pdcb, &dc );
            if( SUCCEEDED(hres) )
            {
                DIDEVICEINSTANCEW didi;

                didi.dwSize = cbX(didi);

                hres = pdcb->lpVtbl->GetDeviceInfo(pdcb, &didi);
                if( SUCCEEDED(hres) )
                {
                    LPDIDATAFORMAT pdf;

                    hres = pdcb->lpVtbl->GetDataFormat(pdcb, &pdf);
                    if( SUCCEEDED(hres) )
                    {
                        DIPROPCAL dipc;
                        DWORD axis, pov = 0;

                        ZeroBuf(pvip->Usages, 6 * cbX(pvip->Usages[0]));

                        hres = pdcb->lpVtbl->MapUsage(pdcb, CheckHatswitch->dwUsage, &propi.iobj);
                        if(SUCCEEDED(hres) )
                        {
                            pvip->dwPOV1usage      = CheckHatswitch->dwUsage;
                            pvip->dwFlags         |= CheckHatswitch->dwFlags;
                            wCaps                 |= CheckHatswitch->dwCaps;

                            propi.pguid = DIPROP_GRANULARITY;
                            propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                            hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipd.diph);
                            if( SUCCEEDED( hres ) )
                            {
                                if( dipd.dwData >= 9000 ) // 4 directional POV
                                {
                                    wCaps |= JOYCAPS_POV4DIR;
                                    
                                    if( pcfg != NULL ) {
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_FORWARD]   = JOY_POVFORWARD;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_BACKWARD]  = JOY_POVBACKWARD;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_LEFT]      = JOY_POVLEFT;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_RIGHT]     = JOY_POVRIGHT;
                                    }
                                } else // Continuous POV
                                {
                                    wCaps |= JOYCAPS_POVCTS;
                                }
                            }
                        } 

                        for( axis = 0; axis < cA(AxesUsages)-1; axis++ ) 
                        {
                            USAGES *pUse = &AxesUsages[axis];
                            DWORD   dwCurAxisPos = pUse->dwAxisPos;

                            if( pvip->Usages[dwCurAxisPos] != 0) {
                                continue;
                            } else {
                            	int i;
                            	BOOL bHasUsed = FALSE;
                            	
                            	for( i = 0; i < (int)dwCurAxisPos; i++ ) {
                                    if( pvip->Usages[i] == pUse->dwUsage ) {
                                        bHasUsed = TRUE;
                                        break;
                                    }
                                }
                                
                                if( bHasUsed ) {
                                    continue;
                                }
                            }
                            
                            hres = pdcb->lpVtbl->MapUsage(pdcb, pUse->dwUsage, &propi.iobj);
                            if(SUCCEEDED(hres) )
                            {
                                pvip->Usages[dwCurAxisPos] = pUse->dwUsage;
                                pvip->dwFlags     |= pUse->dwFlags;
                                wCaps             |= pUse->dwCaps;

                                propi.pguid = DIPROP_CALIBRATION;
                                propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipc.diph);
                                if( SUCCEEDED(hres) && pcfg != NULL )
                                {

#ifdef WINNT
                                    (&pcfg->hwc.hwv.jrvHardware.jpMin.dwX)[dwCurAxisPos] 
                                        = dipc.lMin;
                                    (&pcfg->hwc.hwv.jrvHardware.jpMax.dwX)[dwCurAxisPos] 
                                        = dipc.lMax;
                                    (&pcfg->hwc.hwv.jrvHardware.jpCenter.dwX)[dwCurAxisPos] 
                                        = CCal_Midpoint(dipc.lMin, dipc.lMax);
#else
                                    DIPROPRANGE diprp;
                                    DIPROPRANGE diprl;
                                    
                                    propi.pguid = DIPROP_PHYSICALRANGE;
                                    propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                    hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &diprp.diph);
                                    if( SUCCEEDED( hres ) )
                                    {
                                        propi.pguid = DIPROP_LOGICALRANGE;
                                        propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                        hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &diprl.diph);
                                        if( SUCCEEDED( hres ) )
                                        {
                                            LONG lMin, lMax;

                                            lMin = (&pcfg->hwc.hwv.jrvHardware.jpMin.dwX)[dwCurAxisPos] 
                                                = CHid_CoordinateTransform( (PLMINMAX)&diprp.lMin, (PLMINMAX)&diprl.lMin, dipc.lMin );
                                            lMax = (&pcfg->hwc.hwv.jrvHardware.jpMax.dwX)[dwCurAxisPos] 
                                                = CHid_CoordinateTransform( (PLMINMAX)&diprp.lMin, (PLMINMAX)&diprl.lMin, dipc.lMax );
                                            (&pcfg->hwc.hwv.jrvHardware.jpCenter.dwX)[dwCurAxisPos] 
                                                = CCal_Midpoint(lMin, lMax);

                                            if( lMin >= lMax ) {
                                                fBadCalData = TRUE;
                                                break;
                                            }

                                        }

                                    }
#endif

                                }
                            }
                        } //for (axis=0...
                    }  //GetDataFormat

                    pvip->hres                  =   S_OK;
                    pvip->dwSize                =   cbX(*pvip);          /* Which version of VJOYD are we? */
                    pvip->dwFlags              |=   JOY_HWS_AUTOLOAD;    /* Describes the device */

                    if(didi.wUsage ==  HID_USAGE_GENERIC_GAMEPAD )
                        pvip->dwFlags |= JOY_HWS_ISGAMEPAD  ;

                    pvip->dwId                  =   idJoy;               /* Internal joystick ID */
                    pvip->dwFirmwareRevision    =   dc.dwFirmwareRevision;
                    pvip->dwHardwareRevision    =   dc.dwHardwareRevision;
                    pvip->dwFFDriverVersion     =   dc.dwFFDriverVersion;
                    pvip->dwFilenameLengths     =   lstrlen(phdi->pdidd->DevicePath);
                    pvip->pFilenameBuffer       =   phdi->pdidd->DevicePath;

                    //pvip->Usages[6];
                    //pvip->dwPOV1usage =   0x0;
                    pvip->dwPOV2usage =   0x0;
                    pvip->dwPOV3usage =   0x0;

                    /* Fill all fields of cfg */

                    if( pcfg != NULL ) {
                        AssertF( pcfg->dwSize == sizeof(DIJOYCONFIG_DX5) 
                              || pcfg->dwSize == sizeof(DIJOYCONFIG_DX6) );
                        pcfg->guidInstance            =   phdi->guid;
                        pcfg->hwc.hws.dwNumButtons    =   dc.dwButtons;
                        pcfg->hwc.hws.dwFlags         =   pvip->dwFlags;
    
                        //pcfg.hwc.hwv.jrvHardware
                        //pcfg.hwc.hwv.dwPOVValues
    
                        pcfg->hwc.hwv.dwCalFlags      =   0x0;
    
                        if( ( LOWORD(phdi->guidProduct.Data1) == MSFT_SYSTEM_VID )
                          &&( ( HIWORD(phdi->guidProduct.Data1) >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN) 
                            &&( HIWORD(phdi->guidProduct.Data1) < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                        {
                            pcfg->hwc.dwType          =    HIWORD(phdi->guidProduct.Data1) - MSFT_SYSTEM_PID;
                            pcfg->hwc.dwUsageSettings =    JOY_US_PRESENT | JOY_US_VOLATILE;
                        }
                        else
                        {
                            /*
                             *  This value really does not matter much but ideally 
                             *  should be greater than or equal to JOY_HW_PREDEFMAX
                             *  Add idJoy for best compatiblity with the old CPLs.
                             */
                            pcfg->hwc.dwType          =    idJoy + JOY_HW_PREDEFMAX;
                            pcfg->hwc.dwUsageSettings =    JOY_US_PRESENT | JOY_US_VOLATILE | JOY_US_ISOEM;
                        }
                        
                        if(pcfg && pvip->Usages[ecRz]) {
                            pcfg->hwc.dwUsageSettings |= JOY_US_HASRUDDER;
                        }
    
                        pcfg->hwc.dwReserved          =    0x0;
    
                        /*
                         *  Default gain to nominal max so it does not get written
                         *  to the registry unless it has some other value.
                         */
                        pcfg->dwGain                  =    DI_FFNOMINALMAX;
    
                        propi.pguid     = DIPROP_FFGAIN;
                        propi.dwDevType = DIPH_DEVICE;
                        propi.iobj      = 0xFFFFFFFF;
                        hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipd.diph);
                        if( SUCCEEDED(hres) )
                        {
                            pcfg->dwGain  =  dipd.dwData;
                        } else
                        {
                            // Failure to get gain is not crutial
                            hres = S_OK;     
                        }
    
    
                        if( pcfg->hwc.dwType >= JOY_HW_PREDEFMAX )
                        {
        #ifndef UNICODE
                            char szType[20];
        #endif
                            /*
                             * This should work, but it doesn't in Win98, bug!
                             *
                             *  wsprintfW(pcfg->wszType, L"VID_%04X&PID_%04X",
                             *    LOWORD(didi.guidProduct.Data1), HIWORD(didi.guidProduct.Data1));
                             */
        
        #ifdef UNICODE
                            wsprintf(pcfg->wszType, VID_PID_TEMPLATE,
                                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
        #else
                            wsprintf(szType, VID_PID_TEMPLATE,
                                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
                            AToU(pcfg->wszType, cA(pcfg->wszType), szType);
        #endif
                        }
                        else
                        {
                            /*
                             *  Predefined types do not have type strings for the 
                             *  uses the callers of this function need.
                             */
                            ZeroX(pcfg->wszType);
                        }
    
                        if( fWinnt ) {
                            // No callout on NT
                            ZeroX(pcfg->wszCallout);
                        } else {
                            lstrcpyW( pcfg->wszCallout, L"joyhid.vxd" );
                        }
                    } // end of filling pcfg's fields
    
    
                    pdijti->dwSize            = cbX(*pdijti);
                    pdijti->hws.dwNumButtons  = dc.dwButtons;
                    pdijti->hws.dwFlags       = pvip->dwFlags;
                    ZeroX(pdijti->clsidConfig);


                    propi.pguid     = DIPROP_INSTANCENAME;
                    propi.dwDevType = DIPH_DEVICE;
                    propi.iobj      = 0xFFFFFFFF;
                    hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph);

                    if( hres != S_OK && lstrlenW(pdijti->wszDisplayName) != 0x0 )
                    {
                        // Failure to get friendly name
                        // We will try and use the OEM name from the registry
                        lstrcpyW(dips.wsz, pdijti->wszDisplayName);                     
                        //pdcb->lpVtbl->SetProperty(pdcb, &propi, &dips.diph);

                    }else if( SUCCEEDED(hres) )
                    {
                        // Use friendly name in the registry 
                        lstrcpyW(pdijti->wszDisplayName, dips.wsz);
                        hres = S_OK;
                    }
                } // GetDeviceInfo FAILED
            } // GetCapabilities FAILED

            Invoke_Release(&pdcb);
        }
    } else // No HID device for JoyID
    {
        hres = E_FAIL;
    }

    if( fBadCalData ) {
        hres = E_FAIL;
    }

    ExitProcX(hres);
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_JoyIdToDeviceInterface |
 *
 *          Given a joystick ID number, obtain the device interface
 *          corresponding to it.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick ID number, zero-based.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives init parameters from the driver.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          A buffer of size <c MAX_PATH> in which the device interface
 *          path is built.
 *
 *  @returns
 *          A pointer to the part of the <p ptszBuf> buffer that
 *          contains the actual device interface path.
 *
 *****************************************************************************/

LPTSTR EXTERNAL
    JoyReg_JoyIdToDeviceInterface_NT
    (
    IN  UINT idJoy,
    OUT PVXDINITPARMS pvip,
    OUT LPTSTR ptszBuf
    )
{
    HRESULT hres;
    DIJOYCONFIG     cfg;
    DIJOYTYPEINFO   dijti;

    DllEnterCrit();

    ZeroX(cfg);
    ZeroX(dijti);

    cfg.dwSize = cbX(cfg);
    dijti.dwSize = cbX(dijti);

    hres = DIWdm_JoyHidMapping(idJoy, pvip, &cfg, &dijti );

    if( SUCCEEDED(hres ) )
    {
        AssertF( lstrlen(pvip->pFilenameBuffer) < MAX_PATH );
        lstrcpy(ptszBuf, pvip->pFilenameBuffer);
    }

    DllLeaveCrit();

    return ptszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dijoytyp.c ===
/*****************************************************************************
 *
 *  DIJoyTyp.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that pull data out of the joystick type key
 *      (wherever it is).
 *
 *  Contents:
 *
 *      ?
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyType

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CType_OpenIdSubkey |
 *
 *          Given an object ID, attempt to open the subkey that
 *          corresponds to it for reading.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   REGSAM | regsam |
 *
 *          Registry security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the object key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CType_OpenIdSubkey(HKEY hkType, DWORD dwId, REGSAM sam, PHKEY phk)
{
    HRESULT hres;

    EnterProc(CType_OpenIdSubkey, (_ "xx", hkType, dwId));

    *phk = 0;

    if(hkType)
    {
        /*
         *  Worst case is "Actuators\65535" which has length 15.
         */
        TCHAR tsz[32];
        LPCTSTR ptszType;

        if(dwId & DIDFT_AXIS)
        {
            ptszType = TEXT("Axes");
        } else if(dwId & DIDFT_BUTTON)
        {
            ptszType = TEXT("Buttons");
        } else if(dwId & DIDFT_POV)
        {
            ptszType = TEXT("POVs");
        } else if(dwId & DIDFT_NODATA)
        {
            ptszType = TEXT("Actuators");
        } else
        {
            hres = E_NOTIMPL;
            goto done;
        }

        // ISSUE-2001/03/29-timgill Need to scale back for pos vs state
        // MarcAnd -- I believe this means: if you're trying to
        //            look for the X axis, we should use the position
        //            instance, not the velocity one.
        wsprintf(tsz, TEXT("%s\\%u"), ptszType, DIDFT_GETINSTANCE(dwId));

        hres = hresMumbleKeyEx(hkType, tsz, sam, REG_OPTION_NON_VOLATILE, phk);

    } else
    {
        hres = DIERR_NOTFOUND;
    }
    done:;

    if(hres == DIERR_NOTFOUND)
    {
        ExitBenignOleProcPpv(phk);
    } else
    {
        ExitOleProcPpv(phk);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_RegGetObjectInfo |
 *
 *          Given an object ID, look into the registry subkey for the
 *          object and extract anything we can find.
 *
 *          If we find nothing, then do nothing.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   LPDIDEVICEOBJECTINSTANCEW | pdidoiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          <e DIDEVICEOBJECTINSTANCE.dwFlags>
 *          fields have already been filled in so we should only not override
 *          these with default data.
 *
 *****************************************************************************/

void EXTERNAL
    CType_RegGetObjectInfo(HKEY hkType, DWORD dwId,
                           LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    HKEY hk;
    EnterProc(CType_RegKeyObjectInfo, (_ "xx", hkType, dwId));

    /*
     *  Extract information about this item from the registry.
     */
    hres = CType_OpenIdSubkey(hkType, dwId, KEY_QUERY_VALUE, &hk);

    if(SUCCEEDED(hres))
    {

        DIOBJECTATTRIBUTES attr;

        /*
         *  Read the regular and HID attributes.
         */

        hres = JoyReg_GetValue(hk, TEXT("Attributes"),
                               REG_BINARY, &attr,
                               cbX(attr));

        if(SUCCEEDED(hres))
        {
            /*
             *  Copy the bit fields.
             */
            pdidoiW->dwFlags |= (attr.dwFlags & ~DIDOI_ASPECTMASK);

            /*
             *  Copy the aspect, but don't change
             *  the aspect from "known" to "unknown".  If the
             *  registry doesn't have an aspect, then use the
             *  aspect we got from the caller.
             */
            if((attr.dwFlags & DIDOI_ASPECTMASK) != DIDOI_ASPECTUNKNOWN)
            {
                pdidoiW->dwFlags = (pdidoiW->dwFlags & ~DIDOI_ASPECTMASK) |
                                   (attr.dwFlags & DIDOI_ASPECTMASK);
            }
        }

        /*
         *  If the caller wants force feedback info,
         *  then get it.
         */
        if(pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W))
        {
            /*
             *  Only copy the usages if they are valid.
             *  JoyReg_GetValue zeros any buffer beyond what is read.
             */
            if(SUCCEEDED(hres) && attr.wUsagePage && attr.wUsage )
            {
                pdidoiW->wUsagePage = attr.wUsagePage;
                pdidoiW->wUsage = attr.wUsage;
            }

            /*
             *  Assert that we can read the DIFFOBJECTATTRIBUTES
             *  directly into the DIDEVICEOBJECTINSTANCE_DX5.
             */
            CAssertF(FIELD_OFFSET(DIFFOBJECTATTRIBUTES,
                                  dwFFMaxForce) == 0);
            CAssertF(FIELD_OFFSET(DIFFOBJECTATTRIBUTES,
                                  dwFFForceResolution) == 4);
            CAssertF(FIELD_OFFSET(DIDEVICEOBJECTINSTANCE_DX5,
                                  dwFFMaxForce) + 4 ==
                     FIELD_OFFSET(DIDEVICEOBJECTINSTANCE_DX5,
                                  dwFFForceResolution));
            CAssertF(cbX(DIFFOBJECTATTRIBUTES) == 8);

            /*
             *  If this doesn't work, gee that's too bad.
             *  JoyReg_GetValue will zero-fill the error parts.
             */
            hres = JoyReg_GetValue(hk, TEXT("FFAttributes"),
                                   REG_BINARY, &pdidoiW->dwFFMaxForce,
                                   cbX(DIFFOBJECTATTRIBUTES));
        }

        /*
         *  Read the optional custom name.
         *
         *  Note that JoyReg_GetValue(REG_SZ) uses
         *  RegQueryStringValueW, which sets the
         *  string to null on error so we don't have to.
         */
        hres = JoyReg_GetValue(hk, 0, REG_SZ,
                               pdidoiW->tszName, cbX(pdidoiW->tszName));

        if(SUCCEEDED(hres))
        {
        } else
        {
            AssertF(pdidoiW->tszName[0] == L'\0');
        }

        RegCloseKey(hk);
    } else
    {
        AssertF(pdidoiW->tszName[0] == L'\0');
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_RegGetTypeInfo |
 *
 *          Given an object ID, look into the registry subkey for the
 *          object and extract attribute bits that should be OR'd
 *          into the object ID.
 *
 *          This needs to be done during device initialization to
 *          establish the attributes in the data format so that
 *
 *          1.  <mf IDirectInputDevice::EnumObjects> filters properly, and
 *
 *          2.  >mf IDirectInputEffect::SetParameters> can validate properly.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   LPDIOBJECTDATAFORMAT | podf |
 *
 *          Structure to receive more information.  The
 *          <e DIOBJECTDATAFORMAT.dwType> field identifies the object.
 *
 *          On return the
 *          <e DIOBJECTDATAFORMAT.dwType>
 *          and
 *          <e DIOBJECTDATAFORMAT.dwFlags>
 *          fields are updated.
 *
 *****************************************************************************/

void EXTERNAL
    CType_RegGetTypeInfo(HKEY hkType, LPDIOBJECTDATAFORMAT podf, BOOL fPidDevice)
{
    HRESULT hres;
    HKEY hk;
    EnterProc(CType_RegKeyObjectInfo, (_ "xx", hkType, podf->dwType));

    hres = CType_OpenIdSubkey(hkType, podf->dwType, KEY_QUERY_VALUE, &hk);

    if(SUCCEEDED(hres))
    {
        DWORD dwFlags;

        CAssertF(FIELD_OFFSET(DIOBJECTATTRIBUTES, dwFlags) == 0);

        hres = JoyReg_GetValue(hk, TEXT("Attributes"),
                               REG_BINARY, &dwFlags, cbX(dwFlags));

        if(SUCCEEDED(hres))
        {
            /*
             *  Propagate the attributes into the type code.
             */
            CAssertF(DIDOI_FFACTUATOR == DIDFT_GETATTR(DIDFT_FFACTUATOR));
            CAssertF(DIDOI_FFEFFECTTRIGGER
                     == DIDFT_GETATTR(DIDFT_FFEFFECTTRIGGER));

            podf->dwType |= DIDFT_MAKEATTR(dwFlags);

            podf->dwFlags |= (dwFlags & ~DIDOI_ASPECTMASK);

            /*
             *  Copy the aspect, but don't change
             *  the aspect from "known" to "unknown".  If the
             *  registry doesn't have an aspect, then use the
             *  aspect we got from the caller.
             */
            if((dwFlags & DIDOI_ASPECTMASK) != DIDOI_ASPECTUNKNOWN)
            {
                podf->dwFlags = (podf->dwFlags & ~DIDOI_ASPECTMASK) |
                                (dwFlags & DIDOI_ASPECTMASK);
            }
        }

        RegCloseKey(hk);
    }else
    {
#ifndef WINNT
        // Post Dx7Gold Patch
        // This is for Win9x only.
        // On Win9x, a device that is being accessed through the vjoyd path
        // will not get forces, as the attributes necessary for FF have not
        // been appropriately marked.

        // THe following code will mark the

        DWORD dwFlags  = DIDFT_GETATTR( podf->dwType & ~DIDFT_ATTRMASK )
                        | ( podf->dwFlags & ~DIDOI_ASPECTMASK);

        if(   dwFlags != 0x0
           && fPidDevice )
        {
            hres = CType_OpenIdSubkey(hkType, podf->dwType, DI_KEY_ALL_ACCESS, &hk);

            if(SUCCEEDED(hres) )
            {

                hres = JoyReg_SetValue(hk, TEXT("Attributes"),
                                   REG_BINARY, &dwFlags, cbX(dwFlags));

                RegCloseKey(hk);
            }
         }
#endif // ! WINNT
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_MakeGameCtrlName |
 *
 *          Make a game controller name from the attributes of the controller.
 *          Used as a last resort when a name is needed but none is available.
 *
 *  @parm   PWCHAR | wszName |
 *
 *          Output buffer where name will be generated.
 *
 *  @parm   DWORD | dwType |
 *
 *          DI8DEVTYPE value for the controller.
 *
 *  @parm   DWORD | dwAxes |
 *
 *          The number of axes the device has.
 *
 *  @parm   DWORD | dwButtons |
 *
 *          The numer of buttons the device has.
 *
 *  @parm   DWORD | dwPOVs |
 *
 *          The number of POVs the device has.
 *
 *****************************************************************************/

void EXTERNAL
CType_MakeGameCtrlName
( 
    PWCHAR  wszOutput, 
    DWORD   dwDevType,
    DWORD   dwAxes,
    DWORD   dwButtons,
    DWORD   dwPOVs
)
{
    TCHAR tsz[64];
    TCHAR tszPOV[64];
    TCHAR tszFormat[64];
#ifndef UNICODE
    TCHAR tszOut[cA(tsz)+cA(tszFormat)+cA(tszPOV)];
#endif

    /* tszFormat = %d axis, %d button %s */
    LoadString(g_hinst, IDS_TEXT_TEMPLATE, tszFormat, cA(tszFormat));

    /* tsz = joystick, gamepad, etc. */

    if( GET_DIDEVICE_TYPE( dwDevType ) != DIDEVTYPE_JOYSTICK )
    {
        LoadString(g_hinst, IDS_DEVICE_NAME, tsz, cA(tsz));
    }
    else 
    {
        LoadString(g_hinst, 
            GET_DIDEVICE_SUBTYPE( dwDevType ) + IDS_PLAIN_STICK - DIDEVTYPEJOYSTICK_UNKNOWN,
            tsz, cA(tsz));
    }

    if( dwPOVs )
    {
        LoadString(g_hinst, IDS_WITH_POV, tszPOV, cA(tszPOV));
    }
    else
    {
        tszPOV[0] = TEXT( '\0' );
    }

#ifdef UNICODE
    wsprintfW(wszOutput, tszFormat, dwAxes, dwButtons, tsz, tszPOV);
#else
    wsprintfA(tszOut, tszFormat, dwAxes, dwButtons, tsz, tszPOV);
    TToU(wszOutput, cA(tszOut), tszOut);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dilib2.c ===
/*****************************************************************************
 *
 *  DILib1.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIKeyboard
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIKbd[] |
 *
 *          Device object data formats for keyboard-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDATAFORMAT | c_dfDIKeyboard |
 *
 *          A predefined <t DIDATAFORMAT> structure which describes a
 *          keyboard device.  This object is provided in the
 *          DINPUT.LIB library file as a convenience.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a keyboard.
 *
 *          When a device has been set to the keyboard data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          behaves in the same way as the Windows <f GetKeyboardState>
 *          function:  The device state is stored in an array of
 *          256 bytes, with each byte corresponding to the state
 *          of a key.  For example, if high bit of the <c DIK_ENTER>'th
 *          byte is set, then the Enter key is being held down.
 *
 *          When a device has been set to the keyboard data format,
 *          the <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIK_*> value which describes the
 *          key which was pressed or released.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEODF(b)                                                      \
    { &GUID_Key, b,                                                     \
      DIDFT_BUTTON | DIDFT_MAKEINSTANCE(b) | 0x80000000, }              \

#define MAKEODF16(b) \
    MAKEODF(b+0x00), \
    MAKEODF(b+0x01), \
    MAKEODF(b+0x02), \
    MAKEODF(b+0x03), \
    MAKEODF(b+0x04), \
    MAKEODF(b+0x05), \
    MAKEODF(b+0x06), \
    MAKEODF(b+0x07), \
    MAKEODF(b+0x08), \
    MAKEODF(b+0x09), \
    MAKEODF(b+0x0A), \
    MAKEODF(b+0x0B), \
    MAKEODF(b+0x0C), \
    MAKEODF(b+0x0D), \
    MAKEODF(b+0x0E), \
    MAKEODF(b+0x0F)  \

static DIOBJECTDATAFORMAT c_rgodfDIKeyboard[] = {
    MAKEODF16(0x00),
    MAKEODF16(0x10),
    MAKEODF16(0x20),
    MAKEODF16(0x30),
    MAKEODF16(0x40),
    MAKEODF16(0x50),
    MAKEODF16(0x60),
    MAKEODF16(0x70),
    MAKEODF16(0x80),
    MAKEODF16(0x90),
    MAKEODF16(0xA0),
    MAKEODF16(0xB0),
    MAKEODF16(0xC0),
    MAKEODF16(0xD0),
    MAKEODF16(0xE0),
    MAKEODF16(0xF0),
};


const DIDATAFORMAT c_dfDIKeyboard = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    256,
    cA(c_rgodfDIKeyboard),
    c_rgodfDIKeyboard,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dilib1.c ===
/*****************************************************************************
 *
 *  DILib1.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIMouse
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIMouse[] |
 *
 *          Device object data formats for mouse-style access.
 *
 *  @global DIDEVICEFORMAT | c_dfDIMouse |
 *
 *          Device format for mouse-style access.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a mouse.
 *
 *          When a device has been set to the mouse data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIMOUSESTATE> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIMOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

static DIOBJECTDATAFORMAT c_rgodfDIMouse[] = {
    { &GUID_XAxis, FIELD_OFFSET(DIMOUSESTATE,        lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_YAxis, FIELD_OFFSET(DIMOUSESTATE,        lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_ZAxis, FIELD_OFFSET(DIMOUSESTATE,        lZ),       DIDFT_AXIS | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[0]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[1]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[2]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[3]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
};

const DIDATAFORMAT c_dfDIMouse = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    sizeof(DIMOUSESTATE),
    cA(c_rgodfDIMouse),
    c_rgodfDIMouse,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dilist.c ===
/*****************************************************************************
 *
 *  DIList.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      List management.  Really, array management, since our lists
 *      never get very big.
 *
 *      We call them "GPA"s, which stands for "Growable Pointer Array".
 *
 *      There is a more general GXA gizmo in Dr Watson, but we don't
 *      need it yet.  So far, all we need to track is unsorted
 *      lists of pointers.
 *
 *      Yes, there exists a matching concept in COMCTL32, but we can't
 *      use it because
 *
 *      (1) it's not documented,
 *      (2) COMCTL32 puts them into shared memory, which is just
 *          begging for a memory leak.
 *
 *  Contents:
 *
 *      GPA_Init
 *      GPA_Term
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflGpa



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Print |
 *
 *          Print state of the growing pointer array.
 *
 *  @parm   HGPA | hgpa |
 *
 *  @returns    void
 *
 *****************************************************************************/
void INTERNAL
GPA_Print(HGPA hgpa)
{
    int ipv;
    for (ipv = 0; ipv < hgpa->cpv; ipv++)
    {
		// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV( sqflError,
                        TEXT("ipv=%d,hgpa->rgpv[ipv]=%p"),
                        ipv, hgpa->rgpv[ipv]);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Append |
 *
 *          Add a new item to the growing pointer array.
 *
 *          Note that we add 8 after doubling, so that we don't get
 *          stuck if cxAlloc is zero.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to add.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_Append(HGPA hgpa, PV pv)
{
    HRESULT hres;

    if (hgpa->cpv >= hgpa->cpvAlloc) {
        hres = ReallocCbPpv(cbX(PV) * (hgpa->cpvAlloc * 2 + 8),
                            &hgpa->rgpv);
        // Prefix: Whistler 45077.   
        if (FAILED(hres) || ( hgpa->rgpv == NULL) ) {
            goto done;
        }

        hgpa->cpvAlloc = hgpa->cpvAlloc * 2 + 8;
    }

    //hgpa->rgpv[hgpa->cpv++] = pv;
    hgpa->rgpv[hgpa->cpv] = pv;
    InterlockedIncrement(&hgpa->cpv);

    hres = S_OK;


done:;
    //GPA_Print(hgpa);
    return hres;

}

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GPA_FindPtr |
 *
 *          Determine whether a pointer is in the GPA.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to locate.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

BOOL EXTERNAL
GPA_FindPtr(HGPA hgpa, PV pv)
{
    BOOL fRc;
    int ipv;

    for (ipv = 0; ipv < hgpa->cpv; ipv++) {
        if (hgpa->rgpv[ipv] == pv) {
            fRc = TRUE;
            goto done;
        }
    }

    fRc = FALSE;

done:;
    return fRc;

}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_DeletePtr |
 *
 *          Remove the indicated pointer from the GPA.  The order of
 *          the remaining items is unspecified.
 *
 *          Note that CEm_LL_ThreadProc assumes that no items before
 *          the deleted item are affected by the deletion.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to delete.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_DeletePtr(HGPA hgpa, PV pv)
{
    HRESULT hres;
    int ipv;

    for (ipv = 0; ipv < hgpa->cpv; ipv++) {
        if (hgpa->rgpv[ipv] == pv) {
            //hgpa->rgpv[ipv] = hgpa->rgpv[--hgpa->cpv];
            InterlockedDecrement(&hgpa->cpv);
            hgpa->rgpv[ipv] = hgpa->rgpv[hgpa->cpv];
            hres = hgpa->cpv;
            goto done;
        }
    }

    hres = E_FAIL;

done:;
    //GPA_Print(hgpa);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Clone |
 *
 *          Copy the contents of one GPA to another.
 *
 *  @parm   HGPA | hgpaDst |
 *
 *          Handle to destination pointer array.
 *
 *  @parm   HGPA | hgpaSrc |
 *
 *          Handle to source pointer array.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_Clone(HGPA hgpaDst, HGPA hgpaSrc)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCxX(hgpaSrc->cpv, PV), &hgpaDst->rgpv);

    if (SUCCEEDED(hres)) {
        CopyMemory(hgpaDst->rgpv, hgpaSrc->rgpv, cbCxX(hgpaSrc->cpv, PV));
        hgpaDst->cpv = hgpaSrc->cpv;
        hgpaDst->cpvAlloc = hgpaSrc->cpvAlloc;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GPA_Init |
 *
 *          Initialize a GPA structure with no elements.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *****************************************************************************/

void EXTERNAL
GPA_Init(HGPA hgpa)
{
    hgpa->rgpv = 0;
    hgpa->cpv = 0;
    hgpa->cpvAlloc = 0;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GPA_Term |
 *
 *          Clean up an existing GPA.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *****************************************************************************/

void EXTERNAL
GPA_Term(HGPA hgpa)
{
    FreePpv(&hgpa->rgpv);
    GPA_Init(hgpa);
}



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dilib3.c ===
/*****************************************************************************
 *
 *  DILib3.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIJoystick
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIJoy[] |
 *
 *          Device object data formats for joystick-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDEVICEFORMAT | c_dfDIJoystick |
 *
 *          Predefined device format for joystick-style access.
 *
 *          When a device has been set to the joystick data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIJOYSTATE> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIJOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEVAL(guid, f, type, aspect)                                  \
    { &GUID_##guid,                                                     \
      FIELD_OFFSET(DIJOYSTATE, f),                                      \
      DIDFT_##type | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECT##aspect,                                             \
    }                                                                   \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(DIJOYSTATE, rgbButtons[n]),                          \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECTUNKNOWN,                                              \
    }                                                                   \

static DIOBJECTDATAFORMAT c_rgodfDIJoy[] = {
    MAKEVAL( XAxis,  lX,         AXIS, POSITION),
    MAKEVAL( YAxis,  lY,         AXIS, POSITION),
    MAKEVAL( ZAxis,  lZ,         AXIS, POSITION),
    MAKEVAL(RxAxis,  lRx,        AXIS, POSITION),
    MAKEVAL(RyAxis,  lRy,        AXIS, POSITION),
    MAKEVAL(RzAxis,  lRz,        AXIS, POSITION),
    MAKEVAL(Slider,rglSlider[0], AXIS, POSITION),
    MAKEVAL(Slider,rglSlider[1], AXIS, POSITION),
    MAKEVAL(POV,     rgdwPOV[0], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[1], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[2], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[3], POV,  UNKNOWN),
    MAKEBTN( 0),
    MAKEBTN( 1),
    MAKEBTN( 2),
    MAKEBTN( 3),
    MAKEBTN( 4),
    MAKEBTN( 5),
    MAKEBTN( 6),
    MAKEBTN( 7),
    MAKEBTN( 8),
    MAKEBTN( 9),
    MAKEBTN(10),
    MAKEBTN(11),
    MAKEBTN(12),
    MAKEBTN(13),
    MAKEBTN(14),
    MAKEBTN(15),
    MAKEBTN(16),
    MAKEBTN(17),
    MAKEBTN(18),
    MAKEBTN(19),
    MAKEBTN(20),
    MAKEBTN(21),
    MAKEBTN(22),
    MAKEBTN(23),
    MAKEBTN(24),
    MAKEBTN(25),
    MAKEBTN(26),
    MAKEBTN(27),
    MAKEBTN(28),
    MAKEBTN(29),
    MAKEBTN(30),
    MAKEBTN(31),
};

const DIDATAFORMAT c_dfDIJoystick = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(DIJOYSTATE),
    cA(c_rgodfDIJoy),
    c_rgodfDIJoy,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dimem.c ===
/*****************************************************************************
 *
 *  DIMem.c
 *
 *  Copyright (c) 1996 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Memory management
 *
 *  Contents:
 *
 *      ReallocCbPpv
 *      AllocCbPpv
 *      FreePpv
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef NEED_REALLOC

/*****************************************************************************
 *
 *      ReallocCbPpv
 *
 *      Change the size of some zero-initialized memory.
 *
 *      This is the single place where all memory is allocated, resized,
 *      and freed.
 *
 *      If you realloc from a null pointer, memory is allocated.
 *      If you realloc to zero-size, memory is freed.
 *
 *      These semantics avoid boundary cases.  For example, it is no
 *      longer a problem trying to realloc something down to zero.
 *      You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *      If an error is returned, the original pointer is UNCHANGED.
 *      This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
ReallocCbPpv(UINT cb, PV ppvArg)
{
    HRESULT hres;
    PPV ppv = ppvArg;
    HLOCAL hloc = *ppv;
    if (cb) {                       /* Alloc or realloc */
        if (hloc) {                 /* Realloc */
            hloc = LocalReAlloc(*ppv, cb,
                                LMEM_MOVEABLE+LMEM_ZEROINIT);
        } else {                /* Alloc */
            hloc = LocalAlloc(LPTR, cb);
        }
        hres = hloc ? NOERROR : E_OUTOFMEMORY;
    } else {                    /* Freeing */
        if (hloc) {
            LocalFree(hloc);
            hloc = 0;
            hres = NOERROR;     /* All gone */
        } else {
            hres = NOERROR;     /* Nothing to free */
        }
    }

    if (SUCCEEDED(hres)) {
        *ppv = hloc;
    }
    return hres;
}

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}

#else

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

/*****************************************************************************
 *
 *      FreePpv
 *
 *      Free memory from the ppv.
 *
 *****************************************************************************/

void EXTERNAL
FreePpv(PV ppv)
{
#ifdef _M_IA64
    PV pv = (PV)InterlockedExchange64(ppv, 0);
#else
    PV pv = (PV)InterlockedExchange(ppv, 0);
#endif
    if (pv) {
        FreePv(pv);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dilib4.c ===
/*****************************************************************************
 *
 *  DILib4.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIJoystick2
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIJoy2[] |
 *
 *          Device object data formats for joystick-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDEVICEFORMAT | c_dfDIJoystick2 |
 *
 *          Predefined device format for extended joystick-style access.
 *
 *          When a device has been set to the joystick data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIJOYSTATE2> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIJOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEVAL(guid, f, type, aspect)                                  \
    { &GUID_##guid,                                                     \
      FIELD_OFFSET(DIJOYSTATE2, f),                                     \
      DIDFT_##type | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECT##aspect,                                             \
    }                                                                   \

#define MAKEVALS(l, aspect)                                             \
    MAKEVAL( XAxis,l##X,           AXIS, aspect),                       \
    MAKEVAL( YAxis,l##Y,           AXIS, aspect),                       \
    MAKEVAL( ZAxis,l##Z,           AXIS, aspect),                       \
    MAKEVAL(RxAxis,l##Rx,          AXIS, aspect),                       \
    MAKEVAL(RyAxis,l##Ry,          AXIS, aspect),                       \
    MAKEVAL(RzAxis,l##Rz,          AXIS, aspect),                       \
    MAKEVAL(Slider,rgl##Slider[0], AXIS, aspect),                       \
    MAKEVAL(Slider,rgl##Slider[1], AXIS, aspect)                        \

#define MAKEPOV(n)                                                      \
    MAKEVAL(POV,     rgdwPOV[n], POV,  UNKNOWN)                         \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(DIJOYSTATE2, rgbButtons[n]),                         \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECTUNKNOWN,                                              \
    }                                                                   \

#define MAKEBTNS(n)                                                     \
    MAKEBTN(n + 0x00),                                                  \
    MAKEBTN(n + 0x01),                                                  \
    MAKEBTN(n + 0x02),                                                  \
    MAKEBTN(n + 0x03),                                                  \
    MAKEBTN(n + 0x04),                                                  \
    MAKEBTN(n + 0x05),                                                  \
    MAKEBTN(n + 0x06),                                                  \
    MAKEBTN(n + 0x07),                                                  \
    MAKEBTN(n + 0x08),                                                  \
    MAKEBTN(n + 0x09),                                                  \
    MAKEBTN(n + 0x0A),                                                  \
    MAKEBTN(n + 0x0B),                                                  \
    MAKEBTN(n + 0x0C),                                                  \
    MAKEBTN(n + 0x0D),                                                  \
    MAKEBTN(n + 0x0E),                                                  \
    MAKEBTN(n + 0x0F)                                                   \

static DIOBJECTDATAFORMAT c_rgodfDIJoy2[] = {
    MAKEVALS(l, POSITION),
    MAKEPOV(0),
    MAKEPOV(1),
    MAKEPOV(2),
    MAKEPOV(3),
    MAKEBTNS(0x00),
    MAKEBTNS(0x10),
    MAKEBTNS(0x20),
    MAKEBTNS(0x30),
    MAKEBTNS(0x40),
    MAKEBTNS(0x50),
    MAKEBTNS(0x60),
    MAKEBTNS(0x70),
    MAKEVALS(lV, VELOCITY),
    MAKEVALS(lA, ACCEL),
    MAKEVALS(lF, FORCE),
};

const DIDATAFORMAT c_dfDIJoystick2 = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(DIJOYSTATE2),
    cA(c_rgodfDIJoy2),
    c_rgodfDIJoy2,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dilib5.c ===
/*****************************************************************************
 *
 *  DILib5.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIMouse2
 *
 *****************************************************************************/

#include "dinputpr.h"


#if DIRECTINPUT_VERSION >= 0x0700
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIMouse2[] |
 *
 *          Device object data formats for mouse-style access.
 *
 *  @global DIDEVICEFORMAT | c_dfDIMouse2 |
 *
 *          Device format for mouse-style access.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a mouse.
 *
 *          When a device has been set to the mouse data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIMOUSESTATE2> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIMOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

static DIOBJECTDATAFORMAT c_rgodfDIMouse2[] = {
    { &GUID_XAxis, FIELD_OFFSET(DIMOUSESTATE2,        lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_YAxis, FIELD_OFFSET(DIMOUSESTATE2,        lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_ZAxis, FIELD_OFFSET(DIMOUSESTATE2,        lZ),       DIDFT_AXIS | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[0]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[1]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[2]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[3]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[4]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[5]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[6]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[7]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
};

const DIDATAFORMAT c_dfDIMouse2 = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    sizeof(DIMOUSESTATE2),
    cA(c_rgodfDIMouse2),
    c_rgodfDIMouse2,
};

#endif

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dinput.c ===
/*****************************************************************************
 *
 *  DInput.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *
 *
 *  Contents:
 *
 *      DirectInputCreateA()
 *      DirectInputCreateW()
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  The DirectInput synchronization hierarchy |
 *
 *  Extreme caution must be exercised to ensure that the synchronization
 *  hierarchy is preserved.  Failure to observe these rules will result
 *  in a deadlock.
 *
 *  @ex
 *
 *  In the following list, locks must be taken in the order specified.
 *  Furthermore, the Dll critical section and the cross-process mutexes
 *  may never be taken simultaneously.  (They should be considered
 *  to be at the bottom of the hierarchy.)
 *
 *  |
 *
 *      DirectInputEffect
 *      DirectInputDevice
 *      Dll critical section
 *      The cross-process global mutex
 *      The cross-process joystick mutex
 *
 ***************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DWORD | g_cRef |
 *
 *          DLL reference count.
 *
 *  @global HINSTANCE | g_hinst |
 *
 *          DLL instance handle.
 *
 *  @global LONG | g_lLoadLibrary |
 *
 *          Number of times we have been artificially <f LoadLibrary>'d
 *          to prevent ourselves from being unloaded by a non-OLE
 *          application.  Actually, it's the number of times minus one,
 *          so we can use the interlocked functions to tell whether
 *          the first <f LoadLibrary> is happening or the last
 *          <f FreeLibrary> is happening.
 *
 *          We perform a physical <f LoadLibrary> or <f FreeLibrary>
 *          only on the transition, so as to avoid overflowing the
 *          counter in KERNEL32.
 *
 *  @global HANDLE | g_hVxD |
 *
 *          Handle to VxD, if available.  Win9x only!
 *
 *  @global OPENVXDHANDLE | OpenVxDHandle |
 *
 *          Address of Win9x-only KERNEL32 entry point to convert
 *          a process handle into a VxD handle.  Win9x only!
 *
 *  @global CRITICAL_SECTION | g_crstDll |
 *
 *          Per-process critical section to protect process-global
 *          variables.
 *
 *  @global DWORD | g_flEmulation |
 *
 *          Flags that describe what levels of forced emulation are
 *          active.
 *
 *  @global HHOOK | g_hhkLLHookCheck |
 *
 *          Used only temporarily to test whether low-level hooks
 *          are supported on the system.
 *
 *  @global HANDLE | g_hmtxGlobal |
 *
 *          System-global mutex that protects shared memory blocks
 *          which describe device exclusive acquisition information.
 *
 *  @global HANDLE | g_hfm |
 *
 *          Handle to the file mapping that describes the shared
 *          memory block.  NT requires us to keep the handle open
 *          so that the associated name remains in the namespace.
 *
 *  @global PSHAREDOBJECTPAGE | g_psop |
 *
 *          Pointer to the shared memory block itself.
 *
 *  @global HANDLE | g_hmtxJoy |
 *
 *          System-global mutex that protects shared memory blocks
 *          which describe joystick effects.
 *
 *  @global UINT | g_wmJoyChanged |
 *
 *          Registered window message which is broadcast when joysticks
 *          are reconfigured.
 *
 *  @global LONG | g_lWheelGranularity |
 *
 *          The wheel granularity.  One hardware "click" of the mouse
 *          wheel results in this much reported motion.
 *
 *****************************************************************************/

DWORD g_cRef;
HINSTANCE g_hinst;
LONG g_lLoadLibrary = -1;
#ifndef WINNT
HANDLE g_hVxD = INVALID_HANDLE_VALUE;
OPENVXDHANDLE _OpenVxDHandle;
#endif
CRITICAL_SECTION g_crstDll;
DWORD g_flEmulation;
LPDWORD g_pdwSequence;

#ifdef USE_SLOW_LL_HOOKS
HHOOK g_hhkLLHookCheck;
#endif

HANDLE g_hmtxGlobal;
HANDLE g_hfm;
struct SHAREDOBJECTPAGE *g_psop;
HANDLE g_hmtxJoy;
UINT g_wmJoyChanged;
HINSTANCE g_hinstRPCRT4;
LONG g_lWheelGranularity;

BOOL fWinnt;        //whether we are running in Winnt
BOOL g_fCritInited;

#ifdef WORKER_THREAD
MSGWAITFORMULTIPLEOBJECTSEX _MsgWaitForMultipleObjectsEx =
                         FakeMsgWaitForMultipleObjectsEx;
#endif

CANCELIO _CancelIO = FakeCancelIO;

#ifdef XDEBUG
TRYENTERCRITICALSECTION _TryEnterCritSec = FakeTryEnterCriticalSection;
int g_cCrit = -1;
UINT g_thidCrit;
HANDLE g_thhandleCrit;
#endif

#ifdef DEBUG
TCHAR g_tszLogFile[MAX_PATH];
#endif

BOOL  g_fRawInput;

#ifdef USE_WM_INPUT
  HWND   g_hwndThread;
  HANDLE g_hEventAcquire;
  HANDLE g_hEventThread;
  HANDLE g_hEventHid;
#endif

#ifdef WINNT
HANDLE g_hEventWinmm;
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.  Failure to
 *          comply is a violation of the semaphore hierarchy and will
 *          lead to deadlocks.
 *
 *****************************************************************************/

void EXTERNAL
DllEnterCrit_(LPCTSTR lptszFile, UINT line)
{

#ifdef XDEBUG
    if( ! _TryEnterCritSec(&g_crstDll) )
    {
        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec blocked @%s,%d"), lptszFile, line);
        EnterCriticalSection(&g_crstDll);
    }

    if (++g_cCrit == 0) {
        g_thidCrit     = GetCurrentThreadId();
        g_thhandleCrit = GetCurrentThread();

        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Entered @%s,%d"), lptszFile, line);
    }
    AssertF(g_thidCrit == GetCurrentThreadId());
#else
    EnterCriticalSection(&g_crstDll);
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | IsThreadActive |
 *
 *          Check if the thread is still active.
 *
 *****************************************************************************/

BOOL IsThreadActive( HANDLE hThread )
{
    DWORD dwExitCode = 0;

    return (NULL != hThread
            && GetExitCodeThread(hThread, &dwExitCode)
            && STILL_ACTIVE == dwExitCode
            );
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
DllLeaveCrit_(LPCTSTR lptszFile, UINT line)
{
#ifdef XDEBUG
    if( IsThreadActive(g_thhandleCrit) ) {
        AssertF(g_thidCrit == GetCurrentThreadId());
    } else {
        SquirtSqflPtszV(sqflCrit, TEXT("Current thread has died."));
    }
    
    AssertF(g_cCrit >= 0);
    if (--g_cCrit < 0) {
        g_thidCrit = 0;
    }
    SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Leaving @%s,%d"), lptszFile, line);
#endif
    LeaveCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllInCrit |
 *
 *          Nonzero if we are in the DLL critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
DllInCrit(void)
{
    return g_cCrit >= 0 && g_thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllAddRef |
 *
 *          Increment the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
    SquirtSqflPtszV(sqfl, TEXT("DllAddRef -> %d"), g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRelease |
 *
 *          Decrement the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
    SquirtSqflPtszV(sqfl, TEXT("DllRelease -> %d"), g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLoadLibrary |
 *
 *          Increment the DLL load count.
 *
 *          This is to prevent a non-OLE application from unloading us
 *          while we still have windows subclassed.
 *
 *****************************************************************************/

void EXTERNAL
DllLoadLibrary(void)
{
    if (InterlockedIncrement(&g_lLoadLibrary) == 0) {
        TCHAR tsz[MAX_PATH - 1];

        /*
         *  See hresValidInstanceVer_ for an explanation of why
         *  we need to pass cA() - 1 instead of cA().
         */
        GetModuleFileName(g_hinst, tsz, cA(tsz) - 1);
        LoadLibrary(tsz);
    }
    SquirtSqflPtszV(sqfl, TEXT("DllLoadLibrary -> %d"), g_lLoadLibrary);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllFreeLibraryAndExitThread |
 *
 *          Worker thread which frees the library in a less dangerous
 *          (I'm loathe to say "safe") manner.
 *
 *          ThreadProcs are prototyped to return a void but since the return
 *          would follow some form of ExitThread, it will never be reached so
 *          this function is declared to return void and cast.
 *
 *  @parm   LPVOID | pvContext |
 *
 *          Unused context information.
 *
 *****************************************************************************/

void INTERNAL
DllFreeLibraryAndExitThread(LPVOID pvContext)
{
    /*
     *  Sleep for one extra second to make extra sure that the
     *  DllFreeLibrary thread is out and gone.
     */
    SleepEx(1000, FALSE);

    FreeLibraryAndExitThread(g_hinst, 0);

    /*NOTREACHED*/
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllFreeLibrary |
 *
 *          Decrement the DLL load count.
 *
 *          This undoes a previous <f DllLoadLibrary>.
 *
 *          We can't blindly do a <f FreeLibrary>, because we might
 *          be freeing our last reference, and then we will die because
 *          we won't exist when the <f FreeLibrary> returns.
 *
 *          If we are in the wacky case, then we spin a low-priority
 *          thread whose job is to free us. We create it at low priority
 *          so it will lose the race with this thread, which is busy
 *          getting out of the way.
 *
 *****************************************************************************/

void EXTERNAL
DllFreeLibrary(void)
{
    if (InterlockedDecrement(&g_lLoadLibrary) < 0) {
        if (g_cRef) {
            /*
             *  There are other references to us, so we can just
             *  go away quietly.
             */
            FreeLibrary(g_hinst);
        } else {
            /*
             *  This is the last reference, so we need to create a
             *  worker thread which will call <f FreeLibraryAndExitThread>.
             */
            DWORD thid;
            HANDLE hth;

            hth = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)DllFreeLibraryAndExitThread,
                               0, CREATE_SUSPENDED, &thid);
            if (hth) {
                SetThreadPriority(hth, THREAD_PRIORITY_IDLE);
                ResumeThread(hth);
                CloseHandle(hth);
            }
        }
    }
    SquirtSqflPtszV(sqfl, TEXT("DllFreeLibrary -> %d"), g_lLoadLibrary);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllGetClassObject |
 *
 *          Create an <i IClassFactory> instance for this DLL.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The object being requested.
 *
 *  @parm   RIID | riid |
 *
 *          The desired interface on the object.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Output pointer.
 *
 *  @comm
 *          The artificial refcount inside <f DllClassObject> helps
 *          to avoid the race condition described in <f DllCanUnloadNow>.
 *          It's not perfect, but it makes the race window smaller.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#ifdef  DEMONSTRATION_FFDRIVER

/*
 *  Build the fake force feedback driver for internal testing.
 */

GUID CLSID_EffectDriver = {
    0x25E609E2,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00
};

#endif

CLSIDMAP c_rgclsidmap[cclsidmap] = {
    {   &CLSID_DirectInput,         CDIObj_New,     IDS_DIRECTINPUT,        },
    {   &CLSID_DirectInputDevice,   CDIDev_New,     IDS_DIRECTINPUTDEVICE,  },
#ifdef  DEMONSTRATION_FFDRIVER
    {   &CLSID_EffectDriver,        CJoyEff_New,    0,                      },
#endif
};

#pragma END_CONST_DATA

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    UINT iclsidmap;
    EnterProcR(DllGetClassObject, (_ "G", rclsid));

    if( g_fCritInited )
    {
        DllAddRef();
        for (iclsidmap = 0; iclsidmap < cA(c_rgclsidmap); iclsidmap++) {
            if (IsEqualIID(rclsid, c_rgclsidmap[iclsidmap].rclsid)) {
                hres = CDIFactory_New(c_rgclsidmap[iclsidmap].pfnCreate,
                                      riid, ppvObj);
                goto done;
            }
        }
        SquirtSqflPtszV(sqfl | sqflError, TEXT("%S: Wrong CLSID"), s_szProc);
        *ppvObj = 0;
        hres = CLASS_E_CLASSNOTAVAILABLE;

    done:;

        ExitOleProcPpv(ppvObj);
        DllRelease();
    }
    else
    {
        hres = E_OUTOFMEMORY;
        RPF( "Failing DllGetClassObject due to lack of DLL critical section" );
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllCanUnloadNow |
 *
 *          Determine whether the DLL has any outstanding interfaces.
 *
 *          There is an unavoidable race condition between
 *          <f DllCanUnloadNow> and the creation of a new
 *          <i IClassFactory>:  Between the time we return from
 *          <f DllCanUnloaDNow> and the caller inspects the value,
 *          another thread in the same process may decide to call
 *          <f DllGetClassObject>, thus suddenly creating an object
 *          in this DLL when there previously was none.
 *
 *          It is the caller's responsibility to prepare for this
 *          possibility; there is nothing we can do about it.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the DLL can unload, <c S_FALSE> if
 *          it is not safe to unload.
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    HRESULT hres;
#ifdef DEBUG
    if (IsSqflSet(sqfl)) {
        SquirtSqflPtszV(sqfl, TEXT("DllCanUnloadNow() - g_cRef = %d"), g_cRef);
        Common_DumpObjects();
    }
#endif
    hres = g_cRef ? S_FALSE : S_OK;
    return hres;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | DllLlHookTest |
 *
 *          Tiny hook procedure used to test whether LL hooks are
 *          supported by the operating system.
 *
 *          This function is almost never called.  We install the
 *          hook and immediately remove it.  The only time it
 *          manages to get called is if the user moves the mouse
 *          or presses a key during the microsecond that we exist.
 *
 *          Wait!  In fact, this function is *never* called.  We
 *          do not process messages at any point the hook is installed,
 *          so in fact nothing happens at all.
 *
 *  @parm   int | nCode |
 *
 *          Hook code.
 *
 *  @parm   WPARAM | wp |
 *
 *          Hook-specific code.
 *
 *  @parm   LPARAM | lp |
 *
 *          Hook-specific code.
 *
 *  @returns
 *
 *          Always chains to previous hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
DllLlHookTest(int nCode, WPARAM wp, LPARAM lp)
{
    /*
     *  Note that there is not actually anything wrong here,
     *  but it is a theoretically impossible condition, so I want to
     *  know when it happens.
     */
    AssertF(!TEXT("DllLlHookTest - Unexpected hook"));
    return CallNextHookEx(g_hhkLLHookCheck, nCode, wp, lp);
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllProcessAttach |
 *
 *          Called when the DLL is loaded.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA


TCHAR c_tszKernel32[] = TEXT("KERNEL32");
#ifndef WINNT
char c_szOpenVxDHandle[] = "OpenVxDHandle";
#endif

void INTERNAL
DllProcessAttach(void)
{
    HINSTANCE hinstK32;
#ifdef DEBUG

    WriteProfileString(0, 0, 0);   /* Flush the win.ini cache */
    Sqfl_Init();
    GetProfileString(TEXT("DEBUG"), TEXT("LogFile"), TEXT(""),
                     g_tszLogFile, cA(g_tszLogFile));
    SquirtSqflPtszV(sqfl, TEXT("LoadDll - DInput"));
    SquirtSqflPtszV(sqfl, TEXT("Version %x"), DIRECTINPUT_VERSION );
    SquirtSqflPtszV(sqfl, TEXT("Built %s at %s\n"), TEXT(__DATE__), TEXT(__TIME__) );
#endif

    /*
     *  Disabling thread library calls is important so that
     *  we don't deadlock with ourselves over the critical
     *  section when we spin up the worker thread to handle
     *  low-level hooks.
     */
    DisableThreadLibraryCalls(g_hinst);

    g_fCritInited = fInitializeCriticalSection(&g_crstDll);
    if( !g_fCritInited )
    {
        RPF( "Failed to initialize DLL critical section" );
    }

    hinstK32 = GetModuleHandle( c_tszKernel32 );


    {
        CANCELIO tmp;

        tmp = (CANCELIO)GetProcAddress(hinstK32, "CancelIo");
        if (tmp) {
            _CancelIO = tmp;
        } else {
            AssertF(_CancelIO == FakeCancelIO);
        }
    }

#ifdef WINNT
    {
        /*
         *  For now, only look for TryEnterCriticalSection on NT as it is not
         *  implemented on 9x but the stub is annoying on 98 with dbg kernels.
         */
#ifdef XDEBUG
        TRYENTERCRITICALSECTION tmpCrt;

        tmpCrt = (TRYENTERCRITICALSECTION)GetProcAddress(hinstK32, "TryEnterCriticalSection");
        if(tmpCrt)
        {
            _TryEnterCritSec = tmpCrt;
        }else
        {
            AssertF(_TryEnterCritSec == FakeTryEnterCriticalSection);
        }
#endif

        fWinnt = TRUE;
    }
#else
    _OpenVxDHandle = (OPENVXDHANDLE)GetProcAddress(hinstK32, c_szOpenVxDHandle);
    fWinnt = FALSE;
#endif

#ifdef WORKER_THREAD
    {
        MSGWAITFORMULTIPLEOBJECTSEX tmp;

        tmp = (MSGWAITFORMULTIPLEOBJECTSEX)
                GetProcAddress(GetModuleHandle(TEXT("USER32")),
                               "MsgWaitForMultipleObjectsEx");
        if (tmp) {
            _MsgWaitForMultipleObjectsEx = tmp;
        } else {
            AssertF(_MsgWaitForMultipleObjectsEx ==
                 FakeMsgWaitForMultipleObjectsEx);
        }
    }

    /*
     *  We cannot initialize g_hmtxGlobal here, because we
     *  have no way to report the error back to the caller.
     */
#endif

#ifdef USE_SLOW_LL_HOOKS

    /*
     *  Determine whether low-level input hooks are supported.
     */
    g_hhkLLHookCheck = SetWindowsHookEx(WH_MOUSE_LL, DllLlHookTest,
                                        g_hinst, 0);
    if (g_hhkLLHookCheck) {
        UnhookWindowsHookEx(g_hhkLLHookCheck);
    }

#endif

    /*
     *  Warning!  Do not call ExtDll_Init during PROCESS_ATTACH!
     */
    g_wmJoyChanged = RegisterWindowMessage(MSGSTR_JOYCHANGED);

  #ifdef USE_WM_INPUT
    g_fRawInput      = (DIGetOSVersion() == WINWH_OS);
    if( g_fRawInput ) {
        g_hEventAcquire  = CreateEvent(0x0, 0, 0, 0x0);
        g_hEventThread   = CreateEvent(0x0, 0, 0, 0x0);
        g_hEventHid      = CreateEvent(0x0, 0, 0, 0x0);
    }
  #endif

  #ifdef WINNT
    g_hEventWinmm = OpenEvent(EVENT_MODIFY_STATE, 0, TEXT("DINPUTWINMM"));
    if( !g_hEventWinmm ) {
        RPF("Open named event fails (0x%08lx).", GetLastError());
    }
  #endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllProcessDetach |
 *
 *          Called when the DLL is unloaded.
 *
 *****************************************************************************/

void INTERNAL
DllProcessDetach(void)
{
    extern PLLTHREADSTATE g_plts;

  #ifdef USE_WM_INPUT
    if (g_hEventAcquire)
    {
        CloseHandle(g_hEventAcquire);
    }

    if (g_hEventThread)
    {
        CloseHandle(g_hEventThread);
    }

    if (g_hEventHid)
    {
        CloseHandle(g_hEventHid);
    }
  #endif
  
#ifndef WINNT
    if (g_hVxD != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hVxD);
    }
#endif

    if (g_psop) {
        UnmapViewOfFile(g_psop);
    }

    if (g_hfm) {
        CloseHandle(g_hfm);
    }

    if (g_hmtxGlobal) {
        CloseHandle(g_hmtxGlobal);
    }

#ifdef IDirectInputDevice2Vtbl
    if (g_hmtxJoy) {
        CloseHandle(g_hmtxJoy);
    }

#endif

    #ifdef NOTYET
    if (g_hinstRPCRT4) {
        FreeLibrary(g_hinstRPCRT4);
    }
    #endif

#ifdef HID_SUPPORT
    ExtDll_Term();
#endif

    if( g_fCritInited )
    {
        DeleteCriticalSection(&g_crstDll);
    }

    /*
     *  Output message last so that anything that follows in known to be bad.
     */
    if (g_cRef )
    {
      #ifdef WINNT
        if( g_hEventWinmm ) {
            SetEvent(g_hEventWinmm);
            Sleep(10);
        }
      #endif

        RPF("unloaded before all objects released. (cRef:%d)\r\n", g_cRef);
    }

  #ifdef WINNT
    if( g_hEventWinmm ) {
        CloseHandle(g_hEventWinmm);
    }
  #endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllMain |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/

BOOL APIENTRY
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        g_hinst = hinst;
        DllProcessAttach();
		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflMajor,
            TEXT("DINPUT: DLL_PROCESS_ATTACH hinst=0x%p, lpReserved=0x%p"),
            hinst, lpReserved );
        break;

    case DLL_PROCESS_DETACH:
        DllProcessDetach();
		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflMajor,
            TEXT("DINPUT: DLL_PROCESS_DETACH hinst=0x%p, lpReserved=0x%p"),
            hinst, lpReserved );
        break;
    }
    return 1;
}

/*****************************************************************************
 *
 *  @doc EXTERNAL
 *
 *  @topic Definitions and Ground Rules |
 *
 *  The phrase "undefined behavior" refers to behavior which is not
 *  covered by this specification due to violations of a constraint.
 *  No constraint is imposed by the specification as to the result of
 *  undefined behavior.  It may range from silently ignoring the
 *  situation to a complete system crash.
 *
 *  If this specification does not prescribe a behavior for a particular
 *  situation, the behavior is "undefined".
 *
 *  The phrase "It is an error" indicates that failure to comply
 *  is a violation of the DirectInput specification and results
 *  in "undefined behavior".
 *
 *  The word "shall" is to be interpreted as a
 *  requirement on an application; conversely, "shall not" is to be
 *  interpreted as a prohibition.  Violation of a requirement or
 *  prohibition "is an error".
 *
 *  The word "may" indicates that the indicated behavior is possible
 *  but is not required.
 *
 *  The word "should" indicates a strong suggestion.
 *  If the application violates a "should" requirement, then DirectInput
 *  "may" fail the operation.
 *
 *  Pointer parameters to functions "shall not" be NULL unless explicitly
 *  documented as OPTIONAL.  "It is an error" to pass a pointer to an object
 *  of the wrong type, to an object which is not allocated, or to an
 *  object which has been freed or <f Release>d.
 *
 *  Unless indicated otherwise,
 *  an object pointed to by a pointer parameter documented as an
 *  IN parameter "shall not" be modified by the called procedure.
 *  Conversely, a pointer parameter documented
 *  as an OUT parameter "shall" point to a modifiable object.
 *
 *  When a bitmask of flags is defined, all bits not defined by this
 *  specification are reserved.  Applications "shall not" set reserved
 *  bits and "shall" ignore reserved bits should they be received.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @topic  Initialization and Versions |
 *
 *          In several places, DirectInput requires you to pass an instance
 *          handle and a version number.
 *
 *          The instance handle must correspond to the application or
 *          DLL that is initializing the DirectInput object.
 *
 *          DirectInput uses this value to determine whether the
 *          application or DLL has been certified and to establish
 *          any special behaviors that may be necessary for
 *          backwards-compatibility.
 *
 *          It is an error for a DLL to pass the handle of the
 *          parent application.  For example, an ActiveX control
 *          embedded in a web page which uses DirectInput must
 *          pass its own instance handle and not the handle of the
 *          web browser.  This ensures that DirectInput recognizes
 *          the control and can enable any special behaviors
 *          for the control the behave properly.
 *
 *          The version number parameter specifies which version of
 *          DirectInput the DirectInput subsystem should emulate.
 *
 *          Applications designed for the latest version of DirectInput
 *          should pass the value <c DIRECTINPUT_VERSION> as defined
 *          in dinput.h.
 *
 *          Applications designed for previous versions of DirectInput
 *          should pass a value corresponding to the version of
 *          DirectInput they were designed for.  For example, an
 *          application that was designed to run on DirectInput 3.0
 *          should pass a value of 0x0300.
 *
 *          If you #define <c DIRECTINPUT_VERSION> to 0x0300 before
 *          including the dinput.h header file, then the dinput.h
 *          header file will generate DirectInput 3.0-compatible
 *          structure definitions.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DirectInputCreateHelper |
 *
 *          <bnew>This function creates a new DirectInput object
 *          which supports the <i IDirectInput> COM interface.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p lplpDirectInput>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Points to where to return
 *          the pointer to the <i IDirectInput> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown.
 *
 *  @parm   RIID | riid |
 *
 *          The interface the application wants to create.  This will
 *          be either <i IDirectInputA> or <i IDirectInputW>.
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM>
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
DirectInputCreateHelper(HINSTANCE hinst, DWORD dwVer,
                        PPV ppvObj, PUNK punkOuter, RIID riid)
{
    HRESULT hres;
    EnterProc(DirectInputCreateHelper,
              (_ "xxxG", hinst, dwVer, punkOuter, riid));

	if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 3)))
	{
		if( g_fCritInited  )
		{
			LPVOID pvTry = NULL;
			hres = CDIObj_New(punkOuter,
							  punkOuter ? &IID_IUnknown : riid, &pvTry);

			if (SUCCEEDED(hres) && punkOuter == 0) {
				LPDIRECTINPUT pdi = pvTry;
				hres = pdi->lpVtbl->Initialize(pdi, hinst, dwVer);
				if (SUCCEEDED(hres)) {
					*ppvObj = pvTry;
				} else {
					Invoke_Release(&pvTry);
					*ppvObj = NULL;
				}
			}
		}
		else
		{
			RPF( "Failing DirectInputCreate due to lack of DLL critical section" );
			hres = E_OUTOFMEMORY;
		}
	}

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DirectInputCreate |
 *
 *          <bnew>This function creates a new DirectInput object
 *          which supports the <i IDirectInput> COM interface.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p lplpDirectInput>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   OUT LPDIRECTINPUT * | lplpDirectInput |
 *
 *          Points to where to return
 *          the pointer to the <i IDirectInput> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *          Note that if aggregation is requested, the object returned
 *          in *<p lplpDirectInput> will be a pointer to an
 *          <i IUnknown> rather than an <i IDirectInput>, as required
 *          by OLE aggregation.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lplpDirectInput> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_DIERR_OLDDIRECTINPUTVERSION>: The application
 *          requires a newer version of DirectInput.
 *
 *          <c DIERR_DIERR_BETADIRECTINPUTVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of DirectInput.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IDirectInput, <p lplpDirectInput>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInput>).
 *          The aggregated object must be initialized manually.
 *
 *          Note that there are separate ANSI and UNICODE versions of
 *          this service.  The ANSI version creates and initializes
 *          an object which
 *          supports the <i IDirectInputA> interface, whereas
 *          the UNICODE version creates and initializes
 *          an object which supports
 *          the <i IDirectInputW> interface.  As with other system
 *          services which are sensitive to character set issues,
 *          macros in the header file map <f DirectInputCreate> to
 *          the appropriate character set variation.
 *
 *****************************************************************************/

STDMETHODIMP
DirectInputCreateA(HINSTANCE hinst, DWORD dwVer, PPDIA ppdiA, PUNK punkOuter)
{
    HRESULT hres;
    EnterProc(DirectInputCreateA, (_ "xxx", hinst, dwVer, punkOuter));

    /* Need to maintain a refcount to keep the Dll Around */
    DllAddRef();

    hres = DirectInputCreateHelper(hinst, dwVer, (PPV)ppdiA, punkOuter,
                                   &IID_IDirectInputA);

    DllRelease();

    ExitOleProcPpv(ppdiA);
    return hres;
}

STDMETHODIMP
DirectInputCreateW(HINSTANCE hinst, DWORD dwVer, PPDIW ppdiW, PUNK punkOuter)
{
    HRESULT hres;
    EnterProc(DirectInputCreateW, (_ "xx", ppdiW, punkOuter));

    /* Need to maintain a refcount to keep the Dll Around */
    DllAddRef();

    hres = DirectInputCreateHelper(hinst, dwVer, (PPV)ppdiW, punkOuter,
                                   &IID_IDirectInputW);

    DllRelease();

    ExitOleProcPpv(ppdiW);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DirectInputCreateEx |
 *
 *          <bnew>This function creates a new DirectInput object
 *          which supports the <i IDirectInput> COM interface. This function
 *          allows the app to pass an IID so it does not have to do an extra
 *          QI off the <i IDirectInput> interface in order to obtain an
 *          <i IDirectInput2> or <i IDirectInput7> interface.
 *
 *          We don't need a DirectInputCreateExW and DirectInputCreateExA because
 *          you can QI for the IDirectInput#A from this function.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p ppvOut>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   REFIID | riidtlf |
 *
 *          The desired interface interface.
 *          Currently, valid fields are IID_IDirectInput, IID_IDirectInput2 and IID_IDirectInput7.
 *          OR IID_IDirectInputA, IID_IDirectInputW, .... IID_IDirectInput7W
 *
 *  @parm   OUT LPVOID | *ppvOut |
 *
 *          Points to where to return
 *          the pointer to the <i IDirectInput#> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *          Note that if aggregation is requested, the object returned
 *          in *<p lplpDirectInput> will be a pointer to an
 *          <i IUnknown> rather than an <i IDirectInput>, as required
 *          by OLE aggregation.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lplpDirectInput> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_DIERR_OLDDIRECTINPUTVERSION>: The application
 *          requires a newer version of DirectInput.
 *
 *          <c DIERR_DIERR_BETADIRECTINPUTVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of DirectInput.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IDirectInput, <p lplpDirectInput>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInput>).
 *          The aggregated object must be initialized manually.
 *
 *          Note that there are separate ANSI and UNICODE versions of
 *          this service.  The ANSI version creates and initializes
 *          an object which
 *          supports the <i IDirectInputA> interface, whereas
 *          the UNICODE version creates and initializes
 *          an object which supports
 *          the <i IDirectInputW> interface.  As with other system
 *          services which are sensitive to character set issues,
 *          macros in the header file map <f DirectInputCreate> to
 *          the appropriate character set variation.
 *
 *****************************************************************************/

STDMETHODIMP
DirectInputCreateEx(HINSTANCE hinst, DWORD dwVer, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter)
{
    HRESULT hres;
    EnterProc(DirectInputCreateEx, (_ "xxGx", hinst, dwVer, riidltf, ppvOut, punkOuter));

    /* Need to maintain a refcount to keep the Dll Around */
    DllAddRef();

    // Only supports incarnations of IDirectInput interface
    if( IsEqualIID(riidltf, &IID_IDirectInputA) ||
        IsEqualIID(riidltf, &IID_IDirectInputW) ||
        IsEqualIID(riidltf, &IID_IDirectInput2A)||
        IsEqualIID(riidltf, &IID_IDirectInput2W)||
        IsEqualIID(riidltf, &IID_IDirectInput7A)||
        IsEqualIID(riidltf, &IID_IDirectInput7W)
      )
    {
        hres = DirectInputCreateHelper(hinst, dwVer, ppvOut, punkOuter,
                                       riidltf);

    }else
    {
        hres = E_NOINTERFACE;
    }

    DllRelease();

    ExitOleProcPpv(ppvOut);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dinput.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Sources.inc

    Abstract:

    Common makefile settings for DInput.

Author:

    RaymondC and a-MarcAn 1996-10-17

History:
    Date        By          Reason
    ====        ==          ======
    1996-       RaymondC    first version
    1996-10-17  a-MarcAn    tidied and adjusted for checkin to windows\media
			    disabled NTTARGETFILE0
    1996-12-06  RaymondC    Split NT and 95 versions
    1997-01-09  a-MarcAn    Set to OS version 0x403

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk

# we have to be able to run w/ all versions of IE but prsht.h insists
# on IE 4.0 if you pass WIN32_WINNT_VERSION of 0x0500
WIN32_IE_VERSION=0x0400

!IFDEF TARGET_WIN95
#
# CHICAGO_PRODUCT: Suppress -DWINNT
# USE_MAPSYM: Create a .sym file
# ALT_PROJECT_TARGET: Alternate drop point (yes, they call it `chicago')
# WIN32_DEFINE: The things we #define; _WIN32_WINNT is the important one
#               because it's that one that gives us WH_*_LL.
#               We need 0x0403 to get WH_*_LL in SP3 tree
#
DLLBASE=0x70000000
CHICAGO_PRODUCT = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_
WIN32_DEFINE = -DWIN32=100 -D_WIN32_WINDOWS=0x0400 -D_WIN32_WINNT=0x0400

! IF $(FREEBUILD)
#Win9x Free Build
#USE_NOLIBS=1
TARGETLIBS= $(SDK_LIB_PATH)\exsup.lib
#DLLENTRY=DllMain
DLLENTRY=_DllMainCRTStartup        
! ELSE
# Win9x Chk Build        
USE_LIBCMT=1
DLLENTRY=_DllMainCRTStartup

! ENDIF

! ELSE
#Win2k Build
DLLENTRY=DllMain

! IF defined( DIRECTX_REDIST )
WIN32_WINNT_VERSION=0x0500
! ENDIF

C_DEFINES=$(C_DEFINES) -DWINNT -DUNICODE

!ENDIF

USE_MAPSYM = 1

C_DEFINES=$(C_DEFINES) -DNOWINRES -DUSE_SLOW_LL_HOOKS -DHID_SUPPORT

MAJORCOMP=windows
MINORCOMP=media
UMTYPE=windows

TARGETNAME=dinput
TARGETTYPE=DYNLINK
TARGETPATH=obj


INCLUDES=$(INCLUDES); \
        ..\;\
        $(DXROOT)\inc;\

CONDITIONAL_INCLUDES=\
    commctrl.rh      \
    version.h        \
    ieverp.h         \
    $(CONDITIONAL_INCLUDES)

NTTARGETFILES=

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib     \
	   $(SDK_LIB_PATH)\advapi32.lib     \
	   $(SDK_LIB_PATH)\user32.lib       \
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(SDK_LIB_PATH)\winmm.lib        \
           $(TARGETLIBS)         


LINKER_FLAGS=$(LINKER_FLAGS) -SECTION:share,RWS

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

SOURCES=\
    ..\assert.c     \
    ..\common.c     \
    ..\diaphack.c   \
    ..\dicf.c       \
    ..\didev.c      \
    ..\didevdf.c    \
    ..\didevef.c    \
    ..\diem.c       \
    ..\diemm.c      \
    ..\diemk.c      \
    ..\diemh.c      \
    ..\digenj.c     \
    ..\dical.c      \
    ..\dijoytyp.c   \
    ..\dieffj.c     \
    ..\dieffv.c     \
    ..\dieshep.c    \
    ..\digenk.c     \
    ..\digenm.c     \
    ..\digenx.c     \
    ..\digendef.c   \
    ..\dihel.c      \
    ..\dimem.c      \
    ..\dinput.c     \
    ..\diobj.c      \
    ..\dieff.c      \
    ..\didenum.c    \
    ..\dihidenm.c   \
    ..\dihidusg.c   \
    ..\dihid.c      \
    ..\dihidini.c   \
    ..\dihiddat.c   \
    ..\diguid.c     \
    ..\dijoycfg.c   \
    ..\dithunk.c    \
    ..\diaddhw.c    \
    ..\dijoyreg.c   \
    ..\direg.c      \
    ..\disubcls.c   \
    ..\diexcl.c     \
    ..\diutil.c     \
    ..\dilist.c     \
    ..\dioledup.c   \
    ..\diregutl.c   \
    ..\diextdll.c   \
    ..\valid.c      \
    ..\diwinnt.c    \
    ..\dijoyhid.c   \
    ..\diport.c     \
    ..\dinput.rc    \
    ..\guids.c      \
    ..\diriff.c     \
    ..\diraw.c      \
    ..\dilib1.c     \
    ..\dilib2.c     \
    ..\dilib3.c     \
    ..\dilib4.c     \
    ..\dilib5.c     \

DLLDEF=..\dinput.def

PRECOMPILED_INCLUDE=..\dinputpr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dinputpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputpr.h
 *  Content:    private DirectInput include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   96.05.08   raymondc Because it's there
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __DINPUTPR_INCLUDED__
    #define __DINPUTPR_INCLUDED__

    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #define Not_VxD

// ISSUE-2000/12/19-MarcAnd HID_SUPPORT #ifdefs should be cleaned out
// This was commented out since the makefile sets it but adding dilib
// means it is easiest to put this back.  HID_SUPPORT is not going away 
// so the #ifdefed code should be cleaned up.
#ifndef HID_SUPPORT
#define HID_SUPPORT                     
#endif
                                    

/***************************************************************************
 *
 *  Make sure we know what platform we are building for.
 *
 *  INITGUID is defined by guidlib, who doesn't care what platform we
 *  are building for.  (GUIDs are platform-independent.)
 *
 ***************************************************************************/

    #ifndef INITGUID
        #if defined(WINNT) + defined(WIN95) != 1
            #error Must define exactly one of WINNT or WIN95
        #endif
    #endif

/***************************************************************************
 *
 *  Deciding whether we should use UNICODE
 *
 *  Use UNICODE on everything that isn't an X86, because NT is the only
 *  thing that runs on them.
 *
 *  If we *are* X86, then do UNICODE only if the command line says so.
 *
 ***************************************************************************/

    #ifndef _X86_
        #ifndef UNICODE
            #define UNICODE
        #endif
    #endif

    #pragma warning(disable:4115)           /* rpcndr.h: parenthesized type */
    #pragma warning(disable:4201)           /* winnt.h: nameless union */
    #pragma warning(disable:4214)           /* winnt.h: unsigned bitfields */
    #pragma warning(disable:4514)           /* winnt.h: fiber goo */
    #pragma warning(error:4101)             /* unreferenced local variable */


    #define STRICT

    #include <windows.h>
    #include <windowsx.h>
    #include <mmsystem.h>
    #include <mmreg.h>
    #include <objbase.h>
    #include <regstr.h>
    #include <math.h>


    #define DIRECTINPUT_VERSION 0x0700
    #include <dinput.h>
    #include "dinputp.h"

    #if DIRECTINPUT_VERSION > 0x0400 && !defined(GUIDLIB)

    #if (_WIN32_WINNT >= 0x0501)
        #define USE_WM_INPUT 1
    #endif

/*
 *  Old versions of commctrl.h do not #include <prsht.h> automatically;
 *  therefore we must include it so that <setupapi.h> won't barf.
 *  Fortunately, prsht.h is idempotent, so an extra #include won't hurt.
 */
        #include <prsht.h>

        #include <setupapi.h>
        #include <hidsdi.h>
        #include <cfgmgr32.h>
        #include <winioctl.h>


#ifndef WINNT
        /*
         *  The version of basetyps.h hidclass.h includes on Win9x builds
         *  causes redefinition errors for DEFINE_GUID since we already have
         *  it from objbase.h so we have to null the include.
         */
        #define _BASETYPS_H_
#endif

        #include <hidclass.h>
        #include <stdio.h>

    #endif

    #include <dinputd.h>
    #include "dinputdp.h"
    #include "dinputv.h"
    #include "dinputi.h"
    #include "dihel.h"
    #include "debug.h"
    #include "diem.h"
    #include "dihid.h"
    #include "dinputrc.h"

    #include "diwinnt.h"
#if !(DIRECTINPUT_VERSION > 0x0400 && !defined(GUIDLIB))
    #include <winioctl.h>
#endif
    #include "diport.h"
    #include "gameport.h"
    #include "winuser.h"
    #include "dbt.h"

    #ifdef WINNT
        #include "aclapi.h"
    #endif
    #include "diRiff.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dinputrc.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputrc.h
 *  Content:    DirectInput internal resource header file
 *
 ***************************************************************************/


/*****************************************************************************
 *
 *  Strings
 *
 *****************************************************************************/

/*
 *  IDS_STDMOUSE
 *
 *      Friendly name for the standard mouse device.
 */
#define IDS_STDMOUSE            16

/*
 *  IDS_STDKEYBOARD
 *
 *      Friendly name for the standard keyboard device.
 */
#define IDS_STDKEYBOARD         17

/*
 *  IDS_STDJOYSTICK
 *
 *      Friendly name for the standard joystick devices.
 *
 *      This string contains a %d.
 */
#define IDS_STDJOYSTICK         18

/*
 *  IDS_DIRECTINPUT
 *
 *      CLSID name for OLE registration.
 */
#define IDS_DIRECTINPUT         19

/*
 *  IDS_DIRECTINPUTDEVICE
 *
 *      CLSID name for OLE registration.
 */
#define IDS_DIRECTINPUTDEVICE   20

/*
 *  IDS_BUTTONTEMPLATE
 *
 *      Template for generic button name.
 */
#define IDS_BUTTONTEMPLATE      28

/*
 *  IDS_AXISTEMPLATE
 *
 *      Template for generic axis name.
 */
#define IDS_AXISTEMPLATE        29

/*
 *  IDS_POVTEMPLATE
 *
 *      Template for generic POV name.
 */
#define IDS_POVTEMPLATE         30

/*
 *  IDS_COLLECTIONTEMPLATE
 *
 *      Template for generic collection name.
 */
#define IDS_COLLECTIONTEMPLATE  31

/*
 *  IDS_COLLECTIONTEMPLATEFORMAT
 *
 *      Template for generic collection name with room for a "%s"
 *      where the friendly name is kept.
 */
#define IDS_COLLECTIONTEMPLATEFORMAT 32


/*
 *  IDS_STDGAMEPORT
 *
 *      Friendly name for the standard gameport devices.
 *
 *      This string contains a %d.
 */

#define IDS_STDGAMEPORT         33

/*
 *  IDS_STDSERIALPORT
 *
 *      Friendly name for the standard serialport devices.
 *
 *      This string contains a %d.
 */

#define IDS_STDSERIALPORT         34

/*
 *  IDS_UNKNOWNTEMPLATE
 *
 *      Template for Unknown device object.
 */
#define IDS_UNKNOWNTEMPLATE  35

/*
 *  IDS_UNKNOWNTEMPLATEFORMAT
 *
 *      Template format for Unknown device object.
 */
#define IDS_UNKNOWNTEMPLATEFORMAT 36

/*
 *  IDS_MOUSEOBJECT+0 ... IDS_MOUSEOBJECT+255
 *
 *      Friendly names for mouse device objects.
 */
#define IDS_MOUSEOBJECT         0x0100

/*
 *  IDS_KEYBOARDOBJECT+0 ... IDS_KEYBOARDOBJECT+255
 *
 *      Friendly names for keyboard objects.
 */
#define IDS_KEYBOARDOBJECT      0x0200

/*
 *  IDS_JOYSTICKOBJECT+0 ... IDS_JOYSTICKOBJECT+255
 *
 *      Friendly names for joystick objects.
 */
#define IDS_JOYSTICKOBJECT      0x0300

/*
 *  IDS_PREDEFJOYTYPE+0 ... IDS_PREDEFJOYTYPE+255
 *
 *      Friendly names for predefined joystick types.
 */
#define IDS_PREDEFJOYTYPE       0x0400

/* Gap of 256 string IDs for alignment */

/*
 *  IDS_PAGE_GENERIC+0 ... IDS_PAGE_GENERIC+511
 *
 *      Friendly names for HID Usage Page = Generic
 */
#define IDS_PAGE_GENERIC        0x0600

/*
 *  IDS_PAGE_VEHICLE+0 ... IDS_PAGE_VEHICLE+511
 *
 *      Friendly names for HID Usage Page = Vehicle
 */
#define IDS_PAGE_VEHICLE        0x0800

/*
 *  IDS_PAGE_VR+0 ... IDS_PAGE_VR+511
 *
 *      Friendly names for HID Usage Page = VR
 */
#define IDS_PAGE_VR             0x0A00

/*
 *  IDS_PAGE_SPORT+0 ... IDS_PAGE_SPORT+511
 *
 *      Friendly names for HID Usage Page = Sport Controls
 */
#define IDS_PAGE_SPORT          0x0C00

/*
 *  IDS_PAGE_GAME+0 ... IDS_PAGE_GAME+511
 *
 *      Friendly names for HID Usage Page = Game Controls
 */
#define IDS_PAGE_GAME           0x0E00

/*
 *  IDS_PAGE_LED+0 ... IDS_PAGE_LED+511
 *
 *      Friendly names for HID Usage Page = LEDs
 */
#define IDS_PAGE_LED            0x1000

/*
 *  IDS_PAGE_TELEPHONY+0 ... IDS_PAGE_TELEPHONY+511
 *
 *      Friendly names for HID Usage Page = Telephony
 */
#define IDS_PAGE_TELEPHONY      0x1200

/*
 *  IDS_PAGE_CONSUMER+0 ... IDS_PAGE_CONSUMER+511
 *
 *      Friendly names for HID Usage Page = Consumer
 */
#define IDS_PAGE_CONSUMER       0x1400

/*
 *  IDS_PAGE_DIGITIZER+0 ... IDS_PAGE_DIGITIZER+511
 *
 *      Friendly names for HID Usage Page = Digitizer
 */
#define IDS_PAGE_DIGITIZER      0x1600

/*
 *  IDS_PAGE_KEYBOARD+0 ... IDS_PAGE_KEYBOARD+511
 *
 *      Friendly names for HID Usage Page = Keyboard
 */
#define IDS_PAGE_KEYBOARD       0x1800


/*
 *  IDS_PAGE_PID+0 ... IDS_PAGE_PID+511
 *
 *      Friendly names for HID Usage Page = PID
 */
#define IDS_PAGE_PID            0x1A00

/*****************************************************************************
 *
 *  RCDATA
 *
 *  Japanese keyboard translation tables are stored in resources.
 *
 *  This lets us change them at the last minute without too much risk.
 *
 *  It also keeps them out of our image.
 *
 *****************************************************************************/

#define IDDATA_KBD_NEC98        1
#define IDDATA_KBD_NEC98LAPTOP  IDDATA_KBD_NEC98    /* The same */
#define IDDATA_KBD_NEC98_106    2
#define IDDATA_KBD_JAPAN106     3
#define IDDATA_KBD_JAPANAX      4
#define IDDATA_KBD_J3100        5
#define IDDATA_KBD_PCENH        6
#define IDDATA_KBD_NEC98_NT     7
#define IDDATA_KBD_NEC98LAPTOP_NT IDDATA_KBD_NEC98_NT /* The same */
#define IDDATA_KBD_NEC98_106_NT 8

/*****************************************************************************
 *
 *  RCDATA
 *
 *  The mapping between HID usages
 *
 *  This lets us change them at the last minute without too much risk.
 *
 *  It also keeps them out of our image.
 *
 *****************************************************************************/

#define IDDATA_HIDMAP           9

/*****************************************************************************
 * Template for Generic Joystick Names
 *
 * Modified from MsJstick.
 *
 * Assigning a default name to A HID device, when there is none in the registry
 *
 * Note, string IDs for PLAIN_STICK to IDS_HEAD_TRACKER must stay contiguous 
 * and in order.  The various PLAIN_STICKs are present to make a one to one 
 * mapping from joystick subtype to string ID.
 *
 *****************************************************************************/


#define IDS_TEXT_TEMPLATE    0x0002000
#define IDS_PLAIN_STICK      0x0002001
#define IDS_PLAIN_STICK2     0x0002002
#define IDS_FLIGHT_CTRL      0x0002003
#define IDS_GAMEPAD          0x0002004
#define IDS_PLAIN_STICK3     0x0002005
#define IDS_DRIVE_CTRL       0x0002006
#define IDS_HEAD_TRACKER     0x0002007
#define IDS_DEVICE_NAME      0x0002008
#define IDS_WITH_POV         0x0002009
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dinputi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputi.h
 *  Content:    DirectInput internal include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1996.05.07 raymondc Lost a bet
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifdef __cplusplus
extern "C" {
#endif

    /***************************************************************************
     *
     *  Debug / RDebug / Retail
     *
     *  If either DEBUG or RDEBUG, set XDEBUG.
     *
     *  Retail defines nothing.
     *
     ***************************************************************************/

#if defined(DEBUG) || defined(RDEBUG)
    #define XDEBUG
#endif

    /***************************************************************************
     *
     *                            Turning off stuff...
     *
     *  Turn off these things, because they confuse the bilingualism macros.
     *  Instead, we call then IMumbleT.
     *
     ***************************************************************************/

#undef IDirectInput
#undef IDirectInput2
#undef IDirectInput7
#undef IDirectInputDevice
#undef IDirectInputDevice2
#undef IDirectInputDevice7
    /*
     *  And <mmsystem.h> defines JOY_POVCENTERED incorrectly...
     */
#undef  JOY_POVCENTERED
#define JOY_POVCENTERED     0xFFFFFFFF

    /*
     *  And older versions of windows.h don't have this definition.
     */
#ifndef HasOverlappedIoCompleted
    #define HasOverlappedIoCompleted(lpOverlapped) \
            ((lpOverlapped)->Internal != STATUS_PENDING)
#endif

    /***************************************************************************
     *
     *                            Abbreviations....
     *
     *  Give shorter names to things we talk about frequently.
     *
     ***************************************************************************/

    typedef LPDIRECTINPUT  PDI , *PPDI ;
    typedef LPDIRECTINPUTA PDIA, *PPDIA;
    typedef LPDIRECTINPUTW PDIW, *PPDIW;

    typedef LPDIRECTINPUTDEVICE  PDID , *PPDID ;
    typedef LPDIRECTINPUTDEVICEA PDIDA, *PPDIDA;
    typedef LPDIRECTINPUTDEVICEW PDIDW, *PPDIDW;

    typedef LPDIRECTINPUTEFFECT  PDIE , *PPDIE ;

    typedef DIOBJECTDATAFORMAT   ODF,   *PODF;
    typedef const ODF                   *PCODF;

    typedef LPUNKNOWN PUNK;
    typedef LPVOID PV, *PPV;
    typedef CONST VOID *PCV;
    typedef REFIID RIID;
    typedef CONST GUID *PCGUID;

    /***************************************************************************
     *
     *      GetProcAddress'd KERNEL32 and USER32 functions.
     *
     ***************************************************************************/
    typedef DWORD (WINAPI *OPENVXDHANDLE)(HANDLE);
    typedef BOOL  (WINAPI *CANCELIO)(HANDLE);
    typedef DWORD (WINAPI *MSGWAITFORMULTIPLEOBJECTSEX)
    (DWORD, LPHANDLE, DWORD, DWORD, DWORD);

    typedef BOOL (WINAPI *TRYENTERCRITICALSECTION)(LPCRITICAL_SECTION);

    extern OPENVXDHANDLE _OpenVxDHandle;
    extern CANCELIO _CancelIO;
    extern MSGWAITFORMULTIPLEOBJECTSEX _MsgWaitForMultipleObjectsEx;
#ifdef XDEBUG
    extern TRYENTERCRITICALSECTION _TryEnterCritSec;
    BOOL WINAPI FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCrit_sec);
#endif

    DWORD WINAPI
        FakeMsgWaitForMultipleObjectsEx(DWORD, LPHANDLE, DWORD, DWORD, DWORD);

    BOOL WINAPI FakeCancelIO(HANDLE h);


    /***************************************************************************
     *
     *      Our global variables - see dinput.c for documentation
     *
     ***************************************************************************/

    extern HINSTANCE g_hinst;
#ifndef WINNT
    extern HANDLE g_hVxD;
#endif
    extern DWORD g_flEmulation;
    extern LPDWORD g_pdwSequence;

#ifdef USE_SLOW_LL_HOOKS
    extern HHOOK g_hhkLLHookCheck;
    #define g_fUseLLHooks   ((BOOL)(UINT_PTR)g_hhkLLHookCheck)
#endif

    extern HANDLE g_hmtxGlobal;
    extern HANDLE g_hfm;
    extern struct SHAREDOBJECTPAGE *g_psop;
    extern UINT g_wmJoyChanged;
    extern HANDLE g_hmtxJoy;
    extern HINSTANCE g_hinstRPCRT4;
    extern HINSTANCE g_hinstSetupapi;
    extern LONG g_lWheelGranularity;
    extern BOOL fWinnt;     //whether we are running in Winnt

    extern BOOL g_fRawInput;
  #ifdef USE_WM_INPUT
    extern HWND g_hwndThread;
    extern HANDLE g_hEventAcquire;
    extern HANDLE g_hEventThread;
    extern HANDLE g_hEventHid;
  #endif

#if (DIRECTINPUT_VERSION > 0x061A)
    typedef struct _DIAPPHACKS
    {
        BOOL    fReacquire;
        BOOL    fNoSubClass;
        BOOL    fNativeAxisOnly;
        BOOL    fNoPollUnacquire;
		BOOL	fSucceedAcquire;
        int     nMaxDeviceNameLength;
        DWORD   dwDevType;
    } DIAPPHACKS, *LPDIAPPHACKS;
#endif

    /*****************************************************************************
     *
     *                      Baggage
     *
     *      Stuff I carry everywhere.
     *
     *****************************************************************************/

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

    /*
     *  Arithmetic on pointers.
     */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

    /*
     * Convert an object (X) to a count of bytes (cb).
     */
#define cbX(X) sizeof(X)

    /*
     * Convert an array name (A) to a generic count (c).
     */
#define cA(a) (cbX(a)/cbX(a[0]))

    /*
     * Convert a count of X's (cx) into a count of bytes
     * and vice versa.
     */
#define  cbCxX(cx, X) ((cx) * cbX(X))
#define  cxCbX(cb, X) ((cb) / cbX(X))

    /*
     * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
     * or dwords (cdw) into a count of bytes, and vice versa.
     */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

#define  cchCb(cb) cxCbX(cb,  CHAR)
#define cwchCb(cb) cxCbX(cb, WCHAR)
#define ctchCb(cb) cxCbX(cb, TCHAR)
#define  cdwCb(cb) cxCbX(cb, DWORD)

    /*
     * Zero an arbitrary buffer.  It is a common error to get the second
     * and third parameters to memset backwards.
     */
#define ZeroBuf(pv, cb) memset(pv, 0, cb)

    /*
     * Zero an arbitrary object.
     */
#define ZeroX(x) ZeroBuf(&(x), cbX(x))

    /*
     * land -- Logical and.  Evaluate the first.  If the first is zero,
     * then return zero.  Otherwise, return the second.
     */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

    /*
     * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
     * return it.  Otherwise, return the second.
     *
     * Unfortunately, due to the nature of the C language, this can
     * be implemented only with a GNU extension.  In the non-GNU case,
     * we return 1 if the first is nonzero.
     */

#if defined(__GNUC__)
    #define fLorFF(f1, f2) ((f1) ?: (f2))
#else
    #define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

    /*
     * limp - logical implication.  True unless the first is nonzero and
     * the second is zero.
     */
#define fLimpFF(f1, f2) (!(f1) || (f2))

    /*
     * leqv - logical equivalence.  True if both are zero or both are nonzero.
     */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

    /*
     *  fInOrder - checks that i1 <= i2 < i3.
     */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

    /*
     *  fHasAllBitsFlFl - checks that all bits in fl2 are set in fl1.
     */
    BOOL INLINE
        fHasAllBitsFlFl(DWORD fl1, DWORD fl2)
    {
        return (fl1 & fl2) == fl2;
    }

    /*
     *  fEqualMask - checks that all masked bits are equal
     */
    BOOL INLINE
        fEqualMaskFlFl(DWORD flMask, DWORD fl1, DWORD fl2)
    {
        return ((fl1 ^ fl2) & flMask) == 0;
    }

    /*
     * Words to keep preprocessor happy.
     */
#define comma ,
#define empty

    /*
     *  Atomically exchange one value for another.
     */
#if defined(_M_IA64) || defined(_M_AMD64)
#define InterlockedExchange64 _InterlockedExchange64
#ifndef RC_INVOKED
#pragma intrinsic(_InterlockedExchange64)
#endif /*RC_INVOKED*/
#define pvExchangePpvPv(ppv, pv) \
        InterlockedExchange((ppv), (pv))
#define pvExchangePpvPv64(ppv, pv) \
        InterlockedExchange64((PLONGLONG)(ppv), (LONGLONG)(pv))
#else /*_M_IA64*/
#define pvExchangePpvPv(ppv, pv) \
        (PV)InterlockedExchange((PLONG)(ppv), (LONG)(pv))
#define pvExchangePpvPv64(ppv, pv) \
        (PV)InterlockedExchange((PLONG)(ppv), (LONG)(pv))
#endif /*_M_IA64*/

    /*
     *  Creating HRESULTs from a USHORT or from a LASTERROR.
     */
#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))
    /*
     *  or a registry function return code
     */
    HRESULT INLINE
        hresReg( LONG lRc )
    {
        return( (lRc) ? MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(lRc))
                      : S_OK );
    }

    /***************************************************************************
     *
     *  Debugging macros needed by inline functions
     *
     *  The build of debugging goo is in debug.h
     *
     ***************************************************************************/

    int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifdef DEBUG

    #define AssertFPtsz(c, ptsz) \
        ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
    #define ValidateF(c, arg) \
        ((c) ? 0 : (RPF arg, ValidationException(), 0))
    #define ConfirmF(c) \
    ((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))

#else   /* !DEBUG */

    #define AssertFPtsz(c, ptsz)
    #define ValidateF(c, arg)
    #define ConfirmF(c)     (c)

#endif

    /*
     *  CAssertF - compile-time assertion.
     */
#define CAssertF(c)     switch(0) case c: case 0:

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))

    /***************************************************************************
     *
     *                            Validation Code....
     *
     *  "If it crashes in retail, it must crash in debug."
     *
     *  What we don't want is an app that works fine under debug, but crashes
     *  under retail.
     *
     *  So if we find an invalid parameter in debug that would not have been
     *  detected by retail, let it pass through after a warning.  That way,
     *  the invalid parameter continues onward through the system and creates
     *  as much (or more) havoc in debug as it would under retail.
     *
     *  There used to be _fFastValidXxx functions, but the decision was made
     *  to do full validation always, except in inner-loop methods.
     *
     *  The hresFullValidXxx functions return HRESULTs instead of BOOLs.
     *
     *  Values for Xxx:
     *
     *      Hwnd      - hwnd = window handle
     *      Pdw       - pdw = pointer to a dword
     *      PdwOut    - pdw = pointer to a dword that will be set initially to 0
     *      Pfn       - pfn = function pointer
     *      riid      - riid = pointer to IID
     *      guid      - pguid = pointer to GUID
     *      Esc       - pesc = pointer to DIEFFESCAPE
     *
     *      ReadPx    - p -> structure for reading, X = structure name
     *      WritePx   - p -> structure for writing, X = structure name
     *
     *      ReadPxCb  - p -> structure for reading, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X).
     *
     *      WritePxCb - p -> structure for writing, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X).
     *
     *      WritePxCb2 - p -> structure for writing, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X) or cbX(X2).
     *
     *      ReadPvCb  - p -> buffer, cb = size of buffer
     *      WritePvCb - p -> buffer, cb = size of buffer
     *
     *      Pobj      - p -> internal interface
     *
     *      fl        - fl = incoming flags, flV = valid flags
     *
     ***************************************************************************/

#ifndef XDEBUG

    /*
     *  Wrappers that throw away the szProc and iarg info.
     */

    #define hresFullValidHwnd_(hwnd, z, i)                          \
       _hresFullValidHwnd_(hwnd)                                    \

    #define hresFullValidPcbOut_(pdw, cb, z, i)                         \
       _hresFullValidPcbOut_(pdw, cb)                                   \

    #define hresFullValidReadPxCb_(pv, cb, pszProc, iarg)           \
       _hresFullValidReadPxCb_(pv, cb)                              \

    #define hresFullValidReadPvCb_(pv, cb, pszProc, iarg)           \
       _hresFullValidReadPvCb_(pv, cb)                              \

    #define hresFullValidWritePxCb_(pv, cb, pszProc, iarg)          \
       _hresFullValidWritePxCb_(pv, cb)                             \

    #define hresFullValidWriteNoScramblePxCb_(pv, cb, pszProc, iarg)\
       _hresFullValidWriteNoScramblePxCb_(pv, cb)                   \

    #define hresFullValidWritePvCb_(pv, cb, pszProc, iarg)          \
       _hresFullValidWritePvCb_(pv, cb)                             \

    #define hresFullValidFl_(fl, flV, pszProc, iarg)                \
       _hresFullValidFl_(fl, flV)                                   \

    #define hresFullValidPfn_(pfn, pszProc, iarg)                   \
       _hresFullValidPfn_(pfn)                                      \

    #define hresFullValidPitf_(punk, pszProc, iarg)                 \
       _hresFullValidPitf_(punk)                                    \

    #define hresFullValidReadStrA_(psz, cch, pszProc, iarg)         \
       _hresFullValidReadStrA_(psz, cch)                            \

    #define hresFullValidReadStrW_(pwsz, cwch, pszProc, iarg)       \
       _hresFullValidReadStrW_(pwsz, cwch)                          \

    #define hresFullValidHwnd0_(hwnd, pszProc, iarg)                \
       _hresFullValidHwnd0_(hwnd)                                   \

    #define hresFullValidPitf0_(punk, pszProc, iarg)                \
       _hresFullValidPitf0_(punk)                                   \

    #define hresFullValidPesc_(pesc, pszProc, iarg)                 \
       _hresFullValidPesc_(pesc)                                    \

#endif

    /*
     *  The actual functions.
     */

    STDMETHODIMP hresFullValidHwnd_(HWND hwnd, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPcbOut_(PV pdw, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPfn_(FARPROC pfn, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPitf_(PUNK punk, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadStrA_(LPCSTR psz, UINT cch,
                                        LPCSTR s_szProc, int iarg);
    STDMETHODIMP hresFullValidReadStrW_(LPCWSTR pwsz, UINT cwch,
                                        LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPesc_(LPDIEFFESCAPE pesc, LPCSTR pszProc, int iarg);

#ifdef XDEBUG

    STDMETHODIMP
        hresFullValidWriteNoScramblePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg);

    #define hresFullValidWriteNoScramblePvCb_(pv, cb, pszProc, iarg)    \
        hresFullValidWritePvCb_(pv, cb, pszProc, MAKELONG(iarg, 1)) \

#else

    /*
     *  Retail doesn't scramble.
     */
    #define _hresFullValidWriteNoScramblePxCb_  \
        _hresFullValidWritePxCb_                \

    #define hresFullValidWriteNoScramblePvCb_   \
        hresFullValidWritePvCb_                 \

#endif

    HRESULT INLINE
        hresFullValidHwnd0_(HWND hwnd, LPCSTR pszProc, int iarg)
    {
        HRESULT hres;
        if(hwnd)
        {
            hres = hresFullValidHwnd_(hwnd, pszProc, iarg);
        } else
        {
            hres = S_OK;
        }
        return hres;
    }

    HRESULT INLINE
        hresFullValidPitf0_(PUNK punk, LPCSTR pszProc, int iarg)
    {
        HRESULT hres;
        if(punk)
        {
            hres = hresFullValidPitf_(punk, pszProc, iarg);
        } else
        {
            hres = S_OK;
        }
        return hres;
    }

    /*
     *  Wrappers for derived types.
     */

#define hresFullValidRiid_(riid, s_szProc, iarg)                    \
        hresFullValidReadPvCb_(riid, cbX(IID), s_szProc, iarg)      \

    /*
     *  Wrapers that add the szProc and iarg info.
     */

#define hresFullValidHwnd(hwnd, iarg)                               \
        hresFullValidHwnd_(hwnd, s_szProc, iarg)                    \

#define hresFullValidPcbOut(pdw, cb, i)                             \
        hresFullValidPcbOut_(pdw, cb, s_szProc, i)                  \

#define hresFullValidReadPdw_(pdw, z, i)                            \
        hresFullValidReadPvCb_(pdw, cbX(DWORD), z, i)               \

#define hresFullValidRiid(riid, iarg)                               \
        hresFullValidRiid_(riid, s_szProc, iarg)                    \

#define hresFullValidGuid(pguid, iarg)                              \
        hresFullValidReadPvCb_(pguid, cbX(GUID), s_szProc, iarg)    \

#define hresFullValidReadPxCb(pv, X, iarg)                          \
        hresFullValidReadPxCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidReadPxCb2(pv, X, X2, iarg)                     \
        hresFullValidReadPxCb_(pv, MAKELONG(cbX(X), cbX(X2)),       \
                               s_szProc, iarg)                      \

#define hresFullValidReadPvCb(pv, cb, iarg)                         \
        hresFullValidReadPvCb_(pv, cb, s_szProc, iarg)              \

#define hresFullValidReadPx(pv, X, iarg)                            \
        hresFullValidReadPvCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidWritePxCb(pv, X, iarg)                         \
        hresFullValidWritePxCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidWritePxCb2(pv, X, X2, iarg)                    \
        hresFullValidWritePxCb_(pv, MAKELONG(cbX(X), cbX(X2)),      \
                                s_szProc, iarg)                     \

#define hresFullValidWriteNoScramblePxCb(pv, X, iarg)               \
        hresFullValidWriteNoScramblePxCb_(pv, cbX(X), s_szProc, iarg)\

#define hresFullValidWriteNoScramblePxCb2(pv, X, X2, iarg)          \
        hresFullValidWriteNoScramblePxCb_(pv, MAKELONG(cbX(X), cbX(X2)),\
                                s_szProc, iarg)\

#define hresFullValidWritePvCb(pv, cb, iarg)                        \
        hresFullValidWritePvCb_(pv, cb, s_szProc, iarg)             \

#define hresFullValidWriteNoScramblePvCb(pv, cb, iarg)              \
        hresFullValidWriteNoScramblePvCb_(pv, cb, s_szProc, iarg)   \

#define hresFullValidWritePx(pv, X, iarg)                           \
        hresFullValidWritePvCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidReadPdw(pdw, iarg)                             \
        hresFullValidReadPdw_(pdw, s_szProc, iarg)                  \

#define hresFullValidWritePguid(pguid, iarg)                        \
        hresFullValidWritePx(pguid, GUID, iarg)                     \

#define hresFullValidFl(fl, flV, iarg)                              \
        hresFullValidFl_(fl, flV, s_szProc, iarg)                   \

#define hresFullValidPfn(pfn, iarg)                                 \
        hresFullValidPfn_((FARPROC)(pfn), s_szProc, iarg)           \

#define hresFullValidPitf(pitf, iarg)                               \
        hresFullValidPitf_((PUNK)(pitf), s_szProc, iarg)            \

#define hresFullValidReadStrA(psz, cch, iarg)                       \
        hresFullValidReadStrA_(psz, cch, s_szProc, iarg)            \

#define hresFullValidReadStrW(pwsz, cwch, iarg)                     \
        hresFullValidReadStrW_(pwsz, cwch, s_szProc, iarg)          \

#define hresFullValidHwnd0(hwnd, iarg)                              \
        hresFullValidHwnd0_(hwnd, s_szProc, iarg)                   \

#define hresFullValidPitf0(pitf, iarg)                              \
        hresFullValidPitf0_((PUNK)(pitf), s_szProc, iarg)           \

#define hresFullValidPesc(pesc, iarg)                               \
        hresFullValidPesc_(pesc, s_szProc, iarg)                    \

    /*****************************************************************************
     *
     *  @doc INTERNAL
     *
     *  @func   void | ValidationException |
     *
     *          Raises a parameter validation exception in XDEBUG.
     *
     *****************************************************************************/

#define ecValidation (ERROR_SEVERITY_ERROR | hresLe(ERROR_INVALID_PARAMETER))

#ifdef XDEBUG
    #define ValidationException() RaiseException(ecValidation, 0, 0, 0)
#else
    #define ValidationException()
#endif

    /*****************************************************************************
     *
     *      Bilingualism
     *
     *      Special macros that help writing ANSI and UNICODE versions of
     *      the same underlying interface.
     *
     *****************************************************************************/

    /*
     *  _THAT is something you tack onto the end of a "bilingual" interface.
     *  In debug, it expands to the magic third argument which represents
     *  the vtbl the object should have.  In retail, it expands to nothing.
     */
#ifdef XDEBUG
    #define _THAT , PV vtblExpected
    #define THAT_ , vtblExpected
#else
    #define _THAT
    #define THAT_
#endif


    /*
     *  CSET_STUBS creates stubs for ANSI and UNICODE versions of the
     *  same procedure that is not character set-sensitive.
     *
     *  mf   - method function name
     *  arg1 - argument list in prototype form
     *  arg2 - argument list for calling (with _riid appended).
     *
     *  It is assumed that the caller has already defined the symbols
     *  ThisClass and ThisInterface[AWT].  If a "2" interface is involved,
     *  then also define ThisInterface2.
     *
     *  This macro should be used only in DEBUG.  In retail, the common
     *  procedure handles both character sets directly.
     */
#ifdef XDEBUG

    #define   CSET_STUBS(mf, arg1, arg2)                                \
          CSET_STUB(TFORM, mf, arg1, arg2)                              \
          CSET_STUB(SFORM, mf, arg1, arg2)                              \

    #define   CSET_STUB(FORM, mf, arg1, arg2)                           \
         _CSET_STUB(FORM, mf, arg1, arg2, ThisClass, ThisInterface)     \

    #define  _CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                 \
        __CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                     \

    #define __CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                 \
STDMETHODIMP                                                            \
FORM(cls##_##mf) arg1                                                   \
{                                                                       \
    PV vtblExpected = Class_Vtbl(ThisClass, FORM(ThisInterfaceT));      \
    return cls##_##mf arg2;                                             \
}                                                                       \

    #define   CSET_STUBS2(mf, arg1, arg2)                               \
          CSET_STUB2(TFORM, mf, arg1, arg2)                             \
          CSET_STUB2(SFORM, mf, arg1, arg2)                             \

    #define   CSET_STUB2(FORM, mf, arg1, arg2)                          \
         _CSET_STUB2(FORM, mf, arg1, arg2, ThisClass, ThisInterface2)   \

    #define  _CSET_STUB2(FORM, mf, arg1, arg2, cls, itf)                \
        __CSET_STUB2(FORM, mf, arg1, arg2, cls, itf)                    \

    #define __CSET_STUB2(FORM, mf, arg1, arg2, cls, itf)                \
STDMETHODIMP                                                            \
FORM(cls##_##mf##2) arg1                                                \
{                                                                       \
    PV vtblExpected = Class_Vtbl(ThisClass, FORM(ThisInterface2T));     \
    return cls##_##mf arg2;                                             \
}                                                                       \

#endif

    /*
     * TFORM(x) expands to x##A if ANSI or x##W if UNICODE.
     *          This T-izes a symbol, in the sense of TCHAR or PTSTR.
     *
     * SFORM(x) expands to x##W if ANSI or x##A if UNICODE.
     *          This anti-T-izes a symbol.
     */

#ifdef UNICODE
    #define _TFORM(x) x##W
    #define _SFORM(x) x##A
#else
    #define _TFORM(x) x##A
    #define _SFORM(x) x##W
#endif

#define TFORM(x)    _TFORM(x)
#define SFORM(x)    _SFORM(x)

#ifdef UNICODE
    typedef  CHAR     SCHAR;
#else
    typedef WCHAR     SCHAR;
#endif

    typedef       SCHAR * LPSSTR;
    typedef const SCHAR * LPCSSTR;

    /*
     *  SToT(dst, cchDst, src) - convert S to T
     *  TToS(dst, cchDst, src) - convert T to S
     *
     *  Remember, "T" means "ANSI if ANSI, or UNICODE if UNICODE",
     *  and "S" is the anti-T.
     *
     *  So SToT converts to the preferred character set, and TToS converts
     *  to the alternate character set.
     *
     */

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
    #define SToT AToU
    #define TToS UToA
    #define AToT AToU
    #define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define UToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
    #define SToT UToA
    #define TToS AToU
    #define AToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define TToU AToU
    #define UToT UToA
#endif

    /*****************************************************************************
     *
     *      Unicode wrappers for Win95
     *
     *****************************************************************************/


#ifndef UNICODE

    #define LoadStringW     _LoadStringW
    int EXTERNAL LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch);

    #define RegDeleteKeyW   _RegDeleteKeyW
    LONG EXTERNAL RegDeleteKeyW(HKEY hk, LPCWSTR pwsz);

#endif

    /*****************************************************************************
     *
     *      Registry access functions
     *
     *****************************************************************************/
//our own version of KEY_ALL_ACCESS, that does not use WRITE_DAC and WRITE_OWNER (see Whistler bug 318865)
#define DI_DAC_OWNER (WRITE_DAC | WRITE_OWNER)
#define DI_KEY_ALL_ACCESS (KEY_ALL_ACCESS & ~DI_DAC_OWNER)

    LONG EXTERNAL
        RegQueryString(HKEY hk, LPCTSTR ptszValue, LPTSTR ptszBuf, DWORD ctchBuf);

    LONG EXTERNAL RegQueryStringValueW(HKEY hk, LPCTSTR ptszValue,
                                       LPWSTR pwszBuf, LPDWORD pcbBuf);

    LONG EXTERNAL RegSetStringValueW(HKEY hk, LPCTSTR ptszValue, LPCWSTR pwszBuf);

    DWORD EXTERNAL RegQueryDIDword(LPCTSTR ptszPath, LPCTSTR ptszValue, DWORD dwDefault);

    STDMETHODIMP
        hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk);

    STDMETHODIMP
        hresRegCopyValues( HKEY hkSrc, HKEY hkDest );

    STDMETHODIMP
        hresRegCopyKey( HKEY hkSrcRoot, PTCHAR szSrcName, PTCHAR szClass, HKEY hkDestRoot, PTCHAR szDestName, HKEY *phkSub );

    STDMETHODIMP
        hresRegCopyKeys( HKEY hkSrc, HKEY hkRoot, PDWORD OPTIONAL pMaxNameLen );

    STDMETHODIMP
        hresRegCopyBranch( HKEY hkSrc, HKEY hkDest );

    /*****************************************************************************
     *
     *      Common Object Managers for the Component Object Model
     *
     *      OLE wrapper macros and structures.  For more information, see
     *      the beginning of common.c
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *      Pre-vtbl structures
     *
     *      Careful!  If you change these structures, you must also adjust
     *      common.c accordingly.
     *
     *****************************************************************************/

    typedef struct PREVTBL
    {                /* Shared vtbl prefix */
        RIID riid;                          /* Type of this object */
        LONG lib;                           /* offset from start of object */
    } PREVTBL, *PPREVTBL;

    typedef struct PREVTBLP
    {               /* Prefix for primary vtbl */
#ifdef DEBUG
        LPCTSTR tszClass;                   /* Class name (for squirties) */
#endif
        PPV rgvtbl;                         /* Array of standard vtbls */
        UINT cbvtbl;                        /* Size of vtbl array in bytes */
        STDMETHOD(QIHelper)(PV pv, RIID riid, PPV ppvOut); /* QI helper */
        STDMETHOD_(void,AppFinalizeProc)(PV pv);/* App finalization procedure */
        STDMETHOD_(void,FinalizeProc)(PV pv);/* Finalization procedure */
        PREVTBL prevtbl;                    /* lib must be zero */
    } PREVTBLP, *PPREVTBLP;

    /*
     *      A fuller implementation is in common.c.  Out here, we need only
     *      concern ourselves with getting to the primary interface.
     */

#define _thisPv(pitf)                                                   \
        pvSubPvCb(pitf, (*(PPREVTBL*)(pitf))[-1].lib)

#define _thisPvNm(pitf, nm)                                             \
        pvSubPvCb(pitf, FIELD_OFFSET(ThisClass, nm))                    \

#ifndef XDEBUG

    #define hresPvVtbl_(pv, vtbl, pszProc)                              \
       _hresPvVtbl_(pv, vtbl)                                           \

    #define hresPvVtbl2_(pv, vtbl, vtbl2, pszProc)                      \
       _hresPvVtbl2_(pv, vtbl, vtbl2)                                   \

#endif

    HRESULT EXTERNAL
        hresPvVtbl_(PV pv, PV vtbl, LPCSTR pszProc);

    HRESULT EXTERNAL
        hresPvVtbl2_(PV pv, PV vtbl, PV vtbl2, LPCSTR pszProc);

#define hresPvVtbl(pv, vtbl)                                            \
        hresPvVtbl_(pv, vtbl, s_szProc)                                 \

#define hresPvVtbl2(pv, vtbl, vtbl2)                                    \
        hresPvVtbl2_(pv, vtbl, vtbl2, s_szProc)                         \

#define hresPvI(pv, I)                                                  \
        hresPvVtbl(pv, Class_Vtbl(ThisClass, I))                        \

#define hresPv2I(pv, I, I2)                                             \
        hresPvVtbl2(pv, Class_Vtbl(ThisClass, I), Class_Vtbl(ThisClass, I2)) \

#define hresPv(pv)                                                      \
        hresPvI(pv, ThisInterface)                                      \

#define hresPvA(pv)                                                     \
        hresPvI(pv, ThisInterfaceA)                                     \

#define hresPvW(pv)                                                     \
        hresPvI(pv, ThisInterfaceW)                                     \

#define hresPv2A(pv)                                                    \
        hresPv2I(pv, ThisInterfaceA, ThisInterface2A)                   \

#define hresPv2W(pv)                                                    \
        hresPv2I(pv, ThisInterfaceW, ThisInterface2W)                   \

#ifdef XDEBUG

    #define hresPvT(pv)                                                 \
        hresPvVtbl(pv, vtblExpected)                                    \

#else

    #define hresPvT(pv)                                                 \
        hresPv(pv)                                                      \

#endif

    /*****************************************************************************
     *
     *      Declaring interfaces
     *
     *      The extra level of indirection on _Primary_Interface et al
     *      allow the interface name to be a macro which expands to the
     *      *real* name of the interface.
     *
     *****************************************************************************/

#define __Class_Vtbl(C, I)              &c_##I##_##C##VI.vtbl
#define  _Class_Vtbl(C, I)            __Class_Vtbl(C, I)
#define   Class_Vtbl(C, I)             _Class_Vtbl(C, I)

#define Num_Interfaces(C)               cA(c_rgpv##C##Vtbl)

#ifdef  DEBUG

    #define Simple_Interface(C)             Primary_Interface(C, IUnknown); \
                                        Default_QueryInterface(C)       \
                                        Default_AddRef(C)               \
                                        Default_Release(C)
    #define Simple_Vtbl(C)                  Class_Vtbl(C)
    #define Simple_Interface_Begin(C)       Primary_Interface_Begin(C, IUnknown)
    #define Simple_Interface_End(C)         Primary_Interface_End(C, IUnknown)

#else

    #define Simple_Interface(C)             Primary_Interface(C, IUnknown)
    #define Simple_Vtbl(C)                  Class_Vtbl(C)
    #define Simple_Interface_Begin(C)                                   \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##IUnknown, 0 },                                     \
        }, {                                                            \
            Common##_QueryInterface,                                    \
            Common##_AddRef,                                            \
            Common##_Release,                                           \

    #define Simple_Interface_End(C)                                     \
        } };                                                            \

#endif

#define _Primary_Interface(C, I)                                        \
        extern struct S_##C##Vtbl {                                     \
            PREVTBLP prevtbl;                                           \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Primary_Interface(C, I)                                         \
       _Primary_Interface(C, I)                                         \

#ifdef DEBUG
    #define _Primary_Interface_Begin(C, I)                              \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            TEXT(#C),                                                   \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#else
    #define _Primary_Interface_Begin(C, I)                              \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#endif

#define Primary_Interface_Begin(C, I)                                   \
       _Primary_Interface_Begin(C, I)                                   \

#define Primary_Interface_End(C, I)                                     \
        } };                                                            \

#define _Secondary_Interface(C, I)                                      \
        extern struct S_##I##_##C##Vtbl {                               \
            PREVTBL prevtbl;                                            \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Secondary_Interface(C, I)                                       \
       _Secondary_Interface(C, I)                                       \

    /*
     *  Secret backdoor for the "private" IUnknown in common.c
     */
#define _Secondary_Interface_Begin(C, I, ofs, Pfx)                      \
        struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {                  \
            &IID_##I,                                                   \
            ofs,                                                        \
        }, {                                                            \
            Pfx##QueryInterface,                                        \
            Pfx##AddRef,                                                \
            Pfx##Release,                                               \

#define Secondary_Interface_Begin(C, I, nm)                             \
       _Secondary_Interface_Begin(C, I, FIELD_OFFSET(C, nm), Common_)   \

#define _Secondary_Interface_End(C, I)                                  \
        } };                                                            \

#define Secondary_Interface_End(C, I, nm)                               \
       _Secondary_Interface_End(C, I)                                   \

#define Interface_Template_Begin(C)                                     \
        PV c_rgpv##C##Vtbl[] = {                                        \

#define Primary_Interface_Template(C, I)                                \
        Class_Vtbl(C, I),                                               \

#define Secondary_Interface_Template(C, I)                              \
        Class_Vtbl(C, I),                                               \

#define Interface_Template_End(C)                                       \
        };                                                              \


    STDMETHODIMP Common_QueryInterface(PV, RIID, PPV);
    STDMETHODIMP_(ULONG) Common_AddRef(PV pv);
    STDMETHODIMP_(ULONG) Common_Release(PV pv);

    STDMETHODIMP_(void) Common_Hold(PV pv);
    STDMETHODIMP_(void) Common_Unhold(PV pv);

    STDMETHODIMP Common_QIHelper(PV, RIID, PPV);
    void EXTERNAL Common_Finalize(PV);

#define Common_AppFinalize      Common_Finalize

#ifndef XDEBUG

    #define _Common_New_(cb, punkOuter, vtbl, pvpObj, z)            \
       __Common_New_(cb, punkOuter, vtbl, pvpObj)                   \

    #define _Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj, z)  \
       __Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj)         \

#endif

    STDMETHODIMP
        _Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR s_szProc);

    STDMETHODIMP
        _Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV pvpObj,
                         LPCSTR s_szProc);

#define Common_NewCb(cb, C, punkOuter, ppvObj)                          \
       _Common_New_(cb, punkOuter, Class_Vtbl(C, ThisInterface), ppvObj, s_szProc)

#define Common_New(C, punkOuter, ppvObj)                                \
        Common_NewCb(cbX(C), C, punkOuter, ppvObj)                      \

#define Common_NewCbRiid(cb, C, punkOuter, riid, ppvObj) \
       _Common_NewRiid_(cb, Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#define Common_NewRiid(C, punkOuter, riid, ppvObj) \
   _Common_NewRiid_(cbX(C), Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#ifdef DEBUG
    PV EXTERNAL Common_IsType(PV pv);
#else
    #define Common_IsType
#endif
#define Assert_CommonType Common_IsType

    STDMETHODIMP Forward_QueryInterface(PV pv, RIID riid, PPV ppvObj);
    STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
    STDMETHODIMP_(ULONG) Forward_Release(PV pv);

    void EXTERNAL Invoke_Release(PV pv);

#define Common_DumpObjects()

    /*****************************************************************************
     *
     *      OLE wrappers
     *
     *      These basically do the same as IUnknown_Mumble, except that they
     *      avoid side-effects in evaluation by being inline functions.
     *
     *****************************************************************************/

    HRESULT INLINE
        OLE_QueryInterface(PV pv, RIID riid, PPV ppvObj)
    {
        PUNK punk = pv;
        return punk->lpVtbl->QueryInterface(punk, riid, ppvObj);
    }

    ULONG INLINE
        OLE_AddRef(PV pv)
    {
        PUNK punk = pv;
        return punk->lpVtbl->AddRef(punk);
    }

    ULONG INLINE
        OLE_Release(PV pv)
    {
        PUNK punk = pv;
        return punk->lpVtbl->Release(punk);
    }

    /*****************************************************************************
     *
     *      Macros that forward to the common handlers after squirting.
     *      Use these only in DEBUG.
     *
     *      It is assumed that sqfl has been #define'd to the appropriate sqfl.
     *
     *****************************************************************************/

#ifdef  DEBUG

    #define Default_QueryInterface(Class)                       \
STDMETHODIMP                                                    \
Class##_QueryInterface(PV pv, RIID riid, PPV ppvObj)            \
{                                                               \
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_QueryInterface()")); \
    return Common_QueryInterface(pv, riid, ppvObj);             \
}                                                               \

// 7/21/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    #define Default_AddRef(Class)                               \
STDMETHODIMP_(ULONG)                                            \
Class##_AddRef(PV pv)                                           \
{                                                               \
    ULONG ulRc = Common_AddRef(pv);                             \
    SquirtSqflPtszV(sqfl, TEXT(#Class)                          \
                        TEXT("_AddRef(%p) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

// 7/21/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    #define Default_Release(Class)                              \
STDMETHODIMP_(ULONG)                                            \
Class##_Release(PV pv)                                          \
{                                                               \
    ULONG ulRc = Common_Release(pv);                            \
    SquirtSqflPtszV(sqfl, TEXT(#Class)                          \
                       TEXT("_Release(%p) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

#endif

    /*****************************************************************************
     *
     *      Paranoid callbacks
     *
     *      Callback() performs a callback.  The callback must accept exactly
     *      two parameters, both pointers.  (All our callbacks are like this.)
     *      And it must return a BOOL.
     *
     *****************************************************************************/

    typedef BOOL (FAR PASCAL * DICALLBACKPROC)(LPVOID, LPVOID);

#ifdef XDEBUG
    BOOL EXTERNAL Callback(DICALLBACKPROC, PVOID, PVOID);
#else
    #define Callback(pec, pv1, pv2) pec(pv1, pv2)
#endif

#if 0
    /*****************************************************************************
     *
     *      Groveling into a CONTEXT structure.
     *
     *      This is used to check that a callback procedure is properly
     *      prototyped.  We save the stack register before calling the
     *      procedure and compare it with the stack register on the way back.
     *      If they are different, explode!
     *
     *      ctxEsp is the name of the stack pointer register.
     *
     *****************************************************************************/

    typedef struct STACKINFO
    {
        CONTEXT ctxPre;             /* Thread context before call */
        CONTEXT ctxPost;            /* Thread context after call */
    } STACKINFO, *PSTACKINFO;

    #ifdef XDEBUG

        #if defined(_X86_)
            #define ctxEsp  Esp

        #elif defined(_ALPHA_)
            #define ctxEsp  IntSp

        #elif defined(_MIPS_)
            #define ctxEsp  IntSp

        #elif defined(_PPC_)
            #define ctxEsp  Gpr1

        #else
            #pragma message("I don't know what the stack register is called on this platform")
        #endif

    #endif

    #ifdef ctxEsp

        #define DECLARE_STACKINFO()                                         \
    STACKINFO si                                                            \

        #define PRE_CALLBACK()                                              \
    si.ctxPre.ContextFlags = CONTEXT_CONTROL;                               \
    GetThreadContext(GetCurrentThread(), &si.ctxPre)                        \

        #define POST_CALLBACK()                                             \
    si.ctxPost.ContextFlags = CONTEXT_CONTROL;                              \
    if (GetThreadContext(GetCurrentThread(), &si.ctxPost) &&                \
        si.ctxPre.ctxEsp != si.ctxPost.ctxEsp) {                            \
        RPF("DINPUT: Incorrectly prototyped callback! Crash soon!");        \
        ValidationException();                                              \
    }                                                                       \

    #else

        #define DECLARE_STACKINFO()
        #define PRE_CALLBACK()
        #define POST_CALLBACK()

    #endif

#endif

    /*****************************************************************************
     *
     *      Alternative message cracker macros
     *
     *      Basically the same as HANDLE_MSG, except that it stashes the
     *      answer into hres.
     *
     *****************************************************************************/

#define HRES_MSG(this, msg, fn) \
    case msg: hres = HANDLE_##msg(this, wParam, lParam, fn); break

    /*****************************************************************************
     *
     *      Registry keys and value names
     *
     *****************************************************************************/

#define REGSTR_PATH_DINPUT      TEXT("Software\\Microsoft\\DirectInput")
#define REGSTR_PATH_LASTAPP     REGSTR_PATH_DINPUT TEXT("\\MostRecentApplication\\")
#define REGSTR_PATH_DITYPEPROP  REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\DirectInput")
#define REGSTR_KEY_APPHACK      TEXT("Compatibility")
#define REGSTR_KEY_TEST         TEXT("Test")
#define REGSTR_KEY_KEYBTYPE     REGSTR_KEY_TEST TEXT("\\KeyboardType")
#define REGSTR_VAL_EMULATION    TEXT("Emulation")
#define REGSTR_VAL_GAMEPADDELAY TEXT("GamepadDelay")
#define REGSTR_VAL_JOYNFFCONFIG TEXT("Joystick%dFFConfiguration")
#define REGSTR_VAL_JOYGAMEPORTEMULATOR TEXT("OEMEmulator")
#define REGSTR_VAL_CPLCLSID     TEXT("ConfigCLSID")
#define REGSTR_KEY_JOYPREDEFN   TEXT("predef%d")
#define REGSTR_VAL_JOYOEMCALLOUT TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMHARDWAREID TEXT("OEMHardwareID")
#define REGSTR_VAL_FLAGS1       TEXT("Flags1")
#define REGSTR_VAL_FLAGS2       TEXT("Flags2")
    /*****************************************************************************
     *
     *      Registered window messages
     *
     *****************************************************************************/

#define MSGSTR_JOYCHANGED       TEXT("MSJSTICK_VJOYD_MSGSTR")

    /*****************************************************************************
     *
     *      mem.c - Memory management
     *
     *      Be extremely careful with FreePv, because it doesn't work if
     *      the pointer is null.
     *
     *****************************************************************************/

#define NEED_REALLOC

    STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
    STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#ifdef NEED_REALLOC
    #define FreePpv(ppv) (void)ReallocCbPpv(0, ppv)
#else
    void EXTERNAL FreePpv(PV ppv);
    #define FreePpv(ppv) FreePpv(ppv)
#endif
#define FreePv(pv) LocalFree((HLOCAL)(pv))

    /*****************************************************************************
     *
     *      diutil.c - Misc utilities
     *
     *****************************************************************************/

    extern GUID GUID_Null;

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

    BOOL EXTERNAL ParseGUID(LPGUID pGUID, LPCTSTR ptsz);
    BOOL EXTERNAL ParseVIDPID(PUSHORT puVID, PUSHORT puPID , LPCWSTR ptsz);

#define ctchNamePrefix  12              /* 12 = strlen("DirectInput.") */
#define ctchNameGuid    (ctchNamePrefix + ctchGuid)
    void EXTERNAL NameFromGUID(LPTSTR ptszBuf, PCGUID pGUID);

    typedef STDMETHOD(CREATEDCB)(PUNK, REFGUID, RIID, PPV);

    typedef struct DIOBJECTSTATICDATA
    {
        union
        {
            PCGUID rguidInstance;       /* If a static device */
            UINT   uiButtons;           /* If a HID mouse */
        };
        DWORD   dwDevType;
        union
        {
            CREATEDCB CreateDcb;        /* If a static device */
            UINT      uiAxes;           /* If a HID mouse */
        };
    } DIOBJECTSTATICDATA, *PDIOBJECTSTATICDATA, **PPDIOBJECTSTATICDATA;

    HRESULT EXTERNAL hresRunControlPanel(LPCTSTR ptszCpl);

    void EXTERNAL DeviceInfoWToA(LPDIDEVICEINSTANCEA pdiA,
                                 LPCDIDEVICEINSTANCEW pdiW);

    void EXTERNAL ObjectInfoWToA(LPDIDEVICEOBJECTINSTANCEA pdoiA,
                                 LPCDIDEVICEOBJECTINSTANCEW pdoiW);

#ifdef IDirectInputDevice2Vtbl
    void EXTERNAL EffectInfoWToA(LPDIEFFECTINFOA pdeiA,
                                 LPCDIEFFECTINFOW pdeiW);

#endif

#ifndef XDEBUG

    #define hresFindInstanceGUID_(pGUID, pcdcb, z, i)               \
       _hresFindInstanceGUID_(pGUID, pcdcb)                         \

    #define hresValidInstanceVer_(hinst, dwVer, z)                  \
       _hresValidInstanceVer_(hinst, dwVer)                         \

#endif

    HRESULT EXTERNAL hresFindInstanceGUID_(PCGUID pGUID, CREATEDCB *pcdcb,
                                           LPCSTR s_szProc, int iarg);

    HRESULT EXTERNAL
        hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc);

#define hresFindInstanceGUID(pGuid, pcdcb, iarg)                    \
        hresFindInstanceGUID_(pGuid, pcdcb, s_szProc, iarg)         \

#define hresValidInstanceVer(hinst, dwVer)                          \
        hresValidInstanceVer_(hinst, dwVer, s_szProc)               \

    HRESULT EXTERNAL DupEventHandle(HANDLE h, LPHANDLE phOut);
    DWORD EXTERNAL GetWindowPid(HWND hwnd);

    PV EXTERNAL pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt);

    void EXTERNAL GetNthString(LPWSTR pwsz, UINT ids, UINT ui);

#define GetNthButtonString(pwsz, ui)    \
        GetNthString(pwsz, IDS_BUTTONTEMPLATE, ui)

#define GetNthAxisString(pwsz, ui)      \
        GetNthString(pwsz, IDS_AXISTEMPLATE, ui)

#define GetNthPOVString(pwsz, ui)       \
        GetNthString(pwsz, IDS_POVTEMPLATE, ui)

    HRESULT EXTERNAL hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst);

    BOOL EXTERNAL fInitializeCriticalSection(LPCRITICAL_SECTION pCritSec);

    void EXTERNAL DiCharUpperW(LPWSTR pwsz);

#define WIN_UNKNOWN_OS 0
#define WIN95_OS       1
#define WIN98_OS       2
#define WINME_OS       3
#define WINNT_OS       4
#define WINWH_OS       5

    DWORD INTERNAL DIGetOSVersion();

    /*****************************************************************************
     *
     *      dilist.c
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct GPA |
     *
     *          Growable pointer array.
     *
     *  @field  PPV | rgpv |
     *
     *          The base of the array of pointers.
     *
     *  @field  int | cpv |
     *
     *          The number of pointers in use in the array.
     *
     *  @field  int | cpvAlloc |
     *
     *          The number of pointers allocated in the array.
     *
     *****************************************************************************/

    typedef struct GPA
    {

        PPV rgpv;
        int cpv;
        int cpvAlloc;

    } GPA, *HGPA;

    void EXTERNAL GPA_Init(HGPA hgpa);
    void EXTERNAL GPA_Term(HGPA hgpa);

    STDMETHODIMP GPA_Append(HGPA hgpa, PV pv);
    BOOL EXTERNAL GPA_FindPtr(HGPA hgpa, PV pv);
    STDMETHODIMP GPA_DeletePtr(HGPA hgpa, PV pv);
    STDMETHODIMP GPA_Clone(HGPA hgpaDst, HGPA hgpaSrc);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   void | GPA_InitFromZero |
     *
     *          Initialize a GPA structure that is already zero-initialized.
     *
     *  @parm   HGPA | hgpa |
     *
     *          Handle to pointer array.
     *
     *****************************************************************************/

    /*
     *  Nothing needs to be done; zero-init is just fine.
     *
     *  Note: didev.c also has a global GPA, and it assumes that zero-init
     *  is just fine.
     */
#define GPA_InitFromZero(hgpa)

    /*****************************************************************************
     *
     *      dioledup.c
     *
     *****************************************************************************/

    STDMETHODIMP
        DICoCreateInstance(LPTSTR ptszClsid, LPUNKNOWN punkOuter,
                           RIID riid, PPV ppvOut, HINSTANCE *phinst);

    /*****************************************************************************
     *
     *      diexcl.c - Exclusive access management
     *
     *      We also keep GUID uniqueness goo up here, because it is
     *      diexcl.c that manages shared memory.
     *
     *****************************************************************************/

    STDMETHODIMP Excl_Acquire(PCGUID pguid, HWND hwnd, DWORD discl);
    void EXTERNAL Excl_Unacquire(PCGUID pguid, HWND hwnd, DWORD discl);
    STDMETHODIMP Excl_Init(void);

    LONG  EXTERNAL Excl_UniqueGuidInteger(void);
    DWORD EXTERNAL Excl_GetConfigChangedTime();
    void  EXTERNAL Excl_SetConfigChangedTime(DWORD tm);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct GLOBALJOYSTATE |
     *
     *          Structure that records global joystick state information.
     *
     *  @field  DWORD | dwTag |
     *
     *          Counter used to keep track of how many times each joystick's
     *          force feedback driver has been reset.  This is used to make
     *          sure that nobody messes with a joystick that he doesn't own.
     *
     *          Each time the joystick is reset, the corresponding counter
     *          is incremented.  Before we do anything to a device, we check
     *          if the reset counter matches the value stored in the
     *          object.  If not, then it means that the device has been
     *          reset in the meantime and no longer belongs to the caller.
     *
     *  @field  DWORD | dwCplGain |
     *
     *          Control panel (global) gain setting for the joystick.
     *
     *  @field  DWORD | dwDevGain |
     *
     *          Most recent device (local) gain applied to the joystick.
     *
     *          This is cached so that when the global gain changes,
     *          we know what physical gain to apply as a result.
     *
     *****************************************************************************/

    typedef struct GLOBALJOYSTATE
    {
        DWORD   dwTag;
        DWORD   dwCplGain;
        DWORD   dwDevGain;
    } GLOBALJOYSTATE, *PGLOBALJOYSTATE;

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct SHAREDOBJECTHEADER |
     *
     *          A simple header comes in front of the array of objects.
     *
     *          WARNING!  This structure may not change between DEBUG and
     *          RETAIL.  Otherwise, you have problems if one DirectInput
     *          app is using DEBUG and another is using RETAIL.
     *
     *          The global <c g_gsop> variable points to one of these things,
     *          suitably cast.
     *
     *  @field  int | cso |
     *
     *          Number of <t SHAREDOBJECT>s currently in use.  The array
     *          is kept packed for simplicity.
     *
     *  @field  DWORD | dwSequence |
     *
     *          Global sequence number used during data collection.
     *          (Not used if we have a VxD to manage a "really global"
     *          sequence number.)
     *
     *  @field  int | cguid |
     *
     *          Unique integer for GUID generation.
     *
     *  @field  DWORD | rgdwJoy[cMaxJoy] |
     *
     *          Counter used to keep track of how many times each joystick's
     *          force feedback driver has been reset.  This is used to make
     *          sure that nobody messes with a joystick that they don't own.
     *
     *          Each time the joystick is reset, the corresponding counter
     *          is incremented.  Before we do anything to a device, we check
     *          if the reset counter matches the value stored in the
     *          object.  If not, then it means that the device has been
     *          reset in the meantime and no longer belongs to the caller.
     *
     *          Note!  We support up to 16 joysticks.  Hope that'll be enough
     *          for a while.
     *
     *  @field  GLOBALJOYSTATE | rggjs[cMaxJoy] |
     *
     *          Global settings for each joystick.
     *
     *  @field  DWORD | tmConfigChanged
     *
     *          The tick count of last config changed.
     *
     *****************************************************************************/

#define cJoyMax     16              /* Up to 16 joysticks */
    typedef struct SHAREDOBJECTHEADER
    {
        int cso;
        DWORD dwSequence;
        int cguid;
        GLOBALJOYSTATE rggjs[cJoyMax];
        DWORD tmConfigChanged;
    } SHAREDOBJECTHEADER, *PSHAREDOBJECTHEADER;

#define g_psoh  ((PSHAREDOBJECTHEADER)g_psop)

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @topic  The Worker Thread |
     *
     *          Some emulation behaviors (low-level hooks, HID) require
     *          a worker thread to do the data collection.  We multiplex
     *          all such work onto a single worker thread (known as
     *          simple "the" worker thread).
     *
     *          The thread is spun up when the first client needs it
     *          and is taken down when the last client has been released.
     *
     *          To prevent race conditions from crashing us, we addref
     *          our DLL when the thread exists and have the thread
     *          perform a FreeLibrary as its final act.
     *
     *****************************************************************************/

#if defined(USE_SLOW_LL_HOOKS) || defined(HID_SUPPORT)
    #define WORKER_THREAD
#endif

    /*****************************************************************************
     *
     *      diem.c - Emulation
     *
     *****************************************************************************/

    HRESULT EXTERNAL CEm_AcquireInstance(PVXDINSTANCE *ppvi);
    HRESULT EXTERNAL CEm_UnacquireInstance(PVXDINSTANCE *ppvi);
    HRESULT EXTERNAL CEm_SetBufferSize(PVXDDWORDDATA pvdd);
    HRESULT EXTERNAL CEm_DestroyInstance(PVXDINSTANCE *ppvi);

    HRESULT EXTERNAL CEm_SetDataFormat(PVXDDATAFORMAT pvdf);

    HRESULT EXTERNAL CEm_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                              PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Mouse_InitButtons(PVXDDWORDDATA pvdd);

    HRESULT EXTERNAL CEm_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Kbd_InitKeys(PVXDDWORDDATA pvdd);

    HRESULT EXTERNAL CEm_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Joy_Ping(PVXDINSTANCE *ppvi);

    HRESULT EXTERNAL CEm_HID_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    /*****************************************************************************
     *
     *      diemm.c - Mouse Emulation
     *
     *****************************************************************************/

    void EXTERNAL    CEm_Mouse_AddState(LPDIMOUSESTATE_INT pms, DWORD tm);

    /*****************************************************************************
     *
     *      dinput.c - Basic DLL stuff
     *
     *****************************************************************************/

    void EXTERNAL DllEnterCrit_(LPCTSTR lptszFile, UINT line);
    void EXTERNAL DllLeaveCrit_(LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL EXTERNAL DllInCrit(void);
    #define DllEnterCrit() DllEnterCrit_(TEXT(__FILE__), __LINE__)
    #define DllLeaveCrit() DllLeaveCrit_(TEXT(__FILE__), __LINE__)
#else
    #define DllEnterCrit() DllEnterCrit_(NULL, 0x0)
    #define DllLeaveCrit() DllLeaveCrit_(NULL, 0x0)
#endif

    void EXTERNAL DllAddRef(void);
    void EXTERNAL DllRelease(void);

    void EXTERNAL DllLoadLibrary(void);
    void EXTERNAL DllFreeLibrary(void);

#ifdef DEBUG

    extern UINT g_thidCrit;

    #define InCrit() (g_thidCrit == GetCurrentThreadId())

#endif

    /*
     *  Describes the CLSIDs we provide to OLE.
     */

    typedef STDMETHOD(CREATEFUNC)(PUNK punkOuter, RIID riid, PPV ppvOut);

    typedef struct CLSIDMAP
    {
        REFCLSID rclsid;        /* The clsid */
        CREATEFUNC pfnCreate;   /* How to create it */
        UINT    ids;            /* String that describes it */
    } CLSIDMAP, *PCLSIDMAP;

#ifdef DEBUG
    #define DEMONSTRATION_FFDRIVER
    #define cclsidmap   3       /* DirectInput, DirectInputDevice, DIEffectDiver */
#else
    #define cclsidmap   2       /* CLSID_DirectInput, CLSID_DirectInputDevice */
#endif

    extern CLSIDMAP c_rgclsidmap[cclsidmap];

    /*****************************************************************************
     *
     *      dicf.c - IClassFactory implementation
     *
     *****************************************************************************/

    STDMETHODIMP CDIFactory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      didenum.c - IDirectInput device enumeration
     *
     *****************************************************************************/

    typedef struct CDIDEnum CDIDEnum;

    extern GUID rgGUID_Joystick[cJoyMax];

#define GUID_Joystick (rgGUID_Joystick[0])

    void EXTERNAL CDIDEnum_Release(CDIDEnum *pde);
    STDMETHODIMP CDIDEnum_Next(CDIDEnum *pde, LPDIDEVICEINSTANCEW pddiW);
    STDMETHODIMP
        CDIDEnum_New(PDIW pdiW, DWORD dwDevType, DWORD edfl, DWORD dwVer, CDIDEnum **);

    /*****************************************************************************
     *
     *      diobj.c - IDirectInput implementation
     *
     *****************************************************************************/

    HRESULT EXTERNAL CDIObj_TestDeviceFlags(PDIDW pdidW, DWORD diedfl);
    HRESULT EXTERNAL CDIObj_FindDeviceInternal(LPCTSTR ptszName, LPGUID pguidOut);

    STDMETHODIMP CDIObj_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      diaddhw.c - AddNewHardware
     *
     *****************************************************************************/

    HRESULT EXTERNAL AddNewHardware(HWND hwnd, REFGUID rguid);

    /*****************************************************************************
     *
     *      dijoycfg.c - IDirectInputJoyConfig implementation
     *
     *****************************************************************************/

    STDMETHODIMP CJoyCfg_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *  @doc    INLINE
     *
     *  @method BOOL | IsWriteSam |
     *
     *          Nonzero if the registry security access mask will
     *          obtain (or attempt to obtain) write access.
     *
     *  @parm   REGSAM | regsam |
     *
     *          Registry security access mask.
     *
     *****************************************************************************/

    BOOL INLINE
        IsWriteSam(REGSAM sam)
    {
        return sam & (KEY_SET_VALUE | KEY_CREATE_SUB_KEY | MAXIMUM_ALLOWED);
    }

    /*****************************************************************************
     *
     *      dijoyreg.c - Joystick registry services
     *
     *****************************************************************************/
    extern LPCWSTR c_rghwIdPredef[];

    STDMETHODIMP JoyReg_OpenTypeKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk);
    STDMETHODIMP JoyReg_OpenFFKey(HKEY hkType, REGSAM sam, PHKEY phk);

    STDMETHODIMP
        JoyReg_OpenConfigKey(UINT idJoy, DWORD sam, PJOYCAPS pcaps, DWORD dwOptions, PHKEY phk);

    STDMETHODIMP JoyReg_OpenPropKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk);

    STDMETHODIMP JoyReg_GetTypeInfo(LPCWSTR pwszType,
                                    LPDIJOYTYPEINFO pjti, DWORD fl);
    STDMETHODIMP JoyReg_SetTypeInfo(HKEY hkTypesW, LPCWSTR pwszType,
                                    LPCDIJOYTYPEINFO pjti, DWORD fl);

    STDMETHODIMP JoyReg_GetConfig(UINT idJoy, PJOYCAPS pcaps,
                                  LPDIJOYCONFIG pcfg, DWORD fl);
    STDMETHODIMP JoyReg_SetConfig(UINT idJoy, LPJOYREGHWCONFIG phwc,
                                  LPCDIJOYCONFIG pcfg, DWORD fl);

    STDMETHODIMP JoyReg_GetUserValues(LPDIJOYUSERVALUES pjuv, DWORD fl);
    STDMETHODIMP JoyReg_SetUserValues(LPCDIJOYUSERVALUES pjuv, DWORD fl);


    STDMETHODIMP
        JoyReg_GetSetConfigValue(HKEY hk, LPCTSTR ptszNValue, UINT idJoy,
                                 DWORD reg, PV pvBuf, DWORD cb, BOOL fSet);

#define GSCV_GET        0
#define GSCV_SET        1

#define JoyReg_GetConfigValue(hk, ptsz, id, reg, pv, cb) \
        JoyReg_GetSetConfigValue(hk, ptsz, id, reg, pv, cb, GSCV_GET)

#define JoyReg_SetConfigValue(hk, ptsz, id, reg, pv, cb) \
        JoyReg_GetSetConfigValue(hk, ptsz, id, reg, (PV)(pv), cb, GSCV_SET)


    STDMETHODIMP
        JoyReg_GetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PV pvBuf, DWORD cb);

    STDMETHODIMP
        JoyReg_IsWdmGameport(HKEY hk);

#if 0
    STDMETHODIMP
        JoyReg_IsWdmGameportFromDeviceInstance( LPTSTR ptszDeviceInst );
#endif

    STDMETHODIMP
        JoyReg_SetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PCV pvBuf, DWORD cb);

    LPSTR EXTERNAL
        JoyReg_JoyIdToDeviceInterface_95(UINT idJoy, PVXDINITPARMS pvip, LPSTR ptszBuf);

    HRESULT EXTERNAL
        JoyReg_GetPredefTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl);

    HRESULT EXTERNAL
        hResIdJoypInstanceGUID_95( UINT idJoy, LPGUID  lpguid);

    HRESULT EXTERNAL
        hResIdJoypInstanceGUID_WDM( UINT idJoy, LPGUID  lpguid);

#if 0
    HRESULT EXTERNAL JoyReg_GetIDByOemName( LPTSTR szOemName, PUINT pId );
#endif
/*****************************************************************************
*
*      didev.c - IDirectInputDevice implementation
*
*****************************************************************************/

    STDMETHODIMP CDIDev_New(PUNK punkOuter, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      CDIDev_Enter/LeaveCrit are secret backdoors to allow emulation
     *      and effects
     *      to take the device critical section when updating buffers.
     *
     *      CDIDev_InCrit is used for assertion checking.
     *
     *      CDIDev_IsExclAcquired is used by effects to make sure the parent
     *      is acquired for exclusive before attempting to download.
     *
     *      CDIDev_SyncShepHandle is used to get the joystick "tag" which
     *      is used by dieshep.c to determine who owns the joystick.
     *
     *****************************************************************************/

    void EXTERNAL CDIDev_EnterCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line);
    void EXTERNAL CDIDev_LeaveCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL INTERNAL CDIDev_InCrit(struct CDIDev *this);
    #define CDIDev_EnterCrit(cdidev) CDIDev_EnterCrit_(cdidev, TEXT(__FILE__), __LINE__)
    #define CDIDev_LeaveCrit(cdidev) CDIDev_LeaveCrit_(cdidev, TEXT(__FILE__), __LINE__)
#else
    #define CDIDev_EnterCrit(cdidev) CDIDev_EnterCrit_(cdidev, NULL, 0x0);
    #define CDIDev_LeaveCrit(cdidev) CDIDev_LeaveCrit_(cdidev, NULL, 0x0);
#endif

#ifndef XDEBUG

    #define CDIDev_IsExclAcquired_(pdd, z)                          \
       _CDiDev_IsExclAcquired_(pdd)                                 \

#endif

    STDMETHODIMP CDIDev_IsExclAcquired_(struct CDIDev *this, LPCSTR s_szProc);

#define CDIDev_IsExclAcquired(pdd)                                  \
        CDIDev_IsExclAcquired_(pdd, s_szProc)                       \


    STDMETHODIMP CDIDev_SyncShepHandle(struct CDIDev *this, PSHEPHANDLE psh);

    /*****************************************************************************
     *
     *      CDIDev_SetNotifyEvent is used by the emulation code to
     *      notify the application when the state of the device changes.
     *
     *****************************************************************************/

    void EXTERNAL CDIDev_SetNotifyEvent(struct CDIDev *this);
    void EXTERNAL CDIDev_SetForcedUnacquiredFlag(struct CDIDev *this);

    /*****************************************************************************
     *
     *      CDIDev_NotifyCreate/DestroyEvent is used by CDIEff to
     *      let the parent know when a child effect comes or goes.
     *
     *      CDIDev_FindEffectGUID is used by CDIEff to convert an
     *      effect GUID into an effect cookie dword.
     *
     *      CDIDev_ConvertObjects converts item identifiers in various ways.
     *
     *****************************************************************************/

    HRESULT EXTERNAL
        CDIDev_NotifyCreateEffect(struct CDIDev *this, struct CDIEff *pdeff);
    HRESULT EXTERNAL
        CDIDev_NotifyDestroyEffect(struct CDIDev *this, struct CDIEff *pdeff);

#ifdef IDirectInputDevice2Vtbl
    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct EFFECTMAPINFO |
     *
     *          Information about an effect, much like a
     *          <t DIEFFECTINFO>, but containing the
     *          effect ID, too.
     *
     *  @field  DWORD | dwId |
     *
     *          The effect ID.  This comes first so we can copy
     *          an <t EFFECTMAPINFO> into a <t DIEFFECTINFO>
     *          all at one go.
     *
     *  @field  GUID | guid |
     *
     *          The effect GUID.
     *
     *  @field  DWORD | dwEffType |
     *
     *          The effect type and flags.
     *
     *  @field  WCHAR | wszName[MAX_PATH] |
     *
     *          The name for the effect.
     *
     *****************************************************************************/

    typedef struct EFFECTMAPINFO
    {
        DIEFFECTATTRIBUTES attr;
        GUID    guid;
        WCHAR   wszName[MAX_PATH];
    } EFFECTMAPINFO, *PEFFECTMAPINFO;
    typedef const EFFECTMAPINFO *PCEFFECTMAPINFO;

    #ifndef XDEBUG

        #define CDIDev_FindEffectGUID_(this, rguid, pemi, z, i)     \
       _CDIDev_FindEffectGUID_(this, rguid, pemi)                   \

    #endif

    #define CDIDev_FindEffectGUID(this, rguid, pemi, iarg)          \
        CDIDev_FindEffectGUID_(this, rguid, pemi, s_szProc, iarg)   \


    STDMETHODIMP
        CDIDev_FindEffectGUID_(struct CDIDev *this, REFGUID rguid,
                               PEFFECTMAPINFO pemi, LPCSTR s_szProc, int iarg);

    STDMETHODIMP
        CDIDev_ConvertObjects(struct CDIDev *this, UINT cdw, LPDWORD rgdw, UINT fl);

    /*
     *  Note that the bonus DEVCO flags live inside the DIDFT_INSTANCEMASK.
     */
    #define DEVCO_AXIS              DIDFT_AXIS
    #define DEVCO_BUTTON            DIDFT_BUTTON
    #define DEVCO_TYPEMASK          DIDFT_TYPEMASK

    #define DEVCO_FFACTUATOR        DIDFT_FFACTUATOR
    #define DEVCO_FFEFFECTTRIGGER   DIDFT_FFEFFECTTRIGGER
    #define DEVCO_ATTRMASK          DIDFT_ATTRMASK

    #define DEVCO_FROMID            0x00000100
    #define DEVCO_FROMOFFSET        0x00000200
    #define DEVCO_FROMMASK          0x00000300
    #define DEVCO_TOID              0x00001000
    #define DEVCO_TOOFFSET          0x00002000
    #define DEVCO_TOMASK            0x00003000


    #if ((DEVCO_FROMMASK | DEVCO_TOMASK) & DIDFT_INSTANCEMASK) !=       \
     (DEVCO_FROMMASK | DEVCO_TOMASK)
        #error DEVCO_FROMMASK and DEVCI_TOMASK should not escape DIDFT_INSTANCEMASK.
    #endif

    #define DEVCO_VALID          (DEVCO_TYPEMASK |      \
                                 DEVCO_ATTRMASK |       \
                                 DEVCO_FROMMASK |       \
                                 DEVCO_TOMASK)

#endif

    /*****************************************************************************
     *
     *      dieffv.c - IDirectInputEffectDriver for VJoyD joysticks
     *
     *****************************************************************************/

    STDMETHODIMP CEffVxd_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dieshep.c - IDirectInputEffectShepherd
     *
     *****************************************************************************/

    STDMETHODIMP CEShep_New(HKEY hk, PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digendef.c - Default IDirectInputDeviceCallback
     *
     *****************************************************************************/

    /*
     *  We can't call it a DCB because winbase.h already has one for
     *  comm goo.
     */

    typedef IDirectInputDeviceCallback DICB, *PDICB;

    STDMETHODIMP
        CDefDcb_Acquire(PDICB pdcb);

    STDMETHODIMP
        CDefDcb_Unacquire(PDICB pdcb);

    STDMETHODIMP
        CDefDcb_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph);

    STDMETHODIMP
        CDefDcb_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph);

    STDMETHODIMP
        CDefDcb_SetEventNotification(PDICB pdcb, HANDLE h);

    STDMETHODIMP
        CDefDcb_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags);

    STDMETHODIMP
        CDefDcb_CookDeviceData(PDICB pdcb, UINT cdod, LPDIDEVICEOBJECTDATA rgdod);

    STDMETHODIMP
        CDefDcb_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes);

    STDMETHODIMP
        CDefDcb_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk);

    STDMETHODIMP
        CDefDcb_SendDeviceData(PDICB pdcb, LPCDIDEVICEOBJECTDATA rgdod,
                               LPDWORD pdwInOut, DWORD fl);

    STDMETHODIMP
        CDefDcb_Poll(IDirectInputDeviceCallback *pdcb);

    STDMETHODIMP
        CDefDcb_GetVersions(IDirectInputDeviceCallback *pdcb, LPDIDRIVERVERSIONS pvers);

    STDMETHODIMP
        CDefDcb_MapUsage(IDirectInputDeviceCallback *pdcb, DWORD dwUsage, PINT piOut);

    STDMETHODIMP_(DWORD)
        CDefDcb_GetUsage(IDirectInputDeviceCallback *pdcb, int iobj);

    STDMETHODIMP
        CDefDcb_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks);

    /*****************************************************************************
     *
     *      digenx.c - IDirectInputDeviceCallback that does nothing
     *
     *****************************************************************************/

    extern IDirectInputDeviceCallback c_dcbNil;

#define c_pdcbNil       &c_dcbNil

    /*****************************************************************************
     *
     *      digenm.c - IDirectInputDeviceCallback for mouse
     *
     *****************************************************************************/

    STDMETHODIMP CMouse_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digenk.c - IDirectInputDeviceCallback for keyboard
     *
     *****************************************************************************/

    STDMETHODIMP CKbd_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digenj.c - IDirectInputDeviceCallback for joystick
     *
     *****************************************************************************/

    STDMETHODIMP CJoy_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   UINT | ibJoyPosAxisFromPosAxis |
     *
     *          Returns the offset of the <p iAxis>'th joystick axis
     *          in the <t JOYPOS> structure.
     *
     *  @parm   UINT | uiAxis |
     *
     *          The index of the requested axis.  X, Y, Z, R, U and V are
     *          respctively zero through five.
     *
     *  @returns
     *
     *          The offset relative to the structure.
     *
     *****************************************************************************/

#define _ibJoyPosAxisFromPosAxis(uiAxis)   \
         (FIELD_OFFSET(JOYPOS, dwX) + cbX(DWORD) * (uiAxis))

    UINT INLINE
        ibJoyPosAxisFromPosAxis(UINT uiPosAxis)
    {
#define CheckAxis(x)                                            \
        CAssertF(_ibJoyPosAxisFromPosAxis(iJoyPosAxis##x)       \
                            == FIELD_OFFSET(JOYPOS, dw##x))     \

        CheckAxis(X);
        CheckAxis(Y);
        CheckAxis(Z);
        CheckAxis(R);
        CheckAxis(U);
        CheckAxis(V);

#undef CheckAxis

        return _ibJoyPosAxisFromPosAxis(uiPosAxis);
    }

    /*****************************************************************************
     *
     *      dieffj.c - Dummy IDirectInputEffectDriver for joystick
     *
     *****************************************************************************/

    STDMETHODIMP CJoyEff_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dihid.c - IDirectInputDeviceCallback for generic HID devices
     *
     *****************************************************************************/
    STDMETHODIMP CHid_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dieff.c - IDirectInputEffect implementation
     *
     *****************************************************************************/

    STDMETHODIMP
        CDIEff_New(struct CDIDev *pdev, LPDIRECTINPUTEFFECTSHEPHERD pes,
                   PUNK punkOuter, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      dihidusg.c - HID usage converters
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct HIDUSAGEMAP |
     *
     *          This structure maps HID usages to GUIDs
     *          or legacy joystick axes.
     *
     *  @field  DWORD | dwUsage |
     *
     *          Packed usage via <f DIMAKEUSAGEDWORD>.
     *
     *  @field  UINT | uiPosAxis |
     *
     *          <t JOYPOS> axis number, where 0 = X, 1 = Y, ..., 5 = V.
     *
     *  @field  PCGUID | pguid |
     *
     *          Corresponding <t GUID>.
     *
     *****************************************************************************/

    typedef struct HIDUSAGEMAP
    {

        DWORD dwUsage;
        UINT uiPosAxis;
        PCGUID pguid;

    } HIDUSAGEMAP, *PHIDUSAGEMAP;

    PHIDUSAGEMAP EXTERNAL UsageToUsageMap(DWORD dwUsage);

    DWORD EXTERNAL GuidToUsage(PCGUID pguid);

    UINT EXTERNAL
        GetHIDString(DWORD Usage, DWORD UsagePage, LPWSTR pwszBuf, UINT cwch);

    void EXTERNAL InsertCollectionNumber(UINT icoll, LPWSTR pwszBuf);

    /*****************************************************************************
     *
     *      disubcls.c - Subclassing
     *
     *****************************************************************************/

    typedef LRESULT
        (CALLBACK *SUBCLASSPROC)(HWND hwnd, UINT wm, WPARAM wp,
                                 LPARAM lp, UINT_PTR uId, ULONG_PTR dwRef);

    BOOL EXTERNAL
        SetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId, ULONG_PTR dwRef);

    BOOL EXTERNAL
        GetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId, ULONG_PTR *pdwRef);

    BOOL EXTERNAL
        RemoveWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId);

    LRESULT EXTERNAL
        DefSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp);

    /*****************************************************************************
     *
     *      dical.c - Axis ramps and calibration
     *
     *      Structure names begin with "Joy" for historical reasons.
     *
     *****************************************************************************/

#if defined(_X86_)

    LONG EXTERNAL CCal_MulDiv(LONG lA, LONG lB, LONG lC);

#else

    #define CCal_MulDiv     MulDiv

#endif

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct JOYRAMP |
     *
     *          Parameters for a "ramp".  A ramp looks like this:
     *
     *             r       !
     *             e    dy -      *---
     *             t       !     /
     *             u       !    /
     *             r       !   /
     *             n     y ---*
     *             e       !
     *             d       +--!---!---
     *                        x   dx
     *
     *                  physical position
     *
     *
     *          y, dy = baseline and height
     *
     *          x, dx = initiation level and width
     *
     *          The mapping is
     *
     *
     *          (-infty, x    ] -> y
     *          (x,      x+dx ) -> (y, y+dy)
     *          [x+dx,   infty) -> y+dy
     *
     *          It is very important that the middle range not be taken
     *          if dx = 0.
     *
     *  @field  int | x |
     *
     *          Horizontal value below which we return the baseline.
     *
     *  @field  DWORD | dx |
     *
     *          Width of the ramp.  Beyond this point, we return the
     *          full height.
     *
     *  @field  int | y |
     *
     *          Baseline.
     *
     *  @field  int | dy |
     *
     *          Total height.
     *
     *****************************************************************************/

    typedef struct JOYRAMP
    {

        int     x;
        int     y;
        DWORD   dx;
        int     dy;

    } JOYRAMP, *PJOYRAMP;

    typedef const JOYRAMP *PCJOYRAMP;

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct JOYRANGECONVERT |
     *
     *          Parameters for range conversion.
     *
     *          The conversion curve is in five sections.
     *
     *
     *
     *                 !
     *             lmax-                     *----
     *         r       !                    /
     *         e       !                   /
     *         t       !                  /
     *         u     lc-          *------*
     *         r       !         /
     *         n       !        /
     *         e       !       /
     *         d   lmin-------*
     *                 !
     *                 +-!----!---!------!----!----!--
     *                pmin  smin dmin  dmax  smax  pmax
     *
     *                                !
     *                                pc
     *
     *
     *                        physical position
     *
     *
     *      lmin/lmax = logical min/max - This is the smallest/largest
     *          position the app will ever see.
     *
     *      lc = logical center
     *
     *      pmin/pmax = physical min/max - This is the position determined by
     *          calibration to be the value which the hardware reports
     *          when the device is physically at its bottom/upper limit.  Note
     *          that the hardware might report values outside this range.
     *
     *      pc = physical center - This is the nominal neutral location for
     *           the axis
     *
     *      dmin/dmax = dead zone min/max - This is the zone around which
     *          the center is artificially expanded.
     *
     *      smin/smax = saturation min/max - This is the level at which
     *          we treat the axis as being at its most extreme position.
     *
     *  @field  BOOL | fRaw |
     *
     *          Is the axis in raw mode?  If so, then no cooking is performed.
     *
     *  @field  JOYRAMP | rmpLow |
     *
     *          The ramp for below-center.
     *
     *  @field  JOYRAMP | rmpHigh |
     *
     *          The ramp for above-center.
     *
     *  @field  DWORD | dwPmin |
     *
     *          Physical minimum.
     *
     *  @field  DWORD | dwPmax |
     *
     *          Physical maximum.
     *
     *  @field  LONG | lMin |
     *
     *          Logical minimum.
     *
     *  @field  LONG | lCenter |
     *
     *          Logical center.
     *
     *  @field  LONG | lMax |
     *
     *          Logical maximum.
     *
     *  @field  DWORD | dwPc |
     *
     *          Physical center.
     *
     *  @field  DWORD | dwDz |
     *
     *          Dead zone (in ten thousandths, 10000 = 100%).
     *
     *  @field  DWORD | dwSat |
     *
     *          Saturation level (in ten thousands, 10000 = 100%).
     *
     *  @field  BOOL | fPolledPOV |
     *
     *          Whether the axis is a polled POV. Usable only when the axis is a POV.
     *
     *  @field  LONG | lMinPOV[5] |
     *
     *          Mininum ranges of POV directions. Usable only when the axis is a POV.
     *
     *  @field  LONG | lMaxPOV[5] |
     *
     *          Maxinum ranges of POV directions. Usable only when the axis is a POV.
     *
     *****************************************************************************/

    /*
     *  Number of range divisions.  We work in ten thousandths.
     */
#define RANGEDIVISIONS      10000

    typedef struct JOYRANGECONVERT
    {
        BOOL fRaw;

        JOYRAMP rmpLow;
        JOYRAMP rmpHigh;

        DWORD dwPmin;
        DWORD dwPmax;
        DWORD dwPc;
        LONG  lMin;
        LONG  lMax;
        LONG  lC;
        DWORD dwDz;
        DWORD dwSat;
      #ifdef WINNT  
        BOOL  fFakeRaw;
        BOOL  fPolledPOV;
        LONG  lMinPOV[5];
        LONG  lMaxPOV[5];
      #endif
        
    } JOYRANGECONVERT, *PJOYRANGECONVERT;

    typedef const JOYRANGECONVERT *PCJOYRANGECONVERT;

    /*****************************************************************************
     *
     *      dical.c functions
     *
     *****************************************************************************/

    void EXTERNAL CCal_CookRange(PJOYRANGECONVERT this, LONG UNALIGNED *pl);
    void EXTERNAL CCal_RecalcRange(PJOYRANGECONVERT this);

    STDMETHODIMP
        CCal_GetProperty(PJOYRANGECONVERT this, REFGUID rguid, LPDIPROPHEADER pdiph, DWORD dwVersion);

    STDMETHODIMP
        CCal_SetProperty(PJOYRANGECONVERT this, LPCDIPROPINFO ppropi,
                         LPCDIPROPHEADER pdiph, HKEY hkType, DWORD dwVersion);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   LONG | CCal_Midpoint |
     *
     *          Return the midpoint of two values.  Note, however, that
     *          we round <y upward> instead of downward.  This is important,
     *          because many people set the ranges to something like
     *          0 .. 0xFFFF, and we want the midpoint to be 0x8000.
     *
     *          Care must be taken that the intermediate sum does not overflow.
     *
     *  @parm   LONG | lMin |
     *
     *          Lower limit.
     *
     *  @parm   LONG | lMax |
     *
     *          Upper limit.
     *
     *  @returns
     *
     *          The midpoint.
     *
     *****************************************************************************/

    LONG INLINE
        CCal_Midpoint(LONG lMin, LONG lMax)
    {
        /*
         *  Can't do "lMax + lMin" because that might overflow.
         */
        AssertF(lMax >= lMin);
        return lMin + (UINT)(lMax - lMin + 1) / 2;
    }

    /*****************************************************************************
     *
     *      dijoytyp.c
     *
     *****************************************************************************/

    STDMETHODIMP CType_OpenIdSubkey(HKEY, DWORD, REGSAM, PHKEY);
    void EXTERNAL CType_RegGetObjectInfo(HKEY hkType, DWORD dwId,
                                         LPDIDEVICEOBJECTINSTANCEW pdidoiW);
    void EXTERNAL CType_RegGetTypeInfo(HKEY hkType, LPDIOBJECTDATAFORMAT podf, BOOL bHid);
    void EXTERNAL CType_MakeGameCtrlName(PWCHAR wszOutput, DWORD dwDevType, 
        DWORD dwAxes, DWORD dwButtons, DWORD dwPOVs );


    /*****************************************************************************
     *
     *      diaphack.c
     *
     *****************************************************************************/

    HRESULT EXTERNAL AhAppRegister(DWORD dwVer);
    BOOL EXTERNAL AhGetAppHacks(LPDIAPPHACKS);

    /*****************************************************************************
     *
     *      diraw.c
     *
     *****************************************************************************/
  #ifdef USE_WM_INPUT
    #define DIRAW_NONEXCL       0
    #define DIRAW_EXCL          1
    #define DIRAW_NOHOTKEYS     2
    
    HRESULT CDIRaw_RegisterRawInputDevice( UINT uirim, DWORD dwOrd, HWND hwnd);
    HRESULT CDIRaw_UnregisterRawInputDevice( UINT uirim, HWND hwnd );
    BOOL    CDIRaw_OnInput(MSG *pmsg);
    HRESULT INTERNAL CDIRaw_Mouse_InitButtons();
    int     EXTERNAL DIRaw_GetKeyboardType(int nTypeFlag);
  #endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dinputv.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputv.h
 *  Content:    private DirectInput VxD include file
 *
 ***************************************************************************/

#ifndef __DINPUTV_INCLUDED__
#define __DINPUTV_INCLUDED__

/* XLATOFF */
#ifdef __cplusplus
extern "C" {
#endif
/* XLATON */



/****************************************************************************
 *
 *      DeviceIOCtl codes for DINPUT.VXD
 *
 *      IOCTL_FIRST is where DINPUT keeps its IOCTL codes.  Modify it
 *      if necessary to move DINPUT's IOCTLs to a new location.
 *
 *      All DINPUT IOCTLs are private between DINPUT.DLL and DINPUT.VXD.
 *      You can change them with impunity.
 *
 ***************************************************************************/

#define IOCTL_FIRST     0x0100

/* H2INCSWITCHES -t -f */

#if 0
/* Declare some types so h2inc will get them */
typedef LONG HWND;
typedef LONG DWORD;
#endif

/* Declare some more types for Win9x builds and h2inc */
#ifndef MAXULONG_PTR
typedef DWORD   ULONG_PTR;
typedef DWORD   *PULONG_PTR;
typedef DWORD   UINT_PTR;
typedef DWORD   *PULONG_PTR;
#endif //MAXULONG_PTR

/****************************************************************************
 *
 *      The shared portion of the VXDINSTANCE structure.
 *
 *      Instance "handles" are really pointers to a VXDINSTANCE structure.
 *
 ***************************************************************************/

typedef struct VXDINSTANCE {            /* vi */
    ULONG   fl;                         /* Flags */
    void *  pState;                     /* Instantaneous device state */
    DIDEVICEOBJECTDATA *pBuffer;        /* Device object data buffer */
    DIDEVICEOBJECTDATA *pEnd;           /* End of buffer */
    DIDEVICEOBJECTDATA *pHead;          /* Where new data appears */
    DIDEVICEOBJECTDATA *pTail;          /* Oldest object data */
    ULONG   fOverflow;                  /* Did the buffer overflow? */
                                        /* (exactly 0 or 1) */
    struct CDIDev *pdd;                 /* For misc communication */
    HWND hwnd;                          /* The cooperative window */
} VXDINSTANCE, *PVXDINSTANCE;

#define VIFL_CAPTURED_BIT   0
#define VIFL_CAPTURED       0x00000001  /* Device is captured (exclusive) */

#define VIFL_ACQUIRED_BIT   1
#define VIFL_ACQUIRED       0x00000002  /* Device is acquired */

#define VIFL_RELATIVE_BIT   2
#define VIFL_RELATIVE       0x00000004  /* Device wants relative data */

#define VIFL_EMULATED_BIT   3
#define VIFL_EMULATED       0x00000008  /* Device uses emulation */

#define VIFL_UNPLUGGED_BIT  4
#define VIFL_UNPLUGGED      0x00000010  /* Device is disconnected */

#define VIFL_NOWINKEY_BIT   5
#define VIFL_NOWINKEY       0x00000020  /* The Window Key are disabled */

#define VIFL_MODECOMPAT_BIT 6
#define VIFL_MODECOMPAT     0x00000040  /* Set if this application needs 
                                           buggy DX7 axis mode behavior */

#ifdef WANT_TO_FIX_MANBUG43879                                           
  #define VIFL_FOREGROUND_BIT 7
  #define VIFL_FOREGROUND     0x00000080  /* Device is foreground */
#endif

#define VIFL_INITIALIZE_BIT 8
#define VIFL_INITIALIZE     0x00000100  /* This flag is set during the acquisition
                                           of a HID device so that we can get the
                                           initial device state successfully. */

/*
 *  The high word of fl contains device-specific flags.  They are
 *  currently used to record emulation information, and they aren't
 *  really device-specific because we have so few emulation flags.
 *
 *  The high word is just the emulation flags shifted upwards.
 */
#define DIGETEMFL(fl)       ((fl) >> 16)
#define DIMAKEEMFL(fl)      ((fl) << 16)

/****************************************************************************
 *
 *      System-defined IOCTL codes
 *
 ***************************************************************************/

#define IOCTL_GETVERSION        0x0000

/****************************************************************************
 *
 *      DINPUT-class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: None
 *
 *  OUT: None
 *
 *  The foreground window has lost activation.  Force all exclusively
 *  acquired devices to be unacquired.
 *
 *  This IOCTL is no longer used.  (Actually, it was never used.)
 *
 */
#define IOCTL_INPUTLOST         (IOCTL_FIRST + 0)


typedef struct VXDDEVICEFORMAT { /* devf */
    ULONG   cbData;             /* Size of device data */
    ULONG   cObj;               /* Number of objects in data format */
    DIOBJECTDATAFORMAT *rgodf;  /* Array of descriptions */
    ULONG_PTR   dwExtra;            /* Extra dword for private communication */
    DWORD   dwEmulation;        /* Flags controlling emulation */
} VXDDEVICEFORMAT, *PVXDDEVICEFORMAT;

/*
 *  IN: An instance handle that needs to be cleaned up.
 *
 *  OUT: None.
 *
 */
#define IOCTL_DESTROYINSTANCE   (IOCTL_FIRST + 1)

/*
 *  pDfOfs is an array of DWORDs.  Each entry corresponds to a byte in the
 *  device data format, indicating the offset in the *client* data format
 *  which records the data.  Or it is -1 if the client isn't tracking this
 *  object.
 *
 *  For example, if the object at device offset 4 is to be reported at
 *  client data offset 12, then pDfOfs[4] = 12.
 */
typedef struct VXDDATAFORMAT {  /* vdf */
    VXDINSTANCE *pvi;           /* Instance identifier */
    ULONG   cbData;             /* Size of device data */
    DWORD * pDfOfs;             /* Array of data format offsets */
} VXDDATAFORMAT, *PVXDDATAFORMAT;

/*
 *  IN: PVXDDATAFORMAT.
 *
 *  OUT: None
 *
 *  The application has changed the data format.  Notify the VxD so that
 *  data can be collected appropriately.
 *
 */
#define IOCTL_SETDATAFORMAT     (IOCTL_FIRST + 2)

/*
 *  IN: An instance handle to be acquired.
 *
 *  OUT: None.
 *
 */
#define IOCTL_ACQUIREINSTANCE   (IOCTL_FIRST + 3)

/*
 *  IN: An instance handle to be unacquired.
 *
 *  OUT: None.
 *
 */
#define IOCTL_UNACQUIREINSTANCE (IOCTL_FIRST + 4)

typedef struct VXDDWORDDATA {   /* vdd */
    VXDINSTANCE *pvi;           /* Instance identifier */
    ULONG   dw;                 /* Some dword */
} VXDDWORDDATA, *PVXDDWORDDATA;

/*
 *  IN: VXDDWORDDATA (dw = ring 0 handle)
 *
 *  OUT: None.
 *
 */
#define IOCTL_SETNOTIFYHANDLE   (IOCTL_FIRST + 5)

/*
 *  IN: VXDDWORDDATA (dw = buffer size)
 *
 *  OUT: None.
 *
 */
#define IOCTL_SETBUFFERSIZE     (IOCTL_FIRST + 6)

/****************************************************************************
 *
 *      Mouse class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = number of axes)
 *
 *  OUT: Instance handle
 */
#define IOCTL_MOUSE_CREATEINSTANCE (IOCTL_FIRST + 7)

/*
 *  IN: VXDDWORDDATA; dw is a BYTE[4] of initial mouse button states
 *
 *  OUT: None
 */
#define IOCTL_MOUSE_INITBUTTONS (IOCTL_FIRST + 8)

/****************************************************************************
 *
 *      Keyboard class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = keyboard type translation table)
 *
 *  OUT: Instance handle
 */
#define IOCTL_KBD_CREATEINSTANCE (IOCTL_FIRST + 9)

/*
 *  IN: VXDDWORDDATA; dw is a bitmask
 *      1 = KANA key is down, 2 = CAPITAL key is down
 *
 *  OUT: None
 */
#define IOCTL_KBD_INITKEYS       (IOCTL_FIRST + 10)

/****************************************************************************
 *
 *      Joystick class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = joystick id number)
 *
 *  OUT: Instance handle
 */
#define IOCTL_JOY_CREATEINSTANCE (IOCTL_FIRST + 11)

/*
 *  IN: An instance handle to be pinged
 *
 *  OUT: Instance handle
 */
#define IOCTL_JOY_PING           (IOCTL_FIRST + 12)

/*
 *  IN: DWORD external joystick ID
 *
 *  OUT: VXDINITPARMS containing goo we get from VJOYD.
 *
 */
typedef struct VXDINITPARMS {   /* vip */
    ULONG   hres;               /* result */
    ULONG   dwSize;             /* Which version of VJOYD are we? */
    ULONG   dwFlags;            /* Describes the device */
    ULONG   dwId;               /* Internal joystick ID */
    ULONG   dwFirmwareRevision;
    ULONG   dwHardwareRevision;
    ULONG   dwFFDriverVersion;
    ULONG   dwFilenameLengths;
    void *  pFilenameBuffer;
    DWORD   Usages[6];          /* X, Y, Z, R, U, V */
    DWORD   dwPOV0usage;
    DWORD   dwPOV1usage;
    DWORD   dwPOV2usage;
    DWORD   dwPOV3usage;
} VXDINITPARMS, *PVXDINITPARMS;

/*
 * Flags returned in VXDINITPARMS
 */
#define VIP_UNIT_ID             0x00000001L /* unit id is valid */
#define VIP_ISHID               0x00000002L /* This is a HID device */
#define VIP_SENDSNOTIFY         0x00000004L /* Driver will notify */

#define IOCTL_JOY_GETINITPARMS   (IOCTL_FIRST + 13)

/*
 *  IN: VXDFFIO describing FF I/O request
 *
 *      pvArgs points to an array of arguments.  We rely on several
 *      quirks of fate for this to work.
 *
 *      1.  STDCALL pushes arguments on the stack from right to left,
 *          so the address of the first argument can be used as a
 *          structure pointer.
 *
 *      2.  All the VJOYD interfaces pass arguments in registers.
 *
 *      3.  The registers used by VJOYD interfaces are always in the
 *          order eax, ecx, edx, esi, edi, matching the order in which
 *          the arguments are passed to IDirectInputEffectDriver.
 *
 *  OUT: HRESULT containing result code
 *
 */
/* XLATOFF */
#include <pshpack4.h>
/* XLATON */
typedef struct VXDFFIO { /* ffio */
    DWORD   dwIOCode;           /* I/O code */
    void *  pvArgs;             /* Array of arguments */
} VXDFFIO, *PVXDFFIO;
/* XLATOFF */
#include <poppack.h>
/* XLATON */

#define FFIO_ESCAPE             0
#define FFIO_SETGAIN            1
#define FFIO_SETFFSTATE         2
#define FFIO_GETFFSTATE         3
#define FFIO_DOWNLOADEFFECT     4
#define FFIO_DESTROYEFFECT      5
#define FFIO_STARTEFFECT        6
#define FFIO_STOPEFFECT         7
#define FFIO_GETEFFECTSTATUS    8
#define FFIO_MAX                9

#define IOCTL_JOY_FFIO           (IOCTL_FIRST + 14)

/****************************************************************************
 *
 *      Misc services
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Pointer to dword sequence pointer
 */
#define IOCTL_GETSEQUENCEPTR    (IOCTL_FIRST + 15)

/****************************************************************************
 *
 *      Back to Joystick
 *
 ***************************************************************************/

/*
 *  Define these again, because NT doesn't have vjoyd
 *  and because vjoyd.inc doesn't define them.
 */
#define JOYPF_X             0x00000001
#define JOYPF_Y             0x00000002
#define JOYPF_Z             0x00000004
#define JOYPF_R             0x00000008
#define JOYPF_U             0x00000010
#define JOYPF_V             0x00000020
#define JOYPF_POV0          0x00000040
#define JOYPF_POV1          0x00000080
#define JOYPF_POV2          0x00000100
#define JOYPF_POV3          0x00000200
#define JOYPF_POV(n)        (JOYPF_POV0 << (n))
#define JOYPF_BTN0          0x00000400
#define JOYPF_BTN1          0x00000800
#define JOYPF_BTN2          0x00001000
#define JOYPF_BTN3          0x00002000
#define JOYPF_ALLAXES       0x0000003F
#define JOYPF_ALLCAPS       0x00003FFF

#define JOYPF_POSITION      0x00010000
#define JOYPF_VELOCITY      0x00020000
#define JOYPF_ACCELERATION  0x00040000
#define JOYPF_FORCE         0x00080000
#define JOYPF_ALLMODES      0x000F0000
#define JOYPF_NUMMODES      4

/*
 *  IN: DWORD external joystick ID
 *
 *  OUT: array of DWORDs listing which axes are valid where
 *
 */
typedef struct VXDAXISCAPS {    /* vac */
    DWORD   dwPos;              /* Axis positions */
    DWORD   dwVel;              /* Axis velocities */
    DWORD   dwAccel;            /* Axis accelerations */
    DWORD   dwForce;            /* Axis forces */
} VXDAXISCAPS, *PVXDAXISCAPS;

#define IOCTL_JOY_GETAXES       (IOCTL_FIRST + 16)

/****************************************************************************
 *
 *      Mouse random
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Pointer to dword wheel granularity.
 */
#define IOCTL_MOUSE_GETWHEEL    (IOCTL_FIRST + 17)

/****************************************************************************
 *
 *      New IOCTLs for DX8, stuck on the end to improve chances of cross 
 *      version compatibility.
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Nothing
 */
#define IOCTL_JOY_CONFIGCHANGED    (IOCTL_FIRST + 18)

/*
 *  IN: An instance handle to be pinged
 *
 *  OUT: Instance handle
 *
 *  This is used by the post dinput.dll versions of the DLL to avoid 
 *  unacquiring all instances of a device on a poll failure.
 *  It is used by dinput.dll to implement the NoPollUnacquire app compat fix.
 */
#define IOCTL_JOY_PING8           (IOCTL_FIRST + 19)

/****************************************************************************
 *
 *      End of IOCTL table
 *
 ***************************************************************************/

#define IOCTL_MAX               (IOCTL_FIRST + 20)



/* XLATOFF */
#ifdef __cplusplus
};
#endif
/* XLATON */

#endif  /* __DINPUTV_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diobj.c ===
/*****************************************************************************
 *
 *  DIObj.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInput main interface.
 *
 *  Contents:
 *
 *      CDIObj_New
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "verinfo.h"                /* For #ifdef FINAL */

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDi

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIObj |
 *
 *          The <i IDirectInput> object, from which other things come.
 *
 *          The A and W versions are simply alternate interfaces on the same
 *          underlying object.
 *
 *          There really isn't anything interesting in the structure
 *          itself.
 *
 *
 *  @field  IDirectInputA | diA |
 *
 *          ANSI DirectInput object (containing vtbl).
 *
 *  @field  IDirectInputW | diW |
 *
 *          UNICODE DirectInput object (containing vtbl).
 *
 *  @field  IDirectInputJoyConfig *| pdjc |
 *
 *          Aggregated joystick configuration interface (if created).
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Critical section that guards thread-sensitive data.
 *****************************************************************************/

typedef struct CDIObj {

    /* Supported interfaces */
    TFORM(IDirectInput)   TFORM(di);
    SFORM(IDirectInput)   SFORM(di);

    DWORD dwVersion;

    IDirectInputJoyConfig *pdjc;

    BOOL fCritInited:1;

    CRITICAL_SECTION crst;

} CDIObj, DDI, *PDDI;

#define ThisClass CDIObj


#ifdef IDirectInput7Vtbl

    #define ThisInterface  TFORM(IDirectInput7)
    #define ThisInterfaceA IDirectInput7A
    #define ThisInterfaceW IDirectInput7W
    #define ThisInterfaceT IDirectInput7

#else 
#ifdef IDirectInput2Vtbl

#define ThisInterface TFORM(IDirectInput2)
#define ThisInterfaceA IDirectInput2A
#define ThisInterfaceW IDirectInput2W
#define ThisInterfaceT IDirectInput2

#else

#define ThisInterface TFORM(IDirectInput)
#define ThisInterfaceA IDirectInputA
#define ThisInterfaceW IDirectInputW
#define ThisInterfaceT IDirectInput

#endif
#endif
/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

  Primary_Interface(CDIObj, TFORM(ThisInterfaceT));
Secondary_Interface(CDIObj, SFORM(ThisInterfaceT));

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIObj)
Default_AddRef(CDIObj)
Default_Release(CDIObj)

#else

#define CDIObj_QueryInterface   Common_QueryInterface
#define CDIObj_AddRef           Common_AddRef
#define CDIObj_Release          Common_Release

#endif

#define CDIObj_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc   void | CDIObj | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @doc    INTERNAL
 *
 *  @mfunc   void | CDIObj | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *****************************************************************************/

void INLINE
CDIObj_EnterCrit(PDDI this)
{
    EnterCriticalSection(&this->crst);
}

void INLINE
CDIObj_LeaveCrit(PDDI this)
{
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IDirectInput | QIHelper |
 *
 *          We will dynamically create <i IDirectInputJoyConfig>
 *          and aggregate it with us.
 *
#ifdef IDirectInput2Vtbl
 *          Support the original IDirectInput interfaces as well
 *          as the new IDirectInput2 interfaces.
#endif
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_QIHelper(PDDI this, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(CDIObj_QIHelper, (_ "pG", this, riid));

    if (IsEqualIID(riid, &IID_IDirectInputJoyConfig)) {

        *ppvObj = 0;                /* In case the New fails */

        CDIObj_EnterCrit(this);
        if (this->pdjc == 0) {
            hres = CJoyCfg_New((PUNK)this, &IID_IUnknown, (PPV)&this->pdjc);
        } else {
            hres = S_OK;
        }
        CDIObj_LeaveCrit(this);

        if (SUCCEEDED(hres)) {
            /*
             *  This QI will addref us if it succeeds.
             */
            hres = OLE_QueryInterface(this->pdjc, riid, ppvObj);
        } else {
            this->pdjc = 0;
        }

#ifdef IDirectInput2Vtbl

    } else if (IsEqualIID(riid, &IID_IDirectInputA)) {

        *ppvObj = &this->diA;
        OLE_AddRef(this);
        hres = S_OK;

    } else if (IsEqualIID(riid, &IID_IDirectInputW)) {

        *ppvObj = &this->diW;
        OLE_AddRef(this);
        hres = S_OK;
    
#endif
#ifdef IDirectInput7Vtbl

     } else if (IsEqualIID(riid, &IID_IDirectInput2A)) {
 
         *ppvObj = &this->diA;
         OLE_AddRef(this);
         hres = S_OK;
     } else if (IsEqualIID(riid, &IID_IDirectInput2W)) {

        *ppvObj = &this->diW;
        OLE_AddRef(this);
        hres = S_OK;

#endif //IDirectInput7Vtbl
    } else {
        hres = Common_QIHelper(this, riid, ppvObj);
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIObj_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CDIObj_Finalize(PV pvObj)
{
    PDDI this = pvObj;

    Invoke_Release(&this->pdjc);

    if (this->fCritInited) {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInput | CreateDeviceHelper |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   IN LPUNKNOWN | punkOuter |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   IN RIID | riid |
 *
 *          The interface the application wants to create.  This will
 *          be either <i IDirectInputDeviceA> or <i IDirectInputDeviceW>.
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_CreateDeviceHelper(PDDI this, PCGUID pguid, PPV ppvObj,
                          PUNK punkOuter, RIID riid)
{
    HRESULT hres;
    EnterProc(CDIObj_CreateDeviceHelper,
              (_ "pGxG", this, pguid, punkOuter, riid));

    /*
     *  CDIDev_New will validate the punkOuter and ppvObj.
     *
     *  IDirectInputDevice_Initialize will validate the pguid.
     *
     *  riid is known good (since it came from CDIObj_CreateDeviceW
     *  or CDIObj_CreateDeviceA).
     */

    hres = CDIDev_New(punkOuter, punkOuter ? &IID_IUnknown : riid, ppvObj);

    if (SUCCEEDED(hres) && punkOuter == 0) {
        PDID pdid = *ppvObj;
        hres = IDirectInputDevice_Initialize(pdid, g_hinst,
                                             this->dwVersion, pguid);
        if (SUCCEEDED(hres)) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpv(ppvObj);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | CreateDevice |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   REFGUID | rguid |
 *          Identifies the instance of the
 *          device for which the indicated interface
 *          is requested.  The <mf IDirectInput::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @parm   OUT LPDIRECTINPUTDEVICE * | lplpDirectInputDevice |
 *          Points to where to return
 *          the pointer to the <i IDirectInputDevice> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, NULL,
 *          CLSCTX_INPROC_SERVER, <p riid>, <p lplpDirectInputDevice>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInputDevice>).
 *          The aggregated object must be initialized manually.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_NOINTERFACE> = <c E_NOINTERFACE>
 *          The specified interface is not supported by the object.
 *
 *          <c DIERR_DEVICENOTREG> = The device instance does not
 *          correspond to a device that is registered with DirectInput.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_CreateDeviceW(PV pdiW, REFGUID rguid, PPDIDW ppdidW, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput::CreateDevice,
               (_ "pGp", pdiW, rguid, punkOuter));

    if (SUCCEEDED(hres = hresPvI(pdiW, ThisInterfaceW))) {
        PDDI this = _thisPvNm(pdiW, diW);

        hres = CDIObj_CreateDeviceHelper(this, rguid, (PPV)ppdidW,
                                         punkOuter, &IID_IDirectInputDeviceW);
    }

    ExitOleProcPpv(ppdidW);
    return hres;
}

STDMETHODIMP
CDIObj_CreateDeviceA(PV pdiA, REFGUID rguid, PPDIDA ppdidA, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput::CreateDevice,
               (_ "pGp", pdiA, rguid, punkOuter));

    if (SUCCEEDED(hres = hresPvI(pdiA, ThisInterfaceA))) {
        PDDI this = _thisPvNm(pdiA, diA);

        hres = CDIObj_CreateDeviceHelper(this, rguid, (PPV)ppdidA,
                                         punkOuter, &IID_IDirectInputDeviceA);
    }

    ExitOleProcPpv(ppdidA);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | CreateDeviceEx |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID. CreateDeviceEx allows an app to 
 *          directly create a IID_IDirectInputDevice7 interface without
 *          going through a CreateDevice() and QI the interface 
 *          for an IID_IDirectInput7.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   REFGUID | rguid |
 *          Identifies the instance of the
 *          device for which the indicated interface
 *          is requested.  The <mf IDirectInput::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @parm  REFIID | riid |
 *          Identifies the REFIID for the interface. Currently accepted values
 *          are IID_IDirectInputDevice, IID_IDirectInputDevice2, IID_IDirectInputDevice7.
 *
 *
 *  @parm   OUT LPVOID * | pvOut |
 *          Points to where to return
 *          the pointer to the <i IDirectInputDevice#> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, NULL,
 *          CLSCTX_INPROC_SERVER, <p riid>, <p lplpDirectInputDevice>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInputDevice>).
 *          The aggregated object must be initialized manually.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_NOINTERFACE> = <c E_NOINTERFACE>
 *          The specified interface is not supported by the object.
 *
 *          <c DIERR_DEVICENOTREG> = The device instance does not
 *          correspond to a device that is registered with DirectInput.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIObj_CreateDeviceExW(PV pdiW, REFGUID rguid, REFIID riid,  LPVOID * pvOut, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput::CreateDeviceEx,
               (_ "pGGp", pdiW, rguid, riid, punkOuter));

    if(SUCCEEDED(hres = hresPvI(pdiW, ThisInterfaceW)))
    {
        PDDI this = _thisPvNm(pdiW, diW);

        hres = CDIObj_CreateDeviceHelper(this, rguid, pvOut,
                                         punkOuter, riid);
    }

    ExitOleProcPpv(pvOut);
    return hres;
}

STDMETHODIMP
    CDIObj_CreateDeviceExA(PV pdiA, REFGUID rguid, REFIID riid,  LPVOID * pvOut, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput::CreateDevice,
               (_ "pGp", pdiA, rguid, riid, punkOuter));

    if(SUCCEEDED(hres = hresPvI(pdiA, ThisInterfaceA)))
    {
        PDDI this = _thisPvNm(pdiA, diA);

        hres = CDIObj_CreateDeviceHelper(this, rguid, pvOut,
                                         punkOuter, riid);
    }

    ExitOleProcPpv(pvOut);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIObj_TestDeviceFlags |
 *
 *          Determines whether the device matches the specified flags.
 *          Phantom devices are treated as not really there.
 *
 *  @parm   PDIDW | pdidW |
 *
 *          Device to be queried.
 *
 *  @parm   DWORD | edfl |
 *
 *          Enumeration flags.  It is one or more <c DIEDFL_*> values.
 *
 *          The bits in the enumeration flags are in two categories.*
 *
 *          Normal flags are the ones whose presence requires that
 *          the corresponding bit in the device flags also be set.
 *
 *          Inverted flags (<c DIEDFL_INCLUDEMASK>) are the ones whose
 *          absence requires that the corresponding bit in the device
 *          flags also be absent.
 *
 *          By inverting the inclusion flags in both the enumeration
 *          flags and the actual device flags, and then treating the
 *          whole thing as a bunch of normal flags, we get the desired
 *          behavior for the inclusion flags.
 *
 *  @returns
 *
 *          <c S_OK> if the device meets the criteria.
 *
 *          <c S_FALSE> if the device does not meet the criteria.
 *          Note that <mf DirectInput::GetDeviceStatus> relies on
 *          this specific return value.
 *
 *          Other error code as appropriate.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIObj_TestDeviceFlags(PDIDW pdidW, DWORD edfl)
{
    HRESULT hres;
    DIDEVCAPS_DX3 dc;
    EnterProcI(CDIObj_TestDeviceFlags, (_ "px", pdidW, edfl));

    /*
     *  We intentionally use a DIDEVCAPS_DX3 because going for
     *  a full DIDEVCAPS_DX5 requires us to load the force
     *  feedback driver which is pointless for our current
     *  goal.
     */
    dc.dwSize = cbX(dc);

    hres = IDirectInputDevice_GetCapabilities(pdidW, (PV)&dc);

    AssertF(dc.dwSize == cbX(dc));

    CAssertF(DIEDFL_ATTACHEDONLY == DIDC_ATTACHED);
    CAssertF(DIEDFL_FORCEFEEDBACK == DIDC_FORCEFEEDBACK);
    CAssertF(DIEDFL_INCLUDEALIASES == DIDC_ALIAS);
    CAssertF(DIEDFL_INCLUDEPHANTOMS == DIDC_PHANTOM);

    if (SUCCEEDED(hres)) {
        if (fHasAllBitsFlFl(dc.dwFlags ^ DIEDFL_INCLUDEMASK,
                            edfl ^ DIEDFL_INCLUDEMASK)) {
            hres = S_OK;
        } else {
            /*
             *  Note: DX3 and DX5 returned E_DEVICENOTREG for
             *  phantom devices.  Now we return S_FALSE. Let's
             *  hope nobody gets upset.
             */
            hres = S_FALSE;
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | EnumDevices |
 *
 *          Enumerates the DirectInput devices that are attached to
 *          or could be attached to the computer.
 *
 *          For example, an external game port may support a joystick
 *          or a steering wheel, but only one can be plugged in at a
 *          time.  <mf IDirectInput::EnumDevices> will enumerate both
 *          devices.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   DWORD | dwDevType |
 *
 *          Device type filter.  If 0, then all device types are
 *          enumerated.  Otherwise, it is a <c DIDEVTYPE_*> value,
 *          indicating the device type that should be enumerated.
 *
 *  @parm   LPDIENUMDEVICESCALLBACK | lpCallback |
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumDevicesProc> callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @parm   DWORD | fl |
 *          Optional flags which control the enumeration.  The
 *          following flags are defined and may be combined.
 *
 *          <c DIEDFL_ATTACHEDONLY>: Enumerate only attached devices.
 *
 *          <c DIEDFL_FORCEFEEDBACK>: Enumerate only devices which
 *          support force feedback.  This flag is new for DirectX 5.0.
 *
 *          <c DIEDFL_INCLUDEALIASES>: Include alias devices in the
 *          enumeration.  If this flag is not specified, then devices
 *          which are aliases of other devices (indicated by the
 *          <c DIDC_ALIAS> flag in the <e DIDEVCAPS.dwFlags> field
 *          of the <t DIDEVCAPS> structure) will be excluded from
 *          the enumeration.  This flag is new for DirectX 5.0a.
 *
 *          <c DIEDFL_INCLUDEPHANTOMS>: Include phantom devices in the
 *          enumeration.  If this flag is not specified, then devices
 *          which are phantoms (indicated by the
 *          <c DIDC_PHANTOM> flag in the <e DIDEVCAPS.dwFlags> field
 *          of the <t DIDEVCAPS> structure) will be excluded from
 *          the enumeration.  This flag is new for DirectX 5.0a.
 *
 *          The default is
 *          <c DIEDFL_ALLDEVICES>: Enumerate all installed devices.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumDevicesProc |
 *
 *          An application-defined callback function that receives
 *          DirectInput devices as a result of a call to the
 *          <om IDirectInput::EnumDevices> method.
 *
 *  @parm   IN LPDIDEVICEINSTANCE | lpddi |
 *
 *          Structure that describes the device instance.
 *
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInput::EnumDevices> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *//**************************************************************************
 *
 *      In DEBUG/RDEBUG, if the callback returns a bogus value, raise
 *      a validation exception.
 *
 *****************************************************************************/

HRESULT INLINE
CDIObj_EnumDevices_IsValidTypeFilter(DWORD dwDevType)
{
    HRESULT hres;

    /*
     *  First make sure the type mask is okay.
     */
    if ((dwDevType & DIDEVTYPE_TYPEMASK) < DIDEVTYPE_MAX) {

        /*
         *  Now make sure attribute masks are okay.
         */
        if (dwDevType & DIDEVTYPE_ENUMMASK & ~DIDEVTYPE_ENUMVALID) {
            RPF("IDirectInput::EnumDevices: Invalid dwDevType");
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }

    } else {
        RPF("IDirectInput::EnumDevices: Invalid dwDevType");
        hres = E_INVALIDARG;
    }
    return hres;
}

STDMETHODIMP
CDIObj_EnumDevicesW(PV pdiW, DWORD dwDevType,
                    LPDIENUMDEVICESCALLBACKW pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInput::EnumDevices,
               (_ "pxppx", pdiW, dwDevType, pec, pvRef, fl));

    if (SUCCEEDED(hres = hresPvI(pdiW, ThisInterfaceW)) &&
        SUCCEEDED(hres = hresFullValidPfn(pec, 2)) &&
        SUCCEEDED(hres = CDIObj_EnumDevices_IsValidTypeFilter(dwDevType)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIEDFL_VALID, 4))) {
        PDDI this = _thisPvNm(pdiW, diW);

        if(SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion))) {

            CDIDEnum *pde;
    
            hres = CDIDEnum_New(&this->diW, dwDevType, fl, this->dwVersion, &pde);
            if (SUCCEEDED(hres)) {
                DIDEVICEINSTANCEW ddiW;
                ddiW.dwSize = cbX(ddiW);
    
                while ((hres = CDIDEnum_Next(pde, &ddiW)) == S_OK) {
                    BOOL fRc;
    
                    /*
                     *  WARNING!  "goto" here!  Make sure that nothing
                     *  is held while we call the callback.
                     */
                    fRc = Callback(pec, &ddiW, pvRef);
    
                    switch (fRc) {
                    case DIENUM_STOP: goto enumdoneok;
                    case DIENUM_CONTINUE: break;
                    default:
                        RPF("%s: Invalid return value from callback", s_szProc);
                        ValidationException();
                        break;
                    }
                }
    
                AssertF(hres == S_FALSE);
            enumdoneok:;
                CDIDEnum_Release(pde);
    
                hres = S_OK;
            }
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_EnumDevicesCallbackA |
 *
 *          Wrapper function for <mf IDirectInput::EnumDevices>
 *          which translates the UNICODE parameters to ANSI.
 *
 *  @parm   IN LPCDIDECICEINSTANCEW | pdiW |
 *
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   IN OUT PV | pvRef |
 *
 *          Pointer to <t struct ENUMDEVICESINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMDEVICESINFO {
    LPDIENUMDEVICESCALLBACKA pecA;
    PV pvRef;
} ENUMDEVICESINFO, *PENUMDEVICESINFO;

BOOL CALLBACK
CDIObj_EnumDevicesCallback(LPCDIDEVICEINSTANCEW pdiW, PV pvRef)
{
    PENUMDEVICESINFO pedi = pvRef;
    BOOL fRc;
    DIDEVICEINSTANCEA diA;
    EnterProc(CDIObj_EnumDevicesCallback,
              (_ "GGxWWp", &pdiW->guidInstance, &pdiW->guidProduct,
                           &pdiW->dwDevType,
                           pdiW->tszProductName, pdiW->tszInstanceName,
                           pvRef));

    diA.dwSize = cbX(diA);
    DeviceInfoWToA(&diA, pdiW);

    fRc = pedi->pecA(&diA, pedi->pvRef);

    ExitProcX(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputA | EnumDevices |
 *
 *          ANSI version of <mf IDirectInput::EnumDevices>.
 *          We wrap the operation.
 *
 *  @parm   IN LPGUID | lpGUIDDeviceType |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   LPDIENUMDEVICESCALLBACKA | lpCallbackA |
 *          Same as <mf IDirectInput::EnumDevices>, except ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   DWORD | fl |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_EnumDevicesA(PV pdiA, DWORD dwDevType,
                    LPDIENUMDEVICESCALLBACKA pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInput::EnumDevices,
               (_ "pxppx", pdiA, dwDevType, pec, pvRef, fl));

    /*
     *  EnumDevicesW will validate the rest.
     */
    if (SUCCEEDED(hres = hresPvI(pdiA, ThisInterfaceA)) &&
        SUCCEEDED(hres = hresFullValidPfn(pec, 1))) {
        ENUMDEVICESINFO edi = { pec, pvRef };
        PDDI this = _thisPvNm(pdiA, diA);
        hres = CDIObj_EnumDevicesW(&this->diW, dwDevType,
                                   CDIObj_EnumDevicesCallback, &edi, fl);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | GetDeviceStatus |
 *
 *          Determine whether a device is currently attached.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the instance of the
 *          device whose status is being checked.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *          <c DI_NOTATTACHED> = <c S_FALSE>: The device is not
 *          attached.
 *
 *          <c E_FAIL>: DirectInput could not determine
 *          whether the device is attached.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          device does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_GetDeviceStatus(PV pdi, REFGUID rguid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput::GetDeviceStatus, (_ "pG", pdi, rguid));

    if (SUCCEEDED(hres = hresPvT(pdi))) {
        PDDI this = _thisPv(pdi);
        PDIDW pdidW;

        hres = IDirectInput_CreateDevice(&this->diW, rguid, (PV)&pdidW, 0);
        if (SUCCEEDED(hres)) {
            hres = CDIObj_TestDeviceFlags(pdidW, DIEDFL_ATTACHEDONLY);
            OLE_Release(pdidW);
        }
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(GetDeviceStatus, (PV pdi, REFGUID rguid), (pdi, rguid THAT_))

#else

#define CDIObj_GetDeviceStatusA         CDIObj_GetDeviceStatus
#define CDIObj_GetDeviceStatusW         CDIObj_GetDeviceStatus

#endif

#ifdef DO_THE_IMPOSSIBLE

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | SetAttachedDevice |
 *
 *          Informs DirectInput that a new device has been attached
 *          to the system by the user.  This is useful when an application
 *          asks the user to attach a currently installed device but does
 *          not want to launch the DirectInput control panel.
 *
 *          DirectInput needs to be informed that the device has
 *          been attached for internal bookkeeping purposes.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN LPDIRECTINPUTDEVICE | lpDIDevice |
 *
 *          Identifies the device which has been attached.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          This method is not implemented in the current release
 *          of DirectInput.
 *
 *          This won't work.  We need to receive a port, too.
 *          And how can the app create a <p lpDIDevice> in the
 *          first place for a device that does not exist?
 *          I guess I just don't understand.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_SetAttachedDevice(PV pdi, PV pdid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput::SetAttachedDevice, (_ "pp", pdi, pdid));

    if (SUCCEEDED(hres = hresPvT(pdi))) {
        PDDI this = _thisPv(pdi);

        hres = E_NOTIMPL;
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(SetAttachedDevice, (PV pdi, PV pdid), (pdi, pdid THAT_))

#else

#define CDIObj_SetAttachedDeviceA       CDIObj_SetAttachedDevice
#define CDIObj_SetAttachedDeviceW       CDIObj_SetAttachedDevice

#endif

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | RunControlPanel |
 *
 *          Run the DirectInput control panel so that the user can
 *          install a new input device or modify the setup.
 *
 *          This function will not run third-party control panels.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          Identifies the window handle that will be used as the
 *          parent window for subsequent UI.  NULL is a valid parameter,
 *          indicating that there is no parent window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          No flags are currently defined.  This parameter "must" be
 *          zero.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          The <p dwFlags> is eventually going to allow
 *          <c DIRCP_MODAL> to request a modal control panel.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

STDMETHODIMP
CDIObj_RunControlPanel(PV pdi, HWND hwndOwner, DWORD fl _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput::RunControlPanel, (_ "pxx", pdi, hwndOwner, fl));

    if (SUCCEEDED(hres = hresPvT(pdi)) &&
        SUCCEEDED(hres = hresFullValidHwnd0(hwndOwner, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIRCP_VALID, 2)) ) {

        PDDI this = _thisPv(pdi);

        if(SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion))) {

            /*
             *  We used to run "directx.cpl,@0,3" but directx.cpl is not
             *  redistributable; it comes only with the SDK.  So we just
             *  run the system control panel.
             */

            hres = hresRunControlPanel(TEXT(""));
        }
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(RunControlPanel, (PV pdi, HWND hwndOwner, DWORD fl),
                            (pdi, hwndOwner, fl THAT_))

#else

#define CDIObj_RunControlPanelA         CDIObj_RunControlPanel
#define CDIObj_RunControlPanelW         CDIObj_RunControlPanel

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | Initialize |
 *
 *          Initialize a DirectInput object.
 *
 *          The <f DirectInputCreate> method automatically
 *          initializes the DirectInput object device after creating it.
 *          Applications normally do not need to call this function.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *          <c DIERR_DIERR_OLDDIRECTINPUTVERSION>: The application
 *          requires a newer version of DirectInput.
 *
 *          <c DIERR_DIERR_BETADIRECTINPUTVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of DirectInput.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_Initialize(PV pdi, HINSTANCE hinst, DWORD dwVersion _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput::Initialize, (_ "pxx", pdi, hinst, dwVersion));

    AhAppRegister(dwVersion);

    if (SUCCEEDED(hres = hresPvT(pdi))) {
        PDDI this = _thisPv(pdi);

        if (SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion))) {
            this->dwVersion = dwVersion;
        }
    }

#ifndef DX_FINAL_RELEASE
{
        #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
        SYSTEMTIME st;
        GetSystemTime(&st);

        if (  st.wYear > DX_EXPIRE_YEAR ||
             ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
        ) {
            MessageBox(0, DX_EXPIRE_TEXT,
                          TEXT("Microsoft DirectInput"), MB_OK);
        }
}
#endif
    
    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(Initialize, (PV pdi, HINSTANCE hinst, DWORD dwVersion),
                       (pdi, hinst, dwVersion THAT_))

#else

#define CDIObj_InitializeA              CDIObj_Initialize
#define CDIObj_InitializeW              CDIObj_Initialize

#endif

#ifdef IDirectInput2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIObj_FindDeviceInternal |
 *
 *          The worker function for
 *          <mf IDirectInput2::FindDevice> which works only for HID devices.
 *
 *          For more details, see <mf IDirectInput2::FindDevice>.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the device relative to the class <t GUID>.
 *
 *  @parm   OUT LPGUID | pguidOut |
 *
 *          Pointer to a <t GUID> which receives the instance
 *          <t GUID> for the device, if the device is found.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIObj_FindDeviceInternal(LPCTSTR ptszName, LPGUID pguidOut)
{
    HRESULT hres;

    /*
     *  Look twice.  If it's not found the first time,
     *  then refresh the cache and try again in case
     *  it was for a device that was recently added.
     *  (In fact, it will likely be a device that was
     *  recently added, because FindDevice is usually
     *  called in response to a Plug and Play event.)
     */
    hres = hresFindHIDDeviceInterface(ptszName, pguidOut);
    if (FAILED(hres)) {
        DIHid_BuildHidList(TRUE);
        hres = hresFindHIDDeviceInterface(ptszName, pguidOut);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput2 | FindDevice |
 *
 *          Obtain the instance <t GUID> for a device given
 *          its class <t GUID> and an opaque name.
 *
 *          This method can be used by applications which register
 *          for Plug and Play notifications and are notified by
 *          Plug and Play that a new device has been added
 *          to the system.  The Plug and Play notification will
 *          be in the form of a class <t GUID> and a device name.
 *          The application can pass the <t GUID> and name to
 *          this method to obtain the instance <t GUID> for
 *          the device, which can then be passed to
 *          <mf IDirectInput::CreateDevice> or
 *          <mf IDirectInput::GetDeviceStatus>.
 *
 *  @cwrap  LPDIRECTINPUT2 | lpDirectInput2
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          Class <t GUID> identifying the device class
 *          for the device the application wishes to locate.
 *
 *          The application obtains the class <t GUID> from the
 *          Plug and Play device arrival notification.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the device relative to the class <t GUID>.
 *
 *          The application obtains the class name from the
 *          Plug and Play device arrival notification.
 *
 *  @parm   OUT LPGUID | pguidInstance |
 *
 *          Pointer to a <t GUID> which receives the instance
 *          <t GUID> for the device, if the device is found.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device was found, and its
 *          instance <t GUID> has been stored in <p pguidInstance>.
 *
 *          <c DIERR_DEVICENOTREG> = The <t GUID> and name do not
 *          correspond to a device that is registered with DirectInput.
 *          For example, they may refer to a storage device rather
 *          than an input device.
 *
 *****************************************************************************/

#define cchNameMax      MAX_PATH

STDMETHODIMP
TFORM(CDIObj_FindDevice)(PV pdiT, REFGUID rguid,
                         LPCTSTR ptszName, LPGUID pguidOut)
{
    HRESULT hres;
    EnterProcR(IDirectInput2::FindDevice,
                (_ "pGs", pdiT, rguid, ptszName));

    if (SUCCEEDED(hres = TFORM(hresPv)(pdiT)) &&
        SUCCEEDED(hres = hresFullValidGuid(rguid, 1)) &&
        SUCCEEDED(hres = TFORM(hresFullValidReadStr)(ptszName,
                                                     cchNameMax, 2)) &&
        SUCCEEDED(hres = hresFullValidWritePvCb(pguidOut, cbX(GUID), 3))) {

        if (IsEqualIID(rguid, &GUID_HIDClass)) {
            hres = CDIObj_FindDeviceInternal(ptszName, pguidOut);
        } else {
            hres = DIERR_DEVICENOTREG;
        }
    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
SFORM(CDIObj_FindDevice)(PV pdiS, REFGUID rguid,
                         LPCSSTR psszName, LPGUID pguidOut)
{
    HRESULT hres;
    TCHAR tsz[cchNameMax];
    EnterProcR(IDirectInput2::FindDevice,
                (_ "pGS", pdiS, rguid, psszName));

    /*
     *  TFORM(CDIObj_FindDevice) will validate the rguid and pguidOut.
     */
    if (SUCCEEDED(hres = SFORM(hresPv)(pdiS)) &&
        SUCCEEDED(hres = SFORM(hresFullValidReadStr)(psszName, cA(tsz), 2))) {
        PDDI this = _thisPvNm(pdiS, SFORM(di));

        SToT(tsz, cA(tsz), psszName);

        hres = TFORM(CDIObj_FindDevice)(&this->TFORM(di), rguid, tsz, pguidOut);
    }

    ExitOleProc();
    return hres;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IDirectInput | New |
 *
 *          Create a new instance of an IDirectInput object.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInput::CreateInstance, (_ "Gp", riid, ppvObj));

    hres = Excl_Init();
    if (SUCCEEDED(hres)) {

        /*
         *  Note that we cannot use Common_NewRiid for an object
         *  that aggregates other interfaces!
         *
         *  The reason is that Common_NewRiid will perform
         *  a QI as part of the initialization, but we cannot handle
         *  the QI until after we've been initialized and are
         *  ready to mess with aggregated goo.
         */

        if (SUCCEEDED(hres = hresFullValidRiid(riid, 2))) {
            if (fLimpFF(punkOuter, IsEqualIID(riid, &IID_IUnknown))) {

                hres = Common_New(CDIObj, punkOuter, ppvObj);

                if (SUCCEEDED(hres)) {
                    PDDI this = _thisPv(*ppvObj);

                    this->fCritInited = fInitializeCriticalSection(&this->crst);
                    if( this->fCritInited )
                    {
                        /*
                         *  Only after the object is ready do we QI for the
                         *  requested interface.  And the reason is that the
                         *  QI might cause us to create an aggregated buddy,
                         *  which we can't do until we've been initialized.
                         *
                         *  Don't do this extra QI if we are ourselves aggregated,
                         *  or we will end up giving the wrong punk to the caller!
                         */
                        if (punkOuter == 0) {
                            hres = OLE_QueryInterface(this, riid, ppvObj);
                            OLE_Release(this);
                        }
                        if (FAILED(hres)) {
                            Invoke_Release(ppvObj);
                        }
                    }
                    else
                    {
                        Common_Unhold(this);
                        *ppvObj = NULL;
                        hres = E_OUTOFMEMORY;
                    }
                }
            } else {
                RPF("CreateDevice: IID must be IID_IUnknown if created for aggregation");
                *ppvObj = 0;
                hres = CLASS_E_NOAGGREGATION;
            }
        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CDIObj_Signature        0x504E4944      /* "DINP" */

Interface_Template_Begin(CDIObj)
    Primary_Interface_Template(CDIObj, TFORM(ThisInterfaceT))
  Secondary_Interface_Template(CDIObj, SFORM(ThisInterfaceT))
Interface_Template_End(CDIObj)

Primary_Interface_Begin(CDIObj, TFORM(ThisInterfaceT))
    TFORM(CDIObj_CreateDevice),
    TFORM(CDIObj_EnumDevices),
    TFORM(CDIObj_GetDeviceStatus),
    TFORM(CDIObj_RunControlPanel),
    TFORM(CDIObj_Initialize),
#ifdef IDirectInput2Vtbl
    TFORM(CDIObj_FindDevice),
#ifdef IDirectInput7Vtbl
    TFORM(CDIObj_CreateDeviceEx),
#endif
#endif
Primary_Interface_End(CDIObj, TFORM(ThisInterfaceT))

Secondary_Interface_Begin(CDIObj, SFORM(ThisInterfaceT), SFORM(di))
    SFORM(CDIObj_CreateDevice),
    SFORM(CDIObj_EnumDevices),
    SFORM(CDIObj_GetDeviceStatus),
    SFORM(CDIObj_RunControlPanel),
    SFORM(CDIObj_Initialize),
#ifdef IDirectInput2Vtbl
    SFORM(CDIObj_FindDevice),
#ifdef IDirectInput7Vtbl
    SFORM(CDIObj_CreateDeviceEx),
#endif
#endif
Secondary_Interface_End(CDIObj, SFORM(ThisInterfaceT), SFORM(di))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diport.c ===
/*****************************************************************************
 *
 *  DIPort.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support functions for Gameport/Serialport enumeration.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "dinputpr.h"

/*
 * We can reuse some code from diHidEnm.c
 */
#define DIPort_GetDevicePath(hdev, pdid, didd, dinf) \
        DIHid_GetDevicePath(hdev, pdid, didd, dinf)

#define DIPort_GetDeviceInstanceId(hdev, pdinf, tszId) \
        DIHid_GetDeviceInstanceId(hdev, pdinf, tszId)

#define DIPort_GetInstanceGUID(hk, lpguid)  \
        DIHid_GetInstanceGUID(hk, lpguid)

#define DIPort_GetRegistryProperty(ptszId, dwProperty, pdiph)    \
        DIHid_GetRegistryProperty(ptszId, dwProperty, pdiph)

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#undef  sqfl
#define sqfl sqflPort

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PBUSDEVICE | g_pBusDevice |
 *
 *          List of known GamePort/SerialPort devices.
 *
 *****************************************************************************/

static BUSDEVICE g_pBusDevice[] =
{
    {
        D(TEXT("GamePort Bus") comma)
        NULL,
        &GUID_GAMEENUM_BUS_ENUMERATOR,
        0x0,
        IOCTL_GAMEENUM_EXPOSE_HARDWARE,
        IOCTL_GAMEENUM_REMOVE_HARDWARE,
        IOCTL_GAMEENUM_PORT_DESC,
        IOCTL_GAMEENUM_PORT_PARAMETERS,
        IOCTL_GAMEENUM_EXPOSE_SIBLING,
        IOCTL_GAMEENUM_REMOVE_SELF,
        IDS_STDGAMEPORT,
        JOY_HWS_ISGAMEPORTBUS
    },

    /***************
    No defination for serial port devices yet !
    {
        D(TEXT("SerialPort Bus") comma )
        NULL,
        &GUID_SERENUM_BUS_ENUMERATOR,
        0x0,
        IOCTL_SERIALENUM_EXPOSE_HARDWARE,
        IOCTL_SERIALENUM_REMOVE_HARDWARE,
        IOCTL_SERIALENUM_PORT_DESC,
        IOCTL_SERIALENUM_PORT_PARAMETERS,
        IOCTL_SERIALENUM_EXPOSE_SIBLING,
        IOCTL_SERIALENUM_REMOVE_SELF,
        IDS_STDSERIALPORT,
        JOY_HWS_ISSERIALPORTBUS
    },
    ****************/
};


#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL INTERNAL | SearchDevTree |
 *
 *          Helper routine that searches the device tree for
 *          a desired device device.
 *
 *  @parm   IN DEVINST | dnStart |
 *          Starting point for the search.
 *
 *  @parm   IN DEVINST | dnSeek |
 *          The device instance we are looking for.
 *
 *  @parm   IN PULONG   | pRecurse |
 *          To limit the number of recursions.
 *
 *  @returns    BOOL
 *          True on success.
 *
 *****************************************************************************/
CONFIGRET INTERNAL
    SearchDevTree
    (
    DEVINST dnStart,
    DEVINST dnSeek,
    PUINT   pRecurse
    )
{
#define MAX_RECURSION   ( 4 )

    CONFIGRET   cr;

    EnterProcI(SearchDevTree, (_"xxx", dnStart, dnSeek, pRecurse));

    cr = CR_SUCCESS;
    for( *pRecurse = 0x0; *pRecurse < MAX_RECURSION && cr == CR_SUCCESS; (*pRecurse)++)
    {
        cr = CM_Get_Parent(&dnSeek, dnSeek, 0 );
        if( dnStart == dnSeek )
        {
            break;  
        }
    }    
    if( dnStart != dnSeek )
    {
        cr = CR_NO_SUCH_DEVNODE;
    }
#undef MAX_RECURSION

#if 0 // Using Recursion 
    if( *pRecurse > MAX_RECURSION )
    {
        return CR_NO_SUCH_DEVNODE;
    }

    if( dnSeek == dnStart )
    {
        return CR_SUCCESS;
    }

    do
    {
        DEVINST dnNode;

        cr = CM_Get_Child(&dnNode, dnStart, 0 );
        if( cr == CR_SUCCESS )
        {
            CAssertF(CR_SUCCESS == 0x0 );
            if( CR_SUCCESS == SearchDevTree(dnNode, dnSeek, pRecurse) )
            {
                return cr;
            }
        }
        cr = CM_Get_Sibling(&dnStart, dnStart, 0);

    }while( cr == CR_SUCCESS );
#endif  // No recursion 

    return cr;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PBUSDEVICEINFO | pbdiFromphdi |
 *
 *          Locates Gameport/Serialport information given a device instance of
 *          one of its children.
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PHIDDEVICEINFO | phdi |
 *
 *          Address of a HIDDEVICEINFO structure
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the parent bus.
 *
 *****************************************************************************/
PBUSDEVICEINFO INTERNAL
    pbdiFromphdi
    (
    IN PHIDDEVICEINFO phdi
    )
{
    PBUSDEVICEINFO pbdi_Found;
    PBUSDEVICE     pBusDevice;
    int iBusType;

    EnterProcI(pbdiFromphdi, (_"x", phdi));

    AssertF(InCrit());
    AssertF(phdi != NULL );

    pbdi_Found = NULL;
    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice) && pbdi_Found == NULL;
       iBusType++, pBusDevice++ )
    {
        HDEVINFO hdev;
        /*
         *  Now talk to SetupApi to get info about the device.
         */
        hdev = SetupDiCreateDeviceInfoList(NULL, NULL);

        if(hdev != INVALID_HANDLE_VALUE  )
        {
            SP_DEVINFO_DATA dinf_hid;

            ZeroX(dinf_hid);

            dinf_hid.cbSize = cbX(SP_DEVINFO_DATA);

            /* Get SP_DEVINFO_DATA for the HID device */
            if( pBusDevice->pbdl != NULL  &&
                phdi!= NULL  &&
                SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf_hid))
            {
                int igdi;
                PBUSDEVICEINFO pbdi;
                SP_DEVINFO_DATA dinf_bus;

                ZeroX(dinf_bus);

                dinf_bus.cbSize = cbX(SP_DEVINFO_DATA);

                /*
                 * Loop through all known gameports/serialports and look for a gameport/serialport
                 * that is a parent of the HID device
                 */

                for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
                   igdi < pBusDevice->pbdl->cgbi && pbdi_Found == NULL ;
                   igdi++, pbdi++)
                {
                    if(SetupDiOpenDeviceInfo(hdev, pbdi->ptszId, NULL, 0, &dinf_bus))
                    {
                        ULONG Recurse = 0x0;
                        if( CR_SUCCESS == SearchDevTree(dinf_bus.DevInst, dinf_hid.DevInst, &Recurse) )
                        {
                            pbdi_Found = pbdi;
                            break;
                        }
                    }
                }
            }
            SetupDiDestroyDeviceInfoList(hdev);
        }
    }
    ExitProcX((UINT_PTR)pbdi_Found);
    return pbdi_Found;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PBUSDEVICEINFO | pbdiFromGUID |
 *
 *          Locates Gameport/Serialport information given a device instance of
 *          one of its children.
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the parent bus.
 *
 *****************************************************************************/
PBUSDEVICEINFO EXTERNAL
    pbdiFromGUID
    (
    IN PCGUID pguid
    )
{
    PBUSDEVICEINFO pbdi_Found;
    PBUSDEVICE     pBusDevice;
    int iBusType;

    EnterProcI(pbdiFromGUID, (_"G", &pguid));

    AssertF(InCrit());

    pbdi_Found = NULL;
    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice) && pbdi_Found == NULL;
       iBusType++, pBusDevice++ )
    {
        /*
         * Loop through all known gameports/serialports and look for a gameport/serialport
         * that is a parent of the HID device
         */
        PBUSDEVICEINFO pbdi;
        int igdi;
        for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
           igdi < pBusDevice->pbdl->cgbi && pbdi_Found == NULL ;
           igdi++, pbdi++)
        {
            if( IsEqualGUID(pguid, &pbdi->guid)  )
            {
                pbdi_Found = pbdi;
            }
        }
    }
    ExitProcX((UINT_PTR)pbdi_Found);
    return pbdi_Found;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFrompbdi |
 *
 *          Locates a HID device attached to a given Gameport/Serialport
 *          Returns NULL if no devices are currently attached to a known port.
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PBUSDEVICEINFO | pbdi |
 *
 *          Address of the <t BUSDEVICEINFO> structure that
 *          describes the gameport/serialport.
 *
 *  @returns
 *
 *          Pointer to one of the <t HIDDEVICEINFO> that describes
 *          the device. ( Gamport may have multiple devices attached ).
 *
 *****************************************************************************/

PHIDDEVICEINFO INTERNAL
    phdiFrompbdi
    (
    IN PBUSDEVICEINFO pbdi
    )
{
    PHIDDEVICEINFO phdi_Found;
    HDEVINFO hdev;

    EnterProcI(phdiFrompbdi, (_"x", pbdi));

    AssertF(InCrit());
    AssertF(pbdi != NULL );

    /* Enumurate the HID devices */
    DIHid_BuildHidList(TRUE);

    phdi_Found = NULL;
    /*
     *  Now talk to SetupApi to get info about the device.
     */
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);

    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf_bus;

        dinf_bus.cbSize = cbX(SP_DEVINFO_DATA);

        if( pbdi != NULL && SetupDiOpenDeviceInfo(hdev, pbdi->ptszId, NULL, 0, &dinf_bus))
        {
            int ihdi;
            PHIDDEVICEINFO phdi;
            SP_DEVINFO_DATA dinf_hid;
            dinf_hid.cbSize = cbX(SP_DEVINFO_DATA);

            if( g_phdl )
            {
                for(ihdi = 0, phdi = g_phdl->rghdi ;
                   ihdi < g_phdl->chdi && phdi_Found == NULL ;
                   ihdi++, phdi++)
                {
                    if(SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf_hid))
                    {
                        ULONG Recurse = 0x0;
                        if(CR_SUCCESS == SearchDevTree(dinf_bus.DevInst, dinf_hid.DevInst, &Recurse) )
                        {
                            phdi_Found = phdi;
                        }
                    }
                }
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);
    }

    ExitProcX((UINT_PTR)phdi_Found);
    return phdi_Found;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   PPORTDEVICEINFO | pbdiFromJoyId |
 *
 *          Locates Gameport/Serialport information given a device id of
 *          a joystick .
 *
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Joystick ID of the child device that will be associated
 *          to a known gameport/serialport.
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PBUSDEVICEINFO EXTERNAL
    pbdiFromJoyId
    (
    IN int idJoy
    )
{
    GUID guid;
    HRESULT hres;
    PBUSDEVICEINFO pbdi;

    EnterProcI(pbdiFromJoyId, (_"x", idJoy));
    AssertF(InCrit());

    pbdi = NULL;

    /* Find the GUID that corresponds to the Joystick ID */
    hres = hResIdJoypInstanceGUID_WDM(idJoy, &guid);
    
    if( (hres != S_OK) && !fWinnt ) {
        hres = hResIdJoypInstanceGUID_95(idJoy, &guid);
    }

    if( SUCCEEDED(hres) )
    {
        PHIDDEVICEINFO phdi;
        phdi = phdiFindHIDInstanceGUID(&guid);

        if( phdi != NULL )
        {
            pbdi = pbdiFromphdi(phdi);
        }
    }

    ExitProcX((UINT_PTR)pbdi);
    return pbdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIBusDevice_Expose |
 *
 *  Attaches a gameport/serialport device to the Gameport/SerialPort Bus
 *
 *  @parm   IN PBUSDEVICEINFO | pbdi |
 *          Address of a BUSDEVICEINFO structure.
 *
 *  @parm   IN OUT PBUS_REGDATA    | pRegData |
 *          Gameport/Serialport specific data. The Handle to the opened device
 *          is returned in this structure
 *
 *
 *  @returns
 *          BOOL. True indicates success.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIBusDevice_Expose
    (
    IN     PBUSDEVICEINFO  pbdi,
    IN OUT PBUS_REGDATA    pRegData
    )
{
    HRESULT hres;
    BOOL frc;
    PHIDDEVICEINFO  phdi;

    EnterProcI(DIBusDevice_Expose, (_ "pp", pbdi, pRegData));

    AssertF(DllInCrit() );
    AssertF(pbdi!= NULL );

    phdi = phdiFrompbdi(pbdi);

    if( pRegData && pRegData->dwSize != cbX(*pRegData) )
    {
        hres = E_INVALIDARG;
    } else if( phdi != NULL )
    {
        hres = E_ACCESSDENIED;
    } else
    {
        HANDLE hf;
		BUS_REGDATA RegDataTest;

        /* There is a weird condition where the HID device does not appear on a previous
         * Add, (drivers not loaded, user cancelled loading of some files, etc
         * In such cases we need to tell GameEnum to remove the device before proceeding
         * any further
         */
        if( pbdi->fAttached || pRegData->hHardware != NULL )
        {
            DIBusDevice_Remove(pbdi);
        }
        AssertF(pbdi->fAttached == FALSE);

		// Change for Windows bug 575181 -- make sure we can write to the registry
		// before we expose the device; otherwise we might not be able to remove it!
		ZeroMemory(&RegDataTest, cbX(RegDataTest));
		RegDataTest.dwSize = cbX(RegDataTest);
		if (FAILED(DIBusDevice_SetRegData(pbdi->hk,  &RegDataTest)))
		{
			// We couldn't write to the registy; return E_ACCESSDENIED
			hres = E_ACCESSDENIED;
		}
		else
		{

        // Open a File handle to the gameport/serialport device so we can send it IOCTLS
        hf = CreateFile(pbdi->pdidd->DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,                /* no SECURITY_ATTRIBUTES */
                        OPEN_EXISTING,
                        0,                /* attributes */
                        0);               /* template */

        if( hf != INVALID_HANDLE_VALUE )
        {
            DWORD cbRc;
            GAMEENUM_PORT_DESC  Desc;
            Desc.Size = cbX(Desc) ;

            Sleep(50);  //need sleep a while to wait for the device is ready to accept commands.

            /* Get the gameport bus properties */
            frc = DeviceIoControl (hf,
                                   pbdi->pBusDevice->ioctl_DESC,
                                   &Desc, cbX(Desc),
                                   &Desc, cbX(Desc),
                                   &cbRc, NULL);
            if( frc  && cbRc == cbX(Desc) )
            {
                PGAMEENUM_EXPOSE_HARDWARE pExpose;
                DWORD cbExpose;
                cbExpose = cbX(*pExpose) + cbX(pRegData->wszHardwareId);

                hres = AllocCbPpv( cbExpose, & pExpose);

                if( SUCCEEDED(hres ) )
                {
                    typedef struct _OEMDATA
                    {
                        ULONG   uVID_uPID;
                        ULONG   joy_hws_dwFlags;
                        ULONG   dwFlags1;
                        ULONG   Reserved;
                    } OEMDATA, *POEMDATA;

                    POEMDATA    pOemData = (POEMDATA)(&pExpose->OemData);
                    CAssertF(2*sizeof(*pOemData) == sizeof(pExpose->OemData))

                    pOemData->uVID_uPID = MAKELONG(pRegData->uVID, pRegData->uPID);
                    pOemData->joy_hws_dwFlags = pRegData->hws.dwFlags;
                    pOemData->dwFlags1 = pRegData->dwFlags1;

                    /*
                     *  Make sure only known analog devices cause the 
                     *  compatible hardware ID to be exposed.
                     *  This is done so that no in-box drivers will match for 
                     *  an unsupported digital joystick so users will be 
                     *  prompted to use an unsigned IHV driver rather than 
                     *  silently loading the generic analog joystick driver.
                     */
                    if( ( pRegData->dwFlags1 & JOYTYPE_ANALOGCOMPAT )
                     || ( ( pRegData->uVID == MSFT_SYSTEM_VID )
                       && ( ( pRegData->uPID & 0xff00 ) == MSFT_SYSTEM_PID ) ) )
                    {
                        pExpose->Flags = GAMEENUM_FLAG_COMPATIDCTRL;
                    }
                    else
                    {
                        pExpose->Flags = GAMEENUM_FLAG_COMPATIDCTRL | GAMEENUM_FLAG_NOCOMPATID ;
                    }

                    pExpose->Size            = cbX(*pExpose) ;
                    pExpose->PortHandle      = Desc.PortHandle;
                    pExpose->NumberJoysticks = pRegData->nJoysticks;

                    pRegData->nAxes          = 2;

                    if( pExpose->NumberJoysticks != 2 )
                    {
                        AssertF( pExpose->NumberJoysticks == 1);
                        if( pRegData->hws.dwFlags & JOY_HWS_HASZ )
                        {
                            pRegData->nAxes++;
                        }
                        if( pRegData->hws.dwFlags & JOY_HWS_HASR )
                        {
                            pRegData->nAxes++;
                        }
                        pExpose->NumberButtons   = (USHORT)pRegData->hws.dwNumButtons;
                    }
                    else
                    {
                        pOemData++;
                        pOemData->uVID_uPID = MAKELONG(pRegData->uVID, pRegData->uPID);
                        pOemData->joy_hws_dwFlags = JOY_HWS_XISJ2X | JOY_HWS_YISJ2Y;
                        pExpose->NumberButtons = 2;
                    }

                    pExpose->NumberAxis = pRegData->nAxes;

                    /*
                     *  The SideWinder driver uses the OEMData field in a 
                     *  sibling expose to pass internal data (this ptrs) from 
                     *  one instance to another.  Since these fields are 
                     *  supposed to be for the OEMData we have a Flags1 field 
                     *  to allow the data to be zeroed for a DInput expose for 
                     *  drivers that don't want the normal data.
                     */

                    if ( pRegData->dwFlags1 & JOYTYPE_ZEROGAMEENUMOEMDATA )                      
                    {
                        ZeroBuf(pExpose->OemData, sizeof(pExpose->OemData) );
                    }

                    CopyMemory(pExpose->HardwareIDs, pRegData->wszHardwareId, cbX(pRegData->wszHardwareId) );

                    if( frc = DeviceIoControl (hf,
                                               pbdi->pBusDevice->ioctl_EXPOSE,
                                               pExpose, cbExpose,
                                               pExpose, cbExpose,
                                               &cbRc, NULL )
                        && cbRc == cbExpose )
                    {
                        PVOID hHardwareOld = pRegData->hHardware;

                        pbdi->fAttached = TRUE;
                        pRegData->hHardware = pExpose->HardwareHandle;
                        DIBusDevice_SetRegData(pbdi->hk,  pRegData);

                        /*
                         * If we have dealt with this device before then the hHardwareOld
                         * will be non null, and we have sufficient reason to believe that the
                         * expose will succeed.
                         *
                         * This test needs to be removed to fix manbug: 39554. 
                         * For new created device, we need wait for a while to let phdi be ready.
                         * 
                         */
                        //if(hHardwareOld)
                        {
                            int i;
                            for(i = 0x0; i < 20 && phdiFrompbdi(pbdi) == NULL ; i++ )
                            {
                                Sleep(50);
                            }
                        }

                    } else // DeviceIOControl (EXPOSE) Failed
                    {
                        hres = E_FAIL;
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: IOCTL_PORTENUM_EXPOSE_HARDWARE failed  ")
                                        TEXT("Error = %d"),
                                        s_szProc, GetLastError());
                    }
                    FreePpv(&pExpose);
                } else // Alloc failed
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: AllocCbPpv  failed  "),
                                    s_szProc);
                }
            } else // IOCTL FAILED
            {
                hres = E_FAIL;
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: IOCTL_PORTENUM_PORT_DESC failed ")
                                TEXT("Error = %d"),
                                s_szProc, GetLastError());
            }

            CloseHandle(hf);
        } else
        {
            hres = E_FAIL;
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%S: CreateFile(%s) failed  ")
                            TEXT("Error = %d"),
                            s_szProc, pbdi->pdidd->DevicePath, GetLastError());
        }
		}
    }
    ExitBenignProcX(hres);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIBusDevice_Remove |
 *
 *  Removes the FDO for a gameport/serialport device.
 *
 *  @parm   IN HANDLE | hf |
 *          Handle to the GamePort/SerialPort Bus device file object
 *
 *  @parm   IN PPORT_REGDATA    | pRegData |
 *          Structure that contains registry data. What we need from here is the
 *          handle to the hardware.
 *
 *  @returns
 *          BOOL. True for success.
 *
 *****************************************************************************/

HRESULT INTERNAL
    DIBusDevice_Remove
    (
    IN PBUSDEVICEINFO  pbdi
    )
{
    HRESULT hres;
    BUS_REGDATA RegData;

    EnterProcI(DIBus_Remove, (_ "p", pbdi));

    hres = DIBusDevice_GetRegData(pbdi->hk,  &RegData);

    //
    //  Delete our registry goo, so this device
    //  will not show up on subsequent reboots
    //
    DIBusDevice_SetRegData(pbdi->hk,  NULL);

    if( SUCCEEDED(hres) )
    {
        HANDLE hf;
        BOOL frc;

        // Open a File handle to the gameport/serialport device so we can send it IOCTLS
        hf = CreateFile(pbdi->pdidd->DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,                /* no SECURITY_ATTRIBUTES */
                        OPEN_EXISTING,
                        0,                /* attributes */
                        0);               /* template */

        if( hf != INVALID_HANDLE_VALUE )
        {

            DWORD cbRc;
            GAMEENUM_REMOVE_HARDWARE Remove;

            Remove.Size = cbX(Remove);
            Remove.HardwareHandle = RegData.hHardware;

            frc = DeviceIoControl (hf,
                                   pbdi->pBusDevice->ioctl_REMOVE,
                                   &Remove, cbX(Remove),
                                   &Remove, cbX(Remove),
                                   &cbRc, NULL) ;
            if( frc &&  cbRc == cbX(Remove) )
            {
                pbdi->fAttached = FALSE;
            } else // DeviceIoControl ( REMOVE_HARDWARE ) Failed
            {
                hres = E_FAIL;
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: DeviceIOControl(REMOVE_HARDWARE) failed  ")
                                TEXT("Error = %d"),
                                s_szProc, GetLastError());
            }
            CloseHandle(hf);
        }
    }

    ExitBenignOleProc();

    return hres;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIPort_SetRegData |
 *
 *          Sets up registry data under the $hk$/Config subkey for the gameport
 *          device.
 *
 *  @parm   IN HKEY | hk |
 *          A handle to the parent key where the registry data will be written.
 *
 *  @parm   IN PGAMEPORT_REGDATA | pRegData |
 *          Pointer to a structure containing data to be written to the registry.
 *
 *  @returns
 *          BOOL. True for success
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIBusDevice_SetRegData
    (
    IN HKEY hk,
    IN PBUS_REGDATA pRegData
    )
{
    LONG    lrc;
    HRESULT hres = S_OK;

    EnterProcI(DIPort_SetRegData, (_ "xpx", hk, pRegData ));

    if( pRegData != NULL )
    {

        if( ( lrc =  RegSetValueEx(hk, TEXT("Config"), 0, REG_BINARY,
                                   (PV) (pRegData), cbX(*pRegData)) )  == ERROR_SUCCESS )
        {
            hres = S_OK;
        } else // RegSetValueEx FAILED
        {
            hres = E_FAIL;
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%S: RegSetValueEx() failed ")
                            TEXT("Error = %d"),
                            s_szProc, lrc);
        }
    } else
    {
        lrc = RegDeleteValue(hk, TEXT("Config"));
    }

    ExitOleProc();
    return (hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIPort_GetRegData |
 *
 *          Gets registry data from the $hk$/Config subkey for the gameport
 *          device.
 *
 *  @parm   IN HKEY | hk |
 *          A handle to the parent key where the registry.
 *
 *  @parm   IN PGAMEPORT_REGDATA | pRegData |
 *          Address of a pointer to the structure where the registry data
 *          will be read into.
 *
 *  @returns
 *          HRESULT
 *****************************************************************************/
HRESULT INTERNAL
    DIBusDevice_GetRegData
    (
    IN HKEY hk,
    OUT PBUS_REGDATA pRegData
    )
{
    LONG    lRc;
    DWORD cb;
    HRESULT hres;

    EnterProcI(DIPort_GetRegData, (_ "xpx", hk, pRegData ));

    cb = cbX(*pRegData);

    lRc = RegQueryValueEx( hk, TEXT("Config"), 0, 0 , (PV)(pRegData), &cb );

    if( lRc == ERROR_SUCCESS && pRegData->dwSize == cbX(*pRegData ) )
    {
        hres = S_OK;
    } else
    {
        DIBusDevice_SetRegData(hk, NULL );
        ZeroX(*pRegData);
        hres = E_FAIL;

        SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("%S: RegQueryValueEx(Config) failed ")
                        TEXT("Error = %d, ( pRegData->cbSize(%d) == cbX(*pRegData)(%d)) "),
                        s_szProc, lRc, pRegData->dwSize, cbX(*pRegData) );
    }

    ExitBenignOleProc();
    return ( hres ) ;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIBus_BuildListEntry |
 *
 *          Builds a single entry in the list of GAMEPORT/SERIALPORT devices.
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device list being enumerated.
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device that was enumerated.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIBusDevice_BuildListEntry
    (
    HDEVINFO hdev,
    PSP_DEVICE_INTERFACE_DATA pdid,
    PBUSDEVICE pBusDevice
    )
{
    BOOL fRc = TRUE;
    //HKEY hkDev;
    PBUSDEVICEINFO pbdi;
    PBUSDEVICELIST pbdl;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
    BOOL    fAlreadyExist;

    HRESULT hres;

    EnterProcI(DIBus_BuildListEntry, (_ "xp", hdev, pdid));

    pbdl = pBusDevice->pbdl;

    fAlreadyExist = FALSE;

    /* GetDevicePath is expecting a NULL */
    pdidd = NULL;
    
    if( DIPort_GetDevicePath(hdev, pdid, &pdidd, NULL) )
    {
        int ibdi;
        //Check whether the device has been in the list
        for( ibdi = 0; ibdi < pbdl->cgbi; ibdi++)
        {
            if( pbdl->rgbdi[ibdi].pdidd )
            {
                if( lstrcmp( pdidd->DevicePath, pbdl->rgbdi[ibdi].pdidd->DevicePath ) == 0 )
                {
                    //already in the list
                    fAlreadyExist = TRUE;
                    break;
                }
            }
        }
        FreePpv(&pdidd);
    }

    if( fAlreadyExist == TRUE )
    {
        fRc = TRUE;
    } else
    {
        /*
         *  Make sure there is room for this device in the list.
         *  Grow by doubling.
         */
        if( pbdl->cgbi >= pbdl->cgbiAlloc)
        {
            hres = ReallocCbPpv( cbGdlCbdi( pbdl->cgbiAlloc * 2), &pBusDevice->pbdl );
            // Prefix: Whistler 45084
            if(FAILED(hres) && (pBusDevice->pbdl == NULL) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: Realloc failed"), s_szProc);
                fRc = FALSE;
                goto done;
            }
            pbdl = pBusDevice->pbdl;
            pbdl->cgbiAlloc *= 2;
        }

        AssertF( pbdl->cgbi < pbdl->cgbiAlloc);

        pbdi        = &pbdl->rgbdi[pbdl->cgbi];
        pbdi->pBusDevice = pBusDevice;
        pbdi->hk    = 0;
        pbdi->idJoy = JOY_BOGUSID;

        /*
         *  Open the registry key for the device so we can obtain
         *  auxiliary information, creating it if necessary.
         */
        {
			HKEY hkDin;
            //Open our own reg key under MediaProperties\DirectInput,
			//creating it if necessary.
			hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
								   REGSTR_PATH_DITYPEPROP,
								   DI_KEY_ALL_ACCESS, 
								   REG_OPTION_NON_VOLATILE, 
								   &hkDin);
			if (SUCCEEDED(hres))
			{
				//Create the Gameports reg key
				HKEY hkGameports;
				hres = hresMumbleKeyEx(hkDin,
									   TEXT("Gameports"),
									   DI_KEY_ALL_ACCESS,
									   REG_OPTION_NON_VOLATILE,
									   &hkGameports);
				if (SUCCEEDED(hres))
				{
					//Create a reg key corresponding to the instance number.
					//Since we do this for every gameport enumerated, the number in the list
					//indicates the instance number.
					TCHAR tszInst[3];
					wsprintf(tszInst, TEXT("%u"), pbdl->cgbi);

					hres = hresMumbleKeyEx(hkGameports,
									   tszInst,
									   DI_KEY_ALL_ACCESS,
									   REG_OPTION_NON_VOLATILE,
									   &pbdi->hk);

				if(SUCCEEDED(hres))
				{
					SP_DEVINFO_DATA dinf;
					dinf.cbSize = cbX(SP_DEVINFO_DATA);

					/*
					 *  Get the instance GUID and the path to
					 *  the GAMEPORT/SERIALPORT device so we can talk to it.
					 */
					if(DIPort_GetDevicePath(hdev, pdid, &pbdi->pdidd, &dinf) &&
					   DIPort_GetDeviceInstanceId(hdev, &dinf, &pbdi->ptszId) &&
					   DIPort_GetInstanceGUID(pbdi->hk, &pbdi->guid) )
					{
						HANDLE hf;
						hf = CreateFile(pbdi->pdidd->DevicePath,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ | FILE_SHARE_WRITE,
										0,                /* no SECURITY_ATTRIBUTES */
										OPEN_EXISTING,
										0,                /* attributes */
										0);               /* template */

						if( hf != INVALID_HANDLE_VALUE )
						{

							BUS_REGDATA  RegData;
							ZeroX(RegData);

							CloseHandle(hf);

							// Bump up the counter
							fRc = TRUE;
							pbdl->cgbi++;

							hres = DIBus_InitId(pBusDevice->pbdl);

							if( SUCCEEDED(hres) )
							{
								hres = DIBusDevice_GetRegData(pbdi->hk, &RegData);
							}

							if(  SUCCEEDED(hres)  )
							{
								/* There is a pathological case which can cause endless bluescreen's
								 * If the HID driver causes a bluescreen, and we keep reattaching
								 * it, we are sunk !!
								 * To guard against this possiblity we reattach a device on reboot
								 * only if we are sure that it succeeded the first time around
								 */
								if( RegData.fAttachOnReboot == FALSE )
								{
									DIBusDevice_Remove(pbdi);

									SquirtSqflPtszV(sqfl | sqflError,
													TEXT("%S: DIPortDevice_Expose FAILED, ")
													TEXT("Driver did not load property the first time around "),
													s_szProc);
								} else if( pbdi->fAttached == FALSE )
								{
									hres = DIBusDevice_Expose( pbdi,  &RegData );
									if( SUCCEEDED( hres ) || hres == E_ACCESSDENIED )
									{
										pbdi->fAttached = TRUE;
									} else
									{
										SquirtSqflPtszV(sqfl | sqflError,
														TEXT("%S: DIPortDevice_Expose FAILED ")
														TEXT("hres = %d"),
														s_szProc, hres);
									}
								}
							}

						} else
						{
							fRc = FALSE;

							SquirtSqflPtszV(sqfl | sqflError,
											TEXT("%S: CreateFile(%s) failed  ")
											TEXT("Error = %d"),
											s_szProc, pbdi->pdidd->DevicePath, GetLastError());
						}

					} else
					{
						SquirtSqflPtszV(sqfl | sqflError,
										TEXT("%S: Unable to get device path"),
										s_szProc);
						pbdi->hk = 0x0;
						fRc = FALSE;
					}

					/*
					 *  If we failed, then free the goo we already got.
					 */
					if(!fRc)
					{
						if( pbdi->hk )
							RegCloseKey(pbdi->hk);
						pbdi->hk = 0;
						FreePpv(&pbdi->pdidd);
						FreePpv(&pbdi->ptszId);
						fRc = FALSE;
					}

				} else // RegCreateKeyEx FAILED
				{
					SquirtSqflPtszV(sqfl | sqflError,
									TEXT("%S: RegCreateKeyEx failed on Instance, error "),
									s_szProc);
					fRc = FALSE;
				}

				RegCloseKey(hkGameports);

				} else // RegCreateKeyEx FAILED
				{
					SquirtSqflPtszV(sqfl | sqflError,
									TEXT("%S: RegCreateKeyEx failed on Gameports, error "),
									s_szProc);
					fRc = FALSE;
				}

				RegCloseKey(hkDin);
			}
			else
			{
				SquirtSqflPtszV(sqfl | sqflError,
									TEXT("%S: RegOpenKeyEx failed on DirectInput, error "),
									s_szProc);
				fRc = FALSE;
			}

        } 
    }
    done:;
    ExitProcF(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIPort_EmptyList |
 *
 *          Empty the list of GAMEPORT/SERIALPORT devices.
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIBus_EmptyList
    (
    PBUSDEVICELIST *ppbdl
    )
{
    PBUSDEVICELIST pbdl = *ppbdl;

    AssertF(InCrit());

    if( pbdl )
    {
        int igdi;
        for(igdi = 0; igdi < pbdl->cgbi; igdi++)
        {
            FreePpv(&pbdl->rgbdi[igdi].pdidd);
            FreePpv(&pbdl->rgbdi[igdi].ptszId);
            if( pbdl->rgbdi[igdi].hk)
            {
                RegCloseKey( pbdl->rgbdi[igdi].hk);
            }
        }
        /*
         *  We invalidated all the pointers, so make sure
         *  nobody looks at them.
         */
        pbdl->cgbi = 0;
        FreePpv(&pbdl);
        *ppbdl = NULL;
    }
}

void EXTERNAL
    DIBus_FreeMemory()
{
    int iBusType;
    PBUSDEVICE pBusDevice;

    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        DIBus_EmptyList(&pBusDevice->pbdl);
    }
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIPort_InitId |
 *
 *          Initializes Joystick IDs for JoyConfig and legacy APIs
 *          Store the joystick IDs the registry under the %%DirectX/JOYID key.
 *
 *****************************************************************************/

#undef  PORTID_BOGUS
#define PORTID_BOGUS    ( 0xffffffff )

HRESULT EXTERNAL
    DIBus_InitId(PBUSDEVICELIST pbdl)
{
    HRESULT hres = FALSE;
    LONG    lRc;
    DWORD   cb;
    int     igdi;
    BOOL    fNeedId;
    BOOL    rfPortId[cgbiMax];     /* Bool Array for to determine which IDs are in use */
    PBUSDEVICEINFO pbdi;

    EnterProcI(DIBus_InitId, (_ ""));

    fNeedId = FALSE;

    AssertF(DllInCrit());

    ZeroX(rfPortId );


    if( pbdl != NULL )
    {
        /* Iterate over to find used IDs */
        for( igdi = 0, pbdi = pbdl->rgbdi ;
           igdi < pbdl->cgbi ;
           igdi++, pbdi++ )
        {
            pbdi->idPort = PORTID_BOGUS;  // Default

            cb = cbX(pbdi->idPort);
            if( ( lRc = RegQueryValueEx(pbdi->hk, TEXT("ID"),
                                        0, 0, (PV)&pbdi->idPort, &cb) == ERROR_SUCCESS ) )
            {
                if(    rfPortId[pbdi->idPort]           // Collision in GameId
                       || pbdi->idPort > cgbiMax  )       // Wrror
                {
                    pbdi->idPort = PORTID_BOGUS;
                    fNeedId = TRUE;
                } else  // Valid idPort
                {
                    rfPortId[pbdi->idPort] = TRUE;

                }
            } else // RegQueryValue("ID") does not exist
            {
                fNeedId = TRUE;
            }
        }

        if( fNeedId )
        {
            /*
             * We have Examined all GamePort/SerialPort Ids found used IDs
             * and determined some device needs an Id
             */
            /* Iterate to assign unused Id's */
            for( igdi = 0, pbdi = pbdl->rgbdi;
               igdi < pbdl->cgbi ;
               igdi++, pbdi++ )
            {
                if( pbdi->idPort == PORTID_BOGUS  )
                {
                    /* Get an Unused ID */
                    for( pbdi->idPort = 0x0;
                       pbdi->idPort < cgbiMax;
                       pbdi->idPort++ )
                    {
                        if( rfPortId[pbdi->idPort] == FALSE )
                            break;
                    }
                    rfPortId[pbdi->idPort] = TRUE;

                    if( lRc = RegSetValueEx(pbdi->hk, TEXT("ID"), 0, REG_BINARY,
                                            (PV)&pbdi->idPort, cbX(pbdi->idPort)) == ERROR_SUCCESS )
                    {

                    } else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: RegSetValueEx(JOYID) FAILED ")
                                        TEXT("Error = %d"),
                                        s_szProc, lRc);
                        hres = FALSE;
                    }
                }
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIBus_CheckList |
 *
 *          Check the list of HID devices and free any that cannot be opened
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIBus_CheckList(PBUSDEVICELIST pbdl)
{
    HANDLE hf;

    AssertF(InCrit());

    /*
     *  Free all the information of the device that cannot be opened
     */
    if(pbdl)
    {
        int ibdi;

        PBUSDEVICEINFO pbdi;
        for(ibdi = 0, pbdl->cgbi = 0; ibdi < pbdl->cgbiAlloc; ibdi++)
        {
            pbdi = &pbdl->rgbdi[ibdi];
            if( pbdi && pbdi->pdidd )
            {
                /*
                 *  Open the device
                 */
                hf = CreateFile(pbdi->pdidd->DevicePath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0,                /* attributes */
                                0);               /* template */

                if(hf == INVALID_HANDLE_VALUE)
                {
                    FreePpv(&pbdi->pdidd);
                    FreePpv(&pbdi->ptszId);
                    if(pbdi->hk)
                    {
                        RegCloseKey(pbdi->hk);
                    }
                    ZeroX( pbdi );
                } else
                {
                    pbdl->cgbi++;
                    CloseHandle(hf);
                }
            }
        }

        //re-order the existing devices, put them at the front of the hid list.
        for(ibdi = 0; ibdi < pbdl->cgbi; ibdi++)
        {
            if( !pbdl->rgbdi[ibdi].pdidd )
            {
                int ibdi2;

                //find the existing device from the biggest index in the hid list.
                for( ibdi2 = pbdl->cgbiAlloc; ibdi2 >= ibdi+1; ibdi2-- )
                {
                    if( pbdl->rgbdi[ibdi2].pdidd )
                    {
                        memcpy( &pbdl->rgbdi[ibdi], &pbdl->rgbdi[ibdi2], sizeof(BUSDEVICEINFO) );
                        ZeroX( pbdl->rgbdi[ibdi2] );
                    }
                }
            }
        }

    }

    return;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIBus_BuildList |
 *
 *          Builds the list of GAMEPORT/SERIALPORT devices.
 *
 *  @parm   BOOL | fForce |
 *
 *          If nonzero, we force a rebuild of the GAMEPORT/SERIALPORT list.
 *          Otherwise, we rebuild only if the list hasn't
 *          been rebuilt recently.
 *
 *****************************************************************************/

#define MSREBUILDRATE       20000                /* Twenty seconds */

ULONG EXTERNAL
    DIBus_BuildList( IN BOOL fForce )
{
    HRESULT hres;
    PBUSDEVICE pBusDevice;
    ULONG cDevices;
    int iBusType;
    DWORD    dwTickCount;

    EnterProcI(DIBus_BuildList, (_ "u", fForce));

    DllEnterCrit();

    /*
     *  Decide whether or not to rebuild once (don't want to half rebuild)
     */
    dwTickCount = GetTickCount();

    // Force implies a complete rebuild of the list. 
    if(fForce) 
    {
        DIBus_FreeMemory();
    }
    
    DIHid_BuildHidList(fForce);

    hres = S_OK;
    for( cDevices = iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        PBUSDEVICELIST pbdl;
        pbdl = pBusDevice->pbdl;

        if( HidD_GetHidGuid &&                          /* HID support */
            ( fForce ||                                 /* Forcing rebuild, or */
              pBusDevice->tmLastRebuild == 0 ||         /* Never built before, or */
              dwTickCount - pBusDevice->tmLastRebuild > MSREBUILDRATE )
          )
        {
            HDEVINFO hdev;

            /* delete devices that disappeared since we last looked */
            DIBus_CheckList(pbdl);

            hdev = SetupDiGetClassDevs((LPGUID)pBusDevice->pcGuid, 0, 0,
                                       DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

            if(hdev != INVALID_HANDLE_VALUE)
            {
                /*
                 *  There is no way to query the number of devices.
                 *  You just have to keep incrementing until you run out.
                 *
                 *  If we already have a pbdl, then re-use it.  Else, create
                 *  a new one.  Alloc up to the minimum starting point.
                 */

                if( pBusDevice->pbdl == NULL )
                {
                    hres = AllocCbPpv(cbGdlCbdi(cgbiInit), &pBusDevice->pbdl );

                    if(SUCCEEDED(hres))
                    {
                        pbdl = pBusDevice->pbdl;
                        pbdl->cgbi = 0;
                        pbdl->cgbiAlloc = cgbiInit;
                    }
                }

                if( SUCCEEDED(hres) )
                {
                    int idev;

                    /*
                     *  To avoid infinite looping on
                     *  internal error, break on any
                     *  error once we have tried more than
                     *  cgbiMax devices, since that's the most
                     *  GAMEPORT/SERIALPORT will ever give us.
                     */
                    for(idev = 0; idev < cgbiMax; idev++)
                    {
                        SP_DEVICE_INTERFACE_DATA did;

                        AssertF( pbdl->cgbi <= pbdl->cgbiAlloc);

                        /* 
                         *  Note, pnp.c doesn't initialize this so we have to
                         */
                        did.cbSize = cbX(did);
                        if(SetupDiEnumDeviceInterfaces(hdev, 0, (LPGUID)pBusDevice->pcGuid,
                                                       idev, &did))
                        {
                            if(DIBusDevice_BuildListEntry(hdev, &did, &g_pBusDevice[iBusType] ))
                            {
                                //pbdl->cgbi++;
                            } else
                            {
                                /* Skip erroneous items */
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("DIBus_BuildListEntry ")
                                                TEXT("failed?"));
                            }

                        } else

                            if(GetLastError() == ERROR_NO_MORE_ITEMS)
                        {
                            break;

                        } else
                        {
                            /* Skip erroneous items */
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("SetupDiEnumDeviceInterface ")
                                            TEXT("failed? le=%d"), GetLastError());
                        }

                    }

                }

                SetupDiDestroyDeviceInfoList(hdev);
                pBusDevice->tmLastRebuild = GetTickCount();
            }
        }

        if(pbdl) { cDevices += pbdl->cgbi; }
    }
    
    /* New gameport devices may be exposed. Pick them up too */
    DIHid_BuildHidList(FALSE);
    
    DllLeaveCrit();
    ExitProc();
    return (cDevices);
}

PBUSDEVICELIST EXTERNAL
    pbdlFromGUID
    (
    IN PCGUID pcGuid
    )
{
    PBUSDEVICELIST  pbdl_Found = NULL;
    PBUSDEVICE      pBusDevice;
    int iBusType;

    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        if( IsEqualGUID(pBusDevice->pcGuid, pcGuid) )
        {
            pbdl_Found = pBusDevice->pbdl;
            break;
        }
    }
    return pbdl_Found;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIBusDevice_ExposeEx |
 *
 *          Attache a HID device to all available ports.
 *
 *  @parm   IN HANDLE | hf |
 *          Handle the the Gameport/SerialPort File object
 *
 *  @parm   IN OUT PBUS_REGDATA    | pRegData |
 *          Gameport/Serialport specific data. The Handle to the opened device
 *          is returned in this structure
 *
 *
 *  @returns
 *          BOOL. True indicates success.
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIBusDevice_ExposeEx
    (
    IN PBUSDEVICELIST  pbdl,
    IN PBUS_REGDATA    pRegData
    )
{
    HRESULT hres = DIERR_DEVICENOTREG;

    EnterProcI(DIBusDevice_ExposeEx, (_ "xx", pbdl, pRegData));

    /*
     * The return code a little strange for this function
     * If the Expose succeeds for any gameport then
     * we will return that error code.
     * If the expose fails for all gameports,
     * then we will return the amalgam of
     * all the error codes.
     */
    if( pbdl->cgbi != 0x0 )
    {
		int ibdi;
		HRESULT hres1 = DIERR_DEVICENOTREG;
        hres = S_OK;
    
		for( ibdi = 0x0; ibdi < pbdl->cgbi; ibdi++)
		{
			HRESULT hres0;
			PBUSDEVICEINFO   pbdi;

			hres0 = DIERR_DEVICENOTREG;

			pbdi = &(pbdl->rgbdi[ibdi]);

			if( pbdi->fAttached == FALSE )
			{
				pbdi->fDeleteIfNotConnected = TRUE;

				hres0 = DIBusDevice_Expose(pbdi, pRegData);
				if( FAILED(hres0) )
				{
					hres |= hres0;
				} else
				{
					hres1 = hres0;
				}
			} else {
        		hres = DIERR_DEVICEFULL;
			}
		}

		if(SUCCEEDED(hres1))
		{
			hres = hres1;
		}
	}

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIBusDevice_GetTypeInfo |
 *
 *          Gets typeinfo for bus device.
 *
 *  @parm   IN PCGUID | pcguid |
 *          GUID that identifies the gameport
 *
 *  @parm   OUT LPDIJOTYPEINFO    | pjti |
 *          Typeinfo stuct filled in by this function
 *
 *  @parm   IN DWORD | fl |
 *          Flags that specify what fields to fill out.
 *
 *  @returns
 *          HRESULT.
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIBusDevice_GetTypeInfo
    (
    PCGUID pcguid,
    LPDIJOYTYPEINFO pjti,
    DWORD           fl
    )
{
    HRESULT hres;
    PBUSDEVICEINFO pbdi;
    EnterProcI(DIBusDevice_GetTypeInfo, (_ "Gp", pcguid, pjti));

    hres = E_FAIL;
    DllEnterCrit();

    if( NULL != ( pbdi = pbdiFromGUID(pcguid) ) )
    {
        DIPROPSTRING dips;

        if(fl & DITC_REGHWSETTINGS)
        {
            pjti->hws.dwFlags = pbdi->pBusDevice->dwJOY_HWS_ISPORTBUS | JOY_HWS_AUTOLOAD ;
            pjti->hws.dwNumButtons = MAKELONG( pbdi->idPort, 0x0 );
        }

        if( fl & DITC_CLSIDCONFIG )
        {
            pjti->clsidConfig = pbdi->guid;
        }

        if(fl & DITC_DISPLAYNAME)
        {
            if(FAILED( hres = DIPort_GetRegistryProperty(pbdi->ptszId, SPDRP_FRIENDLYNAME, &dips.diph) ) )
            {
                if( FAILED( hres = DIPort_GetRegistryProperty(pbdi->ptszId, SPDRP_DEVICEDESC, &dips.diph) ) )
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: No device name | friendly name for gameport %d "),
                                    s_szProc, pbdi->idPort);
                }
            }
            if( SUCCEEDED(hres) )
            {
                /*
                 *  Prefix warns (Wi:228282) that dips.wsz could be 
                 *  uninitialized however one of the above GetRegistryProperty 
                 *  functions has succeeded leaving a worst case of a NULL 
                 *  terminator having been copied there.
                 */
                lstrcpyW(pjti->wszDisplayName, dips.wsz);
            }
        }

        if(fl & DITC_CALLOUT)
        {
            ZeroX(pjti->wszCallout);
        }

        if(fl & DITC_HARDWAREID)
        {
            ZeroX(pjti->wszHardwareId);
        }

        if( fl & DITC_FLAGS1 )
        {
            pjti->dwFlags1 = 0x0;
        }

        hres = S_OK;
    } else
    {
        hres = E_FAIL;
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%S: GUID not a port GUID "),
                        s_szProc);
    }

    DllLeaveCrit();
    ExitProcX(hres);

    return hres;

}


HRESULT EXTERNAL DIPort_SnapTypes(LPWSTR *ppwszz)
{
    LONG cDevices;
    HRESULT hres = E_FAIL;

    cDevices = DIBus_BuildList(FALSE);

    if( cDevices)
    {
        DllEnterCrit();
        hres = AllocCbPpv(cbCwch( cDevices  * MAX_JOYSTRING) , ppwszz);
        if( SUCCEEDED(hres) )
        {
            int iBusType, igdi;
            PBUSDEVICE     pBusDevice;
            LPWSTR pwsz = *ppwszz;

            for(iBusType = 0x0, pBusDevice = g_pBusDevice;
               iBusType < 1;
               iBusType++, pBusDevice++ )
            {
                PBUSDEVICEINFO pbdi;
                for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
                   igdi < pBusDevice->pbdl->cgbi;
                   igdi++, pbdi++)
                {
                    TCHAR tszGuid[MAX_JOYSTRING];
                    NameFromGUID(tszGuid, &pbdi->guid);

                    #ifdef UNICODE
                        lstrcpyW(pwsz, &tszGuid[ctchNamePrefix]);
                        pwsz += lstrlenW(pwsz) + 1;
                    #else
                        TToU(pwsz, cA(pwsz), &tszGuid[ctchNamePrefix]);
                        pwsz += lstrlenW(pwsz) + 1;
                    #endif
                }
            }
            *pwsz = L'\0';              /* Make it ZZ */
        }
        DllLeaveCrit();
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dioledup.c ===
/*****************************************************************************
 *
 *  DIOleDup.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that sort-of duplicate what OLE does.
 *
 *  Contents:
 *
 *      DICoCreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflOleDup

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _CreateInstance |
 *
 *          Worker function for <f DICoCreateInstance>.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The <t CLSID> to create.
 *
 *  @parm   LPCTSTR | ptszDll |
 *
 *          The name of the DLL to load.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

HRESULT INTERNAL
_CreateInstance(REFCLSID rclsid, LPCTSTR ptszDll, LPUNKNOWN punkOuter,
                RIID riid, PPV ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    HINSTANCE hinst;

    hinst = LoadLibrary(ptszDll);
    if (hinst) {
        LPFNGETCLASSOBJECT DllGetClassObject;

        DllGetClassObject = (LPFNGETCLASSOBJECT)
                            GetProcAddress(hinst, "DllGetClassObject");

        if (DllGetClassObject) {
            IClassFactory *pcf;

            hres = DllGetClassObject(rclsid, &IID_IClassFactory, &pcf);
            if (SUCCEEDED(hres)) {
                hres = pcf->lpVtbl->CreateInstance(pcf, punkOuter,
                                                   riid, ppvOut);
                pcf->lpVtbl->Release(pcf);

                /*
                 *  Some people forget to adhere to
                 *  the OLE spec, which requires that *ppvOut be
                 *  set to zero on failure.
                 */
                if (FAILED(hres)) {
                    if (*ppvOut) {
                        RPF("ERROR! CoCreateInstance: %s forgot to zero "
                            "out *ppvOut on failure path", ptszDll);
                    }
                    *ppvOut = 0;
                }

            }
        } else {
            /*
             *  DLL does not export GetClassObject.
             */
            hres = REGDB_E_CLASSNOTREG;
        }

        if (SUCCEEDED(hres)) {
            *phinst = hinst;
        } else {
            FreeLibrary(hinst);
        }
    } else {
        /*
         *  DLL does not exist.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DICoCreateInstance |
 *
 *          Private version of CoCreateInstance that doesn't use OLE.
 *
 *  @parm   LPTSTR | ptszClsid |
 *
 *          The string version of the <t CLSID> to create.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

STDMETHODIMP
DICoCreateInstance(LPTSTR ptszClsid, LPUNKNOWN punkOuter,
                   RIID riid, PPV ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    CLSID clsid;
    EnterProcI(DICoCreateInstance, (_ "spG", ptszClsid, punkOuter, riid));

    *ppvOut = 0;
    *phinst = 0;

    if (ParseGUID(&clsid, ptszClsid)) {
        HKEY hk;
        LONG lRc;
        TCHAR tszKey[ctchGuid + 40];    /* 40 is more than enough */

        /*
         *  Look up the CLSID in HKEY_CLASSES_ROOT.
         */
        wsprintf(tszKey, TEXT("CLSID\\%s\\InProcServer32"), ptszClsid);

        lRc = RegOpenKeyEx(HKEY_CLASSES_ROOT, tszKey, 0,
                           KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {
            TCHAR tszDll[MAX_PATH];
            DWORD cb;

            cb = cbX(tszDll);
            lRc = RegQueryValue(hk, 0, tszDll, &cb);

            if (lRc == ERROR_SUCCESS) {
                TCHAR tszModel[20];     /* more than enough */

                lRc = RegQueryString(hk, TEXT("ThreadingModel"),
                                     tszModel, cA(tszModel));
                if (lRc == ERROR_SUCCESS &&
                    ((lstrcmpi(tszModel, TEXT("Both"))==0x0) ||
                     (lstrcmpi(tszModel, TEXT("Free"))==0x0))) {

                    hres = _CreateInstance(&clsid, tszDll, punkOuter,
                                           riid, ppvOut, phinst);

                } else {
                    /*
                     *  No threading model or bad threading model.
                     */
                    hres = REGDB_E_CLASSNOTREG;
                }
            } else {
                /*
                 *  No InprocServer32.
                 */
                hres = REGDB_E_CLASSNOTREG;
            }

            RegCloseKey(hk);

        } else {
            /*
             *  CLSID not registered.
             */
            hres = REGDB_E_CLASSNOTREG;
        }
    } else {
        /*
         *  Invalid CLSID string.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    ExitOleProcPpv(ppvOut);
    return hres;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diraw.c ===
/*****************************************************************************
 *
 *  DIRaw.c
 *
 *  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput Raw Input Device processor.
 *
 *  Contents:
 *
 *      CDIRaw_RegisterRawInputDevice
 *      CDIRaw_UnregisterRawInputDevice
 *      CDIRaw_ProcessInput
 *      CDIRaw_OnInput
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef USE_WM_INPUT

#include "ntddkbd.h"

#define sqfl sqflRaw

extern DIMOUSESTATE_INT s_msEd; //in diemm.c
extern ED s_edMouse;            //in diemm.c
extern ED s_edKbd;              //in diemk.c
extern LPBYTE g_pbKbdXlat;      //in diemk.c

static RAWMOUSE s_absrm;
static BOOL s_fFirstRaw;

#ifndef RIDEV_INPUTSINK
  // RIDEV_INPUTSINK is defined in winuserp.h
  #define RIDEV_INPUTSINK   0x00000100
#endif

#ifndef RIDEV_NOHOTKEYS
  #define RIDEV_NOHOTKEYS   0x00000200
#endif

RAWINPUTDEVICE ridOn[] = {
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_INPUTSINK },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_NOLEGACY | RIDEV_CAPTUREMOUSE },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_INPUTSINK },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_NOLEGACY | RIDEV_NOHOTKEYS },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_NOHOTKEYS },
};

RAWINPUTDEVICE ridOff[] = {
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_REMOVE },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_REMOVE },
};


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | CDIRaw_RegisterRawInputDevice |
 *
 *          register raw input device.
 *
 *  @parm   IN UINT | uirim |
 *
 *          the type of device: RIM_TYPEMOUSE or RIM_TYPEKEYBOARD
 *
 *  @parm   IN DWORD | dwOrd |
 *
 *          dwOrd determines which item of ridOn will be used for registration.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          the window handler used by RegisterRawInputDevices.
 *
 *  @returns
 *
 *          S_OK - successful
 *          E_FAIL - otherwise
 *
 *****************************************************************************/

HRESULT CDIRaw_RegisterRawInputDevice( UINT uirim, DWORD dwOrd, HWND hwnd)
{
    HRESULT hres;

    AssertF( (uirim == RIM_TYPEMOUSE) || (uirim == RIM_TYPEKEYBOARD) );

    if( hwnd ) {
        ridOn[uirim*2+dwOrd].hwndTarget = hwnd;
    }

    if( RegisterRawInputDevices &&
        RegisterRawInputDevices(&ridOn[uirim*2+dwOrd], 1, sizeof(RAWINPUTDEVICE)) ) {
        SquirtSqflPtszV(sqfl, TEXT("RegisterRawInputDevice: %s, mode: %s, hwnd: 0x%08lx"),
                            uirim==0 ? TEXT("mouse"):TEXT("keyboard"), 
                            dwOrd==0 ? TEXT("NONEXCL") : dwOrd==1 ? TEXT("EXCL") : TEXT("NOWIN"),
                            hwnd);
        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | CDIRaw_UnregisterRawInputDevice |
 *
 *          unregister raw input device.
 *
 *  @parm   IN UINT | uirim |
 *
 *          the type of device: RIM_TYPEMOUSE or RIM_TYPEKEYBOARD
 *
 *  @parm   IN HWND | hwnd |
 *
 *          the window handler used by RegisterRawInputDevices.
 *
 *  @returns
 *
 *          S_OK - successful
 *          E_FAIL - otherwise
 *
 *****************************************************************************/

HRESULT CDIRaw_UnregisterRawInputDevice( UINT uirim, HWND hwnd )
{
    HRESULT hres;

    AssertF( (uirim == RIM_TYPEMOUSE) || (uirim == RIM_TYPEKEYBOARD) );

    if( hwnd ) {
        ridOn[uirim].hwndTarget = hwnd;
    }

    if( RegisterRawInputDevices &&
        RegisterRawInputDevices(&ridOff[uirim], 1, sizeof(RAWINPUTDEVICE)) ) {
        SquirtSqflPtszV(sqfl, TEXT("UnregisterRawInputDevice: %s, hwnd: 0x%08lx"),
                            uirim==0 ? TEXT("mouse"):TEXT("keyboard"), hwnd);
        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIRaw_ProcessInput |
 *
 *          Process raw input device data.
 *
 *  @parm   IN PRAWINPUT | pRawInput |
 *
 *          pointer to RAWINPUT data
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void CDIRaw_ProcessInput(PRAWINPUT pRawInput)
{
    HANDLE hDevice = pRawInput->header.hDevice;

    if ( g_plts ) {
        if( g_plts->rglhs[LLTS_MSE].cHook && pRawInput->header.dwType == RIM_TYPEMOUSE )
        {
            DIMOUSESTATE_INT ms;
            RAWMOUSE        *prm = &pRawInput->data.mouse;

            memcpy(ms.rgbButtons, s_msEd.rgbButtons, cbX(ms.rgbButtons));

            if( prm->usFlags & MOUSE_MOVE_ABSOLUTE ) {
                if( s_fFirstRaw ) {
                    memcpy( &s_absrm, prm, sizeof(RAWMOUSE) );
                    s_fFirstRaw = FALSE;
                    return;
                } else {
                    RAWMOUSE rm;

                    memcpy( &rm, prm, sizeof(RAWMOUSE) );

                    prm->lLastX -= s_absrm.lLastX;
                    prm->lLastY -= s_absrm.lLastY;
                    if ( prm->usButtonFlags & RI_MOUSE_WHEEL ) {
                        prm->usButtonData -= s_absrm.usButtonData;
                    }

                    memcpy( &s_absrm, &rm, sizeof(RAWMOUSE) );
                }
            }

            ms.lX = prm->lLastX;
            ms.lY = prm->lLastY;
            if ( prm->usButtonFlags & RI_MOUSE_WHEEL ) {
                ms.lZ = (short)prm->usButtonData;
            } else {
                ms.lZ = 0;
            }

            if( prm->usButtonFlags & RI_MOUSE_LEFT_BUTTON_DOWN ) {
                ms.rgbButtons[0] = 0x80;
            } else if (prm->usButtonFlags & RI_MOUSE_LEFT_BUTTON_UP ) {
                ms.rgbButtons[0] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_RIGHT_BUTTON_DOWN ) {
                ms.rgbButtons[1] = 0x80;
            } else if (prm->usButtonFlags & RI_MOUSE_RIGHT_BUTTON_UP) {
                ms.rgbButtons[1] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_MIDDLE_BUTTON_DOWN ) {
                ms.rgbButtons[2] = 0x80;
            } else if( prm->usButtonFlags & RI_MOUSE_MIDDLE_BUTTON_UP ) {
                ms.rgbButtons[2] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_BUTTON_4_DOWN ) {
                ms.rgbButtons[3] = 0x80;
            } else if( prm->usButtonFlags & RI_MOUSE_BUTTON_4_UP ) {
                ms.rgbButtons[3] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_BUTTON_5_DOWN ) {
                ms.rgbButtons[4] = 0x80;
            } else if ( prm->usButtonFlags & RI_MOUSE_BUTTON_5_UP ) {
                ms.rgbButtons[4] = 0x00;
            }

            #if 0
            {
                char buf[128];
                static DWORD cnt = 0;

                wsprintfA(buf, "%d: x: %ld (%ld), y: %ld (%ld), z: %ld, rgb[0]: 0x%lx, rgb[4]: 0x%lx", cnt, prm->lLastX,ms.lX, prm->lLastY, ms.lY, (short)prm->usButtonData,*(DWORD *)ms.rgbButtons,*(DWORD *)&ms.rgbButtons[4]);
                RPF(buf);
                cnt++;
            }
            #endif

            CEm_Mouse_AddState(&ms, GetTickCount());

        } else
        if ( g_plts->rglhs[LLTS_KBD].cHook && pRawInput->header.dwType == RIM_TYPEKEYBOARD ) {
            RAWKEYBOARD *prk = &pRawInput->data.keyboard;
            BYTE bAction, bScan;
            static BOOL fE1 = FALSE;

            bAction = (prk->Flags & KEY_BREAK) ? 0 : 0x80;
            bScan   = (BYTE)prk->MakeCode;

            if( prk->Flags & KEY_E0 ) {
                if( bScan == 0x2A ) {  //special extra scancode when pressing PrtScn
                    return;
                } else {
                    bScan |= 0x80;
                }
            } else if( prk->Flags & KEY_E1 ) {  //special key: PAUSE
                fE1 = TRUE;

                // now, we need to bypass 0x1d key for compitibility with low level hook.
                if( bScan == 0x1d ) {
                    return;
                }
            }

            if( fE1 ) {
                // This is the work around for bug 288535.
                // But we really don't want to fix it in this way.
                //if( !bAction ) {
                //  Sleep(80);
                //}
                bScan |= 0x80;
                fE1 = FALSE;
            }

            AssertF(g_pbKbdXlat);
            if( bScan != 0x45 && bScan != 0xc5 ) {
                bScan = g_pbKbdXlat[bScan];
            }

            #if 0
            {
                char buf[128];
                static DWORD cnt = 0;
                
                wsprintfA(buf, "%d: bAction: 0x%lx, bScan: 0x%lx, Flags: 0x%lx, Make: 0x%lx", cnt, bAction, bScan, prk->Flags,prk->MakeCode);
                RPF(buf);
                cnt++;
            }
            #endif

            CEm_AddEvent(&s_edKbd, bAction, bScan, GetTickCount());
        }
    }

    return;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIRaw_OnInput |
 *
 *          WM_INPUT message handler used by CEm_LL_ThreadProc (in diem.c).
 *
 *  @parm   IN MSG * | pmsg |
 *
 *          pointer to MSG
 *
 *  @returns
 *
 *          TRUE = Successful
 *          FALSE = otherwise
 *
 *****************************************************************************/

BOOL CDIRaw_OnInput(MSG *pmsg)
{
    BOOL  fRtn = FALSE;
    HRAWINPUT hRawInput = (HRAWINPUT)pmsg->lParam;
    PRAWINPUT pRawInput;
    UINT cbSize;
    BYTE pbBuf[512];
    BOOL fMalloc;
    UINT uiRtn;

    //
    // Firstly, get the size of this Raw Input.
    //
    if ( (uiRtn = GetRawInputData(hRawInput, RID_INPUT, NULL, &cbSize, sizeof(RAWINPUTHEADER))) != 0) {
        return FALSE;
    }

    //
    // Allocate required memory.
    //
    if( cbSize < cbX(pbBuf) ) {
        pRawInput = (PRAWINPUT)pbBuf;
        fMalloc = FALSE;
    } else {
        pRawInput = (PRAWINPUT)malloc(cbSize);
        if (pRawInput == NULL) {
            RPF("CDIRaw_OnInput: failed to allocate pRawInput.");
            return FALSE;
        }
        fMalloc = TRUE;
    }

    //
    // Receive the content of the Raw Input.
    //
    if (GetRawInputData(hRawInput, RID_INPUT, pRawInput, &cbSize, sizeof(RAWINPUTHEADER)) > 0) {
        //
        // Call the handler of ours, to start/continue/stop drawing.
        //
        CDIRaw_ProcessInput(pRawInput);
    }

    // no longer needed.
    if( fMalloc ) {
        free(pRawInput);
        pRawInput = NULL;
    }

    return fRtn;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIRaw_Mouse_InitButtons |
 *
 *          Initialize the mouse state in preparation for acquisition.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIRaw_Mouse_InitButtons(void)
{
    if (s_edMouse.cAcquire < 0) {
        s_fFirstRaw = TRUE;
    }

    return S_OK;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   int | DIRaw_GetKeyboardType |
 *
 *          Return keyboard type (nTypeFlag==0) or subtype (nTypeFlag==1).
 *
 *****************************************************************************/

int EXTERNAL
DIRaw_GetKeyboardType(int nTypeFlag)
{
    PRAWINPUTDEVICELIST pList = NULL;
    UINT  uiNumDevices = 0;
    DWORD dwType;
    int   nResult = 0;

    if (GetRawInputDeviceList(NULL, &uiNumDevices, sizeof(RAWINPUTDEVICELIST)) == (UINT)-1) {
        SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: failed to get the number of devices."));
        goto _DIRAWGKT_EXIT;
    }

    if( uiNumDevices ) {
        pList = malloc(sizeof(RAWINPUTDEVICELIST) * uiNumDevices);
        if( !pList ) {
            SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: malloc failed."));
            goto _DIRAWGKT_EXIT;
        }
        
        if (GetRawInputDeviceList(pList, &uiNumDevices, sizeof(RAWINPUTDEVICELIST)) == (UINT)-1) {
            SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType:  failed to get device list."));
            goto _DIRAWGKT_EXIT;
        } else {
            UINT  i;
            UINT  uiLen;
            UINT  cbSize;
            RID_DEVICE_INFO info;

            info.cbSize = sizeof(RID_DEVICE_INFO);

            for (i = 0; i<uiNumDevices; ++i) 
            {
                if (pList[i].dwType == RIM_TYPEKEYBOARD) 
                {
                    uiLen = 0;

                    // Get device name
                    if (GetRawInputDeviceInfo(pList[i].hDevice, RIDI_DEVICENAME, NULL, &uiLen)) {
                        continue;
                    }

                    // Get device type info.
                    cbSize = sizeof(RID_DEVICE_INFO);
                    if (GetRawInputDeviceInfo(pList[i].hDevice, RIDI_DEVICEINFO, &info, &cbSize) == (UINT)-1) {
                        continue;
                    }

                    if( nTypeFlag == 0 || nTypeFlag == 1)   //keyboard type or subtype
                    {
                        dwType = info.keyboard.dwType;
                        if( dwType == 4 || dwType == 7 || dwType == 8 ) {
                            nResult = (nTypeFlag==0) ? info.keyboard.dwType : info.keyboard.dwSubType;
                            break;
                        }
                    } else 
                    {
                        RPF("DIRaw_GetKeyboardType: wrong argument, %d is not supported.", nTypeFlag);
                    }
                }
            }
        }
    }

_DIRAWGKT_EXIT:
    if( pList ) {
        free(pList);
    }

    if( !nResult ) {
        nResult = GetKeyboardType(nTypeFlag);
    }

    SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: %s: %d"),
                          nTypeFlag==0 ? TEXT("type"):TEXT("sybtype"), nResult);
    
    return nResult;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diregutl.c ===
/*****************************************************************************
 *
 *  DIRegUtl.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Registry utility functions.
 *
 *  Contents:
 *
 *
 *****************************************************************************/
#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflRegUtils

#if DIRECTINPUT_VERSION > 0x0400

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryString |
 *
 *          Wrapper for <f RegQueryValueEx> that reads a
 *          string value from the registry.  An annoying quirk
 *          is that on Windows NT, the returned string might
 *          not end in a null terminator, so we might need to add
 *          one manually.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPTSTR | ptsz |
 *
 *          Output buffer.
 *
 *  @parm   DWORD | ctchBuf |
 *
 *          Size of output buffer.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegQueryString(HKEY hk, LPCTSTR ptszValue, LPTSTR ptszBuf, DWORD ctchBuf)
{
    LONG lRc;
    DWORD reg;

    #ifdef UNICODE
    DWORD cb;

    /*
     *  NT quirk: Non-null terminated strings can exist.
     */
    cb = cbCtch(ctchBuf);
    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (PV)ptszBuf, &cb);
    if(lRc == ERROR_SUCCESS)
    {
        if(reg == REG_SZ)
        {
            /*
             *  Check the last character.  If it is not NULL, then
             *  append a NULL if there is room.
             */
            DWORD ctch = ctchCb(cb);
            if(ctch == 0)
            {
                ptszBuf[ctch] = TEXT('\0');
            } else if(ptszBuf[ctch-1] != TEXT('\0'))
            {
                if(ctch < ctchBuf)
                {
                    ptszBuf[ctch] = TEXT('\0');
                } else
                {
                    lRc = ERROR_MORE_DATA;
                }
            }
        } else
        {
            lRc = ERROR_INVALID_DATA;
        }
    }


    #else

    /*
     *  This code is executed only on Win95, so we don't have to worry
     *  about the NT quirk.
     */

    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (PV)ptszBuf, &ctchBuf);

    if(lRc == ERROR_SUCCESS && reg != REG_SZ)
    {
        lRc = ERROR_INVALID_DATA;
    }


    #endif

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryStringValueW |
 *
 *          Wrapper for <f RegQueryValueEx> that handles ANSI/UNICODE
 *          issues, as well as treating a nonexistent key as if it
 *          were a null string.
 *
 *          Note that the value name is still a <t LPCTSTR>.
 *
 *          It is assumed that the thing being read is a string.
 *          Don't use this function to read binary data.
 *
 *          You cannot use this function to query the necessary
 *          buffer size (again, because I'm lazy).  It's not as
 *          simple as doubling the ansi size, because DBCS may
 *          result in a non-linear translation function.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   LPDWORD | pcbBuf |
 *
 *          Size of UNICODE output buffer.  May not exceed
 *          cbCwch(MAX_PATH).
 *
 *  @returns
 *
 *          Registry error code.  On error, the output buffer is
 *          set to a null string.  On an ERROR_MORE_DATA, the
 *          output buffer is null-terimated.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegQueryStringValueW(HKEY hk, LPCTSTR ptszValue,
                         LPWSTR pwszBuf, LPDWORD pcbBuf)
{
    LONG lRc;

    #ifdef UNICODE

    AssertF(*pcbBuf > 0);
    AssertF(*pcbBuf <= cbCwch(MAX_PATH));

    /*
     *  NT quirk: Non-null terminated strings can exist.
     */
    lRc = RegQueryString(hk, ptszValue, pwszBuf, ctchCb(*pcbBuf));

    #else

    /*
     *  NT quirk: Non-null terminated strings can exist.  Fortunately,
     *  this code is executed only on Win95, which terminates properly.
     */
    DWORD cb;
    TCHAR tszBuf[MAX_PATH];

    AssertF(*pcbBuf > 0);
    AssertF(*pcbBuf <= cbCwch(MAX_PATH));

    /*
     *  ISSUE-2001/03/29-timgill Incorrect size returned in single case
     *  Note that we do not get the size perfect in the DBCS case.
     *
     *  Fortunately, the slop is on the high end, where hopefully
     *  nobody lives or will notice.
     *
     *  Is it worth fixing?
     */

    cb = cwchCb(*pcbBuf);
    lRc = RegQueryValueEx(hk, ptszValue, 0, 0, (PV)tszBuf, &cb);

    if(lRc == ERROR_SUCCESS)
    {
        DWORD cwch;

        /*
         *  Convert the string up to UNICODE.
         */
        cwch = AToU(pwszBuf, cwchCb(*pcbBuf), tszBuf);
        *pcbBuf = cbCwch(cwch);

        /*
         *  If the buffer was not big enough, the return value
         *  will be zero.
         */
        if(cwch == 0 && tszBuf[0])
        {
            lRc = ERROR_MORE_DATA;
        } else
        {
            lRc = ERROR_SUCCESS;
        }

    }
    #endif

    /*
     *  If the buffer was too small, then null-terminate it just
     *  to make sure.
     */
    if(lRc == ERROR_MORE_DATA)
    {
        if(*pcbBuf)
        {
            pwszBuf[cwchCb(*pcbBuf)-1] = TEXT('\0');
        }
    } else

        /*
         *  If it was some other error, then wipe out the buffer
         *  so the caller won't get confused.
         */
        if(lRc != ERROR_SUCCESS)
    {
        pwszBuf[0] = TEXT('\0');
        /*
         *  If the error was that the key doesn't exist, then
         *  treat it as if it existed with a null string.
         */
        if(lRc == ERROR_FILE_NOT_FOUND)
        {
            lRc = ERROR_SUCCESS;
        }
    }

    return lRc;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegSetStringValueW |
 *
 *          Wrapper for <f RegSetValueEx> that handles ANSI/UNICODE
 *          issues, as well as converting null strings into nonexistent
 *          values.
 *
 *          Note that the value name is still a <t LPCTSTR>.
 *
 *          It is assumed that the thing being written is a string.
 *          Don't use this function to write binary data.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          UNICODE value to write.  A null pointer is valid, indicating
 *          that the key should be deleted.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegSetStringValueW(HKEY hk, LPCTSTR ptszValue, LPCWSTR pwszData)
{
    DWORD cwch;
    LONG lRc;

    if(pwszData)
    {
        cwch = lstrlenW(pwszData);
    } else
    {
        cwch = 0;
    }

    if(cwch)
    {
#ifdef UNICODE
        lRc = RegSetValueExW(hk, ptszValue, 0, REG_SZ,
                             (PV)pwszData, cbCwch(cwch+1));
#else

        DWORD ctch;
        TCHAR tszBuf[MAX_PATH];

        /*
         *  Convert the string down to ANSI.
         */
        ctch = UToA(tszBuf, cA(tszBuf), pwszData);

        if(ctch)
        {
            lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                                (PV)tszBuf, cbCtch(ctch+1));
        } else
        {
            lRc = ERROR_CANTWRITE;
        }

#endif

    } else
    {
        lRc = RegDeleteValue(hk, ptszValue);

        /*
         *  It is not an error if the key does not already exist.
         */
        if(lRc == ERROR_FILE_NOT_FOUND)
        {
            lRc = ERROR_SUCCESS;
        }
    }

    return lRc;
}

#ifndef UNICODE
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegDeleteKeyW |
 *
 *          Wrapper for <f RegDeleteKeyA> on non-UNICODE platforms.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          Subkey name.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegDeleteKeyW(HKEY hk, LPCWSTR pwsz)
{
    LONG lRc;
    CHAR szBuf[MAX_PATH];

    /*
     *  Convert the string down to ANSI.
     */
    UToA(szBuf, cA(szBuf), pwsz);

    lRc = RegDeleteKeyA(hk, szBuf);

    return lRc;
}
#endif

#if DIRECTINPUT_VERSION > 0x0300

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresMumbleKeyEx |
 *
 *          Either open or create the key, depending on the degree
 *          of access requested.
 *
 *  @parm   HKEY | hk |
 *
 *          Base key.
 *
 *  @parm   LPCTSTR | ptszKey |
 *
 *          Name of subkey, possibly NULL.
 *
 *  @parm   REGSAM | sam |
 *
 *          Security access mask.
 *
 *  @parm   DWORD   | dwOptions |
 *          Options for RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives output key.
 *
 *  @returns
 *
 *          Return value from <f RegOpenKeyEx> or <f RegCreateKeyEx>,
 *          converted to an <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    LONG lRc;

    /*
     *  If caller is requesting write access, then try opening it for writing;
	 *  if that fails with access denied error, then try opening it for reading;
	 *  if key doesn't exist, create the key.
     *  Else just open it.
     */
    if(IsWriteSam(sam))
    {
		// on WinXP, we strip out WRITE_DAC and WRITE_OWNER bits
		if (DIGetOSVersion() == WINWH_OS)
		{
			sam &= ~DI_DAC_OWNER;
		}
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);

        if( lRc == ERROR_SUCCESS )
        {
            // Don't need to create it already exists
        } else
        {
			// Change for server per Whistler bug 575181
			// If error is access denied, try opening the key for reading
			if (lRc == ERROR_ACCESS_DENIED)
			{
				lRc = RegOpenKeyEx(hk, ptszKey, 0, KEY_READ, phk);
			}
			else
			{
				// Try to create it
				lRc = RegCreateKeyEx
						(
						hk,									// handle of an open key
						ptszKey,							// address of subkey name
						0,									// reserved
						NULL,								// address of class string
						dwOptions,							// special options flag
						sam,                                // desired security access
						NULL,								// inherit the parent's secuirty descriptor
						phk,								// address of buffer for opened handle
						0						            // address of disposition value buffer);
						);
			}
		}

    } else
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);
    }

    if(lRc == ERROR_SUCCESS)
    {
        hres = S_OK;
    } else
    {
        if(lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
        {
            lRc = ERROR_FILE_NOT_FOUND;
        }
        hres = hresLe(lRc);
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryDIDword |
 *
 *          Read a dword value from a sub key of the DirectInput part of the 
 *          registry.
 *
 *  @parm   LPCTSTR | ptszSubKey |
 *
 *          Optional path from root of DirectInput registry.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   DWORD | dwDefault |
 *
 *          Default value to use if there was an error.
 *
 *  @returns
 *
 *          The value read, or the default.
 *
 *****************************************************************************/

DWORD EXTERNAL
    RegQueryDIDword(LPCTSTR ptszPath, LPCTSTR ptszValue, DWORD dwDefault)
{
    HKEY hk;
    DWORD dw;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DINPUT, 0,
                    KEY_QUERY_VALUE, &hk) == 0)
    {
        DWORD cb = cbX(dw);

        if( ptszPath )
        {
            HKEY hkSub;

            if(RegOpenKeyEx(hk, ptszPath, 0,
                            KEY_QUERY_VALUE, &hkSub) == 0)
            {
                RegCloseKey( hk );
                hk = hkSub;
            }
        }

        if(RegQueryValueEx(hk, ptszValue, 0, 0, (LPBYTE)&dw, &cb) == 0 &&
           cb == cbX(dw))
        {
        } else
        {
            dw = dwDefault;
        }
        RegCloseKey(hk);
    } else
    {
        dw = dwDefault;
    }
    return dw;
}


//
// A registry key that is opened by an application can be deleted
// without error by another application in both Windows 95 and
// Windows NT. This is by design.
DWORD EXTERNAL
    DIWinnt_RegDeleteKey
    (
    HKEY hStartKey ,
    LPCTSTR pKeyName
    )
{

    #define MAX_KEY_LENGTH  ( 256 )
    DWORD   dwRtn, dwSubKeyLength;
    TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
    HKEY    hKey;

    // do not allow NULL or empty key name
    if( pKeyName &&  lstrlen(pKeyName))
    {
        if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
                                0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
        {
            while(dwRtn == ERROR_SUCCESS )
            {
                dwSubKeyLength = MAX_KEY_LENGTH;
                dwRtn=RegEnumKeyEx(
                                  hKey,
                                  0,       // always index zero
                                  szSubKey,
                                  &dwSubKeyLength,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL
                                  );

                if(dwRtn == ERROR_SUCCESS)
                {
                    dwRtn = DIWinnt_RegDeleteKey(hKey, szSubKey);
                } else if(dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                }
            }
            RegCloseKey(hKey);
            // Do not save return code because error
            // has already occurred
        }
    } else
        dwRtn = ERROR_BADKEY;

    return dwRtn;
}

#endif /* DIRECTINPUT_VERSION > 0x0300 */

//ISSUE-2001/03/29-timgill  Make this version 7 when available
#if DIRECTINPUT_VERSION > 0x0500

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyValues |
 *
 *          Copy all the values from one key to another.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key with values to be copied 
 *              (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkDest |
 *
 *          Key to receive copies (must be opened with at least KEY_WRITE).
 *
 *  @returns
 *
 *          S_OK if all values were successfully copied
 *          S_FALSE if there were no values to copy.
 *          Or a memory allocation error code or the failing registry function 
 *          return code converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyValues( HKEY hkSrc, HKEY hkDest )
{
    HRESULT hres;
    LONG    lRc;
    DWORD   cItems;
    DWORD   MaxNameLen;
    DWORD   MaxDataLen;
    DWORD   NameLen;
    DWORD   DataLen;
    PTCHAR  tszName;
    PBYTE   pData;
    DWORD   Type;

    EnterProcI(hresRegCopyValues, (_ "xx", hkSrc, hkDest));

    lRc = RegQueryInfoKey( hkSrc,           // Key, 
                           NULL, NULL, NULL,// Class, cbClass, Reserved,
                           NULL, NULL, NULL,// NumSubKeys, MaxSubKeyLen, MaxClassLen,
                           &cItems,         // NumValues, 
                           &MaxNameLen,     // MaxValueNameLen,
                           &MaxDataLen,     // MaxValueLen,
                           NULL, NULL );    // Security descriptor, last write

    if( lRc == ERROR_SUCCESS )
    {
        if( cItems )
        {
            MaxNameLen++; // Take account of NULL terminator
            hres = AllocCbPpv( MaxDataLen + MaxNameLen * sizeof(tszName[0]), &pData );
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory copying registry values") );
            }
            else
            {
                tszName = (PTCHAR)(pData + MaxDataLen);

                do
                {
                    DataLen = MaxDataLen;
                    NameLen = MaxNameLen;
                    lRc = RegEnumValue( hkSrc, --cItems, tszName, &NameLen,
                                         NULL, &Type, pData, &DataLen );
                    if( lRc != ERROR_SUCCESS )
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegEnumValues failed during copy values, code 0x%08x"), lRc );
                        break;
                    }
                    else
                    {
                        lRc = RegSetValueEx( hkDest, tszName, 0, Type, pData, DataLen );
                        if( lRc != ERROR_SUCCESS )
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed to copy value %s code %x"), tszName, lRc );
                            break;
                        }
                    }
                } while( cItems );

                FreePpv( &pData );

                if( lRc != ERROR_SUCCESS )
                {
                    hres = hresReg( lRc );
                }
                else
                {
                    hres = S_OK;
                }
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl, TEXT("No values to copy") );
            hres = S_FALSE;
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("RegQueryInfoKey failed during value copy, code 0x%08x"), lRc );
        hres = hresReg(lRc);
    }

    ExitOleProc();

    return( hres );
} /* hresRegCopyValues */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyKey |
 *
 *          Make an empty copy of a key.
 *
 *  @parm   HKEY | hkSrcRoot |
 *
 *          The Key under the key name to be copied exists.
 *              (must be opened with at least KEY_READ).
 *
 *  @parm   PTCHAR | szSrcName |
 *          Name of key to copy
 *
 *  @parm   PTCHAR | szClass |
 *          Class of key to copy
 *
 *  @parm   HKEY | hkDestRoot |
 *
 *          The Key under which the copy will be created
 *              (must be opened with at least KEY_WRITE).
 *
 *  @parm   PTCHAR | szSrcName |
 *          Name of new key
 *
 *  @parm   PHKEY | phkSub |
 *
 *          The optional pointer to an HKEY to recieve the opened key if it is 
 *          successfully created.  If this is NULL, the key is closed.
 *
 *  @returns
 *
 *          S_OK if the new key was created.
 *          S_FALSE if the new key already existed
 *          Or the return value of a failing registry function or 
 *          GetSecurityInfo converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyKey( HKEY hkSrcRoot, PTCHAR szSrcName, PTCHAR szClass, 
        HKEY hkDestRoot, PTCHAR szDestName, HKEY *phkSub )
{
    LONG    lRc;
    HKEY    hkSub;
    DWORD   dwDisposition;
    HRESULT hres;


#ifdef WINNT
    HKEY                    hkSrc;
#endif

    EnterProcI(hresRegCopyKey, (_ "xssxs", hkSrcRoot, szSrcName, szClass, hkDestRoot, szDestName));
#ifdef WINNT

    lRc = RegOpenKeyEx( hkSrcRoot, szSrcName, 0, KEY_READ, &hkSrc );

    if( lRc == ERROR_SUCCESS )
    {
        SECURITY_ATTRIBUTES     sa;
        SECURITY_INFORMATION    si;

        sa.nLength = sizeof( sa );
        sa.bInheritHandle = TRUE;
        si = OWNER_SECURITY_INFORMATION;

        lRc = GetSecurityInfo( hkSrc, SE_REGISTRY_KEY, 
                               si,           
                               NULL, NULL, // Don't care about SID or SID group
                               NULL, NULL, // Don't care about DACL or SACL
                               &sa.lpSecurityDescriptor );

        RegCloseKey( hkSrc );

        if( lRc == ERROR_SUCCESS )
        {
            lRc = RegCreateKeyEx(  hkDestRoot,
                                   szDestName,
                                   0,
                                   szClass,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   &sa,
                                   &hkSub,
                                   &dwDisposition );

            LocalFree( sa.lpSecurityDescriptor );
            if( lRc != ERROR_SUCCESS ) 
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                    TEXT("Failed to RegCreateKeyEx for key name %s, code 0x%08x"), szDestName, lRc );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Failed to GetSecurityInfo for key name %s, code 0x%08x"), szSrcName, lRc );
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Failed to RegOpenKeyEx for key name %s, code 0x%08x"), szSrcName, lRc );
    }

#else
    /* On Win9x the source is not used as the name and class is all we need */
    hkSrcRoot;
    szSrcName;

    lRc = RegCreateKeyEx(  hkDestRoot,
                           szDestName,
                           0,
                           szClass,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hkSub,
                           &dwDisposition );
    if( lRc != ERROR_SUCCESS ) 
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Failed to RegCreateKeyEx for key name %s, code 0x%08x"), szDestName, lRc );
    }
#endif /* WINNT */

    if( lRc == ERROR_SUCCESS ) 
    {
        if( phkSub )
        {
            *phkSub = hkSub;
        }
        else
        {
            RegCloseKey( hkSub );
        }
        
        hres =( dwDisposition == REG_CREATED_NEW_KEY ) ? S_OK : S_FALSE;
    }
    else
    {
        hres = hresReg( lRc );
    }

    ExitOleProc();

    return( hres );

} /* hresRegCopyKey */

                    


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyKeys |
 *
 *          Copy all the keys under the source key to the root.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key be copied (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkRoot |
 *
 *          The Key under which the copy will be created
 *              (must be opened with at least KEY_WRITE).
 *
 *  @parm   PDWORD | pMaxNameLen |
 *
 *          An optional pointer to a value which will be filled with the number 
 *          of characters, incl. the NULL terminator, in the longest key name.
 *
 *  @returns
 *
 *          S_OK if all keys were successfully copied
 *          S_FALSE if there were no keys to copy.
 *          Or the memory allocation error code or the failing registry 
 *          function return code converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyKeys( HKEY hkSrc, HKEY hkRoot, PDWORD OPTIONAL pMaxNameLen )
{
    HRESULT             hres;
    LONG                lRc;
    DWORD               cSubKeys;
    DWORD               MaxNameLen;
    DWORD               cbName;
    PTCHAR              szKeyName;
    DWORD               MaxClassLen;
    DWORD               cbClass;
    PTCHAR              szClassName;

    EnterProcI(hresRegCopyKeys, (_ "xx", hkSrc, hkRoot ));

    lRc = RegQueryInfoKey(  hkSrc,              // handle to key to query
                            NULL, NULL, NULL,   // Class, cbClass, Reserved
                            &cSubKeys,          // NumSubKeys
                            &MaxNameLen,        // MaxSubKeyLen
                            &MaxClassLen,       // MaxClassLen
                            NULL, NULL, NULL,   // NumValues, MaxValueNameLen, MaxValueLen
                            NULL, NULL );       // Security descriptor, last write

    if( lRc == ERROR_SUCCESS )
    {
        if( cSubKeys )
        {
            // Make space for NULL terminators
            MaxNameLen++;
            MaxClassLen++;

            if( pMaxNameLen )
            {
                *pMaxNameLen = MaxNameLen;
            }

            /*
             *  There are keys to copy so allocate buffer sapce for the key and 
             *  key class names.
             */
            hres = AllocCbPpv( (MaxNameLen + MaxClassLen) * sizeof(szClassName[0]), &szKeyName );
            if( FAILED( hres ) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory copying subkeys") );
            }
            else
            {
                szClassName = &szKeyName[MaxNameLen];

                cSubKeys--;
                do
                {
                    cbName = MaxNameLen;
                    cbClass = MaxClassLen;

                    lRc = RegEnumKeyEx( hkSrc,      // Key containing subkeys to enumerate
                                        cSubKeys,   // index of subkey to enumerate
                                        szKeyName,  // address of buffer for subkey name
                                        &cbName,    // address for size of subkey buffer
                                        NULL,       // reserved
                                        szClassName,// address of buffer for class string
                                        &cbClass,   // address for size of class buffer
                                        NULL );     // address for time key last written to

                    if( lRc == ERROR_SUCCESS )
                    {
                        hres = hresRegCopyKey( hkSrc, szKeyName, szClassName, hkRoot, szKeyName, NULL );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegEnumKeyEx failed during copy keys, code 0x%08x"), lRc );
                        hres = hresReg( hres );
                    }

                    if( FAILED( hres ) )
                    {
                        break;
                    }
                } while( cSubKeys-- ); 
                FreePpv(&szKeyName);
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl, TEXT("No keys to copy") );
            hres = S_FALSE;
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("RegQueryInfoKey failed during value key, code 0x%08x"), lRc );
        hres = hresReg(lRc);
    }

    ExitOleProc();    

    return( hres );
} /* hresRegCopyKeys */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyBranch |
 *
 *          Copy the contents of one key including sub-keys to another.
 *          Since this function calls itself to copy the contents of subkeys,
 *          the local variables should be kept to a minimum.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key to be copied (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkDest |
 *
 *          Key to receive copy (must be opened with at least KEY_WRITE).
 *
 *  @returns
 *
 *          S_OK if the copy completed succesfully 
 *          or the return value from <f hresRegCopyValues>, 
 *          <f hresRegCopyKeys>, memory allocation error or a registry 
 *          function failure code converted to a <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresRegCopyBranch( HKEY hkSrc, HKEY hkDest )
{
    HKEY    hkSrcSub; 
    HKEY    hkDestSub;
    HRESULT hres;
    DWORD   dwIdx;
    DWORD   cbMaxName;
    DWORD   cbKeyName;
    PTCHAR  szKeyName;

    EnterProcI(hresRegCopyBranch, (_ "xx", hkSrc, hkDest));

    hres = hresRegCopyValues( hkSrc, hkDest );

    if( SUCCEEDED( hres ) )
    {
        hres = hresRegCopyKeys( hkSrc, hkDest, &cbMaxName );

        if( hres == S_FALSE )
        {
            /* No keys to recurse into */
            hres = S_OK;
        }
        else if( hres == S_OK )
        {
            hres = AllocCbPpv( cbMaxName * sizeof(szKeyName[0]), &szKeyName );

            if( SUCCEEDED( hres ) )
            {
                for( dwIdx=0; SUCCEEDED( hres ); dwIdx++ )
                {
                    cbKeyName = cbMaxName;

                    hres = hresReg( RegEnumKeyEx( hkSrc, dwIdx, 
                                                  szKeyName, &cbKeyName,
                                                  NULL, NULL, NULL, NULL ) );  // Reserved, szClass, cbClass, Last Write
                    if( SUCCEEDED( hres ) )
                    {
                        hres = hresReg( RegOpenKeyEx( hkSrc, szKeyName, 0, KEY_READ, &hkSrcSub ) );

                        if( SUCCEEDED( hres ) )
                        {
                            hres = hresReg( RegOpenKeyEx( hkDest, szKeyName, 0, KEY_WRITE, &hkDestSub ) );
                            if( SUCCEEDED( hres ) )
                            {
                                hres = hresRegCopyBranch( hkSrcSub, hkDestSub );
                            }
                            else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("Failed to open destination subkey %s for recursion, code 0x%04x"),
                                    szKeyName, LOWORD(hres) );
                            }
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed to open source subkey %s for recursion, code 0x%04x"),
                                szKeyName, LOWORD(hres) );
                        }
                    }
                    else
                    {
                        if( hres == hresReg( ERROR_NO_MORE_ITEMS ) )
                        {
                            /* Recursed all keys */
                            hres = S_OK;
                            break;
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed RegEnumKeyEx during subkey recursion, code 0x%04x"),
                                LOWORD(hres) );
                        }
                    }
                }

                FreePpv( &szKeyName );
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory recursing subkeys") );
            }
        }
        else
        {
            if( SUCCEEDED( hres ) )
            {
                RPF( "Unexpected success code 0x%08x from hresRegCopyKeys", hres );
            }
        }
    }

    ExitOleProc();

    return( hres );

} /* hresRegCopyBranch */

//  ISSUE-2001/03/29-timgill Make this version 7 when available
#endif /* DIRECTINPUT_VERSION > 0x0500 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diriff.h ===
#ifndef __RIFF_H__
#define __RIFF_H__
/****************************************************************************

	MODULE:     	RIFF.H
	Tab settings: 	Every 4 spaces

	Copyright 1996, Microsoft Corporation, 	All Rights Reserved.

	PURPOSE:    	Classes for reading and writing RIFF files
    
	CLASSES:
		CRIFFFile	Encapsulates common RIFF file functionality

	Author(s):	Name:
	----------	----------------
		DMS		Daniel M. Sangster

	Revision History:
	-----------------
	Version Date            Author  Comments
	1.0  	25-Jul-96       DMS     Created

	COMMENTS:
****************************************************************************/


// the four-character codes (FOURCC) needed for .FRC RIFF format

#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')

#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')

#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')

#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')

#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')

#define MAX_SIZE_SNAME              (64)

HRESULT RIFF_Open
    (
    LPCSTR          lpszFilename,
    UINT            nOpenFlags,
    PHANDLE         lphmmio,
    LPMMCKINFO      lpmmck,
    PDWORD          pdwEffectSize
    );

HRESULT
    RIFF_ReadEffect
    (
    HMMIO           hmmio, 
    LPDIFILEEFFECT  lpDiFileEf 
    );


HRESULT RIFF_WriteEffect
    (
     HMMIO          hmmio,
     LPDIFILEEFFECT lpDiFileEf
     );


HRESULT RIFF_Close
    (
    HMMIO           hmmio, 
    UINT            nFlags
    );

#endif //__RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diriff.c ===
/****************************************************************************

    MODULE:     	RIFF.CPP
    Tab settings: 	Every 4 spaces

    Copyright 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Classes for reading and writing RIFF files
    
    CLASSES:
        CRIFFFile	Encapsulates common RIFF file functionality

    Author(s):	Name:
    ----------	----------------
        DMS		Daniel M. Sangster

    Revision History:
    -----------------
    Version Date            Author  Comments
    1.0  	25-Jul-96       DMS     Created

    COMMENTS:
****************************************************************************/
#include "dinputpr.h"
#define sqfl sqflDev


/* 
 * This function converts MMIO errors to HRESULTS
 */
HRESULT INLINE hresMMIO(UINT mmioErr)
{
    switch(mmioErr)
    {
    case 0x0:                       return  S_OK;
    case MMIOERR_FILENOTFOUND:      return  hresLe(ERROR_FILE_NOT_FOUND);/* file not found */
    case MMIOERR_OUTOFMEMORY:       return  hresLe(ERROR_OUTOFMEMORY);  /* out of memory */
    case MMIOERR_CANNOTOPEN:        return  hresLe(ERROR_OPEN_FAILED);  /* cannot open */
    case MMIOERR_CANNOTCLOSE:       return  S_FALSE;                    /* cannot close */
    case MMIOERR_CANNOTREAD:        return  hresLe(ERROR_READ_FAULT);   /* cannot read */
    case MMIOERR_CANNOTWRITE:       return  hresLe(ERROR_WRITE_FAULT);  /* cannot write */
    case MMIOERR_CANNOTSEEK:        return  hresLe(ERROR_SEEK);         /* cannot seek */
    case MMIOERR_CANNOTEXPAND:      return  hresLe(ERROR_SEEK);           /* cannot expand file */
    case MMIOERR_CHUNKNOTFOUND:     return  hresLe(ERROR_SECTOR_NOT_FOUND);  /* chunk not found */
    case MMIOERR_UNBUFFERED:        return  E_FAIL;
    case MMIOERR_PATHNOTFOUND:      return  hresLe(ERROR_PATH_NOT_FOUND);/* path incorrect */
    case MMIOERR_ACCESSDENIED:      return  hresLe(ERROR_ACCESS_DENIED); /* file was protected */
    case MMIOERR_SHARINGVIOLATION:  return  hresLe(ERROR_SHARING_VIOLATION); /* file in use */
    case MMIOERR_NETWORKERROR:      return  hresLe(ERROR_UNEXP_NET_ERR); /* network not responding */
    case MMIOERR_TOOMANYOPENFILES:  return  hresLe(ERROR_TOO_MANY_OPEN_FILES); /* no more file handles  */
    case MMIOERR_INVALIDFILE:       return  hresLe(ERROR_BAD_FORMAT);    /* default error file error */
    default:                        return  E_FAIL;   
    }

}


HRESULT INLINE RIFF_Ascend(HMMIO hmmio, LPMMCKINFO lpmmckinfo)
{
    return hresMMIO( mmioAscend(hmmio, lpmmckinfo, 0) );
}

HRESULT INLINE RIFF_Descend(HMMIO hmmio, LPMMCKINFO lpmmckinfo, LPMMCKINFO lpmmckinfoParent, UINT nFlags)
{
    return hresMMIO(mmioDescend(hmmio, lpmmckinfo, lpmmckinfoParent, nFlags));
}

HRESULT INLINE RIFF_CreateChunk(HMMIO hmmio, LPMMCKINFO lpmmckinfo, UINT nFlags)
{
    // set cksize to zero to overcome a bug in release version of mmioAscend
    // which does not correctly write back the size of the chunk
    lpmmckinfo->cksize = 0;

    return hresMMIO(mmioCreateChunk(hmmio, lpmmckinfo, nFlags));
}


HRESULT INLINE RIFF_Read(HMMIO hmmio, LPVOID pBuf, LONG nCount)
{
    return (nCount == mmioRead(hmmio, (char*)pBuf, nCount)) ? S_OK: hresLe(ERROR_READ_FAULT);
}          

HRESULT INLINE RIFF_Write(HMMIO hmmio, const LPVOID pBuf, LONG nCount)
{
    return ( nCount == mmioWrite(hmmio, (char*)pBuf, nCount)) ? S_OK : hresLe(ERROR_WRITE_FAULT);
}

HRESULT RIFF_Close(HMMIO hmmio, UINT nFlags)
{
    return hresMMIO(mmioClose(hmmio, nFlags));
}

/*
 * Opens a RIFF file for read / write
 * Reads/Writes a GUID that servers as our signature
 */
HRESULT RIFF_Open
    (
    LPCSTR      lpszFilename,
    UINT        nOpenFlags,
    PHANDLE     phmmio,
    LPMMCKINFO  lpmmck,
    PDWORD      pdwEffectSz
    )
{
    HRESULT     hres = S_OK;
    MMIOINFO    mmInfo;
    HMMIO       hmmio;

    ZeroX(mmInfo);

    // go ahead and open the file, if we can
    hmmio = mmioOpenA((LPSTR)lpszFilename, &mmInfo, nOpenFlags);

    if(mmInfo.wErrorRet)
    {
        hres = hresMMIO(mmInfo.wErrorRet);
        AssertF(FAILED(hres));
    }

   // if( nOpenFlags & ( MMIO_READ | MMIO_ALLOCBUF) )
	 if( nOpenFlags == ( MMIO_READ | MMIO_ALLOCBUF) )
    {
        if(SUCCEEDED(hres))
        {
            // locate and descend into FORC RIFF chunk
            lpmmck->fccType = FCC_FORCE_EFFECT_RIFF;
            hres = RIFF_Descend(hmmio, lpmmck, NULL, MMIO_FINDRIFF);
        }

        if(SUCCEEDED(hres))
        {
            GUID GUIDVersion;
            //read the guid
            hres = RIFF_Read(hmmio, &GUIDVersion, sizeof(GUID));

            if(SUCCEEDED(hres))
            {
                if(IsEqualGUID(&GUIDVersion, &GUID_INTERNALFILEEFFECT))
                {
                
                } else
                {
                    hres = hresLe(ERROR_BAD_FORMAT);
                }
            }
        }

    } 
	//else if( nOpenFlags & ( MMIO_WRITE | MMIO_ALLOCBUF) )
	else if( nOpenFlags & ( MMIO_WRITE) )
    {

        // create the FORC RIFF chunk
        lpmmck->fccType = FCC_FORCE_EFFECT_RIFF;
        hres = RIFF_CreateChunk(hmmio, lpmmck, MMIO_CREATERIFF);

        if(SUCCEEDED(hres))
        {
            //write the version GUID
            hres = RIFF_Write(hmmio, (PV)&GUID_INTERNALFILEEFFECT, sizeof(GUID));
        }
    } else
    {
        hres = E_FAIL;
    }

    *phmmio = hmmio;
    return hres;
}



/*****************************************************************************
 *
 * internal
 * RIFF_ReadEffect
 *
 *  Reads a single Effect from a RIFF file
 *  
 *  The callee bears the responsibility to free the TypeSpecificParameterBlock
 *  for the effect.
 *       
 *
 *****************************************************************************/

#ifdef _M_IA64
//This is hack to read 32 bit files on ia64, since someone decided to write 
//pointers to file.
//Copied from dinput.h and modified.
typedef struct DIEFFECT_FILE32 {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */

/*Make sure size is same on both 1386 and ia64.
    LPDWORD rgdwAxes;
    LPLONG rglDirection;
    LPDIENVELOPE lpEnvelope;
*/  DWORD rgdwAxes;                 /* Array of axes        */
    DWORD rglDirection;             /* Array of directions  */
    DWORD lpEnvelope;               /* Optional             */

    DWORD cbTypeSpecificParams;     /* Size of params       */

/*Make sure size is same on both 1386 and ia64.
    LPVOID lpvTypeSpecificParams;
*/  DWORD lpvTypeSpecificParams;    /* Pointer to params    */

//#if(DIRECTINPUT_VERSION >= 0x0600)//Out since file format does not change.
    DWORD  dwStartDelay;            /* Microseconds         */
//#endif /* DIRECTINPUT_VERSION >= 0x0600 *///Out since file format does not change.
} DIEFFECT_FILE32, *LPDIEFFECT_FILE32;
#endif /*_M_IA64*/

HRESULT
    RIFF_ReadEffect
    (
    HMMIO      hmmio, 
    LPDIFILEEFFECT lpDiFileEf 
    )
{
    HRESULT hres = E_FAIL;
    MMCKINFO mmckinfoEffectLIST;
    MMCKINFO mmckinfoDataCHUNK;
    LPDIEFFECT peff = (LPDIEFFECT)lpDiFileEf->lpDiEffect;

    // descend into the effect list
    mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
    hres = RIFF_Descend(hmmio, &mmckinfoEffectLIST, NULL, MMIO_FINDLIST);
   
    if(SUCCEEDED(hres))
    {
        //read the name
        hres = RIFF_Read(hmmio, lpDiFileEf->szFriendlyName, MAX_SIZE_SNAME);
    }

    if(SUCCEEDED(hres))
    {
#ifdef _M_IA64

        DIEFFECT_FILE32 eff32;
        //read the effect structure
        hres = RIFF_Read(hmmio, &eff32, sizeof(eff32));

        AssertF( eff32.dwSize == sizeof(eff32) );
        if( eff32.dwSize != sizeof(eff32) )
        {
            hres = ERROR_BAD_FORMAT;
        }
        else
        {
            peff->dwSize=sizeof(*peff);
            peff->dwFlags=eff32.dwFlags;
            peff->dwDuration=eff32.dwDuration;
            peff->dwSamplePeriod=eff32.dwSamplePeriod;
            peff->dwGain=eff32.dwGain;
            peff->dwTriggerButton=eff32.dwTriggerButton;
            peff->dwTriggerRepeatInterval=eff32.dwTriggerRepeatInterval;
            peff->cAxes=eff32.cAxes;
            peff->cbTypeSpecificParams=eff32.cbTypeSpecificParams;
            peff->lpvTypeSpecificParams=(LPVOID)(DWORD_PTR)eff32.lpvTypeSpecificParams;
            peff->dwStartDelay=eff32.dwStartDelay;
        }

#else /*_M_IA64*/
            
        // Reading the effect structure will zap out the following,
        // so we make a copy before the read.
        LPDIENVELOPE    lpEnvelope  = peff->lpEnvelope;
        LPDWORD         rgdwAxes    = peff->rgdwAxes;
        LPLONG          rglDirection= peff->rglDirection;
        
        //read the effect structure
        hres = RIFF_Read(hmmio, peff, sizeof(DIEFFECT));
        
        AssertF( peff->dwSize == sizeof(DIEFFECT) );
        if( peff->dwSize != sizeof(DIEFFECT) )
        {
            hres = ERROR_BAD_FORMAT;
        }
        else
        {
            if(peff->lpEnvelope)		peff->lpEnvelope    =   lpEnvelope;
            if(peff->rgdwAxes)			peff->rgdwAxes      =   rgdwAxes;
            if(peff->rglDirection)		peff->rglDirection  =   rglDirection;
        }

#endif /*_M_IA64*/

	    if(SUCCEEDED(hres))
        {    
            AssertF(peff->cAxes < DIEFFECT_MAXAXES);
            if(peff->cAxes >= DIEFFECT_MAXAXES)
            {
                hres = ERROR_BAD_FORMAT;
            }
        }
    }

	if(SUCCEEDED(hres))
    {
        // read the Effect GUID
        hres = RIFF_Read(hmmio, &lpDiFileEf->GuidEffect, sizeof(GUID));
    }


	if(SUCCEEDED(hres))
    {
        UINT nRepeatCount;
        //read in the repeat count
        hres = RIFF_Read(hmmio, &nRepeatCount, sizeof(nRepeatCount));
    }


    if(SUCCEEDED(hres) && peff->rgdwAxes)
    {
        // descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			//read the axes
			hres = RIFF_Read(hmmio, peff->rgdwAxes, cbX(*peff->rgdwAxes)*(peff->cAxes));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
	}

    if(SUCCEEDED(hres) && peff->rglDirection)
    {
		//descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			//read the direction
			hres = RIFF_Read(hmmio, peff->rglDirection, cbX(*peff->rglDirection)*(peff->cAxes));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
    }

    if(SUCCEEDED(hres) && peff->lpEnvelope )
    {
	
		//descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			hres = RIFF_Read(hmmio, peff->lpEnvelope, sizeof(DIENVELOPE));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
    }


    if(SUCCEEDED(hres) && (peff->cbTypeSpecificParams > 0))
    {
        // get the param structure, if any 
        hres = AllocCbPpv( peff->cbTypeSpecificParams, &peff->lpvTypeSpecificParams );

        if( SUCCEEDED( hres ) )
        {
			//descend the data chunk
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Read(hmmio, peff->lpvTypeSpecificParams, peff->cbTypeSpecificParams);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    if(SUCCEEDED(hres))
    {
		 // ascend the effect chunk
		 hres = RIFF_Ascend(hmmio, &mmckinfoEffectLIST);
    }
    return hres;
}


/*
 * RIFF_WriteEffect
 *
 *  Writes a single Effect structure to a RIFF file
 *
 *  The effect structure is quite complex. It contains pointers
 *  to a number of other structures. This function checks for
 *  valid data before it writes out the effect structure
 */

HRESULT RIFF_WriteEffect
    (HMMIO hmmio,
     LPDIFILEEFFECT    lpDiFileEf
    )
{

    HRESULT hres = E_FAIL;
    LPDIEFFECT peff = (LPDIEFFECT)lpDiFileEf->lpDiEffect;
    MMCKINFO mmckinfoEffectLIST;
    MMCKINFO mmckinfoDataCHUNK;
	LPDWORD rgdwAxes = NULL;
	LPLONG rglDirection = NULL;
	LPDIENVELOPE lpEnvelope = NULL;
	LPVOID lpvTypeSpecPar = NULL;

    EnterProcI(RIFF_WriteEffect, (_ "xx", hmmio, lpDiFileEf));

    // create the effect LIST
    mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
    hres = RIFF_CreateChunk(hmmio, &mmckinfoEffectLIST, MMIO_CREATELIST);

	//save the effect ptrs and write flags to the file, instead of ptrs
	if (peff->rgdwAxes)
	{
		rgdwAxes = peff->rgdwAxes;
		peff->rgdwAxes = (LPDWORD)DIEP_AXES;
	}
	if (peff->rglDirection)
	{
		rglDirection = peff->rglDirection;
		peff->rglDirection = (LPLONG)DIEP_DIRECTION;
	}
	if (peff->lpEnvelope)
	{
		lpEnvelope = peff->lpEnvelope;
		peff->lpEnvelope = (LPDIENVELOPE)DIEP_ENVELOPE;
	}
	if ((peff->cbTypeSpecificParams > 0) && (peff->lpvTypeSpecificParams != NULL))
	{
		lpvTypeSpecPar = peff->lpvTypeSpecificParams;
		peff->lpvTypeSpecificParams = (LPVOID)DIEP_TYPESPECIFICPARAMS;
	}

	
    if(SUCCEEDED(hres))
    {
        hres = hresFullValidReadStrA(lpDiFileEf->szFriendlyName, MAX_JOYSTRING,1);

        if(SUCCEEDED(hres))
        {
            //write the name, only MAX_SIZE_SNAME characters
            hres = RIFF_Write(hmmio, lpDiFileEf->szFriendlyName, MAX_SIZE_SNAME);
        }
    }

    if(SUCCEEDED(hres))
    {
        hres = (peff && IsBadReadPtr(peff, cbX(DIEFFECT_DX5))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
            hres = (peff && IsBadReadPtr(peff, peff->dwSize)) ? E_POINTER : S_OK;
        }
        
        if(SUCCEEDED(hres))
        {
            //write the effect structure
#ifdef _M_IA64
            DIEFFECT_FILE32 eff32;
            ZeroMemory(&eff32,sizeof(eff32));
            eff32.dwSize=sizeof(eff32);
            eff32.dwFlags=peff->dwFlags;
            eff32.dwDuration=peff->dwDuration;
            eff32.dwSamplePeriod=peff->dwSamplePeriod;
            eff32.dwGain=peff->dwGain;
            eff32.dwTriggerButton=peff->dwTriggerButton;
            eff32.dwTriggerRepeatInterval=peff->dwTriggerRepeatInterval;
            eff32.cAxes=peff->cAxes;
            eff32.cbTypeSpecificParams=peff->cbTypeSpecificParams;
            eff32.lpvTypeSpecificParams=(DWORD)(DWORD_PTR)peff->lpvTypeSpecificParams;
            eff32.dwStartDelay=peff->dwStartDelay;
            hres = RIFF_Write(hmmio, &eff32, eff32.dwSize);
#else /*_M_IA64*/
            hres = RIFF_Write(hmmio, peff, peff->dwSize);
#endif /*_M_IA64*/
        }
    }

	//restore the ptrs
	if (rgdwAxes != NULL)
	{
		peff->rgdwAxes = rgdwAxes;
	}

	if (rglDirection != NULL)
	{
		peff->rglDirection = rglDirection;
	}

	if (lpEnvelope != NULL)
	{
		peff->lpEnvelope = lpEnvelope;
	}

	if (lpvTypeSpecPar != NULL)
	{
		peff->lpvTypeSpecificParams = lpvTypeSpecPar;
	}


	if(SUCCEEDED(hres))
    {
        // write the Effect GUID
        hres = RIFF_Write(hmmio, &lpDiFileEf->GuidEffect, sizeof(GUID));
    }


	//write 1 as the repeat count
	if(SUCCEEDED(hres))
    {
		UINT nRepeatCount = 1;
        hres = RIFF_Write(hmmio, &nRepeatCount, sizeof(DWORD));
    }


    if(SUCCEEDED(hres) && rgdwAxes )
    {
        hres = (IsBadReadPtr(rgdwAxes, (*rgdwAxes)*cbX(peff->cAxes))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the axes
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, rgdwAxes, sizeof(*rgdwAxes)*(peff->cAxes));
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }

    if(SUCCEEDED(hres) && rglDirection)
    {

        hres = (IsBadReadPtr(rglDirection, cbX(*rglDirection)*(peff->cAxes))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			if(SUCCEEDED(hres))
			{
				//write the direction
				hres = RIFF_Write(hmmio, rglDirection, sizeof(*rglDirection)*(peff->cAxes));
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    //write the envelope, if one is present
    if(SUCCEEDED(hres) &&
       (lpEnvelope != NULL) )
    {

        hres = (IsBadReadPtr(lpEnvelope, cbX(*lpEnvelope))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the envelope
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, lpEnvelope, lpEnvelope->dwSize);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    //write the type-specific
    if(SUCCEEDED(hres) &&
       (peff->cbTypeSpecificParams > 0) && 
       (peff->lpvTypeSpecificParams != NULL) )
    {

        hres = (IsBadReadPtr(lpvTypeSpecPar, peff->cbTypeSpecificParams)) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the params
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, lpvTypeSpecPar, peff->cbTypeSpecificParams);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    if(SUCCEEDED(hres))
    {
        // ascend the effect chunk
        hres = RIFF_Ascend(hmmio, &mmckinfoEffectLIST);
    }

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diport.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       digsport.h
 *  Content:    DirectInput internal include file for HID
 *
 ***************************************************************************/


#ifndef __DIPORT_H
    #define __DIPORT_H

/* Forward define */
typedef struct _BUSDEVICE BUSDEVICE, *PBUSDEVICE;



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUS_REGDATA
 *          Persistent Data, written to the registry for each gameport device. 
 *          Contains information on how to reexpose the analog joystick device
 *          on reboot. 
 *
 *  @field  DWORD | dwSize |
 *          Size of the structure. 
 *
 *  @field  USHORT | uVID |
 *          Vendor ID.
 *
 *  @field  USHORT | uPID |
 *          Product ID.
 *
 *  @field  USHORT | nJoysticks |
 *          Number of joysticks attached to this gameport. 
 *
 *  @field  USHORT | nAxes |
 *          Number of axes in each joystick. 
 *
 *  @field  PVOID | hHardwareHandle |
 *          Hardware handle returned by EXPOSE IOCTL to gameenum.
 *          Needed to remove the joystick device. 
 *
 *  @field  BOOLEAN | fAttachOnReboot |
 *          Flag that is cleared when a device is exposed and set when 
 *          the device is found to be OK.  Used to prevent reloading 
 *          of a device that crashes immediately.
 *
 *  @field  JOYREGHWSSETTINGS | hws |
 *          Joystick Hardware settings. 
 *
 *  @field  WCHAR | wszHardwareId |
 *          PnP hardware ID for the joystick. 
 * 
 *****************************************************************************/

typedef struct _BUS_REGDATA
{
    /* Size of structure */
    DWORD               dwSize;
    /* VID PID for this device */
    USHORT              uVID;
    USHORT              uPID;
    /* Number of joysticks to expose */
    USHORT              nJoysticks;
    USHORT              nAxes;
    /* Hardware settings for joystick */
    PVOID               hHardware;
    /* Flag whether or not device should be re-exposed */
    BOOLEAN             fAttachOnReboot;
    /* Joystick Hardware settings */
    JOYREGHWSETTINGS    hws;
    DWORD               dwFlags1;
    /* An array of (zero terminated wide character
     * strings).  The array itself also null terminated
     */
    WCHAR   wszHardwareId[MAX_JOYSTRING];

} BUS_REGDATA, *PBUS_REGDATA;



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICEINFO
 *          Data about each instance of bus devices ( gameport / serial port, etc .. )
 *
 *  @field  PBUSDEVICE | pBusDevice |
 *          Address of the BusDevice struct.
 *
 *  @field  PSP_DEVICE_INTERFACE_DETAIL_DATA | pdidd |
 *          Device interface detail data. 
 *
 *  @field  GUID | guid |
 *          Instance GUID for the device.
 *
 *  @field  int | idPort |
 *          Unique ID for the gameport. 
 *
 *  @field  int | idJoy |
 *          Id of one of the joysticks attached to this gameport. 
 *
 *  @field  HKEY | hk |
 *          Registry key that contains configuration information.
 *          Sadly, we must keep it open because there is no way to
 *          obtain the name of the key, and the only way to open the
 *          key is inside an enumeration.
 *
 *  @field  LPTSTR  | ptszId |
 *          Device path to access the gameport for read / write. 
 *
 *  @field  BOOL    | fAttached |
 *          True is device is attached.
 *
 *  @field  BOOL    | fDeleteIfNotConnected |
 *          Flag that indicates that the device should be deleted if it
 *          is not connected. 
 *
 *******************************************************************************/

typedef struct _BUSDEVICEINFO
{
    PBUSDEVICE pBusDevice;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pdidd;
    GUID                                guid;
    int                                 idPort;
    int                                 idJoy;
    HKEY                                hk;
    LPTSTR                              ptszId;
    BOOL                                fAttached;
    BOOL                                fDeleteIfNotConnected;
} BUSDEVICEINFO, *PBUSDEVICEINFO;


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICELIST |
 *
 *          Records information about all the HID devices.
 *
 *  @field  int | cbdi |
 *
 *          Number of items in the list that are in use.
 *
 *  @field  int | cbdiAlloc |
 *
 *          Number of items allocated in the list.
 *
 *  @field  BUSDEVICEINFO | rgbdi[0] |
 *
 *          Variable-size array of device information structures.
 *
 *****************************************************************************/

typedef struct _BUSDEVICELIST
{
    int cgbi;
    int cgbiAlloc;
    BUSDEVICEINFO rgbdi[0];
} BUSDEVICELIST, *PBUSDEVICELIST;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICE |
 *
 *          Data specific to each bus ( gameport / serialPort ).
 *
 *  @field  PBUSDEVICE | pbdl |
 *          List of devices on a bus. 
 *
 *  @field  PCGUID  | pcGuid |
 *          Device GUID for the bus. 
 *
 *  @field  DWORD   | tmLastRebuild |
 *          Last time the bus device list was rebuild. 
 *
 *  @field  const int | ioctl_EXPOSE |
 *          IOCTL to expose a device.
 *
 *  @field  const int | ioclt_REMOVE |
 *          IOCTL to remove a device. 
 *
 *  @field  const int | ioctl_DESC |
 *          IOCTL to obtain description of the bus.
 *
 *  @field  const int | ioctl_PARAMETERS |
 *
 *  @field  const int | ioctl_EXPOSE_SIBLING |
 *
 *  @field  const int | ioctl_REMOVE_SELF |
 *
 *  @field  const int | dw_IDS_STDPORT |
 *          index into the IDS String table for text associated with device.
 *
 *  @field  const int | dw_JOY_HWS_ISPORTBUS |
 *
 *****************************************************************************/

typedef struct _BUSDEVICE
{
    D(TCHAR wszBusType[MAX_PATH];)
    PBUSDEVICELIST pbdl;
    PCGUID pcGuid;
    DWORD tmLastRebuild;
    const int ioctl_EXPOSE;
    const int ioctl_REMOVE;
    const int ioctl_DESC;
    const int ioctl_PARAMETERS;
    const int ioctl_EXPOSE_SIBLING;
    const int ioctl_REMOVE_SELF;
    const int dwIDS_STDPORT;
    const int dwJOY_HWS_ISPORTBUS;
} BUSDEVICE, *PBUSDEVICE;

extern BUSDEVICE g_pBusDevice[];


    #define cbGdlCbdi(cbdi)         FIELD_OFFSET(BUSDEVICELIST, rgbdi[cbdi])

/*
 *  We choose our starting point at 2 devices, since most machines
 *  will have one gameport/serialport bus.
 *  The maximum number is chosen at randomn
 */

    #define cgbiMax                 32
    #define cgbiInit                2   // Most machines will have only one gameport bus, two serialports


    #define MAX_PORT_BUSES  16


PBUSDEVICEINFO INTERNAL
    pbdiFromphdi
    (
    IN PHIDDEVICEINFO phdi
    );

PHIDDEVICEINFO INTERNAL
    phdiFrompbdi
    (
    IN PBUSDEVICEINFO pbdi
    );

PBUSDEVICEINFO EXTERNAL
    pbdiFromJoyId
    (
    IN int idJoy
    );

PBUSDEVICEINFO EXTERNAL
    pbdiFromGUID
    (
    IN PCGUID pguid    
    );

HRESULT EXTERNAL
    DIBusDevice_Expose
    (
    IN HANDLE hf,
    IN OUT PBUS_REGDATA pRegData
    );


HRESULT INTERNAL
    DIBusDevice_Remove
    (
    IN PBUSDEVICEINFO  pbdi
    );


HRESULT INTERNAL
    DIBusDevice_SetRegData
    (
    IN HKEY hk,
    IN PBUS_REGDATA pRegData
    );


HRESULT INTERNAL
    DIBusDevice_GetRegData
    (
    IN HKEY hk,
    OUT PBUS_REGDATA pRegData
    );


BOOL INTERNAL
    DIBusDevice_BuildListEntry
    (
    HDEVINFO hdev,
    PSP_DEVICE_INTERFACE_DATA pdid,
    PBUSDEVICE pBusDevice
    );


void INTERNAL
    DIBus_EmptyList
    (
    PBUSDEVICELIST *ppbdl 
    );

void EXTERNAL
    DIBus_FreeMemory();

HRESULT EXTERNAL
    DIBus_InitId
    (
     PBUSDEVICELIST pbdl
    );


ULONG EXTERNAL
    DIBus_BuildList
    (
    IN BOOL fForce
    );

PBUSDEVICELIST EXTERNAL 
    pbdlFromGUID
    ( 
    IN PCGUID pcGuid 
    );

HRESULT EXTERNAL
    DIBusDevice_ExposeEx
    (
    IN PBUSDEVICELIST  pbdl,
    IN PBUS_REGDATA    pRegData
    );

HRESULT EXTERNAL
    DIBusDevice_GetTypeInfo
    (
        PCGUID guid,
        LPDIJOYTYPEINFO pjti,
        DWORD fl
    );

HRESULT EXTERNAL DIPort_SnapTypes(LPWSTR *ppwszz);

#endif /* __DIPORT_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\direg.c ===
/*****************************************************************************
 *
 *  DIReg.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      OLE self-registration.
 *
 *  Contents:
 *
 *      DllRegisterServer()
 *      DllUnregisterServer()
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/*****************************************************************************
 *
 *      RegSetStringEx
 *
 *      Add a REG_SZ to hkey\sub::value.
 *
 *****************************************************************************/

void INTERNAL
RegSetStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                             (PV)ptszData, cbCtch(lstrlen(ptszData)+1));
}

/*****************************************************************************
 *
 *      RegDelStringEx
 *
 *      Remove a REG_SZ from hkey\sub::value.  The data is ignored.
 *      It's passed so that RegDelStringEx matches the prototype for a
 *      REGSTRINGACTION.
 *
 *****************************************************************************/

void INTERNAL
RegDelStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegDeleteValue(hk, ptszValue);
}

/*****************************************************************************
 *
 *      RegCloseFinish
 *
 *      Just close the subkey already.
 *
 *****************************************************************************/

void INTERNAL
RegCloseFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc = RegCloseKey(hkSub);
}

/*****************************************************************************
 *
 *      RegDelFinish
 *
 *      Delete a key if there is nothing in it.
 *
 *      OLE unregistration rules demand that you not delete a key if OLE
 *      has added something to it.
 *
 *****************************************************************************/

void INTERNAL
RegDelFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc;
    DWORD cKeys = 0, cValues = 0;
    RegQueryInfoKey(hkSub, 0, 0, 0, &cKeys, 0, 0, &cValues, 0, 0, 0, 0);
    RegCloseKey(hkSub);
    if ((cKeys | cValues) == 0) {

    if( fWinnt )
        lRc = DIWinnt_RegDeleteKey(hk, ptszSub);
    else
        lRc = RegDeleteKey(hk, ptszSub);

    } else {
        lRc = 0;
    }
}

/*****************************************************************************
 *
 *      REGVTBL
 *
 *      Functions for dorking with a registry key, either coming or going.
 *
 *****************************************************************************/

typedef struct REGVTBL {
    /* How to create/open a key */
    LONG (INTERNAL *KeyAction)(HKEY hk, LPCTSTR ptszSub, PHKEY phkOut);

    /* How to create/delete a string */
    void (INTERNAL *StringAction)(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData);

    /* How to finish using a key */
    void (INTERNAL *KeyFinish)(HKEY hk, LPCTSTR ptszSub, HKEY hkSub);

} REGVTBL, *PREGVTBL;
typedef const REGVTBL *PCREGVTBL;

const REGVTBL c_vtblAdd = { RegCreateKey, RegSetStringEx, RegCloseFinish };
const REGVTBL c_vtblDel = {   RegOpenKey, RegDelStringEx,   RegDelFinish };

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllServerAction |
 *
 *          Register or unregister our objects with OLE/COM/ActiveX/
 *          whatever its name is.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern const TCHAR c_tszNil[];

#define ctchClsid       ctchGuid

const TCHAR c_tszClsidGuid[] =
TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

const TCHAR c_tszInProcServer32[] = TEXT("InProcServer32");
const TCHAR c_tszThreadingModel[] = TEXT("ThreadingModel");
const TCHAR c_tszBoth[] = TEXT("Both");

#pragma END_CONST_DATA

void INTERNAL
DllServerAction(PCREGVTBL pvtbl)
{
    TCHAR tszThisDll[MAX_PATH];
    UINT iclsidmap;

    GetModuleFileName(g_hinst, tszThisDll, cA(tszThisDll));

    for (iclsidmap = 0; iclsidmap < cclsidmap; iclsidmap++) {
        TCHAR tszClsid[7+ctchClsid];
        HKEY hkClsid;
        HKEY hkSub;
        REFCLSID rclsid = c_rgclsidmap[iclsidmap].rclsid;

        wsprintf(tszClsid, c_tszClsidGuid,
                 rclsid->Data1, rclsid->Data2, rclsid->Data3,
                 rclsid->Data4[0], rclsid->Data4[1],
                 rclsid->Data4[2], rclsid->Data4[3],
                 rclsid->Data4[4], rclsid->Data4[5],
                 rclsid->Data4[6], rclsid->Data4[7]);

        if (pvtbl->KeyAction(HKEY_CLASSES_ROOT, tszClsid, &hkClsid) == 0) {
            TCHAR tszName[127];

            /* Do the type name */
            LoadString(g_hinst, c_rgclsidmap[iclsidmap].ids,
                       tszName, cA(tszName));
            pvtbl->StringAction(hkClsid, 0, tszName);

            /* Do the in-proc server name and threading model */
            if (pvtbl->KeyAction(hkClsid, c_tszInProcServer32, &hkSub) == 0) {
                pvtbl->StringAction(hkSub, 0, tszThisDll);
                pvtbl->StringAction(hkSub, c_tszThreadingModel, c_tszBoth);
                pvtbl->KeyFinish(hkClsid, c_tszInProcServer32, hkSub);
            }

            pvtbl->KeyFinish(HKEY_CLASSES_ROOT, tszClsid, hkClsid);

        }
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRegisterServer |
 *
 *          Register our classes with OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllRegisterServer(void)
{
    DllServerAction(&c_vtblAdd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllUnregisterServer |
 *
 *          Unregister our classes from OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllUnregisterServer(void)
{
    DllServerAction(&c_vtblDel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dithunk.h ===
/*****************************************************************************
 *
 *  DiThunk.h
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template thunks for Windows 95 device manager.
 *
 *****************************************************************************/
/*****************************************************************************
 *
 *  dithunk.c
 *
 *****************************************************************************/

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct KERNELPROCADDR |
 *
 *          Kernel procedure addresses.
 *
 *          Careful!  This must match dithunk.c::c_rgpszKernel32.
 *
 ***************************************************************************/

typedef struct KERNELPROCADDR { /* kpa */

    /* By ordinal */
    HINSTANCE   (NTAPI *LoadLibrary16)(LPCSTR);
    BOOL        (NTAPI *FreeLibrary16)(HINSTANCE);
    FARPROC     (NTAPI *GetProcAddress16)(HINSTANCE, LPCSTR);

    /* By name */
    LPVOID      (NTAPI   *MapLS)(LPVOID);
    void        (NTAPI   *UnMapLS)(LPVOID);
    LPVOID      (NTAPI   *MapSL)(LPVOID);
    LPVOID      (NTAPI   *MapSLFix)(LPVOID);
    void        (NTAPI   *UnMapSLFixArray)(int, LPVOID);

    /* Warning: GetKernelProcAddresses assumes that QT_Thunk is last */
    void        (__cdecl *QT_Thunk)(void);

} KERNELPROCADDR;

extern KERNELPROCADDR g_kpa;

int __cdecl TemplateThunk(FARPROC fp, PCSTR pszSig, ...);

#define MAKELP(sel, ofs)            (PV)MAKELPARAM(ofs, sel)

BOOL EXTERNAL Thunk_GetKernelProcAddresses(void);

HINSTANCE EXTERNAL
Thunk_GetProcAddresses(FARPROC *rgfp, LPCSTR *rgpsz,
                       UINT cfp, LPCSTR pszLibrary);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\dithunk.c ===
/*****************************************************************************
 *
 *  DiThunk.c
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template thunks for Windows 95 device manager.
 *
 *  Contents:
 *
 *      Thunk_Init
 *      Thunk_Term
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "dithunk.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflThunk


KERNELPROCADDR g_kpa;

#pragma BEGIN_CONST_DATA

/*
 *  Careful!  This must match KERNELPROCADDR ...
 */
static LPCSTR c_rgpszKernel32[] = {
    (LPVOID) 35,            /* LoadLibrary16 */
    (LPVOID) 36,            /* FreeLibrary16 */
    (LPVOID) 37,            /* GetProcAddress16 */

    "MapLS",
    "UnMapLS",
    "MapSL",
    "MapSLFix",
    "UnMapSLFixArray",
    "QT_Thunk",
};

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | TemplateThunk |
 *
 *          Call down, passing all sorts of random parameters.
 *
 *          Parameter signature is as follows:
 *
 *          p = 0:32 pointer to convert to 16:16 pointer
 *
 *          l = a 32-bit integer
 *
 *          s = a 16-bit integer
 *
 *
 *          P = returns a pointer
 *
 *          L = returns a 32-bit integer
 *
 *          S = returns a 16-bit signed integer
 *
 *          U = returns a 16-bit unsigned integer
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

#ifdef WIN95
#ifdef SLOW_BUT_READABLE

__declspec(naked) int
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    BYTE rgbThunk[60];          /* For private use of QT_Thunk */
    LPVOID *ppvArg;
    int i;
    LPVOID pv;
    int iRc;

    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, __LOCAL_SIZE;
        push    ebx;
        push    edi;
        push    esi;

    }

    /* Thunk all the parameters according to the signature */
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        pv = ppvArg[i];
        switch (pszSig[i]) {
        case 'p':
            pv = ppvArg[i] = MapLS(pv);
            __asm push pv;
            break;

        case 'l':
            __asm push pv;
            break;

        case 's':
            __asm mov eax, pv;
            __asm push ax;
            break;

        default: goto doneThunk;
        }
    }

doneThunk:;

    /* Call the 16:16 procedure */
    __asm {
        mov     edx, fp;
        mov     ebx, ebp;
        lea     ebp, rgbThunk+64;               /* Required by QT_Thunk */
    }
        g_kpa.QT_Thunk();
    __asm {
        mov     ebp, ebx;
        shl     eax, 16;                        /* Convert DX:AX to EAX */
        shrd    eax, edx, 16;
        mov     iRc, eax;
    }

    /* Now unthunk the parameters */
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        switch (pszSig[i]) {
        case 'p':
            UnMapLS(ppvArg[i]);
            break;

        case 'l':
        case 's':
            break;

        default: goto doneUnthunk;
        }
    }

doneUnthunk:;

    /* Thunk the return value */
    switch (pszSig[i]) {
    case 'L':
        break;

    case 'U':
        iRc = LOWORD(iRc);
        break;

    case 'S':
        iRc = (short)iRc;
        break;

    case 'P':
        iRc = (int)MapSL((LPVOID)iRc);
        break;
    }

    __asm {
        mov     eax, iRc;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}

#else               /* Fast but illegible */

__declspec(naked) int
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, 60;                /* QT_Thunk needs 60 bytes */
        push    ebx;
        push    edi;
        push    esi;

        /* Thunk all the parameters according to the signature */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
thunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Q: Pointer? */
        jz      thunkPtr;               /* Y: Do the pointer */
        cmp     al, 'l';                /* Q: Long? */
        jz      thunkLong;              /* Y: Do the long */
        cmp     al, 's';                /* Q: Short? */
        jnz     thunkDone;              /* N: Done */

                                        /* Y: Do the short */
        lodsd;                          /* eax = *ppvArg++ */
        push    ax;                     /* Push the short */
        jmp     thunkLoop;

thunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    dword ptr g_kpa.MapLS;  /* Map it */
        mov     [esi][-4], eax;         /* Save it for unmapping */
        push    eax;
        jmp     thunkLoop;

thunkLong:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        jmp     thunkLoop;
thunkDone:

        /* Call the 16:16 procedure */

        mov     edx, fp;
        call    dword ptr g_kpa.QT_Thunk;
        shl     eax, 16;                /* Convert DX:AX to EDX */
        shld    edx, eax, 16;

        /* Translate the return code according to the signature */

        mov     al, [ebx][-1];          /* Get return code type */
        cmp     al, 'P';                /* Pointer? */
        jz      retvalPtr;              /* Y: Do the pointer */
        cmp     al, 'S';                /* Signed? */
        jz      retvalSigned;           /* Y: Do the signed short */
        cmp     al, 'U';                /* Unsigned? */
        mov     edi, edx;               /* Assume long or void */
        jnz     retvalOk;               /* N: Then long or void */

        movzx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalPtr:
        push    edx;                    /* Pointer */
        call    dword ptr g_kpa.MapSL;  /* Map it up */
        jmp     retvalOk;

retvalSigned:                           /* Signed */
        movsx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalOk:                               /* Return value in EDI */

        /* Now unthunk the parameters */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
unthunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Pointer? */
        jz      unthunkPtr;             /* Y: Do the pointer */
        cmp     al, 'l';                /* Long? */
        jz      unthunkSkip;            /* Y: Skip it */
        cmp     al, 's';                /* Short? */
        jnz     unthunkDone;            /* N: Done */
unthunkSkip:
        lodsd;                          /* eax = *ppvArg++ */
        jmp     unthunkLoop;

unthunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    dword ptr g_kpa.UnMapLS;/* Unmap it */
        jmp     unthunkLoop;

unthunkDone:

        /* Done */

        mov     eax, edi;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}

#endif

#else // Not X86
int __cdecl TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    return 0;
}
#endif

#pragma BEGIN_CONST_DATA

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FARPROC | GetProcOrd |
 *
 *          GetProcAddress on a DLL by ordinal.
 *
 *          Win95 does not let you GetProcAddress on KERNEL32 by ordinal,
 *          so we need to do it the evil way.
 *
 *  @parm   HINSTANCE | hinstDll |
 *
 *          The instance handle of the DLL we want to get the ordinal
 *          from.  The only DLL you need to use this function for is
 *          KERNEL32.
 *
 *  @parm   UINT | ord |
 *
 *          The ordinal you want to retrieve.
 *
 ***************************************************************************/

#define poteExp(pinth) (&(pinth)->OptionalHeader. \
                          DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT])

FARPROC NTAPI
GetProcOrd(HINSTANCE hinstDll, UINT ord)
{
    FARPROC fp;

    /*
     *  Make sure the MZ header is good.
     */

    PIMAGE_DOS_HEADER pidh = (LPVOID)hinstDll;
    if (!IsBadReadPtr(pidh, sizeof(*pidh)) &&
        pidh->e_magic == IMAGE_DOS_SIGNATURE) {

        /*
         *  Make sure the PE header is good.
         */
        PIMAGE_NT_HEADERS pinth = pvAddPvCb(pidh, pidh->e_lfanew);
        if (!IsBadReadPtr(pinth, sizeof(*pinth)) &&
            pinth->Signature == IMAGE_NT_SIGNATURE) {

            /*
             *  Make sure the export table is good and the ordinal
             *  is within range.
             */
            PIMAGE_EXPORT_DIRECTORY pedt =
                              pvAddPvCb(pidh, poteExp(pinth)->VirtualAddress);
            if (!IsBadReadPtr(pedt, sizeof(*pedt)) &&
                (ord - pedt->Base) < pedt->NumberOfFunctions) {

                PDWORD peat = pvAddPvCb(pidh, (DWORD)pedt->AddressOfFunctions);
                fp = (FARPROC)pvAddPvCb(pidh, peat[ord - pedt->Base]);
                if ((DWORD)cbSubPvPv(fp, peat) >= poteExp(pinth)->Size) {
                    /* fp is valid */
                } else {                /* Note: We don't support forwarding */
                    fp = 0;
                }
            } else {
                fp = 0;
            }
        } else {
            fp = 0;
        }
    } else {
        fp = 0;
    }

    return fp;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GetKernelProcAddresses |
 *
 *          Get all the necessary proc addresses from Kernel.
 *
 ***************************************************************************/

BOOL EXTERNAL
Thunk_GetKernelProcAddresses(void)
{
    DllEnterCrit();

    if (g_kpa.QT_Thunk == 0) {
        HINSTANCE hinstK32 = GetModuleHandle(TEXT("KERNEL32"));

        if (hinstK32) {
            int i;
            FARPROC *rgfpKpa = (LPVOID)&g_kpa;

            for (i = 0; i < cA(c_rgpszKernel32); i++) {
                if (HIWORD((UINT_PTR)c_rgpszKernel32[i])) {
                    rgfpKpa[i] = GetProcAddress(hinstK32, c_rgpszKernel32[i]);
                } else {
                    rgfpKpa[i] = GetProcOrd(hinstK32, (UINT)(UINT_PTR)c_rgpszKernel32[i]);
                }
                if (!rgfpKpa[i]) break;     /* Aigh! */
            }
        }
    }

    DllLeaveCrit();

    return (BOOL)(UINT_PTR)g_kpa.QT_Thunk;

}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HINSTANCE | ThunkGetProcAddresses |
 *
 *          Get all the necessary proc addresses.
 *
 ***************************************************************************/

HINSTANCE EXTERNAL
Thunk_GetProcAddresses(FARPROC *rgfp, LPCSTR *rgpsz,
                       UINT cfp, LPCSTR pszLibrary)
{
    HINSTANCE hinst;

    hinst = g_kpa.LoadLibrary16(pszLibrary);
    if (hinst >= (HINSTANCE)32) {
        UINT ifp;
        for (ifp = 0; ifp < cfp; ifp++) {
            rgfp[ifp] = g_kpa.GetProcAddress16(hinst, rgpsz[ifp]);
            if (!rgfp[ifp]) {
                g_kpa.FreeLibrary16(hinst);
                hinst = 0;
                break;
            }
        }
    } else {
        hinst = 0;
    }

    return hinst;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\disubcls.c ===
/*****************************************************************************
 *
 *  DISubCls.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      "Safe subclassing" code, stolen from comctl32.
 *
 *      Originally written by francish.  Stolen by raymondc.
 *
 *  Contents:
 *
 *      SetWindowSubclass
 *      GetWindowSubclass
 *      RemoveWindowSubclass
 *      DefSubclassProc
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflSubclass

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  DirectInput Subclassing |
 *
 *
 * This module defines helper functions that make subclassing windows safe(er)
 * and easy(er).  The code maintains a single property on the subclassed window
 * and dispatches various "subclass callbacks" to its clients a required.  The
 * client is provided reference data and a simple "default processing" API.
 *
 * Semantics:
 *  A "subclass callback" is identified by a unique pairing of a callback
 * function pointer and an unsigned ID value.  Each callback can also store a
 * single DWORD of reference data, which is passed to the callback function
 * when it is called to filter messages.  No reference counting is performed
 * for the callback, it may repeatedly call the SetWindowSubclass API to alter
 * the value of its reference data element as desired.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_CALL |
 *
 *          Structure which tracks a single subclassing client.
 *
 *          Although a linked list would have made the code slightly
 *          simpler, this module uses a packed callback array to avoid
 *          unneccessary fragmentation.
 *
 *  @field  SUBCLASSPROC | pfnSubclass |
 *
 *          The subclass procedure.  If this is zero, it means that
 *          the node is dying and should be ignored.
 *
 *  @field  UINT | uIdSubclass |
 *
 *          Unique subclass identifier.
 *
 *  @field  DWORD | dwRefData |
 *
 *          Optional reference data for subclass procedure.
 *
 *****************************************************************************/

typedef struct SUBCLASS_CALL {
    SUBCLASSPROC    pfnSubclass;
    UINT_PTR        uIdSubclass;
    ULONG_PTR       dwRefData;
} SUBCLASS_CALL, *PSUBCLASS_CALL;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_FRAME |
 *
 *          Structure which tracks the state of an active call to the
 *          window's window procedure.
 *
 *          Each time the window procedure is entered, we create a new
 *          <t SUBCLASS_FRAME>, which remains active until the last
 *          subclass procedure returns, at which point the frame is
 *          torn down.
 *
 *          The subclass frames are stored on the stack.  So walking
 *          the frame chain causes you to wander through the stack.
 *
 *  @field  UINT | uCallIndex |
 *
 *          Index of next callback to call.
 *
 *  @field  UINT | uDeepestCall |
 *
 *          Deepest <e SUBCLASS_FRAME.uCallIndex> on the stack.
 *
 *  @field  SUBCLASS_FRAME * | pFramePrev |
 *
 *          The previous subclass frame.
 *
 *  @field  PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with this frame.
 *
 *****************************************************************************/

typedef struct SUBCLASS_FRAME {
    UINT uCallIndex;
    UINT uDeepestCall;
    struct SUBCLASS_FRAME *pFramePrev;
    struct SUBCLASS_HEADER *pHeader;
} SUBCLASS_FRAME, *PSUBCLASS_FRAME;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_HEADER |
 *
 *          Structure which tracks the subclass goo associated with
 *          a window.  A pointer to this structure is kept in a private
 *          window property.
 *
 *  @field  UINT | uRefs |
 *
 *          Subclass count.  This is the number of valid entries
 *          in the <p CallArray>.
 *
 *  @field  UINT | uAlloc |
 *
 *          Number of allocated <t SUBCLASS_CALL> nodes in the array.
 *
 *  @field  UINT | uCleanup |
 *
 *          Index of the call node to clean up.
 *
 *  @field  WORD | dwThreadId |
 *
 *          Thread id of the window with which the structure is associated.
 *
 *  @field  PSUBCLASS_FRAME | pFrameCur |
 *
 *          Pointer to the current subclass frame.
 *
 *  @field  SUBCLASS_CALL | CallArray[1] |
 *
 *          Base of the packed call node array.
 *
 *****************************************************************************/

typedef struct SUBCLASS_HEADER {
    UINT uRefs;
    UINT uAlloc;
    UINT uCleanup;
    DWORD dwThreadId;
    PSUBCLASS_FRAME pFrameCur;
    SUBCLASS_CALL CallArray[1];
} SUBCLASS_HEADER, *PSUBCLASS_HEADER;

#define CALLBACK_ALLOC_GRAIN (3)        /* 1 defproc, 1 subclass, 1 spare */

LRESULT CALLBACK
MasterSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp);


LRESULT INTERNAL
CallNextSubclassProc(PSUBCLASS_HEADER pHeader, HWND hwnd, UINT wm,
                     WPARAM wp, LPARAM lp);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | SubclassDeath |
 *
 *          This function is called if we ever enter one of our subclassing
 *          procedures without our reference data (and hence without the
 *          previous <t WNDPROC>).
 *
 *          Hitting this represents a catastrophic failure in the
 *          subclass code.
 *
 *          The function resets the <t WNDPROC> of the window to
 *          <f DefWindowProc> to avoid faulting.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window that just got hosed.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that caused us to realize that we are hosed.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/


LRESULT INTERNAL
SubclassDeath(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    /*
     * WE SHOULD NEVER EVER GET HERE
     */
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Fatal! SubclassDeath in window %p"),
                    hwnd);
    AssertF(0);

    /*
     * We call the outside world, so we'd better not have the critsec.
     */
    AssertF(!InCrit());

    /*
     * In theory, we could save the original WNDPROC in a separate property,
     * but that just wastes memory for something that should never happen.
     */
#ifdef WINNT
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)(DefWindowProc));
#else
    SubclassWindow(hwnd, DefWindowProc);
#endif

    return DefWindowProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   WNDPROC | GetWindowProc |
 *
 *          Returns the <t WNDPROC> of the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window to be inspected.
 *
 *  @returns
 *
 *          The <t WNDPROC> of the specified window.
 *
 *****************************************************************************/

WNDPROC INLINE
GetWindowProc(HWND hwnd)
{
#ifdef WINNT
    return (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
#else
    return (WNDPROC)GetWindowLong(hwnd, GWL_WNDPROC);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global ATOM | g_atmDISubclass |
 *
 *          This is the global <t ATOM> we use to store our
 *          <t SUBCLASS_HEADER> property on whatever windows come our way.
 *
 *          If the <p WIN95_HACK> symbol is defined, then we will work
 *          around a bug in Windows 95 where Windows "helpfully"
 *          <f GlobalDeleteAtom>'s all properties that are on a window
 *          when the window dies.  See Francis's original explanation
 *          in subclass.c.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszDISubclass[] = TEXT("DirectInputSubclassInfo");

#pragma END_CONST_DATA

#ifdef WIN95_HACK
ATOM g_atmDISubclass;
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | FastGetSubclassHeader |
 *
 *          Obtains the <t SUBCLASS_HEADER> for the specified window.
 *
 *          This function succeeds on any thread, although the value
 *          is meaningless from the wrong process.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @returns
 *
 *          Pointer to the <t SUBCLASS_HEADER> associated with the window,
 *          or <c NULL> if the window is not subclassed by us.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INLINE
FastGetSubclassHeader(HWND hwnd)
{
#ifdef WIN95_HACK
    /*
     *  The right thing happens if g_atmDISubclass is 0, namely,
     *  the property is not found.  Unfortunately, NT RIPs when
     *  you do this, so we'll be polite and not RIP.
     */
    if (g_atmDISubclass) {
        return (PSUBCLASS_HEADER)GetProp(hWnd, (PV)g_atmDISubclass);
    } else {
        return 0;
    }
#else
    return (PSUBCLASS_HEADER)GetProp(hwnd, c_tszDISubclass);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | GetSubclassHeader |
 *
 *          Obtains the <t SUBCLASS_HEADER> for the specified window.
 *          It fails if the caller is in the wrong process, but will
 *          allow the caller to get the header from a different thread.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @returns
 *
 *          Pointer to the <t SUBCLASS_HEADER> associated with the window,
 *          or <c NULL> if the window is not subclass by us yet, or 1 
 *          if it belongs to another process.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
GetSubclassHeader(HWND hwnd)
{
    DWORD idProcess;

    /*
     *  Make sure we're in the right process.
     *
     *  Must use our helper function to catch bad scenarios like
     *  the goofy Windows 95 console window which lies about its
     *  owner.
     */

    idProcess = GetWindowPid(hwnd);

    if (idProcess == GetCurrentProcessId()) {   /* In the right process */
        return FastGetSubclassHeader(hwnd);
    } else {
        if (idProcess) {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("XxxWindowSubclass: ")
                            TEXT("wrong process for window %p"), hwnd);
        }
        return (PSUBCLASS_HEADER)1;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | SetSubclassHeader |
 *
 *          Sets the <t SUBCLASS_HEADER> for the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The value to set.
 *
 *  @parm   PSUBCLASS_FRAME | pFrameFixup |
 *
 *          The active frames, which need to be walked and fixed up
 *          to refer to the new <t SUBCLASS_HEADER>.
 *
 *****************************************************************************/

BOOL INTERNAL
SetSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader,
                  PSUBCLASS_FRAME pFrameFixup)
{
    BOOL fRc;

    AssertF(InCrit());      /* We are partying on the header and frame list */

#ifdef WIN95_HACK
    if (g_atmDISubclass == 0) {
        ATOM atm;
        /*
         *  HACK: we are intentionally incrementing the refcount on this atom
         *  WE DO NOT WANT IT TO GO BACK DOWN so we will not delete it in
         *  process detach (see comments for g_atmDISubclass in subclass.c
         *  for more info).
         */
        atm = GlobalAddAtom(c_tszDISubclass);
        if (atm) {
            g_atmDISubclass = atm;  /* In case the old atom got nuked */
        }
    }
#endif

    /*
     *  Update the frame list if required.
     */
    while (pFrameFixup) {
        pFrameFixup->pHeader = pHeader;
        pFrameFixup = pFrameFixup->pFramePrev;
    }

    /*
     *  If we have a window to update, then update/remove the property
     *  as required.
     */
    if (hwnd) {
        if (!pHeader) {
#ifdef WIN95_HACK
            /*
             * HACK: we remove with an ATOM so the refcount won't drop
             *          (see comments for g_atmDISubclass above)
             */
            RemoveProp(hwnd, (PV)g_atmDISubclass);
#else
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("SetSubclassHeader: Removing %p"),
                            pHeader);
            RemoveProp(hwnd, c_tszDISubclass);
#endif
            fRc = 1;
        } else {
#ifdef WIN95_HACK
            /*
             * HACK: we add using a STRING so the refcount will go up
             *          (see comments for g_atmDISubclass above)
             */
#endif
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("SetSubclassHeader: Adding %p"),
                            pHeader);
            fRc = SetProp(hwnd, c_tszDISubclass, pHeader);
            if (!fRc) {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				SquirtSqflPtszV(sqfl | sqflError, TEXT("SetWindowSubclass: ")
                                TEXT("couldn't subclass window %p"), hwnd);
            }
        }
    } else {
        fRc = 1;                /* Weird vacuous success */
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | FreeSubclassHeader |
 *
 *          Toss the subclass header for the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The value being tossed.
 *
 *****************************************************************************/

void INTERNAL
FreeSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader)
{
    AssertF(InCrit());          /* we will be removing the subclass header */

    /*
     *  Sanity checking...
     */
    if (pHeader) {
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl, TEXT("FreeSubclassHeader: Freeing %p"),
                        pHeader);
        SetSubclassHeader(hwnd, 0, pHeader->pFrameCur); /* Clean up the header */
        LocalFree(pHeader);
    } else {
        AssertF(0);
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ReallocSubclassHeader |
 *
 *          Change the size of the subclass header as indicated.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The current header.
 *
 *  @parm   UINT | uCallbacks |
 *
 *          Desired size.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
ReAllocSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader, UINT uCallbacks)
{
    UINT uAlloc;

    AssertF(InCrit());      /* we will be replacing the subclass header */

    /*
     *  Granularize the allocation.
     */
    uAlloc = CALLBACK_ALLOC_GRAIN *
        ((uCallbacks + CALLBACK_ALLOC_GRAIN - 1) / CALLBACK_ALLOC_GRAIN);

    /*
     *  Do we need to change the allocation?
     */
    if (!pHeader || (uAlloc != pHeader->uAlloc)) {
        /*
         * compute bytes required
         */
        uCallbacks = uAlloc * sizeof(SUBCLASS_CALL) + sizeof(SUBCLASS_HEADER);

        /*
         * And try to alloc / realloc.
         */
        if (SUCCEEDED(ReallocCbPpv(uCallbacks, &pHeader))) {
            /*
             * Update info.
             */
            pHeader->uAlloc = uAlloc;

            if (SetSubclassHeader(hwnd, pHeader, pHeader->pFrameCur)) {
            } else {
                FreeSubclassHeader(hwnd, pHeader);
                pHeader = 0;
            }
        } else {
            pHeader = 0;
        }
    }

    AssertF(pHeader);
    return pHeader;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CallOriginalWndProc |
 *
 *          This procedure is the default <t SUBCLASSPROC> which is always
 *          installed when we subclass a window.  The original window
 *          procedure is installed as the reference data for this
 *          callback.  It simply calls the original <t WNDPROC> and
 *          returns its result.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that needs to go to the original <t WNDPROC>.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          ID number (not used).
 *
 *  @parm   DWORD | dwRefData |
 *
 *          Reference data for subclass procedure (original <t WNDPROC>).
 *
 *****************************************************************************/

LRESULT CALLBACK
CallOriginalWndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                    UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    /*
     * dwRefData should be the original window procedure
     */
    AssertF(dwRefData);

    /*
     * and call it.
     */
    return CallWindowProc((WNDPROC)dwRefData, hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | AttachSubclassHeader |
 *
 *          This procedure makes sure that a given window is subclassed by us.
 *          It maintains a reference count on the data structures associated
 *          with our subclass.  if the window is not yet subclassed by us
 *          then this procedure installs our subclass procedure and
 *          associated data structures.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
AttachSubclassHeader(HWND hwnd)
{
    PSUBCLASS_HEADER pHeader;

    /*
     *  We party on the subclass call chain here
     */
    AssertF(InCrit());

    /*
     *  Yes, we subclass the window out of context, but we are careful
     *  to avoid race conditions.  There is still a problem if some
     *  other DLL tries to un-subclass a window just as we are subclassing
     *  it.  But there's nothing you can do about it, and besides,
     *  what are the odds...?
     */

    /*
     * If haven't already subclassed the window then do it now
     */
    pHeader = GetSubclassHeader(hwnd);

    if( pHeader == (PSUBCLASS_HEADER)1 )
    {
        /*
         *  It's all gone horribly wrong
         * This can happen when the application uses joyXXX functions in Winmm.dll.
         */
        pHeader = 0;
    }
    else if (pHeader == 0) {
        /*
         * attach our header data to the window
         * we need space for two callbacks:
         * the subclass and the original proc
         */
        pHeader = ReAllocSubclassHeader(hwnd, 0, 2);
        if (pHeader) {
            SUBCLASS_CALL *pCall;

            /*
             *  Set up the first node in the array to call
             *  the original WNDPROC.  Do this before subclassing
             *  to avoid a race if the window receives a message
             *  after we have installed our subclass but before
             *  we can save the original WNDPROC.
             */
            AssertF(pHeader->uAlloc);

            pCall = pHeader->CallArray;
            pCall->pfnSubclass = CallOriginalWndProc;
            pCall->uIdSubclass = 0;
            pCall->dwRefData   = (ULONG_PTR)GetWindowProc(hwnd);

            /*
             * init our subclass refcount...
             */
            pHeader->uRefs = 1;

            pHeader->dwThreadId = GetWindowThreadProcessId(hwnd, NULL);

            /*
             *  Super-paranoid.  We must must not race with another
             *  instance of ourselves trying to un-subclass.
             */
            AssertF(InCrit());

            /*
             *  Save the new "old" wndproc in case we raced with
             *  somebody else trying to subclass.
             */
#ifdef WINNT
            pCall->dwRefData = (ULONG_PTR)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)MasterSubclassProc);
#else
            pCall->dwRefData = (DWORD)SubclassWindow(hwnd, MasterSubclassProc);
#endif
            if (pCall->dwRefData) {
                DllLoadLibrary();   /* Make sure we don't get unloaded */
            } else {                /* clean up and get out */
                FreeSubclassHeader(hwnd, pHeader);
                pHeader = 0;
            }
        }
    }

    return pHeader;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DetachSubclassHeader |
 *
 *          This procedure attempts to detach the subclass header from
 *          the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Header to detach.
 *
 *  @parm   BOOL | fForce |
 *
 *          Nonzero if we should detach even if we are not the top-level
 *          subclass.
 *
 *****************************************************************************/

void INTERNAL
DetachSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader, BOOL fForce)
{
    WNDPROC wndprocOld;

    AssertF(InCrit());      /* we party on the subclass call chain here */
    AssertF(pHeader);       /* fear */

    /*
     *  If we are not being forced to remove and the window is still
     *  valid then sniff around a little and decide if it's a good
     *  idea to detach now.
     */
    if (!fForce && hwnd) {
        AssertF(pHeader == FastGetSubclassHeader(hwnd)); /* paranoia */

        /* should always have the "call original" node */
        AssertF(pHeader->uRefs);

        /*
         *  We can't have active clients.
         *  We can't have people still on our stack.
         */
        if (pHeader->uRefs <= 1 && !pHeader->pFrameCur) {

            /*
             *  We must be in the correct context.
             */
            if (pHeader->dwThreadId == GetCurrentThreadId()) {

                /*
                 *  We kept the original window procedure as refdata for our
                 *  CallOriginalWndProc subclass callback.
                 */
                wndprocOld = (WNDPROC)pHeader->CallArray[0].dwRefData;
                AssertF(wndprocOld);

                /*
                 *  Make sure we are the top of the subclass chain.
                 */
                if (GetWindowProc(hwnd) == MasterSubclassProc) {

                    /*
                     * go ahead and try to detach
                     */
#ifdef WINNT
                    if (SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)wndprocOld)) {
#else
                    if (SubclassWindow(hwnd, wndprocOld)) {
#endif
                        SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                                        TEXT("Unhooked"));
                    } else {
                        AssertF(0);         /* just plain shouldn't happen */
                        goto failed;
                    }
                } else {            /* Not at top of chain; can't do it */
                    SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                                    TEXT("Somebody else subclassed"));
                    goto failed;
                }
            } else {                /* Out of context. Try again later. */
                SendNotifyMessage(hwnd, WM_NULL, 0, 0L);
                goto failed;
            }
        } else {
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                            TEXT("Still %d users, %p frame"),
                            pHeader->uRefs, pHeader->pFrameCur);
            goto failed;
        }
    }

#if 0
#ifdef DEBUG
    {
    /*
     * warn about anybody who hasn't unhooked yet
     */
    UINT uCur;    
    SUBCLASS_CALL *pCall;
    
    uCur = pHeader->uRefs;
    pCall = pHeader->CallArray + uCur;
    /* don't complain about our 'call original' node */
    while (--uCur) {
        pCall--;
        if (pCall->pfnSubclass) {
            /*
             * always warn about these they could be leaks
             */
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl | sqflError, TEXT("warning: orphan subclass: ")
                            TEXT("fn %p, id %08x, dw %08x"),
                            pCall->pfnSubclass, pCall->uIdSubclass,
                            pCall->dwRefData);
        }
    }
    }
#endif
#endif
    /*
     * free the header now
     */
    FreeSubclassHeader(hwnd, pHeader);

    DllFreeLibrary();               /* Undo LoadLibrary when we hooked */


failed:;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | PurgeSingleCallNode |
 *
 *          Purges a single dead node in the call array.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with the window.
 *          The <p uCleanup> field is the index of the node being
 *          cleaned up.
 *
 *****************************************************************************/

void INTERNAL
PurgeSingleCallNode(HWND hwnd, PSUBCLASS_HEADER pHeader)
{

    AssertF(InCrit());      /* we will try to re-arrange the call array */

    if (pHeader->uCleanup) {/* Sanity check */
        UINT uRemain;

        SquirtSqflPtszV(sqfl,
                TEXT("PurgeSingleCallNode: Purging number %d"),
                pHeader->uCleanup);

        /*
         * and a little paranoia
         */
        AssertF(pHeader->CallArray[pHeader->uCleanup].pfnSubclass == 0);

        AssertF(fLimpFF(pHeader->pFrameCur,
                        pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall));

        /*
         * are there any call nodes above the one we're about to remove?
         */
        uRemain = pHeader->uRefs - pHeader->uCleanup;
        if (uRemain > 0) {
            /*
             * yup, need to fix up the array the hard way
             */
            SUBCLASS_CALL *pCall;
            SUBCLASS_FRAME *pFrame;
            UINT uCur, uMax;

            /*
             * move the remaining nodes down into the empty space
             */
            pCall = pHeader->CallArray + pHeader->uCleanup;
            /*
             *  Since the souce and destination overlap (unless there's only 
             *  one node remaining) the behavior of memcpy is undefined.
             *  memmove (aka MoveMemory) would guarantee the correct 
             *  behavior but requires the runtime library.
             *  Since this is the only function we require in retail from the 
             *  RTL, it is not worth the 22% bloat we gain from using the 
             *  static version and using the dynamic version is a load time 
             *  and redist test hit.  So copy the array one element at a time.
             */
            for( uCur = 0; uCur < uRemain; uCur++ )
            {
                memcpy( &pCall[uCur], &pCall[uCur+1], sizeof(*pCall) );
            }

            /*
             * update the call indices of any active frames
             */
            uCur = pHeader->uCleanup;
            pFrame = pHeader->pFrameCur;
            while (pFrame) {
                if (pFrame->uCallIndex >= uCur) {
                    pFrame->uCallIndex--;

                    if (pFrame->uDeepestCall >= uCur) {
                        pFrame->uDeepestCall--;
                    }
                }

                pFrame = pFrame->pFramePrev;
            }

            /*
             * now search for any other dead call nodes in the remaining area
             */
            uMax = pHeader->uRefs - 1;  /* we haven't decremented uRefs yet */
            while (uCur < uMax && pCall->pfnSubclass)  {
                pCall++;
                uCur++;
            }
            pHeader->uCleanup = (uCur < uMax) ? uCur : 0;
        } else {
            /*
             * No call nodes above.  This case is easy.
             */
            pHeader->uCleanup = 0;
        }

        /*
         * finally, decrement the client count
         */
        pHeader->uRefs--;
        SquirtSqflPtszV(sqfl, TEXT("warning: PurgeSingleCallNode: ")
                        TEXT("Still %d refs"), pHeader->uRefs);

    } else {
        AssertF(0);         /* Nothing to do! */
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CompactSubclassHeader |
 *
 *          Attempts to compact the subclass array, freeing the
 *          subclass header if the array is empty.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with the window.
 *
 *****************************************************************************/

void INTERNAL
CompactSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader)
{
    AssertF(InCrit());      /* we will try to re-arrange the call array */

    /*
     * we must handle the "window destroyed unexpectedly during callback" case
     */
    if (hwnd) {
        /*
         *  Clean out as many dead callbacks as possible.
         *
         *  The "DeepestCall" test is an optimization so we don't go
         *  purging call nodes when no active frame cares.
         *
         *  (I'm not entirely conviced of this.  I mean, we have to
         *  purge it eventually anyway, right?)
         */
        while (pHeader->uCleanup &&
               fLimpFF(pHeader->pFrameCur,
                       pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall)) {
            PurgeSingleCallNode(hwnd, pHeader);
        }

        /*
         * do we still have clients?
         */
        if (pHeader->uRefs > 1) {
            SquirtSqflPtszV(sqfl, TEXT("CompactSubclassHeader: ")
                            TEXT("Still %d users"), pHeader->uRefs);
            /*
             * yes, shrink our allocation, leaving room for at least one client
             */
            ReAllocSubclassHeader(hwnd, pHeader, pHeader->uRefs + 1);
            goto done;
        }
    }

    /*
     *  There are no clients left, or the window is gone.
     *  Try to detach and free
     */
    DetachSubclassHeader(hwnd, pHeader, FALSE);

done:;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_CALL | FindCallRecord |
 *
 *          Searches for a call record with the specified subclass proc
 *          and id, and returns its address.  If no such call record is
 *          found then NULL is returned.
 *
 *          This is a helper function used when we need to track down
 *          a callback because the client is changing its refdata or
 *          removing it.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header in which to search.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to locate.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *****************************************************************************/

SUBCLASS_CALL * INTERNAL
FindCallRecord(PSUBCLASS_HEADER pHeader, SUBCLASSPROC pfnSubclass,
               UINT_PTR uIdSubclass)
{
    SUBCLASS_CALL *pCall;
    UINT uCallIndex;

    AssertF(InCrit());      /* we'll be scanning the call array */

    /*
     * scan the call array.  note that we assume there is always at least
     * one member in the table (our CallOriginalWndProc record)
     */
    uCallIndex = pHeader->uRefs;
    pCall = &pHeader->CallArray[uCallIndex];
    do {
        uCallIndex--;
        pCall--;
        if ((pCall->pfnSubclass == pfnSubclass) &&
            (pCall->uIdSubclass == uIdSubclass))
        {
            return pCall;
        }
    } while (uCallIndex != (UINT)-1);

    return NULL;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GetWindowSubclass |
 *
 *          Retrieves the reference data for the specified window
 *          subclass callback.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to locate.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *  @parm   LPDWORD | pdwRefData |
 *
 *          Output pointer.
 *
 *****************************************************************************/

BOOL EXTERNAL
GetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
                  PULONG_PTR pdwRefData)
{
    BOOL fRc;
    ULONG_PTR dwRefData;

    DllEnterCrit();

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        PSUBCLASS_HEADER pHeader;
        SUBCLASS_CALL *pCall;

        /*
         * if we've subclassed it and they are a client then get the refdata
         */
        pHeader = GetSubclassHeader(hwnd);
        if (pHeader &&
            (pHeader != (PSUBCLASS_HEADER)1) && 
            (pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) != 0) {
            /*
             * fetch the refdata and note success
             */
            fRc = 1;
            dwRefData = pCall->dwRefData;
        } else {
            fRc = 0;
            dwRefData = 0;
        }

    } else {                            /* Invalid window handle */
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl | sqflError, TEXT("GetWindowSubclass: ")
                        TEXT("Bad window %p or callback %p"),
                        hwnd, pfnSubclass);
        fRc = 0;
        dwRefData = 0;
    }

    /*
     * we always fill in/zero pdwRefData regradless of result
     */
    if (pdwRefData) {
        *pdwRefData = dwRefData;
    }

    DllLeaveCrit();

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | SetWindowSubclass |
 *
 *          Installs/updates a window subclass callback.  Subclass
 *          callbacks are identified by their callback address and id pair.
 *          If the specified callback/id pair is not yet installed then
 *          the procedure installs the pair.  If the callback/id pair is
 *          already installed, then this procedure changes the reference
 *          data for the pair.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to install or modify.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *  @parm   DWORD | dwRefData |
 *
 *          Reference data to associate with the callback/id.
 *
 *****************************************************************************/

BOOL EXTERNAL
SetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
                  ULONG_PTR dwRefData)
{
    BOOL fRc;

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        SUBCLASS_HEADER *pHeader;

        /*
         * we party on the subclass call chain here
         */
        DllEnterCrit();

        /*
         * actually subclass the window
         */
        /*
         *  Prefix gets confused (mb:34501) by this.  I assume this is because 
         *  AttachSubclassHeader returns a pointer to allocated memory but we 
         *  allow the pointer to go out of context without saving it.  This is 
         *  OK because AttachSubclassHeader already saved it for us.
         */
        pHeader = AttachSubclassHeader(hwnd);
        if (pHeader) {
            SUBCLASS_CALL *pCall;

            /*
             * find a call node for this caller
             */
            pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass);
            if (pCall == NULL) {
                /*
                 * not found, alloc a new one
                 */
                SUBCLASS_HEADER *pHeaderT =
                    ReAllocSubclassHeader(hwnd, pHeader, pHeader->uRefs + 1);

                if (pHeaderT) {
                    pHeader = pHeaderT;
                    pCall = &pHeader->CallArray[pHeader->uRefs++];
                } else {
                    /*
                     * re-query in case it is already gone
                     */
                    pHeader = FastGetSubclassHeader(hwnd);
                    if (pHeader) {
                        CompactSubclassHeader(hwnd, pHeader);
                    }
                    goto bail;
                }

            }

            /*
             * fill in the subclass call data
             */
            pCall->pfnSubclass = pfnSubclass;
            pCall->uIdSubclass = uIdSubclass;
            pCall->dwRefData   = dwRefData;

            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl,
                    TEXT("SetWindowSubclass: Added %p/%d as %d"),
                    pfnSubclass, uIdSubclass, pHeader->uRefs - 1);

            fRc = 1;

        } else {                        /* Unable to subclass */
        bail:;
            fRc = 0;
        }
        DllLeaveCrit();
    } else {
        fRc = 0;                        /* Invalid parameter */
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | RemoveWindowSubclass |
 *
 *          Removes a subclass callback from a window.
 *          Subclass callbacks are identified by their
 *          callback address and id pair.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to remove.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *****************************************************************************/

BOOL EXTERNAL
RemoveWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass)
{
    BOOL fRc;

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        SUBCLASS_HEADER *pHeader;

        /*
         * we party on the subclass call chain here
         */
        DllEnterCrit();

        /*
         * obtain our subclass data and find the callback to remove.
         */
        pHeader = GetSubclassHeader(hwnd);
        if (pHeader && (pHeader != (PSUBCLASS_HEADER)1) ) {
            SUBCLASS_CALL *pCall;

            /*
             * find the callback to remove
             */
            pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass);

            if (pCall) {
                UINT uCall;

                /*
                 *  disable this node.
                 */
                pCall->pfnSubclass = 0;

                /*
                 *  Remember that we have something to clean up.
                 *
                 *  Set uCleanup to the index of the shallowest node that
                 *  needs to be cleaned up.  CompactSubclassHeader will
                 *  clean up everything from uCleanup onward.
                 */

                uCall = (UINT)(pCall - pHeader->CallArray);
                if (fLimpFF(pHeader->uCleanup, uCall < pHeader->uCleanup)) {
                    pHeader->uCleanup = uCall;
                }

                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				SquirtSqflPtszV(sqfl,
                        TEXT("RemoveWindowSubclass: Removing %p/%d as %d"),
                        pfnSubclass, uIdSubclass, uCall);

                /*
                 * now try to clean up any unused nodes
                 */
                CompactSubclassHeader(hwnd, pHeader);

                /*
                 * the call above can realloc or free the subclass
                 * header for this window, so make sure we don't use it.
                 */
                D(pHeader = 0);

                fRc = 1;

            } else {                /* Not found */
                fRc = 0;
            }
        } else {                    /* Never subclassed (ergo not found) */
            fRc = 0;
        }

        /*
         * release the critical section and return the result
         */
        DllLeaveCrit();
    } else {
        fRc = 0;                    /* Validation failed */
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | DefSubclassProc |
 *
 *          Calls the next handler in the window's subclass chain.
 *          The last handler in the subclass chain is installed by us,
 *          and calls the original window procedure for the window.
 *
 *          Every subclass procedure should call <f DefSubclassProc>
 *          in order to allow the message to be processed by other handlers.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that needs to go to the original <t WNDPROC>.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT EXTERNAL
DefSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    LRESULT lResult;

    /*
     * make sure the window is still valid
     */
    if (IsWindow(hwnd)) {
        PSUBCLASS_HEADER pHeader;

        /*
         * take the critical section while we figure out who to call next
         */
        AssertF(!InCrit());
        DllEnterCrit();

        /*
         * complain if we are being called improperly
         */
        pHeader = FastGetSubclassHeader(hwnd);
        if (pHeader &&
            pHeader->pFrameCur &&
            GetCurrentThreadId() == pHeader->dwThreadId) {

            /*
             * call the next proc in the subclass chain
             *
             * WARNING: this call temporarily releases the critical section
             * WARNING: pHeader is invalid when this call returns
             */
            lResult = CallNextSubclassProc(pHeader, hwnd, wm, wp, lp);
            D(pHeader = 0);

        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("DefSubclassProc: Called improperly"));
            lResult = 0;
        }
        DllLeaveCrit();

    } else {
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("DefSubclassProc: %P not a window"),
                        hwnd);
        lResult = 0;
    }

    return lResult;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | UpdateDeepestCall |
 *
 *          Updates the deepest call index for the specified frame.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame in question.
 *
 *****************************************************************************/

void INTERNAL
UpdateDeepestCall(SUBCLASS_FRAME *pFrame)
{
    AssertF(InCrit());  /* we are partying on the frame list */

    /*
     *  My deepest call equals my current call or my parent's
     *  deepest call, whichever is deeper.
     */
    if (pFrame->pFramePrev &&
        (pFrame->pFramePrev->uDeepestCall < pFrame->uCallIndex)) {
        pFrame->uDeepestCall = pFrame->pFramePrev->uDeepestCall;
    } else {
        pFrame->uDeepestCall = pFrame->uCallIndex;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | EnterSubclassFrame |
 *
 *          Sets up a new subclass frame for the specified header,
 *          saving away the previous one.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Header in question.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Brand new frame to link in.
 *
 *****************************************************************************/

void INLINE
EnterSubclassFrame(PSUBCLASS_HEADER pHeader, SUBCLASS_FRAME *pFrame)
{
    AssertF(InCrit());  /* we are partying on the header and frame list */

    /*
     * fill in the frame and link it into the header
     */
    pFrame->uCallIndex   = pHeader->uRefs + 1;
    pFrame->pFramePrev   = pHeader->pFrameCur;
    pFrame->pHeader      = pHeader;
    pHeader->pFrameCur   = pFrame;

    /*
     * initialize the deepest call index for this frame
     */
    UpdateDeepestCall(pFrame);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | LeaveSubclassFrame |
 *
 *          Tear down the current subclass frame, restoring the previous one.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame going away.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INLINE
LeaveSubclassFrame(SUBCLASS_FRAME *pFrame)
{
    PSUBCLASS_HEADER pHeader;

    AssertF(InCrit());  /* we are partying on the header */

    /*
     * unlink the frame from its header (if it still exists)
     */
    pHeader = pFrame->pHeader;
    if (pHeader) {
        pHeader->pFrameCur = pFrame->pFramePrev;
    }

    return pHeader;
}

#ifdef SUBCLASS_HANDLEEXCEPTIONS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | SubclassFrameException |
 *
 *          Clean up when a exception is thrown from a subclass frame.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to clean up.
 *
 *****************************************************************************/

void INTERNAL
SubclassFrameException(SUBCLASS_FRAME *pFrame)
{
    /*
     * clean up the current subclass frame
     */
    AssertF(!InCrit());
    DllEnterCrit();

    SquirtSqflPtszV(sqfl | sqflError, TEXT("SubclassFrameException: ")
                    TEXT("cleaning up subclass frame after exception"));
    LeaveSubclassFrame(pFrame);
    DllLeaveCrit();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | MasterSubclassProc |
 *
 *          The window procedure we install to dispatch subclass
 *          callbacks.
 *
 *          It maintains a linked list of "frames" through the stack
 *          which allow <f DefSubclassProc> to call the right subclass
 *          procedure in multiple-message scenarios.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window under attack.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT CALLBACK
MasterSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult;

    /*
     * prevent people from partying on the callback chain while we look at it
     */
    AssertF(!InCrit());
    DllEnterCrit();

    /*
     * We'd better have our data.
     */
    pHeader = FastGetSubclassHeader(hwnd);
    if (pHeader) {
        SUBCLASS_FRAME Frame;

        /*
         * set up a new subclass frame and save away the previous one
         */
        EnterSubclassFrame(pHeader, &Frame);

#ifdef SUBCLASS_HANDLEEXCEPTIONS
        __try    /* protect our state information from exceptions */
#endif
        {
            /*
             * go ahead and call the subclass chain on this frame
             *
             * WARNING: this call temporarily releases the critical section
             * WARNING: pHeader is invalid when this call returns
             */
            lResult =
                CallNextSubclassProc(pHeader, hwnd, wm, wp, lp);
            D(pHeader = 0);
        }
#ifdef SUBCLASS_HANDLEEXCEPTIONS
        __except (SubclassFrameException(&Frame), EXCEPTION_CONTINUE_SEARCH)
        {
            AssertF(0);
        }
#endif

        AssertF(InCrit());

        /*
         * restore the previous subclass frame
         */
        pHeader = LeaveSubclassFrame(&Frame);

        /*
         *  Do postprocessing if the header is still here.
         */
        if (pHeader) {

            /*
             *  was the window nuked (somehow)
             *  without us seeing the WM_NCDESTROY?
             */
            if (!IsWindow(hwnd)) {
                /*
                 * EVIL! somebody subclassed after us and didn't pass on WM_NCDESTROY
                 */
                AssertF(!TEXT("unknown subclass proc swallowed a WM_NCDESTROY"));

                /* go ahead and clean up now */
                hwnd = 0;
                wm = WM_NCDESTROY;
            }

            /*
             * if we are returning from a WM_NCDESTROY then we need to clean up
             */
            if (wm == WM_NCDESTROY) {
                DetachSubclassHeader(hwnd, pHeader, TRUE);
            } else {

                /*
                 * is there any pending cleanup, or are all our clients gone?
                 */
                if (pHeader->uCleanup ||
                    (!pHeader->pFrameCur && (pHeader->uRefs <= 1))) {
                    CompactSubclassHeader(hwnd, pHeader);
                    D(pHeader = 0);
                }
            }

            /*
             * all done
             */

        } else {
            /*
             *  Header is gone.  We already cleaned up in a nested frame.
             */
        }
        DllLeaveCrit();
        AssertF(!InCrit());

    } else {                            /* Our property vanished! */
        DllLeaveCrit();
        lResult = SubclassDeath(hwnd, wm, wp, lp);
    }

    return lResult;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | EnterSubclassCallback |
 *
 *          Finds the next callback in the subclass chain and updates
 *          <p pFrame> to indicate that we are calling it.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Controlling header.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to update.
 *
 *  @parm   SUBCLASS_CALL * | pCallChosen |
 *
 *          The call selected for calling.
 *
 *****************************************************************************/

UINT INTERNAL
EnterSubclassCallback(PSUBCLASS_HEADER pHeader, SUBCLASS_FRAME *pFrame,
                      SUBCLASS_CALL *pCallChosen)
{
    SUBCLASS_CALL *pCall;
    UINT uDepth;

    /*
     * we will be scanning the subclass chain and updating frame data
     */
    AssertF(InCrit());

    /*
     * scan the subclass chain for the next callable subclass callback
     * Assert that the loop will terminate.
     */
    AssertF(pHeader->CallArray[0].pfnSubclass);
    pCall = pHeader->CallArray + pFrame->uCallIndex;
    uDepth = 0;
    do {
        uDepth++;
        pCall--;

    } while (!pCall->pfnSubclass);

    /*
     * copy the callback information for the caller
     */
    pCallChosen->pfnSubclass = pCall->pfnSubclass;
    pCallChosen->uIdSubclass = pCall->uIdSubclass;
    pCallChosen->dwRefData   = pCall->dwRefData;

    /*
     * adjust the frame's call index by the depth we entered
     */
    pFrame->uCallIndex -= uDepth;

    /*
     * keep the deepest call index up to date
     */
    UpdateDeepestCall(pFrame);

    return uDepth;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | LeaveSubclassCallback |
 *
 *          Get out one level.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to update.
 *
 *  @parm   UINT | uDepth |
 *
 *          Who just finished.
 *
 *****************************************************************************/

void INLINE
LeaveSubclassCallback(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    /*
     * we will be updating subclass frame data
     */
     AssertF(InCrit());

    /*
     * adjust the frame's call index by the depth we entered and return
     */
    pFrame->uCallIndex += uDepth;

    /*
     * keep the deepest call index up to date
     */
    UpdateDeepestCall(pFrame);
}

#ifdef SUBCLASS_HANDLEEXCEPTIONS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | SubclassCallbackException |
 *
 *          Clean up when a subclass callback throws an exception.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to clean up.
 *
 *  @parm   UINT | uDepth |
 *
 *          Where we were.
 *
 *****************************************************************************/

void INTERNAL
SubclassCallbackException(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    /*
     * clean up the current subclass callback
     */
    AssertF(!InCrit());
    DllEnterCrit();
    SquirtSqflPtszV(sqfl | sqflError, TEXT("SubclassCallbackException: ")
                    TEXT("cleaning up subclass callback after exception"));
    LeaveSubclassCallback(pFrame, uDepth);
    DllLeaveCrit();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CallNextSubclassProc |
 *
 *          Calls the next subclass callback in the subclass chain.
 *
 *          WARNING: this call temporarily releases the critical section.
 *
 *          WARNING: <p pHeader> is invalid when this call returns.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header that is tracking the state.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window under attack.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT INTERNAL
CallNextSubclassProc(PSUBCLASS_HEADER pHeader, HWND hwnd, UINT wm,
                     WPARAM wp, LPARAM lp)
{
    SUBCLASS_CALL Call;
    SUBCLASS_FRAME *pFrame;
    LRESULT lResult;
    UINT uDepth;

    AssertF(InCrit());  /* sanity */
    AssertF(pHeader);   /* paranoia */

    /*
     * get the current subclass frame
     */
    pFrame = pHeader->pFrameCur;
    AssertF(pFrame);

    /*
     * get the next subclass call we need to make
     */
    uDepth = EnterSubclassCallback(pHeader, pFrame, &Call);

    /*
     * leave the critical section so we don't deadlock in our callback
     *
     * WARNING: pHeader is invalid when this call returns
     */
    DllLeaveCrit();
    D(pHeader = 0);

    /*
     * we call the outside world so prepare to deadlock if we have the critsec
     */
    AssertF(!InCrit());

#ifdef SUBCLASS_HANDLEEXCEPTIONS
    __try    /* protect our state information from exceptions */
#endif
    {
        /*
         * call the chosen subclass proc
         */
        AssertF(Call.pfnSubclass);

        lResult = Call.pfnSubclass(hwnd, wm, wp, lp,
                                   Call.uIdSubclass, Call.dwRefData);
    }
#ifdef SUBCLASS_HANDLEEXCEPTIONS
    __except (SubclassCallbackException(pFrame, uDepth),
        EXCEPTION_CONTINUE_SEARCH)
    {
        AssertF(0);
    }
#endif

    /*
     * we left the critical section before calling out so re-enter it
     */
    AssertF(!InCrit());
    DllEnterCrit();

    /*
     * finally, clean up and return
     */
    LeaveSubclassCallback(pFrame, uDepth);
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diwinnt.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DIWdm.h
 *  Content:    DirectInput internal include file for Winnt
 *
 ***************************************************************************/
#ifndef DIWdm_H
#define DIWdm_H

#define JOY_BOGUSID    ( cJoyMax + 1 )
#define REGSTR_SZREGKEY     (TEXT("DINPUT.DLL"))

HRESULT EXTERNAL
DIWdm_SetJoyId
(
    IN PCGUID   guid,
    IN int      idJoy
);

PHIDDEVICEINFO EXTERNAL
phdiFindJoyId
(
    IN  int idJoy
);

HRESULT INTERNAL
DIWdm_SetLegacyConfig
(
    IN  int idJoy
);

BOOL EXTERNAL
DIWdm_InitJoyId( void );

DWORD EXTERNAL
DIWinnt_RegDeleteKey
(
    IN HKEY hStartKey ,
    IN LPCTSTR pKeyName
);

HRESULT EXTERNAL
DIWdm_SetConfig
(
    UINT idJoy,
    LPJOYREGHWCONFIG jwc,
    LPCDIJOYCONFIG pcfg,
    DWORD fl
);

HRESULT EXTERNAL
DIWdm_DeleteConfig
(
    int idJoy
);


HRESULT EXTERNAL
DIWdm_JoyHidMapping
(
    IN  int             idJoy,
    OUT PVXDINITPARMS   pvip,   OPTIONAL
    OUT LPDIJOYCONFIG   pcfg,   OPTIONAL
    OUT LPDIJOYTYPEINFO pdijti  OPTIONAL
);

LPTSTR EXTERNAL
JoyReg_JoyIdToDeviceInterface
(
    IN  UINT            idJoy,
    OUT PVXDINITPARMS   pvip,
    OUT LPTSTR          ptszBuf
);

#endif // DIWdm_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\guids.c ===
/*****************************************************************************
 *
 *  guids.c
 *
 *  Copyright (c) 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *****************************************************************************/

#define INITGUID
#include <dinputpr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diutil.c ===
/*****************************************************************************
 *
 *  DIUtil.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc helper functions.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflUtil

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LPCTSTR | _ParseHex |
 *
 *          Parse a hex string encoding cb bytes (at most 4), then expect 
 *          the tchDelim to appear afterwards.  If tchDelim is 0, then no 
 *          delimiter is expected.
 *
 *          Store the result into the indicated LPBYTE (using only the
 *          size requested), updating it, and return a pointer to the
 *          next unparsed character, or 0 on error.
 *
 *          If the incoming pointer is also 0, then return 0 immediately.
 *          
 *  @parm   IN LPCTSTR | ptsz |
 *
 *          The string to parse.  
 *
 *  @parm   IN OUT LPBYTE * | ppb |
 *
 *          Pointer to the address of the destination buffer.
 *
 *  @parm   IN int | cb |
 *
 *          The size in bytes of the buffer.
 *
 *  @parm   IN TCHAR | tchDelim |
 *
 *          The delimiter charater to end the sequence or zero if none is 
 *          expected.
 *
 *  @returns
 *
 *          Returns a pointer to the next unparsed character, or 0 on error.
 *
 *  @comm
 *          Stolen from TweakUI.
 *
 *          Prefix takes a strong dislike to this function, reporting that 
 *          all callers could use uninitialized memory when the function 
 *          succeeds.
 *          The problem appears to be that Prefix is unable to determine that 
 *          if the source string can successfully be read, the destination is 
 *          always completely filled (the whole passed destination size) with 
 *          the binary value of the source string.  Since all callers always 
 *          pass the size of the variable to which the destination buffer 
 *          pointer points, the memory is always completely initialized but 
 *          it seems reasonable that Prefix would raise a warning. 
 *
 *****************************************************************************/

LPCTSTR INTERNAL
    _ParseHex(LPCTSTR ptsz, LPBYTE *ppb, int cb, TCHAR tchDelim)
{
    if(ptsz)
    {
        int i = cb * 2;
        DWORD dwParse = 0;

        do
        {
            DWORD uch;
            uch = (TBYTE)*ptsz - TEXT('0');
            if(uch < 10)
            {             /* a decimal digit */
            } else
            {
                uch = (*ptsz | 0x20) - TEXT('a');
                if(uch < 6)
                {          /* a hex digit */
                    uch += 10;
                } else
                {
                    return 0;           /* Parse error */
                }
            }
            dwParse = (dwParse << 4) + uch;
            ptsz++;
        } while(--i);

        if(tchDelim && *ptsz++ != tchDelim) return 0; /* Parse error */

        for(i = 0; i < cb; i++)
        {
            (*ppb)[i] = ((LPBYTE)&dwParse)[i];
        }
        *ppb += cb;
    }
    return ptsz;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | ParseGUID |
 *
 *          Take a string and convert it into a GUID, return success/failure.
 *
 *  @parm   OUT LPGUID | lpGUID |
 *
 *          Receives the parsed GUID on success.
 *
 *  @parm   IN LPCTSTR | ptsz |
 *
 *          The string to parse.  The format is
 *
 *      { <lt>dword<gt> - <lt>word<gt> - <lt>word<gt>
 *                      - <lt>byte<gt> <lt>byte<gt>
 *                      - <lt>byte<gt> <lt>byte<gt> <lt>byte<gt>
 *                        <lt>byte<gt> <lt>byte<gt> <lt>byte<gt> }
 *
 *  @returns
 *
 *          Returns zero if <p ptszGUID> is not a valid GUID.
 *
 *
 *  @comm
 *
 *          Stolen from TweakUI.
 *
 *****************************************************************************/

BOOL EXTERNAL
    ParseGUID(LPGUID pguid, LPCTSTR ptsz)
{
    if(lstrlen(ptsz) == ctchGuid - 1 && *ptsz == TEXT('{'))
    {
        ptsz++;
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 4, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('}'));
        return (BOOL)(UINT_PTR)ptsz;
    } else
    {
        return 0;
    }
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | ParseVIDPID |
 *
 *          Take a string formatted as VID_%04&PID_%04.
 *
 *  @parm   OUT PUSHORT | puVID |
 *
 *          Receives the parsed VID.
 *
 *  @parm   OUT PUSHORT | puPID |
 *
 *          Receives the parsed PID.
 *
 *  @parm   IN LPCTSTR | ptsz |
 *
 *
 *  @returns
 *
 *          Returns zero on failure.
 *
 *
 *  @comm
 *
 *          Stolen from TweakUI.
 *
 *****************************************************************************/

//                    VID _ XXXX  &  PID  _ YYYY
#define ctchVIDPID  ( 3 + 1 + 4 + 1 + 3 + 1 + 4 )

#define VID_        TEXT("VID_")
#define VID_offset  (3+1)
#define PID_        TEXT("&PID_")
#define PID_offset  (3+1+4+1+3+1)

BOOL EXTERNAL
    ParseVIDPID(PUSHORT puVID, PUSHORT puPID , LPCWSTR pwsz)
{
    LPCTSTR ptsz;
#ifndef UNICODE
    TCHAR    tsz[MAX_JOYSTRING];
    UToT( tsz, cA(tsz), pwsz );
    ptsz = tsz;
#else
   ptsz = pwsz;
#endif

    if( _ParseHex(ptsz+VID_offset, (LPBYTE *)&puVID, 2, TEXT('&'))  &&
        _ParseHex(ptsz+PID_offset, (LPBYTE *)&puPID, 2, 0) )
        {
            return TRUE;
        }
   return FALSE;
}

#endif



#if DIRECTINPUT_VERSION > 0x0300

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | NameFromGUID |
 *
 *          Convert a GUID into an ASCII string that will be used
 *          to name it in the global namespace.
 *
 *          We use the name "DirectInput.{guid}".
 *
 *          Names are used in the following places:
 *
 *          <c g_hmtxGlobal> names a mutex based on
 *          <c IID_IDirectInputW> to gate access to the
 *          shared memory block used to manage exclusive access.
 *
 *          <c g_psop> names a shared memory block based on
 *          <c IID_IDirectInputDeviceW> to record information
 *          about exclusive access.
 *
 *          <c g_hmtxJoy> names a mutex based on
 *          <c IID_IDirectInputDevice2A> to gate access to the
 *          shared memory block used to track joystick effects.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          Output buffer to receive the converted name.  It must
 *          be <c ctchNameGuid> characters in size.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to convert.
 *
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

/* Note: If you change this string, you need to change ctchNameGuid to match */
TCHAR c_tszNameFormat[] =
    TEXT("DirectInput.{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

    #pragma END_CONST_DATA


void EXTERNAL
    NameFromGUID(LPTSTR ptszBuf, PCGUID pguid)
{
    int ctch;

    ctch = wsprintf(ptszBuf, c_tszNameFormat,
                    pguid->Data1, pguid->Data2, pguid->Data3,
                    pguid->Data4[0], pguid->Data4[1],
                    pguid->Data4[2], pguid->Data4[3],
                    pguid->Data4[4], pguid->Data4[5],
                    pguid->Data4[6], pguid->Data4[7]);

    AssertF(ctch == ctchNameGuid - 1);
}


#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | pvFindResource |
 *
 *          Handy wrapper that finds and loads a resource.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   DWORD | id |
 *
 *          Resource identifier.
 *
 *  @parm   LPCTSTR | rt |
 *
 *          Resource type.
 *
 *  @returns
 *
 *          Pointer to resource, or 0.
 *
 *****************************************************************************/

PV EXTERNAL
    pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt)
{
    HANDLE hrsrc;
    PV pv;

    hrsrc = FindResource(hinst, (LPTSTR)(LONG_PTR)id, rt);
    if(hrsrc)
    {
        pv = LoadResource(hinst, hrsrc);
    } else
    {
        pv = 0;
    }
    return pv;
}

#ifndef UNICODE

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | LoadStringW |
 *
 *          Implementation of LoadStringW for platforms on which Unicode is
 *          not supported.  Does exactly what LoadStringW would've done
 *          if it existed.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   UINT | ids |
 *
 *          String id number.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   UINT | cwch |
 *
 *          Size of UNICODE output buffer.
 *
 *  @returns
 *
 *          Number of characters copied, not including terminating null.
 *
 *  @comm
 *
 *          Since the string is stored in the resource as UNICODE,
 *          we just pull it out ourselves.  If we go through
 *          <f LoadStringA>, we may end up losing characters due
 *          to character set translation.
 *
 *****************************************************************************/

int EXTERNAL
    LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch)
{
    PWCHAR pwch;

    AssertF(cwch);
    ScrambleBuf(pwsz, cbCwch(cwch));

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    pwch = pvFindResource(hinst, 1 + ids / 16, RT_STRING);
    if(pwch)
    {
        /*
         *  Now skip over the strings in the resource until we
         *  hit the one we want.  Each entry is a counted string,
         *  just like Pascal.
         */
        for(ids %= 16; ids; ids--)
        {
            pwch += *pwch + 1;
        }
        cwch = min(*pwch, cwch - 1);
        memcpy(pwsz, pwch+1, cbCwch(cwch)); /* Copy the goo */
    } else
    {
        cwch = 0;
    }
    pwsz[cwch] = TEXT('\0');            /* Terminate the string */
    return cwch;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GetNthString |
 *
 *          Generate a generic numbered object name.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          Output buffer of <c MAX_PATH> characters.
 *
 *  @parm   UINT | ids |
 *
 *          String containing number template.
 *
 *  @parm   UINT | ui |
 *
 *          Button number.
 *
 *****************************************************************************/

void EXTERNAL
    GetNthString(LPWSTR pwsz, UINT ids, UINT ui)
{
    TCHAR tsz[256];
#ifndef UNICODE
    TCHAR tszOut[MAX_PATH];
#endif

    LoadString(g_hinst, ids, tsz, cA(tsz));
#ifdef UNICODE
    wsprintfW(pwsz, tsz, ui);
#else
    wsprintf(tszOut, tsz, ui);
    TToU(pwsz, MAX_PATH, tszOut);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRunControlPanel |
 *
 *          Run the control panel with the specified applet.
 *
 *  @parm   LPCTSTR | ptszApplet |
 *
 *          Applet name.
 *
 *  @returns
 *
 *          <c S_OK> if we started the applet.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszControlExeS[] = TEXT("control.exe %s");

#pragma END_CONST_DATA

HRESULT EXTERNAL
    hresRunControlPanel(LPCTSTR ptszCpl)
{
    HRESULT hres;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR tsz[MAX_PATH];
    EnterProc(hresRunControlPanel, (_ "s", ptszCpl));

    ZeroX(si);
    si.cb = cbX(si);
    wsprintf(tsz, c_tszControlExeS, ptszCpl);
    if(CreateProcess(0, tsz, 0, 0, 0, 0, 0, 0, &si, &pi))
    {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        hres = S_OK;
    } else
    {
        hres = hresLe(GetLastError());
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DeviceInfoWToA |
 *
;begin_dx3
 *          Convert a <t DIDEVICEINSTANCEW> to a <t DIDEVICEINSTANCEA>.
;end_dx3
;begin_dx5
 *          Convert a <t DIDEVICEINSTANCEW> to a <t DIDEVICEINSTANCE_DX3A>
 *          or a <t DIDEVICEINSTANCE_DX5A>.
;end_dx5
 *
 *  @parm   LPDIDIDEVICEINSTANCEA | pdiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIDIDEVICEINSTANCEW | pdiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    DeviceInfoWToA(LPDIDEVICEINSTANCEA pdiA, LPCDIDEVICEINSTANCEW pdiW)
{
    EnterProc(DeviceInfoWToA, (_ "pp", pdiA, pdiW));

    AssertF(pdiW->dwSize == sizeof(DIDEVICEINSTANCEW));

#if DIRECTINPUT_VERSION <= 0x0400
    pdiA->dwSize = sizeof(*pdiA);
#else
    AssertF(IsValidSizeDIDEVICEINSTANCEA(pdiA->dwSize));
#endif

    pdiA->guidInstance = pdiW->guidInstance;
    pdiA->guidProduct  = pdiW->guidProduct;
    pdiA->dwDevType    = pdiW->dwDevType;

    UToA(pdiA->tszInstanceName, cA(pdiA->tszInstanceName), pdiW->tszInstanceName);
    UToA(pdiA->tszProductName, cA(pdiA->tszProductName), pdiW->tszProductName);

#if DIRECTINPUT_VERSION > 0x0400
    if(pdiA->dwSize >= cbX(DIDEVICEINSTANCE_DX5A))
    {
        pdiA->guidFFDriver       = pdiW->guidFFDriver;
        pdiA->wUsage             = pdiW->wUsage;
        pdiA->wUsagePage         = pdiW->wUsagePage;
    }
#endif

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ObjectInfoWToA |
 *
#ifdef HAVE_DIDEVICEOBJECTINSTANCE_DX5
 *          Convert a <t DIDEVICEOBJECTINSTANCEW>
 *          to a <t DIDEVICEOBJECTINSTANCE_DX3A>
 *          or a <t DIDEVICEOBJECTINSTANCE_DX5A>.
#else
 *          Convert a <t DIDEVICEOBJECTINSTANCEW>
 *          to a <t DIDEVICEOBJECTINSTANCEA>.
#endif
 *
 *  @parm   LPDIDIDEVICEOBJECTINSTANCEA | pdoiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIDIDEVICEOBJECTINSTANCEW | pdoiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    ObjectInfoWToA(LPDIDEVICEOBJECTINSTANCEA pdoiA,
                   LPCDIDEVICEOBJECTINSTANCEW pdoiW)
{
    EnterProc(ObjectInfoWToA, (_ "pp", pdoiA, pdoiW));

    AssertF(pdoiW->dwSize == sizeof(DIDEVICEOBJECTINSTANCEW));

#ifdef HAVE_DIDEVICEOBJECTINSTANCE_DX5
    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEA(pdoiA->dwSize));
#else
    pdoiA->dwSize    = sizeof(*pdoiA);
#endif
    pdoiA->guidType  = pdoiW->guidType;
    pdoiA->dwOfs     = pdoiW->dwOfs;
    pdoiA->dwType    = pdoiW->dwType;
    pdoiA->dwFlags   = pdoiW->dwFlags;

    UToA(pdoiA->tszName, cA(pdoiA->tszName), pdoiW->tszName);
#ifdef HAVE_DIDEVICEOBJECTINSTANCE_DX5
    if(pdoiA->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5A))
    {
        pdoiA->dwFFMaxForce        = pdoiW->dwFFMaxForce;
        pdoiA->dwFFForceResolution = pdoiW->dwFFForceResolution;
        pdoiA->wCollectionNumber   = pdoiW->wCollectionNumber;
        pdoiA->wDesignatorIndex    = pdoiW->wDesignatorIndex;
        pdoiA->wUsagePage          = pdoiW->wUsagePage;
        pdoiA->wUsage              = pdoiW->wUsage;
        pdoiA->dwDimension         = pdoiW->dwDimension;
        pdoiA->wExponent           = pdoiW->wExponent;
        pdoiA->wReportId           = pdoiW->wReportId;
    }
#endif
    ExitProc();
}

#ifdef IDirectInputDevice2Vtbl
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | EffectInfoWToA |
 *
 *          Convert a <t DIEFFECTINFOW> to a <t DIEFFECTINFOA>
 *
 *  @parm   LPDIEFFECTINFOA | pdeiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIEFFECTINFOW | pdeiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    EffectInfoWToA(LPDIEFFECTINFOA pdeiA, LPCDIEFFECTINFOW pdeiW)
{
    EnterProc(EffectInfoWToA, (_ "pp", pdeiA, pdeiW));

    AssertF(pdeiW->dwSize == sizeof(DIEFFECTINFOW));

    AssertF(pdeiA->dwSize == cbX(*pdeiA));
    pdeiA->guid            = pdeiW->guid;
    pdeiA->dwEffType       = pdeiW->dwEffType;
    pdeiA->dwStaticParams  = pdeiW->dwStaticParams;
    pdeiA->dwDynamicParams = pdeiW->dwDynamicParams;

    UToA(pdeiA->tszName, cA(pdeiA->tszName), pdeiW->tszName);
    ExitProc();
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidInstanceVer |
 *
 *          Check the <t HINSTANCE> and version number received from
 *          an application.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          Purported module instance handle.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version the application is asking for.
 *
 *****************************************************************************/
HRESULT EXTERNAL
    hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc)
{
    HRESULT hres;
    TCHAR tszScratch[4];

    EnterProcS(hresValidInstanceVer, (_ "xxs", hinst, dwVersion, s_szProc));


    /*
     *  You would think that passing a zero-sized buffer to
     *  GetModuleFileName would return the necessary buffer size.
     *
     *  You would be right.  Except that the Win95 validation layer
     *  doesn't realize that this was a valid scenario, so the call
     *  fails in the validation layer and never reached Kernel.
     *
     *  So we read it into a small scratch buffer.  The scratch buffer
     *  must be at least 2 characters; if we passed only 1, then
     *  GetModuleFileName won't be able to write any characters and
     *  will return 0.
     *
     *  Now it turns out that there's a bug in NT where, if you
     *  pass a buffer size of 4, but the actual name is longer than
     *  4, it writes 4 characters, PLUS A NULL TERMINATOR, thereby
     *  smashing your stack and making you fault randomly.
     *
     *  I spent two hours trying to figure that out.
     *
     *  Therefore, you must pass one *less* than the buffer size
     *  to GetModuleFileName, because it will overwrite your buffer
     *  by one.
     */

    /*
     *  For compatibility reasons, DirectInput 3.0 clients must be
     *  allowed to pass hinst == 0.  (It was a loophole in the original
     *  DX3 implementation.)
     */

    if(hinst == 0 ?
       dwVersion == 0x0300 :
       GetModuleFileName(hinst, tszScratch, cA(tszScratch) - 1))
    {

        /*
         *  We need to permit the following DirectX versions:
         *
         *  0x0300 - DX3 golden
         *  0x0500 - DX5 golden
         *  0x050A - DX5a Win98 golden
         *  0x05B2 - NT 5 beta 2 (also the CPL and WinMM)
         *  0x0602 - Win98 OSR1 internal first version
         *  0x061A - DX6.1a Win98 OSR1
         *  0x0700 - DX7 Win2000 golden
         */
        if(dwVersion == 0x0300 ||
           dwVersion == 0x0500 ||
           dwVersion == 0x050A ||
           dwVersion == 0x05B2 ||
           dwVersion == 0x0602 ||
           dwVersion == 0x061A ||
           dwVersion == 0x0700
          )
        {
            hres = S_OK;
        } else if ( dwVersion == 0 ) {
            RPF("%s: DinputInput object has not been initialized, or the version is given as 0.",
                s_szProc);
            hres = DIERR_NOTINITIALIZED;
        } else if(dwVersion < DIRECTINPUT_VERSION)
        {
            RPF("%s: Incorrect dwVersion(0x%x); program was written with beta SDK. This version 0x%x",
                s_szProc, dwVersion, DIRECTINPUT_VERSION);
            hres = DIERR_BETADIRECTINPUTVERSION;
        } else
        {
            RPF("%s: Incorrect dwVersion(0x%x); program needs newer version of dinput. This version 0x%x",
                s_szProc, dwVersion, DIRECTINPUT_VERSION);
            hres = DIERR_OLDDIRECTINPUTVERSION;
        }

    } else
    {
        RPF("%s: Invalid HINSTANCE", s_szProc);
        hres = E_INVALIDARG;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DupEventHandle |
 *
 *          Duplicate an event handle intra-process-ly.  If the incoming
 *          handle is NULL, then so is the output handle (and the call
 *          succeeds).
 *
 *  @parm   HANDLE | h |
 *
 *          Source handle.
 *
 *  @parm   LPHANDLE | phOut |
 *
 *          Receives output handle.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DupEventHandle(HANDLE h, LPHANDLE phOut)
{
    HRESULT hres;
    EnterProc(DupEventHandle, (_ "p", h));

    if(h)
    {
        HANDLE hProcessMe = GetCurrentProcess();
        if(DuplicateHandle(hProcessMe, h, hProcessMe, phOut,
                           EVENT_MODIFY_STATE, 0, 0))
        {
            hres = S_OK;
        } else
        {
            hres = hresLe(GetLastError());
        }
    } else
    {
        *phOut = h;
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | GetWindowPid |
 *
 *          Simple wrapper that returns the PID of a window.
 *
 *          Here is also where we do goofy hacks for DOS boxes
 *          on Win95.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle.
 *
 *  @returns
 *
 *          PID or 0.
 *
 *****************************************************************************/

DWORD EXTERNAL
    GetWindowPid(HWND hwnd)
{
    DWORD pid;

    if(IsWindow(hwnd) &&
       GetWindowThreadProcessId(hwnd, &pid) )
    {
        if( !fWinnt )
           /*
            *  The Winoldap console window belongs to another
            *  process but Win95 lies and says that it belongs
            *  to you but it doesn't.
            */
            if ( GetProp(hwnd, TEXT("flWinOldAp")) != 0 )
                pid = 0;
    } else
    {
        pid = 0;
    }

    return pid;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresDupPtszPptsz |
 *
 *          OLEish version of strdup.
 *
 *  @parm   LPCTSTR | ptszSrc |
 *
 *          Source string being duplicated.
 *
 *  @parm   LPTSTR * | pptszDst |
 *
 *          Receives the duplicated string.
 *
 *  @returns
 *
 *          <c S_OK> or an error code.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCtch(lstrlen(ptszSrc) + 1), pptszDst);

    if(SUCCEEDED(hres))
    {
        lstrcpy(*pptszDst, ptszSrc);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | fInitializeCriticalSection |
 *
 *          Initialize the give critical section, returning 0 if an exception
 *          is thrown, else 0.
 *
 *  @parm   LPCRITICAL_SECTION | pCritSec |
 *
 *          Pointer to an uninitialized critical section.
 *
 *****************************************************************************/

BOOL EXTERNAL
    fInitializeCriticalSection(LPCRITICAL_SECTION pCritSec)
{
    BOOL fres = 1;
    EnterProc(fInitializeCriticalSection, (_ "" ));

    AssertF( pCritSec );
    __try
    {
        InitializeCriticalSection( pCritSec );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        fres = 0;
    }

    ExitProcF( fres );
    return fres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DiCharUpperW |
 *
 *          This function converts a wide-character string or a single wide-character
 *          to uppercase. Since Win9x doesn't implement CharUpperW, we have to implement
 *          ourselves.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          The string to be converted
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void EXTERNAL
    DiCharUpperW(LPWSTR pwsz)
{
    int idx;
    int iLen = lstrlenW(pwsz);

    #define DIFF  (L'a' - L'A')

    for( idx=0; idx<iLen; idx++ )
    {
        if( (pwsz[idx] >= L'a') && (pwsz[idx] <= L'z') ){
            pwsz[idx] -= DIFF;
        }
    }

    #undef DIFF
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | DIGetOSVersion |
 *
 *          Return the OS version on which DInput8.dll is running.
 *          
 *  @returns
 *
 *          WIN95_OS, WIN98_OS, WINME_OS, WINNT_OS, WINWH_OS, or WIN_UNKNOWN_OS.
 *
 *****************************************************************************/

DWORD DIGetOSVersion()
{
    OSVERSIONINFO osVerInfo;
    DWORD dwVer;

    if( GetVersion() < 0x80000000 ) {
        dwVer = WINNT_OS;
    } else {
        dwVer = WIN95_OS;  //assume Windows 95 for safe
    }

    osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    // If GetVersionEx is supported, then get more details.
    if( GetVersionEx( &osVerInfo ) )
    {
        // Win2K
        if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // Whistler: Major = 5 & Build # > 2195
            if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
            {
                dwVer = WINWH_OS;
            } else {
                dwVer = WINNT_OS;
            }
        }
        // Win9X
        else
        {
            if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) ) 
            {
                // WinMe: Major = 4, Minor = 90
                if( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
                {
                    dwVer = WINME_OS;
                } else if ( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) > 0) ) {
                    dwVer = WIN98_OS;
                } else {
                    dwVer = WIN95_OS;
                }
            }
        }
    }

    return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\diwinnt.c ===
/*****************************************************************************
 *
 *  DIWdm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      WINNT specific functions.
 *
 *  Contents:
 *
 *      hResIdJoyInstanceGUID
 *      DIWdm_SetLegacyConfig
 *      DIWdm_InitJoyId
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflWDM

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIWdm_SetJoyId |
 *          Given a guid for a HID device and a Joystick ID.
 *          This function will swap the old joystick ID for the device
 *          specified by the guid ( pcguid ) for the new ID specified in
 *          idJoy
 *
 *  @parm   IN UINT | idJoy |
 *
 *          The Joyid the the HID device specified  by pcguid should have.
 *
 *  @parm   OUT LPGUID | pcguid |
 *
 *          GUID that specifies a HID device.
 *
 *  @returns
 *          HRESULT
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIWdm_SetJoyId
    (
    IN PCGUID   pcguid,
    IN int      idJoy
    )
{
    PHIDDEVICEINFO  phdi;
    HRESULT         hres;
    BOOL            fConfigChanged = FALSE;

    EnterProcI(DIWdm_SetJoyId, (_"Gu", pcguid, idJoy));


    //PostDx7 patch:
    // No point setting the joystick entries in the registry
    // if the ID of the joystick is -1.
    if( idJoy == -1 )
    {
        return E_FAIL;
    }

    DllEnterCrit();
    hres = S_OK;


    /* Get pointer to HIDDEVICEINFO from the GUID */
    phdi = phdiFindHIDInstanceGUID(pcguid);

    if(phdi != NULL )
    {
        PHIDDEVICEINFO  phdiSwap;
        GUID            guidInstanceOld;
        LONG            lRc;
        int             idJoySwap;

        /* Swap the ID's */
        idJoySwap = phdi->idJoy;
        phdi->idJoy = idJoy;

        phdiSwap = NULL;
        /* Get the GUID for the old ID */
        if( SUCCEEDED( hres = hResIdJoypInstanceGUID_WDM(idJoySwap, &guidInstanceOld)) )
        {
            /* Get pointer to HIDDEVICEINFO for old ID */
            phdiSwap  = phdiFindHIDInstanceGUID(&guidInstanceOld);
            if( phdiSwap )
            {
                phdiSwap->idJoy = idJoySwap;
            } else
            {
                // Old device disappeared !
            }

        } else
        {
            DIJOYCONFIG c_djcReset = {
                cbX(c_djcReset),                   /* dwSize               */
                { 0},                              /* guidInstance         */
                { 0},                              /* hwc                  */
                DI_FFNOMINALMAX,                   /* dwGain               */
                { 0},                              /* wszType              */
                { 0},                              /* wszCallout           */
            };

            hres = JoyReg_SetConfig(idJoySwap, &c_djcReset.hwc,&c_djcReset, DIJC_SETVALID) ;
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: JoyReg_SetConfig to NULL FAILED  "),
                                s_szProc );
            }
        }

        /* Set the new ID and LegacyConfig */
        if( phdi )
        {
            if( lRc = RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoy, cbX(idJoy)) == ERROR_SUCCESS )
            {
                /*
                 * This extra RegSetValueEx on "Joystick Id" is to keep the 
                 * compatibility with Win2k Gold. 
                 * See Windows bug 395416 for detail.
                 */
                RegSetValueEx(phdi->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                        (PV)&idJoy, cbX(idJoy));

                if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoy)) )
                {
                    fConfigChanged = TRUE;
                }
            }
        }

        /* Set old ID and legacy Config */
        if( (phdiSwap != NULL) && (phdiSwap != phdi) )
        {
            if( lRc = RegSetValueEx(phdiSwap->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoySwap, cbX(idJoySwap)) == ERROR_SUCCESS )
            {
                /*
                 * This extra RegSetValueEx on "Joystick Id" is to keep the 
                 * compatibility with Win2k Gold. 
                 * See Windows bug 395416 for detail.
                 */
                RegSetValueEx(phdiSwap->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                        (PV)&idJoySwap, cbX(idJoySwap));
                
                if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoySwap) ) )
                {
                    fConfigChanged = TRUE;
                }
            }
        } else if( phdiSwap == NULL )
        {
            // Old Device disappeared !
            if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoySwap) ) )
            {
                fConfigChanged = TRUE;
            }
        }
    } else
    {
        hres = E_FAIL;
        RPF("ERROR %s: invalid guid.", s_szProc);
    }

  #ifndef WINNT
    if( SUCCEEDED(hres) )
    {
        /*
         * Make sure the new Ids do not cause any collisions
         */
        DIWdm_InitJoyId();
    }
  #endif

    if( fConfigChanged ) {
      #ifdef WINNT
        Excl_SetConfigChangedTime( GetTickCount() );
        PostMessage(HWND_BROADCAST, g_wmJoyChanged, 0, 0L);   
      #else
        joyConfigChanged(0);
      #endif
    }

    DllLeaveCrit();

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | hResIdJoyInstanceGUID_WDM |
 *
 *          Maps a HID JoyStick ID to a DeviceInstance GUID
 *
 *          The parameters have already been validated.
 *
 *
 *  @parm   IN UINT | idJoy |
 *
 *          The Joyid of the HID device to be located.
 *
 *  @parm   OUT LPGUID | lpguid |
 *
 *          The Device Instance GUID corresponding to the JoystickID
 *          If a mapping is not found GUID_NULL is passed back in lpguid
 *
 *  @returns
 *          HRESULT
 *
 *****************************************************************************/
HRESULT EXTERNAL hResIdJoypInstanceGUID_WDM
    (
    IN  UINT idJoy,
    OUT LPGUID lpguid
    )
{
    HRESULT hres = S_FALSE;
    EnterProc( hResIdJoypInstanceGUID_WDM, ( _ "ux", idJoy, lpguid) );

    /* Zap the guid for failure case */
    ZeroBuf(lpguid, cbX(*lpguid) );

    if( idJoy > cJoyMax )
    {
        hres = DIERR_NOMOREITEMS;
    } else
    {
        DllEnterCrit();

        /* Build the HID list if it is too old */
        DIHid_BuildHidList(FALSE);

        /* Make sure there is some HID device */
        if(g_phdl)
        {
            int ihdi;
            PHIDDEVICEINFO  phdi;

            /* Search over all HID devices */
            for(ihdi = 0, phdi = g_phdl->rghdi;
               ihdi < g_phdl->chdi;
               ihdi++, phdi++)
            {
                /* Check for matching ID */
                if(idJoy == (UINT)phdi->idJoy)
                {
                    hres = S_OK;
                    /* Copy the GUID */
                    *lpguid = phdi->guid;
                    break;
                }
            }
        }
        DllLeaveCrit();
    }

    ExitBenignOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindJoyId |
 *
 *          Locates information given a joystick ID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Id of the joystick to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindJoyId(int idJoy )
{
    PHIDDEVICEINFO phdi;

    EnterProcI(phdiFindJoyId, (_"u", idJoy));

    /* We should have atleast one HID device */
    if(g_phdl)
    {
        int ihdi;

        /* Loop over all HID devices */
        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            /* Match */
            if(idJoy == phdi->idJoy)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    ExitProcX((UINT_PTR)phdi);
    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIWdm_SetLegacyConfig |
 *
 *          Sets up the registry keys so that a joystick HID device
 *          can be "seen" by legacy APIs and the Control Panel.
 *          Primarily, this routine sets up the structs that are passed
 *          to JoyReg_SetConfig routine.
 *
 *  @parm   IN int  | idJoy |
 *
 *          Joystick ID.
 *
 *  @returns HRESULT
 *
 *****************************************************************************/
//ISSUE-2001/03/29-timgill Fix unicode madness
HRESULT INTERNAL DIWdm_SetLegacyConfig
    (
    IN  int idJoy
    )
{
    HRESULT hres;
    DIJOYCONFIG         cfg;
    BOOL                fNeedType;
    BOOL                fNeedConfig;
    BOOL                fNeedNone;
    HKEY                hk;
    DIJOYTYPEINFO       dijti;
    PHIDDEVICEINFO      phdi;
    WCHAR               wszType[cA(VID_PID_TEMPLATE)];
#ifndef UNICODE
    char szType[cbX(VID_PID_TEMPLATE)];
#endif

    EnterProcI(DIWdm_SetLegacyConfig, (_ "u", idJoy));

    ZeroX(dijti);
    dijti.dwSize = cbX(dijti);

    if( idJoy == -1 )
    {
        // Dx7Gold Patch:
        // ID == -1 implies this device is not joystick.
        // Do not write any entries to the registry
        return E_FAIL;
    }

    fNeedType = fNeedConfig = TRUE;
    fNeedNone = FALSE;


    /*
     *  1. Find out what the WinMM registry data is saying now
     */
    CAssertF( JOY_HW_NONE == 0 );
    hres = JoyReg_OpenConfigKey(idJoy, KEY_QUERY_VALUE, NULL, 0x0, &hk);
    if( SUCCEEDED(hres) )
    {
        /* Get the type name from the registry */
        JoyReg_GetConfigValue(
                             hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                             &cfg.wszType, cbX(cfg.wszType) );
        hres = JoyReg_GetConfigValue(
                                    hk, REGSTR_VAL_JOYNCONFIG, idJoy, REG_BINARY,
                                    &cfg.hwc, cbX(cfg.hwc) );
        RegCloseKey(hk);
    } else
    {
        cfg.wszType[0] = '\0';
    }
    if( FAILED( hres ) )
    {
        cfg.hwc.dwType = JOY_HW_NONE;
    }

    /*
     *  2. If the config info is in sync with WDM then don't rewrite
     */
    phdi = phdiFindJoyId(idJoy);
    if( phdi )
    {
        /*
         *  The type key for HID devices is "VID_xxxx&PID_yyyy",
         *  mirroring the format used by plug and play.
         */

        if( ( LOWORD(phdi->guidProduct.Data1) == MSFT_SYSTEM_VID )
            &&( ( HIWORD(phdi->guidProduct.Data1) >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
                &&( HIWORD(phdi->guidProduct.Data1) < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
        {
            /* Predefined type definitions don't go into the registry */
            fNeedType = FALSE;

            /*
             *  Predefined types are determined by the dwType value so fix
             *  only it if that is wrong.
             */
            if( cfg.hwc.dwType + MSFT_SYSTEM_PID == HIWORD(phdi->guidProduct.Data1) )
            {
                fNeedConfig = FALSE;
            } else
            {
                /*
                 *  Get type info so that JOY_HWS_* flags start with correct values.
                 */
                wszType[0] = L'#';
                wszType[1] = L'0' + HIWORD(phdi->guidProduct.Data1) - MSFT_SYSTEM_PID;
                wszType[2] = L'\0';
                JoyReg_GetPredefTypeInfo(wszType, &dijti, DITC_INREGISTRY | DITC_DISPLAYNAME);
            }
        } else
        {
            /*
             * This should work, but it doesn't in Win98.
             *
             *   ctch = wsprintfW(wszType, L"VID_%04X&PID_%04X",
             *                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
             */

#ifdef UNICODE
            wsprintfW(wszType, VID_PID_TEMPLATE,
                      LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
            CharUpperW(wszType);
#else
            wsprintf(szType, VID_PID_TEMPLATE,
                     LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
            CharUpper( szType );
            AToU( wszType, cA(wszType), szType );
#endif
        }
    } else
    {
        /*
         *  There is no WDM device so flag for deletion if the WinMM data is wrong
         */
        if( ( cfg.hwc.dwType != JOY_HW_NONE ) || ( cfg.wszType[0] != L'\0' ) )
        {
            fNeedNone = TRUE;
            fNeedType = fNeedConfig = FALSE;
        }
    }


    if( fNeedType ) /* Not already decided against (predefined type) */
    {
        /* Does the registry have the correct device ? */

        /*
         * lstrcmpW doesn't work in Win9x, bad. We have to use our own DiChauUpperW,
         * then memcmp. Also, the wsprintf template has to use 'X' not 'x'.
         */

        DiCharUpperW(cfg.wszType);
        if( (memcmp(cfg.wszType, wszType, cbX(wszType)) == 0x0)
            && (cfg.hwc.dwType >= JOY_HW_PREDEFMAX) )
        {
            fNeedConfig = FALSE;
        }

        /* Check the type key */
        hres = JoyReg_GetTypeInfo(wszType, &dijti, DITC_INREGISTRY);
        if( SUCCEEDED(hres) )
        {
            fNeedType = FALSE;
        }
    }

    /*
     *  No failures up to thDIWdm_SetJoyIdis point should be returned
     */
    hres = S_OK;


    /*
     *  3. If something is missing, find the data from WDM and set it straight
     */
    if( fNeedType || fNeedConfig )
    {
        if( fNeedConfig ) {
            ZeroX(cfg);
            cfg.dwSize   = cbX(cfg);

            hres = DIWdm_JoyHidMapping(idJoy, NULL, &cfg, &dijti );
        } else {

            hres = DIWdm_JoyHidMapping(idJoy, NULL, NULL, &dijti );
        }

        if( SUCCEEDED(hres) )
        {
            if( fNeedType == TRUE)
            {
             hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE,
                                       REGSTR_PATH_JOYOEM,
                                       DI_KEY_ALL_ACCESS,
                                       REG_OPTION_NON_VOLATILE,
                                       &hk);

                if( SUCCEEDED(hres) )
                {
                    hres = JoyReg_SetTypeInfo(hk,
                                              cfg.wszType,
                                              &dijti,
                                              DITC_REGHWSETTINGS | DITC_DISPLAYNAME | DITC_HARDWAREID );
                    if( SUCCEEDED(hres ) )
                    {
                    } else // SetTypeinfo FAILED
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: JoyReg_SetTypeInfo FAILED  "),
                                        s_szProc );

                    RegCloseKey(hk);
                } else // SetTypeinfo FAILED
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: JoyReg_OpenTypeKey FAILED  "),
                                    s_szProc );
            }

            if( fNeedConfig )
            {
                hres = JoyReg_SetConfig(idJoy,
                                        &cfg.hwc,
                                        &cfg,
                                        DIJC_INREGISTRY);

                if( SUCCEEDED(hres) )
                {
                  #ifdef WINNT
                    Excl_SetConfigChangedTime( GetTickCount() );
                    PostMessage (HWND_BROADCAST, g_wmJoyChanged, idJoy+1, 0L);
                  #else
                    joyConfigChanged(0);
                  #endif

                } else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT(",JoyReg_SetConfig FAILED hres=%d"),
                                    hres);
                }
            }
        } else // DIWdm_GetJoyHidMapping FAILED
        {
            fNeedNone = TRUE;
        }
    }

    /*
     *  4. If WinMM has data for a device that WDM does not, delete it
     */
    if( fNeedNone )
    {
        ZeroX( cfg );
        cfg.dwSize = cbX( cfg );
        cfg.dwGain = DI_FFNOMINALMAX;

        if(SUCCEEDED(hres = JoyReg_SetConfig(idJoy, &cfg.hwc,
                                             &cfg, DIJC_SETVALID)) &&
           SUCCEEDED(hres = JoyReg_OpenConfigKey(idJoy, MAXIMUM_ALLOWED,
                                                 NULL, REG_OPTION_VOLATILE, &hk)))
        {
            TCHAR tsz[MAX_JOYSTRING];

            wsprintf(tsz, TEXT("%u"), idJoy + 1);
            if( fWinnt )
                DIWinnt_RegDeleteKey(hk, tsz);
            else
                RegDeleteKey(hk, tsz);
            RegCloseKey(hk);

            hres = S_OK;
        }
    }

    ExitProcX(hres);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIWdm_InitJoyId |
 *
 *          Initializes Joystick IDs for JoyConfig and legacy APIs
 *          Store the joystick IDs the registry under the %%DirectX/JOYID key.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIWdm_InitJoyId( void )
{
    BOOL    fRc;
    LONG    lRc;
    int     ihdi;
    int     idJoy;
    BOOL    fNeedId;
    BOOL    rfJoyId[cJoyMax];     /* Bool Array for to determine which IDs are in use */
    PHIDDEVICEINFO phdi;
    HRESULT hres = E_FAIL;

    EnterProcI(DIWdm_InitJoyId, (_ ""));

    DllEnterCrit();

    fRc = TRUE;
    ZeroX(rfJoyId );
    fNeedId = FALSE;


    /* Iterate over all HID devices to fDIWdm_SetJoyIdind used IDs */
    for( ihdi = 0, phdi = g_phdl->rghdi ;
       (g_phdl != NULL) && (phdi != NULL) && (phdi->fAttached) && (ihdi < g_phdl->chdi) ;
       ihdi++, phdi++ )
    {
        /* We need joyIDs only for JOYSTICK devices */
        if( fHasAllBitsFlFl( phdi->osd.dwDevType, DIDEVTYPE_JOYSTICK | DIDEVTYPE_HID ) )
        {
            idJoy = phdi->idJoy ;

            /* Validate the ID. */
            if( idJoy < cJoyMax && rfJoyId[idJoy] != TRUE )
            {
                rfJoyId[idJoy] = TRUE;
                hres = DIWdm_SetLegacyConfig(idJoy);
                if( FAILED ( hres ) )
                {
                    fRc = FALSE;
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: DIWdm_SetLegacyConfig() FAILED ")
                                    TEXT("idJoy=%d FAILED hres = %d"),
                                    s_szProc, idJoy, hres );
                }
            } else
            {
                /* ID either over the limit OR is already used */
                phdi->idJoy = JOY_BOGUSID;
                fNeedId = TRUE;
            }
        }
    }

    /* Are there devices that need an ID */
    if( fNeedId )
    {
        /*
         * We have Examined all Joystick Ids found used IDs
         * and determined some device needs an Id
         */
        /* Iterate to assign unused Id's */
        for( ihdi = 0, phdi = g_phdl->rghdi;
           ihdi < g_phdl->chdi ;
           ihdi++, phdi++ )
        {
            /* We need joyIDs only for HID JOYSTICK devices */
            if( fHasAllBitsFlFl( phdi->osd.dwDevType, DIDEVTYPE_JOYSTICK | DIDEVTYPE_HID ) )
            {
                idJoy = phdi->idJoy;
                if( idJoy == JOY_BOGUSID  )
                {
                    /* Get an Unused ID */
                    for(idJoy = 0x0;
                       idJoy < cJoyMax;
                       idJoy++ )
                    {
                        if( rfJoyId[idJoy] == FALSE )
                            break;
                    }

                    if( idJoy < cJoyMax )
                    {
                        rfJoyId[idJoy] = TRUE;
                        phdi->idJoy  = idJoy;
                        if( lRc = RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                                (PV)&idJoy, cbX(idJoy)) == ERROR_SUCCESS )
                        {
                            /*
                             * This extra RegSetValueEx on "Joystick Id" is to keep the 
                             * compatibility with Win2k Gold. 
                             * See Windows bug 395416 for detail.
                             */
                            RegSetValueEx(phdi->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                                    (PV)&idJoy, cbX(idJoy));
                            
                            /* Setup Registry data for legacy API's */
                            hres = DIWdm_SetLegacyConfig(idJoy);

                            if( FAILED ( hres ) )
                            {
                                fRc = FALSE;
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("%S: DIWdm_SetLegacyConfig() FAILED")
                                                TEXT(" idJoy=%d hres = %d"),
                                                s_szProc, idJoy, hres );
                            }
                        } else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("%S: RegSetValueEx(JOYID) FAILED ")
                                            TEXT("Error = %d"),
                                            s_szProc, lRc);
                            fRc = FALSE;
                        }
                    }
                }
            }
        }
    }

    DllLeaveCrit();

    ExitBenignProcF(fRc);

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DIWdm_SetConfig |
 *
 *          Sets config for analog joysticks. This function is an
 *          extention of the JoyCfg_SetConfig function for NT.
 *          It associates a gameport/serialport bus with a legacy (HID) device and
 *          sends an IOCTL to the gameport/serialport bus to attach the device.
 *          The IOCLT takes the hardware ID[] which is got from
 *          the Joystick OEM types entry
 *          (HKLM\CurrentControlSet\Control\Media\PrivateProperties\Joystick\OEM)
 *          Some time later PnP realizes that a new device has been added, and hunts for
 *          an inf file that matches the HardwareId.
 *
 *          When the new HID device finally shows up, we look for the gameport/serialport that
 *          the HID device is associated with and try to give it the requested idJoy.
 *
 *
 *  @parm   IN UINT | idJoy |
 *
 *          ID of Joystick
 *
 *  @parm   IN LPJOYREGHWCONFIG | pjwc |
 *
 *          Address of JOYREGHWCONFIG structure that contains config info for the joystick
 *
 *  @parm   IN LPCDIJOYCONFIG  | pcfg |
 *
 *          Address of DIJOYCONFIG structure that contains config info for the joystick
 *
 *  @parm   IN DWORD | fl |
 *
 *          Flags
 *
 *  @returns
 *
 *          DIERR_INVALIDPARAM  This function needs DX6.1a functionality.
 *          DIERR_UNSUPPORTED   Autoload devices cannot be added through this API.
 *          DIERR_NOTFOUND      TypeInfo not found in the registry.
 *          E_ACCESSDENIED      Gameport is configured to use another device.
 *          E_FAIL              CreateFile on Gameport device failed.
 *                              Could not send IOCTL to gameport device.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIWdm_SetConfig
    (
    IN UINT             idJoy,
    IN LPJOYREGHWCONFIG pjwc,
    IN LPCDIJOYCONFIG   pcfg,
    IN DWORD            fl
    )
{
    HRESULT hres;
    EnterProc(DIWdm_SetConfig, (_"uppu", idJoy, pjwc, pcfg, fl));

    DllEnterCrit();

    hres = E_FAIL;

    if( pcfg->dwSize < cbX(DIJOYCONFIG_DX6 ))
    {
        /* This function needs DX5B2 functionality */
        hres = DIERR_INVALIDPARAM;
    } else if( pjwc->hws.dwFlags & JOY_HWS_AUTOLOAD )
    {
        /* Device cannot be autoload */
        hres = DIERR_UNSUPPORTED;
    } else
    {
        DIJOYTYPEINFO dijti;
        BUS_REGDATA RegData;

        ZeroX(dijti);
        dijti.dwSize = cbX(dijti);

        ZeroX(RegData);
        RegData.dwSize     = cbX(RegData);
        RegData.nJoysticks = 1;

        /* Is this a predefined joystick type ? */
        if(pcfg->wszType[0] == TEXT('#'))
        {
#define JoyCfg_TypeFromChar(tch)   ((tch) - L'0')
            hres = JoyReg_GetPredefTypeInfo(pcfg->wszType,
                                            &dijti, DITC_INREGISTRY | DITC_HARDWAREID);

            RegData.uVID = MSFT_SYSTEM_VID;
            RegData.uPID = MSFT_SYSTEM_PID + JoyCfg_TypeFromChar(pcfg->wszType[1]);

            if(JoyCfg_TypeFromChar(pcfg->wszType[1]) == JOY_HW_TWO_2A_2B_WITH_Y  )
            {
                RegData.nJoysticks = 2;
                pjwc->hws.dwFlags = 0x0;
            }
#undef JoyCfg_TypeFromChar
        } else
        {
            hres = JoyReg_GetTypeInfo(pcfg->wszType,
                                      &dijti, DITC_INREGISTRY | DITC_HARDWAREID | DITC_DISPLAYNAME );

            if( SUCCEEDED(hres) )
            {
                USHORT uVID, uPID;
                PWCHAR pCurrChar;
                PWCHAR pLastSlash = NULL;

                /* Find the last slash in the hardwareId, any VID/PID should follow directly */
                for( pCurrChar = dijti.wszHardwareId; *pCurrChar != L'\0'; pCurrChar++ )
                {
                    if( *pCurrChar == L'\\' )
                    {
                        pLastSlash = pCurrChar;
                    }
                }

                /*
                 *  If the hardware ID has no separator, treat the device as 
                 *  though JOY_HWS_AUTOLOAD were set because we cannot expose 
                 *  a non-PnP device without a hardware ID.
                 */
                if( pLastSlash++ )
                {
                    /* 
                     *  If the hardwareId does contain a VIDPID, try the type 
                     *  name.  Some auto-detect types require this.
                     *
                     *  Prefix gets messed up in ParseVIDPID (mb:34573) and warns 
                     *  that uVID is uninitialized when ParseVIDPID returns TRUE.
                     */
                    if( ParseVIDPID( &uVID, &uPID, pLastSlash )
                     || ParseVIDPID( &uVID, &uPID, pcfg->wszType ) )
                    {
                        RegData.uVID = uVID;
                        RegData.uPID = uPID;        
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: cannot find VID and PID for non-PnP type %ls"),
                                        s_szProc, pcfg->wszType);
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: invalid hardware ID for non-PnP type %ls"),
                                    s_szProc, pcfg->wszType);
                    hres = DIERR_UNSUPPORTED;
                }
            }
        }



        if( SUCCEEDED(hres) )
        {
            PBUSDEVICEINFO pbdi;
            PBUSDEVICELIST pbdl;

            /* Copy over the hardwareID */
            lstrcpyW(RegData.wszHardwareId, dijti.wszHardwareId);
            RegData.hws = pjwc->hws;
            RegData.dwFlags1 = dijti.dwFlags1;

            pbdi = pbdiFromGUID(&pcfg->guidGameport);

            // Attach device to the gameport
            if( pbdi )
            {
                // Set the Joystick ID for the gameport/serialport
                pbdi->idJoy = idJoy;

                // We know which instance of the gameport.
                hres = DIBusDevice_Expose(pbdi, &RegData);
            } else if( NULL != ( pbdl = pbdlFromGUID(&pcfg->guidGameport ) ) )
            {
                // We don't kwow which instance of the gameport
                // only which bus.
                // We will expose the device on all instances of the
                // gameport and later delete devices when we find they
                // are not connected.
                hres = DIBusDevice_ExposeEx(pbdl, &RegData);
            } else
            {
                hres = DIERR_DEVICENOTREG;
            }


            if( SUCCEEDED(hres) )
            {
                /* Device is not present */
                pjwc->dwUsageSettings &= ~JOY_US_PRESENT;

                /* Definately volatile */
                pjwc->dwUsageSettings |=  JOY_US_VOLATILE;

            }
        }
    }

    ExitOleProc();
    DllLeaveCrit();

    return hres;
} /* DIWdm_SetConfig */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DIWdm_DeleteConfig |
 *
 *          WDM extension for JoyCfd::DeleteConfig. On WDM a legacy(HID) device will
 *          keep reappearing as long as the gameport bus is aware of it. So when a
 *          legacy(HID) device is deleted, we need to find out he associated gameport bus
 *          and tell him to stop attaching the device.
 *
 *  @parm   IN UINT | idJoy |
 *
 *          ID of Joystick
 *
 *  @returns
 *
 *          HRESULT code
 *          DIERR_DEVICENOTREG:     Device is not a WDM device
 *          DIERR_UNSUPPORTED:      Device is WDM but not gameport
 *          S_OK:                   Device Persistance removed.
 *
 *****************************************************************************/


HRESULT EXTERNAL
    DIWdm_DeleteConfig( int idJoy )
{
    HRESULT hres = S_OK;
    PBUSDEVICEINFO  pbdi = NULL;
    PHIDDEVICEINFO  phdi = NULL;

    EnterProcI(DIWdm_DeleteConfig, (_"u", idJoy));
    DllEnterCrit();

    DIHid_BuildHidList(FALSE);

    /*
     * pbdi (BUSDEVICEINFO) must be obtained before we remove the device
     */
    phdi = phdiFindJoyId(idJoy);
    if(phdi != NULL )
    {
        pbdi = pbdiFromphdi(phdi);
    } else
    {
        hres = DIERR_DEVICENOTREG;
        goto _done;
    }


    if( SUCCEEDED(hres)
        && phdi != NULL
        && pbdi != NULL )
    {
        lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
        g_tmLastRemoved = GetTickCount();

        // If the device is a bus device ( Non USB )
        // it needs some help in removal.
        hres = DIBusDevice_Remove(pbdi);

        //If the device has been successfully removed,
        //then we need remember it in phdi list in case
        //the PnP doesn't function well.
        if( pbdi->fAttached == FALSE )
        {
            phdi->fAttached = FALSE;
        }

    } else
    {
        //HDEVINFO hdev;

        // Device is USB, we do not support removing
        // USB devices from the CPL. User is encouraged to
        // Yank out the device or go to the device manager to
        // remove it.

        // This is true in Win2K. But in Win9X, since VJOYD also works with USB,
        // when we swap id, we need delete it first.

        hres = DIERR_UNSUPPORTED;

#if 0
        // In case we wanted to support removing USB devices from
        // the game cpl. Here is the code ...

        /*
         *  Talk to SetupApi to delete the device.
         *  This should not be necessary, but I have
         *  to do this to work around a PnP bug whereby
         *  the device is not removed after I send a remove
         *  IOCTL to gameenum.
         */
        hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
        if( phdi && hdev != INVALID_HANDLE_VALUE)
        {
            SP_DEVINFO_DATA dinf;

            dinf.cbSize = cbX(SP_DEVINFO_DATA);

            /* Get SP_DEVINFO_DATA for the HID device */
            if(SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf))
            {
                /* Delete the device */
                if( SetupDiCallClassInstaller(DIF_REMOVE,
                                              hdev,
                                              &dinf) )
                {
                    // SUCCESS
                } else
                {
                    hres = E_FAIL;
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: SetupDiClassInstalled(DIF_REMOVE) FAILED  "),
                                    s_szProc );
                }
            }
            SetupDiDestroyDeviceInfoList(hdev);
        }
#endif
    }

_done:

    /*
     * Force a remake of the HID list
     * Some devices may have disappered
     * It helps to sleep for some time to give
     * PnP and its worker threads to spin.
     */
    Sleep(10);

    DIHid_BuildHidList(TRUE);
    DllLeaveCrit();

    ExitOleProc();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\winnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\makefile.inc ===
$(O)\guids.obj: ..\guids.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx7\dll\valid.c ===
/*****************************************************************************
 *
 *  Valid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Validate services.  On a validation error that would not have
 *      been caught in retail, we throw an exception.
 *
 *  Contents:
 *
 *      fFullValidPhwnd
 *      fFullValidPpdw
 *      fFullValidPpfn
 *      fFullValidReadPx
 *      fFullValidWritePx
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidHwnd |
 *
 *          Validate a window handle completely.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle to validate.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_HANDLE> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidHwnd_(HWND hwnd, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (IsWindow(hwnd)) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: not a window handle", s_szProc, iarg);
        hres = E_HANDLE;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPvCb_ |
 *
 *          Validate that a buffer is readable or writeable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   PFNBAD | pfnBad |
 *
 *          Function that determines whether the buffer is bad.
 *          Should be <f IsBadReadPtr> or <f IsBadWritePtr>.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *          High word indicates how many bytes should not be
 *          scrambled.
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

typedef BOOL (WINAPI *PFNBAD)(PCV pv, UINT_PTR cb);

#ifndef XDEBUG

#define hresFullValidPvCb_(pv, cb, pfnBad, z, i)                    \
       _hresFullValidPvCb_(pv, cb, pfnBad)                          \

#endif

STDMETHODIMP
hresFullValidPvCb_(PCV pv, UINT cb, PFNBAD pfnBad, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
#if DIRECTINPUT_VERSION < 0x0400
    if (pfnBad(pv, cb)) {
#else
    if (!pfnBad(pv, LOWORD(cb))) {
#endif
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePvCb_ |
 *
 *          Validate that a buffer is writeable.  Also scrambles it
 *          if special goo doesn't need to be done.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    hres = hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadWritePtr, s_szProc, iarg);
#ifdef XDEBUG
    if (SUCCEEDED(hres) && HIWORD(iarg) == 0) {
        ScrambleBuf(pv, cb);
    }
#endif
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPvCb_ |
 *
 *          Validate that a buffer is readable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    return hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadReadPtr, s_szProc, iarg);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPxCb_ |
 *
 *          Validate that a sized structure is readable or writeable.
 *
 *  @parm   PCV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.  If the structure is being validated for
 *          writing, then all fields beyond the <p dwSize> are scrambled
 *          in XDEBUG.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   STRUCTPROC | pfnStruct |
 *
 *          Function which validates that a structure is readable or writable.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable or writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

typedef STDMETHOD(STRUCTPROC)(PCV pv, UINT cb
                                   RD(comma LPCSTR s_szProc comma int iarg));

#ifndef XDEBUG

#define hresFullValidPxCb_(pv, cbHiLo, pfnStruct, z, i)             \
       _hresFullValidPxCb_(pv, cbHiLo, pfnStruct)                   \

#endif

STDMETHODIMP
hresFullValidPxCb_(PCV pv, UINT cbHiLo, STRUCTPROC pfnStruct,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    /*
     *  Raymond frequently suffers a brain lapse and passes
     *  a cbX(LPMUMBLE) instead of a cbX(MUMBLE).
     */
    AssertF(LOWORD(cbHiLo) != cbX(DWORD));
    AssertF(HIWORD(cbHiLo) != cbX(DWORD));

    if (!IsBadReadPtr(pv, cbX(DWORD))) {

        DWORD cbIn = *(LPDWORD)pv;

        /*
         *  The leading "cbIn &&" prevents the HIWORD(cbHiLo)==0 case from
         *  accidentally allowing a size of zero to sneak past.
         */

        if (cbIn && (cbIn == LOWORD(cbHiLo) || cbIn == HIWORD(cbHiLo))) {

            hres = pfnStruct(pv, cbIn RD(comma s_szProc comma iarg));
            if (SUCCEEDED(hres)) {
                if (HIWORD(iarg)) {
                    ScrambleBuf(pvAddPvCb(pv, HIWORD(iarg)),
                                cbIn - HIWORD(iarg));
                }
            }
        } else {
            RPF("ERROR %s: arg %d: invalid dwSize", s_szProc, LOWORD(iarg));
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePxCb_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are scrambled before returning.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidWritePvCb_ and
     *  _hresFullValidWritePvCb_ manually, because the preprocessor
     *  gets confused.
     *
     *  We also need to put a cbX(DWORD) into the high word of the iarg
     *  so that the size field won't get demolished.
     */
#ifdef XDEBUG
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cbX(DWORD)));
#else
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)_hresFullValidWritePvCb_,
                                      s_szProc, iarg);
#endif
}

#ifdef XDEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWriteNoScramblePxCb_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are not scrambled.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWriteNoScramblePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cb));
}
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPxCb_ |
 *
 *          Validate that a sized structure is readable.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidReadPvCb_ and
     *  _hresFullValidReadPvCb_ manually, because the preprocessor
     *  gets confused.
     */
#ifdef XDEBUG
    return hresFullValidPxCb_(pv, cb, hresFullValidReadPvCb_, s_szProc, iarg);
#else
    return hresFullValidPxCb_(pv, cb, _hresFullValidReadPvCb_, s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidFl_ |
 *
 *          Validate that no invalid flags are passed.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags passed by the caller.
 *
 *  @parm   DWORD | flV |
 *
 *          Flags which are valid.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if ((fl & ~flV) == 0) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid flags", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPfn_ |
 *
 *          Validate that the parameter is a valid code pointer.
 *
 *          Actually, <f IsValidCodePtr> on Win32 is broken, but
 *          tough.
 *
 *  @parm   FARPROC | pfn |
 *
 *          Procedure to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPfn_(FARPROC pfn, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadCodePtr(pfn)) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid callback address", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPitf_ |
 *
 *          Validate that the parameter is an interface pointer.
 *
 *          We don't look at it very hard.
 *
 *  @parm   PUNK | punk |
 *
 *          <i IUnknown> to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *          <c E_INVALIDARG> if something inside the pointer is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPitf_(PUNK punk, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if (!IsBadReadPtr(punk, cbX(*punk))) {
        IUnknownVtbl *pvtbl = punk->lpVtbl;
        if (!IsBadReadPtr(pvtbl, cbX(*pvtbl))) {
            if (!IsBadCodePtr((FARPROC)pvtbl->QueryInterface) &&
                !IsBadCodePtr((FARPROC)pvtbl->AddRef) &&
                !IsBadCodePtr((FARPROC)pvtbl->Release)) {
                hres = S_OK;
            } else {
                RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
                hres = E_INVALIDARG;
            }
        } else {
            RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPcbOut_ |
 *
 *          Validate that the parameter is a valid place to stick an
 *          output result.  We also smas it to zero.
 *
 *  @parm   PV | pcb |
 *
 *          Pointer to "validate".
 *
 *  @parm   UINT | cb |
 *
 *          Size of data pcb points to.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPcbOut_(PV pcb, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadWritePtr(pcb, cb)) {
        memset(pcb,0,cb);
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadStrA_ |
 *
 *          Validate that the parameter is a valid readable
 *          ANSI string of maximum length <p cch>.
 *
 *          Note that we cannot use <f IsBadStringPtr> because
 *          <f IsBadStringPtr> handles the "string too long"
 *          case incorrectly.  Instead, we use <f lstrlenA>.
 *
 *  @parm   LPCSTR | psz |
 *
 *          String to "validate".
 *
 *  @parm   UINT | cch |
 *
 *          Maximum string length, including null terminator.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadStrA_(LPCSTR psz, UINT cch, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT cchT;

    /*
     *  lstrlenA returns 0 if the parameter is invalid.
     *  It also returns 0 if the string is null.
     */
    cchT = (UINT)lstrlenA(psz);

    if (cchT == 0) {
        /*
         *  The ambiguous case.  See if it's really a null string.
         */
        if (IsBadReadPtr(psz, cbCch(1)) || psz[0]) {
            RPF("ERROR %s: arg %d: invalid ANSI string", s_szProc, iarg);
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else if (cchT < cch) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid ANSI string", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadStrW_ |
 *
 *          Validate that the parameter is a valid readable
 *          UNICODE string of maximum length <p cwch>.
 *
 *          Note that we cannot use <f IsBadStringPtr> because
 *          <f IsBadStringPtr> handles the "string too long"
 *          case incorrectly.  Instead, we use <f lstrlenW>.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          String to "validate".
 *
 *  @parm   UINT | cwch |
 *
 *          Maximum string length, including null terminator.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadStrW_(LPCWSTR pwsz, UINT cwch, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT cwchT;

    hres = E_INVALIDARG;
    /*
     *  lstrlenW returns 0 if the parameter is invalid.
     *  It also returns 0 if the string is null.
     */
    cwchT = (UINT)lstrlenW(pwsz);

    if (cwchT == 0) {
        /*
         *  The ambiguous case.  See if it's really a null string.
         */
        if (IsBadReadPtr(pwsz, cbCwch(1)) || pwsz[0]) {
            RPF("ERROR %s: arg %d: invalid UNICODE string", s_szProc, iarg);
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else if (cwchT < cwch) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid UNICODE string", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPesc_ |
 *
 *          Validate that the parameter is a valid <t DIEFFESCAPE>
 *          structure.
 *
 *          This is merely a wrapper around other validation methods.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Structure to "validate".
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPesc_(LPDIEFFESCAPE pesc, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if (SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(pesc, DIEFFESCAPE,
                                                          iarg)) &&
        SUCCEEDED(hres = hresFullValidReadPvCb(pesc->lpvInBuffer,
                                               pesc->cbInBuffer, iarg)) &&
        SUCCEEDED(hres = hresFullValidWriteNoScramblePvCb(pesc->lpvOutBuffer,
                                                pesc->cbOutBuffer, iarg))) {
    } else {
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\newthrow.cpp ===
/******************************************************************************
 *
 * newthrow.cpp
 *
 * Copyright (c) 1999, 2000 Microsoft Corporation. All Rights Reserved.
 *
 * Abstract:
 *
 * Contents:
 *
 *****************************************************************************/

#include "dimapp.h"
#include <new>
#include <new.h>

#pragma warning(disable:4073)
#pragma init_seg(lib)
int __cdecl my_new_handler(size_t) {
throw MAP_EXCEPTION(E_OUTOFMEMORY);
return 0;
}
struct _tag_g_new_handler_obj{
_PNH _old_new_handler;
int _old_new_mode;
_tag_g_new_handler_obj() {
   _old_new_mode = _set_new_mode(1);
   _old_new_handler = _set_new_handler(my_new_handler);
}
~_tag_g_new_handler_obj() {
   _set_new_handler(_old_new_handler);
   _set_new_mode(_old_new_mode);
}

} _g_new_handler_obj;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\dimapp.h ===
/******************************************************************************
 *
 * dimapp.h
 *
 * Copyright (c) 1999, 2000 Microsoft Corporation. All Rights Reserved.
 *
 * Abstract:
 *
 * Contents:
 *
 *****************************************************************************/

#ifndef _DIMAPP_H
#define _DIMAPP_H

#ifdef  __cplusplus
extern "C" {
#endif

#undef _DLL
#undef _MT
#define _MT

#ifdef UNICODE
#undef _UNICODE
#define _UNICODE
#endif

#ifdef DEBUG
#define _CHECKED
#endif

#include "windows.h"

/*///////////////////////////////////////////////////////////
// Callout Alignment Flags (inserted by a-mday 11-04-1999)
//
// (defines from diconfig\diacpage\cdevicecontrol.h)
//*/
#define CAF_LEFT 1
#define CAF_RIGHT 2
#define CAF_TOP 4
#define CAF_BOTTOM 8

#define CAF_TOPLEFT (CAF_TOP | CAF_LEFT)
#define CAF_TOPRIGHT (CAF_TOP | CAF_RIGHT)
#define CAF_BOTTOMLEFT (CAF_BOTTOM | CAF_LEFT)
#define CAF_BOTTOMRIGHT (CAF_BOTTOM | CAF_RIGHT)

#define DEV_IMAGE_ALIGN_CENTER      0
#define DEV_IMAGE_ALIGN_LEFT        CAF_LEFT
#define DEV_IMAGE_ALIGN_RIGHT       CAF_RIGHT
#define DEV_IMAGE_ALIGN_TOP         CAF_TOP
#define DEV_IMAGE_ALIGN_BOTTOM      CAF_BOTTOM
#define DEV_IMAGE_ALIGN_TOPLEFT     CAF_TOPLEFT
#define DEV_IMAGE_ALIGN_TOPRIGHT    CAF_TOPRIGHT
#define DEV_IMAGE_ALIGN_BOTTOMLEFT  CAF_BOTTOMLEFT
#define DEV_IMAGE_ALIGN_BOTTOMRIGHT CAF_BOTTOMRIGHT
    
STDAPI_(ULONG) DllAddRef(void);
STDAPI_(ULONG) DllRelease(void);
HRESULT Map_New(REFIID riid,LPVOID *ppvOut);

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#ifdef __cplusplus /*make this dissapear in non C++ files (obj.c)*/
#include "tchar.h"
#include <exception>

#ifdef _CHECKED
#define MAP_EXCEPTION(A) MapException(_T(__FILE__),__LINE__,A)
#else
#define MAP_EXCEPTION(A) MapException(A)
#endif

class MapException:public exception
{
    HRESULT m_hRes;
public:
    HRESULT GetResult(){return m_hRes;};
    MapException(
#ifdef _CHECKED
        LPCTSTR lpSourceFile,DWORD dwLine,
#endif
        HRESULT hRes);
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\guids.cpp ===
/*****************************************************************************
 *
 *  guids.c
 *
 *  Copyright (c) 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *****************************************************************************/

#define INITGUID
#include <dinput.h>
#include <coguid.h>
#include "dimap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\dimap.cpp ===
/******************************************************************************
 *
 * dimap.cpp
 *
 * Copyright (c) 1999, 2000 Microsoft Corporation. All Rights Reserved.
 *
 * Abstract:
 *
 * Contents:
 *
 *****************************************************************************/

#include "dimapp.h"
#include "objbase.h"
#include "stdio.h"
#include "shlwapi.h"
#include "shlobj.h"
#include "lmcons.h"
#include "dimap.h"
#include "dinputp.h"
#include "string"
#include "list"
#include "algorithm"
#include "dinputd.h"

/******************************************************************************
 *
 * Definitions
 *
 *****************************************************************************/

using namespace std;

#undef STRICT_DEV_DEF

//MAKE SURE THIS SIX ARE CONSISTENT
#define MAP_DIR _T("\\DirectX\\DirectInput\\User Maps")
#define MAP_DIR_NT _T("\\Microsoft\\DirectX\\DirectInput\\User Maps")
#define MS_NAME _T("\\Microsoft")
#define DIRECTX _T("\\DirectX")
#define DIRECTINPUT _T("\\DirectInput")
#define USER_MAPS _T("\\User Maps")

#define DEFAULT_USER_NAME _T("X")

#define NAME _T("Name")
#define RESERVED_STRING _T("Error")
#define DIRECT_INPUT _T("DirectInput")
#define DIRECTX_VERSION _T("DirectXVersion")
#define DEVICES _T("Devices")
#define DEVICE _T("Device")
#define VENDORID _T("VID")
#define PRODUCTID _T("PID")
#define CONTROLS _T("Controls")
#define CONTROL _T("Control")
#define USAGE _T("Usage")
#define USAGEPAGE _T("UsagePage")
#define GENRE _T("Genre")
#define MAPEXISTS _T("MapExists")
#define APPLICATION _T("Application")
#define IMAGE_FILENAME _T("ImageFileName")
#define OVERLAY_FILENAME _T("OverlayFileName")
#define SELECTION_FILENAME _T("SelectionFileName")
#define VIEWSELECT_FILENAME _T("ViewSelectFileName")
#define IMAGE_FORMAT _T("ImageFormat")
#define OVERLAY_FORMAT _T("OverlayFormat")
#define SELECTION_FORMAT _T("SelectionFormat")
#define VIEWSELECT_FORMAT _T("ViewSelectFormat")
#define OVERLAY_RECT _T("OverlayRect")
#define CONTROL_STRING_ALIGN _T("Align")
#define CONTROL_VISIBLE _T("Visible")
#define STRING_POS _T("StringPos")
#define LINE_DATA _T("LineData")
#define CALLOUTMAX _T("CallOutMax")
#define OVERLAYRECT _T("OverlayRect")
#define OFFSET _T("Type")
#define TIMESTAMPHIGH _T("TimestampHigh")
#define TIMESTAMPLOW _T("TimestampLow")
#define NUMACTIONS _T("NumActions")
#define SEPARATOR _T(',')
#define RESERVED_DX_VER 0xffffffff
#define RESERVED_VENDORID 0
#define RESERVED_PRODUCTID 0
#define RESERVED_OFFSET 0xffffffff
#define RESERVED_USAGE 0
#define RESERVED_USAGEPAGE 0
#define RESERVED_ACTION 0xffffffff
#define _MAX_SECTION_NAME 64
#define _MAX_KEY_NAME 64

GUID NULLGUID;

#ifdef UNICODE
#define String  wstring
#define IsSpace iswspace
#else
#define String  string
#define IsSpace isspace
#endif // !UNICODE

typedef String::iterator StrIter;
class CS:public String{};
typedef list<CS> STRINGLIST;

/******************************************************************************
 *
 * Classes
 *
 *****************************************************************************/

template <class p> class AutoRelease
{
    p m_p;
public:
    AutoRelease(){m_p=NULL;};
    ~AutoRelease(){if(m_p){m_p->Release();m_p=NULL;};};
    inline LPVOID* Addr() { return (LPVOID*) &m_p;};
    operator p(){return m_p;};
    operator p*(){return &m_p;};
    p P(){return m_p;};
};
typedef AutoRelease<LPDIRECTINPUT8> LPDIRECTINPUT_AR;
typedef AutoRelease<LPDIRECTINPUTDEVICE8> LPDIRECTINPUTDEVICE_AR;

struct DeviceObjData;
struct ControlData
{
    DeviceObjData *pDevObj;
    String ControlName;//Name in .ini file
    String Name;
    DWORD dwUsage;
    DWORD dwUsagePage;
    DWORD dwAction;//<---workspace for mapping...
    DWORD dwOffset;
};
typedef list<ControlData> CONTROLLIST;

struct DeviceObjData
{
    ControlData *pUCtrlData;
    ControlData *pVCtrlData;
    String Name;//Name for device object returned by DInput
    DWORD dwUsage;
    DWORD dwUsagePage;
    DWORD dwOffset;
    DWORD dwType;
    DWORD dwFlags;
    bool bMapped;//<---workspace for mapping...
};
typedef list<DeviceObjData> DEVICEOBJLIST;

struct DEVCNT
{
    LPDIDEVICEINSTANCE pDIDI;
    int *m_pnCnt;
};

class IDirectInputMapperTrA:
    public IDirectInputMapperA,public IDirectInputMapperVendorA
{
    virtual HRESULT InitializeI(
        LPCGUID lpThisGUIDInstance,
        LPCTSTR lpcstrFileName,
        DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE Initialize(
        LPCGUID lpThisGUIDInstance,
        LPCSTR lpcstrFileName,
        DWORD dwFlags);
    
    virtual HRESULT GetActionMapI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPCTSTR lpctstrUserName,
        FILETIME *pTimestamp,DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE GetActionMap(
        LPDIACTIONFORMATA lpDiActionFormat,
        LPCSTR lpctstrUserName,
        FILETIME *pTimestamp,DWORD dwFlags);
    
    virtual HRESULT SaveActionMapI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPCTSTR lpctstrUserName,
        DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE SaveActionMap(
        LPDIACTIONFORMATA lpDiActionFormat,
        LPCSTR lpctstrUserName,
        DWORD dwFlags);
    
    virtual HRESULT GetImageInfoI(
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader)=0;
    HRESULT STDMETHODCALLTYPE GetImageInfo(
        LPDIDEVICEIMAGEINFOHEADERA lpdiDevImageInfoHeader);
    
    virtual HRESULT WriteVendorFileI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
        DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE WriteVendorFile(
        LPDIACTIONFORMATA lpDiActionFormat,
        LPDIDEVICEIMAGEINFOHEADERA lpdiDevImageInfoHeader,
        DWORD dwFlags);
};

class IDirectInputMapperTrW:
    public IDirectInputMapperW,public IDirectInputMapperVendorW
{
    virtual HRESULT InitializeI(
        LPCGUID lpThisGUIDInstance,
        LPCTSTR lpcstrFileName,
        DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE Initialize(
        LPCGUID lpThisGUIDInstance,
        LPCWSTR lpcstrFileName,
        DWORD dwFlags);
    
    virtual HRESULT GetActionMapI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPCTSTR lpctstrUserName,
        FILETIME *pTimestamp,DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE GetActionMap(
        LPDIACTIONFORMATW lpDiActionFormat,
        LPCWSTR lpctstrUserName,
        FILETIME *pTimestamp,DWORD dwFlags);
    
    virtual HRESULT SaveActionMapI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPCTSTR lpctstrUserName,
        DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE SaveActionMap(
        LPDIACTIONFORMATW lpDiActionFormat,
        LPCWSTR lpctstrUserName,
        DWORD dwFlags);
    
    virtual HRESULT GetImageInfoI(
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader)=0;
    HRESULT STDMETHODCALLTYPE GetImageInfo(
        LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader);
    
    virtual HRESULT WriteVendorFileI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
        DWORD dwFlags)=0;
    HRESULT STDMETHODCALLTYPE WriteVendorFile(
        LPDIACTIONFORMATW lpDiActionFormat,
        LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader,
        DWORD dwFlags);
};

class CDIMapObj:public IDirectInputMapperTrA,public IDirectInputMapperTrW
{
#ifdef _CHECKED
    static int m_DeviceCount;
    int m_DeviceNo;
#endif
    
    ULONG m_ulRefCnt;
    bool m_bInitialized;
    
    DWORD m_dwThisVendorID;
    DWORD m_dwThisProductID;
    String m_DeviceName;
    GUID m_DeviceGuid;
    int m_nDeviceInstanceNo;    

    //Vendor file name data
    String m_VFileName;
    LPCTSTR m_lpVFileName;
    String m_VFileDevName;
    CONTROLLIST m_VCtrlData;
    bool m_bVLoaded;
    //User file name data
    String m_UName;
    LPCTSTR m_lpUName;
    String m_UFileName;
    String m_UserDir;
    String m_UFileDevName;
    CONTROLLIST m_UCtrlData;
    bool m_bULoaded;
    FILETIME m_UTimestamp;
    
    bool m_bImageBufferSize;
    DWORD m_dwImageBufferSize;

    HRESULT InitializeI(
        LPCGUID lpThisGUIDInstance,
        LPCTSTR lpcstrFileName,
        DWORD dwFlags);
    
    HRESULT GetActionMapI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPCTSTR lpctstrUserName,
        FILETIME *pTimestamp,DWORD dwFlags);
    
    HRESULT SaveActionMapI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPCTSTR lpctstrUserName,
        DWORD dwFlags);
    
    HRESULT GetImageInfoI(
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader);
    
    HRESULT WriteVendorFileI(
        LPDIACTIONFORMAT lpDiActionFormat,
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
        DWORD dwFlags);
    
    HRESULT GetImageInfoInternal(
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
        bool bGettingSize);
    void SaveActionMapUV(
        LPDIACTIONFORMAT lpDiActionFormat,
        bool bDevInFileLoaded,
        LPCTSTR pFileName,
        String &FileDevName,
        CONTROLLIST &ControlsData,
        LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
        DWORD dwHow1,DWORD dwHow2,bool bUserFile);
    void WriteImageInfo(LPCTSTR lpFileKeyName,LPCTSTR lpFormatKeyName,
        LPCTSTR lpSectionName,LPDIDEVICEIMAGEINFO lpImageInfo,
        bool bAddIndex,bool bDelete);
    void MakeNewControlName(String &CtrlName,
        DEVICEOBJLIST::iterator DevObjIt,
        CONTROLLIST &ControlsData,
        String &FileDevName,
        STRINGLIST &ControlsAllDevs,
        STRINGLIST &Controls);
    void Resinc(LPDIACTIONFORMAT lpDiActionFormat);
    HRESULT GetImageInfo(
        DeviceObjData *pDevObj,
        DWORD dwIndex,
        LPDIDEVICEIMAGEINFO lpImageInfo,
        DWORD dwImageType);
    
    bool GetImageInfoFileName(LPCTSTR lpKeyName,LPCTSTR lpSectionName,
        DWORD dwIndex,LPDIDEVICEIMAGEINFO lpImageInfo);
//keep flags for a while just in case we change our minds again
#if 0       
    void GetImageInfoFormat(LPCTSTR lpKeyName,LPCTSTR lpSectionName,
        DWORD dwIndex,LPDIDEVICEIMAGEINFO lpImageInfo);
#endif
    void LoadFileData(LPCTSTR lpFileName,LPCTSTR lpThisName,
        DWORD dwThisVendorID,DWORD dwThisProductID,
        String &FileDeviceName,CONTROLLIST &ControlsData,
        bool &bLoaded,FILETIME *pT,LPDIACTIONFORMAT lpDiActionFormat);
    void LoadUserData(LPCTSTR lpctstrUserName,
        LPDIACTIONFORMAT lpDiActionFormat,
        bool bForceReload=false,
        bool bCreateDir=false);
    void Clear();
    bool IsVIDPID(){if(m_dwThisVendorID&&m_dwThisProductID)
        return true;return false;};
    bool CompareData(DeviceObjData &DOD,ControlData &CD);
    bool GetOffset(ControlData &CD,DEVICEOBJLIST &DevObjList,DWORD dwSemantic,
        DEVICEOBJLIST::iterator &DevObjItOut);
    void MapGenre(LPDIACTIONFORMAT lpDiActionFormat,CONTROLLIST &ControlsData,
        LPCTSTR lpGenreName,LPCTSTR lpFileName,
        LPCGUID lpThisGUIDInstance,
        DEVICEOBJLIST &DevObjList,DWORD dwHow,
        DWORD &dwNOfMappedActions);
    void MapDevice(LPDIACTIONFORMAT lpDiActionFormat,
        LPCTSTR lpFileName,
        LPCTSTR lpFileDevName,LPCGUID lpThisGUIDInstance,
        DEVICEOBJLIST &DevObjList,CONTROLLIST &ControlsData,
        DWORD dwHow,DWORD dwHowApp,DWORD &dwNOfMappedActions,
        bool *pbMapExists,bool bUserFile);
public:
#ifdef _CHECKED
    int GetDeviceNo(){return m_DeviceNo;};
#endif
    DEVICEOBJLIST m_DevObjList;
    
    CDIMapObj();
    ~CDIMapObj();
    ULONG STDMETHODCALLTYPE AddRef()
        {DllAddRef();m_ulRefCnt++;return m_ulRefCnt;};
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID * ppvObj);
};

/******************************************************************************
 *
 * Debug code
 *
 *****************************************************************************/

#ifdef _CHECKED

#include <tchar.h>
#include <crtdbg.h>
#include <stdio.h>

enum BlockType{
    eObjectEntryBT,
    eFunctionBT,
    eSubBT,
    eException,
};

enum ObjectEntry{
    eInitialize=1,
    eGetActionMap=2,
    eSaveActionMap=4,
    eGetImageInfo=8,
    eWriteVendorFile=16,
    eCDIMapObj=32,
    e_CDIMapObj=64,
    eAddRef=128,
    eRelease=256,
    eUnknownMethod=4096
};

class CAdvancedTracer
{
    static DWORD s_dwFlags;
    static DWORD s_dwFlagsEx;
    static DWORD s_dwObjNo;
    static DWORD s_dwObjNoEx;
    static int s_nDeviceNo;
    static DWORD s_dwLevels;
    static String s_ExceptionBuffer;
    static LPCTSTR s_lpMethodName;
    static ObjectEntry s_eObjectEntry;
    static CDIMapObj* s_lpMapObj;
    static FILE *s_pLogFile;  // File handle used for outputing to file
    static bool s_bException;
    static bool ExProcessing(){return s_bException;};

    BlockType m_eBlockType;
    int m_nExceptionBufferPos;
    static bool DumpFlagEx();
    static bool DumpFlag(bool bInfoEx);
public:
    CAdvancedTracer(
        BlockType eBlockType=eSubBT,
        LPCTSTR pMethodName=NULL,
        ObjectEntry eObjectEntry=eUnknownMethod,
        CDIMapObj*lpMapObj=NULL);
    CAdvancedTracer(LPCTSTR lpSourceFile,DWORD dwLine,HRESULT hRes);
    ~CAdvancedTracer();
    static void OutputTraceString(LPCTSTR szFmt, ...);
    static void OutputTraceStringInfoEx(LPCTSTR szFmt, ...);
    static void OutputTraceStringI(bool bInfoEx,LPCTSTR szFmt,
        va_list argptr);
    static void Dump(LPCTSTR szName,DWORD dwVal);
    static void Dump(LPCTSTR szName,int nVal);
    static void Dump(LPCTSTR szName,bool bVal);
    static void Dump(LPCTSTR szName,LPDIACTIONFORMAT lpVal);
    static void Dump(LPCTSTR szName,LPDIDEVICEIMAGEINFOHEADER lpVal);
    static void Dump(LPCTSTR szName,LPCTSTR lpVal);
    static void Dump(LPCTSTR szName,LPTSTR lpVal);
    static void Dump(LPCTSTR szName,LPCGUID lpVal);
    static void Dump(LPCTSTR szName,LPCDIDEVICEOBJECTINSTANCE lpVal);
    static void Dump(LPCTSTR szName,const GUID &guid);
    static void Dump(LPCTSTR szName,String &Val);
    static void Dump(LPCTSTR szName,DEVICEOBJLIST &Val);
};
// Initialize to 0 implicitly
DWORD CAdvancedTracer::s_dwFlags;
DWORD CAdvancedTracer::s_dwFlagsEx;
DWORD CAdvancedTracer::s_dwObjNo;
DWORD CAdvancedTracer::s_dwObjNoEx;
int CAdvancedTracer::s_nDeviceNo;
DWORD CAdvancedTracer::s_dwLevels;
String CAdvancedTracer::s_ExceptionBuffer;
LPCTSTR CAdvancedTracer::s_lpMethodName=_T("");
ObjectEntry CAdvancedTracer::s_eObjectEntry=eUnknownMethod;
CDIMapObj* CAdvancedTracer::s_lpMapObj;
FILE *CAdvancedTracer::s_pLogFile;
bool CAdvancedTracer::s_bException;

#define USETRACER() \
        CAdvancedTracer \
        There_can_be_only_one_USETRACER_macro_per_block;
#define METHOD_ENTRY(MethodName) \
        CAdvancedTracer \
        There_can_be_only_one_USETRACER_macro_per_block\
        (eFunctionBT,_T(#MethodName));
#define OBJECT_ENTRY(MethodName,MethodID) \
        CAdvancedTracer \
        There_can_be_only_one_USETRACER_macro_per_block\
        (eObjectEntryBT,MethodName,MethodID,this);
#define EXCEPTION(lpSourceFile,dwLine,hRes) \
        CAdvancedTracer \
        There_can_be_only_one_USETRACER_macro_per_block\
        (lpSourceFile,dwLine,hRes);
#define CDIMAPOBJ_ENTERED OBJECT_ENTRY\
    (_T("CDIMapObj"),eCDIMapObj);
#define _CDIMAPOBJ_ENTERED OBJECT_ENTRY\
    (_T("~CDIMapObj"),e_CDIMapObj);
#define ADDREF_ENTERED OBJECT_ENTRY\
    (_T("AddRef"),eAddRef);
#define RELEASE_ENTERED OBJECT_ENTRY\
    (_T("Release"),eRelease);
#define INITIALIZE_ENTERED OBJECT_ENTRY\
    (_T("Initialize"),eInitialize);
#define GETACTIONMAP_ENTERED OBJECT_ENTRY\
    (_T("GetActionMap"),eGetActionMap);
#define SAVEACTIONMAP_ENTERED OBJECT_ENTRY\
    (_T("SaveActionMap"),eSaveActionMap);
#define GETIMAGEINFO_ENTERED OBJECT_ENTRY\
    (_T("GetImageInfo"),eGetImageInfo);
#define WRITEVENDORFILE_ENTERED OBJECT_ENTRY\
    (_T("WriteVendorFile"),eWriteVendorFile);

#define TRACE CAdvancedTracer::OutputTraceString
#define TRACEI CAdvancedTracer::OutputTraceStringInfoEx

#define DUMP(P) CAdvancedTracer::Dump(_T(#P),P)
#define DUMPN(N,V) CAdvancedTracer::Dump(N,V)

#define TRACEGUID OutputDebugGuid
void OutputDebugGuid(const GUID &guid);
#define MAP_EXCEPTION(A) MapException(_T(__FILE__),__LINE__,A)

#else //_CHECKED

#define TRACE 1 ? 0 :
#define TRACEI 1 ? 0 :
#define DUMP(a)
#define DUMPN(a,b)
#define USETRACER()
#define METHOD_ENTRY(a)
#define OBJECT_ENTRY(a,b)
#define EXCEPTION(a,b,c)
#define CDIMAPOBJ_ENTERED
#define _CDIMAPOBJ_ENTERED
#define ADDREF_ENTERED
#define RELEASE_ENTERED
#define INITIALIZE_ENTERED
#define GETACTIONMAP_ENTERED
#define SAVEACTIONMAP_ENTERED
#define GETIMAGEINFO_ENTERED
#define WRITEVENDORFILE_ENTERED

#define TRACEGUID 0 ? 1 : (DWORD)&
#define MAP_EXCEPTION(A) MapException(A)

#endif //_CHECKED

#ifdef _CHECKED

CAdvancedTracer::CAdvancedTracer(
        BlockType eBlockType,
        LPCTSTR pMethodName,
        ObjectEntry eObjectEntry,
        CDIMapObj*lpMapObj)
{
    m_eBlockType=eBlockType;
    switch(m_eBlockType)
    {
    case eObjectEntryBT:
        s_bException=false;
        //default - no method is dumped
        s_dwFlags=GetProfileInt(_T("DEBUG"),_T("dinput.map"),0);
        //default - all methods are dumped during exception
        s_dwFlagsEx=GetProfileInt(_T("DEBUG"),_T("dinput.mapex"),-1);
        //default - all objects are dumped
        s_dwObjNo=GetProfileInt(_T("DEBUG"),_T("dinput.mapobj"),-1);
        //default - all objects are dumped during exception
        s_dwObjNoEx=GetProfileInt(_T("DEBUG"),_T("dinput.mapobjex"),-1);
        s_nDeviceNo=lpMapObj->GetDeviceNo();
        s_dwLevels=0;
        s_ExceptionBuffer.resize(0);
        s_lpMethodName=pMethodName;
        s_eObjectEntry=eObjectEntry;
        s_lpMapObj=lpMapObj;
        s_pLogFile=NULL;  // File handle used for outputing to file
        m_nExceptionBufferPos=0;
        TCHAR F[1024];
        if((GetProfileString(_T("DEBUG"),
            _T("dinput.maplogfile"),_T(""),
            F,1024)!=1023)&&F[0])
        {
            F[1023]=0;
            s_pLogFile=_tfopen(F,_T("a+"));
        }
TRACE(_T("____________________________________\
___________________________________________\n"));
        TRACE(_T("%s() entered, dump method id=%u, dump object id=%u\n"),
            s_lpMethodName,s_eObjectEntry,s_nDeviceNo);
        TRACE(_T("{\n"));
        break;
    case eFunctionBT:
        m_nExceptionBufferPos=s_ExceptionBuffer.size();
        TRACE(_T("%s()\n"),pMethodName);
        TRACE(_T("{\n"));
        break;
    case eSubBT:
        m_nExceptionBufferPos=s_ExceptionBuffer.size();
        break;
    }
    s_dwLevels++;
}

CAdvancedTracer::CAdvancedTracer(
        LPCTSTR lpSourceFile,
        DWORD dwLine,
        HRESULT hRes)
{
    m_eBlockType=eException;
    s_bException=true;

    DWORD dwOldLevels=s_dwLevels;
    s_dwLevels=0;
    TRACE(_T("MAPPER ERROR ******************************\n"));
    TRACE(_T("ERROR IN FILE: %s\n"),lpSourceFile);
    TRACE(_T("ERROR ON LINE: %d\n"),dwLine);
    TRACE(_T("hRes=0x%x\n"),hRes);
    switch(hRes)
    {
    case E_SYNTAX_ERROR:
        TRACE(_T("hRes=E_SYNTAX_ERROR\n"));
        break;
    case E_DEFINITION_NOT_FOUND:
        TRACE(_T("hRes=E_DEFINITION_NOT_FOUND\n"));
        break;
    case E_LINE_TO_LONG:
        TRACE(_T("hRes=E_LINE_TO_LONG\n"));
        break;
    case E_ACTION_NOT_DEFINED:
        TRACE(_T("hRes=E_ACTION_NOT_DEFINED\n"));
        break;
    case E_DEVICE_NOT_DEFINED:
        TRACE(_T("hRes=E_DEVICE_NOT_DEFINED\n"));
        break;
    case E_VENDORID_NOT_FOUND:
        TRACE(_T("hRes=E_VENDORID_NOT_FOUND\n"));
        break;
    case E_PRODUCTID_NOT_FOUND:
        TRACE(_T("hRes=E_PRODUCTID_NOT_FOUND\n"));
        break;
    case E_USAGE_NOT_FOUND:
        TRACE(_T("hRes=E_USAGE_NOT_FOUND\n"));
        break;
    case E_USAGEPAGE_NOT_FOUND:
        TRACE(_T("hRes=E_USAGEPAGE_NOT_FOUND\n"));
        break;
    case E_DEVICE_NOT_FOUND:
        TRACE(_T("hRes=E_DEVICE_NOT_FOUND\n"));
        break;
    case E_BAD_VERSION:
        TRACE(_T("hRes=E_BAD_VERSION\n"));
        break;
    case E_DEVICE_MISSING_CONTROL:
        TRACE(_T("hRes=E_DEVICE_MISSING_CONTROL\n"));
        break;
    case E_DEV_OBJ_NOT_FOUND:
        TRACE(_T("hRes=E_DEV_OBJ_NOT_FOUND\n"));
        break;
    case E_CTRL_W_OFFSET_NOTFOUND:
        TRACE(_T("hRes=E_CTRL_W_OFFSET_NOTFOUND\n"));
        break;
    case E_FILENAME_TO_LONG:
        TRACE(_T("hRes=E_FILENAME_TO_LONG\n"));
        break;
    case E_WRONG_ALIGN_DATA:
        TRACE(_T("hRes=E_WRONG_ALIGN_DATA\n"));
        break;
    case E_CORRUPT_IMAGE_DATA:
        TRACE(_T("hRes=E_CORRUPT_IMAGE_DATA\n"));
        break;
    case E_OUTOFMEMORY:
        TRACE(_T("hRes=E_OUTOFMEMORY\n"));
        break;
    case E_INVALIDARG:
        TRACE(_T("hRes=E_INVALIDARG\n"));
        break;
    case DIERR_NOTINITIALIZED:
        TRACE(_T("hRes=DIERR_NOTINITIALIZED\n"));
        break;
    case E_FAIL:
        TRACE(_T("hRes=E_FAIL\n"));
        break;
    default :
        TRACE(_T("hRes=UNKNOWN ERROR.\n"));
        break;
    }
    TRACE(_T("ERROR INFO:\n"));

    if(DumpFlagEx())
    {
        if(s_ExceptionBuffer.data())
        {
            LPCTSTR p=s_ExceptionBuffer.data();
            TCHAR C[2];
            C[1]=0;
            while(*p)
            {
                C[0]=*p;
                OutputDebugString(C);
                Sleep(0);
                p++;
            };
            //OutputDebugString(s_ExceptionBuffer.data());
            if (s_pLogFile)
            {
                _ftprintf(s_pLogFile,s_ExceptionBuffer.data());
            }
        }
    }
    TRACE(_T("ERROR HAPPENED HERE -->\n"));

    s_ExceptionBuffer.resize(0);
    s_dwLevels=dwOldLevels+1;
}

CAdvancedTracer::~CAdvancedTracer()
{
    --s_dwLevels;
    switch(m_eBlockType)
    {
    case eObjectEntryBT:
        TRACE(_T("}\n"));
        TRACE(_T("%s leaving\n"),s_lpMethodName);
TRACE(_T("____________________________________\
___________________________________________\n"));
        s_dwFlags=0;
        s_dwFlagsEx=-1;
        s_dwObjNo=-1;
        s_dwObjNoEx=-1;
        s_nDeviceNo=-1;
        s_dwLevels=0;
        s_ExceptionBuffer.resize(0);
        s_lpMethodName=_T("");
        s_eObjectEntry=eUnknownMethod;
        s_lpMapObj=NULL;
        if(s_pLogFile)
            fclose(s_pLogFile);
        s_pLogFile=NULL;
        break;
    case eFunctionBT:
        TRACE(_T("}\n"));
        break;
    case eSubBT:
        break;
    case eException:
        break;
    }
    if((m_eBlockType!=eObjectEntryBT)&&
        (m_eBlockType!=eSubBT))
    {
        if(!ExProcessing())
            s_ExceptionBuffer.resize(m_nExceptionBufferPos);
    }
}

bool CAdvancedTracer::DumpFlag(bool bInfoEx)
{
    if((s_dwObjNo==-1)||(s_dwObjNo==s_nDeviceNo))
        if(s_dwFlags&s_eObjectEntry)
            return true;
    if(bInfoEx)
        if((s_dwObjNoEx==-1)||(s_dwObjNoEx==s_nDeviceNo))
            if(s_dwFlagsEx&s_eObjectEntry)
                return true;
    return false;
}

bool CAdvancedTracer::DumpFlagEx()
{
    if((s_dwObjNoEx==-1)||(s_dwObjNoEx==s_nDeviceNo))
        if(s_dwFlagsEx&s_eObjectEntry)
            return true;
    return false;
}

void CAdvancedTracer::OutputTraceString(LPCTSTR szFmt, ...)
{
    va_list argptr;
    va_start(argptr, szFmt);
    OutputTraceStringI(false,szFmt,argptr);
    va_end(argptr);
}

void CAdvancedTracer::OutputTraceStringInfoEx(LPCTSTR szFmt, ...)
{
    va_list argptr;
    va_start(argptr, szFmt);
    OutputTraceStringI(true,szFmt,argptr);
    va_end(argptr);
}

// Warning: This function is not thread safe.
void CAdvancedTracer::OutputTraceStringI(bool bInfoEx,
                                         LPCTSTR szFmt,va_list argptr)
{
    const cBufSize=1024;    
    TCHAR szBuf[cBufSize];
    szBuf[cBufSize-1]=0;
    
    // Print the identation first
    int nCnt=s_dwLevels;
    if(nCnt>cBufSize-1)nCnt=cBufSize-1;
    for (DWORD i = 0; i < nCnt; ++i)
    {
        szBuf[i]=_T(' ');
    }
    szBuf[i]=0;

    // Then print the content
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,szFmt);									// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))						// find each %p
			*(psz+1) = 'x';										// replace each %p with %x
	    _vsntprintf(&szBuf[i], cBufSize-1-i, szDfs, argptr);	// use the local format string
	}
#else
	{
	    _vsntprintf(&szBuf[i], cBufSize-1-i, szFmt, argptr);
	}
#endif
    szBuf[cBufSize-1]=0;

    if((!ExProcessing())&&DumpFlagEx())
        s_ExceptionBuffer+=szBuf;

    if(DumpFlag(bInfoEx)||(ExProcessing()&&DumpFlagEx()))
    {
        OutputDebugString(szBuf);
        if (s_pLogFile)
        {
            _ftprintf(s_pLogFile, szBuf);
        }
    }
}

void CAdvancedTracer::Dump(LPCTSTR szName,DWORD dwVal)
{
    TRACE(_T("%s=%u\n"),szName,(unsigned int)dwVal);
}

void CAdvancedTracer::Dump(LPCTSTR szName,int nVal)
{
    TRACE(_T("%s=%d\n"),szName,(unsigned int)nVal);
}

void CAdvancedTracer::Dump(LPCTSTR szName,String &Val)
{
    if(Val.data())
        TRACE(_T("%s=%s\n"),szName,Val.data());
    else
        TRACE(_T("%s=NULL\n"),szName);
}

void CAdvancedTracer::Dump(LPCTSTR szName,bool bVal)
{
    TRACE(_T("%s=%u\n"),szName,(unsigned int)bVal);
}

void CAdvancedTracer::Dump(LPCTSTR szName,DEVICEOBJLIST &Val)
{
    TRACE(_T("%s:\n"),szName);
    USETRACER();
    TRACE(_T("UsagePage\tUsage\tType\tFlags\tName\n"));
    DEVICEOBJLIST::iterator DevObjIt;
    for(DevObjIt=Val.begin();DevObjIt!=Val.end();DevObjIt++)
    {
        TRACE(_T("%u\t%u\t0x%x\t0x%x\t%s\n"),
            DevObjIt->dwUsagePage,
            DevObjIt->dwUsage,
            DevObjIt->dwType,
            DevObjIt->dwFlags,
            DevObjIt->Name.data());
    }    
}

void CAdvancedTracer::Dump(LPCTSTR szName,LPDIACTIONFORMAT lpVal)
{
	// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    TRACE(_T("%s=0x%p\n"),szName,lpVal);
    if(lpVal)
    {
        USETRACER();
        TRACE(_T("dwSize=%u\tdwActionSize=%u\n"),
            (unsigned int)lpVal->dwSize,
            (unsigned int)lpVal->dwActionSize);
        TRACE(_T("guidActionMap="));TRACEGUID(lpVal->guidActionMap);
        TRACE(_T("dwGenre=0x%x\tGenre=%u\n"),
            (unsigned int)lpVal->dwGenre,
            (unsigned int)DISEM_GENRE_GET(lpVal->dwGenre));
        TRACE(_T("dwNumActions=%u\trgoAction=0x%x\n"),
            (unsigned int)lpVal->dwNumActions,
            lpVal->rgoAction);
        TRACE(_T("ftTimeStamp.dwHighDateTime=0x%x\t"),
            (unsigned int)lpVal->ftTimeStamp.dwHighDateTime);
        TRACE(_T("ftTimeStamp.dwLowDateTime=0x%x\n"),
            (unsigned int)lpVal->ftTimeStamp.dwLowDateTime);
		// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        TRACE(_T("rgoAction=0x%p\n"),lpVal);
        if(lpVal->rgoAction)
        {
            USETRACER();
TRACE(_T("Action No\tdwSemantic\tSemantic\tSemantic type\tdwFlags\t\
dwObjID\tdwHow\tguidInstance\n"));
            for(DWORD i=0;i<lpVal->dwNumActions;i++)
            {
                LPCTSTR p;
                if(DISEM_TYPE_GET(lpVal->rgoAction[i].dwSemantic)==
                        DISEM_TYPE_GET(DISEM_TYPE_AXIS))
                    p=_T("DISEM_TYPE_AXIS");
                else if(DISEM_TYPE_GET(lpVal->rgoAction[i].dwSemantic)==
                        DISEM_TYPE_GET(DISEM_TYPE_BUTTON))
                    p=_T("DISEM_TYPE_BUTTON");
                else if(DISEM_TYPE_GET(lpVal->rgoAction[i].dwSemantic)==
                        DISEM_TYPE_GET(DISEM_TYPE_POV))
                    p=_T("DISEM_TYPE_POV");
                else
                    p=_T("");

                TRACE(_T("%u\t0x%x\t%u\t%u %s\t0x%x\t0x%x\t0x%x\t"),
                    i,
                    (unsigned int)lpVal->rgoAction[i].dwSemantic,
                    (unsigned int)DISEM_INDEX_GET
                        (lpVal->rgoAction[i].dwSemantic),
                    (unsigned int)DISEM_TYPE_GET
                        (lpVal->rgoAction[i].dwSemantic),p,
                    (unsigned int)lpVal->rgoAction[i].dwFlags,
                    (unsigned int)lpVal->rgoAction[i].dwObjID,
                    (unsigned int)lpVal->rgoAction[i].dwHow);
                TRACEGUID(lpVal->rgoAction[i].guidInstance);
            }
        }
    }
}

void CAdvancedTracer::Dump(LPCTSTR szName,LPDIDEVICEIMAGEINFOHEADER lpVal)
{
	// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    TRACE(_T("%s=0x%p\n"),szName,lpVal);
    if(lpVal)
    {
        USETRACER();
        TRACE(_T("dwSize=%u\tdwSizeImageInfo=%u\n"),
            (unsigned int)lpVal->dwSize,
            (unsigned int)lpVal->dwSizeImageInfo);
        TRACE(_T("dwcViews=%u\tdwcButtons=%u\n"),
            (unsigned int)lpVal->dwcViews,
            (unsigned int)lpVal->dwcButtons);
        TRACE(_T("dwcAxes=%u\tdwcPOVs=%u\n"),
            (unsigned int)lpVal->dwcAxes,
            (unsigned int)lpVal->dwcPOVs);
        TRACE(_T("dwBufferSize=%u\tdwBufferUsed=%u\n"),
            (unsigned int)lpVal->dwBufferSize,
            (unsigned int)lpVal->dwBufferUsed);
		// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        TRACE(_T("lprgImageInfoArray=0x%p\n"),lpVal->lprgImageInfoArray);
        if(lpVal->lprgImageInfoArray)
        {
            USETRACER();
TRACE(_T("tszImagePath\ndwFlags\tdwViewID\trcOverlay\tdwObjID\t\
dwcValidPts\trcCalloutRect\tdwTextAlign\n"));
            for(DWORD i=0;i<(lpVal->dwBufferSize/
                sizeof(lpVal->lprgImageInfoArray[0]));i++)
            {
                TCHAR tszImagePath[MAX_PATH];
                memcpy(&tszImagePath,
                    &lpVal->lprgImageInfoArray[i].tszImagePath,
                    sizeof(tszImagePath));
                tszImagePath[MAX_PATH-1]=0;
                TRACE(_T("%s\n"),&tszImagePath);
                TRACE(_T("0x%x\t"),lpVal->lprgImageInfoArray[i].dwFlags);
                TRACE(_T("%u\t"),lpVal->lprgImageInfoArray[i].dwViewID);
                TRACE(_T("[%u,%u],[%u,%u]\t"),
                    lpVal->lprgImageInfoArray[i].rcOverlay.left,
                    lpVal->lprgImageInfoArray[i].rcOverlay.top,
                    lpVal->lprgImageInfoArray[i].rcOverlay.right,
                    lpVal->lprgImageInfoArray[i].rcOverlay.bottom);
                TRACE(_T("0x%x\t"),lpVal->lprgImageInfoArray[i].dwObjID);
                TRACE(_T("%u\t"),lpVal->lprgImageInfoArray[i].dwcValidPts);
                const int nPnts=
                    sizeof(lpVal->lprgImageInfoArray[i].rgptCalloutLine)/
                    sizeof(lpVal->lprgImageInfoArray[i].rgptCalloutLine[0]);
                TRACE(_T("[%u,%u],[%u,%u]\t"),
                    lpVal->lprgImageInfoArray[i].rcCalloutRect.left,
                    lpVal->lprgImageInfoArray[i].rcCalloutRect.top,
                    lpVal->lprgImageInfoArray[i].rcCalloutRect.right,
                    lpVal->lprgImageInfoArray[i].rcCalloutRect.bottom);
                TRACE(_T("0x%x\n"),lpVal->lprgImageInfoArray[i].dwTextAlign);
            }
        }
    }
}

void CAdvancedTracer::Dump(LPCTSTR szName,LPCTSTR lpVal)
{
    if(lpVal)
        TRACE(_T("%s=%s\n"),szName,lpVal);
    else
        TRACE(_T("%s=NULL\n"),szName);
}

void CAdvancedTracer::Dump(LPCTSTR szName,LPTSTR lpVal)
{
    Dump(szName,(LPCTSTR)lpVal);
}

void CAdvancedTracer::Dump(LPCTSTR szName,LPCDIDEVICEOBJECTINSTANCE lpVal)
{
	// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    TRACE(_T("%s=0x%p\n"),szName,lpVal);
    if(lpVal)
    {
        USETRACER();
		// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        TRACE(_T("tszName=0x%p\n"),lpVal->tszName);
        if(lpVal->tszName)
        {
            USETRACER();
            TRACE(_T("%s\n"),lpVal->tszName);
        }
        TRACE(_T("dwOfs=%u\n"),(unsigned int)lpVal->dwOfs);
        TRACE(_T("wUsagePage=%u\n"),(unsigned int)lpVal->wUsagePage);
        TRACE(_T("wUsage=%u\n"),(unsigned int)lpVal->wUsage);
        TRACE(_T("dwType=%u\n"),(unsigned int)lpVal->dwType);
        if(lpVal->dwType&DIDFT_RELAXIS)
            TRACE(_T("dwType&=DIDFT_RELAXIS\n"));
        if(lpVal->dwType&DIDFT_ABSAXIS)
            TRACE(_T("dwType&=DIDFT_ABSAXIS\n"));
        if(lpVal->dwType&DIDFT_PSHBUTTON)
            TRACE(_T("dwType&=DIDFT_PSHBUTTON\n"));
        if(lpVal->dwType&DIDFT_TGLBUTTON)
            TRACE(_T("dwType&=DIDFT_TGLBUTTON\n"));
        if(lpVal->dwType&DIDFT_POV)
            TRACE(_T("dwType&=DIDFT_POV\n"));
    }
}

void CAdvancedTracer::Dump(LPCTSTR szName,const GUID &guid)
{
    TRACE(_T("%s="),szName);
    OutputDebugGuid(guid);
}

void CAdvancedTracer::Dump(LPCTSTR szName,LPCGUID lpVal)
{
    if(lpVal)
    {
        TRACE(_T("%s="),szName);
        OutputDebugGuid(*lpVal);
    }
    else
        TRACE(_T("%s=NULL\n"),szName);

}

void OutputDebugGuid(const GUID &guid)
{
    TRACE(_T("{%08X-%04hX-%04hX-%02hX%02hX-%02X%02X%02X%02X%02X%02X}\n"),
        guid.Data1,
        guid.Data2,
        guid.Data3,
        (WORD)guid.Data4[0], (WORD)guid.Data4[1],
        (WORD)guid.Data4[2], (WORD)guid.Data4[3],
        (WORD)guid.Data4[4], (WORD)guid.Data4[5],
        (WORD)guid.Data4[6], (WORD)guid.Data4[7]);
}

#endif //_CHECKED

/******************************************************************************
 *
 * Exception Handler
 *
 *****************************************************************************/

MapException::MapException(
#ifdef _CHECKED
    LPCTSTR lpSourceFile,DWORD dwLine,
#endif
    HRESULT hRes)
{
    m_hRes=hRes;
    EXCEPTION(lpSourceFile,dwLine,hRes);
}

/******************************************************************************
 *
 * String Processing
 *
 *****************************************************************************/

void ToUpper(String &S)
{
    CharUpperBuff((LPTSTR)S.data(),S.size());

    for(StrIter B=S.begin();B<S.end();B++)
    {
        if(!IsSpace(*B))break;
    }
    for(StrIter E=S.end();E>S.begin();E--)
    {
        if(!(IsSpace(*(E-1))||(0==*(E-1))))break;
    }
    String R;
    while(B<E)
    {
        if(*B)
            R+=*B;
        B++;
    }
    S=R;
}

String GUID2String(const GUID &G)
{
    String Ret;
    OLECHAR S[256];
    if(!StringFromGUID2(G,S,255))
        throw MAP_EXCEPTION(E_OUTOFMEMORY);
    S[255]=0;
    
    int i;
    for(i=0;i<256;i++)
    {
        if(!S[i])break;
        Ret+=(TCHAR)__toascii(S[i]);
    }
    
    ToUpper(Ret);
    return Ret;
}

String N2Str(DWORD N)
{
    String Ret;
    _TCHAR S[32];
    if(_sntprintf(S,32,_T("%d"),N)<0)
        throw MAP_EXCEPTION(E_OUTOFMEMORY);
    S[31]=0;
    Ret=S;
    return Ret;
}

void SkipWS(StrIter &Pos)
{
    while(IsSpace(*Pos))
        Pos++;
}

BOOL IsComma(StrIter &Pos)
{
    if(*Pos==SEPARATOR)
    {
        Pos++;
        return TRUE;
    }
    return FALSE;
}

void Eat(StrIter &Pos,TCHAR Ch)
{
    if(*Pos!=Ch)
    {
        TRACE(_T("Error in ini file, key value.\n"));
        throw MAP_EXCEPTION(E_SYNTAX_ERROR);
    }
    Pos++;
}

DWORD GetNum(StrIter &Pos)
{
    DWORD dwRet=0;
    String S;
    StrIter OldPos;
    OldPos=Pos;
    //Read each character, verify it is a number and append
    while(isdigit(*Pos))
    {
        S+=*Pos;
        Pos++;
    }
    if(Pos==OldPos)//There must be a string
    {
        TRACE(_T("Error in ini file, in key numeric value.\n"));
        throw MAP_EXCEPTION(E_SYNTAX_ERROR);
    }
    int nR=_stscanf(S.data(),_T("%d"),&dwRet);
    if((nR==EOF)||(nR==0))
    {
        TRACE(_T("Error in ini file, in key numeric value.\n"));
        throw MAP_EXCEPTION(E_SYNTAX_ERROR);
    }
    return dwRet;
}

bool ReadString(StrIter &Pos,String &S,bool bNoStringOK=false)
{
    StrIter OldPos;
    //String has no white spaces
    OldPos=Pos;
    //Read each character, verify it is a string character and append
    while(!((*Pos==SEPARATOR)||(*Pos==0)))
    {
        S+=*Pos;
        Pos++;
    }
    if(Pos==OldPos)//If no string
    {
        if(!bNoStringOK)
        {
            TRACE(_T("Error in ini file, in key string.\n"));
            throw MAP_EXCEPTION(E_SYNTAX_ERROR);
        }
        else
            return false;
    }
    return true;
}

bool LoadString(String &S,LPCTSTR lpFileName,LPCTSTR lpSectionName,
    LPCTSTR lpKeyName,bool bNoThrow=false)
{
    METHOD_ENTRY(LoadString);
    DUMP(lpFileName);
    DUMP(lpSectionName);
    DUMP(lpKeyName);

    //Load line from a file
    TCHAR L[1024];
    if(GetPrivateProfileString(lpSectionName,lpKeyName,RESERVED_STRING,
        L,1024,lpFileName)==1023)
    {
        TRACE(_T("Line in file is too long.\n"));
        throw MAP_EXCEPTION(E_LINE_TO_LONG);
    }
    L[1023]=0;
    String Line=L;
    if((Line==RESERVED_STRING)||(Line==_T("")))
    {
        if(!bNoThrow)
        {
            TRACE(_T("No such section, key or key is empty.\n"));
            throw MAP_EXCEPTION(E_DEFINITION_NOT_FOUND);
        }
        else
            return false;
    }
    S=_T("");
    StrIter Pos=Line.begin();
    //Read single string
    ReadString(Pos,S);
    //To upper case and throw away spaces infront and back
    ToUpper(S);
    if(S==_T(""))//There must be a string
    {
        TRACE(_T("No such section, key or key is empty.\n"));
        throw MAP_EXCEPTION(E_SYNTAX_ERROR);
    }
    //Must end with 0
    if(*Pos!=0)
    {
        TRACE(_T("String corrupted.\n"));
        throw MAP_EXCEPTION(E_SYNTAX_ERROR);
    }
    return true;
}

bool LoadPointArray(LPCTSTR lpFileName,LPCTSTR lpSectionName,
    LPCTSTR lpKeyName,LPPOINT pPt,DWORD &dwCount,DWORD dwSize)
{
    METHOD_ENTRY(LoadPointArray);
    DUMP(lpFileName);
    DUMP(lpSectionName);
    DUMP(lpKeyName);

    dwCount=0;
    //Load line with strings
    TCHAR L[1024];
    if(GetPrivateProfileString(lpSectionName,lpKeyName,RESERVED_STRING,
            L,1024,lpFileName)==1023)
    {
        TRACE(_T("Line in file is too long.\n"));
        throw MAP_EXCEPTION(E_LINE_TO_LONG);
    }
    L[1023]=0;
    String Line=L;
    if((Line==RESERVED_STRING)||(Line==_T("")))
        return false;
    
    ToUpper(Line);
    
    StrIter Pos=Line.begin();
    do
    {
        if(dwCount==dwSize)
            break;
        SkipWS(Pos);
        Eat(Pos,_T('('));
        pPt[dwCount].x=GetNum(Pos);
        SkipWS(Pos);
        Eat(Pos,_T(','));
        SkipWS(Pos);
        pPt[dwCount].y=GetNum(Pos);
        SkipWS(Pos);
        Eat(Pos,_T(')'));
        SkipWS(Pos);
        dwCount++;
        
        //Repeat while comma is found
    }while(IsComma(Pos));
    //      if(!dwCount)
    //              throw MAP_EXCEPTION4(E_SYNTAX_ERROR);
    
    return true;
}

bool LoadListOfStrings(LPCTSTR lpFileName,LPCTSTR lpSectionName,
                       LPCTSTR lpKeyName,STRINGLIST &StrList,
                       bool bNoThrow=false)
{
    METHOD_ENTRY(LoadListOfStrings);
    DUMP(lpFileName);
    DUMP(lpSectionName);
    DUMP(lpKeyName);

    //Load line with strings
    TCHAR L[1024];
    if(GetPrivateProfileString(lpSectionName,lpKeyName,RESERVED_STRING,
        L,1024,lpFileName)==1023)
    {
        TRACE(_T("Line in file is too long.\n"));
        throw MAP_EXCEPTION(E_LINE_TO_LONG);
    }
    L[1023]=0;
    String Line=L;
    if((Line==RESERVED_STRING)||(Line==_T("")))
    {
        if(!bNoThrow)
        {
            TRACE(_T("No such section, key or key is empty.\n"));
            throw MAP_EXCEPTION(E_DEFINITION_NOT_FOUND);
        }
        else
            return false;
    }
    
    StrIter Pos=Line.begin();
    CS S;
    //Read first string, must be there
    ReadString(Pos,S);
    //To upper case and throw away spaces infront and back
    ToUpper(S);
    if(S==_T(""))//There must be a string
    {
        TRACE(_T("No such section, key or key is empty.\n"));
        throw MAP_EXCEPTION(E_SYNTAX_ERROR);
    }
    //Store string into the list
    StrList.push_back(S);
    //Repeat while comma is found
    while(IsComma(Pos))
    {
        CS S;
        //Read next string, does not have to be there
        if(ReadString(Pos,S,true))
        {
            //String found
            //To upper case and throw away spaces infront and back
            ToUpper(S);
            //Check if string, if no cont.
            if(S==_T(""))
                continue;
            //Store string into the list
            StrList.push_back(S);
        }
    }
    if(*Pos!=0)//Must end with 0
    {
        TRACE(_T("Corrupt string list.\n"));
        throw MAP_EXCEPTION(E_SYNTAX_ERROR);
    }
    return true;
}

void WritePrivateProfileIntX(LPCTSTR lpAppName,LPCTSTR lpKeyName,
                             UINT Value,LPCTSTR lpFileName)
{
    METHOD_ENTRY(WritePrivateProfileIntX);
    DUMP(lpFileName);
    DUMP(lpAppName);
    DUMP(lpKeyName);

    TCHAR ValBuf[16];
    wsprintf(ValBuf,TEXT("0x%X"),Value);
    if(!WritePrivateProfileString(lpAppName,lpKeyName,
        ValBuf,lpFileName))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
}

void WritePrivateProfileInt(LPCTSTR lpAppName,LPCTSTR lpKeyName,
                            INT Value,LPCTSTR lpFileName)
{
    METHOD_ENTRY(WritePrivateProfileInt);
    DUMP(lpFileName);
    DUMP(lpAppName);
    DUMP(lpKeyName);

    TCHAR ValBuf[16];
    wsprintf(ValBuf,TEXT("%i"),Value);
    if(!WritePrivateProfileString(lpAppName,lpKeyName,
        ValBuf,lpFileName))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
}

void WriteRect(LPCTSTR pSection,LPCTSTR pKey,LPRECT pR,LPCTSTR pFile)
{
    METHOD_ENTRY(WriteRect);
    DUMP(pFile);
    DUMP(pSection);
    DUMP(pKey);

    String Rect;
    Rect+=_T("(")+N2Str(pR->left)+_T(",")+N2Str(pR->top)+
        _T("),(")+N2Str(pR->right)+_T(",")+N2Str(pR->bottom)+_T(")");
    if(!WritePrivateProfileString(pSection,pKey,Rect.data(),pFile))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
}

void WritePointArray(LPCTSTR pSection,LPCTSTR pKey,LPPOINT pP,
                     int N,LPCTSTR pFile)
{
    METHOD_ENTRY(WritePointArray);
    DUMP(pFile);
    DUMP(pSection);
    DUMP(pKey);

    String LineData;
    for(DWORD i=0;i<N;i++)
    {
        LineData+=_T("(")+N2Str(pP[i].x)+_T(",")+N2Str(pP[i].y)+_T(")");
        if(i<(N-1))
            LineData+=_T(",");
    }
    if(!WritePrivateProfileString(pSection,pKey,LineData.data(),pFile))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
}

void WriteListOfStrings(LPCTSTR pSection,LPCTSTR pKey,
                        STRINGLIST &Values,LPCTSTR pFile)
{
    METHOD_ENTRY(WriteListOfStrings);
    DUMP(pFile);
    DUMP(pSection);
    DUMP(pKey);

    if(!Values.size())return;
    String List;
    List=*Values.begin();
    STRINGLIST::iterator ValuesIt=Values.begin();
    ValuesIt++;
    for(;ValuesIt!=Values.end();ValuesIt++)
        List=List+_T(",")+*ValuesIt;
    if(!WritePrivateProfileString(pSection,pKey,List.data(),pFile))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
}

void MakeUniqueName(String &InitialName,STRINGLIST &Names)
{
    METHOD_ENTRY(MakeUniqueName);
    for(int i=0;i<10000;i++)
    {
        CS S;
        S.assign(InitialName);
        if(i)
        {
            S+=_T("_");;
            S+=N2Str(i);
        }
        if(find(Names.begin(),Names.end(),S)==Names.end())
        {
            InitialName=S;
            Names.push_back(S);
            break;
        }
    }
    if(i==10000)//Could not find unique name after 10000 tries ???!!!
    {
        TRACE(_T("Could not generate unique name!?!?\n"));
        throw MAP_EXCEPTION(E_DEVICE_NOT_DEFINED);
    }
}

/******************************************************************************
 *
 * Directory/filename functions
 *
 *****************************************************************************/

void GetDirectory(LPCTSTR lpFullName,String &FullDir)
{
    if(lpFullName)
    {
        TCHAR Drive[_MAX_DRIVE];Drive[0]=0;
        TCHAR Dir[_MAX_DIR];Dir[0]=0;
        //	TCHAR FName[_MAX_FNAME];
        //	TCHAR Ext[_MAX_EXT];
        _tsplitpath(lpFullName,Drive,Dir,NULL,NULL);
        FullDir=Drive;
        FullDir+=Dir;
    }
}

void StripDirectory(LPCTSTR lpFullName,String &FileName)
{
    if(lpFullName)
    {
        //	TCHAR Drive[_MAX_DRIVE];Drive[0]=0;
        //	TCHAR Dir[_MAX_DIR];Dir[0]=0;
        TCHAR FName[_MAX_FNAME];
        TCHAR Ext[_MAX_EXT];
        _tsplitpath(lpFullName,NULL,NULL,FName,Ext);
        FileName=FName;
        FileName+=Ext;
    }
}

void GetHexCode(String &Ret,char In)
{
    switch(In&0x0f)
    {
    case 0x00:Ret+=_T('0');break;
    case 0x01:Ret+=_T('1');break;
    case 0x02:Ret+=_T('2');break;
    case 0x03:Ret+=_T('3');break;
    case 0x04:Ret+=_T('4');break;
    case 0x05:Ret+=_T('5');break;
    case 0x06:Ret+=_T('6');break;
    case 0x07:Ret+=_T('7');break;
    case 0x08:Ret+=_T('8');break;
    case 0x09:Ret+=_T('9');break;
    case 0x0A:Ret+=_T('A');break;
    case 0x0B:Ret+=_T('B');break;
    case 0x0C:Ret+=_T('C');break;
    case 0x0D:Ret+=_T('D');break;
    case 0x0E:Ret+=_T('E');break;
    case 0x0F:Ret+=_T('F');break;
    }
}

void MakeUniqueUserName(String &Ret,
                    LPCTSTR pIn)
{
    Ret=_T("");
    for(const TCHAR *p=pIn;*p!=0;p++)
    {
        switch(*p)
        {
        case _T('A'):
        case _T('a'):Ret+=_T('A');break;
        case _T('B'):
        case _T('b'):Ret+=_T('B');break;
        case _T('C'):
        case _T('c'):Ret+=_T('C');break;
        case _T('D'):
        case _T('d'):Ret+=_T('D');break;
        case _T('E'):
        case _T('e'):Ret+=_T('E');break;
        case _T('F'):
        case _T('f'):Ret+=_T('F');break;
        case _T('G'):
        case _T('g'):Ret+=_T('G');break;
        case _T('H'):
        case _T('h'):Ret+=_T('H');break;
        case _T('I'):
        case _T('i'):Ret+=_T('I');break;
        case _T('J'):
        case _T('j'):Ret+=_T('J');break;
        case _T('K'):
        case _T('k'):Ret+=_T('K');break;
        case _T('L'):
        case _T('l'):Ret+=_T('L');break;
        case _T('M'):
        case _T('m'):Ret+=_T('M');break;
        case _T('N'):
        case _T('n'):Ret+=_T('N');break;
        case _T('O'):
        case _T('o'):Ret+=_T('O');break;
        case _T('P'):
        case _T('p'):Ret+=_T('P');break;
        case _T('Q'):
        case _T('q'):Ret+=_T('Q');break;
        case _T('R'):
        case _T('r'):Ret+=_T('R');break;
        case _T('S'):
        case _T('s'):Ret+=_T('S');break;
        case _T('T'):
        case _T('t'):Ret+=_T('T');break;
        case _T('U'):
        case _T('u'):Ret+=_T('U');break;
        case _T('V'):
        case _T('v'):Ret+=_T('V');break;
        case _T('W'):
        case _T('w'):Ret+=_T('W');break;
//X: Special case. Make sure it is consistent
//with special case elsewhere.
        case _T('X'):
        case _T('x'):Ret+=_T("XX");break;
        case _T('Y'):
        case _T('y'):Ret+=_T('Y');break;
        case _T('Z'):
        case _T('z'):Ret+=_T('Z');break;
        case _T('1'):Ret+=_T('1');break;
        case _T('2'):Ret+=_T('2');break;
        case _T('3'):Ret+=_T('3');break;
        case _T('4'):Ret+=_T('4');break;
        case _T('5'):Ret+=_T('5');break;
        case _T('6'):Ret+=_T('6');break;
        case _T('7'):Ret+=_T('7');break;
        case _T('8'):Ret+=_T('8');break;
        case _T('9'):Ret+=_T('9');break;
        case _T('0'):Ret+=_T('0');break;
        case _T(' '):Ret+=_T(' ');break;
        case _T('('):Ret+=_T('(');break;
        case _T(')'):Ret+=_T(')');break;
        case _T('.'):Ret+=_T('.');break;
        case _T('_'):Ret+=_T('_');break;
        case _T('-'):Ret+=_T('-');break;
        case _T('&'):Ret+=_T('&');break;
        default:
//X: Special case. Make sure it is consistent
//with special case elsewhere.
            Ret+=_T("X");
            GetHexCode(Ret,(*p)>>12);
            GetHexCode(Ret,(*p)>>8);
            GetHexCode(Ret,(*p)>>4);
            GetHexCode(Ret,*p);
            break;
        }
    }
}
void MakeUniqueDeviceName(String &Ret,
                    LPCWSTR pIn/*This is hardcoded in dinput to WSTR*/)
{
    Ret=_T("");
    for(LPCWCH p=pIn;*p!=0;p++)
    {
        switch(*p)
        {
        case L'A':
        case L'a':Ret+=_T('A');break;
        case L'B':
        case L'b':Ret+=_T('B');break;
        case L'C':
        case L'c':Ret+=_T('C');break;
        case L'D':
        case L'd':Ret+=_T('D');break;
        case L'E':
        case L'e':Ret+=_T('E');break;
        case L'F':
        case L'f':Ret+=_T('F');break;
        case L'G':
        case L'g':Ret+=_T('G');break;
        case L'H':
        case L'h':Ret+=_T('H');break;
        case L'I':
        case L'i':Ret+=_T('I');break;
        case L'J':
        case L'j':Ret+=_T('J');break;
        case L'K':
        case L'k':Ret+=_T('K');break;
        case L'L':
        case L'l':Ret+=_T('L');break;
        case L'M':
        case L'm':Ret+=_T('M');break;
        case L'N':
        case L'n':Ret+=_T('N');break;
        case L'O':
        case L'o':Ret+=_T('O');break;
        case L'P':
        case L'p':Ret+=_T('P');break;
        case L'Q':
        case L'q':Ret+=_T('Q');break;
        case L'R':
        case L'r':Ret+=_T('R');break;
        case L'S':
        case L's':Ret+=_T('S');break;
        case L'T':
        case L't':Ret+=_T('T');break;
        case L'U':
        case L'u':Ret+=_T('U');break;
        case L'V':
        case L'v':Ret+=_T('V');break;
        case L'W':
        case L'w':Ret+=_T('W');break;
//X: Special case. Make sure it is consistent
//with special case elsewhere.
        case L'X':
        case L'x':Ret+=_T("XX");break;
        case L'Y':
        case L'y':Ret+=_T('Y');break;
        case L'Z':
        case L'z':Ret+=_T('Z');break;
        case L'1':Ret+=_T('1');break;
        case L'2':Ret+=_T('2');break;
        case L'3':Ret+=_T('3');break;
        case L'4':Ret+=_T('4');break;
        case L'5':Ret+=_T('5');break;
        case L'6':Ret+=_T('6');break;
        case L'7':Ret+=_T('7');break;
        case L'8':Ret+=_T('8');break;
        case L'9':Ret+=_T('9');break;
        case L'0':Ret+=_T('0');break;
        case L' ':Ret+=_T(' ');break;
        case L'(':Ret+=_T('(');break;
        case L')':Ret+=_T(')');break;
        case L'.':Ret+=_T('.');break;
        case L'_':Ret+=_T('_');break;
        case L'-':Ret+=_T('-');break;
        case L'&':Ret+=_T('&');break;
        default:
//X: Special case. Make sure it is consistent
//with special case elsewhere.
            Ret+=_T("X");
            GetHexCode(Ret,(*p)>>12);
            GetHexCode(Ret,(*p)>>8);
            GetHexCode(Ret,(*p)>>4);
            GetHexCode(Ret,*p);
            break;
        }
    }
}

void MakeSubDir(LPCTSTR lpDir)
{
    String DirCreationString=lpDir;
    DirCreationString+=_T("\\");
    LPTSTR lpPos=_tcschr(DirCreationString.data(),_T('\\'));
    if(!lpPos)
    {
TRACE(_T("Error creating user directory. Invalid parent directory.\n"));
         throw MAP_EXCEPTION(E_FAIL);    
    }
    lpPos=_tcschr(lpPos+1,_T('\\'));
    if(!lpPos)
    {
TRACE(_T("Error creating user directory. Invalid parent directory.\n"));
         throw MAP_EXCEPTION(E_FAIL);    
    }
    while(lpPos)
    {
        *lpPos=0;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                TRACE(_T("Error creating user directory.\n"));
                throw MAP_EXCEPTION(HRESULT_FROM_WIN32(dwErr));
            }
        }
        *lpPos=_T('\\');
        lpPos=_tcschr(lpPos+1,_T('\\'));
    }
}

void GetMapFileName(LPCTSTR lpctstrUserName,LPCTSTR lpctstrDeviceName,
                    int nDeviceInstanceNo,
                    LPTSTR szFileName/*_MAX_PATH*/,bool bCreateDir=false,
                    String *lpUserDir=NULL)
{
    HRESULT hRes=S_OK;

#ifdef WINNT
    
    //Allocate a pointer to an Item ID list
    LPITEMIDLIST pidl;

    hRes=SHGetSpecialFolderLocation(NULL,CSIDL_APPDATA,&pidl);
    if(FAILED(hRes))
    {
        TRACE(_T("Error calling SHGetSpecialFolderLocation().\n"));
        throw MAP_EXCEPTION(hRes);
    }
    //Convert the item ID list's binary
    //representation into a file system path
    if(!SHGetPathFromIDList(pidl,szFileName))
    {
        TRACE(_T("Error calling SHGetPathFromIDList().\n"));
    }
    szFileName[_MAX_PATH-1]=0;

    //Allocate a pointer to an IMalloc interface
    LPMALLOC pMalloc=NULL;

    //Get the address of our task allocator's IMalloc interface
    hRes=SHGetMalloc(&pMalloc);

    if((hRes==NOERROR)&&pMalloc)
    {
        //Free the item ID list allocated by SHGetSpecialFolderLocation
        pMalloc->Free(pidl);

        //Free our task allocator
        pMalloc->Release();
    }
#ifdef _CHECKED
    else
    {
TRACE(_T("RESOURCE LEAK! SHGetMalloc failed, can not free resource.\n"));
    }
#endif
    hRes=S_OK;//Could not release resource. Continue anyways.
    //There is nothing we can do.

    //Create directories if necessary.

    String DirCreationString=szFileName;
    //Check if directory name is too long
    if((_tcslen(szFileName)+_tcslen(MAP_DIR_NT)+1)>_MAX_PATH)
    {
        TRACE(_T("User dir name too long.\n"));
        throw MAP_EXCEPTION(E_FAIL);
    }
    _tcscat(szFileName,MAP_DIR_NT);
    if(lpUserDir)*lpUserDir=szFileName;
    //Create directory for map files
    if(bCreateDir)
    {
        //Create subdirs one by one
        TRACE(_T("Creating user directory %s.\n"),szFileName);
        DirCreationString+=MS_NAME;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                TRACE(_T("Error creating user directory.\n"));
                throw MAP_EXCEPTION(HRESULT_FROM_WIN32(dwErr));
            }
        }
        DirCreationString+=DIRECTX;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                TRACE(_T("Error creating user directory.\n"));
                throw MAP_EXCEPTION(HRESULT_FROM_WIN32(dwErr));
            }
        }
        DirCreationString+=DIRECTINPUT;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                TRACE(_T("Error creating user directory.\n"));
                throw MAP_EXCEPTION(HRESULT_FROM_WIN32(dwErr));
            }
        }
        DirCreationString+=USER_MAPS;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                TRACE(_T("Error creating user directory.\n"));
                throw MAP_EXCEPTION(HRESULT_FROM_WIN32(dwErr));
            }
        }
    }

    //Get user name
    if(!lpctstrUserName)
    {
        lpctstrUserName=DEFAULT_USER_NAME;
    }

#else//WINNT
    
    //For win9x get directory name from the registry
    HKEY Key=0;
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
        (DWORD)0,
        KEY_QUERY_VALUE,
        &Key)!=ERROR_SUCCESS)
    {
TRACE(_T("Error calling RegOpenKeyEx(HKEY_LOCAL_MACHINE\
\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion).\n"));
        throw MAP_EXCEPTION(E_FAIL);
    }

    DWORD dwType=REG_SZ;
    DWORD dwSize=MAX_PATH*sizeof(TCHAR);
    if(RegQueryValueEx(Key,_T("CommonFilesDir"),
        NULL,&dwType,(LPBYTE)szFileName,&dwSize)!=ERROR_SUCCESS)
    {
        TRACE(_T("Error calling RegQueryValueEx(CommonFilesDir).\n"));
        throw MAP_EXCEPTION(E_FAIL);
    }
    
    RegCloseKey(Key);

    //Create directories if necessary.

    String DirCreationString=szFileName;
    //Check if directory name is too long
    if((_tcslen(szFileName)+_tcslen(MAP_DIR)+1)>_MAX_PATH)
    {
        TRACE(_T("User dir name too long.\n"));
        throw MAP_EXCEPTION(E_FAIL);
    }
    _tcscat(szFileName,MAP_DIR);
    if(lpUserDir)*lpUserDir=szFileName;
    //Create directory for map files
    if(bCreateDir)
    {
        //Create subdirs one by one
        TRACE(_T("Creating user directory %s.\n"),szFileName);
        DirCreationString+=DIRECTX;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                //could be that Win95 Gold does not have "Common Files" dir
                MakeSubDir(DirCreationString.data());
            }
        }
        DirCreationString+=DIRECTINPUT;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                TRACE(_T("Error creating user directory.\n"));
                throw MAP_EXCEPTION(HRESULT_FROM_WIN32(dwErr));
            }
        }
        DirCreationString+=USER_MAPS;
        if(!CreateDirectory(DirCreationString.data(),NULL))
        {
            DWORD dwErr=GetLastError();
            if(dwErr!=ERROR_ALREADY_EXISTS)
            {
                TRACE(_T("Error creating user directory.\n"));
                throw MAP_EXCEPTION(HRESULT_FROM_WIN32(dwErr));
            }
        }
    }

    //Get user name
    TCHAR UN[UNLEN+1];
    if(!lpctstrUserName)
    {
        DWORD dwLen=UNLEN+1;
        GetUserName(UN,&dwLen);
        lpctstrUserName=UN;
    }

#endif //WINNT    
        
    //Create full path filename
    
    //Unique user name
    String UniqueUserName;
    MakeUniqueUserName(UniqueUserName,lpctstrUserName);

    //Device instance string
    String DevInst;
    DevInst=N2Str(nDeviceInstanceNo);

    if((_tcslen(szFileName)+1+_tcslen(UniqueUserName.data())+2+
        _tcslen(lpctstrDeviceName)+2+
        _tcslen(DevInst.data())+4+1)>_MAX_PATH)
    {
        TRACE(_T("User path file name too long.\n"));
        throw MAP_EXCEPTION(E_FAIL);
    }
    _tcscat(szFileName,_T("\\"));
    _tcscat(szFileName,UniqueUserName.data());

//X: Special case. Make sure it is consistent
//with special case elsewhere.
    _tcscat(szFileName,_T("X_"));

    _tcscat(szFileName,lpctstrDeviceName);

//X: Special case. Make sure it is consistent
//with special case elsewhere.
    _tcscat(szFileName,_T("X_"));

    _tcscat(szFileName,DevInst.data());
    _tcscat(szFileName,_T(".INI"));
}

/******************************************************************************
 *
 * ANSI/UNICODE parameter translation templates
 *
 *****************************************************************************/

int TrCopy(LPCSTR pszA,size_t nCharacters,LPWSTR pszW,size_t nSizeW)
{return MultiByteToWideChar(CP_ACP,0,pszA,nCharacters,pszW,nSizeW);};
int TrCopy(LPCOLESTR pszW,size_t nCharacters,LPSTR pszA,size_t nSizeA)
{return WideCharToMultiByte(CP_ACP,0,pszW,nCharacters,
                            pszA,nSizeA,NULL,NULL);};
size_t TrSize(LPCSTR pszA,size_t nSizeA){return nSizeA;};
size_t TrSize(LPCWSTR pszW,size_t nSizeW){return nSizeW*2;};
size_t TrStrLen(LPCSTR pszA){return strlen(pszA);};
size_t TrStrLen(LPCWSTR pszW){return wcslen(pszW);};
template <class StrTypeFrom,class StrTypeTo>
void Tr(StrTypeFrom *pszFrom,size_t nSizeFrom,
        StrTypeTo* pszTo,size_t nSizeTo)
{
    if(!TrCopy(pszFrom,TrStrLen(pszFrom)+1,pszTo,nSizeTo))
        throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    pszTo[nSizeTo-1]=0;
};
template <class StrTypeFrom,class StrTypeTo> class C2Base
{
protected:
    StrTypeTo *m_pszStrTo;
    size_t m_nSizeTo;
    StrTypeFrom *m_pszStrFrom;
    size_t m_nSizeFrom;
    bool m_bReturn;
public:
    C2Base(){m_pszStrTo=NULL;};
    ~C2Base(){delete m_pszStrTo;};
    operator StrTypeTo*(){return m_pszStrTo;};
    size_t Size(){return m_nSizeTo;};
    void Set(const StrTypeFrom *pszStrFrom=NULL,size_t nSizeFrom=-1)
    {
        //Delete old buffer
        delete m_pszStrTo;
        //Initialize members
        m_pszStrTo=NULL;
        m_nSizeTo=0;
        m_pszStrFrom=(StrTypeFrom*)pszStrFrom;
        m_nSizeFrom=nSizeFrom;
        m_bReturn=false;
        //Check if in string is 0
        if((!m_pszStrFrom)||(!nSizeFrom))
        {
            m_nSizeFrom=0;
            return;
        }
        //Get len of the in string
        if(m_nSizeFrom==-1)
            m_nSizeFrom=TrStrLen(m_pszStrFrom)+1;
        //Allocate buffer for translated string
        m_nSizeTo=TrSize(m_pszStrFrom,m_nSizeFrom);
        m_pszStrTo=new StrTypeTo[m_nSizeTo];
        if(m_nSizeTo)
            m_pszStrTo[0]=0;
        //Check if this is in or out param
        if((nSizeFrom!=-1))
            m_bReturn=true;
        //Translate
        if(!m_bReturn)
            Tr(m_pszStrFrom,m_nSizeFrom,m_pszStrTo,m_nSizeTo);
    }
};
template <class StrTypeFrom,class StrTypeTo> class C2:
public C2Base<StrTypeFrom,StrTypeTo>
{
public:
    C2(const StrTypeFrom *pszStrFrom=NULL,size_t nSizeFrom=-1)
    {Set(pszStrFrom,nSizeFrom);};
    ~C2(){if(m_bReturn)
        Tr(m_pszStrTo,m_nSizeTo,m_pszStrFrom,m_nSizeFrom);};
};

//This template translates between DIACTIONFORMATA and DIACTIONFORMATW
template <class IDFrom,class IDTo,class Act>
    class CTrDIACTIONFORMAT:public IDTo
{
    IDTo* m_pIDTo;
    IDFrom* m_pIDFrom;
public:
    CTrDIACTIONFORMAT(IDFrom *pIn)
    {
        m_pIDTo=NULL;
        m_pIDFrom=pIn;
        if(pIn)
        {
            dwSize=sizeof(IDTo);
            dwActionSize=pIn->dwActionSize;
            dwDataSize=0;
            dwNumActions=pIn->dwNumActions;
            guidActionMap=pIn->guidActionMap;
            dwGenre=pIn->dwGenre;
            rgoAction=(Act*)(pIn->rgoAction);
            dwBufferSize=0;
            lAxisMin=0;
            lAxisMax=0;
            hInstString=0;
            tszActionMap[0]=0;
            ftTimeStamp.dwLowDateTime=
                pIn->ftTimeStamp.dwLowDateTime;
            ftTimeStamp.dwHighDateTime=
                pIn->ftTimeStamp.dwHighDateTime;
            
            m_pIDTo=(IDTo*)this;
        }
    };
    ~CTrDIACTIONFORMAT()
    {
        if(m_pIDFrom&&m_pIDTo)
        {
            m_pIDFrom->ftTimeStamp.dwLowDateTime=
                m_pIDTo->ftTimeStamp.dwLowDateTime;
            m_pIDFrom->ftTimeStamp.dwHighDateTime=
                m_pIDTo->ftTimeStamp.dwHighDateTime;
        }
    }
    operator IDTo*(){return m_pIDTo;};
};

//This templates translate between DIDEVICEIMAGEINFOHEADERA and 
//DIDEVICEIMAGEINFOHEADERW
template <class IDTo> class CTrDIDEVICEIMAGEINFOHEADERB:public IDTo
{
public:
    CTrDIDEVICEIMAGEINFOHEADERB(){lprgImageInfoArray=NULL;};
    ~CTrDIDEVICEIMAGEINFOHEADERB(){delete lprgImageInfoArray;};
};

template <class StrTypeFrom,class StrTypeTo>
void TrDIDEVICEIMAGEINFO(StrTypeFrom *pszFrom,StrTypeTo* pszTo)
{
    Tr(pszFrom->tszImagePath,
        sizeof(pszFrom->tszImagePath)/sizeof(pszFrom->tszImagePath[0]),
        pszTo->tszImagePath,
        sizeof(pszTo->tszImagePath)/sizeof(pszTo->tszImagePath[0]));
    pszTo->dwFlags=pszFrom->dwFlags; 
    pszTo->dwViewID=pszFrom->dwViewID;      
    pszTo->rcOverlay=pszFrom->rcOverlay;             
    pszTo->dwObjID=pszFrom->dwObjID;            
    pszTo->rgptCalloutLine[0]=pszFrom->rgptCalloutLine[0];  
    pszTo->rgptCalloutLine[1]=pszFrom->rgptCalloutLine[1];  
    pszTo->rgptCalloutLine[2]=pszFrom->rgptCalloutLine[2];  
    pszTo->rgptCalloutLine[3]=pszFrom->rgptCalloutLine[3];  
    pszTo->rgptCalloutLine[4]=pszFrom->rgptCalloutLine[4];  
    pszTo->dwcValidPts=pszFrom->dwcValidPts;
    pszTo->rcCalloutRect=pszFrom->rcCalloutRect;  
    pszTo->dwTextAlign=pszFrom->dwTextAlign;     
}

template <class IDFrom,class IDTo,class IDFromImgInfo,class IDToImgInfo> 
class CTrDIDEVICEIMAGEINFOHEADER:public CTrDIDEVICEIMAGEINFOHEADERB<IDTo>
{
    IDTo* m_pIDTo;
    IDFrom* m_pIDFrom;
    bool m_bGet;
public:
    CTrDIDEVICEIMAGEINFOHEADER(IDFrom *pIn,bool bGet=true)
    {
        m_pIDTo=NULL;
        m_pIDFrom=pIn;
        m_bGet=bGet;
        if(pIn)
        {
            memset((IDTo*)this,0,sizeof(IDTo));
            
            if(pIn->dwSize==sizeof(IDFrom))
                dwSize=sizeof(IDTo);
            else
                dwSize=0;
            if(pIn->dwSizeImageInfo==sizeof(IDFromImgInfo))
                dwSizeImageInfo=sizeof(IDToImgInfo);
            else
                dwSizeImageInfo=0;
            //dwcViews=pIn->dwcViews;
            //dwcButtons=pIn->dwcButtons;
            //dwcAxes=pIn->dwcAxes;
            dwBufferSize=(pIn->dwBufferSize/
                sizeof(IDFromImgInfo))*sizeof(IDToImgInfo);
            dwBufferUsed=(pIn->dwBufferUsed/
                sizeof(IDFromImgInfo))*sizeof(IDToImgInfo);
            if(dwBufferSize&&pIn->lprgImageInfoArray)
            {
                lprgImageInfoArray=(IDToImgInfo*)new char[dwBufferSize];
//PREFIX #171787 new does not return NULL. Instead, exception is thrown and
//handled properly inside of catch block.
                memset(lprgImageInfoArray,0,dwBufferSize);
                for(int i=0;i<(dwBufferSize/sizeof(IDToImgInfo));i++)
                {
//PREFIX #34520 I do not see how m_pIDFrom or m_pIDFrom->lprgImageInfoArray
//can be NULL at this point.
                    if(!m_bGet)
                    {
                        TrDIDEVICEIMAGEINFO(
                            &m_pIDFrom->lprgImageInfoArray[i],
                            &lprgImageInfoArray[i]);
                    }
                }
            }
            m_pIDTo=(IDTo*)this;
        }
    };
    ~CTrDIDEVICEIMAGEINFOHEADER()
    {
        if(m_pIDFrom)
        {
            m_pIDFrom->dwcViews=dwcViews;
            //m_pIDFrom->dwcButtons=dwcButtons;
            //m_pIDFrom->dwcAxes=dwcAxes;
            m_pIDFrom->dwBufferUsed=(dwBufferUsed/
                sizeof(IDToImgInfo))*sizeof(IDFromImgInfo);
            if(m_pIDFrom->dwBufferSize)
            {
                for(int i=0;i<(dwBufferSize/sizeof(IDToImgInfo));i++)
                {
                    if(m_bGet)
                    {
                        TrDIDEVICEIMAGEINFO(&lprgImageInfoArray[i],
                            &m_pIDFrom->lprgImageInfoArray[i]);
                    }
                }
            }
            delete lprgImageInfoArray;
            lprgImageInfoArray=NULL;
        }
    };
    operator IDTo*(){return m_pIDTo;};
};

/*
template <class ActionFormat,class Action,class Str> class CDIAFAUBase
{
protected:
    Str m_ApplicationName;
    ActionFormat *m_pDIAF;
    ActionFormat m_DIAF;
    Action* m_lpDIA;
    Str *m_pA2U;
public:
    CDIAFAUBase()
    {
        m_pDIAF=NULL;
        m_lpDIA=NULL;
        m_pA2U=NULL;
    };
    ~CDIAFAUBase()
    {
        delete[] m_lpDIA;
        delete[] m_pA2U;
    };
    operator ActionFormat*(){return m_pDIAF;};
};
template <class ActionFormat,class Action,class Str,class ActionFormatFrom> 
class CDIAFAU:
public CDIAFAUBase <ActionFormat,Action,Str>
{
public:
    CDIAFAU(ActionFormatFrom lpDiActionFormat)
    {
        if(!lpDiActionFormat)return;
        memcpy(&m_DIAF,lpDiActionFormat,sizeof(m_DIAF));
        m_ApplicationName.Set(lpDiActionFormat->lptszActionMap);
        m_DIAF.lptszActionMap=m_ApplicationName;
        if(!(m_DIAF.dwNumActions&&m_DIAF.rgoAction))return;
        m_lpDIA=new Action[m_DIAF.dwNumActions];
        m_DIAF.rgoAction=m_lpDIA;
        m_pA2U=new Str[m_DIAF.dwNumActions];
        for(DWORD i=0;i<m_DIAF.dwNumActions;i++)
        {
            memcpy(&m_lpDIA[i],&lpDiActionFormat->rgoAction[i],
                sizeof(m_lpDIA[i]));
            m_pA2U[i].Set(lpDiActionFormat->rgoAction[i].lptszActionName);
            m_lpDIA[i].lptszActionName=m_pA2U[i];
        }
        m_pDIAF=&m_DIAF;
    };
};
*/
#define STARTTR try{
#define ENDTR }catch(MapException E){return E.GetResult();}\
    catch(exception){return E_OUTOFMEMORY;}

#ifdef UNICODE

#define U2A(P) P
#define DIAFU2A(P) P
#define IDW(P) P
typedef C2<CHAR,WCHAR> CA2U;
#define A2U(P) CA2U(P)
#define STARTTRA STARTTR
#define ENDTRA ENDTR
#define STARTTRW
#define ENDTRW
//DIACTIONFORMAT translation
typedef CTrDIACTIONFORMAT<DIACTIONFORMATA,DIACTIONFORMATW,DIACTIONW> 
    CDIACTIONFORMAT;
#define AFA(P) CDIACTIONFORMAT(P)
#define AFW(P) P
//DIDEVICEIMAGEINFOHEADER translation
typedef CTrDIDEVICEIMAGEINFOHEADER<DIDEVICEIMAGEINFOHEADERA,
    DIDEVICEIMAGEINFOHEADERW,DIDEVICEIMAGEINFOA,DIDEVICEIMAGEINFOW> 
    CDIDEVICEIMAGEINFOHEADER;
#define DIIHA(P) CDIDEVICEIMAGEINFOHEADER(P)
#define DIIHW(P) P
#define SETDIIHA(P) CDIDEVICEIMAGEINFOHEADER(P,false)
#define SETDIIHW(P) P

#else //ANSI

#define A2U(P) P
#define DIAFA2U(P) P
#define IDA(P) P
typedef C2<WCHAR,CHAR> CU2A;
#define U2A(P) CU2A(P)
#define STARTTRA
#define ENDTRA
#define STARTTRW STARTTR
#define ENDTRW ENDTR
//DIACTIONFORMAT translation
typedef CTrDIACTIONFORMAT<DIACTIONFORMATW,DIACTIONFORMATA,DIACTIONA> 
    CDIACTIONFORMAT;
#define AFA(P) P
#define AFW(P) CDIACTIONFORMAT(P)
//DIDEVICEIMAGEINFOHEADER translation
typedef CTrDIDEVICEIMAGEINFOHEADER<DIDEVICEIMAGEINFOHEADERW,
    DIDEVICEIMAGEINFOHEADERA,DIDEVICEIMAGEINFOW,DIDEVICEIMAGEINFOA> 
    CDIDEVICEIMAGEINFOHEADER;
#define DIIHA(P) P
#define DIIHW(P) CDIDEVICEIMAGEINFOHEADER(P)
#define SETDIIHA(P) P
#define SETDIIHW(P) CDIDEVICEIMAGEINFOHEADER(P,false)

#endif //ANSI

/******************************************************************************
 *
 * ANSI/UNICODE parameter translation
 *
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrA::
Initialize(
           LPCGUID lpThisGUIDInstance,
           LPCSTR lpcstrFileName,
           DWORD dwFlags)
{
    STARTTRA
        return InitializeI(lpThisGUIDInstance,A2U(lpcstrFileName),dwFlags);
    ENDTRA
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrA::
GetActionMap(
             LPDIACTIONFORMATA lpDiActionFormat,
             LPCSTR lpcstrUserName,
             FILETIME *pTimestamp,DWORD dwFlags)
{
    STARTTRA
        return GetActionMapI(AFA(lpDiActionFormat),A2U(lpcstrUserName),
            pTimestamp,dwFlags);
    ENDTRA
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrA::
SaveActionMap(
              LPDIACTIONFORMATA lpDiActionFormat,
              LPCSTR lpcstrUserName,
              DWORD dwFlags)
{
    STARTTRA
        return SaveActionMapI(AFA(lpDiActionFormat),A2U(lpcstrUserName),
            dwFlags);
    ENDTRA
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrA::
GetImageInfo(
             LPDIDEVICEIMAGEINFOHEADERA lpdiDevImageInfoHeader)
{
    STARTTRA
        return GetImageInfoI(DIIHA(lpdiDevImageInfoHeader));
    ENDTRA
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrA::
WriteVendorFile(
                LPDIACTIONFORMATA lpDiActionFormat,
                LPDIDEVICEIMAGEINFOHEADERA lpdiDevImageInfoHeader,
                DWORD dwFlags)
{
    STARTTRA
        return WriteVendorFileI(AFA(lpDiActionFormat),
            SETDIIHA(lpdiDevImageInfoHeader),dwFlags);
    ENDTRA
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrW::
Initialize(
           LPCGUID lpThisGUIDInstance,
           LPCWSTR lpcwstrFileName,
           DWORD dwFlags)
{
    STARTTRA
        return InitializeI(lpThisGUIDInstance,U2A(lpcwstrFileName),dwFlags);
    ENDTRA
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrW::
GetActionMap(
             LPDIACTIONFORMATW lpDiActionFormat,
             LPCWSTR lpcwstrUserName,
             FILETIME *pTimestamp,DWORD dwFlags)
{
    STARTTRW
        return GetActionMapI(AFW(lpDiActionFormat),U2A(lpcwstrUserName),
            pTimestamp,dwFlags);
    ENDTRW
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrW::
SaveActionMap(
              LPDIACTIONFORMATW lpDiActionFormat,
              LPCWSTR lpcwstrUserName,
              DWORD dwFlags)
{
    STARTTRW
        return SaveActionMapI(AFW(lpDiActionFormat),U2A(lpcwstrUserName),
            dwFlags);
    ENDTRW
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrW::
GetImageInfo(
             LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader)
{
    STARTTRW
        return GetImageInfoI(DIIHW(lpdiDevImageInfoHeader));
    ENDTRW
}

HRESULT STDMETHODCALLTYPE IDirectInputMapperTrW::
WriteVendorFile(
                LPDIACTIONFORMATW lpDiActionFormat,
                LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader,
                DWORD dwFlags)
{
    STARTTRW
        return WriteVendorFileI(AFW(lpDiActionFormat),
        SETDIIHW(lpdiDevImageInfoHeader),dwFlags);
    ENDTRW
}

/******************************************************************************
 *
 * Mapper object implementation
 *
 *****************************************************************************/

BOOL CALLBACK DIEnumDeviceObjectsProcC(LPCDIDEVICEOBJECTINSTANCE lpddoi,
                                       LPVOID pvRef)
{
    //Read offset, usage page, usage and name and store into private list
    DEVICEOBJLIST *pDevObjList=&(((CDIMapObj*)pvRef)->m_DevObjList);
    DeviceObjData D;
/*    We decided to use dwType (ObjID) instead of dwOffset. 
    This place and exports are the only places where this data enters into
    the module so there should not be problem. Latter rename the code
    from dwOffset. Also, it is valid to use 0xffffffff value of dwType for
    special purposes.
*/    //D.dwOffset=lpddoi->dwOfs;
    D.dwOffset=lpddoi->dwType;
    D.dwUsage=lpddoi->wUsage;
    D.dwUsagePage=lpddoi->wUsagePage;
    D.dwType=lpddoi->dwType;
    D.dwFlags=lpddoi->dwFlags;
    D.Name=lpddoi->tszName;
    ToUpper(D.Name);
    pDevObjList->push_back(D);
    return DIENUM_CONTINUE;
}

void MakeGenreName(String &S,LPCTSTR lpDeviceName,
                   DWORD dwGenre,LPCGUID lpAppGUID=NULL)
{
    S=lpDeviceName;
    S+=_T(".");
    //If application genre
    if(lpAppGUID)
    {
        S=S+APPLICATION+_T(".")+GUID2String(*lpAppGUID)+_T(".");
    }
    S=S+GENRE+_T(".")+N2Str(DISEM_GENRE_GET(dwGenre));
    DUMPN(_T("Genre section name"),S);
}

bool CompareTypeObjAct(DWORD dwObjType,DWORD dwActType)
{
    if((dwObjType&DIDFT_AXIS)&&
        (DISEM_TYPE_GET(dwActType)==DISEM_TYPE_GET(DISEM_TYPE_AXIS)))
        return true;
    if((dwObjType&DIDFT_BUTTON)&&
        (DISEM_TYPE_GET(dwActType)==DISEM_TYPE_GET(DISEM_TYPE_BUTTON)))
        return true;
    if((dwObjType&DIDFT_POV)&&
        (DISEM_TYPE_GET(dwActType)==DISEM_TYPE_GET(DISEM_TYPE_POV)))
        return true;
    return false;
}

bool CDIMapObj::CompareData(DeviceObjData &DOD,ControlData &CD)
{
    if(IsVIDPID())
    {
        //Assume for now that the DOD.dwOffset and DOD.dwType fields are
        //both always set as they are actually the same thing 
        //under W2K. If this isn't the case we need to work out
        //which one to check against CD.dwOffset
#ifdef _CHECKED
        if (DOD.dwOffset!=DOD.dwType)
            DUMP(_T("CDIMapObj::CompareData. Problem - DeviceObjData has differing dwOffset and dwType fields should not differ!"));
#endif
        if((DOD.dwUsagePage==CD.dwUsagePage)&&
              (DOD.dwUsage==CD.dwUsage) &&
              (DIDFT_FINDMASK&DOD.dwOffset)==(DIDFT_FINDMASK&CD.dwOffset))
            //Device object found
            return true;
    }
    else
    {
        //Ignore FF bits since some drivers do not report properly.
        //Also, this way same ini file can be used for both FF and 
        //non-FF device.
        if((DIDFT_FINDMASK&DOD.dwOffset)==(DIDFT_FINDMASK&CD.dwOffset))
            //Device object found
            return true;
    }
    return false;
}

bool CDIMapObj::GetOffset(ControlData &CD,
               DEVICEOBJLIST &DevObjList,DWORD dwSemantic,
               DEVICEOBJLIST::iterator &DevObjItOut)
{
    METHOD_ENTRY(GetOffset);
    bool bFoundDevice=false;
    //Find DI device object with usage/usage page or name
    DEVICEOBJLIST::iterator DevObjIt;
    for(DevObjIt=DevObjList.begin();DevObjIt!=DevObjList.end();DevObjIt++)
    {
        if(CompareData(*DevObjIt,CD))
        {
            bFoundDevice=true;
            if(CompareTypeObjAct(DevObjIt->dwType,dwSemantic)&&
                !(DevObjIt->bMapped))
            {
                DevObjItOut=DevObjIt;
                return true;
            }
        }
    }
    if(!bFoundDevice)
    {
TRACE(_T("Control with filename '%s' does not exist in device.\n"),
CD.ControlName.data());
        throw MAP_EXCEPTION(E_DEVICE_MISSING_CONTROL);
    }
    return false;
}

/*This three functions TBD*/
//Use when writing
DWORD GetFileSemantic(DWORD dwSemantic,DWORD dwHow)
{
    if(dwHow==DIAH_USERCONFIG)
        return dwSemantic;
    return DISEM_INDEX_SET(DISEM_INDEX_GET(dwSemantic));
}
//Use to get value from file
DWORD GetCmpFileGenreSemantic(DWORD dwSemantic,DWORD dwHow,DWORD dwGenre)
{
    if(dwHow==DIAH_USERCONFIG)
        return dwSemantic;
    return DISEM_INDEX_SET(DISEM_INDEX_GET(dwSemantic))|
        DISEM_GENRE_SET(DISEM_GENRE_GET(dwGenre));
}
//Use to get value from action array
DWORD GetCmpActionGenreSemantic(DWORD dwSemantic,DWORD dwHow)
{
    if(dwHow==DIAH_USERCONFIG)
        return dwSemantic;
    return DISEM_INDEX_SET(DISEM_INDEX_GET(dwSemantic))|
        DISEM_GENRE_SET(DISEM_GENRE_GET(dwSemantic));
}
/**/

void WhichDeviceObjectIsMapped(LPDIACTIONFORMAT lpDiActionFormat,
                               DEVICEOBJLIST &DevObjList,
                               LPCGUID lpThisGUIDInstance)
{
    DEVICEOBJLIST::iterator DevObjIt;
    for(DevObjIt=DevObjList.begin();DevObjIt!=DevObjList.end();DevObjIt++)
    {
        DevObjIt->bMapped=false;
        for(DWORD i=0;i<lpDiActionFormat->dwNumActions;i++)
        {
            if((lpDiActionFormat->rgoAction[i].guidInstance!=
                *lpThisGUIDInstance)||
                (lpDiActionFormat->rgoAction[i].dwHow==DIAH_UNMAPPED)||
                ((DIDFT_FINDMASK&lpDiActionFormat->rgoAction[i].dwObjID)!=
                    (DIDFT_FINDMASK&DevObjIt->dwOffset)))
                continue;
            else
            {
                DevObjIt->bMapped=true;
                break;
            }
        }
    }
}

void CDIMapObj::MapGenre(LPDIACTIONFORMAT lpDiActionFormat,
              CONTROLLIST &ControlsData,
              LPCTSTR lpGenreName,LPCTSTR lpFileName,
              LPCGUID lpThisGUIDInstance,
              DEVICEOBJLIST &DevObjList,DWORD dwHow,
              DWORD &dwNOfMappedActions)
{
    METHOD_ENTRY(MapGenre);
    //For all file control names, read the genre action mapping
    CONTROLLIST::iterator CtrlIt;
    for(CtrlIt=ControlsData.begin();CtrlIt!=ControlsData.end();CtrlIt++)
    {
        DWORD dwAction=GetPrivateProfileInt(lpGenreName,
            CtrlIt->ControlName.data(),RESERVED_ACTION,lpFileName);
        CtrlIt->dwAction=dwAction;
    }
    //Find actions which are not mapped yet
    TRACE(_T("Iterate through action array and controls in ini file.\n"));
    for(DWORD i=0;i<lpDiActionFormat->dwNumActions;i++)
    {
        if(((lpDiActionFormat->rgoAction[i].guidInstance!=NULLGUID)
          &&(lpDiActionFormat->rgoAction[i].guidInstance!=*lpThisGUIDInstance))||
           (lpDiActionFormat->rgoAction[i].dwFlags&DIA_APPNOMAP)||
           (lpDiActionFormat->rgoAction[i].dwHow!=DIAH_UNMAPPED))
            continue;
        
        //Find control which maps to this action
        for(CtrlIt=ControlsData.begin();CtrlIt!=ControlsData.end();CtrlIt++)
        {
            if(GetCmpFileGenreSemantic(CtrlIt->dwAction,dwHow,
                lpDiActionFormat->dwGenre)==
                GetCmpActionGenreSemantic(
                    lpDiActionFormat->rgoAction[i].dwSemantic,dwHow))
            {
                //Find offset and initialize it in the action structure
                DEVICEOBJLIST::iterator DevObjIt;
                if(GetOffset(*CtrlIt,DevObjList,
                    lpDiActionFormat->rgoAction[i].dwSemantic,DevObjIt))
                {
                    if((lpDiActionFormat->rgoAction[i].dwFlags&
                        DIA_FORCEFEEDBACK)&&
                        !((DevObjIt->dwFlags&DIDOI_FFEFFECTTRIGGER)||
                        (DevObjIt->dwFlags&DIDOI_FFACTUATOR)))
                    {
TRACE(_T("Action array %u has DIA_FORCEFEEDBACK set but devobj \
does not have DIDOI_FFEFFECTTRIGGER or DIDOI_FFACTUATOR set. Not mapped.\n"),i);
                        continue;
                    }
TRACE(_T("Action array %u mapped to ini file \
control and devobj with dwObjID 0x%x\n"),i,DevObjIt->dwOffset);
                    lpDiActionFormat->rgoAction[i].dwObjID=DevObjIt->dwOffset;
                    DevObjIt->bMapped=true;
                    dwNOfMappedActions++;
                    lpDiActionFormat->rgoAction[i].guidInstance=
                        *lpThisGUIDInstance;
                    lpDiActionFormat->rgoAction[i].dwHow=dwHow;
                    break;
                }
                else
                {
TRACE(_T("Action array %u related to ini file \
control but devobj not found. Not mapping.\n"),i);
                }
            }
        }
    }
}

void WriteTimestamp(LPCTSTR lpFileName,LPCTSTR lpDeviceName,
                    GUID &AppGUID,LPDIACTIONFORMAT lpDiActionFormat)
{
    String S,SH,SL;
    S=GUID2String(AppGUID)+_T(".");
    SH=S+TIMESTAMPHIGH;
    SL=S+TIMESTAMPLOW;
    FILETIME T;
    if((lpDiActionFormat->ftTimeStamp.dwLowDateTime==DIAFTS_NEWDEVICELOW)&&
        (lpDiActionFormat->ftTimeStamp.dwHighDateTime==DIAFTS_NEWDEVICEHIGH))
    {
        T.dwHighDateTime=DIAFTS_UNUSEDDEVICEHIGH;
        T.dwLowDateTime=DIAFTS_UNUSEDDEVICELOW;
    }
    else
    {
        GetSystemTimeAsFileTime(&T);
    }
    WritePrivateProfileIntX(lpDeviceName,SH.data(),
        T.dwHighDateTime,lpFileName);
    WritePrivateProfileIntX(lpDeviceName,SL.data(),
        T.dwLowDateTime,lpFileName);
}

void ReadTimestamp(FILETIME &T,LPCTSTR lpFileName,
                   LPCTSTR lpDeviceName,GUID &AppGUID)
{
    String S,SH,SL;
    S=GUID2String(AppGUID)+_T(".");
    SH=S+TIMESTAMPHIGH;
    SL=S+TIMESTAMPLOW;
    T.dwHighDateTime=GetPrivateProfileInt(lpDeviceName,SH.data(),
        DIAFTS_NEWDEVICELOW,lpFileName);
    T.dwLowDateTime=GetPrivateProfileInt(lpDeviceName,SL.data(),
        DIAFTS_NEWDEVICEHIGH,lpFileName);
}

#ifdef _CHECKED
int CDIMapObj::m_DeviceCount=0;
#endif

CDIMapObj::CDIMapObj()
{
#ifdef _CHECKED
    m_DeviceNo=m_DeviceCount++;
#endif
    m_ulRefCnt=0;
    Clear();
}

void CDIMapObj::Clear()
{
    //m_ulRefCnt must not be set here, only in constructor
    bool m_bInitialized=false;
    
    m_dwThisVendorID=0;
    m_dwThisProductID=0;
    m_DeviceName=_T("");
    memset(&m_DeviceGuid,0,sizeof(m_DeviceGuid));
    
    //Vendor file name data
    m_VFileName=_T("");
    m_lpVFileName=NULL;
    m_VFileDevName=_T("");
    m_VCtrlData.clear();
    m_bVLoaded=false;
    //User file name data
    m_UName=_T("");
    m_lpUName=NULL;
    m_UFileName=_T("");
    m_UserDir=_T("");
    m_UFileDevName=_T("");
    m_UCtrlData.clear();
    m_bULoaded=false;
    m_UTimestamp.dwHighDateTime=0;
    m_UTimestamp.dwLowDateTime=0;
    
    m_bImageBufferSize=false;
    m_dwImageBufferSize=0;
}

CDIMapObj::~CDIMapObj()
{
}

void CDIMapObj::LoadFileData(LPCTSTR lpFileName,LPCTSTR lpThisName,
                             DWORD dwThisVendorID,DWORD dwThisProductID,
                             String &FileDeviceName,CONTROLLIST &ControlsData,
                             bool &bLoaded,FILETIME *pT,
                             LPDIACTIONFORMAT lpDiActionFormat)
{
    METHOD_ENTRY(LoadFileData);
    DUMPN(_T("Filename"),lpFileName);
    
    bLoaded=false;
    FileDeviceName=_T("");
    ControlsData.clear();
    //Clear DevObj pointers to controls
    for(DEVICEOBJLIST::iterator DevObjIt=m_DevObjList.begin();DevObjIt!=
        m_DevObjList.end();DevObjIt++)
    { 
        if(&ControlsData==&m_UCtrlData)
            DevObjIt->pUCtrlData=NULL;
        else
            DevObjIt->pVCtrlData=NULL;
    }
    if(pT)
    {
        pT->dwLowDateTime=DIAFTS_NEWDEVICELOW;
        pT->dwHighDateTime=DIAFTS_NEWDEVICEHIGH;
    }
    
    //Read file version and choose file parser
    DWORD dwVersion=GetPrivateProfileInt(DIRECT_INPUT,DIRECTX_VERSION,
        RESERVED_DX_VER,lpFileName);
    if(dwVersion==0x800)
    {
        //Load all file device names
        STRINGLIST Devices;
        LoadListOfStrings(lpFileName,DIRECT_INPUT,DEVICES,Devices);
        
        BOOL bDeviceFound=FALSE;
        //Iterate through all file device names
        STRINGLIST::iterator DevIt=Devices.begin();
        while(DevIt!=Devices.end())
        {
            String DeviceName=(*DevIt);
            DUMPN(_T("Trying to match device with ini file name"),
                DeviceName);

            //Read VID, PID and type name.
            String NameCur;
            DWORD dwVendorIDCur=GetPrivateProfileInt(DeviceName.data(),
                VENDORID,RESERVED_VENDORID,lpFileName);
            DWORD dwProductIDCur=GetPrivateProfileInt(DeviceName.data(),
                    PRODUCTID,RESERVED_PRODUCTID,lpFileName);
            LoadString(NameCur,lpFileName,DeviceName.data(),NAME);

            if((IsVIDPID()&&
                ((dwVendorIDCur==dwThisVendorID)&&
                (dwProductIDCur==dwThisProductID)))||
                ((!IsVIDPID())&&
                (NameCur==lpThisName)))
            {
                TRACE(_T("Device found in ini file!\n"));
                //Definition of a device is found in the file
                bDeviceFound=TRUE;
                
                FileDeviceName=DeviceName;
                
                if(pT&&lpDiActionFormat)
                    ReadTimestamp(*pT,lpFileName,FileDeviceName.data(),
                    lpDiActionFormat->guidActionMap);
                
                //Load all file control names
                STRINGLIST Controls;
                LoadListOfStrings(lpFileName,DeviceName.data(),CONTROLS,
                    Controls,true);
                
                //Iterate through all file control names for this device
                STRINGLIST::iterator CtrlIt=Controls.begin();
                while(CtrlIt!=Controls.end())
                {
                    DUMPN(_T("Read control data with ini file name"),
                        CtrlIt->data());
                    String ControlSectionName=*CtrlIt;
                    ControlData ControlDataCur;
                    ControlDataCur.pDevObj=NULL;
                    ControlDataCur.ControlName=*CtrlIt;
                    ControlDataCur.dwOffset=RESERVED_OFFSET;
                    ControlDataCur.dwUsagePage=RESERVED_USAGEPAGE;
                    ControlDataCur.dwUsage=RESERVED_USAGE;
                    //Read offset, Usage and UsagePage for a file control name
                    ControlDataCur.dwOffset=
                        GetPrivateProfileInt(ControlSectionName.data(),
                        OFFSET,RESERVED_OFFSET,lpFileName);
                    ControlDataCur.dwUsage=
                        GetPrivateProfileInt(ControlSectionName.data(),
                        USAGE,RESERVED_USAGE,lpFileName);
                    ControlDataCur.dwUsagePage=
                        GetPrivateProfileInt(
                                ControlSectionName.data(),
                                USAGEPAGE,RESERVED_USAGEPAGE,
                                lpFileName);
//                    LoadString(ControlDataCur.Name,lpFileName,
//                        ControlSectionName.data(),NAME);
                    
#ifdef STRICT_DEV_DEF
                    //Store data for this control into the list
                    ControlsData.push_back(ControlDataCur);
#endif STRICT_DEV_DEF
                    
                    //Here bind device obj and control data
                    //Find DI device object with usage/usage page or name
                    for(DEVICEOBJLIST::iterator DevObjIt=m_DevObjList.begin();
                    DevObjIt!=m_DevObjList.end();DevObjIt++)
                    {
                        if(CompareData(*DevObjIt,ControlDataCur))
                        {
#ifndef STRICT_DEV_DEF
                            //Store data for this control into the list
                            ControlsData.push_back(ControlDataCur);
#endif STRICT_DEV_DEF
                            ControlsData.back().pDevObj=&(*DevObjIt);
                            if(&ControlsData==&m_UCtrlData)    
                                DevObjIt->pUCtrlData=&ControlsData.back();
                            else
                                DevObjIt->pVCtrlData=&ControlsData.back();
                        }
                    }
#ifdef STRICT_DEV_DEF
                    if(!ControlsData.back().pDevObj)
                    {
TRACE(_T("Could not match control in file with device object.\n"));
                        throw MAP_EXCEPTION(E_DEVICE_MISSING_CONTROL);
                    }
#endif STRICT_DEV_DEF
                    
                    CtrlIt++;
                }
                break;
            }
            DevIt++;
        }
        if(!bDeviceFound)
        {
TRACE(_T("Device description not present in this file!!!!!!!!!!!!!\n"));
          //throw MAP_EXCEPTION(E_DEVICE_NOT_FOUND); Currently this is legal
        }
        else
        {
            TRACE(_T("Device data loaded from ini file.\n"));
            bLoaded=true;
        }
    }
    else if(dwVersion!=RESERVED_DX_VER)
    {
        TRACE(_T("Bad file version\n"));
        throw MAP_EXCEPTION(E_BAD_VERSION);
    }
    else
    {
        TRACE(_T("File not found, or no version info. Continuing...\n"));
    }
}

void CDIMapObj::LoadUserData(LPCTSTR lpctstrUserName,
        LPDIACTIONFORMAT lpDiActionFormat,
        bool bForceReload/*=false*/,bool bCreateDir/*=false*/)
{
    METHOD_ENTRY(LoadUserData);
    String UserName;
    if(bForceReload)
        lpctstrUserName=m_lpUName;
    if(lpctstrUserName)
        UserName=lpctstrUserName;
    if((m_UFileName==_T(""))||//first run
        (UserName!=m_UName)||//different user name
        bForceReload)
    {
        TRACE(_T("First run or new user or forced reload of user data.\n"));
        m_UName=_T("");
        m_lpUName=NULL;
        m_UFileName=_T("");
        m_UserDir=_T("");
        m_UFileDevName=_T("");
        m_UCtrlData.clear();
        m_bULoaded=false;
        m_UTimestamp.dwHighDateTime;
        m_UTimestamp.dwLowDateTime;
        
        if(lpctstrUserName)//just used as logic operation
        {
            m_UName=UserName;
            m_lpUName=m_UName.data();
        }
        TCHAR lpctstrUserFileName[_MAX_PATH];
        GetMapFileName(m_UName.data(),m_DeviceName.data(),
            m_nDeviceInstanceNo,
            lpctstrUserFileName,false,&m_UserDir);
        m_UFileName=lpctstrUserFileName;
        DUMPN(_T("User File Name"),lpctstrUserFileName);
        LoadFileData(m_UFileName.data(),m_DeviceName.data(),
            m_dwThisVendorID,m_dwThisProductID,m_UFileDevName,m_UCtrlData,
            m_bULoaded,&m_UTimestamp,lpDiActionFormat);
    }
    if(bCreateDir)
    {
        TCHAR lpctstrUserFileName[_MAX_PATH];
        GetMapFileName(m_UName.data(),m_DeviceName.data(),
            m_nDeviceInstanceNo,
            lpctstrUserFileName,true,&m_UserDir);
    }
}

BOOL CALLBACK DIEnumDevicesProc(
    const DIDEVICEINSTANCE * lpddi,LPVOID pvRef)
{
    DEVCNT *pDevCnt=(DEVCNT*)pvRef;
    if(!memcmp(&lpddi->guidProduct,
        &pDevCnt->pDIDI->guidProduct,
        sizeof(lpddi->guidProduct)))
    {
        if(0<memcmp(&lpddi->guidInstance,
                &pDevCnt->pDIDI->guidInstance,
                sizeof(lpddi->guidInstance)))
            (*(pDevCnt->m_pnCnt))++;
    }
	return DIENUM_CONTINUE;
}

HRESULT CDIMapObj::InitializeI(
                               LPCGUID lpThisGUIDInstance,
                               LPCTSTR lpctstrFileName,
                               DWORD dwFlags)
{
    try
    {
        INITIALIZE_ENTERED;
        TRACE(_T("Parameters:\n"));
        DUMP(lpThisGUIDInstance);
        DUMP(lpctstrFileName);
        TRACE(_T("\n"));
        
        //Check parameters
        //Check guid pointer
        if(!lpThisGUIDInstance)
        {
            TRACE(_T("lpThisGUIDInstance is NULL\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        
        HRESULT hRes=S_OK;
        Clear();
        
        m_DeviceGuid=*lpThisGUIDInstance;
        
        //Create DInput device and get info
        LPDIRECTINPUT_AR lpDI;
        HMODULE hM=GetModuleHandle(NULL);
        if(!hM)
        {
            TRACE(_T("ERROR, GetModuleHandle failed\n"));
            throw MAP_EXCEPTION(E_FAIL);
        }
        hRes=DirectInput8Create(hM, DIRECTINPUT_VERSION,
            IID_IDirectInput8, lpDI.Addr(),NULL);
        if(FAILED(hRes))
        {
            TRACE(_T("ERROR, DirectInput8Create failed\n"));
            throw MAP_EXCEPTION(hRes);
        }
        LPDIRECTINPUTDEVICE_AR lpDID;
        hRes=lpDI.P()->CreateDevice(*lpThisGUIDInstance,lpDID,NULL);
        if(FAILED(hRes))
        {
            TRACE(_T("ERROR, CreateDeviceEx failed\n"));
            throw MAP_EXCEPTION(hRes);
        }
        DIDEVICEINSTANCE DIDI;
        DIDI.dwSize=sizeof(DIDI);
        hRes=lpDID.P()->GetDeviceInfo(&DIDI);
        if(FAILED(hRes))
        {
            TRACE(_T("ERROR, GetDeviceInfo failed\n"));
            throw MAP_EXCEPTION(hRes);
        }

        //find device instance number
        m_nDeviceInstanceNo=0;
        DEVCNT DevCnt;
        DevCnt.m_pnCnt=&m_nDeviceInstanceNo;
        DevCnt.pDIDI=&DIDI;
        if(DI_OK!=lpDI.P()->EnumDevices
            (0,DIEnumDevicesProc,&DevCnt,DIEDFL_ATTACHEDONLY))
        {
            TRACE(_T("ERROR, EnumDevices failed\n"));
            throw MAP_EXCEPTION(hRes);
        }
        DUMP(m_nDeviceInstanceNo);
        
        //  Code block added by MarcAnd
        {
            DIPROPDWORD  dipdw;
            
            dipdw.diph.dwSize = sizeof( dipdw );
            dipdw.diph.dwHeaderSize = sizeof( dipdw.diph );
            dipdw.diph.dwObj = 0;
            dipdw.diph.dwHow = DIPH_DEVICE;
            
            if(FAILED(lpDID.P()->GetProperty(DIPROP_VIDPID,&dipdw.diph)))
            {
                m_dwThisVendorID=0;
                m_dwThisProductID=0;
            }
            else
            {
                m_dwThisVendorID=LOWORD( dipdw.dwData );
                m_dwThisProductID=HIWORD( dipdw.dwData );
            }
        }
        DUMP(m_dwThisVendorID);
        DUMP(m_dwThisProductID);
        
        DIPROPSTRING dipwsz;
        dipwsz.diph.dwSize=sizeof(dipwsz);
        dipwsz.diph.dwHeaderSize=sizeof(dipwsz.diph);
        dipwsz.diph.dwObj=0;
        dipwsz.diph.dwHow=DIPH_DEVICE;
        if(FAILED(lpDID.P()->GetProperty(DIPROP_TYPENAME,&dipwsz.diph)))
        {
            //keyboard, mouse...
            m_DeviceName=DIDI.tszInstanceName;
        }
        else
        {
            MakeUniqueDeviceName(m_DeviceName,dipwsz.wsz);
        }
        ToUpper(m_DeviceName);
        DUMP(DIDI.tszInstanceName);
        DUMP(m_DeviceName);
        
        //Enumerate DI device objects and get info.
        //Must go before LoadFileData file control data
        //can be binded to object data
        hRes=lpDID.P()->EnumObjects(DIEnumDeviceObjectsProcC,this,
            DIDFT_AXIS|DIDFT_BUTTON|DIDFT_POV);
        if(FAILED(hRes))
        {
            TRACE(_T("ERROR, EnumObjects failed\n"));
            throw MAP_EXCEPTION(hRes);
        }
        if(!m_DevObjList.size())
        {
            TRACE(_T("ERROR, No dev objects found\n"));
            throw MAP_EXCEPTION(E_DEV_OBJ_NOT_FOUND);
        }
        DUMP(m_DevObjList);

        m_lpVFileName=NULL;
        if(lpctstrFileName)
        {
            m_VFileName=lpctstrFileName;
            m_lpVFileName=m_VFileName.data();
            LoadFileData(m_lpVFileName,m_DeviceName.data(),m_dwThisVendorID,
                m_dwThisProductID,m_VFileDevName,
                m_VCtrlData,m_bVLoaded,NULL,NULL);
        }
        
        m_bInitialized=true;
        TRACE(_T("hRes=0x%x\n"),S_OK);
        return S_OK;
    }
    catch(MapException E)
    {
        return E.GetResult();
    }
    catch(exception)
    {
        USETRACER();
        TRACE(_T("Internal error, hRes=0x%x\n"),E_FAIL);
        return E_FAIL;
    }
}

ULONG STDMETHODCALLTYPE CDIMapObj::Release()
{
    m_ulRefCnt--;
    if(m_ulRefCnt)return m_ulRefCnt;
    delete this;
    DllRelease();
    return 0;
}

HRESULT STDMETHODCALLTYPE CDIMapObj::QueryInterface(REFIID riid,
                                                    LPVOID * ppvOut)
{
    if(IsEqualIID(riid,IID_IDirectInputMapIW))
    {
        AddRef();
        *ppvOut=(IDirectInputMapperW*)this;
        return S_OK;
    }
    else if(IsEqualIID(riid,IID_IDirectInputMapIA))
    {
        AddRef();
        *ppvOut=(IDirectInputMapperA*)this;
        return S_OK;
    }
    else if(IsEqualIID(riid,IID_IUnknown))
    {
        AddRef();
        *ppvOut=(IUnknown*)(IDirectInputMapperA*)this;
        return S_OK;
    }
    else if(IsEqualIID(riid,IID_IDirectInputMapVendorIW))
    {
        AddRef();
        *ppvOut=(IDirectInputMapperVendorW*)this;
        return S_OK;
    }
    else if(IsEqualIID(riid,IID_IDirectInputMapVendorIA))
    {
        AddRef();
        *ppvOut=(IDirectInputMapperVendorA*)this;
        return S_OK;
    }
    
    *ppvOut = 0;
    return E_NOINTERFACE;
}

void CDIMapObj::MapDevice(LPDIACTIONFORMAT lpDiActionFormat,
               LPCTSTR lpFileName,
               LPCTSTR lpFileDevName,LPCGUID lpThisGUIDInstance,
               DEVICEOBJLIST &DevObjList,CONTROLLIST &ControlsData,
               DWORD dwHow,DWORD dwHowApp,DWORD &dwNOfMappedActions,
               bool *pbMapExists,bool bUserFile)
{
    METHOD_ENTRY(MapDevice);
    
    DUMPN(_T("Filename"),lpFileName);
    DUMPN(_T("Device name file"),lpFileDevName);
    //Map genre overrides for a particular game
    String ApplicationGenreName;
    MakeGenreName(ApplicationGenreName,lpFileDevName,
        lpDiActionFormat->dwGenre,
        &lpDiActionFormat->guidActionMap);
    if(GetPrivateProfileInt(ApplicationGenreName.data(),
            MAPEXISTS,0,lpFileName))
    {
        if(pbMapExists)
        {
            *pbMapExists=true;
        }
        if(lpDiActionFormat->dwNumActions!=
            GetPrivateProfileInt(
                ApplicationGenreName.data(),NUMACTIONS,
                -1,lpFileName))
        {
            TRACEI(_T("WARNING! Action map changed!\n"));
            TRACEI(_T("File name=%s\n"),lpFileName);
            TRACEI(_T("Genre section name=%s\n"),ApplicationGenreName.data());
        }
    }
    TRACE(_T("Process application specific genre.\n"));
    DUMPN(_T("Section name"),ApplicationGenreName.data());
    MapGenre(lpDiActionFormat,ControlsData,
        ApplicationGenreName.data(),lpFileName,lpThisGUIDInstance,
        DevObjList,dwHowApp,dwNOfMappedActions);
    
    //Map remainder of semantics of a genre
    if(!bUserFile)//only app. specific maps in user file
    {
        String GenreName;
        MakeGenreName(GenreName,lpFileDevName,
            lpDiActionFormat->dwGenre);
        if(pbMapExists)
        {
            if(GetPrivateProfileInt(GenreName.data(),
                    MAPEXISTS,0,lpFileName))
                *pbMapExists=true;
        }
        TRACE(_T("Process genre.\n"));
        DUMPN(_T("Section name"),GenreName.data());
        MapGenre(lpDiActionFormat,ControlsData,GenreName.data(),
            lpFileName,lpThisGUIDInstance,DevObjList,
            dwHow,dwNOfMappedActions);
    }
}

bool IsImageInfoFull(DIDEVICEIMAGEINFOHEADER *lpdiDevImageInfoHeader,
                     DWORD dwImages)
{
    if((lpdiDevImageInfoHeader->dwBufferSize!=0)&&
        (((dwImages+1)*sizeof(DIDEVICEIMAGEINFO))>
        lpdiDevImageInfoHeader->dwBufferSize))
        return true;
    return false;
}

DIDEVICEIMAGEINFO *GetImageInfoAdr(
    DIDEVICEIMAGEINFOHEADER *lpdiDevImageInfoHeader,DWORD dwImages)
{
    if(lpdiDevImageInfoHeader->dwBufferSize==0)
        return NULL;
    return &lpdiDevImageInfoHeader->lprgImageInfoArray[dwImages];
}

HRESULT CDIMapObj::GetImageInfoI(
    LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader)
{
    try
    {
        GETIMAGEINFO_ENTERED;
        return GetImageInfoInternal(lpdiDevImageInfoHeader,false);
    }
    catch(MapException E)
    {
        return E.GetResult();
    }
    catch(exception)
    {
        USETRACER();
        TRACE(_T("Internal error, hRes=0x%x\n"),E_FAIL);
        return E_FAIL;
    }
}

HRESULT CDIMapObj::GetImageInfoInternal(
    LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
    bool bGettingSize)
{
    METHOD_ENTRY(GetImageInfoInternal);
    TRACE(_T("Parameters:\n"));
//    DUMP(lpdiDevImageInfoHeader);Instead of dumping entire struct
//    dump only input params
	// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    TRACE(_T("lpdiDevImageInfoHeader=0x%p\n"),lpdiDevImageInfoHeader);
    if(lpdiDevImageInfoHeader)
    {
        USETRACER();
        TRACE(_T("dwSize=%u\tdwSizeImageInfo=%u\n"),
            (unsigned int)lpdiDevImageInfoHeader->dwSize,
            (unsigned int)lpdiDevImageInfoHeader->dwSizeImageInfo);
        TRACE(_T("dwBufferSize=%u\tdwBufferUsed=%u\n"),
            (unsigned int)lpdiDevImageInfoHeader->dwBufferSize,
            (unsigned int)lpdiDevImageInfoHeader->dwBufferUsed);
		// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        TRACE(_T("lprgImageInfoArray=0x%p\n"),
            lpdiDevImageInfoHeader->lprgImageInfoArray);
    }
    TRACE(_T("\n"));
    
    //Check if initialized
    if(!m_bInitialized)
    {
        TRACE(_T("Object not initialized\n"));
        throw MAP_EXCEPTION(DIERR_NOTINITIALIZED);
    }
    //Check parameters
    if(!lpdiDevImageInfoHeader)
    {
        TRACE(_T("lpdiDevImageInfoHeader is NULL\n"));
        throw MAP_EXCEPTION(E_INVALIDARG);
    }
    //Check structure sizes
    if(lpdiDevImageInfoHeader->dwSize!=sizeof(DIDEVICEIMAGEINFOHEADER))
    {
        TRACE(_T("lpdiDevImageInfoHeader->dwSize is wrong size\n"));
        throw MAP_EXCEPTION(E_INVALIDARG);
    }
    if(lpdiDevImageInfoHeader->dwBufferSize&&
        lpdiDevImageInfoHeader->dwSizeImageInfo!=
        sizeof(DIDEVICEIMAGEINFO))
    {
TRACE(_T("lpdiDevImageInfoHeader->dwSizeImageInfo is wrong size\n"));
        throw MAP_EXCEPTION(E_INVALIDARG);
    }
    //Check buffer size
    if(lpdiDevImageInfoHeader->dwBufferSize&&
        !lpdiDevImageInfoHeader->lprgImageInfoArray)
    {
TRACE(_T("lpdiDevImageInfoHeader->\
dwBufferSize is not 0 and lpdiDevImageInfoHeader->\
lprgImageInfo is NULL\n"));
        throw MAP_EXCEPTION(E_INVALIDARG);
    }
    
    DUMPN(_T("Vendor filename"),m_VFileName);
    DUMPN(_T("Device name in vendor file"),m_VFileDevName);

    HRESULT hRes=S_OK;

    if((!m_bImageBufferSize)&&(!bGettingSize)&&
        lpdiDevImageInfoHeader->dwBufferSize)
    {
        TRACE(_T("User forgot to inquire about buffer size.\n"));
        DIDEVICEIMAGEINFOHEADER DIIH;
        DIIH.dwSize=sizeof(DIIH);
        DIIH.dwSizeImageInfo=sizeof(DIDEVICEIMAGEINFO);
        DIIH.dwcViews=0;
        DIIH.dwcButtons=0;
        DIIH.dwcAxes=0;
        DIIH.dwcPOVs=0;
        DIIH.dwBufferSize=0;
        DIIH.dwBufferUsed=0;
        hRes=GetImageInfoInternal(&DIIH,true);
        if(hRes!=S_OK)
            return hRes;
    }
    //check if image info buffer is big enough
    if(lpdiDevImageInfoHeader->dwBufferSize&&
        (lpdiDevImageInfoHeader->dwBufferSize<
        m_dwImageBufferSize))
    {
TRACE(_T("lpdiDevImageInfoHeader->dwBufferSize is too small.\n"));
        throw MAP_EXCEPTION(DIERR_MOREDATA );
    }

    //process configuration images
    TRACE(_T("Processing DIDIFT_CONFIGURATION images.\n"));
    lpdiDevImageInfoHeader->dwcViews=0;
    DWORD dwImages=0;
    do
    {
        if(IsImageInfoFull(lpdiDevImageInfoHeader,dwImages))break;
        hRes=GetImageInfo((DeviceObjData*)NULL,
            lpdiDevImageInfoHeader->dwcViews,
            GetImageInfoAdr(lpdiDevImageInfoHeader,dwImages),
            DIDIFT_CONFIGURATION);
        if(hRes==S_OK)
        {
            lpdiDevImageInfoHeader->dwcViews++;
            dwImages++;
        }
    }
    while(hRes==S_OK);
    
#if 0
    //process view select images
    TRACE(_T("Processing DIDIFT_VIEWSELECT images.\n"));
    for(int i=0;i<lpdiDevImageInfoHeader->dwcViews;i++)
    {
        if(IsImageInfoFull(lpdiDevImageInfoHeader,dwImages))break;
        if(GetImageInfo((DeviceObjData*)NULL,i,
            GetImageInfoAdr(lpdiDevImageInfoHeader,dwImages),
            DIDIFT_VIEWSELECT)==S_OK)
            dwImages++;
    }

    //process device selection image
    TRACE(_T("Processing DIDIFT_SELECTION images.\n"));
    if(!IsImageInfoFull(lpdiDevImageInfoHeader,dwImages))
    {
        if(GetImageInfo((DeviceObjData*)NULL,-1,
            GetImageInfoAdr(lpdiDevImageInfoHeader,dwImages),
            DIDIFT_SELECTION)==S_OK)
            dwImages++;
    }
#endif    

    //process control data
    TRACE(_T("Processing DIDIFT_OVERLAY images.\n"));
    DEVICEOBJLIST::iterator DevObjIt;
    for(DevObjIt=m_DevObjList.begin();
        DevObjIt!=m_DevObjList.end();DevObjIt++)
    {
        if(IsImageInfoFull(lpdiDevImageInfoHeader,dwImages))break;
        for(int i=0;i<lpdiDevImageInfoHeader->dwcViews;i++)
        {
            if(IsImageInfoFull(lpdiDevImageInfoHeader,dwImages))break;
            if(GetImageInfo(&(*DevObjIt),i,
                    GetImageInfoAdr(lpdiDevImageInfoHeader,dwImages),
                    DIDIFT_OVERLAY)==S_OK)
                dwImages++;
        }
    }
    lpdiDevImageInfoHeader->dwBufferUsed=
        dwImages*sizeof(DIDEVICEIMAGEINFO);

    if((!lpdiDevImageInfoHeader->dwBufferSize)&&(!m_bImageBufferSize))
    {
        m_bImageBufferSize=true;
        m_dwImageBufferSize=lpdiDevImageInfoHeader->dwBufferUsed;
    }

    TRACE(_T("hRes=0x%x\n"),S_OK);
    DUMP(lpdiDevImageInfoHeader);
    return S_OK;
}

bool CDIMapObj::
GetImageInfoFileName(LPCTSTR lpKeyName,LPCTSTR lpSectionName,
                     DWORD dwIndex,LPDIDEVICEIMAGEINFO lpImageInfo)
{
    METHOD_ENTRY(GetImageInfoFileName);
    DUMP(lpSectionName);
    DUMP(lpKeyName);
    DUMP(dwIndex);

    String KeyName=lpKeyName;
    if(dwIndex!=-1)
        KeyName+=_T(".")+N2Str(dwIndex);
    String ImageFileName;
    if(lpImageInfo)
        lpImageInfo->tszImagePath[0]=0;
    if(!LoadString(ImageFileName,m_VFileName.data(),
        lpSectionName,KeyName.data(),true))
        return false;
    String Dir;
    GetDirectory(m_VFileName.data(),Dir);
    Dir+=ImageFileName;
    if(Dir.size()>
        (sizeof(lpImageInfo->tszImagePath)/
        sizeof(lpImageInfo->tszImagePath[0])))
    {
        TRACE(_T("Image filename too long.\n"));
        throw MAP_EXCEPTION(E_FILENAME_TO_LONG);
    }
    if(lpImageInfo)
        _tcscpy(lpImageInfo->tszImagePath,Dir.data());
    return true;
}

//keep flags for a while just in case we change our minds again
#if 0       
void CDIMapObj::
GetImageInfoFormat(LPCTSTR lpKeyName,LPCTSTR lpSectionName,
                   DWORD dwIndex,LPDIDEVICEIMAGEINFO lpImageInfo)
{
    if(lpImageInfo)
    {
        METHOD_ENTRY(GetImageInfoFormat);
        DUMP(lpSectionName);
        DUMP(lpKeyName);
        DUMP(dwIndex);

        String ImageFileFormatKeyName=lpKeyName;
        if(dwIndex!=-1)
            ImageFileFormatKeyName+=_T(".")+N2Str(dwIndex);
        String ImageFileFormat;
        if(!LoadString(ImageFileFormat,m_VFileName.data(),
            lpSectionName,ImageFileFormatKeyName.data(),true))
            lpImageInfo->dwFlags|=DIDIFT_IMAGE2D_BMP;
        else
        {
            if(ImageFileFormat==_T("BMP"))
                lpImageInfo->dwFlags|=DIDIFT_IMAGE2D_BMP;
            else if(ImageFileFormat==_T("PNG"))
                lpImageInfo->dwFlags|=DIDIFT_IMAGE2D_PNG;
            else
            {
                TRACE(_T("Corrupt image type.\n"));
                throw MAP_EXCEPTION(E_CORRUPT_IMAGE_DATA);
            }
        }
    }
}
#endif

bool ImageDataPresent(DWORD dwIndex,LPCTSTR pControlName,
                      LPCTSTR pVFileName)
{
    TCHAR Ret[2];
    String VisibleKeyName;

    VisibleKeyName=OVERLAY_FILENAME;
    VisibleKeyName+=_T(".")+N2Str(dwIndex);
    if(GetPrivateProfileString(pControlName,VisibleKeyName.data(),
                            _T(""),Ret,2,pVFileName))
        return true;

    VisibleKeyName=OVERLAY_FORMAT;
    VisibleKeyName+=_T(".")+N2Str(dwIndex);
    if(GetPrivateProfileString(pControlName,VisibleKeyName.data(),
                            _T(""),Ret,2,pVFileName))
        return true;

    VisibleKeyName=OVERLAY_RECT;
    VisibleKeyName+=_T(".")+N2Str(dwIndex);
    if(GetPrivateProfileString(pControlName,VisibleKeyName.data(),
                            _T(""),Ret,2,pVFileName))
        return true;

    VisibleKeyName=CONTROL_STRING_ALIGN;
    VisibleKeyName+=_T(".")+N2Str(dwIndex);
    if(GetPrivateProfileString(pControlName,VisibleKeyName.data(),
                            _T(""),Ret,2,pVFileName))
        return true;

    VisibleKeyName=CALLOUTMAX;
    VisibleKeyName+=_T(".")+N2Str(dwIndex);
    if(GetPrivateProfileString(pControlName,VisibleKeyName.data(),
                            _T(""),Ret,2,pVFileName))
        return true;

    VisibleKeyName=LINE_DATA;
    VisibleKeyName+=_T(".")+N2Str(dwIndex);
    if(GetPrivateProfileString(pControlName,VisibleKeyName.data(),
                            _T(""),Ret,2,pVFileName))
        return true;

    return false;
}

HRESULT CDIMapObj::GetImageInfo(
                                DeviceObjData *pDevObj,
                                DWORD dwIndex,
                                LPDIDEVICEIMAGEINFO lpImageInfo,
                                DWORD dwImageType)
{
    METHOD_ENTRY(GetImageInfo);
    DUMPN(_T("Image index"),dwIndex);

    HRESULT hRes=S_OK;
    
    //There must be vendor file when getting image data
    if(!m_bVLoaded)
    {
        TRACE(_T("No vendor file or error in Initialize().\n"));
        throw MAP_EXCEPTION(E_CORRUPT_IMAGE_DATA);
    }
    switch(dwImageType)
    {
    case DIDIFT_CONFIGURATION:
        if(GetImageInfoFileName(IMAGE_FILENAME,m_VFileDevName.data(),
            dwIndex,lpImageInfo))
        {
            if(lpImageInfo)//we are not only counting
            {
                lpImageInfo->dwFlags=dwImageType;
                lpImageInfo->dwViewID=dwIndex;
//keep flags for a while just in case we change our minds again
#if 0       
                GetImageInfoFormat(IMAGE_FORMAT,m_VFileDevName.data(),
                    dwIndex,lpImageInfo);
#endif
            }
            return S_OK;
        }
        else
        {
            if(dwIndex)
                return S_FALSE;
            else
            {
                //there must be at least one device view
TRACE(_T("There must be at least one device view, with index 0.\n"));
                throw MAP_EXCEPTION(E_CORRUPT_IMAGE_DATA);
            }
        }
        break;
#if 0
    case DIDIFT_SELECTION:
        if(GetImageInfoFileName(SELECTION_FILENAME,m_VFileDevName.data(),
            -1,lpImageInfo))
        {
            if(lpImageInfo)//we are not only counting
            {
                lpImageInfo->dwFlags=dwImageType;
//keep flags for a while just in case we change our minds again
#if 0       
                GetImageInfoFormat(SELECTION_FORMAT,m_VFileDevName.data(),
                    -1,lpImageInfo);
#endif
            }
            return S_OK;
        }
        else
            return S_FALSE;
        break;
    case DIDIFT_VIEWSELECT:
        if(GetImageInfoFileName(VIEWSELECT_FILENAME,m_VFileDevName.data(),
            dwIndex,lpImageInfo))
        {
            if(lpImageInfo)//we are not only counting
            {
                lpImageInfo->dwFlags=dwImageType;
                lpImageInfo->dwViewID=dwIndex;
//keep flags for a while just in case we change our minds again
#if 0       
                GetImageInfoFormat(VIEWSELECT_FORMAT,m_VFileDevName.data(),
                    dwIndex,lpImageInfo);
#endif
            }
            return S_OK;
        }
        else
            return S_FALSE;
        break;
#endif
    case DIDIFT_OVERLAY:
        {
            //Get control section name
            CONTROLLIST::iterator VCtrlDataIt=m_VCtrlData.begin();
            while(VCtrlDataIt!=m_VCtrlData.end())
            {
                if(CompareData(*pDevObj,*VCtrlDataIt))break;
                VCtrlDataIt++;
            }
            if(VCtrlDataIt==m_VCtrlData.end())
            {
                TRACE(_T("No control with obj ID in file.\n"));
                return S_FALSE;//control with offset not found
            }
            //Section=VCtrlDataIt->ControlName.data();
            DUMPN(_T("Control name in ini file"),VCtrlDataIt->ControlName);
            //Is there ctrl image data
            String VisibleKeyName=CONTROL_VISIBLE;
            VisibleKeyName+=_T(".")+N2Str(dwIndex);
            if(!GetPrivateProfileInt(VCtrlDataIt->ControlName.data(),
                VisibleKeyName.data(),1,m_VFileName.data()))
            {
                TRACE(_T("No image data for this control.\n"));
                return S_FALSE;//No control data
            }
            if(!ImageDataPresent(dwIndex,VCtrlDataIt->ControlName.data(),
                m_VFileName.data()))
            {
                TRACE(_T("No image data for this control.\n"));
                return S_FALSE;//No control data
            }
            
            if(!lpImageInfo)
                return S_OK;//Just counting data...
            lpImageInfo->dwFlags=dwImageType;
            
            lpImageInfo->dwViewID=dwIndex;
            lpImageInfo->dwObjID=pDevObj->dwType;
            //Get overlay image data
            if(GetImageInfoFileName(OVERLAY_FILENAME,
                VCtrlDataIt->ControlName.data(),dwIndex,lpImageInfo))
            {
                TRACE(_T("There is image file name, reading rest.\n"));
//keep flags for a while just in case we change our minds again
#if 0       
                GetImageInfoFormat(OVERLAY_FORMAT,
                    VCtrlDataIt->ControlName.data(),dwIndex,lpImageInfo);
#endif
                //Get overlay rect
                DWORD dwOverlayRectCnt;
                String OverlayRectKeyName=OVERLAY_RECT;
                OverlayRectKeyName+=_T(".")+N2Str(dwIndex);
                POINT OverlayRect[2];
                if(LoadPointArray(m_VFileName.data(),
                    VCtrlDataIt->ControlName.data(),
                    OverlayRectKeyName.data(),OverlayRect,
                    dwOverlayRectCnt,2))
                {
                    if(dwOverlayRectCnt!=2)
                    {
                        TRACE(_T("Corrupt overlay rect data.\n"));
                        throw MAP_EXCEPTION(E_CORRUPT_IMAGE_DATA);
                    }
                    lpImageInfo->rcOverlay.left=OverlayRect[0].x;
                    lpImageInfo->rcOverlay.top=OverlayRect[0].y;
                    lpImageInfo->rcOverlay.right=OverlayRect[1].x;
                    lpImageInfo->rcOverlay.bottom=OverlayRect[1].y;
                }
                else
                {
                    lpImageInfo->rcOverlay.left=0;
                    lpImageInfo->rcOverlay.top=0;
                    lpImageInfo->rcOverlay.right=100;
                    lpImageInfo->rcOverlay.bottom=20;
                }
            }
            
            //Get string alignment
            String KeyName=CONTROL_STRING_ALIGN;
            KeyName+=_T(".")+N2Str(dwIndex);
            String Align;
            if(!LoadString(Align,m_VFileName.data(),
                VCtrlDataIt->ControlName.data(),KeyName.data(),true))
                lpImageInfo->dwTextAlign=DIDAL_CENTERED|DIDAL_MIDDLE;
            else
            {
                if(Align==_T("C"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_CENTERED|DIDAL_MIDDLE;
                else if(Align==_T("L"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_LEFTALIGNED|DIDAL_MIDDLE;
                else if(Align==_T("R"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_RIGHTALIGNED|DIDAL_MIDDLE;
                else if(Align==_T("T"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_CENTERED|DIDAL_TOPALIGNED;
                else if(Align==_T("B"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_CENTERED|DIDAL_BOTTOMALIGNED;
                else if(Align==_T("TL"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_LEFTALIGNED|DIDAL_TOPALIGNED;
                else if(Align==_T("TR"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_RIGHTALIGNED|DIDAL_TOPALIGNED;
                else if(Align==_T("BL"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_LEFTALIGNED|DIDAL_BOTTOMALIGNED;
                else if(Align==_T("BR"))
                    lpImageInfo->dwTextAlign=
                    DIDAL_RIGHTALIGNED|DIDAL_BOTTOMALIGNED;
                else
                {
                    TRACE(_T("Corrupt align data.\n"));
                    throw MAP_EXCEPTION(E_WRONG_ALIGN_DATA);
                }
            }
            
            //Get call out rect
            DWORD dwCallOutMaxCnt;
            String CallOutMaxKeyName=CALLOUTMAX;
            CallOutMaxKeyName+=_T(".")+N2Str(dwIndex);
            POINT Callout[2];
            if(LoadPointArray(m_VFileName.data(),
                VCtrlDataIt->ControlName.data(),
                CallOutMaxKeyName.data(),Callout,
                dwCallOutMaxCnt,2))
            {
                if(dwCallOutMaxCnt!=2)
                {
                    TRACE(_T("Corrupt callout rect data.\n"));
                    throw MAP_EXCEPTION(E_CORRUPT_IMAGE_DATA);
                }
                lpImageInfo->rcCalloutRect.left=Callout[0].x;
                lpImageInfo->rcCalloutRect.top=Callout[0].y;
                lpImageInfo->rcCalloutRect.right=Callout[1].x;
                lpImageInfo->rcCalloutRect.bottom=Callout[1].y;
            }
            else
            {
                lpImageInfo->rcCalloutRect.left=0;
                lpImageInfo->rcCalloutRect.top=0;
                lpImageInfo->rcCalloutRect.right=100;
                lpImageInfo->rcCalloutRect.bottom=20;
            }
            
            //Get line data
            String PointArrayKeyName=LINE_DATA;
            PointArrayKeyName+=_T(".")+N2Str(dwIndex);
            LoadPointArray(m_VFileName.data(),
                VCtrlDataIt->ControlName.data(),
                PointArrayKeyName.data(),
                lpImageInfo->rgptCalloutLine,
                lpImageInfo->dwcValidPts,
                sizeof(lpImageInfo->rgptCalloutLine)/
                sizeof(lpImageInfo->rgptCalloutLine[0]));
            return S_OK;
        }
        break;
    default:
        TRACE(_T("Internal error!!!!\n"));
        throw MAP_EXCEPTION(E_INVALIDARG);break;
    }
    return S_FALSE;
}

HRESULT CDIMapObj::GetActionMapI(
                                 LPDIACTIONFORMAT lpDiActionFormat,
                                 LPCTSTR lpctstrUserName,
                                 FILETIME *pTimestamp,DWORD dwFlags)
{
    try
    {
        GETACTIONMAP_ENTERED;
        TRACE(_T("Parameters:\n"));
        DUMP(lpDiActionFormat);
        DUMP(lpctstrUserName);
        TRACE(_T("\n"));
        
        //Check if initialized
        if(!m_bInitialized)
        {
            TRACE(_T("Object not initialized\n"));
            throw MAP_EXCEPTION(DIERR_NOTINITIALIZED);
        }
        //Check parameters
        if(!lpDiActionFormat)
        {
            TRACE(_T("lpDiActionFormat is NULL\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check structure sizes
        if(lpDiActionFormat->dwSize!=sizeof(*lpDiActionFormat))
        {
            TRACE(_T("lpDiActionFormat->\
                dwSize is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        if(lpDiActionFormat->dwActionSize!=
            sizeof(*(lpDiActionFormat->rgoAction)))
        {
            TRACE(_T("lpDiActionFormat->\
                dwActionSize is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check how many actions, should be more than 0
        if(!lpDiActionFormat->dwNumActions)
        {
            TRACE(_T("lpDiActionFormat->dwNumActions is 0\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check ptr to the action array
        if(!lpDiActionFormat->rgoAction)
        {
            TRACE(_T("lpDiActionFormat->rgoAction is NULL\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        
        DWORD dwNOfMappedActions=0;
        bool bDoNotMapControl=false;//is this per control or action???
        bool bDoNotMapGenre=false;
        
        WhichDeviceObjectIsMapped(
            lpDiActionFormat,m_DevObjList,&m_DeviceGuid);
        
        bool bMapExists=false;//sticky flag, must set to false
        if(!(DIDBAM_HWDEFAULTS&dwFlags))
        {
            TRACE(_T("No DIDBAM_HWDEFAULTS flag, map user file first."));
            //Map the user file first
            LoadUserData(lpctstrUserName,lpDiActionFormat);
            DUMPN(_T("User File Name"),m_UFileName.data());
            lpDiActionFormat->ftTimeStamp=m_UTimestamp;
            if(m_bULoaded)//file was sucessfully preloaded...
            {
                TRACE(_T("User file loaded.\n"));
                MapDevice(lpDiActionFormat,m_UFileName.data(),
                    m_UFileDevName.data(),
                    &m_DeviceGuid,m_DevObjList,m_UCtrlData,
                    DIAH_USERCONFIG,DIAH_USERCONFIG,
                    dwNOfMappedActions,&bMapExists,true);
            }
        }
        
        if(m_lpVFileName&&m_bVLoaded&&
            ((DIDBAM_HWDEFAULTS&dwFlags)||!bMapExists))
        {
            TRACE(_T("Vendor file loaded.\n"));
            //Check if there are unmapped entries
            for(DWORD i=0;i<lpDiActionFormat->dwNumActions;i++)
            {
                if((lpDiActionFormat->rgoAction[i].guidInstance==NULLGUID)
                 ||((lpDiActionFormat->rgoAction[i].guidInstance==m_DeviceGuid)
                  &&(lpDiActionFormat->rgoAction[i].dwHow==DIAH_UNMAPPED)
                  &&((lpDiActionFormat->rgoAction[i].dwFlags&DIA_APPNOMAP)==0)))
                {
                    TRACE(_T("Unmapped action found, mapping vendor file.\n"));
                    //If there are unmapped entries, map manufacturer file
                    DUMPN(_T("Vendor file name"),m_lpVFileName);
                    MapDevice(lpDiActionFormat,m_lpVFileName,
                        m_VFileDevName.data(),&m_DeviceGuid,m_DevObjList,
                        m_VCtrlData,DIAH_HWDEFAULT,DIAH_HWAPP,
                        dwNOfMappedActions,NULL,false);
                    break;
                }
            }
        }
        if(dwNOfMappedActions)
        {
            DUMP(dwNOfMappedActions);
            TRACE(_T("hRes=0x%x\n"),S_OK);
            DUMP(lpDiActionFormat);
            return S_OK;
        }
        if((!(DIDBAM_HWDEFAULTS&dwFlags))&&bMapExists)
        {
            TRACE(_T("hRes=0x%x\n"),S_FALSE);
            return S_FALSE;
        }
        TRACE(_T("hRes=0x%x\n"),S_NOMAP);
        return S_NOMAP;
    }
    catch(MapException E)
    {
        return E.GetResult();
    }
    catch(exception)
    {
        USETRACER();
        TRACE(_T("Internal error, hRes=0x%x\n"),E_FAIL);
        return E_FAIL;
    }
}

void CDIMapObj::Resinc(LPDIACTIONFORMAT lpDiActionFormat)
{
    TRACE(_T("Resincing object after writing.\n"));
    LoadUserData(NULL,lpDiActionFormat,true);
}

HRESULT CDIMapObj::SaveActionMapI(
                                  LPDIACTIONFORMAT lpDiActionFormat,
                                  LPCTSTR lpctstrUserName,
                                  DWORD dwFlags)
{
    try
    {
        SAVEACTIONMAP_ENTERED;
        TRACE(_T("Parameters:\n"));
        DUMP(lpDiActionFormat);
        DUMP(lpctstrUserName);
        TRACE(_T("\n"));
        
        //Check if initialized
        if(!m_bInitialized)
        {
            TRACE(_T("Object not initialized\n"));
            throw MAP_EXCEPTION(DIERR_NOTINITIALIZED);
        }
        //Check parameters
        if(!lpDiActionFormat)
        {
            TRACE(_T("lpDiActionFormat is NULL\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check structure sizes
        if(lpDiActionFormat->dwSize!=sizeof(*lpDiActionFormat))
        {
            TRACE(_T("lpDiActionFormat->\
                dwSize is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        if(lpDiActionFormat->dwActionSize!=
            sizeof(*(lpDiActionFormat->rgoAction)))
        {
            TRACE(_T("lpDiActionFormat->\
                dwActionSize is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check how many actions, should be more than 0
        if(!lpDiActionFormat->dwNumActions)
        {
            TRACE(_T("lpDiActionFormat->dwNumActions is 0\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check ptr to the action array
        if(!lpDiActionFormat->rgoAction)
        {
            TRACE(_T("lpDiActionFormat->rgoAction is NULL\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        
        //this also creates directory if necessary
        LoadUserData(lpctstrUserName,lpDiActionFormat,false,true);
        
        SaveActionMapUV(
            lpDiActionFormat,
            m_bULoaded,
            m_UFileName.data(),
            m_UFileDevName,
            m_UCtrlData,
            NULL,
            DIAH_USERCONFIG,DIAH_USERCONFIG,true);
        
        Resinc(lpDiActionFormat);
        
        TRACE(_T("hRes=0x%x\n"),S_OK);
        return S_OK;
    }
    catch(MapException E)
    {
        return E.GetResult();
    }
    catch(exception)
    {
        USETRACER();
        TRACE(_T("Internal error, hRes=0x%x\n"),E_FAIL);
        return E_FAIL;
    }
}

void CDIMapObj::WriteImageInfo(LPCTSTR lpFileKeyName,
                               LPCTSTR lpFormatKeyName,
                               LPCTSTR lpSectionName,
                               LPDIDEVICEIMAGEINFO lpImageInfo,
                               bool bAddIndex,
                               bool bDelete)
{
    if(lpImageInfo->tszImagePath[0]||bDelete)
    {
        String FileKeyName=lpFileKeyName;
        if(bAddIndex)
            FileKeyName+=_T(".")+N2Str(lpImageInfo->dwViewID);
        String ImageFileName;
        LPCTSTR pImageFileName=NULL;
        if(!bDelete)
        {
            StripDirectory(lpImageInfo->tszImagePath,ImageFileName);
            pImageFileName=ImageFileName.data();
        }
        if(!WritePrivateProfileString(lpSectionName,FileKeyName.data(),
            pImageFileName,m_VFileName.data()))
            throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
//keep flags for a while just in case we change our minds again
#if 0       
        String FormatKeyName=lpFormatKeyName;
        if(bAddIndex)
            FormatKeyName+=_T(".")+N2Str(lpImageInfo->dwViewID);
        String ImageFileFormat;
        LPCTSTR pImageFileFormat=NULL;
        if(!bDelete)
        {
            if(lpImageInfo->dwFlags&DIDIFT_IMAGE2D_PNG)
                ImageFileFormat=_T("PNG");
            else
                ImageFileFormat=_T("BMP");
            pImageFileFormat=ImageFileFormat.data();
        }
        if(!WritePrivateProfileString(lpSectionName,FormatKeyName.data(),
            pImageFileFormat,m_VFileName.data()))
            throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
#endif
    }
}

void CDIMapObj::MakeNewControlName(String &CtrlName,
                                   DEVICEOBJLIST::iterator DevObjIt,
                                   CONTROLLIST &ControlsData,
                                   String &FileDevName,
                                   STRINGLIST &ControlsAllDevs,
                                   STRINGLIST &Controls)
{
    ControlData *pCtrlData=NULL;
    if(&ControlsData==&m_UCtrlData)
        pCtrlData=DevObjIt->pUCtrlData;
    else
        pCtrlData=DevObjIt->pVCtrlData;
    //Was control data allready in the file
    if(!pCtrlData)
    {
        //No control data in the file
        //Make unique control name for the file
        ControlData ControlDataCur;
        ControlDataCur.ControlName=_T("Ctrl");
        ControlDataCur.ControlName+=N2Str(DevObjIt->dwOffset);
        //ControlDataCur.ControlName+=FileDevName;
        ToUpper(ControlDataCur.ControlName);
        MakeUniqueName(ControlDataCur.ControlName,ControlsAllDevs);
        
        //Now add this control name into the list
        CS S;
        S.assign(ControlDataCur.ControlName);
        Controls.push_back(S);
        
        //Store data for this control into the list
        ControlsData.push_back(ControlDataCur);
        
        //Here bind device obj and control data
        ControlsData.back().pDevObj=&(*DevObjIt);
        if(&ControlsData==&m_UCtrlData)    
            pCtrlData=DevObjIt->pUCtrlData=&ControlsData.back();
        else
            pCtrlData=DevObjIt->pVCtrlData=&ControlsData.back();
    }
    CtrlName=pCtrlData->ControlName;
}

void WriteCtrlData(DEVICEOBJLIST::iterator DevObjIt,
                   LPCTSTR pCtrlName,LPCTSTR pFileName)
{
    //Write offset
    WritePrivateProfileIntX(pCtrlName,OFFSET,
        DevObjIt->dwOffset,pFileName);
    //Write USB usage/usagepage if available
    if(DevObjIt->dwUsage&&DevObjIt->dwUsagePage)
    {
        WritePrivateProfileIntX(pCtrlName,USAGEPAGE,
            DevObjIt->dwUsagePage,pFileName);
        WritePrivateProfileIntX(pCtrlName,USAGE,
            DevObjIt->dwUsage,pFileName);
    }
    //Write control name
    if(!WritePrivateProfileString(pCtrlName,NAME,
        DevObjIt->Name.data(),pFileName))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
}

void CDIMapObj::
SaveActionMapUV(
                LPDIACTIONFORMAT lpDiActionFormat,
                bool bDevInFileLoaded,
                LPCTSTR pFileName,
                String &FileDevName,
                CONTROLLIST &ControlsData,
                LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
                DWORD dwHowDev,DWORD dwHowApp,bool bUserFile)
{
    METHOD_ENTRY(SaveActionMapUV);
    DUMPN(_T("Filename"),pFileName);

    //Write allways ,just to update name with lattest.
    WritePrivateProfileIntX(DIRECT_INPUT,DIRECTX_VERSION,
        0x800,pFileName);
    //Load list of devices in the file
    STRINGLIST Devices;
    LoadListOfStrings(pFileName,DIRECT_INPUT,DEVICES,Devices,true);
    
    if(!bDevInFileLoaded)
    {
        TRACE(_T("Device not in file.\n"));
        FileDevName=m_DeviceName;
        //Find unique device name and add the list
        MakeUniqueName(FileDevName,Devices);
        //Write  list of devices
        WriteListOfStrings(DIRECT_INPUT,DEVICES,Devices,pFileName);
        //Write VID and PID
        if(m_dwThisVendorID&&m_dwThisProductID)
        {
            WritePrivateProfileIntX(FileDevName.data(),VENDORID,
                m_dwThisVendorID,pFileName);
            WritePrivateProfileIntX(FileDevName.data(),PRODUCTID,
                m_dwThisProductID,pFileName);
        }
        //Write device name.
        if(!WritePrivateProfileString(FileDevName.data(),NAME,
            m_DeviceName.data(),pFileName))
        {
            TRACE(_T("Error writing ini file.\n"));
            throw MAP_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    DUMPN(_T("Device name in file"),FileDevName);
    
    //write timestamp, but only if we are processing user file
    if(&ControlsData==&m_UCtrlData)
        WriteTimestamp(pFileName,FileDevName.data(),
        lpDiActionFormat->guidActionMap,lpDiActionFormat);
    
    //Load list of controls for this device in the file
    STRINGLIST Controls;
    LoadListOfStrings(pFileName,FileDevName.data(),CONTROLS,Controls,true);
    //Load list of controls for all devices in the file
    STRINGLIST ControlsAllDevs;
    for(STRINGLIST::iterator DevIt=Devices.begin();
            DevIt!=Devices.end();DevIt++)
        LoadListOfStrings(pFileName,DevIt->data(),CONTROLS,
            ControlsAllDevs,true);
    
//    bool bOtherAppFirst=true;
//    bool bUserConfig=true;

    //Delete old sections and create empty mapping
    String GenreName;
    //Game specific section
    //Get section name
    MakeGenreName(GenreName,FileDevName.data(),
        lpDiActionFormat->dwGenre,&lpDiActionFormat->guidActionMap);
    //Find out if this is first writting
    bool bFirstWrite=!GetPrivateProfileInt(GenreName.data(),
        MAPEXISTS,0,pFileName);
    UINT nNoOfMappings=-1;
    if(!bFirstWrite)
    {
        nNoOfMappings=GetPrivateProfileInt(GenreName.data(),
            NUMACTIONS,-1,pFileName);
    }
    //Delete section
    if(!WritePrivateProfileString(GenreName.data(),NULL,
        NULL,pFileName))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(
            HRESULT_FROM_WIN32(GetLastError()));
    }
    //Write numbet of actions
    if(bUserFile)
    {
        if(bFirstWrite)
            WritePrivateProfileInt(GenreName.data(),NUMACTIONS,
                lpDiActionFormat->dwNumActions,pFileName);
        else
            WritePrivateProfileInt(GenreName.data(),NUMACTIONS,
                nNoOfMappings,pFileName);
    }
    //Mark that section exists
    WritePrivateProfileInt(GenreName.data(),
        MAPEXISTS,1,pFileName);
    //General section (not game specific)
    //Delete section
    MakeGenreName(GenreName,FileDevName.data(),
        lpDiActionFormat->dwGenre,NULL);
    if(!WritePrivateProfileString(GenreName.data(),NULL,
        NULL,pFileName))
    {
        TRACE(_T("Error writing ini file.\n"));
        throw MAP_EXCEPTION(
            HRESULT_FROM_WIN32(GetLastError()));
    }
    //Mark that section exist
    if(!bUserFile)
        WritePrivateProfileInt(GenreName.data(),
            MAPEXISTS,1,pFileName);

    TRACE(_T("Looking for action to write.\n"));
    //Iterate through all the actions and store control data
    for(DWORD dwAct=0;dwAct<lpDiActionFormat->dwNumActions;dwAct++)
    {
        DWORD dwHow=lpDiActionFormat->rgoAction[dwAct].dwHow;

        if(!(lpDiActionFormat->rgoAction[dwAct].guidInstance==
                m_DeviceGuid))
            continue;
        if(bUserFile)
        {
            if(!(dwHow&
                    (DIAH_USERCONFIG|DIAH_APPREQUESTED|DIAH_HWAPP|
                    DIAH_HWDEFAULT|DIAH_DEFAULT)))
                continue;
        }
        else
        {
            if(!(dwHow&(DIAH_HWAPP|DIAH_HWDEFAULT)))
                continue;
        }

        if(bUserFile)
            dwHow=DIAH_HWAPP;

        String CtrlName;
#ifdef _CHECKED
        int nObjIndex=-1;
#endif
        //Find device object with same offset
        for(DEVICEOBJLIST::iterator DevObjIt=m_DevObjList.begin();
                DevObjIt!=m_DevObjList.end();DevObjIt++)
        {
#ifdef _CHECKED
            nObjIndex++;
#endif
            if((DIDFT_FINDMASK&DevObjIt->dwOffset)!=
                (DIDFT_FINDMASK&lpDiActionFormat->rgoAction[dwAct].dwObjID))
                continue;
            if(((DIDFT_FINDMASK&DevObjIt->dwOffset)==
                (DIDFT_FINDMASK&lpDiActionFormat->rgoAction[dwAct].dwObjID))&&
                CompareTypeObjAct(DevObjIt->dwType,
                    lpDiActionFormat->rgoAction[dwAct].dwSemantic))
            {
#ifdef _CHECKED
TRACE(_T("To write found action %u matched with devobj %u\n"),
      dwAct,nObjIndex);
#endif
                //Device object found
                //Now find file control name
                MakeNewControlName(CtrlName,DevObjIt,
                    ControlsData,FileDevName,ControlsAllDevs,Controls);
                DUMPN(_T("control name in file"),CtrlName);
                
                WriteCtrlData(DevObjIt,CtrlName.data(),pFileName);
                
                //Make section genre name
                String GenreName;
                LPCGUID lpAppGUID=NULL;
                if(dwHow&DIAH_HWAPP)
                    lpAppGUID=&lpDiActionFormat->guidActionMap;
                MakeGenreName(GenreName,FileDevName.data(),
                    lpDiActionFormat->dwGenre,lpAppGUID);
/*
                bool bDelSect=false;
                if(bOtherAppFirst&&(dwHow&DIAH_HWAPP))
                {
                    bOtherAppFirst=false;
                    bDelSect=true;
                }
                if(bUserConfig&&(dwHow&DIAH_HWDEFAULT))
                {
                    bUserConfig=false;
                    bDelSect=true;
                }
                
                //Delete section if necessary
                if(bDelSect)
                {
TRACE(_T("First write to this section, deleting section."));
                    if(!WritePrivateProfileString(GenreName.data(),NULL,
                        NULL,pFileName))
                    {
                        TRACE(_T("Error writing ini file.\n"));
                        throw MAP_EXCEPTION(
                            HRESULT_FROM_WIN32(GetLastError()));
                    }
                    //Put flag that this mapping exists
                    WritePrivateProfileInt(GenreName.data(),
                        MAPEXISTS,1,pFileName);
                }
*/
                //Now update genre mapping
                WritePrivateProfileIntX(GenreName.data(),CtrlName.data(),
                    GetFileSemantic(
                        lpDiActionFormat->rgoAction[dwAct].dwSemantic,
                        dwHowDev),
                    pFileName);
                
                break;
            }
        }
    }
    if(lpdiDevImageInfoHeader)
    {
        m_bImageBufferSize=false;
        m_dwImageBufferSize=0;
        
        for(int i=0;i<(lpdiDevImageInfoHeader->dwBufferUsed/
            lpdiDevImageInfoHeader->dwSizeImageInfo);i++)
        {
            LPDIDEVICEIMAGEINFO lpImageInfo=
                &lpdiDevImageInfoHeader->lprgImageInfoArray[i];
            DWORD dwFlags=lpImageInfo->dwFlags;
            if(dwFlags&DIDIFT_CONFIGURATION)
            {
                WriteImageInfo(IMAGE_FILENAME,IMAGE_FORMAT,
                    FileDevName.data(),
                    lpImageInfo,true,(dwFlags&DIDIFT_DELETE)?true:false);
            }
#if 0
            else if(dwFlags&DIDIFT_SELECTION)
            {
                WriteImageInfo(SELECTION_FILENAME,SELECTION_FORMAT,
                    FileDevName.data(),
                    lpImageInfo,false,(dwFlags&DIDIFT_DELETE)?true:false);
            }
            else if(dwFlags&DIDIFT_VIEWSELECT)
            {
                WriteImageInfo(VIEWSELECT_FILENAME,VIEWSELECT_FORMAT,
                    FileDevName.data(),
                    lpImageInfo,true,(dwFlags&DIDIFT_DELETE)?true:false);
            }
#endif
            else if(dwFlags&DIDIFT_OVERLAY)
            {
                String CtrlName;
                //Find device object with same offset
                for(DEVICEOBJLIST::iterator DevObjIt=m_DevObjList.begin();
                    DevObjIt!=m_DevObjList.end();DevObjIt++)
                {
                    if((DIDFT_FINDMASK&lpImageInfo->dwObjID)
                        ==(DIDFT_FINDMASK&DevObjIt->dwType))
                    {
                        //Device object found
                        //Now find file control name
                        String CtrlName;
                        MakeNewControlName(CtrlName,DevObjIt,
                            ControlsData,FileDevName,
                            ControlsAllDevs,Controls);
                        WriteCtrlData(DevObjIt,CtrlName.data(),pFileName);
                        //Write file name and format    
                        WriteImageInfo(OVERLAY_FILENAME,
                            OVERLAY_FORMAT,CtrlName.data(),
                            lpImageInfo,true,
                            (dwFlags&DIDIFT_DELETE)?true:false);
                        
                        //Write overlay rect
                        if(lpImageInfo->tszImagePath[0]||
                            (dwFlags&DIDIFT_DELETE))
                        {
                            //Get overlay rect
                            String OverlayRectKeyName=OVERLAY_RECT;
                            OverlayRectKeyName+=
                                _T(".")+N2Str(lpImageInfo->dwViewID);
                            if(dwFlags&DIDIFT_DELETE)
                            {
                                if(!WritePrivateProfileString(
                                        CtrlName.data(),
                                        OverlayRectKeyName.data(),
                                        NULL,
                                        m_VFileName.data()))
                                    throw MAP_EXCEPTION(
                                        HRESULT_FROM_WIN32(
                                        GetLastError()));
                            }
                            else
                                WriteRect(CtrlName.data(),
                                    OverlayRectKeyName.data(),
                                    &lpImageInfo->rcOverlay,
                                    m_VFileName.data());
                        }
                        
                        //Write string alignment
                        String AlignKeyName=CONTROL_STRING_ALIGN;
                        AlignKeyName+=
                            _T(".")+N2Str(lpImageInfo->dwViewID);
                        String Align;
                        LPCTSTR pAlign=NULL;
                        if(!(dwFlags&DIDIFT_DELETE))
                        {
                            if(lpImageInfo->dwTextAlign&
                                    DIDAL_TOPALIGNED)
                                Align=_T("T");
                            else if(lpImageInfo->dwTextAlign&
                                    DIDAL_BOTTOMALIGNED)
                                Align=_T("B");
                            if(lpImageInfo->dwTextAlign&
                                    DIDAL_LEFTALIGNED)
                                Align+=_T("L");
                            else if(lpImageInfo->dwTextAlign&
                                    DIDAL_RIGHTALIGNED)
                                Align+=_T("R");
                            if(Align==_T(""))
                                Align=_T("C");
                            pAlign=Align.data();
                        }
                        if(!WritePrivateProfileString(
                            CtrlName.data(),
                            AlignKeyName.data(),
                            pAlign,
                            m_VFileName.data()))
                            throw MAP_EXCEPTION(
                                HRESULT_FROM_WIN32(GetLastError()));
                        
                        //Write call out rect
                        String CallOutMaxKeyName=CALLOUTMAX;
                        CallOutMaxKeyName+=
                            _T(".")+N2Str(lpImageInfo->dwViewID);
                        if(dwFlags&DIDIFT_DELETE)
                        {
                            if(!WritePrivateProfileString(
                                    CtrlName.data(),
                                    CallOutMaxKeyName.data(),
                                    NULL,
                                    m_VFileName.data()))
                                throw MAP_EXCEPTION(
                                    HRESULT_FROM_WIN32(
                                    GetLastError()));
                        }
                        else
                            WriteRect(CtrlName.data(),
                                CallOutMaxKeyName.data(),
                                &lpImageInfo->rcCalloutRect,
                                m_VFileName.data());
                        
                        //Write line data
                        String PointArrayKeyName=LINE_DATA;
                        PointArrayKeyName+=
                            _T(".")+N2Str(lpImageInfo->dwViewID);
                        if(dwFlags&DIDIFT_DELETE)
                        {
                            if(!WritePrivateProfileString(
                                    CtrlName.data(),
                                    PointArrayKeyName.data(),
                                    NULL,
                                    m_VFileName.data()))
                                throw MAP_EXCEPTION(
                                    HRESULT_FROM_WIN32(
                                    GetLastError()));
                        }
                        else
                            WritePointArray(
                                CtrlName.data(),
                                PointArrayKeyName.data(),
                                lpImageInfo->rgptCalloutLine,
                                lpImageInfo->dwcValidPts,
                                m_VFileName.data());
                        break;
                    }                        
                }
            }
            else
                throw MAP_EXCEPTION(E_CORRUPT_IMAGE_DATA);
        }
    }
    //Write new list of controls into the file
    if(Controls.size())
        WriteListOfStrings(FileDevName.data(),CONTROLS,Controls,pFileName);
}

HRESULT CDIMapObj::
WriteVendorFileI(
                 LPDIACTIONFORMAT lpDiActionFormat,
                 LPDIDEVICEIMAGEINFOHEADER lpdiDevImageInfoHeader,
                 DWORD dwFlags)
{
    try
    {
        WRITEVENDORFILE_ENTERED;
        TRACE(_T("Parameters:\n"));
        DUMP(lpDiActionFormat);
        DUMP(lpdiDevImageInfoHeader);
        //DUMP(lpdiDevImageInfoHeader);
        TRACE(_T("\n"));
        
        //Check if initialized
        if(!m_bInitialized)
        {
            TRACE(_T("Object not initialized\n"));
            throw MAP_EXCEPTION(DIERR_NOTINITIALIZED);
        }
        //Check lpDiActionFormat structure
        //Check structure sizes
        if(lpDiActionFormat&&(lpDiActionFormat->dwSize!=
            sizeof(*lpDiActionFormat)))
        {
            TRACE(_T("lpDiActionFormat->dwSize is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        if(lpDiActionFormat&&(lpDiActionFormat->dwActionSize!=
            sizeof(*(lpDiActionFormat->rgoAction))))
        {
            TRACE(_T("lpDiActionFormat->dwActionSize is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check how many actions, should be more than 0
        if(lpDiActionFormat&&!lpDiActionFormat->dwNumActions)
        {
            TRACE(_T("lpDiActionFormat->dwNumActions is 0\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check ptr to the action array
        if(lpDiActionFormat&&!lpDiActionFormat->rgoAction)
        {
            TRACE(_T("lpDiActionFormat->rgoAction is NULL\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check lpdiDevImageInfoHeader structure
        //Check structure sizes
        if(lpdiDevImageInfoHeader&&
            (lpdiDevImageInfoHeader->dwSize!=
            sizeof(*lpdiDevImageInfoHeader)))
        {
            TRACE(_T("lpdiDevImageInfoHeader->dwSize is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        if(lpdiDevImageInfoHeader&&
            (lpdiDevImageInfoHeader->dwSizeImageInfo!=
            sizeof(*(lpdiDevImageInfoHeader->lprgImageInfoArray))))
        {
TRACE(_T("lpdiDevImageInfoHeader->dwSizeImageInfo is wrong size\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check how many images, should be more than 0
        if(lpdiDevImageInfoHeader&&!lpdiDevImageInfoHeader->dwBufferSize)
        {
            TRACE(_T("lpdiDevImageInfoHeader->dwBufferSize is 0\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check how many images, should be more than 0
        if(lpdiDevImageInfoHeader&&!lpdiDevImageInfoHeader->dwBufferUsed)
        {
            TRACE(_T("lpdiDevImageInfoHeader->dwBufferUsed is 0\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        //Check ptr to the image array
        if(lpdiDevImageInfoHeader&&
            !lpdiDevImageInfoHeader->lprgImageInfoArray)
        {
TRACE(_T("lpdiDevImageInfoHeader->lprgImageInfoArray is NULL\n"));
            throw MAP_EXCEPTION(E_INVALIDARG);
        }
        
        SaveActionMapUV(
            lpDiActionFormat,
            m_bVLoaded,
            m_VFileName.data(),
            m_VFileDevName,
            m_VCtrlData,
            lpdiDevImageInfoHeader,
            DIAH_HWDEFAULT,DIAH_HWAPP,false);
        
        LoadFileData(m_VFileName.data(),m_DeviceName.data(),
            m_dwThisVendorID,m_dwThisProductID,
            m_VFileDevName,m_VCtrlData,m_bVLoaded,NULL,NULL);
        
        TRACE(_T("hRes=0x%x\n"),S_OK);
        return S_OK;
    }
    catch(MapException E)
    {
        return E.GetResult();
    }
    catch(exception)
    {
        USETRACER();
        TRACE(_T("Internal error, hRes=0x%x\n"),E_FAIL);
        return E_FAIL;
    }
}

HRESULT Map_New(REFIID riid,LPVOID *ppvOut)
{
    CDIMapObj *lpDIMapObj=NULL;
    try
    {
        HRESULT hRes=S_OK;
        *ppvOut=NULL;
        lpDIMapObj=new CDIMapObj;
        hRes=lpDIMapObj->QueryInterface(riid,ppvOut);
        if(hRes!=S_OK)
            throw MAP_EXCEPTION(hRes);
        return S_OK;
    }
    catch(MapException E)
    {
        delete lpDIMapObj;
        return E.GetResult();
    }
    catch(exception)
    {
        delete lpDIMapObj;
        USETRACER();
        TRACE(_T("Internal error, hRes=0x%x\n"),E_FAIL);
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\dimap.h ===
/******************************************************************************
 *
 * dimap.h
 *
 * Copyright (c) 1999, 2000 Microsoft Corporation. All Rights Reserved.
 *
 * Abstract:
 *
 * Contents:
 *
 *****************************************************************************/

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _DIMAP_H
#define _DIMAP_H

#include "dinput.h"

//temporary error codes
//If codes are changed or more are added,
//change exception handling dump as well.
#define E_SYNTAX_ERROR            \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000600L)
#define E_DEFINITION_NOT_FOUND    \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000601L)
#define E_LINE_TO_LONG            \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000602L)
#define E_ACTION_NOT_DEFINED      \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000603L)
#define E_DEVICE_NOT_DEFINED      \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000604L)
#define E_VENDORID_NOT_FOUND      \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000605L)
#define E_PRODUCTID_NOT_FOUND     \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000606L)
#define E_USAGE_NOT_FOUND         \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000607L)
#define E_USAGEPAGE_NOT_FOUND     \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000608L)
#define E_DEVICE_NOT_FOUND        \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000609L)
#define E_BAD_VERSION             \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0000060aL)
#define E_DEVICE_MISSING_CONTROL  \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0000060bL)
#define E_DEV_OBJ_NOT_FOUND       \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0000060cL)
#define E_CTRL_W_OFFSET_NOTFOUND  \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0000060dL)
#define E_FILENAME_TO_LONG        \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0000060eL)
#define E_WRONG_ALIGN_DATA        \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0000060fL)
#define E_CORRUPT_IMAGE_DATA      \
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x00000610L)

#define S_NOMAP ((HRESULT)0x00000002L)

#undef INTERFACE
#define INTERFACE IDirectInputMapperW

DECLARE_INTERFACE_(IDirectInputMapperW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputMapperW methods ***/
//    STDMETHOD(Unacquire)(THIS) PURE;
//    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(Initialize)(THIS_ LPCGUID,LPCWSTR,DWORD) PURE;
    STDMETHOD(GetActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,LPFILETIME,DWORD) PURE;
    STDMETHOD(SaveActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERW) PURE;
};

typedef struct IDirectInputMapperW *LPDIRECTINPUTMAPPERW;

#undef INTERFACE
#define INTERFACE IDirectInputMapperA

DECLARE_INTERFACE_(IDirectInputMapperA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputMapperA methods ***/
//    STDMETHOD(Unacquire)(THIS) PURE;
//    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(Initialize)(THIS_ LPCGUID,LPCSTR,DWORD) PURE;
    STDMETHOD(GetActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,LPFILETIME,DWORD) PURE;
    STDMETHOD(SaveActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERA) PURE;
};

typedef struct IDirectInputMapperA *LPDIRECTINPUTMAPPERA;

#undef INTERFACE
#define INTERFACE IDirectInputMapperVendorW

DECLARE_INTERFACE_(IDirectInputMapperVendorW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputMapperVendorW methods ***/
    STDMETHOD(Initialize)(THIS_ LPCGUID,LPCWSTR,DWORD) PURE;
    STDMETHOD(WriteVendorFile)(THIS_ LPDIACTIONFORMATW,LPDIDEVICEIMAGEINFOHEADERW,DWORD) PURE;
};

typedef struct IDirectInputMapperVendorW *LPDIRECTINPUTMAPPERVENDORW;

#undef INTERFACE
#define INTERFACE IDirectInputMapperVendorA

DECLARE_INTERFACE_(IDirectInputMapperVendorA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputMapperVendorA methods ***/
    STDMETHOD(Initialize)(THIS_ LPCGUID,LPCSTR,DWORD) PURE;
    STDMETHOD(WriteVendorFile)(THIS_ LPDIACTIONFORMATA,LPDIDEVICEIMAGEINFOHEADERA,DWORD) PURE;
};

typedef struct IDirectInputMapperVendorA *LPDIRECTINPUTMAPPERVENDORA;

#ifdef UNICODE
#define IID_IDirectInputMapI IID_IDirectInputMapIW
#define IDirectInputMapper IDirectInputMapperW
#define IDirectInputMapperVtbl IDirectInputMapperWVtbl

#define IID_IDirectInputMapperVendor IID_IDirectInputMapperVendorW
#define IDirectInputMapperVendor IDirectInputMapperVendorW
#define IDirectInputMapperVendorVtbl IDirectInputMapperVendorWVtbl
#else
#define IID_IDirectInputMapI IID_IDirectInputMapIA
#define IDirectInputMapper IDirectInputMapperA
#define IDirectInputMapperVtbl IDirectInputMapperAVtbl

#define IID_IDirectInputMapperVendor IID_IDirectInputMapperVendorA
#define IDirectInputMapperVendor IDirectInputMapperVendorA
#define IDirectInputMapperVendorVtbl IDirectInputMapperVendorAVtbl
#endif
typedef struct IDirectInputMapper *LPDIRECTINPUTMAPPER;
typedef struct IDirectInputMapperVendor *LPDIRECTINPUTMAPPERVENDOR;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputMapper_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputMapper_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputMapper_Release(p) (p)->lpVtbl->Release(p)
//#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
//#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputMapper_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputMapper_GetActionMap(p,a,b,c,d) (p)->lpVtbl->GetActionMap(p,a,b,c,d)
#define IDirectInputMapper_SaveActionMap(p,a,b,c) (p)->lpVtbl->SaveActionMap(p,a,b,c)
#define IDirectInputMapper_GetImageInfo(p,a) (p)->lpVtbl->GetImageInfo(p,a)

#define IDirectInputMapperVendor_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputMapperVendor_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputMapperVendor_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputMapperVendor_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputMapperVendor_WriteVendorFile(p,a,b,c) (p)->lpVtbl->WriteVendorFile(p,a,b,c)
#else
#define IDirectInputMapper_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputMapper_AddRef(p) (p)->AddRef()
#define IDirectInputMapper_Release(p) (p)->Release()
//#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
//#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputMapper_Initialize(p,a,b,c) (p)->Initialize(p,a,b,c)
#define IDirectInputMapper_GetActionMap(p,a,b,c,d) (p)->GetActionMap(p,a,b,c,d)
#define IDirectInputMapper_SaveActionMap(p,a,b,c) (p)->SaveActionMap(p,a,b,c)
#define IDirectInputMapper_GetImageInfo(p,a) (p)->GetImageInfo(p,a)

#define IDirectInputMapperVendor_QueryInterface(p,a,b) (p)->QueryInterface(p,a,b)
#define IDirectInputMapperVendor_AddRef(p) (p)->AddRef(p)
#define IDirectInputMapperVendor_Release(p) (p)->Release(p)
#define IDirectInputMapperVendor_Initialize(p,a,b,c) (p)->Initialize(p,a,b,c)
#define IDirectInputMapperVendor_WriteVendorFile(p,a,b,c) (p)->WriteVendorFile(p,a,b,c)
#endif

//{E364F0AE-60F7-4550-ABF1-BABBE085D68E}
DEFINE_GUID(IID_IDirectInputMapIA,0xe364f0ae,0x60f7,0x4550,0xab,0xf1,0xba,0xbb,0xe0,0x85,0xd6,0x8e);
//{01E8A5B8-7A8E-4565-9FF0-36FCD8E33B79}
DEFINE_GUID(IID_IDirectInputMapIW,0x01e8a5b8,0x7a8e,0x4565,0x9f,0xf0,0x36,0xfc,0xd8,0xe3,0x3b,0x79);
//{EE3DBC5D-9EFE-4c09-B044-7D9BBB32FC4E}
DEFINE_GUID(IID_IDirectInputMapClsFact,0xee3dbc5d,0x9efe,0x4c09,0xb0,0x44,0x7d,0x9b,0xbb,0x32,0xfc,0x4e);
// {44C5D19C-49F3-4fba-92A7-00E3A69CD595}
DEFINE_GUID(IID_IDirectInputMapVendorIA,0x44c5d19c,0x49f3,0x4fba,0x92,0xa7,0x00,0xe3,0xa6,0x9c,0xd5,0x95);
// {9FB90FFB-F9A2-4e9b-949E-1617F08EB549}
DEFINE_GUID(IID_IDirectInputMapVendorIW,0x9fb90ffb,0xf9a2,0x4e9b,0x94,0x9e,0x16,0x17,0xf0,0x8e,0xb5,0x49);

#endif

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\makefile.inc ===
$(O)\guids.obj: ..\guids.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\obj.c ===
/*****************************************************************************
 *
 *  Clsfact.c
 *
 *  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *
 *  Abstract:
 *
 *      Class factory.
 *
 *****************************************************************************/

#include "dimapp.h"
#include "dimap.h"

/*****************************************************************************
 *
 *      CClassFactory_AddRef
 *
 *      Optimization: Since the class factory is static, reference
 *      counting can be shunted to the DLL itself.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CClassFactory_AddRef(IClassFactory *pcf)
{
    return DllAddRef();
}


/*****************************************************************************
 *
 *      CClassFactory_Release
 *
 *      Optimization: Since the class factory is static, reference
 *      counting can be shunted to the DLL itself.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CClassFactory_Release(IClassFactory *pcf)
{
    return DllRelease();
}

/*****************************************************************************
 *
 *      CClassFactory_QueryInterface
 *
 *      Our QI is very simple because we support no interfaces beyond
 *      ourselves.
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IClassFactory)) {
        CClassFactory_AddRef(pcf);
        *ppvOut = pcf;
        hres = S_OK;
    } else {
        *ppvOut = 0;
        hres = E_NOINTERFACE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      CClassFactory_CreateInstance
 *
 *      Create the effect driver object itself.
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter,
                             REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    if (punkOuter == 0) {
        hres = Map_New(riid, ppvObj);
    } else {
        /*
         *  We don't support aggregation.
         */
        hres = CLASS_E_NOAGGREGATION;
    }

    return hres;
}

/*****************************************************************************
 *
 *      CClassFactory_LockServer
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{

    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }

    return S_OK;
}

/*****************************************************************************
 *
 *      The VTBL for our Class Factory
 *
 *****************************************************************************/

IClassFactoryVtbl CClassFactory_Vtbl = {
    CClassFactory_QueryInterface,
    CClassFactory_AddRef,
    CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer,
};

/*****************************************************************************
 *
 *      Our static class factory.
 *
 *****************************************************************************/

IClassFactory g_cf = { &CClassFactory_Vtbl };

/*****************************************************************************
 *
 *      CClassFactory_New
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_New(REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    /*
     *  Attempt to obtain the desired interface.  QueryInterface
     *  will do an AddRef if it succeeds.
     */
    hres = CClassFactory_QueryInterface(&g_cf, riid, ppvOut);

    return hres;

}

/*****************************************************************************/

/*****************************************************************************
 *
 *      Dynamic Globals.  There should be as few of these as possible.
 *
 *      All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;                   /* Global reference count */
CRITICAL_SECTION g_crst;        /* Global critical section */

/*****************************************************************************
 *
 *      DllAddRef / DllRelease
 *
 *      Adjust the DLL reference count.
 *
 *****************************************************************************/

STDAPI_(ULONG)
DllAddRef(void)
{
    return (ULONG)InterlockedIncrement((LPLONG)&g_cRef);
}

STDAPI_(ULONG)
DllRelease(void)
{
    return (ULONG)InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *      DllGetClassObject
 *
 *      OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *****************************************************************************/

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    if (IsEqualGUID(rclsid, &IID_IDirectInputMapClsFact)) {
        hres = CClassFactory_New(riid, ppvObj);
    } else {
        *ppvObj = 0;
        hres = CLASS_E_CLASSNOTAVAILABLE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      DllCanUnloadNow
 *
 *      OLE entry point.  Fail iff there are outstanding refs.
 *
 *****************************************************************************/

STDAPI
DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/*****************************************************************************
 *
 *      DllOnProcessAttach
 *
 *      Initialize the DLL.
 *
 *****************************************************************************/

STDAPI_(BOOL)
DllOnProcessAttach(HINSTANCE hinst)
{
    /*
     *  Performance tweak: We do not need thread notifications.
     */
    DisableThreadLibraryCalls(hinst);

    __try 
    {
        InitializeCriticalSection(&g_crst);
        return TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return FALSE; // usually out of memory condition
    }

    return TRUE;

}

/*****************************************************************************
 *
 *      DllOnProcessDetach
 *
 *      De-initialize the DLL.
 *
 *****************************************************************************/

STDAPI_(void)
DllOnProcessDetach(void)
{
    DeleteCriticalSection(&g_crst);
}

/*****************************************************************************
 *
 *      MapDllEntryPoint
 *
 *      DLL entry point.
 *
 *****************************************************************************/

/*STDAPI_(BOOL)
MapDllEntryPoint*/
BOOL APIENTRY DllMain
(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        return DllOnProcessAttach(hinst);

    case DLL_PROCESS_DETACH:
        DllOnProcessDetach();
        break;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    DirectInput debugging macros
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1996.05.07 raymondc Somebody had to
 *
 *@@END_MSINTERNAL
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 ***************************************************************************/

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef XDEBUG
    #define RD(x)       x
    #ifdef DEBUG
        #define D(x)    x
    #else
        #define D(x)
    #endif
#else
    #define RD(x)
    #define D(x)
#endif

/*****************************************************************************
 *
 *  assert.c - Assertion stuff
 *
 *      A sqfl is in multiple parts.
 *
 *      The low word specifies the area that is generating the message.
 *
 *      The high word contains flags that describe why this squirty
 *      is being generated.
 *
 *****************************************************************************/

typedef enum {
    /*
     *  Areas.
     */
    sqflAlways          =  0,       /* Unconditional */
    sqflDll             =  1,       /* Dll bookkeeping */
    sqflFactory         =  2,       /* IClassFactory */
    sqflDi              =  3,       /* IDirectInput */
    sqflMouse           =  4,       /* IDirectInputMouse */
    sqflDev             =  5,       /* IDirectInputDevice */
    sqflKbd             =  6,       /* IDirectInputKeyboard */
    sqflDf              =  7,       /* DataFormat goo */
    sqflJoy             =  8,       /* joystick device */
    sqflEm              =  9,       /* Emulation */
    sqflSubclass        = 10,       /* subclassing */
    sqflCursor          = 11,       /* Cursor show/hide */
    sqflHel             = 12,       /* Hardware emulation layer */
    sqflLl              = 13,       /* Low-level hooks */
    sqflExcl            = 14,       /* Exclusivity management */
    sqflDEnum           = 15,       /* Device enumeration */
    sqflExtDll          = 16,       /* External DLLs */
    sqflHid             = 17,       /* HID support */
    sqflHidDev          = 18,       /* HID device support */
    sqflJoyCfg          = 19,       /* IDirectInputJoyConfig */
    sqflEff             = 20,       /* IDirectInputEffect */
    sqflOleDup          = 21,       /* OLE duplication */
    sqflEShep           = 22,       /* IDirectInputEffectShepherd */
    sqflJoyEff          = 23,       /* Dummy DIEffectDriver */
    sqflJoyReg          = 24,       /* Joystick registry goo */
    sqflVxdEff          = 25,       /* VxD DIEffectDriver */
    sqflNil             = 26,       /* CNil and CDefDcb */
    sqflHidUsage        = 27,       /* HID usage mapping */
    sqflUtil            = 28,       /* Misc utility fns */
    sqflObj             = 29,       /* Object creation/destruction */
    sqflCommon          = 30,       /* common.c */
    sqflHidParse        = 31,       /* HID report parsing */
    sqflCal             = 32,       /* Axis calibrations */
    sqflJoyType         = 33,       /* Joystick type key */
    sqflHidOutput       = 34,       /* HID output reports */
    sqflHidIni          = 35,       /* HID device initialization */
    sqflPort            = 36,       /* GamePort Bus Enumuration */
    sqflWDM             = 37,       /* WDM specific Code */
    sqflRegUtils        = 38,       /* Registry utilities */
    sqflCrit            = 39,       /* Critical Section tracking */
    sqflCompat          = 40,       /* App Hacks */
    sqflRaw             = 41,       /* Raw Input - keyboard and mouse */
    sqflMaxArea,                    /* Last area */

    /*
     *  Flags which may be combined.  For now, they all fit into a byte.
     */
    sqflTrace           = 0x00010000,   /* Trace squirties */
    sqflIn              = 0x00020000,   /* Function entry */
    sqflOut             = 0x00040000,   /* Function exit */
    sqflBenign          = 0x00080000,   /* Not a bad error */
    sqflError           = 0x00100000,   /* A bad error */
    sqflVerbose         = 0x00200000,   /* Really verbose */
    sqflMajor           = 0x00400000,   /* Significant, generally positive, events */
} SQFL;                                 /* squiffle */

void EXTERNAL WarnPszV(LPCSTR ptsz, ...);
void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);

#ifndef DEBUG
#define SquirtSqflPtszV sizeof
#endif

#ifdef XDEBUG
    #define RPF WarnPszV
#else
    #define WarnPszV sizeof
    #define RPF sizeof
    #define s_szProc 0
    #define iarg 0
#endif

/*****************************************************************************
 *
 *      Buffer scrambling
 *
 *      All output buffers should be scrambled on entry to any function.
 *
 *      Each output bitmask should set an unused bit randomly to ensure
 *      that callers ignore bits that aren't defined.
 *
 *****************************************************************************/

#ifdef XDEBUG

void EXTERNAL ScrambleBuf(LPVOID pv, UINT cb);
void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask);

#else

#define ScrambleBuf(pv, cb)
#define ScrambleBit(pdw, flRandom)

#endif

/*****************************************************************************
 *
 *      Procedure enter/exit tracking.
 *
 *      Start a procedure with
 *
 *      EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcS(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcI(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcR(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *      The format string is documented in EmitPal.
 *
 *      Suffixing an "S" indicates that the macro should not generate
 *      a procedure name because there is a formal parameter with the
 *      name s_szProc.  This is a hack.
 *
 *      Suffixing an "R" indicates that the macro should generate a
 *      procedure name in RDEBUG.
 *
 *      Suffixing an "I" indicates that the macro should emit a dummy
 *      procedure name in RDEBUG because the interface is internal.
 *
 *      No suffix means that the macro should be active only in the
 *      DEBUG build and should vanish in RDEBUG (and RETAIL).
 *
 *      End a procedure with one of the following:
 *
 *          ExitProc();
 *
 *              Procedure returns no value.
 *
 *          ExitProcX();
 *
 *              Procedure returns an arbitrary DWORD.
 *
 *          ExitProcF();
 *
 *              Procedure returns a BOOL, where FALSE is an error.
 *
 *          ExitOleProc();
 *
 *              Procedure returns an HRESULT (named "hres").
 *
 *          ExitOleProcPpv(ppvOut);
 *
 *              Procedure returns an HRESULT (named "hres") and, on success,
 *              puts a new object in ppvOut.
 *
 *      The ExitBenign* versions consider any error to be benign.
 *
 *****************************************************************************/

#define cpvArgMax   12 /* Max of 12 args per procedure */

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);
void EXTERNAL Sqfl_Init(void);

#ifdef DEBUG

extern BYTE g_rgbSqfl[sqflMaxArea];

BOOL INLINE
IsSqflSet(SQFL sqfl)
{
    WORD wHi;
    if (LOWORD(sqfl) == sqflAlways) {
        return TRUE;
    }
    wHi = HIWORD(sqfl);
    if (wHi == 0) {
        wHi = HIWORD(sqflTrace);
    }

    return g_rgbSqfl[LOWORD(sqfl)] & wHi;
}

#endif

#define _SetupEnterProc(nm)                             \
        static CHAR s_szProc[] = #nm;                   \
        ARGLIST _al[1]                                  \

#define _ _al,

#define ppvDword ((PPV)1)
#define ppvVoid  ((PPV)2)
#define ppvBool  ((PPV)3)

#define _DoEnterProc(v)                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_szProc, _al)            \

#define _EnterProc(nm, v)                               \
        _SetupEnterProc(nm);                            \
        _DoEnterProc(v)                                 \

#define _ExitOleProcPpv(ppv)                            \
        ExitSqflPalHresPpv(sqfl, _al, hres, (PPV)(ppv)) \

#define _ExitOleProc()                                  \
        _ExitOleProcPpv(0)                              \

#define _ExitProc()                                     \
        ExitSqflPalHresPpv(sqfl, _al, 0, ppvVoid)       \

#define _ExitProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvDword) \

#define _ExitProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvBool) \

#define _ExitBenignOleProcPpv(ppv)                      \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, hres, (PPV)(ppv)) \

#define _ExitBenignOleProc()                            \
        _ExitBenignOleProcPpv(0)                        \

#define _ExitBenignProc()                               \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, 0, ppvVoid) \

#define _ExitBenignProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvDword) \

#define _ExitBenignProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvBool) \

#if defined(DEBUG)

#define EnterProc           _EnterProc
#define ExitOleProcPpv      _ExitOleProcPpv
#define ExitOleProc         _ExitOleProc
#define ExitProc            _ExitProc
#define ExitProcX           _ExitProcX
#define ExitProcF           _ExitProcF
#define ExitBenignOleProcPpv    _ExitBenignOleProcPpv
#define ExitBenignOleProc       _ExitBenignOleProc
#define ExitBenignProc          _ExitBenignProc
#define ExitBenignProcX         _ExitBenignProcX
#define ExitBenignProcF         _ExitBenignProcF

#define EnterProcS(nm, v)                               \
        static CHAR s_szProc2[] = #nm;                  \
        ARGLIST _al[1];                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_szProc2, _al)           \

#define EnterProcI          _EnterProc
#define EnterProcR          _EnterProc
#define ExitOleProcPpvR     _ExitOleProcPpv
#define ExitOleProcR        _ExitOleProc
#define ExitProcR           _ExitProc
#define ExitProcXR          _ExitProcX
#define ExitProcFR          _ExitProcF
#define ExitBenignOleProcPpvR   _ExitBenignOleProcPpv
#define ExitBenignOleProcR      _ExitBenignOleProc
#define ExitBenignProcR         _ExitBenignProc
#define ExitBenignProcXR        _ExitBenignProcX
#define ExitBenignProcFR        _ExitBenignProcF

#elif defined(RDEBUG)

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)   static CHAR s_szProc[] = ""
#define EnterProcR(nm, v)   static CHAR s_szProc[] = #nm
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR()
#define ExitProcFR()
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#else

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)
#define EnterProcR(nm, v)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR(x)
#define ExitProcFR(x)
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\common.c ===
/*****************************************************************************
 *
 *  Common.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Shared stuff that operates on all classes
 *
 *      This version of the common services supports multiple
 *      inheritance natively.  You can pass any interface of an object,
 *      and the common services will do the right thing.
 *
 *  Contents:
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCommon

/*****************************************************************************
 *
 *  USAGE FOR OLE OBJECTS
 *
 *      Suppose you want to implement an object called CObj that supports
 *      the interfaces Foo, Bar, and Baz.  Suppose that you opt for
 *      Foo as the primary interface.
 *
 *      >> NAMING CONVENTION <<
 *
 *          COM objects begin with the letter "C".
 *
 *      (1) Declare the primary and secondary vtbls.
 *
 *              Primary_Interface(CObj, IFoo);
 *              Secondary_Interface(CObj, IBar);
 *              Secondary_Interface(CObj, IBaz);
 *
 *      (3) Declare the object itself.
 *
 *              typedef struct CObj {
 *                  IFoo        foo;        // Primary must come first
 *                  IBar        bar;
 *                  IBaz        baz;
 *                  ... other fields ...
 *              } CObj;
 *
 *      (4) Implement the methods.
 *
 *          You may *not* reimplement the AddRef and Release methods!
 *          although you can subclass them.
 *
 *      (5) To allocate an object of the appropriate type, write
 *
 *              hres = Common_NewRiid(CObj, punkOuter, riid, ppvOut);
 *
 *          or, if the object is variable-sized,
 *
 *              hres = Common_NewCbRiid(cb, CObj, punkouter, riid, ppvOut);
 *
 *          Common_NewRiid and Common_NewCbRiid will initialize both the
 *          primary and secondary vtbls.
 *
 *      (6) Define the object signature.
 *
 *              #pragma BEGIN_CONST_DATA
 *
 *              #define CObj_Signature        0x204A424F      // "OBJ "
 *
 *      (7) Define the object template.
 *
 *              Interface_Template_Begin(CObj)
 *                  Primary_Interface_Template(CObj, IFoo)
 *                Secondary_Interface_Template(CObj, IBar)
 *                Secondary_Interface_Template(CObj, IBaz)
 *              Interface_Template_End(CObj)
 *
 *      (8) Define the interface descriptors.
 *
 *              // The macros will declare QueryInterface, AddRef and Release
 *              // so don't list them again
 *
 *              Primary_Interface_Begin(CObj, IFoo)
 *                  CObj_FooMethod1,
 *                  CObj_FooMethod2,
 *                  CObj_FooMethod3,
 *                  CObj_FooMethod4,
 *              Primary_Interface_End(Obj, IFoo)
 *
 *              Secondary_Interface_Begin(CObj, IBar, bar)
 *                  CObj_Bar_BarMethod1,
 *                  CObj_Bar_BarMethod2,
 *              Secondary_Interface_Begin(CObj, IBar, bar)
 *
 *              Secondary_Interface_Begin(CObj, IBaz, baz)
 *                  CObj_Baz_BazMethod1,
 *                  CObj_Baz_BazMethod2,
 *                  CObj_Baz_BazMethod3,
 *              Secondary_Interface_Begin(CObj, IBaz, baz)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  USAGE FOR NON-OLE OBJECTS
 *
 *      All objects are COM objects, even if they are never given out.
 *      In the simplest case, it just derives from IUnknown.
 *
 *      Suppose you want to implement an object called Obj which is
 *      used only internally.
 *
 *      (1) Declare the vtbl.
 *
 *              Simple_Interface(Obj);
 *
 *      (3) Declare the object itself.
 *
 *              typedef struct Obj {
 *                  IUnknown unk;
 *                  ... other fields ...
 *              } Obj;
 *
 *      (4) Implement the methods.
 *
 *          You may *not* override the QueryInterface, AddRef or
 *          Release methods!
 *
 *      (5) Allocating an object of the appropriate type is the same
 *          as with OLE objects.
 *
 *      (6) Define the "vtbl".
 *
 *              #pragma BEGIN_CONST_DATA
 *
 *              Simple_Interface_Begin(Obj)
 *              Simple_Interface_End(Obj)
 *
 *          That's right, nothing goes between the Begin and the End.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      CommonInfo
 *
 *      Information tracked for all common objects.
 *
 *      A common object looks like this:
 *
 *                          rgvtbl
 *                          cbvtbl
 *            D(dwSig)      QIHelper
 *              cHoldRef    AppFinalizeProc
 *              cRef        FinalizeProc
 *              punkOuter   riid
 *              unkPrivate  0
 *      pFoo -> lpVtbl ->   QueryInterface
 *              lpVtbl2     Common_AddRef
 *              data        Common_Release
 *              ...         ...
 *
 *      Essentially, we use the otherwise-unused space above the
 *      pointers to record our bookkeeping information.
 *
 *      punkOuter    = controlling unknown, if object is aggregated
 *      lpvtblPunk   = special vtbl for controlling unknown to use
 *      cHoldRef     = Total reference count, including holds
 *      cRef         = object reference count from application
 *      riid         = object iid
 *      rgvtbl       = array of vtbls of supported interfaces
 *      cbvtbl       = size of array in bytes
 *      QIHelper     = QueryInterface helper for aggregation
 *      AppFinalizeProc = Finalization procedure when app does last Release
 *      FinalizeProc = Finalization procedure
 *
 *      For secondary interfaces, it looks like this:
 *
 *                        riid
 *                        offset to primary interface
 *      pFoo -> lpVtbl -> Forward_QueryInterface
 *                        Forward_AddRef
 *                        Forward_Release
 *                        ...
 *
 *
 *      What is a hold?
 *
 *      There is this annoying situation (particularly with
 *      IDirectInputDevice) where an object wants to prevent itself
 *      from being destroyed but we don't want to do an AddRef.
 *
 *      The classic case (and for now the only one) is an
 *      IDirectInputDevice which has been acquired.  If we did
 *      an honest AddRef() on the Acquire(), and the application does
 *      a Release() without Unacquire()ing, then the device would
 *      be acquired forever.
 *
 *      If you thought that the Unacquire() in the finalization
 *      would help, you'd be wrong, because the finalization happens
 *      only when the last reference goes away, but the last reference
 *      belongs to the device itself and will never go away until
 *      the Unacquire() happens, which can't happen because the app
 *      already lost its last reference to the device.
 *
 *      So instead, we need to maintain *two* refcounts.
 *
 *      cRef is the application-visible reference count, accessible
 *      via PrivateAddRef() and PrivateRelease().  When this
 *      drops to zero, we call the AppFinalize().
 *
 *      cHoldRef is the "real" reference count.  This is the sum of
 *      cRef and the number of outstanding Common_Hold()s.  When
 *      this drops to zero, then the object is Finalize()d.
 *
 *
 *****************************************************************************/

/* WARNING!  cin_dwSig must be first:  ci_Start relies on it */
/* WARNING!  cin_unkPrivate must be last: punkPrivateThis relies on it */

typedef struct CommonInfoN {        /* This goes in front of the object */
 RD(ULONG cin_dwSig;)               /* Signature (for parameter validation) */
    LONG cin_cHoldRef;             /* Total refcount, incl. holds */
    LONG cin_cRef;                 /* Object reference count */
    PUNK cin_punkOuter;             /* Controlling unknown */
    IUnknown cin_unkPrivate;        /* Private IUnknown */
} CommonInfoN, CIN, *PCIN;

typedef struct CommonInfoP {        /* This is how we pun the object itself */
    PREVTBLP *cip_prevtbl;          /* Vtbl of object (will be -1'd) */
} CommonInfoP, CIP, *PCIP;

typedef union CommonInfo {
    CIN cin[1];
    CIP cip[1];
} CommonInfo, CI, *PCI;

#define ci_dwSig        cin[-1].cin_dwSig
#define ci_cHoldRef     cin[-1].cin_cHoldRef
#define ci_cRef         cin[-1].cin_cRef
#define ci_punkOuter    cin[-1].cin_punkOuter
#define ci_unkPrivate   cin[-1].cin_unkPrivate
#define ci_rgfp         cip[0].cip_prevtbl

#define ci_tszClass     cip[0].cip_prevtbl[-1].tszClass
#define ci_rgvtbl       cip[0].cip_prevtbl[-1].rgvtbl
#define ci_cbvtbl       cip[0].cip_prevtbl[-1].cbvtbl
#define ci_QIHelper     cip[0].cip_prevtbl[-1].QIHelper
#define ci_AppFinalize  cip[0].cip_prevtbl[-1].AppFinalizeProc
#define ci_Finalize     cip[0].cip_prevtbl[-1].FinalizeProc
#define ci_riid         cip[0].cip_prevtbl[-1].prevtbl.riid
#define ci_lib          cip[0].cip_prevtbl[-1].prevtbl.lib

#ifdef XDEBUG
#define ci_Start        ci_dwSig
#else
#define ci_Start        ci_cRef
#endif

#define ci_dwSignature  0x38162378              /* typed by my cat */

/*****************************************************************************
 *
 *      Common_Finalize (from Common_Release)
 *
 *      By default, no finalization is necessary.
 *
 *****************************************************************************/

void EXTERNAL
Common_Finalize(PV pv)
{
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    SquirtSqflPtszV(sqfl, TEXT("Common_Finalize(%p)"), pv);
}

/*****************************************************************************
 *
 *      "Private" IUnknown methods
 *
 *      When a COM object is aggregated, it exports *two* IUnknown
 *      interfaces.
 *
 *      The "private" IUnknown is the one that is returned to the
 *      controlling unknown.  It is this unknown that the controlling
 *      unknown uses to manipulate the refcount on the inner object.
 *
 *      The "public" IUnknown is the one that all external callers see.
 *      For this, we just hand out the controlling unknown.
 *
 *****************************************************************************/

Secondary_Interface(CCommon, IUnknown);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | thisPunk |
 *
 *          Convert a private punk (&cin_unkPrivate) into the beginning of
 *          the actual object.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The private punk (&cin_unkPrivate) corresponding to some
 *          object we are managing.
 *
 *  @returns
 *
 *          The object pointer on success, or 0 on error.
 *
 *  @comm
 *
 *          We do not return an <t HRESULT> on error, because the
 *          callers of the procedure typically do not return
 *          <t HRESULT>s themselves.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define thisPunk_(punk, z)                                          \
       _thisPunk_(punk)                                             \

#endif

PV INLINE
thisPunk_(PUNK punkPrivate, LPCSTR s_szProc)
{
    PV pv;
    if (SUCCEEDED(hresFullValidPitf(punkPrivate, 0))) {
        if (punkPrivate->lpVtbl == Class_Vtbl(CCommon, IUnknown)) {
            pv = pvAddPvCb(punkPrivate,
                             cbX(CIN) - FIELD_OFFSET(CIN, cin_unkPrivate));
        } else {
            RPF("%s: Invalid parameter 0", s_szProc);
            pv = 0;
        }
    } else {
        RPF("%s: Invalid parameter 0", s_szProc);
        pv = 0;
    }
    return pv;
}

#define thisPunk(punk)                                              \
        thisPunk_(punk, s_szProc)                                   \


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_QIHelper |
 *
 *          Called when we can't find any interface in the standard list.
 *          See if there's a dynamic interface we can use.
 *
 *          Objects are expected to override this method if
 *          they implement dynamic interfaces.
 *
 *  @parm   PV | pv |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *  @returns
 *
 *          Always returns <c E_NOINTERFACE>.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QIHelper(PV pv, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    *ppvObj = NULL;
    hres = E_NOINTERFACE;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_PrivateQueryInterface |
 *
 *          Common implementation of <mf IUnknown::QueryInterface> for
 *          the "private <i IUnknown>".
 *
 *          Note that we AddRef through the public <i IUnknown>
 *          (<ie>, through the controlling unknown).
 *          That's part of the rules of aggregation,
 *          and we have to follow them in order to keep the controlling
 *          unknown from getting confused.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      The "Ensure jump is to end" remark boils down to the fact that 
 *      compilers have failed to recognize this:
 *
 *      for (i = 0; i < n; i++) {
 *          if (cond) {
 *              mumble();
 *              break;
 *          }
 *      }
 *      if (i >= n) {
 *          gurgle();
 *      }
 *
 *      and turn it into this:
 *
 *      for (i = 0; i < n; i++) {
 *          if (cond) {
 *              mumble();
 *              goto done;
 *          }
 *      }
 *      gurgle();
 *      done:;
 *
 *      But even with this help, the compiler emits pretty dumb code.
 *
 *****************************************************************************/

STDMETHODIMP
Common_PrivateQueryInterface(PUNK punkPrivate, REFIID riid, PPV ppvObj)
{
    PCI pci;
    HRESULT hres;
    EnterProcR(IUnknown::QueryInterface, (_ "pG", punkPrivate, riid));

    pci = thisPunk(punkPrivate);
    if (pci) {
        if (IsEqualIID(riid, &IID_IUnknown)) {
            *ppvObj = pci;
            OLE_AddRef(pci->ci_punkOuter);
            hres = S_OK;
        } else {
            UINT ivtbl;
            for (ivtbl = 0; ivtbl * sizeof(PV) < pci->ci_cbvtbl; ivtbl++) {
                if (IsEqualIID(riid, ((PCI)(&pci->ci_rgvtbl[ivtbl]))->ci_riid)) {
                    *ppvObj = pvAddPvCb(pci, ivtbl * sizeof(PV));
                    OLE_AddRef(pci->ci_punkOuter);
                    hres = S_OK;
                    goto exit;          /* Ensure jump is to end */
                }
            }
            hres = pci->ci_QIHelper(pci, riid, ppvObj);
        }
    } else {
        hres = E_INVALIDARG;
    }

exit:;
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_FastHold |
 *
 *          Increment the object hold count inline.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being held.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_Hold |
 *
 *          Increment the object hold count.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being held.
 *
 *****************************************************************************/

void INLINE
Common_FastHold(PV pvObj)
{
    PCI pci = pvObj;

    InterlockedIncrement(&pci->ci_cHoldRef);

    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	D(SquirtSqflPtszV(sqflObj | sqflVerbose, 
                      TEXT("%s %p Common_FastHold ci_cRef(%d) ci_cHoldRef(%d)"),
                      pci->ci_tszClass,
                      pci,
                      pci->ci_cRef,
                      pci->ci_cHoldRef));
}

STDMETHODIMP_(void)
Common_Hold(PV pvObj)
{
    PCI pci = pvObj;
    AssertF(pvObj == _thisPv(pvObj));       /* Make sure it's the primary */
    AssertF(pci->ci_cHoldRef >= pci->ci_cRef);
    Common_FastHold(pvObj);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_FastUnhold |
 *
 *          Decrement the object hold count.  Assumes that the reference
 *          count is <y not> dropping to zero.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being unheld.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_Unhold |
 *
 *          Decrement the object hold count.  If the hold count drops
 *          to zero, then the object is destroyed.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being unheld.
 *
 *****************************************************************************/

void INLINE
Common_FastUnhold(PV pvObj)
{
    PCI pci = pvObj;

    AssertF(pci->ci_cHoldRef > 0);
    InterlockedDecrement(&pci->ci_cHoldRef);


	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p Common_FastUnHold  ci_cRef(%d) ci_cHoldRef(%d)"),
                      pci->ci_tszClass,
                      pci,
                      pci->ci_cRef,
                      pci->ci_cHoldRef));

}

STDMETHODIMP_(void)
Common_Unhold(PV pvObj)
{
    PCI pci = pvObj;

    AssertF(pci->ci_cHoldRef >= pci->ci_cRef);


    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p Common_Unhold  ci_cRef(%d) ci_cHoldRef(%d)"),
                    pci->ci_tszClass,
                    pci,
                    pci->ci_cRef,
                    pci->ci_cHoldRef-1));

    if (InterlockedDecrement(&pci->ci_cHoldRef) == 0) {


    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("Destroy %s %p "),
                        pci->ci_tszClass, 
                        pci));

        /*
         *  Last reference.  Do an artifical addref so that
         *  anybody who does an artificial addref during
         *  finalization won't accidentally destroy us twice.
         */
        pci->ci_cHoldRef = 1;
        pci->ci_Finalize(pci);
        /* Artificial release is pointless: we're being freed */

        FreePv(pvSubPvCb(pci, sizeof(CIN)));
        DllRelease();
    }
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_PrivateAddRef |
 *
 *          Increment the object refcount.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being addref'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_PrivateAddRef(PUNK punkPrivate)
{
    PCI pci;
    ULONG ulRef;
    EnterProcR(IUnknown::AddRef, (_ "p", punkPrivate));

    pci = thisPunk(punkPrivate);
    if (pci) {
        /*
         *  Don't let anyone AddRef from 0 to 1.  This happens if
         *  somebody does a terminal release, but we have an internal
         *  hold on the object, and the app tries to do an AddRef
         *  even though the object is "gone".
         *
         *  Yes, there is a race condition here, but it's not
         *  a big one, and this is only a rough test anyway.
         */
        if (pci->ci_cRef) {
            /*
             *  We must use an interlocked operation in case two threads
             *  do AddRef or Release simultaneously.  Note that the hold
             *  comes first, so that we never have the case where the
             *  hold count is less than the reference count.
             */
            Common_Hold(pci);
            InterlockedIncrement(&pci->ci_cRef);
            ulRef = pci->ci_cRef;

            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			D(SquirtSqflPtszV(sqflObj , TEXT("%s %p Common_PrivateAddref  ci_cRef(%d) ci_cHoldRef(%d)"),
                              pci->ci_tszClass,
                              pci,
                              pci->ci_cRef,
                              pci->ci_cHoldRef));
        } else {
            RPF("ERROR: %s: Attempting to addref a deleted object", s_szProc);
            ulRef = 0;
        }
    } else {
        ulRef = 0;
    }

    ExitProcX(ulRef);
    return ulRef;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_PrivateRelease |
 *
 *          Decrement the object refcount.  Note that decrementing
 *          the hold count may cause the object to vanish, so stash
 *          the resulting refcount ahead of time.
 *
 *          Note that we release the hold last, so that the hold
 *          count is always at least as great as the refcount.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being release'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_PrivateRelease(PUNK punkPrivate)
{
    PCI pci;
    ULONG ulRc;
    EnterProcR(IUnknown::Release, (_ "p", punkPrivate));

    pci = thisPunk(punkPrivate);
    if (pci) {
        LONG lRc;

        /*
         *  We must use an interlocked operation in case two threads
         *  do AddRef or Release simultaneously.  And if the count
         *  drops negative, then ignore it.  (This means that the
         *  app is Release()ing something too many times.)
         */

        lRc = InterlockedDecrement(&pci->ci_cRef);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p Common_PrivateRelease ci_cRef(%d) ci_cHoldRef(%d)"),
                          pci->ci_tszClass,
                          pci->ci_tszClass,
                          pci->ci_cRef,
                          pci->ci_cHoldRef));
        if (lRc > 0) {
            /*
             *  Not the last release; release the hold and return
             *  the resulting refcount.  Note that we can safely
             *  use a fast unhold here, because there will always
             *  be a hold lying around to match the refcount we
             *  just got rid of.
             */
            Common_FastUnhold(pci);

            /*
             *  This isn't 100% accurate, but it's close enough.
             *  (OLE notes that the value is good only for debugging.)
             */
            ulRc = pci->ci_cRef;

        } else if (lRc == 0) {
            /*
             *  That was the last application-visible reference.
             *  Do app-level finalization.
             */
            pci->ci_AppFinalize(pci);
            /*
             *  Note that we can't do
             *  a fast unhold here, because this might be the last
             *  hold.
             */
            Common_Unhold(pci);
            ulRc = 0;
        } else {
            /*
             *  The app messed up big time.
             */
            RPF("ERROR: %s: Attempting to release a deleted object",
                s_szProc);
            ulRc = 0;
        }
    } else {
        ulRc = 0;
    }

    ExitProcX(ulRc);
    return ulRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global IUnknownVtbl * | c_lpvtblPunk |
 *
 *          The special IUnknown object that only the controlling unknown
 *          knows about.
 *
 *          This is the one that calls the "Real" services.  All the normal
 *          vtbl's go through the controlling unknown (which, if we are
 *          not aggregated, points to ourselves).
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

_Secondary_Interface_Begin(CCommon, IUnknown,
                           (ULONG)(FIELD_OFFSET(CIN, cin_unkPrivate) - cbX(CIN)),
                           Common_Private)
_Secondary_Interface_End(CCommon, IUnknown)

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      "Public" IUnknown methods
 *
 *      These simply forward through the controlling unknown.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_QueryInterface |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IUnknown::QueryInterface, (_ "pG", pv, riid));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0)) &&
        SUCCEEDED(hres = hresFullValidRiid(riid, 1)) &&
        SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 2))) {
        PCI pci = _thisPv(pv);
        AssertF(pci->ci_punkOuter);
        hres = OLE_QueryInterface(pci->ci_punkOuter, riid, ppvObj);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_AddRef |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          The object being addref'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_AddRef(PV pv)
{
    ULONG ulRef;
    HRESULT hres;
    EnterProcR(IUnknown::AddRef, (_ "p", pv));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0))) {
        PCI pci = _thisPv(pv);
        ulRef = OLE_AddRef(pci->ci_punkOuter);
    } else {
        ulRef = 0;
    }
    ExitProcX(ulRef);
    return ulRef;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_Release |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          Object being release'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_Release(PV pv)
{
    ULONG ulRc;
    HRESULT hres;
    EnterProcR(IUnknown::Release, (_ "p", pv));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0))) {
        PCI pci = _thisPv(pv);
        ulRc = OLE_Release(pci->ci_punkOuter);
    } else {
        ulRc = 0;
    }
    ExitProcX(ulRc);
    return ulRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | __Common_New |
 *
 *          Create a new object with refcount 1 and the specific vtbl.
 *          All other fields are zero-initialized.  All parameters must
 *          already be validated.
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
__Common_New(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(__Common_New, (_ "uxx", cb, punkOuter, vtbl));

    hres = AllocCbPpv(cb + sizeof(CIN), ppvObj);
    if (SUCCEEDED(hres)) {
        PCI pciO = (PV)&vtbl;
        PCI pci = pvAddPvCb(*ppvObj, sizeof(CIN));
     RD(pci->ci_dwSig = ci_dwSignature);
        pci->ci_unkPrivate.lpVtbl = Class_Vtbl(CCommon, IUnknown);
        if (punkOuter) {
            pci->ci_punkOuter = punkOuter;
        } else {
            pci->ci_punkOuter = &pci->ci_unkPrivate;
        }
        CopyMemory(pci, pciO->ci_rgvtbl, pciO->ci_cbvtbl);
        *ppvObj = pci;

        /*
         *  On an X86, it is simpler to increment a variable up
         *  from zero to one.  On a RISC, it is simpler to
         *  store the value one directly.
         */
#ifdef _X86_
        pci->ci_cHoldRef++;
        pci->ci_cRef++;
#else
        pci->ci_cHoldRef = 1;
        pci->ci_cRef = 1;
#endif

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p __Common_New ci_cRef(%d) ci_cHoldRef(%d)"),
                          pci->ci_tszClass,
                          pci,
                          pci->ci_cRef,
                          pci->ci_cHoldRef
                          ));


        DllAddRef();

		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		D(SquirtSqflPtszV(sqflObj, TEXT("Created %s %p "),
                        pci->ci_tszClass,
                        pci));

        hres = S_OK;
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _Common_New_ |
 *
 *          Create a new object with refcount 1 and the specific vtbl.
 *          All other fields are zero-initialized.  This entry point
 *          validates parameters.
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR pszProc)
{
    HRESULT hres;
    EnterProc(_Common_New, (_ "uxx", cb, punkOuter, vtbl));

    if (SUCCEEDED(hres = hresFullValidPitf0_(punkOuter, pszProc, 1)) &&
        SUCCEEDED(hres = hresFullValidPcbOut_(ppvObj, cbX(*ppvObj), pszProc, 3))) {
        hres = __Common_New(cb, punkOuter, vtbl, ppvObj);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _Common_NewRiid_ |
 *
 *          Create a new object with refcount 1 and the specific vtbl,
 *          but only if the object supports the indicated interface.
 *          All other fields are zero-initialized.
 *
 *          If punkOut is nonzero, then the object is being created for
 *          aggregation.  The interface must then be &IID_IUnknown.
 *
 *          Aggregation is used to allow multiple IDirectInputXxx interfaces
 *          to hang off one logical object.
 *
 *          It is assumed that the prototype of the calling function is
 *
 *          foo(PV this, PUNK punkOuter, RIID riid, PPV ppvObj);
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   RIID | riid |
 *
 *          Interface requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV ppvObj,
                 LPCSTR pszProc)
{
    HRESULT hres;
    EnterProc(Common_NewRiid, (_ "upG", cb, punkOuter, riid));

    /*
     * Note: __Common_New does not validate punkOuter or ppvObj,
     * so we have to.  Note also that we validate ppvObj first,
     * so that it will be set to zero as soon as possible.
     */

    if (SUCCEEDED(hres = hresFullValidPcbOut_(ppvObj, cbX(*ppvObj), pszProc, 3)) &&
        SUCCEEDED(hres = hresFullValidPitf0_(punkOuter, pszProc, 1)) &&
        SUCCEEDED(hres = hresFullValidRiid_(riid, pszProc, 2))) {

        if (fLimpFF(punkOuter, IsEqualIID(riid, &IID_IUnknown))) {
            hres = __Common_New(cb, punkOuter, vtbl, ppvObj);
            if (SUCCEEDED(hres)) {

                /*
                 *  Move to the requested interface if we aren't aggregated.
                 *  Don't do this if aggregated! or we will lose the private
                 *  IUnknown and then the caller will be hosed.
                 */

                if (punkOuter) {
                    PCI pci = *ppvObj;
                    *ppvObj = &pci->ci_unkPrivate;
                } else {
                    PUNK punk = *ppvObj;
                    hres = Common_QueryInterface(punk, riid, ppvObj);
                    Common_Release(punk);
                }
            }
        } else {
            RD(RPF("%s: IID must be IID_IUnknown if created for aggregation",
                   pszProc));
            *ppvObj = 0;
            hres = CLASS_E_NOAGGREGATION;
        }
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      Invoke_Release
 *
 *      Release the object (if there is one) and wipe out the back-pointer.
 *      Note that we wipe out the value before calling the release, in order
 *      to ameliorate various weird callback conditions.
 *
 *****************************************************************************/

void EXTERNAL
Invoke_Release(PV pv)
{
    LPUNKNOWN punk = (LPUNKNOWN) pvExchangePpvPv64(pv, 0);
    if (punk) {
        punk->lpVtbl->Release(punk);
    }
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresPvVtbl_ |
 *
 *          Validate that an interface pointer is what it claims to be.
 *          It must be the object associated with the <p vtbl>.
 *
 *  @parm   IN PV | pv |
 *
 *          The thing that claims to be an interface pointer.
 *
 *  @parm   IN PV | vtbl |
 *
 *          What it should be, or something equivalent to this.
 *
 *  @returns
 *
 *          Returns <c S_OK> if everything is okay, else
 *          <c E_INVALIDARG>.
 *
 *****************************************************************************/

HRESULT EXTERNAL
hresPvVtbl_(PV pv, PV vtbl, LPCSTR s_szProc)
{
    PUNK punk = pv;
    HRESULT hres;

    AssertF(vtbl);
    if (SUCCEEDED(hres = hresFullValidPitf(punk, 0))) {
#ifdef XDEBUG
        if (punk->lpVtbl == vtbl) {
            hres = S_OK;
        } else {
            RPF("ERROR %s: arg %d: invalid pointer", s_szProc, 0);
            hres = E_INVALIDARG;
        }
#else
        /*
         *  ISSUE-2001/03/29-timgill Really only want to see the primary interface
         *  If we are looking for the primary interface,
         *  then allow any interface.  All the dual-character set
         *  interfaces point all the vtbls at the same function,
         *  which uses hresPvT to validate. hresPvT passes the
         *  primary interface, hence the need to allow anything
         *  if you are asking for the primary interface.
         *
         *  The problem is that this is too lenient in the case
         *  where we really want to see only the primary interface
         *  and not accept any of the secondaries.
         *
         */
        UINT ivtbl;
        PV vtblUnk = punk->lpVtbl;
        PCI pci = (PV)&vtbl;
        if (pci->ci_lib == 0) {
            for (ivtbl = 0; ivtbl * sizeof(PV) < pci->ci_cbvtbl; ivtbl++) {
                if (pci->ci_rgvtbl[ivtbl] == vtblUnk) {
                    hres = S_OK;
                    goto found;
                }
            }
            hres = E_INVALIDARG;
        found:;
        } else {
            if (punk->lpVtbl == vtbl) {
                hres = S_OK;
            } else {
                hres = E_INVALIDARG;
            }
        }
#endif
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diaddhw.c ===
/*****************************************************************************
 *
 *  DIAddHw.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Add New Hardware
 *
 *  Contents:
 *
 *      AddNewHardware
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "dithunk.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyCfg

#ifdef IDirectInputJoyConfig_QueryInterface

#define case95(n)       case n:
#define caseNT(n)       case n:

HRESULT INTERNAL hresFromDiErr_NT(DWORD et);
HRESULT INTERNAL hresFromDiErr_95(int   et);

/*****************************************************************************
 *
 *      These are the functions we have to steal from SYSDM...
 *
 *****************************************************************************/

LPCSTR rgpszSysdm[] = {
    "InstallDevice_RunDLL",     /* InstallDevice_RunDLL     */
};

typedef struct SYSDM {          /* sysdm */
    FARPROC InstallDevice_RunDLL;
} SYSDM, *PSYSDM;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | DiDestroyDeviceInfoList |
 *
 *          Thunk down to SETUPX.DiCallClassInstaller.
 *
 *****************************************************************************/

void INLINE
InstallDevice_RunDLL(PSYSDM psysdm, HWND hwnd,
                     HINSTANCE hinst, LPCSTR psz, UINT show)
{
    TemplateThunk(psysdm->InstallDevice_RunDLL, "ssps",
                  hwnd, hinst, psz, show);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CLASSMAP |
 *
 *          Structure that establishes the relationship between
 *          <t GUIDs> for device classes and the name of the class.
 *
 *          This code needs to hang around because Windows 95
 *          doesn't have SETUPAPI.DLL, so we need to fake it.
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Window to act as owner window for UI.
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          <t GUID> which specifies the class of the hardware device.
 *
 *****************************************************************************/

typedef struct CLASSMAP {
    REFGUID pguidClass;
    LPCSTR ptszClass;
} CLASSMAP, *PCLASSMAP;

const CLASSMAP c_rgcmap[] = {
    {   &GUID_KeyboardClass, ("keyboard"),   },
    {   &GUID_MediaClass,    ("media"),      },
    {   &GUID_MouseClass,    ("mouse"),      },
    {   &GUID_HIDClass,      ("HID"),        },
};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   RESULT | AddNewHardware |
 *
 *          Display the "Add new hardware" dialog.
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Window to act as owner window for UI.
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          <t GUID> which specifies the class of the hardware device.
 *
 *  @comm   Win9x and Win2k have completely different versions of this.
 *
 *****************************************************************************/
HRESULT EXTERNAL
AddNewHardware(HWND hwnd, REFGUID rguid)
#ifdef WINNT
{
    HRESULT     hres;
    HINSTANCE   hInst;
    BOOL        b;
    FARPROC     proc;
    DWORD       le;

    EnterProcR(AddNewHardware, (_ "xG", hwnd, rguid));

    hres = E_NOTIMPL;

    /* Load AddNewHardware proc from newdev.dll part of AddNewHardware wizard.
     */
    hInst = LoadLibrary(TEXT("newdev.dll"));

    if (hInst) {
        proc = GetProcAddress(hInst, (LPCSTR)"InstallNewDevice");

        if (proc) {
            le = ERROR_SUCCESS;
            b  = (BOOL)(*proc)(hwnd, rguid, 0); // 0 means newdev decides about reboot

            if (!b) {
                le = GetLastError();
            }

            hres = hresFromDiErr_NT(le);
        }

        FreeLibrary(hInst);
    }

    ExitOleProc();
    return hres;
}
#else
/*
 *  We pull a gross hack because Device Manager is completely unmanageable.  
 *  We simply call the RunDll entry point and let it do its thing.  
 *  Note that this means we have no way of knowing what the result was.  
 */
{
    SYSDM sysdm;
    HINSTANCE hinst;
    HRESULT hres;
    EnterProcR(AddNewHardware, (_ "xG", hwnd, rguid));

    if (Thunk_GetKernelProcAddresses() &&
        (hinst = Thunk_GetProcAddresses((PV)&sysdm, rgpszSysdm,
                                        cA(rgpszSysdm),
                                        ("SYSDM.CPL")))) {
        int icmap;

        for (icmap = 0; icmap < cA(c_rgcmap); icmap++) {
            if (IsEqualGUID(rguid, c_rgcmap[icmap].pguidClass)) {
                goto found;
            }
        }
        RPF("%s: Unknown device class", s_szProc);
        hres = DIERR_INVALIDCLASSINSTALLER;
        goto done;

    found:;

        InstallDevice_RunDLL(&sysdm, hwnd, hinst,
                             c_rgcmap[icmap].ptszClass, SW_NORMAL);

        g_kpa.FreeLibrary16(hinst);

        hres = S_FALSE;

    } else {
        RPF("%s: Problems thunking to configuration manager", s_szProc);
        hres = E_FAIL;
    }


done:;
    ExitOleProc();
    return hres;
}
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFromDiErr |
 *
 *          Convert a device installer error code into an HRESULT.
 *
 *****************************************************************************/

HRESULT INTERNAL
hresFromDiErr_NT(DWORD et)
{
    HRESULT hres;

    switch (et) {

    case ERROR_SUCCESS:
        hres = S_OK; break;

    /*
     *  Do the default action for the requested operation.
     */
    caseNT(ERROR_DI_DO_DEFAULT);
        hres = S_OK; break;

    /*
     *  No need to copy files (in install).
     */
    caseNT(ERROR_DI_NOFILECOPY);
        hres = S_OK; break;

    /*
     *  Registry entry or DLL for class installer invalid.
     */
    caseNT(ERROR_INVALID_CLASS_INSTALLER);
        hres = DIERR_INVALIDCLASSINSTALLER; break;

    /*
     *  Insufficient memory.
     */
    caseNT(ERROR_NOT_ENOUGH_MEMORY);
    caseNT(ERROR_OUTOFMEMORY);
        hres = E_OUTOFMEMORY; break;

    /*
     *  The user cancelled the operation.
     */
    caseNT(ERROR_CANCELLED);
    caseNT(ERROR_NO_DRIVER_SELECTED);
        hres = DIERR_CANCELLED; break;

    /*
     *  Various impossible things.
     */
    caseNT(ERROR_NO_ASSOCIATED_CLASS);
    caseNT(ERROR_CLASS_MISMATCH);
    caseNT(ERROR_DUPLICATE_FOUND);
    caseNT(ERROR_KEY_DOES_NOT_EXIST);
    caseNT(ERROR_INVALID_DEVINST_NAME);
    caseNT(ERROR_INVALID_CLASS);
    caseNT(ERROR_DEVINFO_NOT_REGISTERED);
    caseNT(ERROR_DEVINST_ALREADY_EXISTS);
    caseNT(ERROR_INVALID_REG_PROPERTY);
    caseNT(ERROR_NO_SUCH_DEVINST);
    caseNT(ERROR_CANT_LOAD_CLASS_ICON);
    caseNT(ERROR_INVALID_HWPROFILE);
    caseNT(ERROR_DEVINFO_LIST_LOCKED);
    caseNT(ERROR_DEVINFO_DATA_LOCKED);
    caseNT(ERROR_NO_CLASSINSTALL_PARAMS);
    caseNT(ERROR_FILEQUEUE_LOCKED);
    caseNT(ERROR_BAD_SERVICE_INSTALLSECT);
    caseNT(ERROR_NO_CLASS_DRIVER_LIST);
    caseNT(ERROR_NO_ASSOCIATED_SERVICE);
    caseNT(ERROR_NO_DEFAULT_DEVICE_INTERFACE);
    default:;
        hres = E_FAIL; break;

    caseNT(ERROR_DI_BAD_PATH);
    caseNT(ERROR_NO_INF);
        hres = DIERR_BADINF; break;

    }
    return hres;
}


#ifndef DI_ERROR
#define DI_ERROR       (500)    // Device Installer
#endif

enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         // Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,              // Bad Move Device Params struct
    ERR_DI_NO_INF,                          // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
    ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
    ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
    ERR_DI_API_ERROR,                       // DI API called incorrectly
    ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
    ERR_DI_BAD_UNREMOVEDEVICE_PARAMS,       // Bad Unremove Device Parameters
    ERR_DI_NOUPDATE,                        // No Drivers Were updated
    ERR_DI_NODATE,                          // The driver does not have a Date stamp in the INF
    ERR_DI_NOVERSION,                       // There is not version string in the INF
    ERR_DI_DONT_INSTALL,                    // Don't upgrade the current driver
    ERR_DI_NO_DIGITAL_SIGNATURE_CATALOG,    // Catalog is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_INF,        // Inf is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_FILE,       // A file is not digitally signed
};


HRESULT INTERNAL
hresFromDiErr_95(int et)
{
    HRESULT hres;

    switch (et) {
    case ERROR_SUCCESS:
        hres = S_OK; break;


    /*
     *  Do the default action for the requested operation.
     */
    case95(ERR_DI_DO_DEFAULT);
        hres = S_OK; break;

    /*
     *  No need to copy files (in install).
     */
    case95(ERR_DI_NOFILECOPY);
        hres = S_OK; break;

    /*
     *  No Drivers Were updated.
     */
//    case95(ERR_DI_NOUPDATE);
//        hres = S_OK; break;

    /*
     *  Don't upgrade the current driver.
     */
//    case95(ERR_DI_DONT_UPGRADE);
//        hres = S_OK; break;


    /*
     *  No Drivers Were updated.
     */
    case95(ERR_DI_NOUPDATE);
        hres = S_OK; break;

    /*
     *  Registry entry or DLL for class installer invalid.
     */
    case95(ERR_DI_INVALID_CLASS_INSTALLER);
        hres = DIERR_INVALIDCLASSINSTALLER; break;

    /*
     *  Insufficient memory.
     */
    case95(ERR_DI_LOW_MEM);
        hres = E_OUTOFMEMORY; break;

    /*
     *  The user cancelled the operation.
     */
    case95(ERR_DI_USER_CANCEL);
        hres = DIERR_CANCELLED; break;

    /*
     *  Various impossible things.
     */
    case95(ERR_DI_BAD_DEV_INFO);            /* Device Info struct invalid    */
    case95(ERR_DI_BAD_CLASS_INFO);          /* Class Info Struct invalid     */
    case95(ERR_DI_API_ERROR);               /* DI API called incorrectly     */
    case95(ERR_DI_BAD_PROPCHANGE_PARAMS);   /* Bad property chg param struct */
    case95(ERR_DI_BAD_SELECTDEVICE_PARAMS); /* Bad Select Device Parameters  */
    case95(ERR_DI_BAD_REMOVEDEVICE_PARAMS); /* Bad Remove Device Parameters  */
    case95(ERR_DI_BAD_ENABLECLASS_PARAMS);  /* Bad Enable Class Parameters   */
    case95(ERR_DI_BAD_MOVEDEV_PARAMS);      /* Bad Move Device Params struct */
    case95(ERR_DI_FAIL_QUERY);              /* Fail the Enable Class query   */
    case95(ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST);
                                            /* Invalid compatible device list*/
    case95(ERR_DI_BAD_UNREMOVEDEVICE_PARAMS);
                                            /* Bad Unremove Device Parameters*/
    case95(ERR_DI_INVALID_DEVICE_ID);       /* Incorrectly formed device IDF */
    case95(ERR_DI_REG_API);                 /* Error returned by Reg API.    */
    default:;
        hres = E_FAIL; break;

    case95(ERR_DI_BAD_PATH);                /* OEM path specified incorrectly*/
    case95(ERR_DI_BAD_INF);                 /* Bad INF file encountered      */
    case95(ERR_DI_NO_INF);                  /* No INF found on OEM disk      */
    case95(ERR_DI_NOVERSION);               /* No version string in the INF  */
    case95(ERR_DI_NODATE);                  /* No Date stamp in the INF      */
        hres = DIERR_BADINF; break;

    }
    return hres;
}


#endif /* defined(IDirectInputJoyConfigVtbl) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\assert.c ===
/*****************************************************************************
 *
 *  Assert.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Assertions and squirties.
 *
 *  Contents:
 *
 *      SquirtSqflPtszV
 *      AssertPtszPtszLn
 *      ArgsPalPszV
 *      EnterSqflPszPal
 *      ExitSqflPalHresPpv
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef XDEBUG

/*****************************************************************************
 *
 *      WarnPszV
 *
 *      Display a message, suitable for framing.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_szPrefix[] = TEXT("DINPUT8: ");

#pragma END_CONST_DATA

void EXTERNAL
WarnPszV(LPCSTR ptsz, ...)
{
    va_list ap;
    CHAR sz[1024];

    lstrcpyA(sz, "DINPUT8: ");
    va_start(ap, ptsz);
#ifdef WIN95
    {
        char *psz = NULL;
        char szDfs[1024]={0};
        strcpy(szDfs,ptsz);                                 // make a local copy of format string
        while (psz = strstr(szDfs,"%p"))                    // find each %p
            *(psz+1) = 'x';                                 // replace each %p with %x
        wvsprintfA(sz + cA(c_szPrefix) - 1, szDfs, ap);     // use the local format string
    }
#else
    {
        wvsprintfA(sz + cA(c_szPrefix) - 1, ptsz, ap);
    }
#endif
    va_end(ap);
    lstrcatA(sz, "\r\n");
    OutputDebugStringA(sz);
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

BYTE g_rgbSqfl[sqflMaxArea];

extern TCHAR g_tszLogFile[];

/*****************************************************************************
 *
 *      Sqfl_Init
 *
 *      Load our initial Sqfl settings from win.ini[debug].
 *
 *      We take one sqfl for each area, of the form
 *
 *      dinput.n=v
 *
 *      where n = 0, ..., sqflMaxArea-1, and where v is one of the
 *      hiword sqfl values.
 *
 *      The default value for all areas is to squirt only errors.
 *
 *****************************************************************************/

void EXTERNAL
Sqfl_Init(void)
{
    int sqfl;
    TCHAR tsz[20];

    sqfl = 0x0;
    wsprintf(tsz, TEXT("dinput"));
    g_rgbSqfl[sqfl] = (BYTE)
                      GetProfileInt(TEXT("DEBUG"), tsz, HIWORD(0x0));

    for (sqfl = 0; sqfl < sqflMaxArea; sqfl++) {
        wsprintf(tsz, TEXT("dinput.%d"), sqfl);
        g_rgbSqfl[sqfl] = (BYTE)
                          GetProfileInt(TEXT("DEBUG"), tsz, g_rgbSqfl[0]);
    }

}

/*****************************************************************************
 *
 *      SquirtPtsz
 *
 *      Squirt a message to the debugger and maybe a log file.
 *
 *****************************************************************************/

void INTERNAL
SquirtPtsz(LPCTSTR ptsz)
{
    OutputDebugString(ptsz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            CHAR szBuf[1024];
#endif
            SetFilePointer(h, 0, 0, FILE_END);
#ifdef UNICODE
            _lwrite((HFILE)(UINT_PTR)h, szBuf, UToA(szBuf, cA(szBuf), ptsz));
#else
            _lwrite((HFILE)(UINT_PTR)h, ptsz, cbCtch(lstrlen(ptsz)));
#endif
            CloseHandle(h);
        }
    }
}

/*****************************************************************************
 *
 *      SquirtPtszA
 *
 *      Squirt an ANSI message to the debugger and maybe a log file.
 *
 *****************************************************************************/

#ifdef UNICODE

void INTERNAL
SquirtPtszA(LPCSTR psz)
{
    OutputDebugStringA(psz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
            _lwrite((HFILE)(UINT_PTR)h, psz, cbCch(lstrlenA(psz)));
            CloseHandle(h);
        }
    }
}

#else

#define SquirtPtszA                 SquirtPtsz

#endif

/*****************************************************************************
 *
 *      SquirtSqflPtszV
 *
 *      Squirt a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...)
{
    if (IsSqflSet(sqfl)) {
        va_list ap;
        TCHAR tsz[1024];
        va_start(ap, ptsz);
        
#ifdef WIN95
    {
        char *psz = NULL;
        char szDfs[1024]={0};
        strcpy(szDfs,ptsz);                 // make a local copy of format string
        while (psz = strstr(szDfs,"%p"))    // find each %p
            *(psz+1) = 'x';                 // replace each %p with %x
        wvsprintf(tsz, szDfs, ap);          // use the local format string
    }
#else
    {
        wvsprintf(tsz, ptsz, ap);
    }
#endif

        va_end(ap);
        lstrcat(tsz, TEXT("\r\n"));
        SquirtPtsz(c_szPrefix);
        SquirtPtsz(tsz);
    }
}

/*****************************************************************************
 *
 *      AssertPtszPtszLn
 *
 *      Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    SquirtSqflPtszV(sqflAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
                    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *      Procedure call tracing is gross because the C preprocessor.
 *
 *      Oh, if only we had support for m4...
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      dwSafeGetPdw
 *
 *      Deference a dword, but don't barf if the dword is bad.
 *
 *****************************************************************************/

DWORD INTERNAL
dwSafeGetPdw(LPDWORD pdw)
{
    if (IsBadReadPtr(pdw, cbX(*pdw))) {
        return 0xBAADBAAD;
    } else {
        return *pdw;
    }
}

/*****************************************************************************
 *
 *      ArgsPszV
 *
 *      Collect arguments to a procedure.
 *
 *      psz -> ASCIIZ format string
 *      ... = argument list
 *
 *      The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
        PPV ppv;
        int i;
        pal->pszFormat = psz;
        for (ppv = pal->rgpv, i = 0; i < cpvArgMax, *psz; i++, psz++) {
            *ppv++ = va_arg(ap, PV);
        }
    } else {
        pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *      EmitPal
 *
 *      OutputDebugString the information, given a pal.  No trailing
 *      carriage return is emitted.
 *
 *      pal      -> place where info was saved
 *
 *      Format characters:
 *
 *      p   - 32 or 64 bit flat pointer
 *      x   - 32-bit hex integer
 *      s   - TCHAR string
 *      S   - SCHAR string
 *      A   - ANSI string
 *      W   - UNICODE string
 *      G   - GUID
 *      u   - unsigned integer
 *      C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    SquirtPtsz(c_szPrefix);
    SquirtPtszA(pal->pszProc);
    SquirtPtsz(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
        if (i) {
            SquirtPtsz(TEXT(", "));
        }
        switch (pal->pszFormat[i]) {

        case 'p':                               /* flat pointer */
// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
#ifdef WIN95
            wsprintfA(sz, "%08x", pal->rgpv[i]);
#else
            wsprintfA(sz, "%p", pal->rgpv[i]);
#endif
            SquirtPtszA(sz);
            break;

        case 'x':                               /* 32-bit hex */
            wsprintfA(sz, "%08x", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 's':                               /* TCHAR string */
            if (pal->rgpv[i] && lstrlen(pal->rgpv[i])) {
                SquirtPtsz(pal->rgpv[i]);
            }
            break;

#ifdef  UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'A':                               /* ANSI string */
            if (pal->rgpv[i] && lstrlenA(pal->rgpv[i])) {
                SquirtPtszA(pal->rgpv[i]);
            }
            break;

#ifndef UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'W':                               /* UNICODE string */
            if (pal->rgpv[i] && lstrlenW(pal->rgpv[i])) {
#ifdef  UNICODE
                OutputDebugStringW(pal->rgpv[i]);
#else
                UToA(sz, cA(sz), pal->rgpv[i]);
                SquirtPtszA(sz);
#endif
            }
            break;

        case 'G':                               /* GUID */
#if 1
            wsprintfA(sz, "%08x",
                      HIWORD((DWORD)(UINT_PTR)pal->rgpv[i])
                        ? dwSafeGetPdw((LPDWORD)pal->rgpv[i])
                        : (UINT_PTR)pal->rgpv[i]);
            SquirtPtszA(sz);
#else
            if( HIWORD((DWORD)(UINT_PTR)pal->rgpv[i]) 
              && !(IsBadReadPtr( pal->rgpv[i], cbX(pal->rgpv[i]) ) ) )
            {
                NameFromGUID( (PTCHAR)sz, pal->rgpv[i] );
#ifdef UNICODE
                SquirtPtsz( &((PWCHAR)sz)[ctchNamePrefix]);
#else
                SquirtPtszA( &sz[ctchNamePrefix] );
#endif
            }
            else
            {
                wsprintfA(sz, "%08x",(UINT_PTR)pal->rgpv[i]);
                SquirtPtszA(sz);
            }
#endif
            break;

        case 'u':                               /* 32-bit unsigned decimal */
            wsprintfA(sz, "%u", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 'C':
            if (GetClipboardFormatNameA((UINT)(UINT_PTR)pal->rgpv[i], sz, cA(sz))) {
            } else {
                wsprintfA(sz, "[%04x]", pal->rgpv[i]);
            }
            SquirtPtszA(sz);
            break;

        default: AssertF(! TEXT("Invalid character format code")); /* Invalid */
        }
    }
    SquirtPtsz(TEXT(")"));
}

/*****************************************************************************
 *
 *      EnterSqflPtsz
 *
 *      Mark entry to a procedure.  Arguments were already collected by
 *      ArgsPszV.
 *
 *      If sqfl contains the sqflBenign flag, then any error we detect
 *      should be classified as sqflBenign and not sqflError.
 *
 *      sqfl     -> squirty flags
 *      pszProc  -> procedure name
 *      pal      -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterSqflPszPal(SQFL sqfl, LPCSTR pszProc, PARGLIST pal)
{
    pal->pszProc = pszProc;
    sqfl |= sqflIn;
    if (IsSqflSet(sqfl)) {
        EmitPal(pal);
        SquirtPtsz(TEXT("\r\n"));
    }
}

void EXTERNAL
ExitSqflPalHresPpv(SQFL sqfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    BOOL fInternalError;
    SQFL sqflIsError;
    DWORD le = GetLastError();

    if (sqfl & sqflBenign) {
        sqfl &= ~sqflBenign;
        sqflIsError = sqflBenign;
    } else {
        sqflIsError = sqflError;
    }

    sqfl |= sqflOut;
    fInternalError = 0;
    if (ppvObj == ppvVoid || ppvObj == ppvDword) {
    } else if (ppvObj == ppvBool) {
        if (hres == 0) {
            sqfl |= sqflIsError;
        }
    } else {
        if (FAILED(hres)) {
            if (fLimpFF(ppvObj && !IsBadWritePtr(ppvObj, cbX(*ppvObj)),
                        *ppvObj == 0)) {
            } else {
                fInternalError = 1;
            }
            if (hres == E_NOTIMPL) {    /* E_NOTIMPL is always benign */
                sqfl |= sqflBenign;
            } else {
                sqfl |= sqflIsError;
            }
        }
    }

    if (IsSqflSet(sqfl) || fInternalError) {
        EmitPal(pal);
        SquirtPtsz(TEXT(" -> "));
        if (ppvObj != ppvVoid) {
            TCHAR tszBuf[32];
            wsprintf(tszBuf, TEXT("%08x"), hres);
            SquirtPtsz(tszBuf);
            if (HIWORD((UINT_PTR)ppvObj)) {
                wsprintf(tszBuf, TEXT(" [%08x]"),
                         dwSafeGetPdw((LPDWORD)ppvObj));
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvDword) {
                wsprintf(tszBuf, TEXT(" [%08x]"), hres);
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvBool) {
                wsprintf(tszBuf, hres ? TEXT(" OK ") :
                                 TEXT(" le=[%d]"), le);
                SquirtPtsz(tszBuf);
            }
        }
        SquirtPtsz(TEXT("\r\n"));
        AssertF(!fInternalError);
    }

    /*
     *  This redundant test prevents a breakpoint on SetLastError()
     *  from being hit constantly.
     */
    if (le != GetLastError()) {
        SetLastError(le);
    }
}

#endif

#ifdef XDEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | Random |
 *
 *          Returns a pseudorandom dword.  The value doesn't need to be
 *          statistically wonderful.
 *
 *  @returns
 *          A not very random dword.
 *
 *****************************************************************************/

DWORD s_dwRandom = 1;                   /* Random number seed */

DWORD INLINE
Random(void)
{
    s_dwRandom = s_dwRandom * 214013 + 2531011;
    return s_dwRandom;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBuf |
 *
 *          Fill a buffer with garbage.  Used in RDEBUG to make sure
 *          the caller is not relying on buffer data.
 *
 *          Note: If the buffer is not a multiple of dwords in size,
 *          the leftover bytes are not touched.
 *
 *  @parm   OUT LPVOID | pv |
 *
 *          The buffer to be scrambled.
 *
 *  @parm   UINT | cb |
 *
 *          The size of the buffer.
 *
 *****************************************************************************/

void EXTERNAL
ScrambleBuf(LPVOID pv, UINT cb)
{
    UINT idw;
    UINT cdw = cb / 4;
    LPDWORD pdw = pv;
    for (idw = 0; idw < cdw; idw++) {
        pdw[idw] = Random();
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBit |
 *
 *          Randomly set or clear a bit.
 *
 *  @parm   OUT LPDWORD | pdw |
 *
 *          The dword whose bit is to be set randomly.
 *
 *  @parm   UINT | flMask |
 *
 *          Mask for the bits to scramble.
 *
 *****************************************************************************/

void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask)
{
    *pdw ^= (*pdw ^ Random()) & flMask;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback_CompareContexts |
 *
 *          Check if two <t CONTEXT> structures are substantially the same
 *          to the extent required by the Win32 calling convention.
 *
 *          This is necessary because lots of applications pass
 *          incorrectly prototyped functions as callbacks.  Others will
 *          write callback functions that trash registers that are
 *          supposed to be nonvolatile. 
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   LPCONTEXT | pctx1 |
 *
 *          Context structure before we call the callback.
 *
 *  @parm   LPCONTEXT | pctx2 |
 *
 *          Context structure after we call the callback.
 *
 *  @returns
 *
 *          Nonzero if the two contexts are substantially the same.
 *
 *****************************************************************************/

BOOL INLINE  
Callback_CompareContexts(LPCONTEXT pctx1, LPCONTEXT pctx2)
{
#if defined(_X86_)
    return pctx1->Esp == pctx2->Esp;            /* Stack pointer */
  #if 0
    /*
     *  Can't test these registers because Win95 doesn't preserve
     *  them properly.  GetThreadContext() stashes what happens to
     *  be in the registers when you finally reach the bowels of
     *  kernel, at which point who knows what they contain...
     */
           pctx1->Ebx == pctx2->Ebx &&          /* Nonvolatile registers */
           pctx1->Esi == pctx2->Esi &&
           pctx1->Edi == pctx2->Edi &&
           pctx1->Ebp == pctx2->Ebp;
  #endif

#elif defined(_AMD64_)

    return pctx1->Rbx == pctx2->Rbx &&
           pctx1->Rbp == pctx2->Rbp &&
           pctx1->Rsp == pctx2->Rsp &&
           pctx1->Rdi == pctx2->Rdi &&
           pctx1->Rsi == pctx2->Rsi &&
           pctx1->R12 == pctx2->R12 &&
           pctx1->R13 == pctx2->R13 &&
           pctx1->R14 == pctx2->R14 &&
           pctx1->R15 == pctx2->R15;

#elif defined(_IA64_)

    return pctx1->IntSp == pctx2->IntSp &&      /* Stack pointer */
           pctx1->RsBSP == pctx2->RsBSP &&      /* Backing store pointer */
           pctx1->IntS0 == pctx2->IntS0 &&      /* Nonvolatile registers */
           pctx1->IntS1 == pctx2->IntS1 &&
           pctx1->IntS2 == pctx2->IntS2 &&
           pctx1->IntS3 == pctx2->IntS3;

#else
#error "No Target Architecture"
#endif
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback |
 *
 *          Perform a callback the paranoid way, checking that the
 *          application used the correct calling convention and preserved
 *          all nonvolatile registers.
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   DICALLBACKPROC | pfn |
 *
 *          Procedure to call back.
 *
 *  @parm   PV | pv1 |
 *
 *          First parameter to callback.
 *
 *  @parm   PV | pv2 |
 *
 *          Second parameter to callback.
 *
 *  @returns
 *
 *          Whatever the callback returns.
 *
 *****************************************************************************/

BOOL EXTERNAL
Callback(DICALLBACKPROC pfn, PV pv1, PV pv2)
{
    CONTEXT ctxPre;             /* Thread context before call */
    CONTEXT ctxPost;            /* Thread context after call */
    volatile BOOL fRc;          /* To prevent compiler from enregistering */

    /* Get state of registers before the callback */
    ctxPre.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    GetThreadContext(GetCurrentThread(), &ctxPre);

    fRc = pfn(pv1, pv2);

    ctxPost.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    if (GetThreadContext(GetCurrentThread(), &ctxPost) &&
        !Callback_CompareContexts(&ctxPre, &ctxPost)) {
        RPF("Incorrectly prototyped callback! Crash soon!");
        ValidationException();
    }

    return fRc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dimap\sources.inc ===
#begin sources file

!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk

MAJORCOMP=dinput
MINORCOMP=dimap
TARGETNAME=dimap

TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETEXT=dll

UMTYPE=windows

USER_C_FLAGS=$(USER_C_FLAGS) /EHsc

!IFDEF TARGET_WIN95
CHICAGO_PRODUCT = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_
!ELSE
C_DEFINES=$(C_DEFINES) -DWINNT -DUNICODE
!ENDIF

DLLDEF=..\dimap.def

USE_LIBCMT=1
USE_STL=1
DLLENTRY=_DllMainCRTStartup

INCLUDES= $(INCLUDES);\
        $(DXROOT)\inc;\

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\shell32.lib  \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\dinput8.lib

# Generate symbol file
USE_MAPSYM=1

!IF !$(FREEBUILD)
DEBUG_CRTS=1
!endif

SOURCES=\
        ..\dimap.rc     \
        ..\dimap.cpp    \
        ..\guids.cpp    \
        ..\obj.c        \
        ..\newthrow.cpp \

#end sources file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dical.c ===
/*****************************************************************************
 *
 *  DICal.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that manage axis ramps and calibration.
 *
 *      Structure names begin with "Joy" for historical reasons.
 *
 *  Contents:
 *
 *      CCal_CookRange
 *      CCal_RecalcRange
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCal

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | CCal_MulDiv |
 *
 *          High-speed MulDiv for Intel x86 boxes.  Otherwise, uses
 *          the standard MulDiv.  The values involved are always
 *          nonnegative.
 *
 *  @parm   LONG | lA |
 *
 *          Multiplicand.
 *
 *  @parm   LONG | lB |
 *
 *          Multiplier.
 *
 *  @parm   LONG | lC |
 *
 *          Denominator.
 *
 *  @returns
 *
 *          lA * lB / lC, with 64-bit intermediate precision.
 *
 *****************************************************************************/

#if defined(_X86_)

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) LONG EXTERNAL
CCal_MulDiv(LONG lA, LONG lB, LONG lC)
{
    lA; lB; lC;
    _asm {
        mov     eax, [esp+4]
        mul     dword ptr [esp+8]
        div     dword ptr [esp+12]
        ret     12
    }
}

#pragma warning(default:4035)

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CCal | CookAxisPOV |
 *
 *          Cook a piece of POV data into one of five defined data.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   INOUT PLONG | pl |
 *
 *          On entry, contains the raw value.  On exit, contains the
 *          cooked value.  (Or the raw value if the axis is raw.)
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/
#ifdef WINNT
void CookAxisPOV( PJOYRANGECONVERT this, LONG UNALIGNED *pl )
{
    LONG l;

    /*
     * figure out which direction this value indicates...
     */
    if( (*pl > this->lMinPOV[JOY_POVVAL_FORWARD])
      &&(*pl < this->lMaxPOV[JOY_POVVAL_FORWARD]) ) 
    {
        l = JOY_POVFORWARD;
    } 
    else if( (*pl > this->lMinPOV[JOY_POVVAL_BACKWARD])
           &&(*pl < this->lMaxPOV[JOY_POVVAL_BACKWARD]) ) 
    {
        l = JOY_POVBACKWARD;
    } 
    else if( (*pl > this->lMinPOV[JOY_POVVAL_LEFT])
           &&(*pl < this->lMaxPOV[JOY_POVVAL_LEFT]) ) 
    {
        l = JOY_POVLEFT;
    } 
    else if( (*pl > this->lMinPOV[JOY_POVVAL_RIGHT])
           &&(*pl < this->lMaxPOV[JOY_POVVAL_RIGHT]) ) 
    {
        l = JOY_POVRIGHT;
    }
    else 
    {
        l = JOY_POVCENTERED;
    }
        
    #if 0
    {
        TCHAR buf[100];
       	wsprintf(buf, TEXT("calibrated pov: %d\r\n"), l);
        OutputDebugString(buf);
    }
    #endif

    *pl = l;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CCal | CookRange |
 *
 *          Cook a piece of phys data into a range.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   INOUT PLONG | pl |
 *
 *          On entry, contains the raw value.  On exit, contains the
 *          cooked value.  (Or the raw value if the axis is raw.)
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void EXTERNAL
CCal_CookRange(PJOYRANGECONVERT this, LONG UNALIGNED *pl)
{
    if (this->fRaw) {
        /*
         *  Nothing to do!
         */
    } else {
      #ifdef WINNT
        if( this->fPolledPOV ) {
            CookAxisPOV( this, pl );
        } else 
      #endif
        {
            LONG lRc = 0;
            LONG l;
            PCJOYRAMP prmp;
        
            l = *pl;
    
            /*
             *  Choose the low or high ramp, depending on which side we're in.
             *
             *  This comparison could've been against Dmax or Dmin or Pc.
             *  We must use Dmax because we jiggered up the rmpHigh so
             *  that it rounds properly, so we can't use the flat part
             *  below rmpHigh.x because it's at the wrong level.
             */
            if (l < this->rmpHigh.x) {
                prmp = &this->rmpLow;
            } else {
                prmp = &this->rmpHigh;
            }
    
            if (l <= prmp->x) {
                lRc = 0;
            } else {
                l -= prmp->x;
                if ((DWORD)l < prmp->dx) {
                    /*
                     *  Note that prmp->dx cannot be zero because it
                     *  is greater than something!
                     */
                    lRc = CCal_MulDiv((DWORD)l, prmp->dy, prmp->dx);
                } else {
                    lRc = prmp->dy;
                }
            }
            
            lRc += prmp->y;
        
            if( this->dwCPointsNum > 2 )
            {
                LONG l2 = *pl;
                BOOL fCooked = FALSE;
                DWORD i;
    
                if(  l2 < this->rmpLow.x || l2 > (this->rmpHigh.x + (LONG)this->rmpHigh.dx) || //in Saturation Zone
                   ( l2 > (this->rmpLow.x + (LONG)this->rmpLow.dx) && l2 < this->rmpHigh.x )             //in Dead Zone
                ) {
                    //RPF( "Raw: %d Cooked: %ld in Saturation or Dead Zone." );
                    goto _exitcp;
                }
        
                for(i=0; i<this->dwCPointsNum-1; i++) {
                    if( l2 >= this->cp[i].lP && l2 < this->cp[i+1].lP ) {
                        l2 -= this->cp[i].lP;
                        if( this->cp[i+1].dwLog > this->cp[i].dwLog ) {
                            lRc = CCal_MulDiv((DWORD)l2, 
                                              this->cp[i+1].dwLog - this->cp[i].dwLog, 
                                              this->cp[i+1].lP - this->cp[i].lP);
                        } else {
                            lRc = -1 * CCal_MulDiv((DWORD)l2, 
                                              this->cp[i].dwLog - this->cp[i+1].dwLog, 
                                              this->cp[i+1].lP - this->cp[i].lP);
                        }
                        lRc += this->cp[i].dwLog;
                        AssertF(lRc >= 0);
                        AssertF(this->lMax >= this->lMin);
                        lRc = CCal_MulDiv((DWORD)lRc, 
                                              this->lMax - this->lMin + 1, 
                                              RANGEDIVISIONS);
                        lRc += this->lMin;
                        fCooked = TRUE;
                      #if 0
                        RPF( "Raw: %d Cooked: %ld  Area %d: (%d - %d) -> (%d - %d)", 
                            *pl, lRc, i, this->cp[i].lP, this->cp[i+1].lP,
                            this->cp[i].dwLog, this->cp[i+1].dwLog );
                      #endif
                        break;
                    }
                }
        
    _exitcp:
                ;
            }
        
            *pl = lRc;
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CCal | RecalcRange |
 *
 *          Compute all the values that derive from the user's
 *          range settings.
 *
 *          Be careful not to create values that will cause us to
 *          divide by zero later.  Fortunately,
 *          <f CCal_CookRange> never divides by zero due to the
 *          clever way it was written.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void EXTERNAL
CCal_RecalcRange(PJOYRANGECONVERT this)
{
    int dx;
    DWORD dwSat;

    AssertF(this->dwDz <= RANGEDIVISIONS);
    AssertF(this->dwSat <= RANGEDIVISIONS);
    AssertF(this->lMin <= this->lC);
    AssertF(this->lC   <= this->lMax);
    
    dwSat = max(this->dwSat, this->dwDz);

    /* Smin - Bottom of saturation range */
    dx = CCal_MulDiv(this->dwPc - this->dwPmin, dwSat, RANGEDIVISIONS);
    this->rmpLow.x = this->dwPc - dx;

    /* Dmin - Bottom of dead zone */
    dx = CCal_MulDiv(this->dwPc - this->dwPmin, this->dwDz, RANGEDIVISIONS);
    this->rmpLow.dx = (this->dwPc - dx) - this->rmpLow.x;

    /*
     *  Establish the vertical extent of the low end of the ramp.
     */
    this->rmpLow.y = this->lMin;
    this->rmpLow.dy = this->lC - this->lMin;


    /* Dmax - Top of the dead zone */
    dx = CCal_MulDiv(this->dwPmax - this->dwPc, this->dwDz, RANGEDIVISIONS);
    if (this->dwPmax > this->dwPc+1){
        this->rmpHigh.x = this->dwPc + dx + 1;
    } else {
        this->rmpHigh.x = this->dwPc + dx;
    }

    /* Smax - Top of the saturation range */
    dx = CCal_MulDiv(this->dwPmax - this->dwPc, dwSat, RANGEDIVISIONS);
    this->rmpHigh.dx = (this->dwPc + dx) - this->rmpHigh.x;

    /*
     *  Establish the vertical extent of the high end of the ramp.
     *
     *  If the high end is zero, then the entire ramp is zero.
     *  Otherwise, put the bottom at +1 so that when the user
     *  just barely leaves the dead zone, we report a nonzero
     *  value.  Note: If we were really clever, we could use
     *  a bias to get "round upwards", but it's not worth it.
     *
     */
    if ( (this->lMax > this->lC) && (this->dwPmax > this->dwPc+1) ) {
        this->rmpHigh.y = this->lC + 1;
    } else {
        this->rmpHigh.y = this->lC;
    }
    this->rmpHigh.dy = this->lMax - this->rmpHigh.y;

#if 0
    RPF( "Raw: %d   Dead Zone: 0x%08x  Saturation: 0x%08x", 
        this->fRaw, this->dwDz, this->dwSat );
    RPF( "Physical min: 0x%08x  max: 0x%08x cen: 0x%08x", 
        this->lMin, this->lMax, this->lC );
    RPF( "Logical  min: 0x%08x  max: 0x%08x cen: 0x%08x", 
        this->dwPmin, this->dwPmax, this->dwPc );
    RPF( "Lo ramp X: 0x%08x   dX: 0x%08x   Y: 0x%08x   dY: 0x%08x", 
        this->rmpLow.x, this->rmpLow.dx, this->rmpLow.y, this->rmpLow.dy );
    RPF( "Hi ramp X: 0x%08x   dX: 0x%08x   Y: 0x%08x   dY: 0x%08x",
        this->rmpHigh.x, this->rmpHigh.dx, this->rmpHigh.y, this->rmpHigh.dy );
#endif    

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CCal | GetProperty |
 *
 *          Read a property from a calibration structure.
 *
 *          The caller is permitted to pass a property that doesn't
 *          apply to calibration, in which case <c E_NOTIMPL>
 *          is returned, as it should be.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   REFGUID | rguid |
 *
 *          The property being retrieved.
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          The identity of the property to be obtained.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CCal_GetProperty(PJOYRANGECONVERT this, REFGUID rguid, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
    LPDIPROPDWORD pdipdw  = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);
    LPDIPROPCAL   pdipcal = CONTAINING_RECORD(pdiph, DIPROPCAL  , diph);
    LPDIPROPCPOINTS pdipcps = CONTAINING_RECORD(pdiph, DIPROPCPOINTS  , diph);
    EnterProc(CCal::GetProperty, (_ "pxp", this, rguid, pdiph));

    switch ((DWORD)(UINT_PTR)rguid) {

    case (DWORD)(UINT_PTR)DIPROP_RANGE:
        pdiprg->lMin = this->lMin;
        pdiprg->lMax = this->lMax;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        pdipdw->dwData = this->dwDz;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        pdipdw->dwData = this->dwSat;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        pdipdw->dwData = this->fRaw;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
        pdipcal->lMin = this->dwPmin;
        pdipcal->lMax = this->dwPmax;
        pdipcal->lCenter = this->dwPc;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_CPOINTS:
        pdipcps->dwCPointsNum = this->dwCPointsNum;
        memcpy( &pdipcps->cp, &this->cp, sizeof(this->cp) );
        hres = S_OK;
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CCal | SetCalibration |
 *
 *          The app (hopefully a control panel) is changing the
 *          calibration.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   IN LPCDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @parm   HKEY | hkType |
 *
 *          Registry key to use calibration information.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CCal_SetCalibration(PJOYRANGECONVERT this, LPCDIPROPINFO ppropi,
                    LPCDIPROPHEADER pdiph, HKEY hkType)
{
    HRESULT hres;

  #ifdef WINNT
    if( ppropi->dwDevType == DIDFT_POV ) {
        if( this->fPolledPOV ) {
            LPCDIPROPCALPOV pdipcalpov = CONTAINING_RECORD(pdiph, DIPROPCALPOV, diph);
            if (hkType) {
                LPDIPOVCALIBRATION ppov;
                HKEY hk;
    
                /*
                 *  We pun a DIPROPCALPOV as a DIPOVCALIBRATION.
                 */
                #define CheckField(f)   \
                  CAssertF(FIELD_OFFSET(DIPROPCALPOV, l##f) - cbX(DIPROPHEADER) == \
                           FIELD_OFFSET(DIPOVCALIBRATION, l##f))
                CheckField(Min);
                CheckField(Max);
                #undef CheckField
    
                ppov = pvAddPvCb(pdipcalpov, cbX(DIPROPHEADER));
    
                AssertF( !memcmp(ppov->lMin, pdipcalpov->lMin, cbX(DIPOVCALIBRATION)) );
                AssertF( !memcmp(ppov->lMax, pdipcalpov->lMax, cbX(DIPOVCALIBRATION)) );
    
    
                hres = CType_OpenIdSubkey(hkType, ppropi->dwDevType,
                                          DI_KEY_ALL_ACCESS, &hk);
                if (SUCCEEDED(hres)) {
    
                    /*
                     * All 0x0's for calibration is our cue to reset 
                     * to default values.              
                     */
                    if( ppov->lMin[0] == ppov->lMin[1] == ppov->lMin[2] == ppov->lMin[3] == ppov->lMin[4] == 
                        ppov->lMax[0] == ppov->lMax[1] == ppov->lMax[2] == ppov->lMax[3] == ppov->lMax[4] == 0 )
                    {
                        RegDeleteValue(hk, TEXT("Calibration")) ;
                    } else
                    {
                        hres = JoyReg_SetValue(hk, TEXT("Calibration"),
                                               REG_BINARY, ppov,
                                               cbX(DIPOVCALIBRATION));
                    }
                    RegCloseKey(hk);
                }
    
            } else {
                hres = S_FALSE;
            }
    
            if (SUCCEEDED(hres)) {
                memcpy( this->lMinPOV, pdipcalpov->lMin, cbX(pdipcalpov->lMin) );
                memcpy( this->lMaxPOV, pdipcalpov->lMax, cbX(pdipcalpov->lMax) );
            }
        } else {
            hres = E_NOTIMPL;
        }
    } else 
  #endif
    {
        LPCDIPROPCAL pdipcal = CONTAINING_RECORD(pdiph, DIPROPCAL, diph);
        if (hkType) {
            LPDIOBJECTCALIBRATION pcal;
            HKEY hk;
    
            /*
             *  We pun a DIPROPCAL as a DIOBJECTCALIBRATION.
             */
            #define CheckField(f)   \
              CAssertF(FIELD_OFFSET(DIPROPCAL, l##f) - cbX(DIPROPHEADER) == \
                       FIELD_OFFSET(DIOBJECTCALIBRATION, l##f))
            CheckField(Min);
            CheckField(Max);
            CheckField(Center);
            #undef CheckField
    
            pcal = pvAddPvCb(pdipcal, cbX(DIPROPHEADER));
    
            AssertF(pcal->lMin == pdipcal->lMin);
            AssertF(pcal->lMax == pdipcal->lMax);
            AssertF(pcal->lCenter == pdipcal->lCenter);
    
            hres = CType_OpenIdSubkey(hkType, ppropi->dwDevType,
                                      DI_KEY_ALL_ACCESS, &hk);
            if (SUCCEEDED(hres)) {
                
                /*
                 * All 0x0's for calibration is our cue to reset 
                 * to default values.              
                 */
                if(    pcal->lMin    == pcal->lMax && 
                       pcal->lCenter == pcal->lMax &&
                       pcal->lMax == 0x0 )
                {
                    RegDeleteValue(hk, TEXT("Calibration")) ;
                } else
                {
                    hres = JoyReg_SetValue(hk, TEXT("Calibration"),
                                           REG_BINARY, pcal,
                                           cbX(DIOBJECTCALIBRATION));
                }
                RegCloseKey(hk);
            }
    
        } else {
            hres = S_FALSE;
        }
    
        if (SUCCEEDED(hres)) {
            this->dwPmin  = pdipcal->lMin;
            this->dwPmax  = pdipcal->lMax;
            this->dwPc    = pdipcal->lCenter;
            CCal_RecalcRange(this);
        }
    }

    return hres;
 }

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CCal | SetProperty |
 *
 *          Write a property to a calibration structure.
 *
 *          The caller is permitted to pass a property that doesn't
 *          apply to calibration, in which case <c E_NOTIMPL>
 *          is returned, as it should be.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @parm   HKEY | hkType |
 *
 *          Registry key to use if setting calibration information.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CCal_SetProperty(PJOYRANGECONVERT this, LPCDIPROPINFO ppropi,
                 LPCDIPROPHEADER pdiph, HKEY hkType)
{
    HRESULT hres;
    LPCDIPROPRANGE pdiprg = (PCV)pdiph;
    LPCDIPROPDWORD pdipdw = (PCV)pdiph;
    LPCDIPROPCPOINTS pdipcps = (PCV)pdiph;
    LPDWORD pdw;
    EnterProc(CCal::SetProperty, (_ "pxp", this, ppropi->pguid, pdiph));

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {

    case (DWORD)(UINT_PTR)DIPROP_RANGE:
        if (pdiprg->lMin <= pdiprg->lMax) {

            this->lMin = pdiprg->lMin;
            this->lMax = pdiprg->lMax;

            this->lC = CCal_Midpoint(this->lMin, this->lMax);

            CCal_RecalcRange(this);   

            SquirtSqflPtszV(sqflCal,
                        TEXT("CCal_SetProperty:DIPROP_RANGE: lMin: %08x, lMax: %08x"), 
                              this->lMin, this->lMax );
            
            hres = S_OK;
        } else {
            RPF("ERROR DIPROP_RANGE: lMin must be <= lMax");
            hres = E_INVALIDARG;
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        pdw = &this->dwDz;
        goto finishfraction;

    case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        pdw = &this->dwSat;
        goto finishfraction;

    finishfraction:;
        if (pdipdw->dwData <= RANGEDIVISIONS) {
            *pdw = pdipdw->dwData;
            CCal_RecalcRange(this);
            hres = S_OK;

        } else {
            RPF("SetProperty: Value must be 0 .. 10000");
            hres = E_INVALIDARG;
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        if ((pdipdw->dwData & ~DIPROPCALIBRATIONMODE_VALID) == 0) {
            this->fRaw = pdipdw->dwData;
            hres = S_OK;
        } else {
            RPF("ERROR SetProperty: invalid calibration flags");
            hres = E_INVALIDARG;
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
    case (DWORD)(UINT_PTR)DIPROP_SPECIFICCALIBRATION:
        hres = CCal_SetCalibration(this, ppropi, pdiph, hkType);
        break;

    case (DWORD)(UINT_PTR)DIPROP_CPOINTS:
        this->dwCPointsNum = pdipcps->dwCPointsNum;
        memcpy( &this->cp, &pdipcps->cp, sizeof(this->cp) );
        hres = S_OK;
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diaphack.c ===
/*****************************************************************************
 *
 *  DIApHack.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support routines for app hacks
 *
 *  Contents:
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

//ISSUE-2001/03/29-timgill Need to sort out a prefixed version of of SquirtSqflPtszV
#define sqfl sqflCompat

typedef enum
{
    DICOMPATID_REACQUIRE,           // Perform auto reaquire if device lost
    DICOMPATID_NOSUBCLASS,          // Do not use subclassing
    DICOMPATID_MAXDEVICENAMELENGTH
} DIAPPHACKID, *LPDIAPPHACKID;

typedef struct tagAPPHACKENTRY
{
    LPCTSTR             pszName;
    DWORD               cbData;
    DWORD               dwOSMask;
} APPHACKENTRY, *LPAPPHACKENTRY;

typedef struct tagAPPHACKTABLE
{
    LPAPPHACKENTRY      aEntries;
    ULONG               cEntries;
} APPHACKTABLE, *LPAPPHACKTABLE;

#define BEGIN_DECLARE_APPHACK_ENTRIES(name) \
            APPHACKENTRY name[] = {

#define DECLARE_APPHACK_ENTRY(name, type, osmask) \
                { TEXT(#name), sizeof(type), osmask },

#define END_DECLARE_APPHACK_ENTRIES() \
            };

#define BEGIN_DECLARE_APPHACK_TABLE(name) \
            APPHACKTABLE name = 

#define DECLARE_APPHACK_TABLE(entries) \
                { entries, cA(entries) }

#define END_DECLARE_APPHACK_TABLE() \
            ;

#define DIHACKOS_WIN2K (0x00000001L)
#define DIHACKOS_WIN9X (0x00000002L)

BEGIN_DECLARE_APPHACK_ENTRIES(g_aheAppHackEntries)
    DECLARE_APPHACK_ENTRY(ReAcquire,            BOOL,  DIHACKOS_WIN2K )
    DECLARE_APPHACK_ENTRY(NoSubClass,           BOOL,  DIHACKOS_WIN2K )
    DECLARE_APPHACK_ENTRY(MaxDeviceNameLength,  DWORD, DIHACKOS_WIN2K | DIHACKOS_WIN9X )
END_DECLARE_APPHACK_ENTRIES()

BEGIN_DECLARE_APPHACK_TABLE(g_ahtAppHackTable)
    DECLARE_APPHACK_TABLE(g_aheAppHackEntries)
END_DECLARE_APPHACK_TABLE()


/***************************************************************************
 *
 *  AhGetOSMask
 *
 *  Description:
 *      Gets the mask for the current OS
 *      This mask should be used when we get app hacks for more than just 
 *      Win2k such that hacks can be applied selectively per OS.
 *      For now just #define a value as constant.
 *
 *  Arguments:
 *      none
 *
 *  Returns: 
 *      DWORD: Mask of flags applicable for the current OS.
 *
 ***************************************************************************/

#ifdef WINNT
#define AhGetOSMask() DIHACKOS_WIN2K 
#else
#define AhGetOSMask() DIHACKOS_WIN9X 
#endif

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | AhGetCurrentApplicationPath |
 *
 *          Gets the full path to the current application's executable.
 *
 *  @parm   OUT LPTSTR | pszPath |
 *
 *          The executable full path name
 *
 *  @parm   OUT LPTSTR * | ppszModule |
 *
 *          Pointer to the first character within the above of the module name
 *
 *  @returns
 *
 *          TRUE on success.
 *
 ***************************************************************************/

BOOL AhGetCurrentApplicationPath
(
    LPTSTR                  pszPath,
    LPTSTR *                ppszModule
)
{
    BOOL                    fSuccess                = TRUE;
    TCHAR                   szOriginal[MAX_PATH];

    EnterProcI(AhGetCurrentApplicationPath, (_ ""));

    fSuccess = GetModuleFileName(GetModuleHandle(NULL), szOriginal, cA(szOriginal));

    if(fSuccess)
    {
        fSuccess = ( GetFullPathName(szOriginal, MAX_PATH, pszPath, ppszModule) != 0 );
    }

    ExitProcF(fSuccess);

    return fSuccess;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | AhGetAppDateAndFileLen |
 *
 *          Gets the data time stamp and file length of the current 
 *          application as used to identify the application.
 *
 *  @parm   IN LPTSTR | pszExecutable |
 *
 *          The executable full path name.
 *
 *  @returns
 *
 *          TRUE on success.
 *
 *****************************************************************************/

BOOL AhGetAppDateAndFileLen
(
    LPTSTR                  pszExecutable
)
{
    HANDLE                  hFile                   = NULL;
    IMAGE_NT_HEADERS        nth;
    IMAGE_DOS_HEADER        dh;
    DWORD                   cbRead;
    BOOL                    fSuccess;

    EnterProcI(AhGetApplicationId, (_ ""));
    
    // Open the executable
    hFile = CreateFile( pszExecutable, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );

    if( hFile && ( hFile != INVALID_HANDLE_VALUE ) )
    {
        // Read the executable's DOS header
        fSuccess = ReadFile(hFile, &dh, sizeof(dh), &cbRead, NULL);

        if(!fSuccess || sizeof(dh) != cbRead)
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("Unable to read DOS header") );
            fSuccess = FALSE;
        }

        if(fSuccess && IMAGE_DOS_SIGNATURE != dh.e_magic)
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("Invalid DOS signature") );
            fSuccess = FALSE;
        }

        // Read the executable's PE header
        if(fSuccess)
        {
            cbRead = SetFilePointer(hFile, dh.e_lfanew, NULL, FILE_BEGIN);

            if((LONG)cbRead != dh.e_lfanew)
            {
                SquirtSqflPtszV(sqfl | sqflError, TEXT("Unable to seek to PE header") );
                fSuccess = FALSE;
            }
        }

        if(fSuccess)
        {
            fSuccess = ReadFile(hFile, &nth, sizeof(nth), &cbRead, NULL);

            if(!fSuccess || sizeof(nth) != cbRead)
            {
                SquirtSqflPtszV(sqfl | sqflError, TEXT("Unable to read PE header") );
                fSuccess = FALSE;
            }
        }

        if(fSuccess && IMAGE_NT_SIGNATURE != nth.Signature)
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("Invalid PE signature") );
            fSuccess = FALSE;
        }

        // Get the executable's size
        if(fSuccess)
        {
            g_dwAppDate = nth.FileHeader.TimeDateStamp;
        
            // Assuming < 4 GB
            g_dwAppFileLen = GetFileSize(hFile, NULL);

            if( (DWORD)(-1) == g_dwAppFileLen )
            {
                SquirtSqflPtszV(sqfl | sqflError, TEXT("Unable to get file size") );
                fSuccess = FALSE;
            }
        }

        // Clean up
        CloseHandle( hFile );
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflError, TEXT("CreateFile failed to open %s with error %lu"),  
            pszExecutable, GetLastError() );
        fSuccess = FALSE;
    }

    ExitProcF(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  AhOpenApplicationKey
 *
 *  Description:
 *      Opens or creates the application's root key.
 *
 *  Arguments:
 *      LPCTSTR [in]: application id.
 *
 *  Returns: 
 *      HKEY: registry key handle.
 *
 ***************************************************************************/

HKEY AhOpenApplicationKey
(
    LPCTSTR                 pszAppId
)
{

#ifdef DEBUG

    TCHAR                   szName[0x100]   = { 0 };
    LONG                    cbName          = sizeof(szName);

#endif // DEBUG

    HKEY                    hkeyAll = NULL;
    HKEY                    hkeyApp = NULL;
    HRESULT                 hr;

    EnterProcI(AhOpenApplicationKey, (_ ""));
    
    // Open the parent key
    hr = hresMumbleKeyEx( HKEY_LOCAL_MACHINE, 
        REGSTR_PATH_DINPUT TEXT("\\") REGSTR_KEY_APPHACK, KEY_READ, 0, &hkeyAll );

    if(SUCCEEDED(hr))
    {
        hr = hresMumbleKeyEx( hkeyAll, pszAppId, KEY_READ, 0, &hkeyApp );

        RegCloseKey( hkeyAll );
#ifdef DEBUG

        // Query for the application description
        if(SUCCEEDED(hr))
        {
            JoyReg_GetValue( hkeyApp, NULL, REG_SZ, szName, cbName );
            SquirtSqflPtszV(sqfl | sqflTrace, 
                TEXT( "Application description: %ls"), szName );
        }

#endif // DEBUG
    }

    ExitProc();

    return hkeyApp;
}


/***************************************************************************
 *
 *  AhGetHackValue
 *
 *  Description:
 *      Queries an apphack value.
 *
 *  Arguments:
 *      HKEY [in]: application registry key.
 *      DSAPPHACKID [in]: apphack id.
 *      LPVOID [out]: receives apphack data.
 *      DWORD [in]: size of above data buffer.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL AhGetHackValue
(
    HKEY                    hkey,
    DWORD                   dwOSMask,
    DIAPPHACKID             ahid,
    LPVOID                  pvData,
    DWORD                   cbData
)
{
    HRESULT                 hr;
    
    EnterProcI(AhGetHackValue, (_ ""));
    
    AssertF(ahid < (DIAPPHACKID)g_ahtAppHackTable.cEntries);
    AssertF(cbData == g_ahtAppHackTable.aEntries[ahid].cbData);

    if( !( dwOSMask & g_ahtAppHackTable.aEntries[ahid].dwOSMask ) )
    {
        hr = DI_OK;
    }
    else
    {
        hr = JoyReg_GetValue( hkey, g_ahtAppHackTable.aEntries[ahid].pszName, 
            REG_BINARY, pvData, cbData );
        if( !SUCCEEDED( hr ) )
        {
            SquirtSqflPtszV(sqfl | sqflBenign, 
                TEXT("failed to read value \"%s\", code 0x%08x"), 
                g_ahtAppHackTable.aEntries[ahid].pszName, hr);
        }
    }

    ExitProcF(DI_OK == hr);

    return DI_OK == hr;
}


/***************************************************************************
 *
 *  AhGetAppHacks
 *
 *  Description:
 *      Gets all app-hacks for the current application.
 *
 *  Arguments:
 *      LPDSAPPHACKS [out]: receives app-hack data.
 *
 *  Returns: 
 *      BOOL: TRUE if any apphacks exist for the current application.
 *
 ***************************************************************************/

BOOL AhGetAppHacks
( 
    LPTSTR tszAppId
)
{
    DIAPPHACKS              ahTemp;
    HKEY                    hkey = NULL;
    BOOL                    fFound;
    DWORD                   dwOSMask;
    
    EnterProcI(AhGetAppHacks, (_ "s", tszAppId));
    
    /*
     *  Assume defaults as most apps will have no registry entries
     */
    ahTemp = g_AppHacks;

    /*
     *  Get the OS version mask
     */
    dwOSMask = AhGetOSMask();

    SquirtSqflPtszV(sqfl | sqflTrace, TEXT("Finding apphacks for %s..."), tszAppId);

    /*
     *  Open the application key
     */
    hkey = AhOpenApplicationKey(tszAppId);

#define GET_APP_HACK( hackid, field ) \
        if( !AhGetHackValue( hkey, dwOSMask, hackid, &ahTemp.##field, sizeof(ahTemp.##field) ) ) \
        { \
            ahTemp.##field = g_AppHacks.##field; \
        }


    /*
     *  Query all apphack values
     */
    if( hkey && (hkey != INVALID_HANDLE_VALUE ) )
    {
        GET_APP_HACK( DICOMPATID_REACQUIRE,             fReacquire );
        GET_APP_HACK( DICOMPATID_NOSUBCLASS,            fNoSubClass );
        GET_APP_HACK( DICOMPATID_MAXDEVICENAMELENGTH,   nMaxDeviceNameLength );

        /*
         *  Copy back over the defaults
         */
        g_AppHacks = ahTemp;
    
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("fReacquire:    %d"), g_AppHacks.fReacquire );
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("fNoSubClass:   %d"), g_AppHacks.fNoSubClass );
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("nMaxDeviceNameLength:   %d"), g_AppHacks.nMaxDeviceNameLength );

        RegCloseKey(hkey);
        fFound = TRUE;
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("No apphacks exist") );
        fFound = FALSE;
    }

#undef GET_APP_HACK

    ExitProc();

    return fFound;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | AhAppRegister |
 *
 *          Registers an app 
 *          ISSUE-2001/03/29-timgill Needs more function documentation
 *
 *  @parm   IN DWORD | dwVer |
 *
 *          The version of DInput for which the application was compiled
 *
 *  @parm   IN DWORD | dwMapper |
 *
 *          0 if the caller 
 *
 *  @returns
 *
 *          TRUE on success.
 *
 *****************************************************************************/
HRESULT EXTERNAL AhAppRegister(DWORD dwVer, DWORD dwMapper)
{
    HRESULT hres = S_OK;

    EnterProcI(AhAppRegister, (_ "xx", dwVer, dwMapper));

    /*
     *  It is important to serialize this global processing here so that 
     *  elsewhere we can make read-only access to the data set up without 
     *  making any further checks.  However if an application has already 
     *  been found to use the mapper we can safely test that.  If another 
     *  thread is just about to set g_dwLastMsgSent to 
     *  DIMSGWP_DX8MAPPERAPPSTART then it will be done by the time we get 
     *  the critical section and we'll just find that there's nothing to 
     *  update and no point in sending a message.
     *  DIMSGWP_DX8MAPPERAPPSTART is the only case that needs to be fast 
     *  as the other cases normally only happen once.
     */
    if( g_dwLastMsgSent == DIMSGWP_DX8MAPPERAPPSTART )
    {
        /*
         *  Fast out if everything has been done already
         */
    }
    else
    {

        TCHAR           szExecutable[MAX_PATH];
        LPTSTR          pszModule;
        TCHAR           szAppId[MAX_PATH + 8 +8];
        DWORD           dwAppStat = 0;
        BOOL            fSuccess;

        hres = E_FAIL;

        DllEnterCrit();

        // Get the application path
        if( AhGetCurrentApplicationPath( szExecutable, &pszModule ) )
        {
            if( !g_dwLastMsgSent )
            {
                SquirtSqflPtszV(sqfl | sqflVerbose, TEXT("Application executable path: %s"), szExecutable);
                SquirtSqflPtszV(sqfl | sqflVerbose, TEXT("Application module: %s"), pszModule);
                
                fSuccess = AhGetAppDateAndFileLen( szExecutable );
            }
            else
            {
                fSuccess = TRUE;
            }

            if( fSuccess )
            {
                HKEY hKeyMain;

                hres = hresMumbleKeyEx( HKEY_CURRENT_USER, 
                    REGSTR_PATH_DINPUT, KEY_READ | KEY_WRITE, 0, &hKeyMain );

                if( SUCCEEDED( hres ) )
                {
                    HKEY hKey;
                    DWORD dwAppIdFlag;
                    DWORD dwAppDate = g_dwAppDate, dwAppSize = g_dwAppFileLen;
                    DWORD cb = cbX(dwAppIdFlag);

                    if( ERROR_SUCCESS == RegQueryValueEx( hKeyMain, DIRECTINPUT_REGSTR_VAL_APPIDFLAG, 
                        0, 0, (PUCHAR)&dwAppIdFlag, &cb ) )
                    {
                        SquirtSqflPtszV(sqfl | sqflVerbose, 
                            TEXT("AppIdFlag: %d"), dwAppIdFlag );

                        if( dwAppIdFlag & DIAPPIDFLAG_NOTIME ){
                            dwAppDate = 0;
                        }

                        if( dwAppIdFlag & DIAPPIDFLAG_NOSIZE ){
                            dwAppSize = 0;
                        }
                    }
                    
                    CharUpper( pszModule );
                    wsprintf( szAppId, TEXT("%s%8.8lX%8.8lX"), pszModule, dwAppDate, dwAppSize );
                    SquirtSqflPtszV( sqfl | sqflTrace, TEXT("Application id: %s"), szAppId );

                    /*
                     *  We must only get app hacks once, otherwise a FF driver 
                     *  that uses DInput will corrupt the application app hacks
                     */
                    if( !g_dwLastMsgSent )
                    {
                        AhGetAppHacks( szAppId );
                    }
                    
                    /*
                     *  See if this app has been registered before.
                     */
                    if( ERROR_SUCCESS == RegOpenKeyEx( hKeyMain, szAppId, 0, KEY_READ, &hKey ) )
                    {
                        cb = cbX(dwAppStat);
                        
                        if( ERROR_SUCCESS == RegQueryValueEx( hKey, DIRECTINPUT_REGSTR_VAL_MAPPER, 
                            0, 0, (PUCHAR)&dwAppStat, &cb ) )
                        {
                            SquirtSqflPtszV(sqfl | sqflVerbose, 
                                TEXT("Previous application mapper state: %d"), dwAppStat );

                            if( dwAppStat ) 
                            {
                                dwAppStat = DIMSGWP_DX8MAPPERAPPSTART;
                                dwMapper = 1;
                            }
                            else
                            {
                                dwAppStat = DIMSGWP_DX8APPSTART;
                            }
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign, TEXT("Missing ") 
                                DIRECTINPUT_REGSTR_VAL_MAPPER TEXT(" value for %s"), szAppId);
                            dwAppStat = DIMSGWP_NEWAPPSTART;
                        }
                        RegCloseKey( hKey );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflVerbose, 
                            TEXT("Unknown application") );
                        dwAppStat = DIMSGWP_NEWAPPSTART;
                    }

                    /*
                     *  Write out the application key if none existed or if 
                     *  we've just found out that this app uses the mapper.
                     */
                    if( ( dwAppStat == DIMSGWP_NEWAPPSTART )
                     || ( ( dwAppStat == DIMSGWP_DX8APPSTART ) && dwMapper ) )
                    {
                        hres = hresMumbleKeyEx( hKeyMain, szAppId, KEY_WRITE, 0, &hKey );

                        if( SUCCEEDED(hres) )
                        {
                            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_NAME, 0x0, REG_SZ, (PUCHAR)pszModule, cbCtch(lstrlen(pszModule)+1) );
                            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_MAPPER, 0x0, REG_BINARY, (PUCHAR) &dwMapper, cbX(dwMapper));
                            RegCloseKey(hKey);        
                        }

                        /*
                         *  Make dwAppStat the state to be sent if all goes well
                         */
                        if( dwMapper )
                        {
                            dwAppStat = DIMSGWP_DX8MAPPERAPPSTART;
                        }
                    }
            
                    if( SUCCEEDED(hres) && ( g_dwLastMsgSent != dwAppStat ) )
                    {
                        hres = hresMumbleKeyEx( hKeyMain, ( dwMapper ) ? DIRECTINPUT_REGSTR_KEY_LASTMAPAPP
                                                                       : DIRECTINPUT_REGSTR_KEY_LASTAPP,
                                              KEY_WRITE, 0, &hKey );
                    
                        if( SUCCEEDED(hres) )
                        {
                            FILETIME ftSysTime;
                            GetSystemTimeAsFileTime( &ftSysTime );

                            /*
                             *  Update g_dwLastMsgSent while we're still in the 
                             *  critical section.
                             */
                            g_dwLastMsgSent = dwAppStat;

                            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_NAME, 0x0, REG_SZ, (PUCHAR)pszModule, cbCtch(lstrlen(pszModule)+1));
                            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_ID, 0x0, REG_SZ, (PUCHAR) szAppId, cbCtch(lstrlen(szAppId)+1) );
                            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_VERSION, 0x0, REG_BINARY, (PUCHAR) &dwVer, cbX(dwVer));
                            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_LASTSTART, 0x0, REG_BINARY, (PUCHAR)&ftSysTime, cbX(ftSysTime));

                            RegCloseKey(hKey);        
                        }
                        else
                        {
                            /*
                             *  Zero dwAppStat to indicate that no message 
                             *  should be sent.
                             */
                            dwAppStat = 0;
                        }
                    }
                    else
                    {
                        /*
                         *  Zero dwAppStat to indicate that no message 
                         *  should be sent.
                         */
                        dwAppStat = 0;
                    }

                    RegCloseKey(hKeyMain);

                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError, 
                        TEXT("Failed to open DirectInput application status key (0x%08x)"), hres );
                        
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError, 
                    TEXT("Failed to get application details") );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError, 
                TEXT("Failed to get application path") );
        }

        DllLeaveCrit();

        /*
         *  If there's a message to send, broadcast it outside the critical section
         */
        if( dwAppStat )
        {
            PostMessage( HWND_BROADCAST, g_wmDInputNotify, dwAppStat, 0L);   
        }
    }

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dicf.c ===
/*****************************************************************************
 *
 *  DICF.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput ClassFactory.
 *
 *  Contents:
 *
 *      IClassFactory::CreateInstance
 *      IClassFactory::LockServer
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflFactory

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CDIFactory, IClassFactory);

Interface_Template_Begin(CDIFactory)
    Primary_Interface_Template(CDIFactory, IClassFactory)
Interface_Template_End(CDIFactory)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIFactory |
 *
 *          The DirectInput <i IClassFactory>, which is how you create an
 *          <i IDirectInput> object.
 *          There really isn't anything interesting in the structure
 *          itself.
 *
 *  @field  IClassFactory | cf |
 *
 *          ClassFactory object (containing vtbl).
 *
 *  @field  CREATEFUNC | pfnCreate |
 *
 *          Function that creates new objects.
 *
 *****************************************************************************/

typedef struct CDIFactory {

    /* Supported interfaces */
    IClassFactory   cf;

    CREATEFUNC pfnCreate;

} CDIFactory, DCF, *PDCF;

typedef IClassFactory CF, *PCF;

#define ThisClass CDIFactory
#define ThisInterface IClassFactory
#define ThisInterfaceT IClassFactory

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IClassFactory | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IClassFactory_AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IClassFactory_Finalize |
 *
 *          We don't have any instance data, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIFactory)
Default_AddRef(CDIFactory)
Default_Release(CDIFactory)

#else

#define CDIFactory_QueryInterface     Common_QueryInterface
#define CDIFactory_AddRef             Common_AddRef
#define CDIFactory_Release            Common_Release

#endif

#define CDIFactory_QIHelper           Common_QIHelper
#define CDIFactory_AppFinalize        Common_AppFinalize
#define CDIFactory_Finalize           Common_Finalize

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | CreateInstance |
 *
 *          This function creates a new DirectInput object with
 *          the specified interface.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown.
 *          Aggregation is not supported in this version of DirectInput,
 *          so the value "should" be 0.
 *
 *  @parm   IN REFIID | riid |
 *          Desired interface.  This parameter "must" point to a valid
 *          interface identifier.
 *
 *  @parm   OUT LPVOID * | ppvOut |
 *          Points to where to return the pointer to the created interface,
 *          if successful.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c S_OK>: The operation completed successfully.
 *
 *          <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c CLASS_E_NOAGGREGATION>:
 *          Aggregation not supported.
 *
 *          <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c E_NOINTERFACE>:
 *          The specified interface is not supported.
 *
 *  @xref   OLE documentation for <mf IClassFactory::CreateInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIFactory_CreateInstance(PCF pcf, PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IClassFactory::CreateInstance,
               (_ "ppGp", pcf, punkOuter, riid, ppvObj));

    if (SUCCEEDED(hres = hresPv(pcf))) {
        PDCF this;
        if (Num_Interfaces(CDIFactory) == 1) {
            this = _thisPvNm(pcf, cf);
        } else {
            this = _thisPv(pcf);
        }

        /*
         *  All parameters will be validated by pfnCreate.
         */
        hres = this->pfnCreate(punkOuter, riid, ppvObj);
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | LockServer |
 *
 *          This function increments or decrements the DLL lock
 *          count.  While the DLL lock count is nonzero,
 *          it will not be removed from memory.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   BOOL | fLock |
 *          If <c TRUE>, increments the lock count.
 *          If <c FALSE>, decrements the lock count.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c S_OK>: The operation completed successfully.
 *
 *          <c E_OUTOFMEMORY>: Out of memory.
 *
 *  @xref   OLE documentation for <mf IClassFactory::LockServer>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIFactory_LockServer(PCF pcf, BOOL fLock)
{
    HRESULT hres;
    EnterProcR(IClassFactory::LockServer, (_ "px", pcf, fLock));

    if (SUCCEEDED(hres = hresPv(pcf))) {
        if (fLock) {
            DllAddRef();
        } else {
            DllRelease();
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IClassFactory | New |
 *
 *          Create a new instance of the class factory.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIFactory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IClassFactory::<constructor>, (_ "G", riid));

    hres = Common_NewRiid(CDIFactory, 0, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PDCF this;
        if (Num_Interfaces(CDIFactory) == 1) {
            /* We can go directly in because we cannot be aggregated */
            this = *ppvObj;
        } else {
            this = _thisPv(*ppvObj);
        }

        this->pfnCreate = pfnCreate;
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbl.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA
#define CDIFactory_Signature  0x20204643          /* "CF  " */

Primary_Interface_Begin(CDIFactory, IClassFactory)
    CDIFactory_CreateInstance,
    CDIFactory_LockServer,
Primary_Interface_End(CDIFactory, IClassFactory)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\didenum.c ===
/*****************************************************************************
 *
 *  DIDEnum.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInput device enumerator.
 *
 *      We don't bother making this an honest OLE enumerator because
 *      there's no point.  There's no way to access it from the outside.
 *
 *  Contents:
 *
 *      CDIDEnum_New
 *      CDIDEnum_Next
 *      CDIDEnum_Release
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDEnum


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct _CDIDEnum |
 *
 *          Records the state of a device enumeration.  Note that this
 *          is not free-threaded.
 *
 *  @field  PDIW | pdiW |
 *
 *          The <i IDirectInputW> object that owns the enumeration.
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type filter.
 *
 *  @field  DWORD | edfl |
 *
 *          Enumeration flags.
 *
 *  @field  int | idosdStatic |
 *
 *          The next static device to enumerate.  Static devices live
 *          in <c c_rgdosdStatic>.
 *
 *  @field  DWORD | dwVer |
 *
 *          Version of DirectX we are emulating.
 *
 *          If we are emulating DirectX 3.0 or less, then don't
 *          reveal joysticks.
 *
 *  @field  int | idosdDynamic |
 *
 *          The next dynamic device to enumerate.  Dyanmic devices
 *          are kept in the <e CDIDEnum.rgdosdDynamic> array.  They
 *          are snapshotted into the enumeration structure to avoid
 *          race conditions if a device comes or goes while we are
 *          in the middle of an enumeration.
 *
 *  @field  PHIDDEVICELIST | phdl |
 *
 *          List of HID devices to be returned by the enumeration.
 *
 *****************************************************************************/

    typedef struct _CDIDEnum
    {
    
        D(DWORD dwSig;)
        PDIW pdiW;
        DWORD dwDevType;
        DWORD edfl;
        int idosdStatic;
        DWORD dwVer;
        int idosdDynamic;
        PHIDDEVICELIST phdl;
        PDIDW pdidW;
    } DENUM, *PDENUM, **PPDENUM;

    #define CDIDENUM_SIGNATURE  0x4D554E45          /* "ENUM" */

    #define AssertPde(pde)          AssertF((pde)->dwSig == CDIDENUM_SIGNATURE)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTSTATICDATA | c_rgdosdStatic[] |
 *
 *          Right now, the list of device is static and hard-coded.
 *          Eventually, we'll
 *          use plug and play to enumerate devices of class "input" and
 *          get information from their config/software keys.
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

/*
 *  Our array of static joystick instance guids.
 *
 */
GUID rgGUID_Joystick[cJoyMax] = {
    {   0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B71,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B72,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B73,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B74,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B75,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B76,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B77,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B78,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B79,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7A,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7B,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7C,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7D,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7E,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7F,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
};

    #if cJoyMax != 16
        #error rgGUID_Joystick supports only 16 joysticks.
    #endif

/*
 *  Note that we recycle the SysMouse GUID as the instance GUID too,
 *  since there will never be more than one system mouse installed in
 *  the system.  Similarly for SysKeyboard.
 */

DIOBJECTSTATICDATA c_rgdosdStatic[] = {
    {   &GUID_SysMouse,     DI8DEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysMouseEm,   DI8DEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysMouseEm2,  DI8DEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysKeyboard,  DI8DEVTYPE_KEYBOARD, CKbd_New,},
    {   &GUID_SysKeyboardEm,   DI8DEVTYPE_KEYBOARD, CKbd_New,},
    {   &GUID_SysKeyboardEm2,  DI8DEVTYPE_KEYBOARD, CKbd_New,},

    #ifndef WINNT
    /*
     * On WINNT all joysticks are HID devices.
     * So it is pointless to include predefined
     * Joystick GUIDs
     */
        #define MAKEJOY(n)                                                  \
    {   &rgGUID_Joystick[n],DI8DEVCLASS_GAMECTRL, CJoy_New,           }
        MAKEJOY( 0),
    MAKEJOY( 1),
    MAKEJOY( 2),
    MAKEJOY( 3),
    MAKEJOY( 4),
    MAKEJOY( 5),
    MAKEJOY( 6),
    MAKEJOY( 7),
    MAKEJOY( 8),
    MAKEJOY( 9),
    MAKEJOY(10),
    MAKEJOY(11),
    MAKEJOY(12),
    MAKEJOY(13),
    MAKEJOY(14),
    MAKEJOY(15),

        #undef MAKEJOY
    #endif

};

    #pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindInstanceGUID |
 *
 *          Locates information given an instance GUID.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @parm   OUT CREATEDCB * | pcdcb |
 *
 *          Receives pointer to the <f CreateDcb> function for the object.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresFindInstanceGUID_(PCGUID pguid, CREATEDCB *pcdcb,
                          LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    EnterProcS(hresFindInstance, (_ "G", pguid));

    if(SUCCEEDED(hres = hresFullValidGuid(pguid, iarg)))
    {
        int idosd;

        /*
         *  First try the list of static devices.  Since this
         *  list never changes, we don't need to protect it
         *  with a critical section.
         */
        for(idosd = 0; idosd < cA(c_rgdosdStatic); idosd++)
        {
            if(IsEqualGUID(pguid, c_rgdosdStatic[idosd].rguidInstance))
            {
                *pcdcb = c_rgdosdStatic[idosd].CreateDcb;
                goto done;
            }
        }

        /*
         *  So it wasn't one of the static devices.  See if it's
         *  one of the dynamic HID devices we've already found.
         */
        hres = hresFindHIDInstanceGUID(pguid, pcdcb);
        if(FAILED(hres))
        {

            /*
             *  Not on our list of dynamic HID devices.
             *  Re-enumerate them and try again.  Maybe it was
             *  for a device that we recently added.
             */
            DIHid_BuildHidList(TRUE);
            hres = hresFindHIDInstanceGUID(pguid, pcdcb);
        }

        if(FAILED(hres))
        {
        #ifdef WINNT
            /*
             *  NT Bug#351951.
             *  If they are directly asking for one of the predefined joystick 
             *  IDs then see if we have a device mapped to that ID.  If so,
             *  pretend they asked for that GUID instead.
             */

            /*
             *  Weakly Assert the range of predefined static joystick instance GUIDs
             */
            AssertF( ( rgGUID_Joystick[0].Data1 & 0x0f ) == 0 );
            AssertF( ( rgGUID_Joystick[0x0f].Data1 & 0x0f ) == 0x0f );

            /*
             *  Check the GUID is the same as the first static one ignoring LS 4 bits
             */
            if( ( (pguid->Data1 & 0xf0) == (rgGUID_Joystick[0].Data1 & 0xf0) )
              && !memcmp( ((PBYTE)&rgGUID_Joystick)+1, ((PBYTE)pguid)+1, sizeof(*pguid) - 1 ) )
            {
                RPF("%s: Using predefined instance GUIDs is bad and should not work!", s_szProc);
                if( phdiFindJoyId( pguid->Data1 & 0x0f ) )
                {
                    *pcdcb = CHid_New;
                    hres = S_OK;
                }
                else
                {
                    *pcdcb = 0;
                    hres = DIERR_DEVICENOTREG;
                }
            }
            else
            {
                RPF("%s: Warning: GUID is not installed in this system", s_szProc);
                *pcdcb = 0;
                hres = DIERR_DEVICENOTREG;
            }
        #else
            RPF("%s: Warning: GUID is not installed in this system", s_szProc);
            *pcdcb = 0;
            hres = DIERR_DEVICENOTREG;
        #endif
        }
    }

    done:;
    ExitOleProcPpv(pcdcb);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIDEnum_Release |
 *
 *          Free the enumeration object and its associated resources.
 *
 *  @parm   CDIDEnum * | pde |
 *
 *          The enumeration state to be released.
 *
 *****************************************************************************/

void EXTERNAL
    CDIDEnum_Release(PDENUM pde)
{
    EnterProcI(CDIDEnum_Release, (_ "p", pde));

    AssertPde(pde);

    /*
     *  First, release any last enumerated device
     */
    if( pde->pdidW )
    {
        OLE_Release(pde->pdidW);
    }
    OLE_Release(pde->pdiW);
    FreePpv(&pde->phdl);
    FreePv(pde);

}



    #define S_SKIP      hresUs(2)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresIsDeviceTypeMatch |
 *
 *          Test if a device type matches the filter.
 *
 *  @parm   BYTE | bFilter |
 *
 *          The device type or class to filter by.
 *
 *  @parm   BYTE | bDevType |
 *
 *          The device type to be tested.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the device matches the filter 
 *          or <c S_SKIP> if it does not.
 *
 *****************************************************************************/

HRESULT hresIsDeviceTypeMatch
( 
    BYTE bFilter,
    BYTE bDevType
)
{
    HRESULT hres;

    AssertF( bDevType >= DI8DEVTYPE_MIN );
    AssertF( bDevType < DI8DEVTYPE_MAX );

    if( ( bFilter == 0 )
     || ( bFilter == bDevType ) )
    
    {
        hres = S_OK;
    }
    else 
    {
        hres = S_SKIP;
        switch( bFilter )
        {
        case DI8DEVCLASS_DEVICE:
            if( bDevType == DI8DEVTYPE_DEVICE )
            {
                hres = S_OK;
            }
            break;
        case DI8DEVCLASS_POINTER:
            if( ( bDevType == DI8DEVTYPE_MOUSE )
             || ( bDevType == DI8DEVTYPE_SCREENPOINTER ) )
            {
                hres = S_OK;
            }
            break;
        case DI8DEVCLASS_KEYBOARD:
            if( bDevType == DI8DEVTYPE_KEYBOARD )
            {
                hres = S_OK;
            }
            break;
        case DI8DEVCLASS_GAMECTRL:
            if( (( bDevType >= DI8DEVTYPE_GAMEMIN )
              && ( bDevType < DI8DEVTYPE_GAMEMAX )) ||
                ( bDevType == DI8DEVTYPE_SCREENPOINTER ) ||  /* Windows bug 385284 (jacklin) - DI8DEVCLASS_GAMECTRL should   */
                ( bDevType == DI8DEVTYPE_SUPPLEMENTAL ) )    /* include DI8DEVTYPE_SCREENPOINTER and DI8DEVTYPE_SUPPLEMENTAL */
            {
                hres = S_OK;
            }
            break;
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDEnum_Next |
 *
 *          Return the next device.
 *
 *          Note that this is not the same as the OLE <mf IEnumXxx::Next>
 *          function.  Not that it'd be hard to convert over; it's just
 *          not needed yet.
 *
 *  @parm   CDIDEnum * | pde |
 *
 *          Maintains enumeration state.
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the enumerated GUID.
 *
 *  @parm   LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Receives device attributes.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the object was successfully obtained,
 *          or <c S_FALSE> if there aren't any more objects.
 *
 *          Warning! <f CDIObj_EnumDevicesW> assumes that this function
 *          cannot fail.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDEnum_Next(PDENUM pde, LPDIDEVICEINSTANCEW pddiW)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_Next, (_ "p", pde));

    AssertPde(pde);

    AssertF(pddiW->dwSize == cbX(*pddiW));


    /*
     *  Keep going until something works.
     */
    do
    {
        PDIOBJECTSTATICDATA pdosd;

        /*
         *  Release any previously enumerated or looked at device
         */
        if( pde->pdidW )
        {
            OLE_Release(pde->pdidW);
            pde->pdidW = NULL;
        }

        /*
         *  Pull one from the static list first.
         *  If that is empty, then pull from the dynamic list.
         *  If that is empty, then we're done.
         */
        if(pde->idosdStatic < cA(c_rgdosdStatic))
        {
            pdosd = &c_rgdosdStatic[pde->idosdStatic++];
        } else if(pde->phdl && pde->idosdDynamic < pde->phdl->chdi)
        {
            pdosd = &pde->phdl->rghdi[pde->idosdDynamic].osd;
            pdosd->rguidInstance = &pde->phdl->rghdi[pde->idosdDynamic].guid;
            pde->idosdDynamic++;
        } else
        {
            hres = S_FALSE;
            goto done;
        }

        /*
         *  ISSUE-2001/03/03-MarcAnd Filtered device enumerations are slow
         *  Since DI8DEVTYPEs can be generated on the fly and can be 
         *  overridden we can no longer filter before creating the device.
         *  This is badness.  Ideally, we need to add the WinMM and system 
         *  devices to our dynamic device list, tidy that info up and add 
         *  all the info we need to that list.
         */
        if( 1 ) 
        {

            hres = IDirectInput_CreateDevice(pde->pdiW, pdosd->rguidInstance,
                                             (PV)&pde->pdidW, 0);
            if(SUCCEEDED(hres))
            {
                if(CDIObj_TestDeviceFlags(pde->pdidW, pde->edfl) == S_OK)
                {
                    pddiW->dwSize = cbX(*pddiW);
                    hres = IDirectInputDevice_GetDeviceInfo(pde->pdidW, pddiW);

                    if( SUCCEEDED( hres ) )
                    {
                        AssertF( IsEqualGUID(pdosd->rguidInstance, &pddiW->guidInstance) );

                        hres = hresIsDeviceTypeMatch( GET_DIDEVICE_TYPE(pde->dwDevType), GET_DIDEVICE_TYPE(pddiW->dwDevType) );
                    }

                } else
                {
                    hres = S_SKIP;
                }
            } else
            {
                hres = S_SKIP;
            }
        } else
        {
            hres = S_SKIP;
        }
    } while(hres == S_SKIP);

    done:;

    AssertF(hres == S_OK || hres == S_FALSE);

    ScrambleBit(&pddiW->dwDevType, DIDEVTYPE_RANDOM);

    return hres;
}


STDMETHODIMP
    CDIDEnum_InternalNext(PDENUM pde, LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W *ppdid8W)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_Next, (_ "p", pde));

    AssertPde(pde);

    AssertF(pddiW->dwSize == cbX(*pddiW));


    /*
     *  Keep going until something works.
     */
    do
    {
        PDIOBJECTSTATICDATA pdosd;

        /*
         *  Release any previously enumerated or looked at device
         */
        if( pde->pdidW )
        {
            OLE_Release(pde->pdidW);
            pde->pdidW = NULL;
        }

        /*
         *  Pull one from the static list first.
         *  If that is empty, then pull from the dynamic list.
         *  If that is empty, then we're done.
         */
        if(pde->idosdStatic < cA(c_rgdosdStatic))
        {
            pdosd = &c_rgdosdStatic[pde->idosdStatic++];
        } else if(pde->phdl && pde->idosdDynamic < pde->phdl->chdi)
        {
            pdosd = &pde->phdl->rghdi[pde->idosdDynamic].osd;
            pdosd->rguidInstance = &pde->phdl->rghdi[pde->idosdDynamic].guid;
            pde->idosdDynamic++;
        } else
        {
            hres = S_FALSE;
            goto done;
        }

        hres = IDirectInput_CreateDevice(pde->pdiW, pdosd->rguidInstance,
                                         (PV)&pde->pdidW, 0);
        if(SUCCEEDED(hres))
        {
            if(CDIObj_TestDeviceFlags(pde->pdidW, pde->edfl) == S_OK)
            {

                pddiW->dwSize = cbX(*pddiW);
                hres = IDirectInputDevice_GetDeviceInfo(pde->pdidW, pddiW);
                *ppdid8W = (LPDIRECTINPUTDEVICE8W)pde->pdidW;

                AssertF(fLimpFF(SUCCEEDED(hres),
                                IsEqualGUID(pdosd->rguidInstance,
                                            &pddiW->guidInstance)));

                /*
                 *  Do filtering here (see ISSUE in CDIDEnum_Next for why)
                 */
                hres = hresIsDeviceTypeMatch( GET_DIDEVICE_TYPE(pde->dwDevType), GET_DIDEVICE_TYPE(pddiW->dwDevType) );

            } else
            {
                hres = S_SKIP;
            }
        } else
        {
            hres = S_SKIP;
        }
    } while(hres == S_SKIP);

    done:;

    AssertF(hres == S_OK || hres == S_FALSE);

    ScrambleBit(&pddiW->dwDevType, DIDEVTYPE_RANDOM);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDEnum_New |
 *
 *          Create an enumeration object.
 *
 *          The enumeration object snapshots the system device state
 *          and farms them out one at a time.
 *
 *  @parm   PDIW | pdiW |
 *
 *          Parent <i IDirectInputW> we piggyback off of for device
 *          creation.
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type filter.
 *
 *  @field  DWORD | edfl |
 *
 *          Enumeration flags.
 *
 *  @field  DWORD | dwVer |
 *
 *          Version of DirectX we are emulating.
 *
 *          This should always be DirectX 8.0.
 *
 *  @parm   CDIDEnum ** | ppde |
 *
 *          Receives the enumeration object.
 *
 *  @returns
 *
 *          Returns <c S_OK> on success or an error code on failure.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDEnum_New(PDIW pdiW, DWORD dwDevType, DWORD edfl, DWORD dwVer, PPDENUM ppde)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_New, (_ "pxx", pdiW, dwDevType, edfl));

    /*
     *  Refresh the HID device list so the enumeration is fresh.
     */
    DIHid_BuildHidList(TRUE);

    hres = AllocCbPpv(cbX(CDIDEnum), ppde);
    if(SUCCEEDED(hres))
    {
        PDENUM pde = *ppde;

        D(pde->dwSig = CDIDENUM_SIGNATURE);
        pde->pdiW = pdiW;
        pde->dwDevType = dwDevType;
        pde->edfl = edfl;
        pde->dwVer = dwVer;
        /*
         *  Make sure last enumerated device pointer is cleared
         */
        pde->pdidW = NULL;
        AssertF(pde->idosdStatic == 0);

        /*
         *  If enumerating only HID devices, then skip over all
         *  the static (non-HID) devices.  This is important so
         *  we don't go into infinite recursion death with WINMM.DLL,
         *  which does an enumeration to find HID joysticks
         *  in the first place.
         */
        if(pde->dwDevType & DIDEVTYPE_HID)
        {
            pde->idosdStatic = cA(c_rgdosdStatic);
        }

        AssertF(pde->idosdDynamic == 0);

        /*
         *  Clone the device list.  This must be done under the
         *  critical section to avoid races.
         */
        DllEnterCrit();
        if(g_phdl)
        {
            hres = AllocCbPpv(cbHdlChdi(g_phdl->chdi), &pde->phdl);
            if(SUCCEEDED(hres))
            {
                CopyMemory(pde->phdl, g_phdl, cbHdlChdi(g_phdl->chdi));
                SquirtSqflPtszV(sqfl, TEXT("%S: Have %d HID devices"),
                                s_szProc, pde->phdl->chdi);
                hres = S_OK;
            }
        } else
        {
            hres = S_OK;
        }
        DllLeaveCrit();

        if(SUCCEEDED(hres))
        {
            OLE_AddRef(pde->pdiW);
            hres = S_OK;
        }

    }

    ExitOleProcPpv(ppde);
    return hres;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\didev.c ===
/*****************************************************************************
 *
 *  DIDev.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The standard implementation of IDirectInputDevice.
 *
 *      This is the device-independent part.  the device-dependent
 *      part is handled by the IDirectInputDeviceCallback.
 *
 *      And the IDirectInputEffect support lives in didevef.c.
 *
 *  Contents:
 *
 *      CDIDev_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"
#define INCLUDED_BY_DIDEV
#include "didev.h"


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Interface_Template_Begin(CDIDev)
Primary_Interface_Template(CDIDev, TFORM(ThisInterfaceT))
Secondary_Interface_Template(CDIDev, SFORM(ThisInterfaceT))
Interface_Template_End(CDIDev)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PDD * | g_rgpddForeground |
 *
 *          A list of all devices which have obtained foreground
 *          acquisition.  Items on the list have been
 *          held (not AddRef'd).
 *
 *  @global UINT | g_cpddForeground |
 *
 *          The number of entries in <p g_rgpddForeground>.  When foreground
 *          activation is lost, all objects in the array are unacquired.
 *
 *
 *  @global UINT | g_cpddForegroundMax |
 *
 *          The size of the <p g_rgpddForeground> array, including dummy
 *          spaces that are not yet in use.
 *
 *****************************************************************************/


/*
 *  ISSUE-2001/03/29-timgill We assume that all-zeros is a valid initialization.
 */
    GPA g_gpaExcl;
    #define g_hgpaExcl      (&g_gpaExcl)


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | NotAcquired |
 *
 *          Check that the device is not acquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns
 *          <c S_OK> if all is well, or <c DIERR_ACQUIRED> if
 *          the device is acquired.
 *
 *****************************************************************************/

#ifndef XDEBUG

    #define IDirectInputDevice_NotAcquired_(pdd, z)                     \
       _IDirectInputDevice_NotAcquired_(pdd)                        \

#endif

HRESULT INLINE
    IDirectInputDevice_NotAcquired_(PDD this, LPCSTR s_szProc)
{
    HRESULT hres;

    if(!this->fAcquired)
    {
        hres = S_OK;
    } else
    {
        RPF("ERROR %s: May not be called while device is acquired", s_szProc);
        hres = DIERR_ACQUIRED;
    }
    return hres;
}

#define IDirectInputDevice_NotAcquired(pdd)                         \
        IDirectInputDevice_NotAcquired_(pdd, s_szProc)              \

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | IsExclAcquired |
 *
 *          Check that the device is acquired exclusively.
 *
 *          The device critical section must already be held.
 *
 *  @cwrap  PDD | this
 *
 *  @returns
 *
 *          <c S_OK> if the device is exclusively acquired.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_IsExclAcquired_(PDD this, LPCSTR s_szProc)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if(this->discl & DISCL_EXCLUSIVE)
    {
        if(this->fAcquired)
        {
            hres = S_OK;
        } else
        {
            hres = this->hresNotAcquired;
            if(hres == DIERR_NOTACQUIRED)
            {
                hres = DIERR_NOTEXCLUSIVEACQUIRED;
            }
        }
    } else
    {
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    if(s_szProc && hres == DIERR_NOTEXCLUSIVEACQUIRED)
    {
        RPF("ERROR %s: Device is not acquired in exclusive mode", s_szProc);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_EnterCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line)
{
#ifdef XDEBUG
    if( ! _TryEnterCritSec(&this->crst) )
    {
        SquirtSqflPtszV(sqflCrit, TEXT("Device CritSec blocked @%s,%d"), lptszFile, line);    
        EnterCriticalSection(&this->crst);
    }

    SquirtSqflPtszV(sqflCrit, TEXT("Device CritSec Entered @%s,%d"), lptszFile, line);    
#else        
    EnterCriticalSection(&this->crst);
#endif

    this->thidCrit = GetCurrentThreadId();
    InterlockedIncrement(&this->cCrit);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_LeaveCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line)
{
#ifdef XDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    SquirtSqflPtszV(sqflCrit | sqflVerbose, TEXT("Device CritSec Leaving @%s,%d"), lptszFile, line);    
#endif

    if(InterlockedDecrement(&this->cCrit) == 0)
    {
        this->thidCrit = 0;
    }
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | SetNotifyEvent |
 *
 *          Set the event associated with the device, if any.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_SetNotifyEvent(PDD this)
{
    if(this->hNotify)
    {
        SetEvent(this->hNotify);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | SetForcedUnacquiredFlag |
 *
 *          When forced unacquired happens, set the fOnceForcedUnacquired flag.
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_SetForcedUnacquiredFlag(PDD this)
{
    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this->fOnceForcedUnacquired = 1;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev | InCrit |
 *
 *          Nonzero if we are in the critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
    CDIDev_InCrit(PDD this)
{
    return this->cCrit && this->thidCrit == GetCurrentThreadId();
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | IDirectInputDevice | IsConsistent |
 *
 *          Check that various state variables are consistent.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

    #define VerifyF(f,m)  if( !(f) ) { fRc = 0; RPF( m ); }

BOOL INTERNAL
    CDIDev_IsConsistent(PDD this)
{
    BOOL fRc = 1;

    /*
     *  If acquired, then we must have a translation table, a state manager,
     *  and a device callback.
     */

    if(this->fAcquired)
    {
        VerifyF( this->pdix, "Acquired device has no translation table" )
        VerifyF( this->GetState, "Acquired device has no state manager" )
        VerifyF( this->pdcb != c_pdcbNil, "Acquired device has no device callback" )
    }

    /*
     *  If buffering, then must have a device callback.
     */
    if(this->celtBuf)
    {
        VerifyF( this->pdcb != c_pdcbNil, "Buffered device has no device callback" )
    }

    /*
     *  If managing an instance, then make sure buffer variables are
     *  consistent.
     */
    if(this->pvi)
    {
        if(this->celtBuf)
        {
            VerifyF( this->pvi->pBuffer, "Null internal data buffer" )
            VerifyF( this->pvi->pEnd, "Null internal end of buffer pointer" )
            VerifyF( this->pvi->pHead, "Null internal head of buffer pointer" )
            VerifyF( this->pvi->pTail, "Null internal tail of buffer pointer" )

            VerifyF( this->pvi->pBuffer < this->pvi->pEnd, "Internal buffer pointers invalid" )
            VerifyF(fInOrder((DWORD)(UINT_PTR)this->pvi->pBuffer,
                             (DWORD)(UINT_PTR)this->pvi->pHead,
                             (DWORD)(UINT_PTR)this->pvi->pEnd), "Head of internal buffer pointer invalid" )
            VerifyF(fInOrder((DWORD)(UINT_PTR)this->pvi->pBuffer,
                             (DWORD)(UINT_PTR)this->pvi->pTail,
                             (DWORD)(UINT_PTR)this->pvi->pEnd), "Tail of internal buffer pointer invalid" )
        } else
        {
            VerifyF( ( this->pvi->pBuffer == 0
                     &&this->pvi->pEnd == 0
                     &&this->pvi->pHead == 0
                     &&this->pvi->pTail == 0), "Inactive internal buffer has non-zero pointers" )
        }
    }

    /*
     *  The cooperative levels must match the cached window handle.
     */
    VerifyF(fLimpFF(this->discl & (DISCL_FOREGROUND | DISCL_EXCLUSIVE),
                    this->hwnd), "Cooperative level does not match window" );

    return fRc;
}

    #undef VerifyF

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIDev)
Default_AddRef(CDIDev)
Default_Release(CDIDev)

#else

    #define CDIDev_QueryInterface           Common_QueryInterface
    #define CDIDev_AddRef                   Common_AddRef
    #define CDIDev_Release                  Common_Release
#endif

#define CDIDev_QIHelper         Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_Reset |
 *
 *          Releases all the resources of a generic device that
 *          are associated with a particular device instance.
 *
 *          This method is called in preparation for reinitialization.
 *
 *          It is the responsibility of the caller to have taken
 *          any necessary critical sections.
 *
 *
 *  @parm   PV | pvObj |
 *
 *          Object being reset.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Reset(PDD this)
{
    HRESULT hres;

    if(!this->fAcquired)
    {

        /*
         *  Note! that we must release the driver before releasing
         *  the callback, because the callback will unload the
         *  driver DLL.
         *
         *  We cannot allow people to reset the device
         *  while there are still effects outstanding,
         *  because that would cause us to throw away the
         *  callback while the effects are still using
         *  the effect driver!
         */
        if(this->gpaEff.cpv == 0)
        {
            Invoke_Release(&this->pes);
            Invoke_Release(&this->pdcb);
            this->pdcb = c_pdcbNil;
            FreePpv(&this->pdix);
            FreePpv(&this->rgiobj);
            FreePpv(&this->pvBuffer);
            FreePpv(&this->pvLastBuffer);
            FreePpv(&this->rgdwAxesOfs);
            FreePpv(&this->rgemi);
            FreePpv(&this->rgdwPOV);

            AssertF(!this->fAcquired);
            AssertF(!this->fAcquiredInstance);

            if(this->hNotify)
            {
                CloseHandle(this->hNotify);
            }

            ZeroBuf(&this->hwnd, FIELD_OFFSET(DD, celtBufMax) -
                    FIELD_OFFSET(DD, hwnd));
            ZeroX(this->guid);
            this->celtBufMax = DEVICE_MAXBUFFERSIZE;
            this->GetDeviceState = CDIDev_GetAbsDeviceState;
            this->hresNotAcquired = DIERR_NOTACQUIRED;
            this->fCook = 0;

            AssertF(this->hNotify == 0);
            AssertF(this->cemi == 0);
            AssertF(this->didcFF == 0);
            this->dwGain = 10000;               /* Default to full gain */
            this->dwAutoCenter = DIPROPAUTOCENTER_ON; /* Default to centered */
            GPA_InitFromZero(&this->gpaEff);

            hres = S_OK;

        } else
        {
            RPF("IDirectInputDevice::Initialize: Device still has effects");
            hres = DIERR_HASEFFECTS;
        }
    } else
    {
        RPF("IDirectInputDevice::Initialize: Device is busy");
        hres = DIERR_ACQUIRED;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIDev_AppFinalize |
 *
 *          The application has performed its final release.
 *
 *          If the device is acquired, then unacquire it.
 *
 *          Release the holds on all the created effects that
 *          we have been hanging onto for enumeration purposes.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CDIDev_AppFinalize(PV pvObj)
{
    PDD this = pvObj;

    if(this->fAcquired)
    {
        RPF("IDirectInputDevice::Release: Forgot to call Unacquire()");
        CDIDev_InternalUnacquire(pvObj);
        /*
         *  If our refcount is wrong, we may have just freed ourselves.
         *  PREFIX picks this up (mb:34651) however there is no point in 
         *  adding checks in case we have bugs in refcounting as that has to 
         *  be bug free.
         */
    }

    if(this->fCritInited)
    {
        /*
         *  Stop all the effects, if they are playing.
         *
         *  Then unhold them (because we're done).
         *
         *  ISSUE-2001/03/29-timgill Need to totally remove all effects created by a destroyed device
         *  We also need to neuter them so they don't
         *  do anything any more.  Otherwise, an app might
         *  destroy the parent device and then try to mess with
         *  an effect created by that device after the device
         *  is gone.
         *
         *  Note that we cannot call the effect while inside our
         *  private little critical section, because the effect
         *  may need to do crazy things to stop itself.
         *
         *  (It will almost certainly call back up into the device
         *  to remove itself from the list of created effects.)
         */
        UINT ipdie;
        PPDIE rgpdie;
        UINT cpdie;

        CDIDev_EnterCrit(this);

        rgpdie = (PV)this->gpaEff.rgpv;
        cpdie = this->gpaEff.cpv;
        GPA_Init(&this->gpaEff);

        CDIDev_LeaveCrit(this);

        for(ipdie = 0; ipdie < cpdie; ipdie++)
        {
            AssertF(rgpdie[ipdie]);
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Device %p forgot to destroy effect %p"),
                            this, rgpdie[ipdie]);

            IDirectInputEffect_Stop(rgpdie[ipdie]);
            Common_Unhold(rgpdie[ipdie]);
        }
        FreePpv(&rgpdie);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIDev_Finalize |
 *
 *          Releases the resources of a generic device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CDIDev_Finalize(PV pvObj)
{
    HRESULT hres;
    PDD this = pvObj;

#ifdef XDEBUG
    if(this->cCrit)
    {
        RPF("IDirectInputDevice::Release: Another thread is using the object; crash soon!");
    }
#endif

    AssertF(!this->fAcquired);

    Invoke_Release(&this->pMS);

    /*
     *  Note that we cannot take the critical section because it
     *  might not exist.  (We might've died during initialization.)
     *  Fortunately, we finalize only after every possible client
     *  (both internal and external) has done its final Release(),
     *  so it's impossible for any other method to get called at
     *  this point.
     */
    hres = CDIDev_Reset(this);
    AssertF(SUCCEEDED(hres));

    if(this->fCritInited)
    {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | GetVersions |
 *
 *          Obtain version information from the device.
 *
 *          First try to get it from the effect driver.  If
 *          that doesn't work, then get it from the VxD.
 *          And if that doesn't work, then tough.
 *
 *  @parm   IN OUT LPDIDRIVERVERSIONS | pvers |
 *
 *          Receives version information.
 *
 *****************************************************************************/

void INLINE
    CDIDev_GetVersions(PDD this, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;

    /*
     *  Pre-fill with zeros in case nobody implements GetVersions.
     */
    pvers->dwSize = cbX(*pvers);
    pvers->dwFirmwareRevision = 0;
    pvers->dwHardwareRevision = 0;
    pvers->dwFFDriverVersion  = 0;

    hres = CDIDev_CreateEffectDriver(this);
    /*
     *  Prefix raises a warning (mb:34561) that this->pes could be NULL
     *  however CDIDev_CreateEffectDriver only succeeds if it is not.
     */
    if(SUCCEEDED(hres) &&
       SUCCEEDED(hres = this->pes->lpVtbl->
                 GetVersions(this->pes, pvers)))
    {
    } else
    {
        hres = this->pdcb->lpVtbl->GetVersions(this->pdcb, pvers);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetCapabilitiesHelper |
 *
 *          Obtains information about the device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputDevice> or
 *          <p lpdc> parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetCapabilitiesHelper(PV pdd)
{
    HRESULT hres;
    PDD this = _thisPv(pdd);
    LPDIDEVCAPS pdc = (PV)&this->dc3;

    pdc->dwSize = cbX(this->dc3);
    hres = this->pdcb->lpVtbl->GetCapabilities(this->pdcb, pdc);

    if(SUCCEEDED(hres))
    {
        /*
         *  We'll handle the DIDC_EMULATED and
         *  DIDC_POLLEDDATAFORMAT bits to save the callback
         *  some trouble.
         */
        AssertF(this->pvi);
        if(this->pvi->fl & VIFL_EMULATED)
        {
            pdc->dwFlags |= DIDC_EMULATED;
        }
        if(this->fPolledDataFormat)
        {
            pdc->dwFlags |= DIDC_POLLEDDATAFORMAT;
        }

        /*
         *  Add in the force feedback flags, too.
         */
        pdc->dwFlags |= this->didcFF;

        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetCapabilities |
 *
 *          Obtains information about the device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN OUT LPDIDEVCAPS | lpdc |
 *
 *          Points to a <t DIDEVCAPS> structure that is filled in
 *          by the function.  The <e DIDEVCAPS.dwSize>
 *          field "must" be filled in
 *          by the application before calling this method.
 *          See the documentation of the <t DIDEVCAPS> structure
 *          for additional information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputDevice> or
 *          <p lpdc> parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetCapabilities(PV pdd, LPDIDEVCAPS pdc _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetCapabilities, (_ "pp", pdd, pdc));

    if(SUCCEEDED(hres = hresPvT(pdd)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdc,
                                                DIDEVCAPS_DX5,
                                                DIDEVCAPS_DX3, 1)))
    {
        PDD this = _thisPv(pdd);

        CDIDev_EnterCrit(this);

        /*
         *  For the convenience of the callback, zero out all the fields,
         *  save for the dwSize.
         */
        ZeroBuf(pvAddPvCb(pdc, cbX(DWORD)), pdc->dwSize - cbX(DWORD));
        hres = this->pdcb->lpVtbl->GetCapabilities(this->pdcb, pdc);

        if(SUCCEEDED(hres))
        {
            /*
             *  We'll handle the DIDC_EMULATED and
             *  DIDC_POLLEDDATAFORMAT bits to save the callback
             *  some trouble.
             */
            AssertF(this->pvi);
            if(this->pvi->fl & VIFL_EMULATED)
            {
                pdc->dwFlags |= DIDC_EMULATED;
            }
            if(this->fPolledDataFormat)
            {
                pdc->dwFlags |= DIDC_POLLEDDATAFORMAT;
            }

            /*
             *  Add in the force feedback flags, too.
             */
            pdc->dwFlags |= this->didcFF;

            /*
             *  If the caller wants force feedback parameters, then
             *  set them, too.
             */
            if(pdc->dwSize >= cbX(DIDEVCAPS_DX5))
            {
                DIDRIVERVERSIONS vers;

                pdc->dwFFSamplePeriod      = this->ffattr.dwFFSamplePeriod;
                pdc->dwFFMinTimeResolution = this->ffattr.dwFFMinTimeResolution;

                CDIDev_GetVersions(this, &vers);
                pdc->dwFirmwareRevision    = vers.dwFirmwareRevision;
                pdc->dwHardwareRevision    = vers.dwHardwareRevision;
                pdc->dwFFDriverVersion     = vers.dwFFDriverVersion;

            }
            hres = S_OK;
        }

        CDIDev_LeaveCrit(this);

        ScrambleBit(&pdc->dwDevType, DIDEVTYPE_RANDOM);
        ScrambleBit(&pdc->dwFlags,   DIDC_RANDOM);

    }

    ExitOleProcR();
    return hres;
}


#ifdef XDEBUG

CSET_STUBS(GetCapabilities, (PV pdd, LPDIDEVCAPS pdc), (pdd, pdc THAT_))

#else

    #define CDIDev_GetCapabilitiesA         CDIDev_GetCapabilities
    #define CDIDev_GetCapabilitiesW         CDIDev_GetCapabilities

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetDataFormat |
 *
 *          Get the data format for the device if we don't have it already.
 *
 *  @parm   PDD | this |
 *
 *          Device object.
 *
 *  @returns
 *
 *          COM return code.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDataFormat(PDD this)
{
    HRESULT hres;
    LPDIDATAFORMAT pdf;

    /*
     *  If the DIDATAFORMAT structure changes, you also need to invent
     *  a new DCB message (DIDM_GETDATAFORMAT2), and then do
     *  the right thing when faced with a mix of old and new.
     */

    hres = this->pdcb->lpVtbl->GetDataFormat(this->pdcb, &pdf);


    /*
     * Note!  We don't support external drivers in this release,
     * so it's okay to treat these are Assert's and not try to recover.
     */

    if(SUCCEEDED(hres))
    {
        AssertF(pdf->dwSize == sizeof(this->df));
        this->df = *pdf;

        AssertF(!IsBadReadPtr(pdf->rgodf, cbCxX(pdf->dwNumObjs, ODF)));

        /*
         *  Prepare the axis goo in case the app sets relative mode.
         */
        if(SUCCEEDED(hres = ReallocCbPpv(pdf->dwDataSize,
                                         &this->pvLastBuffer)) &&
           SUCCEEDED(hres = ReallocCbPpv(cbCdw(pdf->dwNumObjs),
                                         &this->rgdwAxesOfs)))
        {

            UINT iobj;
            this->cAxes = 0;

            for(iobj = 0; iobj < pdf->dwNumObjs; iobj++)
            {
                AssertF(pdf->rgodf[iobj].dwOfs < pdf->dwDataSize);
                if(pdf->rgodf[iobj].dwType & DIDFT_AXIS)
                {
                    this->rgdwAxesOfs[this->cAxes++] = pdf->rgodf[iobj].dwOfs;
                }
            }
        }

    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetPolled |
 *
 *          Determine whether the device is polled.
 *
 *  @parm   PDD | this |
 *
 *          Device object.
 *
 *  @returns
 *
 *          COM result code.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetPolled(PDD this)
{
    HRESULT hres;
    DIDEVCAPS_DX3 dc;

    /*
     *  We intentionally use a DIDEVCAPS_DX3 because going for
     *  a full DIDEVCAPS_DX5 requires us to load the force
     *  feedback driver which is pointless for our current
     *  goal.
     */
    ZeroX(dc);
    dc.dwSize = cbX(dc);

    hres = this->pdcb->lpVtbl->GetCapabilities(this->pdcb, (PV)&dc);
    if(SUCCEEDED(hres))
    {
        if(dc.dwFlags & DIDC_POLLEDDEVICE)
        {
            this->hresPolled = DI_POLLEDDEVICE;
        } else
        {
            this->hresPolled = S_OK;
        }
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetObjectInfoHelper |
 *
 *          Set up all the information we can deduce ourselves and
 *          have the callback finish.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPCDIPROPINFO | ppropi |
 *
 *          Object descriptor.
 *
 *  @parm   LPDIDEVICEOBJECTINSTANCEW | pdoiW |
 *
 *          Structure to receive result.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetObjectInfoHelper(PDD this, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdoiW)
{
    HRESULT hres;

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdoiW->dwSize));
    pdoiW->guidType = *this->df.rgodf[ppropi->iobj].pguid;
    /* 
     *  Always report the internal data format offset here.  
     *  This is the way DX3 and DX5 worked until DX7 changed the behavior to
     *  report the user data format value if there was one.  That was very 
     *  confusing so revert it for DX8.
     */
    pdoiW->dwOfs    =  this->df.rgodf[ppropi->iobj].dwOfs;
    pdoiW->dwType   =  this->df.rgodf[ppropi->iobj].dwType;
    pdoiW->dwFlags  =  this->df.rgodf[ppropi->iobj].dwFlags;
    ScrambleBit(&pdoiW->dwFlags, DIDOI_RANDOM);



    /*
     *  Wipe out everything starting at tszName.
     */
    ZeroBuf(&pdoiW->tszName,
            pdoiW->dwSize - FIELD_OFFSET(DIDEVICEOBJECTINSTANCEW, tszName));

    hres = this->pdcb->lpVtbl->GetObjectInfo(this->pdcb, ppropi, pdoiW);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | EnumObjects |
 *
 *          Enumerate the input sources (buttons, axes)
 *          available on a device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMDEVICEOBJECTSCALLBACK | lpCallback |
 *
 *          Callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Reference data (context) for callback.
 *
 *  @parm   IN DWORD | fl |
 *
 *          Flags specifying the type(s) of objects to be enumerated.
 *          See the section "DirectInput Data Format Types" for a
 *          list of flags that can be passed.
 *
 *          Furthermore, the enumeration can be restricted to objects
 *          from a single HID link collection by using the
 *          <f DIDFT_ENUMCOLLECTION> macro.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumDeviceObjectsProc |
 *
 *          An application-defined callback function that receives
 *          DirectInputDevice objects as a result of a call to the
 *          <om IDirectInputDevice::EnumObjects> method.
 *
 *  @parm   IN LPCDIDEVICEOBJECTINSTANCE | lpddoi |
 *
 *          A <t DIDEVICEOBJECTINSTANCE> structure which describes
 *          the object being enumerated.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice::EnumObjects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *  @ex
 *
 *          To enumerate all axis objects:
 *
 *          |
 *
 *          // C++
 *          HRESULT hr = pDevice->EnumObjects(EnumProc, RefData, DIDFT_AXIS);
 *
 *          // C
 *          hr = IDirectInputDevice_EnumObjects(pDevice, EnumProc, RefData,
 *                                              DIDFT_AXIS);
 *
 *  @ex
 *
 *          To enumerate all objects in the third HID link collection:
 *
 *          |
 *
 *          // C++
 *          HRESULT hr = pDevice->EnumObjects(EnumProc, RefData,
 *                                            DIDFT_ENUMCOLLECTION(3));
 *
 *          // C
 *          hr = IDirectInputDevice_EnumObjects(pDevice, EnumProc, RefData,
 *                                              DIDFT_ENUMCOLLECTION(3));
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumObjectsW
    (PV pddW, LPDIENUMDEVICEOBJECTSCALLBACKW pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::EnumObjectsW, (_ "ppx", pddW, pec, fl));

    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 1)) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIDFT_ENUMVALID, 3)))
    {
        PDD this = _thisPvNm(pddW, ddW);
        DWORD flExclude;
        WORD wCollection;

        /*
         *  We snapshot the object information underneath the critical
         *  section so we don't blow up if another thread Reset()s
         *  the device in the middle of an enumeration.  The DIDATAFORMAT
         *  contains pointers to the dcb, so we need to AddRef the
         *  dcb as well.
         */
        AssertF(!CDIDev_InCrit(this));
        CDIDev_EnterCrit(this);

        if(this->pdcb != c_pdcbNil)
        {
            DIPROPINFO propi;
            DIDATAFORMAT df;
            IDirectInputDeviceCallback *pdcb;

            pdcb = this->pdcb;
            OLE_AddRef(pdcb);
            df = this->df;

            CDIDev_LeaveCrit(this);
            AssertF(!CDIDev_InCrit(this));

            flExclude = 0;

            /* Exclude alises if necessary */
            if( !(fl & DIDFT_ALIAS) )
            {
                flExclude |= DIDFT_ALIAS;
            } else
            {
                fl &= ~DIDFT_ALIAS;
            }

            /* Exclude Vendor Defined fields */
            if( !(fl & DIDFT_VENDORDEFINED) )
            {
                flExclude |= DIDFT_VENDORDEFINED;
            } else
            {
                fl &= ~DIDFT_VENDORDEFINED;
            }

            if(fl == DIDFT_ALL)
            {
                fl = DIDFT_ALLOBJS;
            }

            /*
             *  Pull out the link collection we are enumerating.
             *  Note: Backwards compatibility hack.  We can't
             *  use link collection 0 to mean "no parent" because
             *  0 means "don't care".  So instead, we use 0xFFFF
             *  to mean "no parent".  This means that we need to
             *  interchange 0 and 0xFFFF before entering the main
             *  loop.
             */
            wCollection = DIDFT_GETCOLLECTION(fl);
            switch(wCollection)
            {

            case 0:
                wCollection = 0xFFFF;
                break;

            case DIDFT_GETCOLLECTION(DIDFT_NOCOLLECTION):
                wCollection = 0;
                break;
            }

            propi.pguid = 0;

            for(propi.iobj = 0; propi.iobj < df.dwNumObjs; propi.iobj++)
            {
                propi.dwDevType = df.rgodf[propi.iobj].dwType;
                if((propi.dwDevType & fl & DIDFT_TYPEMASK) &&
                   fHasAllBitsFlFl(propi.dwDevType, fl & DIDFT_ATTRMASK) &&
                   !(propi.dwDevType & flExclude))
                {
                    DIDEVICEOBJECTINSTANCEW doiW;
                    doiW.dwSize = cbX(doiW);

                    hres = CDIDev_GetObjectInfoHelper(this, &propi, &doiW);
                    if(SUCCEEDED(hres) &&
                       fLimpFF(wCollection != 0xFFFF,
                               doiW.wCollectionNumber == wCollection))
                    {
                        BOOL fRc = Callback(pec, &doiW, pvRef);

                        switch(fRc)
                        {
                        case DIENUM_STOP: goto enumdoneok;
                        case DIENUM_CONTINUE: break;
                        default:
                            RPF("IDirectInputDevice::EnumObjects: Invalid return value from enumeration callback");
                            ValidationException();
                            break;
                        }
                    } else
                    {
                        if( hres == DIERR_OBJECTNOTFOUND ) {
                            // This can only happen on Keyboard.
                            continue;
                        } else {
                            goto enumdonefail;
                        }
                    }
                }
            }

            enumdoneok:;
            hres = S_OK;
            enumdonefail:;

            OLE_Release(pdcb);

        } else
        {
            CDIDev_LeaveCrit(this);
            RPF("ERROR: IDirectInputDevice: Not initialized");
            hres = DIERR_NOTINITIALIZED;
        }
    }

    ExitOleProcR();
    return hres;
}

#define CDIDev_EnumObjects2W            CDIDev_EnumObjectsW

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | EnumObjectsCallbackA |
 *
 *          Custom callback that wraps
 *          <mf IDirectInputDeviceW::EnumObjects> which
 *          translates the UNICODE string to ANSI.
 *
 *  @parm   IN LPCDIENUMDEVICEOBJECTINSTANCE | pdoiW |
 *
 *          Structure to be translated to ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Pointer to <t struct ENUMDEVICEOBJECTINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMOBJECTSINFO
{
    LPDIENUMDEVICEOBJECTSCALLBACKA pecA;
    PV pvRef;
} ENUMOBJECTSINFO, *PENUMOBJECTSINFO;

BOOL CALLBACK
    CDIDev_EnumObjectsCallbackA(LPCDIDEVICEOBJECTINSTANCEW pdoiW, PV pvRef)
{
    PENUMOBJECTSINFO peoi = pvRef;
    BOOL fRc;
    DIDEVICEOBJECTINSTANCEA doiA;
    EnterProc(CDIDev_EnumObjectsCallbackA,
              (_ "GxxWp", &pdoiW->guidType,
               pdoiW->dwOfs,
               pdoiW->dwType,
               pdoiW->tszName, pvRef));

    doiA.dwSize = cbX(doiA);
    ObjectInfoWToA(&doiA, pdoiW);

    fRc = peoi->pecA(&doiA, peoi->pvRef);

    ExitProcX(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | EnumObjects |
 *
 *          Enumerate the input sources (buttons, axes)
 *          available on a device, in ANSI.
 *          See <mf IDirectInputDevice::EnumObjects> for more information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMDEVICEOBJECTSCALLBACK | lpCallback |
 *
 *          Same as <mf IDirectInputDeviceW::EnumObjects>, except in ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Same as <mf IDirectInputDeviceW::EnumObjects>.
 *
 *  @parm   IN DWORD | fl |
 *
 *          Same as <mf IDirectInputDeviceW::EnumObjects>.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumObjectsA
    (PV pddA, LPDIENUMDEVICEOBJECTSCALLBACKA pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8A::EnumDevices,
               (_ "pppx", pddA, pec, pvRef, fl));

    /*
     *  EnumObjectsW will validate the rest.
     */
    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 1)))
    {
        ENUMOBJECTSINFO eoi = { pec, pvRef};
        PDD this = _thisPvNm(pddA, ddA);

        hres = CDIDev_EnumObjectsW(&this->ddW, CDIDev_EnumObjectsCallbackA,
                                   &eoi, fl);
    }

    ExitOleProcR();
    return hres;
}

#define CDIDev_EnumObjects2A            CDIDev_EnumObjectsA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetEventNotification |
 *
 *          Specify the event that should be set when the device
 *          state changes, or turns off such notifications.
 *
 *          A device state change is defined as any of the following:
 *
 *          - A change in the position of an axis.
 *
 *          - A change in the state (pressed or released) of a button.
 *
 *          - A change in the direction of a POV control.
 *
 *          - Loss of acquisition.
 *
 *          "It is an error" to call <f CloseHandle> on the event
 *          while it has been selected into an <i IDirectInputDevice>
 *          object.  You must call
 *          <mf IDirectInputDevice::SetEventNotification> with the
 *          <p hEvent> parameter set to NULL before closing the
 *          event handle.
 *
 *          The event notification handle cannot be changed while the
 *          device is acquired.
 *
 *          If the function is successful, then the application can
 *          use the event handle in the same manner as any other
 *          Win32 event handle.  Examples of usage are shown below.
 *          For additional information on using Win32 wait functions,
 *          see the Win32 SDK and related documentation.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN HANDLE | hEvent |
 *
 *          Specifies the event handle which will be set when the
 *          device state changes.  It "must" be an event
 *          handle.  DirectInput will <f SetEvent> the handle when
 *          the state of the device changes.
 *
 *          The application should create the handle via the
 *          <f CreateEvent> function.  If the event is created as
 *          an automatic-reset event, then the operating system will
 *          automatically reset the event once a wait has been
 *          satisfied.  If the event is created as a manual-reset
 *          event, then it is the application's responsibility to
 *          call <f ResetEvent> to reset it.  DirectInput will not
 *          call <f ResetEvent> for event notification handles.
 *
 *          If the <p hEvent> is zero, then notification is disabled.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_HANDLEEXISTS>: The  <i IDirectInputDevice> object
 *          already has an event notification handle
 *          associated with it.  DirectInput supports only one event
 *          notification handle per <i IDirectInputDevice> object.
 *
 *          <c DIERR_ACQUIRED>: The <i IDirectInputDevice> object
 *          has been acquired.  You must <mf IDirectInputDevice::Unacquire>
 *          the device before you can change the notification state.
 *
 *          <c E_INVALIDARG>: The thing isn't an event handle.
 *
 *  @ex
 *
 *          To check if the handle is currently set without blocking:
 *
 *          |
 *
 *          dwResult = WaitForSingleObject(hEvent, 0);
 *          if (dwResult == WAIT_OBJECT_0) {
 *              // Event is set.  If the event was created as
 *              // automatic-reset, then it has also been reset.
 *          }
 *
 *  @ex
 *
 *          The following example illustrates blocking
 *          indefinitely until the event is set.  Note that this
 *          behavior is <y strongly> discouraged because the thread
 *          will not respond to the system until the wait is
 *          satisfied.  (In particular, the thread will not respond
 *          to Windows messages.)
 *
 *          |
 *
 *          dwResult = WaitForSingleObject(hEvent, INFINITE);
 *          if (dwResult == WAIT_OBJECT_0) {
 *              // Event has been set.  If the event was created as
 *              // automatic-reset, then it has also been reset.
 *          }
 *
 *  @ex
 *
 *          The following example illustrates a typical message loop
 *          for a message-based application that uses two events.
 *
 *          |
 *
 *          HANDLE ah[2] = { hEvent1, hEvent2 };
 *
 *          while (TRUE) {
 *
 *              dwResult = MsgWaitForMultipleObjects(2, ah, FALSE,
 *                                                   INFINITE, QS_ALLINPUT);
 *              switch (dwResult) {
 *              case WAIT_OBJECT_0:
 *                  // Event 1 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent1();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 1:
 *                  // Event 2 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent2();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 2:
 *                  // A Windows message has arrived.  Process messages
 *                  // until there aren't any more.
 *                  while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
 *                      if (msg.message == WM_QUIT) {
 *                          goto exitapp;
 *                      }
 *                      TranslateMessage(&msg);
 *                      DispatchMessage(&msg);
 *                  }
 *                  break;
 *
 *              default:
 *                  // Unexpected error.
 *                  Panic();
 *                  break;
 *              }
 *          }
 *
 *  @ex
 *
 *          The following example illustrates a typical application loop
 *          for a non-message-based application that uses two events.
 *
 *          |
 *
 *          HANDLE ah[2] = { hEvent1, hEvent2 };
 *          DWORD dwWait = 0;
 *
 *          while (TRUE) {
 *
 *              dwResult = MsgWaitForMultipleObjects(2, ah, FALSE,
 *                                                   dwWait, QS_ALLINPUT);
 *              dwWait = 0;
 *
 *              switch (dwResult) {
 *              case WAIT_OBJECT_0:
 *                  // Event 1 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent1();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 1:
 *                  // Event 2 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent2();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 2:
 *                  // A Windows message has arrived.  Process messages
 *                  // until there aren't any more.
 *                  while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
 *                      if (msg.message == WM_QUIT) {
 *                          goto exitapp;
 *                      }
 *                      TranslateMessage(&msg);
 *                      DispatchMessage(&msg);
 *                  }
 *                  break;
 *
 *              default:
 *                  // No input or messages waiting.
 *                  // Do a frame of the game.
 *                  // If the game is idle, then tell the next wait
 *                  // to wait indefinitely for input or a message.
 *                  if (!DoGame()) {
 *                      dwWait = INFINITE;
 *                  }
 *                  // Poll for data in case the device is not
 *                  // interrupt-driven.
 *                  IDirectInputDevice8_Poll(pdev);
 *                  break;
 *              }
 *          }
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetEventNotification(PV pdd, HANDLE h _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SetEventNotification, (_ "px", pdd, h));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent somebody from
         *  acquiring or setting a new event handle while we're changing it.
         */
        CDIDev_EnterCrit(this);

        if(!this->fAcquired)
        {
            /*
             *  Don't operate on the original handle because
             *  the app might decide to do something *interesting* to it
             *  on another thread.
             */

            hres = DupEventHandle(h, &h);

            if(SUCCEEDED(hres))
            {
                /*
                 *  Resetting the event serves two purposes.
                 *
                 *  1. It performs parameter validation for us, and
                 *  2. The event must be reset while the device is
                 *     not acquired.
                 */
                if(fLimpFF(h, ResetEvent(h)))
                {

                    if(!this->hNotify || !h)
                    {
                        hres = this->pdcb->lpVtbl->
                               SetEventNotification(this->pdcb, h);
                        
                        /*
                         *  All dcb's use default handling for now so 
                         *  assert the callback returns S_FALSE
                         *  so we are reminded to change this if need be.
                         *  An uninitialized device would fail but don't 
                         *  break if we hit one of those, just assert that 
                         *  we won't accidentally call a HEL on it.
                         */
                        AssertF( ( hres == S_FALSE )
                            || ( ( hres == DIERR_NOTINITIALIZED ) && !this->pvi ) );

                        if(this->pvi)
                        {
                            VXDDWORDDATA vhd;
                            vhd.pvi = this->pvi;
                            vhd.dw = (DWORD)(UINT_PTR)h;
                            hres = Hel_SetNotifyHandle(&vhd);
                            AssertF(SUCCEEDED(hres)); /* Should never fail */
                            h = (HANDLE)(UINT_PTR)pvExchangePpvPv64(&this->hNotify, (UINT_PTR)h);
                            hres = this->hresPolled;
                        }
                        else
                        {
                            /*
                             *  ISSUE-2001/03/29-timgill Is this actually an error case?
                             *  Can this ever validly occur?
                             *  if yes, don't we need any of the above?
                             */
                            RPF( "Device internal data missing on SetEventNotification" );
                        }

                    } else
                    {
                        hres = DIERR_HANDLEEXISTS;
                    }
                } else
                {
                    RPF( "Handle not for Event in SetEventNotification" );
                    hres = E_HANDLE;
                }

                /*
                 *  Close the old handle if we swapped one out
                 *  or our duplicate if something went wrong
                 */
                if(h != 0)
                {
                    CloseHandle(h);
                }
            }
        } else
        {
            hres = DIERR_ACQUIRED;
        }
        CDIDev_LeaveCrit(this);
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(SetEventNotification, (PV pdd, HANDLE h), (pdd, h THAT_))

#else

    #define CDIDev_SetEventNotificationA    CDIDev_SetEventNotification
    #define CDIDev_SetEventNotificationW    CDIDev_SetEventNotification

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | hresMapHow |
 *
 *          Map the <p dwObj> and <p dwHow> fields into an object index.
 *
 *  @parm   DWORD | dwObj |
 *
 *          Object identifier.
 *
 *  @parm   DWORD | dwHow |
 *
 *          How <p dwObj> should be interpreted.
 *
 *  @parm   OUT LPDIPROPINFO | ppropi |
 *
 *          Receives object index and <p dwDevType>.
 *
 *****************************************************************************/

#ifndef XDEBUG

    #define CDIDev_hresMapHow_(this, dwObj, dwHow, ppropi, z)           \
       _CDIDev_hresMapHow_(this, dwObj, dwHow, ppropi)              \

#endif

STDMETHODIMP
    CDIDev_hresMapHow_(PDD this, DWORD dwObj, DWORD dwHow,
                       LPDIPROPINFO ppropi, LPCSTR s_szProc)
{
    HRESULT hres;

    if(this->pdcb != c_pdcbNil)
    {
        int iobj = 0;

        switch(dwHow)
        {

        case DIPH_DEVICE:
            if(dwObj == 0)
            {
                ppropi->iobj = 0xFFFFFFFF;
                ppropi->dwDevType = 0;
                hres = S_OK;
            } else
            {
                RPF("%s: dwObj must be zero if DIPH_DEVICE", s_szProc);
                hres = E_INVALIDARG;
            }
            break;

        case DIPH_BYOFFSET:
            if(this->pdix && this->rgiobj)
            {
                if(dwObj < this->dwDataSize)
                {
                    iobj = this->rgiobj[dwObj];
                    if(iobj >= 0)
                    {
                        AssertF(this->pdix[iobj].dwOfs == dwObj);
                        ppropi->iobj = iobj;
                        ppropi->dwDevType = this->df.rgodf[iobj].dwType;
                        hres = S_OK;
                        goto done;
                    } else
                    {
                        AssertF(iobj == -1);
                    }
                }

                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%S: Invalid offset in dwObj. You may use DIPH_BYID to enum it."), s_szProc);

                //RPF("%s: Invalid offset in dwObj", s_szProc);

            } else
            {
                RPF("%s: Must have a data format to use if DIPH_BYOFFSET", s_szProc);
            }
            hres = DIERR_OBJECTNOTFOUND;
            goto done;

        case DIPH_BYID:
            for(iobj = this->df.dwNumObjs; --iobj >= 0; )
            {
                if(DIDFT_FINDMATCH(this->df.rgodf[iobj].dwType, dwObj))
                {
                    ppropi->iobj = iobj;
                    ppropi->dwDevType = this->df.rgodf[iobj].dwType;
                    hres = S_OK;
                    goto done;
                }
            }
            RPF("%s: Invalid ID in dwObj", s_szProc);
            hres = DIERR_OBJECTNOTFOUND;
            break;

        case DIPH_BYUSAGE:
            hres = IDirectInputDeviceCallback_MapUsage(this->pdcb,
                                                       dwObj, &ppropi->iobj);
            if(SUCCEEDED(hres))
            {
                ppropi->dwDevType = this->df.rgodf[ppropi->iobj].dwType;
            }
            break;

        default:
            RPF("%s: Invalid dwHow", s_szProc);
            hres = E_INVALIDARG;
            break;
        }

        done:;
    } else
    {
        RPF("ERROR: IDirectInputDevice: Not initialized");
        hres = DIERR_NOTINITIALIZED;
    }

    return hres;
}

#define CDIDev_hresMapHow(this, dwObj, dwHow, pdwOut)               \
       CDIDev_hresMapHow_(this, dwObj, dwHow, pdwOut, s_szProc)     \

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetObjectInfo |
 *
 *          Obtains information about an object.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEOBJECTINSTANCE | pdidoi |
 *
 *          Receives information about the object.
 *          The caller "must" initialize the <e DIDEVICEOBJECTINSTANCE.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwObj |
 *
 *          Identifies the object for which the property is to be
 *          accessed.  The meaning of this value depends on the
 *          value of the <p dwHow> parameter.
 *          See the documentation of the <t DIPROPHEADER>
 *          structure for additional information.
 *
 *  @parm   DWORD | dwHow |
 *
 *          Identifies how <p dwObj> is to be interpreted.
 *          It must be one of the <c DIPH_*> values.
 *          See the documentation of the <t DIPROPHEADER>
 *          structure for additional information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_OBJECTNOTFOUND>:  The specified object does not
 *          exist.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetObjectInfoW(PV pddW, LPDIDEVICEOBJECTINSTANCEW pdoiW,
                          DWORD dwObj, DWORD dwHow)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetObjectInfo,
               (_ "ppxx", pddW, pdoiW, dwObj, dwHow));

    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdoiW,
                                                DIDEVICEOBJECTINSTANCE_DX5W,
                                                DIDEVICEOBJECTINSTANCE_DX3W, 1)))
    {
        PDD this = _thisPvNm(pddW, ddW);
        DIPROPINFO propi;

        /*
         *  Must protect with the critical section to prevent
         *  another thread from Reset()ing behind our back.
         */
        CDIDev_EnterCrit(this);

        propi.pguid = 0;
        /*
         *  Prefix picks up that ppropi->iobj is uninitialized (mb:34557) in 
         *  the case of a BY_USAGE dwHow.  However, the value is only an 
         *  output for MapUsage which will always either set it or fail so 
         *  there is no error.
         */

        hres = CDIDev_hresMapHow(this, dwObj, dwHow, &propi);

        if(SUCCEEDED(hres))
        {
            if(dwHow != DIPH_DEVICE)
            {
                hres = CDIDev_GetObjectInfoHelper(this, &propi, pdoiW);
            } else
            {
                RPF("%s: Invalid dwHow", s_szProc);
                hres = E_INVALIDARG;
            }
        }

        if(FAILED(hres))
        {
            ScrambleBuf(&pdoiW->guidType,
                        pdoiW->dwSize -
                        FIELD_OFFSET(DIDEVICEOBJECTINSTANCEW, guidType));
        }

        CDIDev_LeaveCrit(this);
    }

    ExitBenignOleProcR();
    return hres;
}

#define CDIDev_GetObjectInfo2W          CDIDev_GetObjectInfoW

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | GetObjectInfo |
 *
 *          ANSI version of same.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEOBJECTINSTANCEA | pdoiA |
 *
 *          Receives information about the device's identity.
 *
 *  @parm   DWORD | dwObj |
 *
 *          Identifies the object for which the property is to be
 *          accessed.
 *
 *  @parm   DWORD | dwHow |
 *
 *          Identifies how <p dwObj> is to be interpreted.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetObjectInfoA(PV pddA, LPDIDEVICEOBJECTINSTANCEA pdoiA,
                          DWORD dwObj, DWORD dwHow)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetObjectInfo,
               (_ "ppxx", pddA, pdoiA, dwObj, dwHow));

    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdoiA,
                                                DIDEVICEOBJECTINSTANCE_DX5A,
                                                DIDEVICEOBJECTINSTANCE_DX3A, 1)))
    {
        PDD this = _thisPvNm(pddA, ddA);
        DIDEVICEOBJECTINSTANCEW doiW;

        doiW.dwSize = cbX(DIDEVICEOBJECTINSTANCEW);

        hres = CDIDev_GetObjectInfoW(&this->ddW, &doiW, dwObj, dwHow);

        if(SUCCEEDED(hres))
        {
            ObjectInfoWToA(pdoiA, &doiW);
            hres = S_OK;
        }
    }

    ExitBenignOleProcR();
    return hres;
}

#define CDIDev_GetObjectInfo2A          CDIDev_GetObjectInfoA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetDeviceInfo |
 *
 *          Obtains information about the device's identity.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEINSTANCE | pdidi |
 *
 *          Receives information about the device's identity.
 *          The caller "must" initialize the <e DIDEVICEINSTANCE.dwSize>
 *          field before calling this method.
 *
 *          If <e DIDEVICEINSTANCE.dwSize> is equal to the size of
 *          the <t DIDEVICEINSTANCE_DX3> structure, then a
 *          DirectX 3.0-compatible structure is returned instead of
 *          a DirectX 5.0 structure.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceInfoW(PV pddW, LPDIDEVICEINSTANCEW pdidiW)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetDeviceInfo, (_ "pp", pddW, pdidiW));

    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdidiW,
                                                DIDEVICEINSTANCE_DX5W,
                                                DIDEVICEINSTANCE_DX3W, 1)))
    {
        PDD this = _thisPvNm(pddW, ddW);

        /*
         *  Must protect with the critical section to prevent
         *  another thread from Reset()ing behind our back.
         */
        CDIDev_EnterCrit(this);

        pdidiW->guidInstance = this->guid;
        pdidiW->guidProduct  = this->guid;

        /*
         *  Don't overwrite the dwSize, guidInstance, or guidProduct.
         *  Start at the dwDevType.
         */

        ZeroBuf(&pdidiW->dwDevType,
                pdidiW->dwSize - FIELD_OFFSET(DIDEVICEINSTANCEW, dwDevType));

        hres = this->pdcb->lpVtbl->GetDeviceInfo(this->pdcb, pdidiW);

        if(FAILED(hres))
        {
            ScrambleBuf(&pdidiW->guidInstance,
                        cbX(DIDEVICEINSTANCEW) -
                        FIELD_OFFSET(DIDEVICEINSTANCEW, guidInstance));
        }

        CDIDev_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DeviceInfoWToA |
 *
 *          Convert a <t DIDEVICEINSTANCEW> to a <t DIDEVICEINSTANCE_DX3A>
 *          <t DIDEVICEINSTANCE_DX5A> or a <t DIDEVICEINSTANCE_DX8A>.
 *
 *  @parm   LPDIDIDEVICEINSTANCEA | pdiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIDIDEVICEINSTANCEW | pdiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    DeviceInfoWToA(LPDIDEVICEINSTANCEA pdiA, LPCDIDEVICEINSTANCEW pdiW)
{
    EnterProc(DeviceInfoWToA, (_ "pp", pdiA, pdiW));

    AssertF(pdiW->dwSize == sizeof(DIDEVICEINSTANCEW));

    AssertF(IsValidSizeDIDEVICEINSTANCEA(pdiA->dwSize));

    pdiA->guidInstance = pdiW->guidInstance;
    pdiA->guidProduct  = pdiW->guidProduct;
    pdiA->dwDevType    = pdiW->dwDevType;

    UToA(pdiA->tszInstanceName, cA(pdiA->tszInstanceName), pdiW->tszInstanceName);
    UToA(pdiA->tszProductName, cA(pdiA->tszProductName), pdiW->tszProductName);

    if(pdiA->dwSize >= cbX(DIDEVICEINSTANCE_DX5A))
    {
        pdiA->guidFFDriver       = pdiW->guidFFDriver;
        pdiA->wUsage             = pdiW->wUsage;
        pdiA->wUsagePage         = pdiW->wUsagePage;
    }

    ExitProc();
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Device8WTo8A |
 *
 *          Convert a <t LPDIRECTINPUTDEVICE8W> to a <t LPDIRECTINPUTDEVICE8A>.
 *
 *  @parm   LPDIRECTINPUTDEVICE8A * | ppdid8A |
 *
 *          Destination.
 *
 *  @parm   LPDIRECTINPUTDEVICE8W | pdid8W |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    Device8WTo8A(LPDIRECTINPUTDEVICE8A *ppdid8A, LPDIRECTINPUTDEVICE8W pdid8W)
{
    PDD this;

    EnterProc(Device8WTo8A, (_ "pp", ppdid8A, pdid8W));

    this = _thisPvNm(pdid8W, ddW);
    *ppdid8A = (ThisInterfaceA*)&this->ddA;

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | GetDeviceInfo |
 *
 *          ANSI version of same.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEINSTANCEA | pdidiA |
 *
 *          Receives information about the device's identity.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceInfoA(PV pddA, LPDIDEVICEINSTANCEA pdidiA)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetDeviceInfo, (_ "pp", pddA, pdidiA));

    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdidiA,
                                                DIDEVICEINSTANCE_DX5A,
                                                DIDEVICEINSTANCE_DX3A, 1)))
    {
        PDD this = _thisPvNm(pddA, ddA);
        DIDEVICEINSTANCEW diW;

        diW.dwSize = cbX(DIDEVICEINSTANCEW);

        hres = CDIDev_GetDeviceInfoW(&this->ddW, &diW);

        if(SUCCEEDED(hres))
        {
            DeviceInfoWToA(pdidiA, &diW);
            hres = S_OK;
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | UnhookCwp |
 *
 *          Remove the CallWndProc handler.
 *
 *          See <mf CDIDev::InstallCwp> for details.
 *
 *****************************************************************************/

HWND g_hwndExclusive;
HHOOK g_hhkCwp;

void INTERNAL
    CDIDev_UnhookCwp(void)
{
    DllEnterCrit();

    if(g_hhkCwp)
    {
        UnhookWindowsHookEx(g_hhkCwp);
        g_hhkCwp = 0;
        g_hwndExclusive = 0;
    }

    DllLeaveCrit();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | AddForegroundDevice |
 *
 *          Add ourselves to the list of devices that need to be
 *          unacquired when the window loses foreground activation.
 *
 *  @parm   PDD | this |
 *
 *          Device to be added.
 *
 *  @devnote
 *
 *          Note that we do not need to AddRef the device, because
 *          <f CDIDev_Finalize> will unacquire the device for us
 *          automatically, so we will never be freed while still
 *          acquired.
 *
 *          (Note that if we did choose to AddRef, it must be done
 *          outside the DLL critical
 *          section, in order to preserve the semaphore hierarchy.)
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_AddForegroundDevice(PDD this)
{
    HRESULT hres;
    DllEnterCrit();

    hres = GPA_Append(g_hgpaExcl, this);
    Common_Hold(this);
    DllLeaveCrit();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | DelForegroundDevice |
 *
 *          Remove ourselves from the list, if we're there.
 *          It is not an error if we aren't on the list, because
 *          in the case of forced unacquire, the list is blanked
 *          out in order to avoid race conditions where somebody
 *          tries to acquire a device immediately upon receiving
 *          foreground activation, before we get a chance to
 *          unacquire all the old guys completely.
 *
 *  @parm   PDD | this |
 *
 *          Device to be removed.
 *
 *  @devnote
 *
 *          Note that the Unhold must be done outside the DLL critical
 *          section, in order to preserve the semaphore hierarchy.
 *
 *          Theoretically, the unhold will never drop the reference count
 *          to zero (because the latest it could be called is during
 *          the AppFinalize, where there is stll the outstanding refcount
 *          from the external ref that hasn't been released yet).
 *
 *          But it's better to play it safe and always release the
 *          object outside.
 *
 *****************************************************************************/

void INTERNAL
    CDIDev_DelForegroundDevice(PDD this)
{
    HRESULT hres;

    DllEnterCrit();

    hres = GPA_DeletePtr(g_hgpaExcl, this);
    if(hres == hresUs(0))
    {            /* If the last one went away */
        GPA_Term(g_hgpaExcl);           /* Free the tracking memory */
        CDIDev_UnhookCwp();             /* Then unhook ourselves */
    }

    DllLeaveCrit();

    if(SUCCEEDED(hres))
    {
        Common_Unhold(this);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CDIDev_CallWndProc |
 *
 *          Thread-specific CallWndProc handler.
 *
 *          Note that we need only one of these, since only the foreground
 *          window will require a hook.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          "Specifies whether the message is sent by the current process."
 *          We don't care.
 *
 *  @parm   LPARAM | lp |
 *
 *          Points to a <t CWPSTRUCT> which describes the message.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CDIDev_CallWndProc(int nCode, WPARAM wp, LPARAM lp)
{
    LRESULT rc;
    LPCWPSTRUCT pcwp = (LPCWPSTRUCT)lp;
  #ifdef WINNT
    static BOOL fKillFocus = FALSE;
    static BOOL fIconic = FALSE;

    fIconic = FALSE;

    /*
     * This part of code is to fix Windows bug 430051.
     * The logic is: if WM_KILLFOCUS is followed by WM_SIZE(minimized),
     * then the app is minimized from full screen mode.
     * This combination should only happen to full screen mode game using DDraw.
     */
    if(pcwp->message == WM_KILLFOCUS)
    {
        fKillFocus = TRUE;
    } else if(pcwp->message == WM_SETFOCUS)
    {
        fKillFocus = FALSE;
    } else if (pcwp->message == WM_SIZE)
    {
        if(pcwp->wParam == SIZE_MINIMIZED){
            if( fKillFocus ) {
                fIconic = TRUE;
                fKillFocus = FALSE;
            }else{
                fKillFocus = FALSE;
            }
        } else {
            fKillFocus = FALSE;
        }
    }
  #endif
  
    rc = CallNextHookEx(g_hhkCwp, nCode, wp, lp);

    if( nCode == HC_ACTION && (pcwp->message == WM_ACTIVATE 
                             #ifdef WINNT
                               || fIconic
                             #endif
                               ) 
      )
    {
        PDD *rgpdid;
        UINT ipdid, cpdid;

      #ifdef WINNT
        fIconic = FALSE;
      #endif

        /*
         *  We cannot mess with items while inside the DLL critical section,
         *  because that would violate our semaphore hierarchy.
         *
         *  Instead, we stash the active item list and replace it with
         *  an empty list.  Then, outside the DLL critical section, we
         *  calmly operate on each item.
         */
        DllEnterCrit();
        rgpdid = (PV)g_hgpaExcl->rgpv;
        cpdid = g_hgpaExcl->cpv;
        GPA_Init(g_hgpaExcl);

        /*
         *  Some sanity checking here.
         */

        for(ipdid = 0; ipdid < cpdid; ipdid++)
        {
            AssertF(rgpdid[ipdid]);
        }

        DllLeaveCrit();

        /*
         *  Note that InternalUnacquire will set the notification
         *  event so the app knows that input was lost.
         */
        for(ipdid = 0; ipdid < cpdid; ipdid++)
        {
            AssertF(rgpdid[ipdid]);
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqfl,
                            TEXT("Forcing unacquire of %p due to focus loss"),
                            rgpdid[ipdid]);
            CDIDev_InternalUnacquire(rgpdid[ipdid]);
            /*
             *  Prefix notices (mb:34651) that the above could release the 
             *  interface, causing the following to party on garbage but this 
             *  should be OK as long as we don't have a refcounting bug.
             */
            Common_Unhold(rgpdid[ipdid]);
        }
        FreePpv(&rgpdid);

        CDIDev_UnhookCwp();
    }

    return rc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | CanAcquire |
 *
 *          Determine whether the device may be acquired exclusively.
 *
 *          If exclusive access is not requested, then the function
 *          succeeds vacuously.
 *
 *          If exclusive access is requested, then the window must
 *          be the foreground window and must belong to the current
 *          process.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_CanAcquire(PDD this)
{
    HRESULT hres;

    AssertF(CDIDev_IsConsistent(this));
    if(this->discl & DISCL_FOREGROUND)
    {
        HWND hwndForeground = GetForegroundWindow();

		AssertF(this->hwnd);
        /*
         *  Note that we don't have to do an IsWindow() on this->hwnd,
         *  because GetForegroundWindow() will always return a valid
         *  window or NULL.  Since we already tested this->hwnd != 0
         *  above, the only way the equality can occur is if the window
         *  handle is indeed valid.
         */
        if(this->hwnd == hwndForeground && !IsIconic(this->hwnd))
        {
            /*
             *  Need to make sure that the window "still" belongs to
             *  this process, in case the window handle got recycled.
             */
            DWORD idProcess;
            GetWindowThreadProcessId(this->hwnd, &idProcess);
            if(idProcess == GetCurrentProcessId())
            {
                hres = S_OK;
            } else
            {
                /*
                 *  Put a permanently invalid handle here so that we
                 *  won't accidentally take a new window that happens
                 *  to get a recycled handle value.
                 */
                this->hwnd = INVALID_HANDLE_VALUE;
                RPF("Error: Window destroyed while associated with a device");
                hres = E_INVALIDARG;
            }
        } else
        {
            hres = DIERR_OTHERAPPHASPRIO;
        }
    } else
    {                        /* No window; vacuous success */
        hres = S_OK;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | InstallCwp |
 *
 *          Install the CallWndProc handler.
 *
 *          There is a bit of subtlety in the way this works.
 *          Since only foreground windows may acquire exclusive access,
 *          we need only one hook (for there is but one foreground
 *          window in the system).
 *
 *          _NT_:  Does NT handle this correctly in the face of
 *          multiple window stations?
 *
 *          The tricky part is that input loss occurs asynchronously.
 *          So a device that registers a <f CallWindowProc> hook doesn't
 *          find out that the input has been lost until the app next
 *          calls <f Unacquire>.
 *
 *          So the way this is done is via a collection of global
 *          variables (which must be accessed atomically).
 *
 *          <p g_hhkCwp> is the hook handle itself.  It is zero when
 *          no hook is installed.
 *
 *          Note that we install the windows hook while inside both the
 *          object critical section and the DLL critical section.
 *          You might think we'd risk deadlocking with the hook procedure,
 *          in case the window asynchronously deactivates while we're
 *          installing the hook.  But your worries are unfounded:
 *          If the window is on the current thread, then window messages
 *          won't be dispatched because we never call <f GetMessage> or
 *          go into a modal loop.  And if the window is on another thread,
 *          then that other thread will simply have to wait until we're done.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_InstallCwp(PDD this)
{
    HRESULT hres;

    if(this->discl & DISCL_FOREGROUND)
    {
        AssertF(this->hwnd);
        hres = CDIDev_CanAcquire(this);
        if(SUCCEEDED(hres))
        {
            hres = CDIDev_AddForegroundDevice(this);
            if(SUCCEEDED(hres))
            {
                DllEnterCrit();
                if(!g_hhkCwp)
                {            /* We're the first one */
                    g_hwndExclusive = this->hwnd;
                    g_hhkCwp = SetWindowsHookEx(WH_CALLWNDPROC,
                                                CDIDev_CallWndProc, g_hinst,
                                                GetWindowThreadProcessId(this->hwnd, 0));
                } else
                {
                    AssertF(g_hwndExclusive == this->hwnd);
                }

                DllLeaveCrit();
                /*
                 *  There is a race condition up above, where the foreground
                 *  window can change between the call to CanAcquire() and
                 *  the call to SetWindowsHookEx().  Close the window by
                 *  checking a second time after the hook is installed.
                 *
                 *  If we leave the window open, it's possible that we will
                 *  perform a physical acquire while the wrong window has
                 *  foreground activation.  Then, of course, we are never told
                 *  that *our* window lost activation, and the physical device
                 *  remains acquired forever.
                 */
                hres = CDIDev_CanAcquire(this);
                if(SUCCEEDED(hres))
                {
                } else
                {
                    SquirtSqflPtszV(sqflError,
                                    TEXT("Window no longer foreground; ")
                                    TEXT("punting acquire"));
                    CDIDev_InternalUnacquire(this);
                }
            }
        } else
        {
            hres = DIERR_OTHERAPPHASPRIO;
        }
    } else
    {                        /* No window; vacuous success */
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | RealUnacquire |
 *
 *          Release access to the device, even if the device was only
 *          partially acquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_RealUnacquire(PDD this)
{
    HRESULT hres;

    hres = this->pdcb->lpVtbl->Unacquire(this->pdcb);
    if(hres == S_FALSE)
    {
        if(this->fAcquiredInstance)
        {
            this->fAcquiredInstance = 0;
            hres = Hel_UnacquireInstance(this->pvi);
            AssertF(SUCCEEDED(hres));
        } else
        {
            hres = S_OK;
        }
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | FFAcquire |
 *
 *          The device has been successfully acquired.  Do any
 *          necessary force feedback related acquisition goo.
 *
 *  @cwrap  PDD | pdd
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_FFAcquire(PDD this)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if(this->pes && (this->discl & DISCL_EXCLUSIVE))
    {
        if(SUCCEEDED(hres = this->pes->lpVtbl->SendForceFeedbackCommand(
                                                                       this->pes, &this->sh,
                                                                       DISFFC_FORCERESET)))
        {

            CDIDev_RefreshGain(this);

            /*
             *  If the center spring is to be disabled,
             *  then disable the center spring.
             */
            if(!this->dwAutoCenter)
            {
                this->pes->lpVtbl->SendForceFeedbackCommand(
                                                           this->pes, &this->sh,
                                                           DISFFC_STOPALL);
            }

            hres = S_OK;
        }

    } else
    {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Acquire |
 *
 *          Obtains access to the device.
 *
 *          Device acquisition does not reference-count.  If a device is
 *          acquired twice then unacquired once, the device is unacquired.
 *
 *          Before the device can be acquired, a data format must
 *          first be set via the <mf IDirectInputDevice::SetDataFormat>
 *          method.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The device has already been acquired.  Note
 *          that this value is a success code.
 *
 *          <c DIERR_OTHERAPPHASPRIO>: Access to the device was not granted.
 *          The most common cause of this is attempting to acquire a
 *          device with the <c DISCL_FOREGROUND> cooperative level when
 *          the associated window is not foreground.
 *
 *          This error code is also returned if an attempt to
 *          acquire a device in exclusive mode fails because the device
 *          is already acquired in exclusive mode by somebody else.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The device
 *          does not have a selected data format.
 */
/*
 *          The point at which we take the exclusive semaphore is important.
 *          We should do it after preliminary validation of foreground
 *          permission, so that we don't accidentally lock out somebody
 *          else who legitimately has permission.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Acquire(PV pdd _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::Acquire, (_ "p", pdd));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent somebody from
         *  acquiring or changing the data format while we're acquiring.
         */
        CDIDev_EnterCrit(this);

        /*
         *  The app explicitly messed with acquisition.  Any problems
         *  retrieving data are now the apps' fault.
         */
        this->hresNotAcquired = DIERR_NOTACQUIRED;

        //We now need a pvi even in where the device doesn't use VxDs
        if(this->pdix && this->pvi)
        {
            if(this->pvi->fl & VIFL_ACQUIRED)
            {
                hres = S_FALSE;
            } else if(SUCCEEDED(hres = CDIDev_CanAcquire(this)))
            {

                hres = Excl_Acquire(&this->guid, this->hwnd, this->discl);
                if(SUCCEEDED(hres))
                {

                    if(SUCCEEDED(hres = CDIDev_FFAcquire(this)))
                    {
                        hres = this->pdcb->lpVtbl->Acquire(this->pdcb);
                        if(SUCCEEDED(hres))
                        {
                            if(hres == S_FALSE)
                            {
                                hres = Hel_AcquireInstance(this->pvi);
                                if(SUCCEEDED(hres))
                                {
                                    this->fAcquiredInstance = 1;

                                    /*
                                     *  If relative mode, need to prime the
                                     *  pvLastBuffer with the current state.
                                     */

                                    if(this->pvi->fl & VIFL_RELATIVE)
                                    {
                                        hres = this->pdcb->lpVtbl->GetDeviceState(
                                                                                 this->pdcb, this->pvLastBuffer);
                                        if(FAILED(hres))
                                        {
                                            goto unacquire;
                                        }
                                    }

                                } else
                                {
                                    goto unacquire;
                                }
                            }

                            /*
                             *  Note that InstallCwp must be the last thing
                             *  we do, because it will add us to the foreground
                             *  list, and none of our error exit paths remove us.
                             */
                            hres = CDIDev_InstallCwp(this);
                            if(SUCCEEDED(hres))
                            {
                                this->fAcquired = 1;
                                this->fOnceAcquired = 1;

                                /*
                                 *  From now on, if we lose acquisition,
                                 *  it's not the app's fault.
                                 */
                                this->hresNotAcquired = DIERR_INPUTLOST;

                                hres = S_OK;
                            } else
                            {
                                goto unacquire;
                            }

                        } else
                        {
                            unacquire:;
                            CDIDev_RealUnacquire(this);
                        }
                    }
                }
            }
        } else
        {
            hres = E_INVALIDARG;
        }

        CDIDev_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(Acquire, (PV pdd), (pdd THAT_))

#else

    #define CDIDev_AcquireA                 CDIDev_Acquire
    #define CDIDev_AcquireW                 CDIDev_Acquire

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | InternalUnacquire |
 *
 *          This does the real work of unacquiring.  The internal
 *          version bypasses the "the app requested this" flag,
 *          so when the app goes to request something, it gets
 *          <c DIERR_INPUTLOST> instead of <c DIERR_NOTACQUIRED>.
 *
 *          If the application error code is <c DIERR_INPUTLOST>, then
 *          we will also signal the associated event so that it knows
 *          that the state changed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_InternalUnacquire(PDD this)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::InternalUnacquire, (_ "p", this));

    /*
     *  Must protect with the critical section to prevent confusing other
     *  methods which change their behavior depending on whether the device
     *  is acquired.
     */
    CDIDev_EnterCrit(this);

    if(this->fAcquired)
    {
        AssertF(this->pdcb != c_pdcbNil);
        this->fAcquired = 0;
        Excl_Unacquire(&this->guid, this->hwnd, this->discl);
        if(this->discl & DISCL_FOREGROUND)
        {
            AssertF(this->hwnd);
            CDIDev_DelForegroundDevice(this);
          #ifdef WINNT
            if( IsIconic(this->hwnd) ) {
                this->fUnacquiredWhenIconic = 1;
            }
          #endif
            /*
             *  Prefix notices (mb:34651) that the above could release the 
             *  interface, causing the following to party on garbage but only 
             *  if we have a refcounting bug so "By design".
             */
        }
        /*
         *  ISSUE-2001/03/29-timgill multithreading means we cannot rely on Excl_Unaquire() return values
         *  We cannot trust the return value (if we made one)
         *  of Excl_Unacquire, because another instance may have
         *  snuck in and acquired the device after we Excl_Unacquire'd
         *  it and started doing force feedback on it.
         *
         *  We need to fix this with the joystick mutex.
         */
        if(this->pes && (this->discl & DISCL_EXCLUSIVE))
        {
            this->pes->lpVtbl->SendForceFeedbackCommand(
                                                       this->pes, &this->sh, DISFFC_RESET);
            this->sh.dwTag = 0;
        }

        hres = CDIDev_RealUnacquire(this);
        if(this->hresNotAcquired == DIERR_INPUTLOST)
        {
            CDIDev_SetNotifyEvent(this);
        }
    } else
    {
        hres = S_FALSE;
    }

    CDIDev_LeaveCrit(this);


    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Unacquire |
 *
 *          Release access to the device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The object is not currently acquired.
 *          This may have been caused by a prior loss of input.
 *          Note that this is a success code.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Unacquire(PV pdd _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::Unacquire, (_ "p", pdd));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  The app explicitly messed with acquisition.  Any problems
         *  retrieving data are now the apps' fault.
         */
        this->hresNotAcquired = DIERR_NOTACQUIRED;

        hres = CDIDev_InternalUnacquire(this);

    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(Unacquire, (PV pdd), (pdd THAT_))

#else

    #define CDIDev_UnacquireA               CDIDev_Unacquire
    #define CDIDev_UnacquireW               CDIDev_Unacquire

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method PDIPROPVALIDINFO | IDirectInputDevice | ppviFind |
 *
 *          Locate the DIPROPVALIDINFO structure that describes
 *          the predefined property.
 *
 *  @parm   const GUID * | pguid |
 *
 *          Property guid, or predefined property.
 *
 *  @returns
 *
 *          Pointer to a const <t DIPROPVALIDINFO> that describes
 *          what is and is not valid for this property.
 *
 *          Returns 0 if the property is not one of the predefined
 *          properties.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

typedef struct DIPROPVALIDINFO
{
    PCGUID  pguid;                      /* Property name */
    DWORD   dwSize;                     /* expected size */
    DWORD   fl;                         /* flags */
} DIPROPVALIDINFO, *PDIPROPVALIDINFO;

/*
 *  Note that the flags are negative in sense.
 *  This makes validation easier.
 */
#define DIPVIFL_NOTDEVICE   0x00000001  /* Cannot be device */
#define DIPVIFL_NOTOBJECT   0x00000002  /* Cannot be object */
#define DIPVIFL_READONLY    0x00000004  /* Cannot be set */
#define DIPVIFL_NOTPRIVATE  0x00000008  /* Cannot handle private pvi */
#define DIPVIFL_NOTACQUIRED 0x00000010  /* Cannot modify while acquired */

DIPROPVALIDINFO c_rgpvi[] = {

    {
        DIPROP_BUFFERSIZE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTPRIVATE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_AXISMODE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTPRIVATE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_GRANULARITY,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTDEVICE | DIPVIFL_READONLY | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_RANGE,
        cbX(DIPROPRANGE),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    /*
     *  Note that you can set the dead zone on the entire device.
     *  This is the same as applying it to each axis individually.
     */
    {
        DIPROP_DEADZONE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTACQUIRED,
    },

    /*
     *  Note that you can set the saturation on the entire device.
     *  This is the same as applying it to each axis individually.
     */
    {
        DIPROP_SATURATION,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTACQUIRED,
    },

    /*
     *  Note that you can change the gain either while acquired
     *  or not.  Your choice.
     */
    {
        DIPROP_FFGAIN,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT,
    },

    /*
     *  Note that the FF load is meaningful only when acquired,
     *  so we'd better not complain if they access it while acquired!
     */
    {
        DIPROP_FFLOAD,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    {
        DIPROP_AUTOCENTER,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_CALIBRATIONMODE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_CALIBRATION,
        cbX(DIPROPCAL),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_GUIDANDPATH,
        cbX(DIPROPGUIDANDPATH),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    {
        DIPROP_INSTANCENAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT,
    },

    {
        DIPROP_PRODUCTNAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT,
    },

    {
        DIPROP_MAXBUFFERSIZE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTPRIVATE | DIPVIFL_NOTACQUIRED,
    },


    {
        DIPROP_JOYSTICKID,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT |  DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_GETPORTDISPLAYNAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    /*
     *  Note that you can change the report ID  while acquired
     *  or not.  Your choice.
     */
    {
        DIPROP_ENABLEREPORTID,
        cbX(DIPROPDWORD),
        0x0,
    },
#if 0
    {
        DIPROP_SPECIFICCALIBRATION,
        cbX(DIPROPCAL),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },
#endif

    {
        DIPROP_PHYSICALRANGE,
        cbX(DIPROPRANGE),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_LOGICALRANGE,
        cbX(DIPROPRANGE),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_KEYNAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_SCANCODE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_APPDATA,
        cbX(DIPROPPOINTER),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_CPOINTS,
        cbX(DIPROPCPOINTS),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_VIDPID,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    {
        DIPROP_USERNAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    {
        DIPROP_TYPENAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    {
        DIPROP_MAPFILE,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

};

#pragma END_CONST_DATA

STDMETHODIMP_(PDIPROPVALIDINFO)
CDIDev_ppviFind(PCGUID pguid)
{
    PDIPROPVALIDINFO ppvi;
    UINT ipvi;

    for(ipvi = 0, ppvi = c_rgpvi; ipvi < cA(c_rgpvi); ipvi++, ppvi++)
    {
        if(ppvi->pguid == pguid)
        {
            goto found;
        }
    }
    ppvi = 0;

    found:
    return ppvi;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | hresValidProp |
 *
 *          Check that the property structure makes sense.
 *          Returns the object index for further processing.
 *
 *  @parm   const GUID * | pguid |
 *
 *          Property guid, or predefined property.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Propery header structure.
 *
 *  @parm   BOOL | fWrite |
 *
 *          Whether property should be validate for writing.
 *
 *  @parm   OUT LPDIPROPINFO | ppropi |
 *
 *          Receives object index.
 *
 *****************************************************************************/

typedef BOOL (WINAPI *PFNBAD)(PCV pv, UINT cb);

STDMETHODIMP
    CDIDev_hresValidProp(PDD this, const GUID *pguid, LPCDIPROPHEADER pdiph,
                         BOOL fWrite, LPDIPROPINFO ppropi)
{
    HRESULT hres;
    PFNBAD pfnBad;
    EnterProcR(IDirectInputDevice8::Get/SetProperty,
               (_ "pxpx", this, pguid, pdiph, fWrite));

    AssertF(CDIDev_InCrit(this));

    if(fWrite)
    {
        pfnBad = (PFNBAD)IsBadWritePtr;
    } else
    {
        pfnBad = (PFNBAD)IsBadReadPtr;
    }

    if(!pfnBad(pdiph, cbX(DIPROPHEADER)) &&
       pdiph->dwHeaderSize == cbX(DIPROPHEADER) &&
       pdiph->dwSize % 4 == 0 &&
       pdiph->dwSize >= pdiph->dwHeaderSize &&
       !pfnBad(pdiph, pdiph->dwSize))
    {

        /*
         *  Now convert the item descriptor into an index.
         */
        hres = CDIDev_hresMapHow(this, pdiph->dwObj, pdiph->dwHow, ppropi);

        if(SUCCEEDED(hres))
        {

            /*
             *  Now validate the property id or guid.
             */
            if(HIWORD((UINT_PTR)pguid) == 0)
            {

                PDIPROPVALIDINFO ppvi;

                ppvi = CDIDev_ppviFind(pguid);

                /*
                 *  Note that if we don't find the GUID in our list,
                 *  we fail it straight away.  This prevents ISVs
                 *  from trying to create properties in the Microsoft
                 *  Reserved range.
                 */
                if(ppvi)
                {
                    if( ppvi->pguid == DIPROP_CALIBRATION ) {
                        if( pdiph->dwSize == ppvi->dwSize ||
                            pdiph->dwSize == cbX(DIPROPCALPOV) ) 
                        {
                            hres = S_OK;
                        } else {
                            RPF("%s: Arg 2: Invalid dwSize for property", s_szProc);
                            hres = E_INVALIDARG;
                        }
                    } else if( pdiph->dwSize == ppvi->dwSize )
                    {
                        if( pguid == DIPROP_KEYNAME || pguid == DIPROP_SCANCODE ) {
                            // Fix Manbug 28888.
                            // DIPROP_KEYNAME and DIPROP_SCANCODE are not a property for device.
                            if( pdiph->dwHow == DIPH_DEVICE ) {
                                hres = E_INVALIDARG;
                            }
                        }
                        else 
                        {
                            if(fWrite)
                            {
                                ScrambleBuf((PV)(pdiph+1), pdiph->dwSize - cbX(DIPROPHEADER) );
                            }
                            hres = S_OK;
                        }
                    } else
                    {
                        RPF("%s: Arg 2: Invalid dwSize for property", s_szProc);
                        hres = E_INVALIDARG;
                    }
                } else
                {
                    RPF("%s: Arg 1: Unknown property", s_szProc);
                    hres = E_NOTIMPL;
                }

            } else
            {
                hres = hresFullValidGuid(pguid, 1);
            }
        }
    } else
    {
        RPF("%s: Arg 2: Invalid pointer", s_szProc);
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | hresValidDefProp |
 *
 *          Determine whether the property is something we can handle
 *          in the default property handler.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags for forbidden things.
 *          <c DIPVIFL_READONLY> if being validated for writing.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: Passes validation.
 *
 *          <c E_NOTIMPL>: Not something we handle.
 *
 *
 *****************************************************************************/

HRESULT INTERNAL
    CDIDev_hresValidDefProp(PDD this, LPCDIPROPINFO ppropi, DWORD dwFlags)
{
    HRESULT hres;
    PDIPROPVALIDINFO ppvi;
    EnterProc(CDIDev_hresValidDefProp,
              (_ "pGxx", this, ppropi->pguid, ppropi->dwDevType, dwFlags));

    /*
     *  Note that it's okay if the device is acquired.  We want to
     *  allow GetProperty to succeed on an acquired device.
     */
    AssertF(CDIDev_InCrit(this));

    ppvi = CDIDev_ppviFind(ppropi->pguid);

    if(ppvi)
    {
        if(ppropi->iobj == 0xFFFFFFFF)
        {
            dwFlags |= DIPVIFL_NOTDEVICE;    /* Fail if devices forbidden */
        } else
        {
            dwFlags |= DIPVIFL_NOTOBJECT;    /* Fail if objects forbidden */
        }
        if(this->pvi == 0)
        {
            dwFlags |= DIPVIFL_NOTPRIVATE;   /* Fail if privates forbidden */
        }
        /*
         *  If attempting to modify property and we are acquired,
         *  then also set the "but not while acquired" filter.
         */
        if((dwFlags & DIPVIFL_READONLY) && this->fAcquired)
        {
            dwFlags |= DIPVIFL_NOTACQUIRED;  /* Fail if r/o while acq'd */
        }

        if((ppvi->fl & dwFlags) == 0)
        {
            hres = S_OK;            /* Seems reasonable */
        } else
        {
            if(ppvi->fl & dwFlags & DIPVIFL_READONLY)
            {
                RPF("SetProperty: Property is read-only");
                hres = DIERR_READONLY;
            } else if(ppvi->fl & dwFlags & DIPVIFL_NOTACQUIRED)
            {
                RPF("SetProperty: Cannot change property while acquired");
                hres = DIERR_ACQUIRED;
            } else
            {
                RPF("Get/SetProperty: Property does not exist for that object");
                hres = E_NOTIMPL;       /* Cannot do that */
            }
        }

    } else
    {
        RPF("Get/SetProperty: Property does not exist");
        hres = E_NOTIMPL;           /* Definitely way out */
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | DefGetProperty |
 *
 *          Default implementation of <mf IDirectInputDevice::GetProperty>
 *          to handle properties which the device decides not to implement.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_DefGetProperty(PDD this, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProc(CDIDev_DefGetProperty,
              (_ "pGx", this, ppropi->pguid, ppropi->dwDevType));

    AssertF(CDIDev_InCrit(this));

    hres = CDIDev_hresValidDefProp(this, ppropi, 0);
    if(SUCCEEDED(hres))
    {
        LPDIPROPDWORD pdipdw = (PV)pdiph;
        LPDIPROPRANGE pdiprg = (PV)pdiph;
        LPDIPROPPOINTER pdipptr = (PV)pdiph;
        LPDIPROPSTRING pdipwsz = (PV)pdiph;

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {

        case (DWORD)(UINT_PTR)DIPROP_BUFFERSIZE:
            AssertF(this->pvi);         /* Validation should've caught this */
            pdipdw->dwData = this->celtBuf;
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_AXISMODE:
            AssertF(this->pvi);         /* Validation should've caught this */
            if(this->pvi->fl & VIFL_RELATIVE)
            {
                pdipdw->dwData = DIPROPAXISMODE_REL;
            } else
            {
                pdipdw->dwData = DIPROPAXISMODE_ABS;
            }
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_GRANULARITY:

            if(DIDFT_GETTYPE(ppropi->dwDevType) & DIDFT_AXIS)
            {
                /* Default axis granularity is 1 */
                pdipdw->dwData = 1;
                hres = S_OK;
            } else
            {
                /*
                 * Buttons don't have granularity.
                 * POVs must be handled by device driver.
                 */
                RPF("GetProperty: Object doesn't have a granularity");
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_RANGE:
            if(DIDFT_GETTYPE(ppropi->dwDevType) & DIDFT_RELAXIS)
            {
                /* Default rel-axis range is infinite */
                pdiprg->lMin = DIPROPRANGE_NOMIN;
                pdiprg->lMax = DIPROPRANGE_NOMAX;
                hres = S_OK;
            } else
            {
                /*
                 * Device driver must handle abs axis range.
                 * Buttons and POVs don't have range.
                 */
                RPF("GetProperty: Object doesn't have a range");
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_MAXBUFFERSIZE:
            pdipdw->dwData = this->celtBufMax;
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_APPDATA:
            if( ( this->df.rgodf[ppropi->iobj].dwType & DIDFT_CONTROLOBJS )
             &&!( this->df.rgodf[ppropi->iobj].dwType & DIDFT_NODATA ) )
            {
                if( this->pdix )
                {
                    if( this->pdix[ppropi->iobj].dwOfs != 0xFFFFFFFF )
                    {
                        pdipptr->uData = this->pdix[ppropi->iobj].uAppData;
                    }
                    else
                    {
                        hres = DIERR_OBJECTNOTFOUND;
                    }
                }
                else
                {
                    RPF("GetProperty: Need data format/semantic map applied to have app data");
                    hres = DIERR_NOTINITIALIZED;
                }
            }
            else
            {
                RPF("SetProperty: app data only valid for input controls");
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_USERNAME:
            hres = CMap_GetDeviceUserName( &this->guid, pdipwsz->wsz );
            break;

        case (DWORD)(UINT_PTR)DIPROP_FFGAIN:
            pdipdw->dwData = this->dwGain;
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_FFLOAD:
            hres = CDIDev_GetLoad(this, &pdipdw->dwData);
            break;

        case (DWORD)(UINT_PTR)DIPROP_AUTOCENTER:
            if(this->didcFF & DIDC_FORCEFEEDBACK)
            {
                pdipdw->dwData = this->dwAutoCenter;
                hres = S_OK;
            } else
            {
                hres = E_NOTIMPL;
            }
            break;

        default:
            /*
             *  The user is asking for some property that simply
             *  makes no sense here.  E.g., asking for the dead
             *  zone on a keyboard.
             */
            SquirtSqflPtszV(sqfl | sqflBenign, 
                            TEXT("GetProperty: Property 0x%08x not supported on device"),
                            (DWORD)(UINT_PTR)ppropi->pguid );
            hres = E_NOTIMPL;
            break;

        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetProperty |
 *
 *          Obtain information about a device or object in a device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguidProp |
 *
 *          The identity of the property to be obtained.  This can be
 *          one of the predefined <c DIPROP_*> values, or it may
 *          be a private GUID.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which dependson the property.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer, or the
 *          <p dwHow> field is invalid, or the <p dwObj> field
 *          is not zero when <p dwHow> is set to <c DIPH_DEVICE>.
 *
 *          <c DIERR_OBJECTNOTFOUND>:  The specified object does not
 *          exist.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>:  The property
 *          is not supported by the device or object.
 *
 *  @ex
 *
 *          The following "C" code fragment illustrates how to obtain
 *          the value of the <c DIPROP_BUFFERSIZE> property.
 *
 *          |
 *
 *          DIPROPDWORD dipdw;
 *          HRESULT hres;
 *          dipdw.diph.dwSize = sizeof(DIPROPDWORD);
 *          dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
 *          dipdw.diph.dwObj  = 0;                   // device property
 *          hres = IDirectInputDevice_GetProperty(pdid, DIPROP_BUFFERSIZE, &dipdw.diph);
 *          if (SUCCEEDED(hres)) {
 *              // dipdw.dwData contains the value of the property
 *          }
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetProperty(PV pdd, REFGUID rguid, LPDIPROPHEADER pdiph _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetProperty, (_ "pxp", pdd, rguid, pdiph));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);
        DIPROPINFO propi;

        /*
         *  Must protect with the critical section to prevent somebody
         *  acquiring or changing the property we are reading.  We need
         *  to do this before validating, to prevent an acquisition.
         */
        CDIDev_EnterCrit(this);

        propi.pguid = rguid;
        if(SUCCEEDED(hres = CDIDev_hresValidProp(this, rguid, pdiph,
                                                 1, &propi)))
        {
            /*
             *  Prefix picks up that ppropi->iobj is uninitialized (mb:34682) 
             *  in the case of a BY_USAGE dwHow.  However, the value is only 
             *  an output for MapUsage which will always either set it or 
             *  fail so there is no error.
             */
            hres = this->pdcb->lpVtbl->GetProperty(this->pdcb, &propi, pdiph);

            if(hres == E_NOTIMPL)
            {
                hres = CDIDev_DefGetProperty(this, &propi, pdiph);
            }

        }

        CDIDev_LeaveCrit(this);
    }

    ExitBenignOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(GetProperty, (PV pdm, REFGUID rguid, LPDIPROPHEADER pdiph),
           (pdm, rguid, pdiph THAT_))

#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SetAxisMode |
 *
 *          Default handler for clients trying to set the axis mode.
 *          If the device doesn't handle axis modes natively, then
 *          we'll fake it ourselves.
 *
 *  @parm   DWORD | dwMode |
 *
 *          Desired new mode.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetAxisMode(PDD this, DWORD dwMode)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SetProperty(AXISMODE),
               (_ "px", this, dwMode));

    AssertF(this->pvi);                 /* Validation should've caught this */

    hres = hresFullValidFl(dwMode, DIPROPAXISMODE_VALID, 2);
    if(SUCCEEDED(hres))
    {
        if(dwMode & DIPROPAXISMODE_REL)
        {
            this->GetDeviceState = CDIDev_GetRelDeviceState;
            this->pvi->fl |= VIFL_RELATIVE;
        } else
        {
            this->GetDeviceState = CDIDev_GetAbsDeviceState;
            this->pvi->fl &= ~VIFL_RELATIVE;
        }
        if(this->cAxes)
        {
            hres = S_OK;
        } else
        {
            hres = DI_PROPNOEFFECT;
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SetAutoCenter |
 *
 *          Default handler for clients trying to set the
 *          auto-center property.
 *
 *          If the device doesn't have control over the
 *          auto-center spring, then we fail.
 *
 *  @parm   DWORD | dwMode |
 *
 *          Desired new mode.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetAutoCenter(PDD this, DWORD dwMode)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SetProperty(AUTOCENTER),
               (_ "px", this, dwMode));

    hres = hresFullValidFl(dwMode, DIPROPAUTOCENTER_VALID, 2);
    if(SUCCEEDED(hres))
    {
        if(this->didcFF & DIDC_FORCEFEEDBACK)
        {
            /*
             *  We need to create the effect driver if disabling
             *  autocenter so that CDIDev_FFAcquire will set the feedback
             *  mode properly.
             */
            if(fLimpFF(dwMode == DIPROPAUTOCENTER_OFF,
                       SUCCEEDED(hres = CDIDev_CreateEffectDriver(this))))
            {
                this->dwAutoCenter = dwMode;
                hres = S_OK;
            }
        } else
        {
            hres = E_NOTIMPL;
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SetGlobalAxisProp |
 *
 *          Default implementation of <mf IDirectInputDevice::SetProperty>
 *          to handle properties which can be applied globally to all
 *          absolute axes.
 *
 *  @parm   IN LPDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *          We edit it to avoid reallocating memory all the time.
 *
 *  @parm   IN LPCDIPROPHEADER | pdiph |
 *
 *          The property itself.
 *
 *  @returns
 *
 *          We consider the property-set a success if all candidates
 *          succeeded.  <c E_NOTIMPL> counts as success, on the assumption
 *          that the property is not meaningful on the candidate.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetGlobalAxisProp(PDD this, LPDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;

    for(ppropi->iobj = 0; ppropi->iobj < this->df.dwNumObjs; ppropi->iobj++)
    {
        DWORD dwType = this->df.rgodf[ppropi->iobj].dwType;
        if(dwType & DIDFT_ABSAXIS)
        {
            ppropi->dwDevType = this->df.rgodf[ppropi->iobj].dwType;

            hres = this->pdcb->lpVtbl->SetProperty(this->pdcb, ppropi, pdiph);
            if(FAILED(hres) && hres != E_NOTIMPL)
            {
                goto done;
            }
        }
    }
    hres = S_OK;

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | DefSetProperty |
 *
 *          Default implementation of <mf IDirectInputDevice::SetProperty>
 *          to handle properties which the device decides not to implement.
 *
 *  @parm   IN LPDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *          We edit it to avoid reallocating memory all the time.
 *
 *  @parm   OUT LPCDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_POLLEDDEVICE>: The device is polled, so the result
 *          might not be meaningful.  (This return code is used when
 *          you attempt to set the buffer size property.)
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_DefSetProperty(PDD this, LPDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProc(CDIDev_DefSetProperty,
              (_ "pGx", this, ppropi->pguid, ppropi->dwDevType));

    AssertF(CDIDev_InCrit(this));

    /*
     * Note: The indentation here is historical; I left it this way
     * to keep the diff size down.
     */

    hres = CDIDev_hresValidDefProp(this, ppropi, DIPVIFL_READONLY);
    if(SUCCEEDED(hres))
    {
        LPDIPROPDWORD pdipdw = (PV)pdiph;
        LPDIPROPRANGE pdiprg = (PV)pdiph;
        LPDIPROPPOINTER pdipptr = (PV)pdiph;
        VXDDWORDDATA vdd;

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {

        case (DWORD)(UINT_PTR)DIPROP_BUFFERSIZE:
            AssertF(this->pvi);     /* Validation should've caught this */
            vdd.pvi = this->pvi;
            if( pdipdw->dwData > this->celtBufMax )
            {
                RPF( "DIPROP_BUFFERSIZE: requested size %d is larger than maximum %d, using %d", 
                    pdipdw->dwData, this->celtBufMax, this->celtBufMax );
                vdd.dw = this->celtBufMax;
            }
            else
            {
                vdd.dw = pdipdw->dwData;
            }
            hres = Hel_SetBufferSize(&vdd);
#ifdef DEBUG_STICKY
            {
                TCHAR tszDbg[80];
                wsprintf( tszDbg, TEXT("SetBufferSize(0x%08x) returned 0x%08x\r\n"), vdd.dw, hres );
                OutputDebugString( tszDbg );
            }
#endif /* DEBUG_STICKY */
            if(SUCCEEDED(hres))
            {
                this->celtBuf = pdipdw->dwData;
                hres = this->hresPolled;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_AXISMODE:
            hres = CDIDev_SetAxisMode(this, pdipdw->dwData);
            break;

            /*
             *  We will handle these global properties
             *  if the callback doesn't want to.
             */
        case (DWORD)(UINT_PTR)DIPROP_RANGE:
        case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
            if(ppropi->dwDevType == 0)
            {           /* For device */
                hres = CDIDev_SetGlobalAxisProp(this, ppropi, pdiph);
            } else
            {
                goto _default;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_MAXBUFFERSIZE:
            this->celtBufMax = pdipdw->dwData;
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_APPDATA:
            if( ( this->df.rgodf[ppropi->iobj].dwType & DIDFT_CONTROLOBJS )
             &&!( this->df.rgodf[ppropi->iobj].dwType & DIDFT_NODATA ) )
            {
                if( this->pdix )
                {
                    if( this->pdix[ppropi->iobj].dwOfs != 0xFFFFFFFF )
                    {
                        this->pdix[ppropi->iobj].uAppData = pdipptr->uData;
                    }
                    else
                    {
                        hres = DIERR_OBJECTNOTFOUND;
                    }
                }
                else
                {
                    RPF("SetProperty: Need data format/semantic map applied to change app data");
                    hres = DIERR_NOTINITIALIZED;
                }
            }
            else
            {
                RPF("SetProperty: app data only valid for input controls");
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_FFGAIN:
            if(ISVALIDGAIN(pdipdw->dwData))
            {
                this->dwGain = pdipdw->dwData;
                CDIDev_RefreshGain(this);
                hres = S_OK;
            } else
            {
                RPF("ERROR: SetProperty(DIPROP_FFGAIN): Gain out of range");
                hres = E_INVALIDARG;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_AUTOCENTER:
            hres = CDIDev_SetAutoCenter(this, pdipdw->dwData);
            break;

            _default:;
        default:
            /*
             * The validation filter already failed invalid properties.
             * So what's left is that the property is valid but cannot
             * be set, because it doesn't exist on the device (e.g.,
             * dead zone) or because it is read-only.
             */
            SquirtSqflPtszV(sqfl | sqflBenign, 
                            TEXT("SetProperty: Property 0x%08x not supported on device"),
                            (DWORD)(UINT_PTR)ppropi->pguid );
            hres = E_NOTIMPL;
            break;

        }

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | RealSetProperty |
 *
 *          The function that does the real work.
 *
 *          <mf IDirectInputDevice::SetDataFormat> will internally
 *          set the axis mode property, so it needs this backdoor
 *          entry point.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguidProp |
 *
 *          The identity of the property to be set.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_RealSetProperty(PDD this, REFGUID rguid, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    DIPROPINFO propi;
    EnterProcR(IDirectInputDevice8::SetProperty, (_ "pxp", this, rguid, pdiph));

    /*
     *  Must protect with the critical section to prevent somebody
     *  acquiring or changing the property we are reading.  We need
     *  to do this before validating, to prevent an acquisition.
     */
    CDIDev_EnterCrit(this);

    propi.pguid = rguid;
    if(SUCCEEDED(hres = CDIDev_hresValidProp(this, rguid, pdiph,
                                             0, &propi)))
    {

        hres = this->pdcb->lpVtbl->SetProperty(this->pdcb, &propi, pdiph);

        if(hres == E_NOTIMPL)
        {
            hres = CDIDev_DefSetProperty(this, &propi, pdiph);
        }
    }

    CDIDev_LeaveCrit(this);

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetProperty |
 *
 *          Set information about a device or object in a device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguidProp |
 *
 *          The identity of the property to be set.  This can be
 *          one of the predefined <c DIPROP_*> values, or it may
 *          be a pointer to a private GUID.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_PROPNOEFFECT> <c S_FALSE>: The operation completed
 *          successfully but
 *          had no effect.  For example, changing the axis mode
 *          on a device with no axes will return this value.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer, or the
 *          <p dwHow> field is invalid, or the <p dwObj> field
 *          is not zero when <p dwHow> is set to <c DIPH_DEVICE>.
 *
 *          <c DIERR_OBJECTNOTFOUND>:  The specified object does not
 *          exist.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>:  The property
 *          is not supported by the device or object.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetProperty(PV pdd, REFGUID rguid, LPCDIPROPHEADER pdiph _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SetProperty, (_ "pxp", pdd, rguid, pdiph));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);
        hres = CDIDev_RealSetProperty(this, rguid, pdiph);
    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(SetProperty, (PV pdm, REFGUID rguid, LPCDIPROPHEADER pdiph),
           (pdm, rguid, pdiph THAT_))

#else

    #define CDIDev_SetPropertyA             CDIDev_SetProperty
    #define CDIDev_SetPropertyW             CDIDev_SetProperty

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetCooperativeLevel |
 *
 *          Establish the cooperativity level for the instance of
 *          the device.
 *
 *          The cooperativity level determines how the instance of
 *          the device interacts with other instances of the device
 *          and the rest of the system.
 *
 *          Note that if the system mouse is acquired in exclusive
 *          mode, then the mouse cursor will be removed from the screen
 *          until the device is unacquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   HWND | hwnd |
 *
 *          The window associated with the device.
 *          The window must be a top-level window.
 *
 *          It is an error to destroy the window while it is still
 *          active in a DirectInput device.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags which describe the cooperativity level associated
 *          with the device.
 *
 *          It consists of <c DISCL_*> flags, documented separately.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p hwnd> parameter is not a valid pointer.
 *
 *****************************************************************************/

HRESULT INLINE
    CDIDev_SetCooperativeLevel_IsValidFl(DWORD dwFlags)
{
    HRESULT hres;
    RD(static char s_szProc[] = "IDirectInputDevice::SetCooperativeLevel");

    if(!(dwFlags & ~DISCL_VALID))
    {
        if((dwFlags & DISCL_EXCLMASK) == DISCL_EXCLUSIVE ||
           (dwFlags & DISCL_EXCLMASK) == DISCL_NONEXCLUSIVE)
        {
            if((dwFlags & DISCL_GROUNDMASK) == DISCL_FOREGROUND ||
               (dwFlags & DISCL_GROUNDMASK) == DISCL_BACKGROUND)
            {
                hres = S_OK;
            } else
            {
                RPF("ERROR %s: arg %d: Must set exactly one of "
                    "DISCL_FOREGROUND or DISCL_BACKGROUND", s_szProc, 2);
                hres = E_INVALIDARG;
            }
        } else
        {
            RPF("ERROR %s: arg %d: Must set exactly one of "
                "DISCL_EXCLUSIVE or DISCL_NONEXCLUSIVE", s_szProc, 2);
            hres = E_INVALIDARG;
        }
    } else
    {
        RPF("ERROR %s: arg %d: invalid flags", s_szProc, 2);
        hres = E_INVALIDARG;

    }
    return hres;
}


HRESULT INLINE
    CDIDev_SetCooperativeLevel_IsValidHwnd(HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    RD(static char s_szProc[] = "IDirectInputDevice::SetCooperativeLevel");

    /*
     *  If a window handle is passed, it must be valid.
     *
     *  The window must be a top-level window to be activated.
     *
     *  The window must belong to the calling process so we can
     *  hook it.
     */
    if(hwnd)
    {
        hres = hresFullValidHwnd(hwnd, 1);
        if(SUCCEEDED(hres))
        {
            if(!(GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD))
            {
                if(GetWindowPid(hwnd) == GetCurrentProcessId())
                {
                } else
                {
                    RPF("ERROR %s: window must belong to current process",
                        s_szProc);
                    hres = E_HANDLE;
                }

            } else
            {
                RPF("ERROR %s: window may not be a child window", s_szProc);
                hres = E_HANDLE;
                goto done;
            }
        } else
        {
            goto done;
        }
    }

    /*
     *  Foreground mode or exclusive mode both require a window handle.
     */
    if(dwFlags & (DISCL_FOREGROUND | DISCL_EXCLUSIVE))
    {
        if(hwnd)
        {
        } else
        {
            RPF("ERROR %s: window handle required "
                "if DISCL_EXCLUSIVE or DISCL_FOREGROUND", s_szProc);
            hres = E_HANDLE;
            goto done;
        }
    }

    hres = S_OK;
    done:;
    return hres;
}


STDMETHODIMP
    CDIDev_SetCooperativeLevel(PV pdd, HWND hwnd, DWORD dwFlags _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SetCooperativeLevel,
               (_ "pxx", pdd, hwnd, dwFlags));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent somebody
         *  acquiring or Reset()ing behind our back.
         */
        CDIDev_EnterCrit(this);

        if(SUCCEEDED(hres = IDirectInputDevice_NotAcquired(this)) &&
           SUCCEEDED(hres = CDIDev_SetCooperativeLevel_IsValidFl(dwFlags)) &&
           SUCCEEDED(hres = CDIDev_SetCooperativeLevel_IsValidHwnd(hwnd, dwFlags)))
        {

            AssertF(CDIDev_IsConsistent(this));

            if( SUCCEEDED( hres ) )
            {
                hres = this->pdcb->lpVtbl->SetCooperativeLevel(
                                                              this->pdcb, hwnd, dwFlags);
                if(SUCCEEDED(hres))
                {
                    this->discl = dwFlags;
                    this->hwnd = hwnd;
                    if(this->pvi)
                    {
                        this->pvi->hwnd = hwnd;
                    }
                }
            }
            else
            {
                AssertF( hres == E_INVALIDARG );
                RPF("ERROR %s: arg %d: invalid flags", s_szProc, 2);
            }


            AssertF(CDIDev_IsConsistent(this));

        }
        CDIDev_LeaveCrit(this);

    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(SetCooperativeLevel, (PV pdm, HWND hwnd, DWORD fl),
           (pdm, hwnd, fl THAT_))

#else

    #define CDIDev_SetCooperativeLevelA         CDIDev_SetCooperativeLevel
    #define CDIDev_SetCooperativeLevelW         CDIDev_SetCooperativeLevel

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | RunControlPanel |
 *
 *          Run the DirectInput control panel for the device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          Identifies the window handle that will be used as the
 *          parent window for subsequent UI.  NULL is a valid parameter,
 *          indicating that there is no parent window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          No flags are currently defined.  This parameter "must" be
 *          zero.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          The <p dwFlags> is eventually going to allow
 *          <c DIRCP_MODAL> to request a modal control panel.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_RunControlPanel(PV pdd, HWND hwndOwner, DWORD fl _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::RunControlPanel,
               (_ "pxx", pdd, hwndOwner, fl));

    if(SUCCEEDED(hres = hresPvT(pdd)) &&
       SUCCEEDED(hres = hresFullValidHwnd0(hwndOwner, 1)) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIRCP_VALID, 2)))
    {

        PDD this = _thisPv(pdd);
        IDirectInputDeviceCallback *pdcb;

        /*
         *  Must protect with the critical section to prevent somebody
         *  Reset()ing behind our back.  However, we cannot hold the
         *  critical section during the control panel callback, because
         *  that will yield.
         *
         *  So we copy/addref the pdcb inside the critical section,
         *  then run the control panel outside the critical section,
         *  then release the pdcb when we're finally done.
         */
        CDIDev_EnterCrit(this);

        pdcb = this->pdcb;
        OLE_AddRef(pdcb);

        CDIDev_LeaveCrit(this);

        hres = pdcb->lpVtbl->RunControlPanel(pdcb, hwndOwner, fl);

        OLE_Release(pdcb);
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(RunControlPanel, (PV pdd, HWND hwndOwner, DWORD fl),
           (pdd, hwndOwner, fl THAT_))

#else

    #define CDIDev_RunControlPanelA         CDIDev_RunControlPanel
    #define CDIDev_RunControlPanelW         CDIDev_RunControlPanel

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Initialize |
 *
 *          Initialize a DirectInputDevice object.
 *
 *          Note that if this method fails, the underlying object should
 *          be considered to be an an indeterminate state and needs to
 *          be reinitialized before it can be subsequently used.
 *
 *          The <mf IDirectInput::CreateDevice> method automatically
 *          initializes the device after creating it.  Applications
 *          normally do not need to call this function.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          Identifies the instance of the device for which the interface
 *          should be associated.
 *          The <mf IDirectInput::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The device had already been initialized with
 *          the instance GUID passed in <p lpGUID>.
 *
 *          <c DIERR_ACQUIRED>: The device cannot be initialized while
 *          it is acquired.
 *
 *          <c DIERR_DEVICENOTREG>: The instance GUID does not exist
 *          on the current machine.
 *
 *          <c DIERR_HASEFFECTS>:
 *          The device cannot be reinitialized because there are
 *          still effects attached to it.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Initialize(PV pdd, HINSTANCE hinst, DWORD dwVersion, REFGUID rguid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::Initialize,
               (_ "pxxG", pdd, hinst, dwVersion, rguid));

    if(SUCCEEDED(hres = hresPvT(pdd)) &&
       SUCCEEDED(hres = hresFullValidGuid(rguid, 1)))
    {
        PDD this = _thisPv(pdd);
        CREATEDCB CreateDcb;
        IDirectInputDeviceCallback *pdcb;

        /*
         *  Must take the critical section to avoid Reset()ing
         *  the device (or generally speaking, modifying the
         *  internal state variables) while somebody else is
         *  messing with it.
         */
        CDIDev_EnterCrit(this);

        if(SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion)) &&
           SUCCEEDED(hres = hresFindInstanceGUID(rguid, &CreateDcb, 1)) &&
           SUCCEEDED(hres = CDIDev_Reset(this)))
        {
            hres = CreateDcb(0, rguid, &IID_IDirectInputDeviceCallback,
                             (PPV)&pdcb);
            if(SUCCEEDED(hres))
            {
                this->pdcb = pdcb;
                AssertF(this->pvi == 0);
                if(SUCCEEDED(hres = CDIDev_GetDataFormat(this)) &&
                   SUCCEEDED(hres = CDIDev_GetPolled(this)) &&
                   SUCCEEDED(hres = this->pdcb->lpVtbl->GetInstance(
                                                                   this->pdcb, &this->pvi)) &&
                   SUCCEEDED(hres = CMapShep_New(NULL, &IID_IDirectInputMapShepherd, &this->pMS)) &&
                   SUCCEEDED(hres = CMap_InitializeCRCTable()) &&
                   SUCCEEDED(hres = CDIDev_GetCapabilitiesHelper(this)) )
                {
                    this->dwVersion = dwVersion;

                    /*
                     *  Take a copy of the global app hacks here rather than 
                     *  using the globals everywhere to make it easier to get 
                     *  rid of the globals some fine day.
                     */
                    this->diHacks = g_AppHacks;

                    this->pdcb->lpVtbl->SetDIData(this->pdcb, dwVersion, &this->diHacks);

                    this->guid = *rguid;
                    if(this->pvi && (this->pvi->fl & VIFL_EMULATED))
                    {
                        this->pvi->pdd = this;
                    }

                    hres = this->pdcb->lpVtbl->CookDeviceData(this->pdcb, 0, 0 );
                    if(SUCCEEDED(hres))
                    {
                        this->fCook = 1;
                    }

                    CDIDev_InitFF(this);

                    hres = S_OK;
                } else
                {
                    RPF("Device driver didn't provide a data format");
                }
            } else
            {
#ifdef NOISY
                RPF("Cannot create device");
#endif
            }
        }
        CDIDev_LeaveCrit(this);
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(Initialize,
           (PV pdd, HINSTANCE hinst, DWORD dwVersion, REFGUID rguid),
           (pdd, hinst, dwVersion, rguid THAT_))

#else

    #define CDIDev_InitializeA              CDIDev_Initialize
    #define CDIDev_InitializeW              CDIDev_Initialize

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | Init |
 *
 *          Initialize the internal parts of the DirectInputDevice object.
 *
 *****************************************************************************/

void INLINE
    CDIDev_Init(PDD this)
{
    /*
     *  The critical section must be the very first thing we do,
     *  because only Finalize checks for its existence.
     *
     *  (We might be finalized without being initialized if the user
     *  passed a bogus interface to CDIDev_New.)
     */
    this->fCritInited = fInitializeCriticalSection(&this->crst);

    if( this->fCritInited )
    {
        this->celtBufMax = DEVICE_MAXBUFFERSIZE;    /* Default maximum buffer size */

        this->pdcb = c_pdcbNil;

        GPA_InitFromZero(&this->gpaEff);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | New |
 *
 *          Create a new DirectInputDevice object, uninitialized.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::<constructor>, (_ "Gp", riid, punkOuter));

    if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 3)))
    {
        hres = Excl_Init();
        if(SUCCEEDED(hres))
        {
            LPVOID pvTry = NULL;
            hres = Common_NewRiid(CDIDev, punkOuter, riid, &pvTry);

            if(SUCCEEDED(hres))
            {
                PDD this = _thisPv(pvTry);
                CDIDev_Init(this);
                if( this->fCritInited )
                {
                    *ppvObj = pvTry;
                }
                else
                {
                    Common_Unhold(this);
                    *ppvObj = NULL;
                    hres = E_OUTOFMEMORY;
                }
            }

        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | CDIDev_ModifyEffectParams |
 *
 *         Modifies parameters of DIEFFECT structure to fit the current FF device
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *
 *  @parm   IN OUT LPDIEFFECT | peff |
 *  
 *          Pointer to the effect structure
 *
 *  @parm   IN GUID | effGUID |
 *
 *         GUID for the effect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED>: The effect can't be supported by the current device
 *          (e.g. the number of FF axes on the device is 0)
 *
 *          <c DIERR_INVALIDPARAM>: Can't create the effect even with the modified parameters
 *
 *****************************************************************************/

HRESULT CDIDev_ModifyEffectParams
    (
    PV pdd,
    LPDIEFFECT peff,
    GUID effGUID
    )
{
    HRESULT hres = S_OK;
    HRESULT hresCreate = S_OK;
    LPDIRECTINPUTEFFECT pdeff;
    PDD this = _thisPv(pdd);

    EnterProcR(CDIDev_ModifyEffectParams, (_ "p", pdd));

    /* 
     *  To make sure that effects we enumerate will actually get 
     *  created on the device, try creating the effect.
     *
     *  PREFIX warns (Win:171786) that pdeff is uninitialized when 
     *  CDIDev_CreateEffect tests that the pointer to it is writable.
     */
#ifdef XDEBUG       
    hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL, ((LPUNKNOWN)this)->lpVtbl);
#else
    hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL);
#endif
                
    if(SUCCEEDED(hresCreate))
    {
        Invoke_Release(&pdeff);    
    }
    else
    {
        if (hresCreate == DIERR_INVALIDPARAM)
            {
                //two things can give DIERR_INVALIDPARAM:
                //invalid axes and invalid trigger button
                //check the axes first, then the trigger buttons
                //try to eliminate all DIERR_INVALIDPARAMS
                LPDIOBJECTDATAFORMAT lpObjDat = this->df.rgodf;
                DWORD dwNum = this->df.dwNumObjs;
                DWORD nCount;
                LPDWORD lpAxes;
                LPDWORD lpThisAxis;
                LPDWORD lpEffAxis;
                DWORD nAxes = 0;
                DWORD dwTrigger = DIJOFS_BUTTON(0);
                BOOL bTriggerCorrect = FALSE;
                AllocCbPpv(sizeof(DWORD)*dwNum, &lpAxes);
                lpThisAxis = lpAxes;
                for (nCount = 0; nCount < dwNum; nCount ++)
                {
                    AssertF(lpObjDat != NULL);

                    //check the axes
                    if ((lpObjDat->dwType & (DIDFT_AXIS | DIDFT_FFACTUATOR) & DIDFT_TYPEMASK) &&
                        (fHasAllBitsFlFl(lpObjDat->dwType, (DIDFT_AXIS | DIDFT_FFACTUATOR) & DIDFT_ATTRMASK)))
                    {
                        *lpAxes = lpObjDat->dwOfs;
                        nAxes++;
                        lpAxes++;
                    }
                    else
                    {
                        //check the trigger button, if there's one
                        if ((peff->dwTriggerButton != DIEB_NOTRIGGER) && 
                            (lpObjDat->dwType & DIDFT_FFEFFECTTRIGGER & DIDFT_TYPEMASK) &&
                            (fHasAllBitsFlFl(lpObjDat->dwType, DIDFT_FFEFFECTTRIGGER & DIDFT_ATTRMASK)))
            
                        {
                            if (lpObjDat->dwOfs == peff->dwTriggerButton)
                            {
                                //the trigger is valid
                                bTriggerCorrect = TRUE;
                            }
                            else
                            {
                                //remember the trigger offset for the future
                                dwTrigger = lpObjDat->dwOfs;
                            }
                        }
                    }

                    lpObjDat++;
                }

                //first, chack if there are any FF axes
                if (nAxes == 0)
                {
                        //return an error if no FF axes on device
                        hres = DIERR_UNSUPPORTED;
                }
                else
                {

                    
                    //trigger buttons are checked for validity before axes,
                    //so set the trigger button, if needed,
                    //because if it is invalid, this is what caused the error
                    if ((peff->dwTriggerButton != DIEB_NOTRIGGER) && (bTriggerCorrect == FALSE))
                    {
                        peff->dwTriggerButton = dwTrigger;

                        // and try creating again
#ifdef XDEBUG
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL, ((LPUNKNOWN)this)->lpVtbl);
#else
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL);
#endif
                        if(SUCCEEDED(hresCreate))
                        {
                            Invoke_Release(&pdeff);
                        }

                    }
                    
                
                    if (hresCreate == DIERR_INVALIDPARAM)
                    {
                                
                        HRESULT hresInfo = S_OK;
                        EFFECTMAPINFO emi;

                        //this time, set the axes
                        if (peff->cAxes > nAxes)
                        {
                            //change the number of axes
                            peff->cAxes = nAxes;

                            //change the flags
                            if ((nAxes < 3)  && (peff->dwFlags & DIEFF_SPHERICAL))
                            {
                                peff->dwFlags &= ~DIEFF_SPHERICAL;
                                peff->dwFlags |= DIEFF_POLAR;
                            }
                            else
                            {
                                if ((nAxes < 2) && (peff->dwFlags & DIEFF_POLAR))
                                {
                                    peff->dwFlags &= ~DIEFF_POLAR;
                                    peff->dwFlags |= DIEFF_CARTESIAN;
                                }
                            }

                        }


                        //check if size of type-specific param structures is not bigger then number of axes,
                        //since this can also give us invalid params in type-specific .

                        //need to do this only for conditions
                        if (SUCCEEDED(hresInfo = CDIDev_FindEffectGUID(this, &effGUID, &emi, 2))) 
                        {
                            //do the conditions
                            if (emi.attr.dwEffType & DIEFT_CONDITION)
                            {
                                if (peff->cbTypeSpecificParams/(sizeof(DICONDITION)) > peff->cAxes)
                                {
                                    peff->cbTypeSpecificParams = peff->cAxes*(sizeof(DICONDITION));
                                }
                            }

                            //don't need to do anything for custom forces,
                            //since DInput doesn't check number of channels against number of axes anyway
                        }


                        //write over the axes
                        lpEffAxis = peff->rgdwAxes;
                        for (nCount = 0; nCount < nAxes, nCount < peff->cAxes; nCount ++)
                        {
                            *(lpEffAxis) = *(lpThisAxis);
                            lpThisAxis ++;
                            lpEffAxis++;
                        }


                        // and try creating again
#ifdef XDEBUG
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL, ((LPUNKNOWN)this)->lpVtbl);
#else
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL);
#endif
                        if(SUCCEEDED(hresCreate))
                        {
                                Invoke_Release(&pdeff);    
                        }
                        
                    }
                }

                //free the axes array
                FreePpv(&lpAxes);
            }
        }

    if ((SUCCEEDED(hres)) && (hresCreate == DIERR_INVALIDPARAM))
    {
        hres = hresCreate;
    }


    ExitOleProc();
    return hres;

}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev | CDIDev_IsStandardEffect |
 *
 *         Checks if the effect GUID belongs to a standard DI effect
 *
 *  @parm   IN GUID | effGUID |
 *
 *         GUID for the effect
 *
 *  @returns BOOL
 *
 *      TRUE if it is a standard DI effect;
 *      FALSE otherwise.
 *
 *
 *****************************************************************************/

BOOL CDIDev_IsStandardEffect
    (GUID effGUID)
{
    BOOL bStandard = TRUE;


    //check all the standard DX7 GUIDs
    if ((IsEqualGUID(&effGUID, &GUID_Sine))         ||
        (IsEqualGUID(&effGUID, &GUID_Triangle))     ||
        (IsEqualGUID(&effGUID, &GUID_ConstantForce)) ||
        (IsEqualGUID(&effGUID, &GUID_RampForce))        ||
        (IsEqualGUID(&effGUID, &GUID_Square))       ||
        (IsEqualGUID(&effGUID, &GUID_SawtoothUp))   ||
        (IsEqualGUID(&effGUID, &GUID_SawtoothDown)) ||
        (IsEqualGUID(&effGUID, &GUID_Spring))       ||
        (IsEqualGUID(&effGUID, &GUID_Damper))       ||
        (IsEqualGUID(&effGUID, &GUID_Inertia))      ||
        (IsEqualGUID(&effGUID, &GUID_Friction))     ||
        (IsEqualGUID(&effGUID, &GUID_CustomForce)))
    {
        bStandard = TRUE;
    }

    else
    {
        bStandard = FALSE;
    }

    return bStandard;

}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | EnumEffectsInFile |
 *
 *          Enumerates DIEFFECT struct(s) and effect GUID from file. 
 *          An application can use this in order to create pre-authored
 *          force effects.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm  LPCSTR | lpszFileName | 
 *
 *          Name of the RIFF file that contains collection of effects. 
 *
 *  @parm   IN OUT LPENUMEFFECTSCALLBACK | pec |
 *  
 *          The callback function.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice::EnumObjects> function.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          Flags which control the enumeration.
 *
 *          It consists of <c DIFEF_*> flags, documented separately.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputDevice> or
 *          <p lpdc> parameter is invalid.
 *
 *  @cb     BOOL CALLBACK | DIEnumEffectsCallback |
 *
 *          An application-defined callback function that receives
 *          effect GUID, DIEFFECT and repeat count as a result of a call to the
 *          <om IDirectInputDevice::EnumEffectsInFile> method.
 *
 *  @parm   OUT LPCDIFILEEFFECT | lpDiFileEf |
 *          
 *          Pointer to a DIFILEEFFECT structure. 
 *
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice::EnumObjects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *****************************************************************************/

HRESULT CDIDev_EnumEffectsInFileA
    (
    PV pddA,
    LPCSTR lpszFileName, 
    LPDIENUMEFFECTSINFILECALLBACK pec, 
    LPVOID pvRef,
    DWORD dwFlags
    )
{
    HRESULT hres = E_FAIL;

    
    EnterProcR(IDirectInputDevice8::EnumEffectsInFile, (_ "s", lpszFileName));

    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidReadStrA(lpszFileName, MAX_JOYSTRING,1)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 2)) &&
       SUCCEEDED(hres = hresFullValidFl(dwFlags, DIFEF_ENUMVALID, 3)) )
    {
        PDD this = _thisPvNm(pddA, ddA);
        HMMIO       hmmio;        
        MMCKINFO    mmck;
        DWORD       dwEffectSz;

        hres = RIFF_Open(lpszFileName, MMIO_READ | MMIO_ALLOCBUF , &hmmio, &mmck, &dwEffectSz);

        if(SUCCEEDED(hres))
        {
            HRESULT hresRead;
            DIEFFECT        effect;
            DIFILEEFFECT    DiFileEf;
            DIENVELOPE      diEnvelope;
            DWORD           rgdwAxes[DIEFFECT_MAXAXES];
            LONG            rglDirection[DIEFFECT_MAXAXES];
            
            effect.rgdwAxes     = rgdwAxes;
            effect.rglDirection = rglDirection;
            effect.lpEnvelope   = &diEnvelope;

            DiFileEf.dwSize     = cbX(DiFileEf);
            DiFileEf.lpDiEffect = &effect;

            while ((SUCCEEDED(hres)) && (SUCCEEDED(hresRead = RIFF_ReadEffect(hmmio, &DiFileEf))))
            {
                BOOL fRc = DIENUM_CONTINUE; 
                BOOL bInclude = TRUE;
                HRESULT hresModify = DI_OK;

                //modify if needed
                if (dwFlags & DIFEF_MODIFYIFNEEDED)
                {
                    hresModify = CDIDev_ModifyEffectParams(this, &effect, DiFileEf.GuidEffect); 
                }

                //if necessary, check whether effect is standard
                if (!(dwFlags & DIFEF_INCLUDENONSTANDARD))
                {
                    bInclude = CDIDev_IsStandardEffect(DiFileEf.GuidEffect);
                }

                //call back only if all the conditions posed by the flags are satisfied 
                if ((SUCCEEDED(hresModify)) && (bInclude == TRUE))
                {
                    fRc = Callback(pec, &DiFileEf, pvRef);
                }

                //free type-specific only if allocated
                if(effect.cbTypeSpecificParams > 0)
                {
                    FreePv(effect.lpvTypeSpecificParams);
                    effect.cbTypeSpecificParams = 0x0;
                }

                if(fRc == DIENUM_STOP)
                {
                    break;
                } else if(fRc == DIENUM_CONTINUE)
                {
                    continue;
                } else
                {
                    RPF("IDirectInputDevice::EnumEffectsInFile: Invalid return value from enumeration callback");
                    ValidationException();
                    break;
                }
            }
            RIFF_Close(hmmio, 0);
            //if hresRead failed because couldn't descend into the chunk, it means the end of file,
            //so everything is OK;
            //else return this error
            if (SUCCEEDED(hres))
            {   
                if (hresRead == hresLe(ERROR_SECTOR_NOT_FOUND))
                {
                    hres = S_OK;
                }
                else
                {
                    hres = hresRead;
                }
            }
        }
    }

    ExitOleProc();
    return hres;
}


HRESULT CDIDev_EnumEffectsInFileW
    (
    PV pddW,
    LPCWSTR lpszFileName, 
    LPDIENUMEFFECTSINFILECALLBACK pec, 
    LPVOID pvRef,
    DWORD dwFlags
    )
{

    HRESULT hres = E_FAIL;

    EnterProcR(IDirectInputDevice8::EnumEffectsInFileW, (_ "s", lpszFileName));

    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(lpszFileName, MAX_JOYSTRING,1)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 2)) &&
       SUCCEEDED(hres = hresFullValidFl(dwFlags, DIFEF_ENUMVALID, 3)) )
    {
        CHAR szFileName[MAX_PATH];

        PDD this = _thisPvNm(pddW, ddW);
        
        UToA(szFileName, MAX_PATH, lpszFileName);

        hres = CDIDev_EnumEffectsInFileA(&this->ddA, szFileName, pec, pvRef, dwFlags);
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | WriteEffectToFile |
 *
 *          Writes DIEFFECT struct(s) and effect GUID to a file. 
 *          An application can use this in order to create pre-authored
 *          force effects.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPCSTR | lpszFileName | 
 *
 *          Name of the RIFF file that contains collection of effects. 
 *
 *  @parm   IN DWORD  | dwEntries |
 *
 *          Number of <t DIFILEEFFECT> structures in the array.
 *
 *  @parm   IN LPCDIFILEEFFECT | rgDiFileEft |
 *
 *          Array of <t DIFILEEFFECT> structure.
 *
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          Flags which control how the effect should be written.
 *
 *          It consists of <c DIFEF_*> flags, documented separately.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputDevice> or
 *          <p lpdc> parameter is invalid.
 *
 *****************************************************************************/


HRESULT CDIDev_WriteEffectToFileA
    (
    PV          pddA,
    LPCSTR      lpszFileName,
    DWORD       dwEntries,
    LPDIFILEEFFECT rgDiFileEffect,
    DWORD       dwFlags
    )
{
    HRESULT hres = E_NOTIMPL;

    EnterProcR(IDirectInputDevice8::WriteEffectToFileA, (_ "s", lpszFileName));


    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidReadStrA(lpszFileName, MAX_JOYSTRING,1))&&
       SUCCEEDED(hres = hresFullValidFl(dwFlags, DIFEF_ENUMVALID, 3))  &&
       SUCCEEDED(hres = (IsBadReadPtr(rgDiFileEffect, cbX(*rgDiFileEffect))) ? E_POINTER : S_OK))

    {
        PDD this = _thisPvNm(pddA, ddA);
        HMMIO       hmmio;        
        MMCKINFO    mmck;
        DWORD       dwEffectSz;

        hres = RIFF_Open(lpszFileName, MMIO_CREATE | MMIO_WRITE | MMIO_ALLOCBUF , &hmmio, &mmck, &dwEffectSz);

        if(SUCCEEDED(hres))
        {
            UINT nCount;
            LPDIFILEEFFECT  lpDiFileEf = rgDiFileEffect;

            //write out the effects
            for(nCount = 0; nCount < dwEntries; nCount++)
            {
                BOOL bInclude = TRUE;

                hres = (IsBadReadPtr(lpDiFileEf, cbX(*lpDiFileEf))) ? E_POINTER : S_OK;

                if (FAILED(hres))
                {
                    break;
                }
                

                //if necessary, check whether the effect is standard
                if (!(dwFlags & DIFEF_INCLUDENONSTANDARD))
                {
                    bInclude = CDIDev_IsStandardEffect(lpDiFileEf->GuidEffect);
                }

                if ((SUCCEEDED(hres)) && (bInclude == TRUE))
                {
                    hres = RIFF_WriteEffect(hmmio, lpDiFileEf);
                }

                if(FAILED(hres))
                {
                    break;
                }

                lpDiFileEf++;
                
            }
            RIFF_Close(hmmio, 0);
        }
    }

    ExitOleProc();
    return hres;
}


HRESULT CDIDev_WriteEffectToFileW
    (
    PV          pddW,
    LPCWSTR      lpszFileName,
    DWORD       dwEntries,
    LPDIFILEEFFECT lpDiFileEffect,
    DWORD       dwFlags
    )
{

    HRESULT hres = E_FAIL;

    EnterProcR(IDirectInputDevice8::WriteEffectToFile, (_ "s", lpszFileName));

    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(lpszFileName, MAX_JOYSTRING,1)))
    {
        CHAR szFileName[MAX_PATH];

        PDD this = _thisPvNm(pddW, ddW);
        
        UToA(szFileName, MAX_PATH, lpszFileName);

        hres = CDIDev_WriteEffectToFileA(&this->ddA, szFileName, dwEntries, lpDiFileEffect, dwFlags);
    }

    return hres;
}



/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CDIDev_Signature        0x20564544      /* "DEV " */

Primary_Interface_Begin(CDIDev, TFORM(ThisInterfaceT))
TFORM(CDIDev_GetCapabilities),
TFORM(CDIDev_EnumObjects),
TFORM(CDIDev_GetProperty),
TFORM(CDIDev_SetProperty),
TFORM(CDIDev_Acquire),
TFORM(CDIDev_Unacquire),
TFORM(CDIDev_GetDeviceState),
TFORM(CDIDev_GetDeviceData),
TFORM(CDIDev_SetDataFormat),
TFORM(CDIDev_SetEventNotification),
TFORM(CDIDev_SetCooperativeLevel),
TFORM(CDIDev_GetObjectInfo),
TFORM(CDIDev_GetDeviceInfo),
TFORM(CDIDev_RunControlPanel),
TFORM(CDIDev_Initialize),
TFORM(CDIDev_CreateEffect),
TFORM(CDIDev_EnumEffects),
TFORM(CDIDev_GetEffectInfo),
TFORM(CDIDev_GetForceFeedbackState),
TFORM(CDIDev_SendForceFeedbackCommand),
TFORM(CDIDev_EnumCreatedEffectObjects),
TFORM(CDIDev_Escape),
TFORM(CDIDev_Poll),
TFORM(CDIDev_SendDeviceData),
TFORM(CDIDev_EnumEffectsInFile),
TFORM(CDIDev_WriteEffectToFile),
TFORM(CDIDev_BuildActionMap),
TFORM(CDIDev_SetActionMap),
TFORM(CDIDev_GetImageInfo),

    Primary_Interface_End(CDIDev, TFORM(ThisInterfaceT))

Secondary_Interface_Begin(CDIDev, SFORM(ThisInterfaceT), SFORM(dd))
SFORM(CDIDev_GetCapabilities),
SFORM(CDIDev_EnumObjects),
SFORM(CDIDev_GetProperty),
SFORM(CDIDev_SetProperty),
SFORM(CDIDev_Acquire),
SFORM(CDIDev_Unacquire),
SFORM(CDIDev_GetDeviceState),
SFORM(CDIDev_GetDeviceData),
SFORM(CDIDev_SetDataFormat),
SFORM(CDIDev_SetEventNotification),
SFORM(CDIDev_SetCooperativeLevel),
SFORM(CDIDev_GetObjectInfo),
SFORM(CDIDev_GetDeviceInfo),
SFORM(CDIDev_RunControlPanel),
SFORM(CDIDev_Initialize),
SFORM(CDIDev_CreateEffect),
SFORM(CDIDev_EnumEffects),
SFORM(CDIDev_GetEffectInfo),
SFORM(CDIDev_GetForceFeedbackState),
SFORM(CDIDev_SendForceFeedbackCommand),
SFORM(CDIDev_EnumCreatedEffectObjects),
TFORM(CDIDev_Escape),
SFORM(CDIDev_Poll),
SFORM(CDIDev_SendDeviceData),
SFORM(CDIDev_EnumEffectsInFile),
SFORM(CDIDev_WriteEffectToFile),
SFORM(CDIDev_BuildActionMap),
SFORM(CDIDev_SetActionMap),
SFORM(CDIDev_GetImageInfo),
    Secondary_Interface_End(CDIDev, SFORM(ThisInterfaceT), SFORM(dd))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\didevdf.c ===
/*****************************************************************************
 *
 *  DIDevDf.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The part of IDirectInputDevice that worries about
 *      data formats and reading device data.
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "didev.h"

#undef sqfl
#define sqfl sqflDf

int INTERNAL
CDIDev_OffsetToIobj(PDD this, DWORD dwOfs);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetAbsDeviceState |
 *
 *          Get the absolute device state.
 *
 *  @parm   OUT LPVOID | pvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetAbsDeviceState(PDD this, LPVOID pvData)
{
    return this->pdcb->lpVtbl->GetDeviceState(this->pdcb, pvData);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetRelDeviceState |
 *
 *          Get the relative device state.
 *
 *  @parm   OUT LPVOID | pvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetRelDeviceState(PDD this, LPVOID pvData)
{
    HRESULT hres;

    hres = this->pdcb->lpVtbl->GetDeviceState(this->pdcb, pvData);
    if ( SUCCEEDED(hres) ) {
        UINT iaxis;
        AssertF(fLimpFF(this->cAxes, this->pvLastBuffer && this->rgdwAxesOfs));

        /*
         *  For each axis, replace the app's buffer with the delta,
         *  and save the old value.
         */
        for ( iaxis = 0; iaxis < this->cAxes; iaxis++ ) {
            LONG UNALIGNED *plApp  = pvAddPvCb(pvData, this->rgdwAxesOfs[iaxis]);
            LONG UNALIGNED *plLast = pvAddPvCb(this->pvLastBuffer,
                                      this->rgdwAxesOfs[iaxis]);
            LONG lNew = *plApp;
            *plApp -= *plLast;
            *plLast = lNew;
        }

        hres = S_OK;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateSlow |
 *
 *          Obtains data from the DirectInput device the slow way.
 *
 *          Read the data into the private buffer, then copy it
 *          bit by bit into the application's buffer.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateSlow(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetDeviceStateSlow, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptNone);
    AssertF(this->pvBuffer);
    AssertF(this->pdcb);
    hres = this->GetDeviceState(this, this->pvBuffer);
    if ( SUCCEEDED(hres) ) {
        int iobj;
        ZeroMemory(pvData, this->dwDataSize);
        for ( iobj = this->df.dwNumObjs; --iobj >= 0; ) {
            if ( this->pdix[iobj].dwOfs != 0xFFFFFFFF ) { /* Data was requested */
                DWORD UNALIGNED *pdwOut = pvAddPvCb(pvData, this->pdix[iobj].dwOfs);
                DWORD UNALIGNED *pdwIn  = pvAddPvCb(this->pvBuffer, this->df.rgodf[iobj].dwOfs);
                if ( this->df.rgodf[iobj].dwType & DIDFT_DWORDOBJS ) {
                    *pdwOut = *pdwIn;
                } else {
                    *(LPBYTE)pdwOut = *(LPBYTE)pdwIn;
                }
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateMatched |
 *
 *          Obtains data from the DirectInput device in the case
 *          where the data formats are matched.
 *
 *          Read the data into the private buffer, then block copy it
 *          into the application's buffer.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateMatched(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetDeviceStateMatched, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptMatch);
    AssertF(this->pvBuffer);
    AssertF(this->pdcb);
    hres = this->GetDeviceState(this, this->pvBuffer);

    if ( SUCCEEDED(hres) ) {
        /*
         *  To keep keyboard clients happy: Zero out the fore and aft.
         *  No need to optimize the perfect match case, because that
         *  gets a different optimization level.
         */
        ZeroMemory(pvData, this->dwDataSize);
        memcpy(pvAddPvCb(pvData, this->ibDelta + this->ibMin),
               pvAddPvCb(this->pvBuffer,         this->ibMin), this->cbMatch);
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateDirect |
 *
 *          Obtains data from the DirectInput device in the case
 *          where we can read the data directly into the client buffer.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateDirect(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetDeviceStateDirect, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptDirect);
    AssertF(!this->pvBuffer);
    AssertF(this->pdcb);

    /*
     *  To keep keyboard clients happy: Zero out the fore and aft.
     */
    ZeroBuf(pvData, this->dwDataSize);
    hres = this->GetDeviceState(this, pvAddPvCb(pvData, this->ibDelta));
    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateEqual |
 *
 *          Obtains data from the DirectInput device in the case
 *          where the two data formats are completely identical.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateEqual(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IEqualInputDevice::GetDeviceStateEqual, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptEqual);
    AssertF(this->ibDelta == 0);
    AssertF(this->dwDataSize == this->df.dwDataSize);
    AssertF(!this->pvBuffer);
    AssertF(this->pdcb);

    /*
     *  Note that this->ibMin is not necessarily zero if the device
     *  data format doesn't begin at zero (which keyboards don't).
     */
    hres = this->GetDeviceState(this, pvData);

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev | IsMatchingGUID |
 *
 *          Helper function that checks if a <t GUID> counts as
 *          a match when parsing the data format.
 *
 *  @parm   PCGUID | pguidSrc |
 *
 *          The <t GUID> to check.
 *
 *  @parm   PCGUID | pguidDst |
 *
 *          The <t GUID> it should match.
 *
 *  @returns
 *
 *          Nonzero if this counts as a success.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

GUID GUID_Null;             /* A zero-filled guid */

#pragma END_CONST_DATA

BOOL INLINE
CDIDev_IsMatchingGUID(PDD this, PCGUID pguidSrc, PCGUID pguidDst)
{
    UNREFERENCED_PARAMETER( this );

    return IsEqualGUID(pguidSrc, &GUID_Null) ||
    IsEqualGUID(pguidSrc, pguidDst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev | IsMatchingUsage |
 *
 *          Helper function that checks if a <f DIMAKEUSAGEDWORD>
 *          counts as a match when parsing the data format.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The <f DIMAKEUSAGEDWORD> to check.
 *
 *  @parm   int | iobj |
 *
 *          The index of hte object to check for a match.
 *
 *  @returns
 *
 *          Nonzero if this counts as a success.
 *
 *****************************************************************************/

BOOL INLINE
CDIDev_IsMatchingUsage(PDD this, DWORD dwUsage, int iobj)
{
    AssertF(this->pdcb);

    return dwUsage == this->pdcb->lpVtbl->GetUsage(this->pdcb, iobj);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | FindDeviceObjectFormat |
 *
 *          Search the device object format table for the one that
 *          matches the guid in question.
 *
 *  @parm   PCODF | podf |
 *
 *          The object to locate.  If the <e DIOBJECTDATAFORMAT.rguid>
 *          is null, then the field is a wildcard.
 *
 *          If the <e DIOBJECTDATAFORMAT.dwType> specifies
 *          <c DIDFT_ANYINSTANCE>, then any instance will be accepted.
 *
 *  @parm   PDIXLAT | pdix |
 *
 *          The partial translation table so far.  This is used to find
 *          an empty slot in case of wildcards.
 *
 *  @returns
 *
 *          Returns the index of the object that matches, or -1 if
 *          the object is not supported by the device.
 *
 *          Someday:  Should fall back to best match if types don't match.
 *
 *****************************************************************************/

int INTERNAL
CDIDev_FindDeviceObjectFormat(PDD this, PCODF podf, PDIXLAT pdix)
{
    PCODF podfD;                        /* The format in the device */
    UINT iobj;

    /*
     *  We must count upwards, so that first-fit chooses the smallest one.
     */
    for ( iobj = 0; iobj < this->df.dwNumObjs; iobj++ ) {
        podfD = &this->df.rgodf[iobj];
        if (

           /*
            *  Type needs to match.
            *
            *  Note that works for output-only actuators:
            *  Since you cannot read from an output-only
            *  actuator, you can't put it in a data format.
            *
            */
           (podf->dwType & DIDFT_TYPEVALID & podfD->dwType)

           /*
            *  Attributes need to match.
            */
           &&  fHasAllBitsFlFl(podfD->dwType, podf->dwType & DIDFT_ATTRVALID)

           /*
            *  Slot needs to be empty.
            */
           &&  pdix[iobj].dwOfs == 0xFFFFFFFF

           /*
            *  "If there is a guid/usage, it must match."
            *
            *  If pguid is NULL, then the match is vacuous.
            *
            *  If DIDOI_GUIDISUSAGE is clear, then pguid points to
            *  a real GUID.  GUID_NULL means "Don't care" and matches
            *  anything.  Otherwise, it must match the actual GUID.
            *
            *  If DIDOI_GUIDISUSAGE is set, then pguid is really
            *  a DIMAKEUSAGEDWORD of the usage and usage page,
            *  which we compare against the same in the object.
            */

           &&  (podf->pguid == 0 ||
                ((podf->dwFlags & DIDOI_GUIDISUSAGE) ?
                 CDIDev_IsMatchingUsage(this, (DWORD)(UINT_PTR)podf->pguid, iobj) :
                 CDIDev_IsMatchingGUID(this, podf->pguid, podfD->pguid)))

           /*
            *  If there is an instance number, it must match.
            */
           &&  fLimpFF((podf->dwType & DIDFT_ANYINSTANCE) !=
                       DIDFT_ANYINSTANCE,
                       fEqualMaskFlFl(DIDFT_ANYINSTANCE,
                                      podf->dwType, podfD->dwType))

           /*
            *  If there is an aspect, it must match.
            *
            *  If the device data format doesn't specify an aspect,
            *  then that counts as a free match too.
            */
           &&  fLimpFF((podf->dwFlags & DIDOI_ASPECTMASK) &&
                       (podfD->dwFlags & DIDOI_ASPECTMASK),
                       fEqualMaskFlFl(DIDOI_ASPECTMASK,
                                      podf->dwFlags, podfD->dwFlags))

           ) {                                 /* Criterion matches, woo-hoo */
            return iobj;
        }
    }
    return -1;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | ParseDataFormat |
 *
 *          Parse the data format passed by the application and
 *          convert it into a format that we can use to translate
 *          the device data into application data.
 *
 *  @parm   IN LPDIDATAFORMAT | lpdf |
 *
 *          Points to a structure that describes the format of the data
 *          the DirectInputDevice should return.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer.
 *
 *          <c DIERR_ACQUIRED>: Cannot change the data format while the
 *          device is acquired.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_ParseDataFormat(PDD this, const DIDATAFORMAT *lpdf)
{
    PDIXLAT pdix;
    // Prefix: Whistler 45081
    PINT rgiobj = NULL;
    HRESULT hres;
    DIPROPDWORD dipdw;
    VXDDATAFORMAT vdf;
#ifdef DEBUG
    EnterProc(CDIDev_ParseDataFormat, (_ "pp", this, lpdf));
#else
    EnterProcR(IDirectInputDevice8::SetDataFormat, (_ "pp", this, lpdf));
#endif

    /*
     *  Caller should've nuked the old translation table.
     */
    AssertF(this->pdix == 0);
    AssertF(this->rgiobj == 0);
    AssertF(this->cdwPOV == 0);

    vdf.cbData = this->df.dwDataSize;
    vdf.pDfOfs = 0;

    if ( SUCCEEDED(hres = AllocCbPpv(cbCxX(this->df.dwNumObjs, DIXLAT), &pdix)) &&
         SUCCEEDED(hres = AllocCbPpv(cbCdw(this->df.dwDataSize), &vdf.pDfOfs)) &&
         SUCCEEDED(hres = AllocCbPpv(cbCdw(lpdf->dwDataSize), &rgiobj)) &&
         SUCCEEDED(hres =
                   ReallocCbPpv(cbCdw(lpdf->dwNumObjs), &this->rgdwPOV)) ) {
        UINT iobj;

        /*
         * Pre-init all the translation tags to -1,
         * which means "not in use"
         */
        memset(pdix, 0xFF, cbCxX(this->df.dwNumObjs, DIXLAT));
        memset(vdf.pDfOfs, 0xFF, cbCdw(this->df.dwDataSize));
        memset(rgiobj, 0xFF, cbCdw(lpdf->dwDataSize));

        SquirtSqflPtszV(sqflDf | sqflVerbose, TEXT("Begin parse data format"));

        for ( iobj = 0; iobj < lpdf->dwNumObjs; iobj++ ) {
            PCODF podf = &lpdf->rgodf[iobj];
            SquirtSqflPtszV(sqflDf | sqflVerbose, TEXT("Object %2d: offset %08x"),
                            iobj, podf->dwOfs);

            /*
             *  Note that the podf->dwOfs < lpdf->dwDataSize test is safe
             *  even for DWORD objects, since we also check that both
             *  values are DWORD multiples.
             */
            if ( ((podf->dwFlags & DIDOI_GUIDISUSAGE) ||
                  fLimpFF(podf->pguid,
                          SUCCEEDED(hres = hresFullValidGuid(podf->pguid, 1)))) &&
                 podf->dwOfs < lpdf->dwDataSize ) {
                int iobjDev = CDIDev_FindDeviceObjectFormat(this, podf, pdix);


                if ( iobjDev != -1 ) {
                    PCODF podfFound = &this->df.rgodf[iobjDev];
                    if ( podfFound->dwType & DIDFT_DWORDOBJS ) {
                        if ( (podf->dwOfs & 3) == 0 ) {
                        } else {
                            RPF("%s: Dword objects must be aligned", s_szProc);
                            goto fail;
                        }
                    }

                    pdix[iobjDev].dwOfs = podf->dwOfs;
                    rgiobj[podf->dwOfs] = iobjDev;
                    vdf.pDfOfs[podfFound->dwOfs] = iobjDev;

                    if ( podfFound->dwFlags & DIDOI_POLLED ) {
                        this->fPolledDataFormat = TRUE;
                    }

                    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
                    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
                    dipdw.diph.dwObj = podfFound->dwType;
                    dipdw.diph.dwHow = DIPH_BYID;
                    dipdw.dwData     = 0x1;   // Enable this report ID
                    hres = CDIDev_RealSetProperty(this, DIPROP_ENABLEREPORTID, &dipdw.diph);
                    if ( hres == E_NOTIMPL )
                    {
                        hres = S_OK;
                    }
                    else if( FAILED( hres ) )
                    {
                        SquirtSqflPtszV(sqflDf | sqflError,
                                        TEXT("Could not set DIPROP_ENABLEREPORTID for offset %d"),
                                        iobj);
                    }


                } else if ( podf->dwType & DIDFT_OPTIONAL ) {
                    SquirtSqflPtszV(sqflDf | sqflVerbose,
                                    TEXT("Object %2d: Skipped (optional)"),
                                    iobj);
                    /*
                     *  We need to remember where the failed POVs live
                     *  so we can neutralize them in GetDeviceState().
                     */
                    if ( podf->dwType & DIDFT_POV ) {
                        AssertF(this->cdwPOV < lpdf->dwNumObjs);
                        this->rgdwPOV[this->cdwPOV++] = podf->dwOfs;
                    }
                } else {
                    RPF("%s: Format not compatible with device", s_szProc);
                    goto fail;
                }
            } else {
                if ( podf->dwOfs >= lpdf->dwDataSize ) {
                    RPF("%s: rgodf[%d].dwOfs of 0x%08x out of range in data format", 
                        s_szProc, iobj, podf->dwOfs );
                }
                fail:;
                hres = E_INVALIDARG;
                goto done;
            }
        }

#ifdef DEBUG
        /*
         *  Double-check the lookup tables just to preserve our sanity.
         */
        {
            UINT dwOfs;

            for ( dwOfs = 0; dwOfs < lpdf->dwDataSize; dwOfs++ ) {
                if ( rgiobj[dwOfs] >= 0 ) {
                    AssertF(pdix[rgiobj[dwOfs]].dwOfs == dwOfs);
                } else {
                    AssertF(rgiobj[dwOfs] == -1);
                }
            }
        }
#endif

        /*
         *  Shrink the "failed POV" array to its actual size.
         *  The shrink "should" always succeed.  Note also that
         *  even if it fails, we're okay; we just waste a little
         *  memory.
         */
        hres = ReallocCbPpv(cbCdw(this->cdwPOV), &this->rgdwPOV);
        AssertF(SUCCEEDED(hres));

        /*
         *  If we are using cooked data, then we actually hand the
         *  device driver a different translation table which
         *  combines the offset and dwDevType so data cooking can
         *  happen safely.
         */

        vdf.pvi = this->pvi;

        if ( fLimpFF(this->pvi,
                     SUCCEEDED(hres = Hel_SetDataFormat(&vdf))) ) {
            this->pdix = pdix;
            pdix = 0;
            this->rgiobj = rgiobj;
            rgiobj = 0;
            this->dwDataSize = lpdf->dwDataSize;
            hres = S_OK;
        } else {
            AssertF(FAILED(hres));
        }

    } else {
        /* Out of memory */
    }

    done:;
    FreePpv(&pdix);
    FreePpv(&rgiobj);
    FreePpv(&vdf.pDfOfs);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | OptimizeDataFormat |
 *
 *          Study the parsed data format to determine whether we can
 *          used an optimized <mf CDIDev::GetDeviceState> to obtain
 *          the data more quickly.
 *
 *          The data format is considered optimized if it matches the
 *          device data format, modulo possible shifting due to insertion
 *          of bonus fields at the beginning or end, and modulo missing
 *          fields.
 *
 *          The data format is considered fully-optimized if it
 *          optimized, and no shifting is necessary, and the structure size
 *          is exactly the same.  This means the buffer can be passed
 *          straight through to the driver.
 *
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIDev_OptimizeDataFormat(PDD this)
{
    int ib;
    DWORD ibMax;                        /* One past highest match point */
    DWORD ibMin;                        /* Lowest match point */
    int iobj;
    DWORD dwDataSize;
    HRESULT hres;
    EnterProc(CDIDev_OptimizeDataFormat, (_ "p", this));

    ib = (int)0x8000000;                /* Not yet known */
    ibMin = 0xFFFFFFFF;
    ibMax = 0;

    for ( iobj = this->df.dwNumObjs; --iobj >= 0; ) {
        DWORD ibMaxThis;
        if ( this->pdix[iobj].dwOfs != 0xFFFFFFFF ) { /* Data was requested */

            int ibExpected = (int)(this->pdix[iobj].dwOfs -
                                   this->df.rgodf[iobj].dwOfs);
            if ( fLimpFF(ib != (int)0x8000000, ib == ibExpected) ) {
                ib  = ibExpected;
            } else {
                SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("IDirectInputDevice: Optimization level 0, translation needed") );
                this->diopt = dioptNone;
                this->GetState = CDIDev_GetDeviceStateSlow;
                goto done;
            }
            if ( ibMin > this->df.rgodf[iobj].dwOfs ) {
                ibMin = this->df.rgodf[iobj].dwOfs;
            }
            if ( this->df.rgodf[iobj].dwType & DIDFT_DWORDOBJS ) {
                ibMaxThis = this->df.rgodf[iobj].dwOfs + sizeof(DWORD);
            } else {
                ibMaxThis = this->df.rgodf[iobj].dwOfs + sizeof(BYTE);
            }
            if ( ibMax < ibMaxThis ) {
                ibMax = ibMaxThis;
            }
        }
    }

    /*
     *  Make sure we actually found something.
     */
    if ( ib != (int)0x8000000 ) {                     /* Data format is matched */
        AssertF(ibMin < ibMax);
        AssertF(ib + (int)ibMin >= 0);
        AssertF(ib + ibMax <= this->dwDataSize);
        this->ibDelta = ib;
        this->ibMin = ibMin;
        this->cbMatch = ibMax - ibMin;
        if ( ib >= 0 && ib + this->df.dwDataSize <= this->dwDataSize ) {
            /* We can go direct */
            if ( ib == 0 && this->dwDataSize == this->df.dwDataSize ) {
                /* Data formats are equal! */
                this->diopt = dioptEqual;
                this->GetState = CDIDev_GetDeviceStateEqual;
                SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("IDirectInputDevice: Optimization level 3, full speed ahead!") );
            } else {
                this->diopt = dioptDirect;
                this->GetState = CDIDev_GetDeviceStateDirect;
                SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("IDirectInputDevice: Optimization level 2, direct access") );
            }
        } else {
            SquirtSqflPtszV(sqfl | sqflMajor,
                TEXT("IDirectInputDevice: Optimization level 1, okay") );
            this->diopt = dioptMatch;
            this->GetState = CDIDev_GetDeviceStateMatched;
        }

    } else {                            /* No data in data format! */
        RPF("IDirectInputDevice: Null data format; if that's what you want...");
        this->diopt = dioptNone;
        this->GetState = CDIDev_GetDeviceStateSlow;
    }

    done:;
    if ( this->diopt >= dioptDirect ) {   /* Can go direct; don't need buf */
        dwDataSize = 0;
    } else {
        dwDataSize = this->df.dwDataSize;
    }

    hres = ReallocCbPpv(dwDataSize, &this->pvBuffer);

    if ( SUCCEEDED(hres) ) {
        AssertF(this->GetState);
    } else {
        FreePpv(&this->pdix);
        D(this->GetState = 0);
    }

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetDataFormat |
 *
 *          Set the data format for the DirectInput device.
 *
 *          The data format must be set before the device can be
 *          acquired.
 *
 *          It is necessary to set the data format only once.
 *
 *          The data format may not be changed while the device
 *          is acquired.
 *
 *          If the attempt to set the data format fails, all data
 *          format information is lost, and a valid data format
 *          must be set before the device may be acquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIDATAFORMAT | lpdf |
 *
 *          Points to a structure that describes the format of the data
 *          the DirectInputDevice should return.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer.
 *
 *          <c DIERR_ACQUIRED>: Cannot change the data format while the
 *          device is acquired.
 *
 *
 *****************************************************************************/

HRESULT INLINE
CDIDev_SetDataFormat_IsValidDataSize(LPCDIDATAFORMAT lpdf)
{
    HRESULT hres;
    if ( lpdf->dwDataSize % 4 == 0 ) {
        hres = S_OK;
    } else {
        RPF("IDirectInputDevice::SetDataFormat: "
            "dwDataSize must be a multiple of 4");
        hres = E_INVALIDARG;
    }
    return hres;
}

HRESULT INLINE
CDIDev_SetDataFormat_IsValidObjectSize(LPCDIDATAFORMAT lpdf)
{
    HRESULT hres;
    if ( lpdf->dwObjSize == cbX(ODF) ) {
        hres = S_OK;
    } else {
        RPF("IDirectInputDevice::SetDataFormat: Invalid dwObjSize");
        hres = E_INVALIDARG;
    }
    return hres;
}


STDMETHODIMP
CDIDev_SetDataFormat(PV pdd, LPCDIDATAFORMAT lpdf _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SetDataFormat, (_ "pp", pdd, lpdf));

    if ( SUCCEEDED(hres = hresPvT(pdd)) &&
         SUCCEEDED(hres = hresFullValidReadPxCb(lpdf, DIDATAFORMAT, 1)) &&
         SUCCEEDED(hres = hresFullValidFl(lpdf->dwFlags, DIDF_VALID, 1)) &&
         SUCCEEDED(hres = CDIDev_SetDataFormat_IsValidDataSize(lpdf)) &&
         SUCCEEDED(hres = CDIDev_SetDataFormat_IsValidObjectSize(lpdf)) &&
         SUCCEEDED(hres = hresFullValidReadPvCb(lpdf->rgodf,
                                                cbCxX(lpdf->dwNumObjs, ODF), 1)) ) {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent two people
         *  from changing the format simultaneously, or one person from
         *  changing the data format while somebody else is reading data.
         */
        CDIDev_EnterCrit(this);

        AssertF( this->dwVersion );

        if ( !this->fAcquired ) {
            DIPROPDWORD dipdw;

            /*
             *  Nuke the old data format stuff before proceeding.
             */
            FreePpv(&this->pdix);
            FreePpv(&this->rgiobj);
            this->cdwPOV = 0;
            D(this->GetState = 0);
            this->fPolledDataFormat = FALSE;

            /*
             * Wipe out the report IDs
             */
            dipdw.diph.dwSize = sizeof(DIPROPDWORD);
            dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
            dipdw.diph.dwObj = 0x0;
            dipdw.diph.dwHow = DIPH_DEVICE;
            dipdw.dwData     = 0;   // Nuke all knowledge of reportId's
            hres = CDIDev_RealSetProperty(this, DIPROP_ENABLEREPORTID, &dipdw.diph);
            if ( SUCCEEDED(hres) || hres == E_NOTIMPL )
            {
                hres = CDIDev_ParseDataFormat(this, lpdf);
                if ( SUCCEEDED(hres) ) {
                    hres = CDIDev_OptimizeDataFormat(this);

                    /*
                     *  Now set the axis mode, as a convenience.
                     */
                    CAssertF(DIDF_VALID == (DIDF_RELAXIS | DIDF_ABSAXIS));

                    switch ( lpdf->dwFlags ) {
                        case 0:
                            hres = S_OK;
                            goto axisdone;

                        case DIDF_RELAXIS:
                            dipdw.dwData = DIPROPAXISMODE_REL;
                            break;

                        case DIDF_ABSAXIS:
                            dipdw.dwData = DIPROPAXISMODE_ABS;
                            break;

                        default:
                            RPF("%s: Cannot combine DIDF_RELAXIS with DIDF_ABSAXIS",
                                s_szProc);
                            hres = E_INVALIDARG;
                            goto axisdone;

                    }

                    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
                    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
                    dipdw.diph.dwObj = 0;
                    dipdw.diph.dwHow = DIPH_DEVICE;

                    hres = CDIDev_RealSetProperty(this, DIPROP_AXISMODE, &dipdw.diph);

                    if ( SUCCEEDED(hres) ) {
                        hres = S_OK;
                    }

                }
            } else
            {
                SquirtSqflPtszV(sqflDf,
                                TEXT("Could not set DIPROP_ENABLEREPORTID to 0x0"));
            }
            axisdone:;

        } else {                                /* Already acquired */
            hres = DIERR_ACQUIRED;
        }
        CDIDev_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}



#define BEGIN_CONST_DATA data_seg(".text", "CODE")
BYTE c_SemTypeToDFType[8] = { 0, 0,
                              DIDFT_GETTYPE(DIDFT_ABSAXIS), DIDFT_GETTYPE(DIDFT_RELAXIS), 
                              DIDFT_GETTYPE(DIDFT_BUTTON), 0,
                              DIDFT_GETTYPE(DIDFT_POV), 0 };
#define END_CONST_DATA data_seg(".data", "DATA")


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct DEVICETOUSER |
 *
 *          Structure to hold a device to user assignment.
 *
 *  @field  GUID | guidDevice |
 *
 *          The device.
 *
 *  @field  WCHAR | wszOwner[MAX_PATH] |
 *
 *          Name of the user who currently owns the device.
 *
 *****************************************************************************/

typedef struct _DEVICETOUSER
{
    GUID    guidDevice;
    WCHAR   wszOwner[MAX_PATH];
} DEVICETOUSER, *PDEVICETOUSER;

#define DELTA_DTO_COUNT 4



// ISSUE-2001/03/29-MarcAnd CMap usage is inconsistant 
// CMap code should be split out into separate source file


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CMap_SetDeviceUserName |
 *
 *          Set the passed device to be associated with the passed user name.
 *          If the device is already associated with a user or with no user 
 *          that association is replaced with the new one.  If the device is 
 *          not yet in the array, it is added.  Memory is allocated as 
 *          necessary to increase the array size.
 *
 *  @parm   REFGUID | guidDevInst |
 *
 *          A pointer to the device instance GUID to be added/modified.
 *
 *  @parm   LPCWSTR | wszOwner |
 *
 *          A UNICODE user name.
 *
 *  @returns
 *
 *          <c S_OK> if the name was set
 *          <c DI_NOEFFECT> if nothing was set because nothing needed to be
 *          A memory allocation error if such occured.
 *
 *****************************************************************************/
HRESULT CMap_SetDeviceUserName
(
    REFGUID guidDevInst,
    LPCWSTR wszOwner
)
{
    HRESULT         hres = S_OK;
    PDEVICETOUSER   pdto;

    CAssertF( DELTA_DTO_COUNT > 1 );

    AssertF( !IsEqualGUID( guidDevInst, &GUID_Null ) );
    AssertF( !InCrit() );
    DllEnterCrit();

    /*
     *  Note g_pdto will be NULL until the first name is set 
     *  however, g_cdtoMax will be zero so this loop should 
     *  fall through to allocate more memory.
     */
    for( pdto = g_pdto; pdto < &g_pdto[ g_cdtoMax ]; pdto++ )
    {
        if( IsEqualGUID( guidDevInst, &pdto->guidDevice ) )
        {
            break;
        }
    }

    if( !wszOwner )
    {
        if( pdto < &g_pdto[ g_cdtoMax ] )
        {
            ZeroMemory( &pdto->guidDevice, cbX( pdto->guidDevice ) );
            g_cdto--;
            AssertF( g_cdto >= 0 );
        }
        else
        {
            /*
             *  Could not find device, since we were removing, don't worry
             */
            hres = DI_NOEFFECT;
        }
    }
    else
    {
        if( pdto >= &g_pdto[ g_cdtoMax ] )
        {
            /*
             *  Need to add a new entry
             */
            if( g_cdto == g_cdtoMax )
            {
                /*
                 *  If all entries are used try to get more
                 */
                hres = ReallocCbPpv( ( g_cdtoMax + DELTA_DTO_COUNT ) * cbX( *g_pdto ), &g_pdto );
                if( FAILED( hres ) )
                {
                    goto exit_SetDeviceUserName;
                }
                g_cdtoMax += DELTA_DTO_COUNT;
                /*
                 *  The first new element is sure to be free
                 */
                pdto = &g_pdto[ g_cdto ];
            }
            else
            {
                /*
                 *  There's an empty one in the array somewhere
                 */
                for( pdto = g_pdto; pdto < &g_pdto[ g_cdtoMax ]; pdto++ )
                {
                    if( IsEqualGUID( &GUID_Null, &pdto->guidDevice ) )
                    {
                        break;
                    }
                }
            }
            pdto->guidDevice = *guidDevInst;
        }
        g_cdto++;

        AssertF( pdto < &g_pdto[ g_cdtoMax ] );
        AssertF( lstrlenW( wszOwner ) < cbX( pdto->wszOwner ) );

#ifdef WINNT
        lstrcpyW( pdto->wszOwner, wszOwner );
#else
        memcpy( pdto->wszOwner, wszOwner, ( 1 + lstrlenW( wszOwner ) ) * cbX( *wszOwner ) );
#endif
    }

exit_SetDeviceUserName:;
    DllLeaveCrit();

    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CMap_IsNewDeviceUserName |
 *
 *          Searches the array of device to user associations for the passed 
 *          device GUID.  If the device GUID is matched the name is tested 
 *          to see if it is the same as the passed name.
 *
 *  @parm   REFGUID | guidDevInst |
 *
 *          A pointer to the device instance GUID to be tested.
 *
 *  @parm   LPCWSTR | wszOwner |
 *
 *          A UNICODE user name to be tested.
 *
 *  @returns
 *
 *          <c FALSE> if a the device was found and the user matches
 *          <c TRUE> if not
 *
 *****************************************************************************/
HRESULT CMap_IsNewDeviceUserName
(
    REFGUID guidDevInst,
    LPWSTR wszTest
)
{
    BOOL            fres = TRUE;
    PDEVICETOUSER   pdto;

    AssertF( !IsEqualGUID( guidDevInst, &GUID_Null ) );
    AssertF( wszTest != L'\0' );
    AssertF( !InCrit() );

    DllEnterCrit();

    if( g_pdto )
    {
        for( pdto = g_pdto; pdto < &g_pdto[ g_cdtoMax ]; pdto++ )
        {
            if( IsEqualGUID( guidDevInst, &pdto->guidDevice ) )
            {
#ifdef WINNT
                if( !lstrcmpW( wszTest, pdto->wszOwner ) )
#else
                if( ( pdto->wszOwner[0] != L'\0' )
                  &&( !memcmp( wszTest, pdto->wszOwner, 
                           lstrlenW( wszTest ) * cbX( *wszTest ) ) ) )
#endif
                {
                    fres = FALSE;
                }
                break;
            }
        }
    }

    DllLeaveCrit();

    return fres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CMap_GetDeviceUserName |
 *
 *          Searches the array of device to user associations for the passed 
 *          device GUID.  If the device GUID is matched and has an associated 
 *          user name, that is copied into wszOwner.  If the GUID is not 
 *          matched or the match has a NULL string associated with it, 
 *          wszOwner is set to a NULL string.
 *
 *  @parm   REFGUID | guidDevInst |
 *
 *          A pointer to the device instance GUID to be added/modified.
 *
 *  @parm   LPCWSTR | wszOwner |
 *
 *          A UNICODE user name.
 *
 *  @returns
 *
 *          <c S_OK> if a user name has been copied into wszOwner
 *          <c DI_NOEFFECT> if wszOwner has been set to a NULL string
 *
 *****************************************************************************/
HRESULT CMap_GetDeviceUserName
(
    REFGUID guidDevInst,
    LPWSTR wszOwner
)
{
    HRESULT         hres = DI_NOEFFECT;
    PDEVICETOUSER   pdto;

    AssertF( !IsEqualGUID( guidDevInst, &GUID_Null ) );

    AssertF( !InCrit() );

    /*
     *  Assume nothing is found
     */
    wszOwner[0] = L'\0';

    DllEnterCrit();

    if( g_pdto )
    {
        for( pdto = g_pdto; pdto < &g_pdto[ g_cdtoMax ]; pdto++ )
        {
            if( IsEqualGUID( guidDevInst, &pdto->guidDevice ) )
            {
                if( pdto->wszOwner[0] != L'\0' )
                {
#ifdef WINNT
                    lstrcpyW( wszOwner, pdto->wszOwner );
#else
                    memcpy( wszOwner, pdto->wszOwner, 
                        ( 1 + lstrlenW( pdto->wszOwner ) ) * cbX( *wszOwner ) );
#endif
                    hres = S_OK;
                }
                break;
            }
        }
    }

    DllLeaveCrit();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMap | ValidateActionMapSemantics |
 *
 *          Validate the semantics in an action map for overall sanity.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags to modify the validation behavior.
 *          Currently these are the <c DIDBAM_*> flags as the only
 *          <mf IDirectInputDevice::SetActionMap> flag is the default 
 *          <c DIDSAM_DEFAULT>.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *
 *****************************************************************************/

int __stdcall CompareActions
(
    PV pv1,
    PV pv2
)
{
    int iRes;
    LPDIACTION pAct1 = (LPDIACTION)pv1;
    LPDIACTION pAct2 = (LPDIACTION)pv2;

    iRes = memcmp( &pAct1->guidInstance, &pAct2->guidInstance, cbX(pAct1->guidInstance) );

    if( !iRes )
    {
        if( pAct1->dwFlags & DIA_APPMAPPED )
        {
            if( pAct2->dwFlags & DIA_APPMAPPED )
            {
                iRes = pAct1->dwObjID - pAct2->dwObjID;
            }
            else
            {
                iRes = -1;
            }
        }
        else
        {
            if( pAct2->dwFlags & DIA_APPMAPPED )
            {
                iRes = 1;
            }
            else
            {
                iRes = pAct1->dwSemantic - pAct2->dwSemantic;
            }
        }
    }

    return iRes;
}


STDMETHODIMP
CMap_ValidateActionMapSemantics
(
    LPDIACTIONFORMATW   paf,
    DWORD               dwFlags
)
{
    HRESULT     hres;

    LPDIACTIONW pAction;
    LPDIACTIONW *pWorkSpace;
    LPDIACTIONW *pCurr;
    LPDIACTIONW *pLast;

    EnterProcI(IDirectInputDeviceCallback::CMap::ValidateActionMapSemantics,
        (_ "px", paf, dwFlags ));


    /*
     *  Create a pointer array to the actions, sort it then look for duplicates
     */
    if( SUCCEEDED( hres = AllocCbPpv( cbCxX(paf->dwNumActions,PV), &pWorkSpace) ) )
    {
        /*
         *  Fill work space from action array discarding unmappable elements
         */
        pCurr = pWorkSpace;
        for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
        {
            if( dwFlags & ( DIDBAM_INITIALIZE | DIDBAM_HWDEFAULTS ) )
            {
                pAction->dwFlags = 0;
                pAction->guidInstance = GUID_Null;
                pAction->dwHow = 0;
            }
            else
            {
                if( pAction->dwFlags & ~DIA_VALID )
                {
                    RPF( "ERROR Invalid action: rgoAction[%d].dwFlags 0x%08x",
                        pAction - paf->rgoAction, pAction->dwFlags & ~DIA_VALID );
                    pAction->dwHow = DIAH_ERROR;
                    hres = DIERR_INVALIDPARAM;
                    goto free_and_exit;
                }

                if( pAction->dwFlags & DIA_APPNOMAP )
                {
                    continue;
                }

                if( dwFlags & DIDBAM_PRESERVE )
                {
                    switch( pAction->dwHow )
                    {
                    case DIAH_UNMAPPED:
                        break;
                    case DIAH_USERCONFIG:
                    case DIAH_APPREQUESTED:
                    case DIAH_HWAPP:
                    case DIAH_HWDEFAULT:
                    case DIAH_OTHERAPP:
                    case DIAH_DEFAULT:
                        if( IsEqualGUID( &pAction->guidInstance, &GUID_Null ) )
                        {
                            RPF("ERROR Invalid action: rgoAction[%d].dwHow is mapped as 0x%08x but has no device", 
                                pAction - paf->rgoAction, pAction->dwHow );
                            hres = DIERR_INVALIDPARAM;
                            goto free_and_exit;
                        }
                        break;
                    case DIAH_ERROR:
                        RPF("ERROR Invalid action: rgoAction[%d].dwHow has DIAH_ERROR", 
                            pAction - paf->rgoAction );
                        hres = DIERR_INVALIDPARAM;
                        goto free_and_exit;
                    default:
                        if( pAction->dwHow & ~DIAH_VALID )
                        {
                            RPF("ERROR Invalid action: rgoAction[%d].dwHow has invalid flags 0x%08x", 
                                pAction - paf->rgoAction, pAction->dwHow & ~DIAH_VALID );
                        }
                        else
                        {
                            RPF("ERROR Invalid action: rgoAction[%d].dwHow has invalid combination of map flags 0x%08x", 
                                pAction - paf->rgoAction, pAction->dwHow & ~DIAH_VALID );
                        }
                        pAction->dwHow = DIAH_ERROR;
                        hres = DIERR_INVALIDPARAM;
                        goto free_and_exit;
                    }
                }
                else
                {
                    if(!( pAction->dwFlags & DIA_APPMAPPED ) )
                    {
                        pAction->guidInstance = GUID_Null;
                    }
                    pAction->dwHow = 0;
                }
            }

            if( ( pAction->dwSemantic ^ paf->dwGenre ) & DISEM_GENRE_MASK )
            {
                switch( DISEM_GENRE_GET( pAction->dwSemantic ) )
                {
                case DISEM_GENRE_GET( DIPHYSICAL_KEYBOARD ):
                case DISEM_GENRE_GET( DIPHYSICAL_MOUSE ):
                case DISEM_GENRE_GET( DIPHYSICAL_VOICE ):
                case DISEM_GENRE_GET( DISEMGENRE_ANY ):
                    break;
                default:
                    RPF("ERROR Invalid action: rgoAction[%d].dwSemantic 0x%08x for genre 0x%08x", 
                        pAction - paf->rgoAction, pAction->dwSemantic, paf->dwGenre  );
                    pAction->dwHow = DIAH_ERROR;
                    hres = DIERR_INVALIDPARAM;
                    goto free_and_exit;
                }
            }

            /*
             *  Note, the SEM_FLAGS are not tested, this is only to save time 
             *  as nothing depends upon their value.  This could be added.
             *  Semantic index 0xFF used to mean ANY so don't allow it any more
             */
            if(!( pAction->dwFlags & DIA_APPMAPPED )
             && ( ( pAction->dwSemantic & ~DISEM_VALID )
               || ( DISEM_INDEX_GET( pAction->dwSemantic ) == 0xFF )
               ||!c_SemTypeToDFType[ DISEM_TYPEANDMODE_GET( pAction->dwSemantic ) ] ) )
            {
                RPF("ERROR Invalid action: rgoAction[%d].dwSemantic 0x%08x is invalid", 
                    pAction - paf->rgoAction, pAction->dwSemantic  );
                pAction->dwHow = DIAH_ERROR;
                hres = DIERR_INVALIDPARAM;
                goto free_and_exit;
            }

                
            *pCurr = pAction;
            pCurr++;
        }
        if( pCurr == pWorkSpace )
        {
            SquirtSqflPtszV(sqflDf | sqflBenign,
                TEXT("Action map contains no mappable actions") );
            hres = S_FALSE;
        }
        else
        {
            hres = S_OK;

            pLast = pCurr - 1;

            ptrPartialQSort( (PV)pWorkSpace, (PV)pLast, &CompareActions );
            ptrInsertSort( (PV)pWorkSpace, (PV)pLast, &CompareActions );


            /*
             *  Now we have an ordered list, see there are duplicate actions.
             */

            for( pCurr = pWorkSpace + 1; pCurr <= pLast; pCurr++ )
            {
                if( !CompareActions( *(pCurr-1), *pCurr ) 
                 && !( (*pCurr)->dwFlags & DIA_APPMAPPED ) ) 
                {
                    RPF( "ERROR Invalid DIACTIONFORMAT: rgoAction contains duplicates" );
                    hres = DIERR_INVALIDPARAM;
#ifndef XDEBUG
                    /*
                     *  In retail, any bad is bad.  In debug report how bad.
                     */
                    break;
#else
                    SquirtSqflPtszV(sqflDf | sqflError,
                        TEXT("Actions %d and %d are the same"),
                        *(pCurr-1) - paf->rgoAction, *pCurr - paf->rgoAction );
#endif

                }
            }
        }

free_and_exit:;
        FreePv( pWorkSpace );
    }

    ExitOleProcR();
    return hres;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CMap_TestSysObject |
 *
 *          Test the passed object to see if it is a reasonable thing to exist 
 *          on a mouse or keyboard depending on the physical genre.
 *
 *  @parm   DWORD | dwPhysicalGenre |
 *
 *          Mouse, keyboard or voice as DIPHYSICAL_*
 *
 *  @parm   DWORD | dwObject |
 *
 *          The object in question
 *
 *  @returns
 *
 *          <c S_OK> if the object could be expected on the class of device
 *          or <c DIERR_INVALIDPARAM> if not
 *
 *****************************************************************************/
HRESULT CMap_TestSysObject
(
    DWORD dwPhysicalGenre,
    DWORD dwObject
)
{
    HRESULT hres = S_OK;

    if( dwPhysicalGenre == DIPHYSICAL_KEYBOARD )
    {
        /*
         *  Anything but a button with an 8 bit offset is invalid.
         */
        if( ( dwObject & DIDFT_BUTTON )
         && ( ( DIDFT_GETINSTANCE( dwObject ) & 0xFF00 ) == 0 ) )
        {
            SquirtSqflPtszV(sqflDf | sqflBenign,
                            TEXT("Key 0x%02 not defined on this keyboard (id)"),
                            dwObject );
        }
        else
        {
            SquirtSqflPtszV(sqflDf | sqflError,
                            TEXT("Object type 0x%08 invalid for keyboard (id)"),
                            dwObject );
            hres = DIERR_INVALIDPARAM;
        }
    }
    else if( dwPhysicalGenre == DIPHYSICAL_MOUSE )
    {
        /*
         *  Allow buttons 1 to 8 and axes 1 to 3
         */
        if( ( dwObject & DIDFT_PSHBUTTON )
         && ( DIDFT_GETINSTANCE( dwObject ) < 8 ) )
        {
            SquirtSqflPtszV(sqflDf | sqflBenign,
                            TEXT("Button %d not defined on this mouse (id)"),
                            DIDFT_GETINSTANCE( dwObject ) );
        }
        else if( ( dwObject & DIDFT_AXIS )
         && ( DIDFT_GETINSTANCE( dwObject ) < 3 ) )
        {
            SquirtSqflPtszV(sqflDf | sqflBenign,
                            TEXT("Axis %d not defined on this mouse (id)"),
                            DIDFT_GETINSTANCE( dwObject ) );
        }
        else
        {
            SquirtSqflPtszV(sqflDf | sqflError,
                            TEXT("Bad control object 0x%08x for mouse (id)"),
                            dwObject );
            hres = DIERR_INVALIDPARAM;
        }
    }
    else if( dwPhysicalGenre == DIPHYSICAL_VOICE )
    {
        if( dwObject & DIDFT_PSHBUTTON )
        {
            switch( DIDFT_GETINSTANCE( dwObject ) )
            {
            case DIVOICE_CHANNEL1:
            case DIVOICE_CHANNEL2:
            case DIVOICE_CHANNEL3:
            case DIVOICE_CHANNEL4:
            case DIVOICE_CHANNEL5:
            case DIVOICE_CHANNEL6:
            case DIVOICE_CHANNEL7:
            case DIVOICE_CHANNEL8:
            case DIVOICE_TEAM:
            case DIVOICE_ALL:
            case DIVOICE_RECORDMUTE:
            case DIVOICE_PLAYBACKMUTE:
            case DIVOICE_TRANSMIT:
            case DIVOICE_VOICECOMMAND:
                SquirtSqflPtszV(sqflDf | sqflBenign,
                                TEXT("Button %d not defined on this comms device (id)"),
                                DIDFT_GETINSTANCE( dwObject ) );
                break;
            default:
                SquirtSqflPtszV(sqflDf | sqflError,
                                TEXT("Bad control object 0x%08x for comms device (id)"),
                                dwObject );
                hres = DIERR_INVALIDPARAM;
            }
        }
        else
        {
            SquirtSqflPtszV(sqflDf | sqflError,
                            TEXT("Comms control object 0x%08x not a button (id)"),
                            dwObject );
            hres = DIERR_INVALIDPARAM;
        }
    }
    else
    {
        AssertF( !"Physical genre not keyboard, mouse or voice (id)" );
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CMap_TestSysOffset |
 *
 *          Test the passed offset to see if it is a reasonable one for the 
 *          default data format of the physical genre.
 *
 *  @parm   DWORD | dwPhysicalGenre |
 *
 *          Mouse, keyboard or voice as DIPHYSICAL_*
 *
 *  @parm   DWORD | dwOffset |
 *
 *          The offset in question
 *
 *  @returns
 *
 *          <c S_OK> if the offset could be expected on the class of device
 *          or <c DIERR_INVALIDPARAM> if not
 *
 *****************************************************************************/
HRESULT CMap_TestSysOffset
(
    DWORD dwPhysicalGenre,
    DWORD dwOffset
)
{
    HRESULT hres = S_OK;

    if( dwPhysicalGenre == DIPHYSICAL_KEYBOARD )
    {
        /*
         *  Anything but a button with an 8 bit offset is invalid.
         */
        if( dwOffset <= 0xFF )
        {
            SquirtSqflPtszV(sqflDf | sqflBenign,
                            TEXT("Key 0x%02 not defined on this keyboard (ofs)"),
                            dwOffset );
        }
        else
        {
            SquirtSqflPtszV(sqflDf | sqflError,
                            TEXT("Key offset 0x%08 invalid for keyboard (ofs)"),
                            dwOffset );
            hres = DIERR_INVALIDPARAM;
        }
    }
    else if( dwPhysicalGenre == DIPHYSICAL_MOUSE )
    {
        CAssertF( DIMOFS_X == 0 );

        if( dwOffset > DIMOFS_BUTTON7 )
        {
            SquirtSqflPtszV(sqflDf | sqflError,
                            TEXT("Bad control offset 0x%08x for mouse (ofs)"),
                            dwOffset );
            hres = DIERR_INVALIDPARAM;
        }
        else
        {
            /*
             *  Allow buttons 1 to 8
             */
            if( dwOffset >= DIMOFS_BUTTON0 )
            {
                SquirtSqflPtszV(sqflDf | sqflBenign,
                                TEXT("Button %d not defined on this mouse (ofs)"),
                                dwOffset - DIMOFS_BUTTON0 );
            }
            else
            {
                SquirtSqflPtszV(sqflDf | sqflBenign,
                                TEXT("Axis %d not defined on this mouse (ofs)"),
                                (dwOffset - DIMOFS_X)>>2 );
            }
        }
    }
    else
    {
        AssertF( !"Physical genre not keyboard, mouse or voice" );
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMap | DeviceValidateActionMap |
 *
 *          Validate an action map for a device.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwDevGenre |
 *
 *          Device genre to match or zero for device that are not physical
 *          devices.
 *
 *  @parm   REFGUID | guidInstace |
 *
 *          Instance guid of device to match.
 *
 *  @parm   LPCDIDATAFORMAT | dfDev |
 *
 *          Ponter to device data format.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          A valid combination of <c DVAM_*> flags to describe optional 
 *          validation behavior.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *
 *****************************************************************************/

#define DVAM_DEFAULT            0x00000000
#define DVAM_GETEXACTMAPPINGS   0x00000001

STDMETHODIMP
CMap_DeviceValidateActionMap
(
    PV                  pdd,
    LPDIACTIONFORMATW   paf,
    DWORD               dwFlags,
    PDWORD              pdwOut
)
{
    HRESULT         hres;
    LPDIDATAFORMAT  dfDev;
    DWORD           dwPhysicalGenre;
    LPDIACTIONW     pAction;
    PBYTE           pMatch;
    UINT            idxObj;
    BOOL            bHasMap = FALSE;
    BOOL            bNewMap = FALSE;
    DWORD           dwCommsType = 0;
    PDD             this;

    EnterProcI(IDirectInputDeviceCallback::CMap::DeviceValidateActionMap,
        (_ "ppx", pdd, paf, dwFlags));

    
    this = _thisPv(pdd);
    
    /*
     *  Note, hres is tested before anything is done with dwPhysicalGenre
     */

    switch( GET_DIDEVICE_TYPE(this->dc3.dwDevType) )
    {
    case DI8DEVTYPE_MOUSE:
        dwPhysicalGenre = DIPHYSICAL_MOUSE;
        break;
    case DI8DEVTYPE_KEYBOARD:
        dwPhysicalGenre = DIPHYSICAL_KEYBOARD;
        break;
    case DI8DEVTYPE_DEVICECTRL:
        if( ( GET_DIDEVICE_SUBTYPE( this->dc3.dwDevType ) == DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED ) 
         || ( GET_DIDEVICE_SUBTYPE( this->dc3.dwDevType ) == DI8DEVTYPEDEVICECTRL_COMMSSELECTION ) )
        {
            dwCommsType = GET_DIDEVICE_SUBTYPE( this->dc3.dwDevType );
            dwPhysicalGenre = DIPHYSICAL_VOICE;
        }
        else
        {
            dwPhysicalGenre = 0;
        }
        break;
    default:
        dwPhysicalGenre = 0;
        break;
    }

    if( SUCCEEDED( hres = this->pdcb->lpVtbl->GetDataFormat(this->pdcb, &dfDev) )
     && SUCCEEDED( hres = AllocCbPpv( dfDev->dwNumObjs, &pMatch) ) )
    {
        enum eMap
        {
            eMapTestMatches,
            eMapDeviceExact,
            eMapClassExact,
            eMapEnd
        }           iMap, ValidationLimit;

        /*
         *  Set the limit on iterations depending on the checks required
         */
        ValidationLimit = ( dwFlags & DVAM_GETEXACTMAPPINGS )
                        ? ( dwPhysicalGenre ) ? eMapClassExact : eMapDeviceExact
                        : eMapTestMatches;

        for( iMap = eMapTestMatches; SUCCEEDED( hres ) && ( iMap <= ValidationLimit ); iMap++ )
        {
            for( pAction = paf->rgoAction;
                 SUCCEEDED( hres ) && ( pAction < &paf->rgoAction[paf->dwNumActions] );
                 pAction++ )
            {
                DWORD dwObject;

                if( pAction->dwFlags & DIA_APPNOMAP )
                {
                    continue;
                }

                /*
                 *  If we are mapping exact matches this time, only care 
                 *  about unmapped actions with app mappings.
                 */
                if( ( iMap != eMapTestMatches )
                 && (!( pAction->dwFlags & DIA_APPMAPPED )
                   || ( pAction->dwHow & DIAH_MAPMASK ) ) )
                {
                    continue;
                }

                switch( iMap )
                {
                case eMapTestMatches:
                    /*
                     *  These flags have already been validated during semantic
                     *  validation so just assert them on the first iteration.
                     */
                    AssertF( ( pAction->dwHow & ~DIAH_VALID ) == 0 );
                    AssertF( ( pAction->dwHow & DIAH_ERROR ) == 0 );
                    AssertF( ( pAction->dwFlags & ~DIA_VALID ) == 0 );

                    /*
                     *  Only care about pre-existing matches
                     */
                    if( !( pAction->dwHow & DIAH_MAPMASK ) )
                    {
                        continue;
                    }

                    /*
                     *  Fall through for a GUID match
                     */
                case eMapDeviceExact:
                    if( !IsEqualGUID( &pAction->guidInstance, &this->guid ) )
                    {
                        continue;
                    }
                    break;

                case eMapClassExact:
                    if( ( DISEM_GENRE_GET( pAction->dwSemantic ) != DISEM_GENRE_GET( dwPhysicalGenre ) ) )
                    {
                        continue;
                    }
                    break;

                default:
                    AssertF( !"Invalid iMap" );
                }

                if( ( iMap != eMapTestMatches )
                 && ( dwCommsType == DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED ) )
                {
                    if( !( pAction->dwHow & DIAH_MAPMASK ) )
                    {
                        RPF( "ERROR: rgoAction[%d] is trying to map on a hardwired device", pAction - paf->rgoAction );
                        hres = DIERR_INVALIDPARAM;
                    }
                    else if( pAction->dwFlags & DIA_APPMAPPED )
                    {
                        RPF( "ERROR: rgoAction[%d] is trying to app map on a hardwired device", pAction - paf->rgoAction );
                        hres = DIERR_INVALIDPARAM;
                    }
                }
                else
                {
                    dwObject = pAction->dwObjID;

                    /*
                     *  Now try to find the object.
                     *  Note, we can't rely on the application data format goo
                     *  because a data format has probably not been set.
                     */
                    for( idxObj = 0; idxObj < dfDev->dwNumObjs; idxObj++ )
                    {
                        /*
                         *  Ignore FF flags so a FF device can be matched for non-FF
                         */
                        if( ( ( dwObject ^ dfDev->rgodf[idxObj].dwType ) 
                            &~( DIDFT_FFACTUATOR | DIDFT_FFEFFECTTRIGGER ) ) == 0 )
                        {
                            break;
                        }
                    }

                    if( idxObj < dfDev->dwNumObjs )
                    {
                        /*
                         *  Application mapped controls don't need to have 
                         *  semantics so we cannot test them.
                         */
                        if( pAction->dwFlags & DIA_APPMAPPED )
                        {
                            if( pMatch[idxObj] )
                            {
                                RPF( "ERROR: rgoAction[%d] maps to control 0x%08x which is already mapped",
                                    pAction - paf->rgoAction, pAction->dwObjID );
                                hres = DIERR_INVALIDPARAM;
                                break;
                            }
                            else
                            {
                                if(!( pAction->dwFlags & DIA_FORCEFEEDBACK )
                                 || ( dfDev->rgodf[idxObj].dwType & ( DIDFT_FFACTUATOR | DIDFT_FFEFFECTTRIGGER ) ) )
                                {
                                    pMatch[idxObj] = TRUE;

                                    SquirtSqflPtszV(sqflDf | sqflVerbose,
                                        TEXT("rgoAction[%d] application mapped to object 0x%08x"),
                                        pAction - paf->rgoAction, dwObject );

                                    bHasMap = TRUE;
                                    if( iMap != eMapTestMatches )
                                    {
                                        bNewMap = TRUE;
                                        pAction->dwHow = DIAH_APPREQUESTED;
                                        pAction->dwObjID = dwObject;
                                        if( iMap == eMapClassExact )
                                        {
                                            pAction->guidInstance = this->guid;
                                        }
                                    }
                                }
                                else
                                {
                                    RPF( "ERROR: rgoAction[%d] need force feedback but object 0x%08x has none",
                                        pAction - paf->rgoAction, dwObject );
                                    hres = DIERR_INVALIDPARAM;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            AssertF( iMap == eMapTestMatches );
                            /*
                             *  Check the object type matches the semantic
                             */
                            if( ( c_SemTypeToDFType[ DISEM_TYPEANDMODE_GET( pAction->dwSemantic ) ]
                                & DIDFT_GETTYPE( dwObject ) ) )
                            {
                                if( pMatch[idxObj] )
                                {
                                    RPF( "ERROR: rgoAction[%d] pre-mapped to control 0x%08x which is already mapped",
                                        pAction - paf->rgoAction, pAction->dwObjID );
                                    hres = DIERR_INVALIDPARAM;
                                    break;
                                }
                                else
                                {
                                    pMatch[idxObj] = TRUE;
                                    bHasMap = TRUE;

                                    SquirtSqflPtszV(sqflDf | sqflVerbose,
                                        TEXT("rgoAction[%d] mapping verifed to object 0x%08x"),
                                        pAction - paf->rgoAction, dwObject );

                                    continue;
                                }
                            }
                            else
                            {
                                RPF( "ERROR: rgoAction[%d] has object type 0x%08x but semantic type 0x%08x",
                                    pAction - paf->rgoAction, DIDFT_GETTYPE( dwObject ),
                                    c_SemTypeToDFType[ DISEM_TYPEANDMODE_GET( pAction->dwSemantic ) ] );
                                hres = DIERR_INVALIDPARAM;
                                break;
                            }
                        }
                    }
                    else
                    {
                        switch( iMap )
                        {
                        case eMapTestMatches:
                            RPF( "ERROR: rgoAction[%d] was mapped (how:0x%08x) to undefined object 0x%08x",
                                pAction - paf->rgoAction, pAction->dwHow, pAction->dwObjID );
                            hres = DIERR_INVALIDPARAM;
                            break;

                        case eMapDeviceExact:
                            RPF( "ERROR: rgoAction[%d] has application map to undefined object 0x%08x",
                                pAction - paf->rgoAction, pAction->dwObjID );
                            hres = DIERR_INVALIDPARAM;
                            break;

                        case eMapClassExact:
                            /*
                             *  If a device class was specified and no match was
                             *  found it is only an error if the object is
                             *  invalid for the class.
                             */
                            hres = CMap_TestSysObject( dwPhysicalGenre, pAction->dwObjID );
                            if( FAILED( hres ) )
                            {
                                RPF( "ERROR: rgoAction[%d] was mapped to object 0x%08x, not valid for device",
                                    pAction - paf->rgoAction, pAction->dwObjID );
                            }
                            else
                            {
                                continue; /* Don't break the loop */
                            }
                        }
                        break;
                    }
                }
            }

            if( FAILED( hres ) )
            {
                pAction->dwHow = DIAH_ERROR;
                AssertF( hres == DIERR_INVALIDPARAM );
                break;
            }
        }

        FreePv( pMatch );
    }

    if( SUCCEEDED( hres ) )
    {
        AssertF( hres == S_OK );
        if( dwCommsType == DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED )
        {
            hres = DI_WRITEPROTECT;
        }
        else if(dwFlags == DVAM_DEFAULT)
        {
            //in default case we want to know if there are ANY mappings
            if (!bHasMap)
               hres = DI_NOEFFECT;
        }
        else if(!bNewMap)
        {
            //in non-default case we are interested in ANY NEW mappings
            hres = DI_NOEFFECT; 
        }
    }

    *pdwOut = dwCommsType; 

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMap | BuildDefaultDevActionMap |
 *
 *          Get default action map from the action format non system devices.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInstace |
 *
 *          Instance guid of device to match.
 *
 *  @parm   PDIDOBJDEFSEM | rgObjSem |
 *
 *          Array of default device object to semantic mappings.
 *
 *  @parm   DWORD | dwNumAxes |
 *
 *          Number of axes in the rgObjSem.
 *
 *  @parm   DWORD | dwNumPOVs |
 *
 *          Number of POVs in the rgObjSem.
 *
 *  @parm   DWORD | dwNumAxes |
 *
 *          Number of buttons in the rgObjSem.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *
 *****************************************************************************/
STDMETHODIMP CMap_BuildDefaultDevActionMap
(
    LPDIACTIONFORMATW paf,
    DWORD dwFlags,
    REFGUID guidDevInst, 
    PDIDOBJDEFSEM rgObjSem,
    DWORD dwNumAxes,
    DWORD dwNumPOVs,
    DWORD dwNumButtons
)
{
#define IS_OBJECT_USED( dwSem ) ( DISEM_RES_GET( dwSem ) )
#define MARK_OBJECT_AS_USED( dwSem ) ( dwSem |= DISEM_RES_SET( 1 ) )

    HRESULT         hres = S_OK;

    BOOL            fSomethingMapped = FALSE;

    PDIDOBJDEFSEM   pSemNextPOV;
    PDIDOBJDEFSEM   pSemButtons;
    LPDIACTIONW     pAction;

    enum eMap
    {
        eMapDeviceSemantic,
        eMapDeviceCompat,
        eMapGenericSemantic,
        eMapGenericCompat,
        eMapEnd
    }           iMap;

    EnterProcI(IDirectInputDeviceCallback::CMap::BuildDefaultDevActionMap,
        (_ "pxGpxxx", paf, dwFlags, guidDevInst,
        rgObjSem, dwNumAxes, dwNumPOVs, dwNumButtons ));

    pSemNextPOV = &rgObjSem[dwNumAxes];
    pSemButtons = &rgObjSem[dwNumAxes+dwNumPOVs];

    /*
     *  Make an initial pass through to mark already mapped actions
     */
    for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
    {
        PDIDOBJDEFSEM   pSemExact;

        /*
         *  These flags have already been validated during semantic validation,
         */
        AssertF( ( pAction->dwHow & ~DIAH_VALID ) == 0 );
        AssertF( ( pAction->dwHow & DIAH_ERROR ) == 0 );
        AssertF( ( pAction->dwFlags & ~DIA_VALID ) == 0 );

        if( ( pAction->dwFlags & DIA_APPNOMAP )
         ||!( pAction->dwHow & DIAH_MAPMASK )
         ||!IsEqualGUID( &pAction->guidInstance, guidDevInst ) )
        {
            continue;
        }

        /*
         *  This object has already been validated so mark it as
         *  in use so we don't try to reuse it.
         *  No errors should be detected here so use asserts not retail tests
         */
        AssertF( pAction->dwObjID != 0xFFFFFFFF );

        /*
         *  Find the object
         */
        for( pSemExact = rgObjSem;
             pSemExact < &rgObjSem[dwNumAxes+dwNumPOVs+dwNumButtons];
             pSemExact++ )
        {
            if( ( ( pSemExact->dwID ^ pAction->dwObjID ) 
                &~( DIDFT_FFACTUATOR | DIDFT_FFEFFECTTRIGGER ) ) == 0 )
            {
                AssertF( !IS_OBJECT_USED( pSemExact->dwSemantic ) );
                AssertF( DISEM_TYPE_GET( pAction->dwSemantic )
                      == DISEM_TYPE_GET( pSemExact->dwSemantic ) );
                MARK_OBJECT_AS_USED( pSemExact->dwSemantic );
                break;
            }
        }

        /*
         *  ISSUE-2001/03/29-timgill There should always be an exact action match
         *  May need to use tests for duplicates and unmatched controls
         */
        AssertF( pSemExact < &rgObjSem[dwNumAxes+dwNumPOVs+dwNumButtons] );
    }


    for( iMap=0; iMap<eMapEnd; iMap++ )
    {
        for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
        {
            /*
             *  Do trivial tests first
             */
            if( pAction->dwHow & DIAH_MAPMASK )
            {
                continue;
            }

            if( pAction->dwFlags & DIA_APPNOMAP )
            {
                continue;
            }

            switch( iMap )
            {
            case eMapDeviceSemantic:
            case eMapGenericSemantic:
                if( DISEM_GENRE_GET( pAction->dwSemantic ) == DISEM_GENRE_GET( DISEMGENRE_ANY ) )
                {
                    continue; /* No semantic mapping requested */
                }
                if( ( DISEM_TYPE_GET( pAction->dwSemantic ) == DISEM_TYPE_GET( DISEM_TYPE_BUTTON ) )
                 && ( DISEM_FLAGS_GET( pAction->dwSemantic ) != 0 ) )
                {
                    continue; /* Don't touch link buttons now */
                }
                break;
                
            case eMapDeviceCompat:
            case eMapGenericCompat:
                if( ( DISEM_GENRE_GET( pAction->dwSemantic ) != DISEM_GENRE_GET( DISEMGENRE_ANY ) )
                 && ( DISEM_TYPE_GET( pAction->dwSemantic ) == DISEM_TYPE_GET( DISEM_TYPE_AXIS ) ) )
                {
                    continue; /* No generic mapping requested or taken by default */
                }
                break;
            }


            /*
             *  Next test that this device suits this action (for this pass)
             */
            if( iMap <= eMapDeviceCompat )
            {
                if( !IsEqualGUID( &pAction->guidInstance, guidDevInst ) )
                {
                    continue;
                }
            }
            else if( !IsEqualGUID( &pAction->guidInstance, &GUID_Null) )
            {
                continue;
            }
            else if( ( DISEM_GENRE_GET( pAction->dwSemantic ) == DISEM_GENRE_GET( DIPHYSICAL_MOUSE ) )
                  || ( DISEM_GENRE_GET( pAction->dwSemantic ) == DISEM_GENRE_GET( DIPHYSICAL_KEYBOARD ) )
                  || ( DISEM_GENRE_GET( pAction->dwSemantic ) == DISEM_GENRE_GET( DIPHYSICAL_VOICE ) ) )
            {
                continue;
            }


            /*
             *  Only actions which may be matched on this device get this far.
             */
            switch( iMap )
            {
            case eMapDeviceSemantic:
            case eMapGenericSemantic:
                /*
                 *  See if a matching control is available.
                 */
                switch( DISEM_TYPE_GET( pAction->dwSemantic ) )
                {
                case DISEM_TYPE_GET( DISEM_TYPE_AXIS ):
                {
                    DWORD dwAxisType = DISEM_FLAGS_GET( pAction->dwSemantic );
                    DWORD dwSemObjType;
                    UINT  uAxisIdx;

                    /*
                     *  Set up a mask of the type of object we need to find
                     */
                    dwSemObjType = c_SemTypeToDFType[ DISEM_TYPEANDMODE_GET( pAction->dwSemantic ) ];
                    if( pAction->dwFlags & DIA_FORCEFEEDBACK )
                    {
                        dwSemObjType |= DIDFT_FFACTUATOR;
                    }

                    for( uAxisIdx = 0; uAxisIdx < dwNumAxes; uAxisIdx++ )
                    {
                        if( ( dwAxisType == DISEM_FLAGS_GET( rgObjSem[uAxisIdx].dwSemantic ) )
                         && ( ( dwSemObjType & rgObjSem[uAxisIdx].dwID ) == dwSemObjType )
                         && ( !IS_OBJECT_USED( rgObjSem[uAxisIdx].dwSemantic ) ) )
                        {
                            pAction->dwObjID = rgObjSem[uAxisIdx].dwID;
                            MARK_OBJECT_AS_USED( rgObjSem[uAxisIdx].dwSemantic );
                            break;
                        }
                    }
                    if( uAxisIdx >= dwNumAxes )
                    {
                        continue; /* No matching left */
                    }
                    break;
                }

                case DISEM_TYPE_GET( DISEM_TYPE_POV ):
                    /*  
                     *  Note, no control of POV ordering 
                     */
                    if( ( pSemNextPOV < pSemButtons )
                     &&!( pAction->dwFlags & DIA_FORCEFEEDBACK ) )
                    {
                        pAction->dwObjID = pSemNextPOV->dwID;
                        MARK_OBJECT_AS_USED( pSemNextPOV->dwSemantic );
                        pSemNextPOV++;
                    }
                    else
                    {
                        if( pAction->dwFlags & DIA_FORCEFEEDBACK )
                        {
                            SquirtSqflPtszV(sqflDf | sqflBenign,
                                TEXT( "Not mapping force feedback semantic hat switch (huh?), rgoAction[%d]"),
                                pAction - paf->rgoAction );
                        }
                        continue; /* None left */
                    }
                    break;

                case DISEM_TYPE_GET( DISEM_TYPE_BUTTON ):
                {
                    DWORD dwButtonIdx;
                    dwButtonIdx = DISEM_INDEX_GET( pAction->dwSemantic );
                    if( dwButtonIdx >= DIAS_INDEX_SPECIAL )
                    {
                        /*
                         *  0xFF used to mean DIBUTTON_ANY.
                         *  To avoid changing other special indices, still 
                         *  use 0xFF as the base number.
                         */
                        dwButtonIdx = dwNumButtons - ( 0xFF - dwButtonIdx );
                    }
                    else
                    {
                        dwButtonIdx--;
                    }
                    if( ( dwButtonIdx >= dwNumButtons )
                     || ( IS_OBJECT_USED( pSemButtons[dwButtonIdx].dwSemantic ) ) 
                     || ( ( pAction->dwFlags & DIA_FORCEFEEDBACK ) 
                       &&!( pSemButtons[dwButtonIdx].dwID & DIDFT_FFEFFECTTRIGGER ) ) )
                    {
                        continue; /* No match, no harm */
                    }
                    else
                    {
                        pAction->dwObjID = pSemButtons[dwButtonIdx].dwID;
                        MARK_OBJECT_AS_USED( pSemButtons[dwButtonIdx].dwSemantic );
                    }
                    break;
                }

                default:
                    RPF( "ERROR Invalid action: rgoAction[%d].dwSemantic 0x%08x",
                        pAction - paf->rgoAction, pAction->dwSemantic );
                    pAction->dwHow = DIAH_ERROR;
                    hres = DIERR_INVALIDPARAM;
                    goto error_exit;
                }
                pAction->dwHow = DIAH_DEFAULT;
                break;

            case eMapDeviceCompat:
            case eMapGenericCompat:

                if( ( DISEM_TYPE_GET( pAction->dwSemantic ) == DISEM_TYPE_GET( DISEM_TYPE_BUTTON ) )
                 && ( DISEM_FLAGS_GET( pAction->dwSemantic ) != 0 ) )
                {
                    LPDIACTIONW     pActionTest;
                    PDIDOBJDEFSEM   pSemTest;
                    DWORD           dwSemMask;

                    /*
                     *  See if the axis or POV has been mapped
                     *  Note, there may be no linked object
                     */
                    if( ( pAction->dwSemantic & DISEM_FLAGS_MASK ) == DISEM_FLAGS_P )
                    {
                        dwSemMask = DISEM_GROUP_MASK;
                    }
                    else
                    {
                        dwSemMask = ( DISEM_FLAGS_MASK | DISEM_GROUP_MASK );
                    }

                    for( pActionTest = paf->rgoAction; pActionTest < &paf->rgoAction[paf->dwNumActions]; pActionTest++ )
                    {
                        /*
                         *  Find the axis or POV for which this button is a fallback
                         *  Ignore buttons as they are just other fallbacks for the same action
                         *  Don't do fallbacks for ANY* axes or POVs.
                         */
                        if( ( DISEM_TYPE_GET( pActionTest->dwSemantic ) != DISEM_TYPE_GET( DISEM_TYPE_BUTTON ) )
                         && ( DISEM_GENRE_GET( pAction->dwSemantic ) != DISEM_GENRE_GET( DISEMGENRE_ANY ) )
                         && ( ( ( pActionTest->dwSemantic ^ pAction->dwSemantic ) & dwSemMask ) == 0 ) )
                        {
                            break;
                        }
                    }

                    if( ( pActionTest < &paf->rgoAction[paf->dwNumActions] )
                     && ( pActionTest->dwHow & DIAH_MAPMASK ) )
                    {
                        continue; /* Don't need a fallback */
                    }

                    /*
                     *  Find a button
                     */
                    for( pSemTest = pSemButtons; pSemTest < &pSemButtons[dwNumButtons]; pSemTest++ )
                    {
                        if( !IS_OBJECT_USED( pSemTest->dwSemantic ) )
                        {
                            if( ( pAction->dwFlags & DIA_FORCEFEEDBACK )
                             &&!( pSemTest->dwID & DIDFT_FFEFFECTTRIGGER ) )
                            {
                                continue;
                            }

                            pAction->dwObjID = pSemTest->dwID;
                            MARK_OBJECT_AS_USED( pSemTest->dwSemantic );
                            break;
                        }
                    }

                    if( pSemTest == &pSemButtons[dwNumButtons] )
                    {
                        continue; /* None left */
                    }

                    pAction->dwHow = DIAH_DEFAULT;
                }
                else
                {
                    PDIDOBJDEFSEM   pSemTest;
                    PDIDOBJDEFSEM   pSemBound;
                    int             iDirection = 1;
                    DWORD           dwSemObjType;

                    /*
                     *  Set up a mask of the type of object we need to find to 
                     *  filter out axes of the wrong mode and non-FF if needed
                     */
                    dwSemObjType = c_SemTypeToDFType[ DISEM_TYPEANDMODE_GET( pAction->dwSemantic ) ];
                    if( pAction->dwFlags & DIA_FORCEFEEDBACK )
                    {
                        dwSemObjType |= DIDFT_FFACTUATOR | DIDFT_FFEFFECTTRIGGER;
                    }

                    /*
                     *  Search the available controls for a match
                     */
                    switch( DISEM_TYPE_GET( pAction->dwSemantic ) )
                    {
                    case DISEM_TYPE_GET( DISEM_TYPE_AXIS ):
                        pSemTest = rgObjSem;
                        pSemBound = &rgObjSem[dwNumAxes];
                        /*
                         *  Filter out axes of the wrong mode and FF caps
                         */
                        dwSemObjType &= DIDFT_FFACTUATOR | DIDFT_AXIS;
                        break;

                    case DISEM_TYPE_GET( DISEM_TYPE_POV ):
                        if( pAction->dwFlags & DIA_FORCEFEEDBACK )
                        {
                            SquirtSqflPtszV(sqflDf | sqflBenign,
                                TEXT( "Not mapping force feedback compatible hat switch (huh?), rgoAction[%d]"),
                                pAction - paf->rgoAction );
                            continue;
                        }
                        pSemTest = pSemNextPOV;
                        pSemBound = pSemButtons;
                        /*
                         *  Don't filter POVs any more
                         */
                        dwSemObjType = 0;
                        break;

                    case DISEM_TYPE_GET( DISEM_TYPE_BUTTON ):
                        /*
                         *  Note a DIBUTTON_ANY with instance DIAS_INDEX_SPECIAL 
                         *  or greater can be mapped from the end.
                         */
                        if( DISEM_INDEX_GET( pAction->dwSemantic ) >= DIAS_INDEX_SPECIAL )
                        {
                            /*
                             *  For buttons selected from the end, find the last available
                             */
                            iDirection = -1;
                            pSemTest = &rgObjSem[dwNumAxes + dwNumPOVs + dwNumButtons - 1];
                            pSemBound = pSemButtons - 1;
                        }
                        else
                        {
                            pSemTest = pSemButtons;
                            pSemBound = &rgObjSem[dwNumAxes + dwNumPOVs + dwNumButtons];
                        }
                        /*
                         *  Filter triggers but just in case, do not distinguish 
                         *  between types of buttons (toggle/push).
                         */
                        dwSemObjType &= DIDFT_FFEFFECTTRIGGER;
                        break;
                    }

                    while( pSemTest != pSemBound )
                    {
                        if( !IS_OBJECT_USED( pSemTest->dwSemantic ) 
                         && ( ( dwSemObjType & pSemTest->dwID ) == dwSemObjType )
                         && ( ( DISEM_FLAGS_GET( pAction->dwSemantic ) == 0 )
                            ||( DISEM_FLAGS_GET( pAction->dwSemantic ) == DISEM_FLAGS_GET( pSemTest->dwSemantic ) ) ) )
                        {
                            pAction->dwObjID = pSemTest->dwID;
                            MARK_OBJECT_AS_USED( pSemTest->dwSemantic );
                            break;
                        }
                        pSemTest += iDirection;
                    }

                    if( pSemTest == pSemBound )
                    {
                        continue; /* None left */
                    }
                    pAction->dwHow = DIAH_DEFAULT;
                }
                break;
#ifdef XDEBUG
            default:
                AssertF(0);
#endif
            }

            SquirtSqflPtszV(sqflDf | sqflVerbose,
                TEXT( "Match for action %d is object 0x%08x and how 0x%08x"),
                pAction - paf->rgoAction, pAction->dwObjID, pAction->dwHow );

            /*
             *  If we get this far, we have a match.
             *  The control object id and dwHow field should have been set
             */
            AssertF( ( pAction->dwHow == DIAH_DEFAULT ) || ( pAction->dwHow == DIAH_APPREQUESTED ) );

            pAction->guidInstance = *guidDevInst;

            SquirtSqflPtszV(sqflDf | sqflVerbose,
                TEXT("Action %d mapped to object id 0x%08x"),
                pAction - paf->rgoAction, pAction->dwObjID );

            fSomethingMapped = TRUE;

        } /* Action loop */
    } /* Match loop */

    /*
     *  The result should always be S_OK
     */
    AssertF( hres == S_OK );

    /*
     *  If nothing was mapped, let the caller know
     */
    if( !fSomethingMapped )
    {
        hres = DI_NOEFFECT;
    }

error_exit:;
    ExitOleProc();
    return hres;

#undef IS_OBJECT_USED
#undef MARK_OBJECT_AS_USED

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMap | BuildDefaultSysActionMap |
 *
 *          Build default action map from the action format for mouse or
 *          keyboard devices.
 *
 *  @parm   LPDIACTIONFORMATW | paf |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   DWORD | dwPhysicalGenre |
 *
 *          Device genre to match.
 *
 *  @parm   REFGUID | guidDevInst |
 *
 *          Instance guid of device to match.
 *
 *  @parm   LPDIDATAFORMAT | dfDev |
 *
 *          Internal data format of device.
 *
 *  @parm   DWORD | dwButtonZeroInst |
 *
 *          For mice only, the instance number of the first button.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CMap_BuildDefaultSysActionMap
(
    LPDIACTIONFORMATW   paf,
    DWORD               dwFlags,
    DWORD               dwPhysicalGenre,
    REFGUID             guidDevInst,
    LPDIDATAFORMAT      dfDev,
    DWORD               dwButtonZeroInst
)
{
    HRESULT     hres;

    PBYTE       pMatch;
    UINT        idxAxis;
    UINT        idxButton;

    EnterProcI(IDirectInputDeviceCallback::CMap::BuildDefaultSysActionMap,
        (_ "pxxGpu", paf, dwFlags, dwPhysicalGenre, guidDevInst, dfDev, dwButtonZeroInst ));

    idxButton = 0;
    if( dwPhysicalGenre == DIPHYSICAL_KEYBOARD )
    {
        idxAxis = dfDev->dwNumObjs;
    }
    else
    {
        idxAxis = 0;
        AssertF( dwPhysicalGenre == DIPHYSICAL_MOUSE );
    }

    if( SUCCEEDED( hres = AllocCbPpv( dfDev->dwNumObjs, &pMatch) ) )
    {
        BOOL fSomethingMapped = FALSE;

        enum eMap
        {
            eMapPrevious,
            eMapDeviceSemantic,
            eMapClassSemantic,
            eMapEnd
        }           iMap;

        for( iMap=0; iMap<eMapEnd; iMap++ )
        {
            LPDIACTIONW pAction;

            for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
            {
                DWORD   dwObject;
                UINT    idxObj;

                dwObject = (DWORD)-1;

                /*
                 *  These flags have already been validated during semantic validation,
                 */
                AssertF( ( pAction->dwHow & ~DIAH_VALID ) == 0 );
                AssertF( ( pAction->dwHow & DIAH_ERROR ) == 0 );
                AssertF( ( pAction->dwFlags & ~DIA_VALID ) == 0 );

                if( pAction->dwFlags & DIA_APPNOMAP )
                {
                    continue;
                }

                if( iMap == eMapPrevious )
                {
                    if( !( pAction->dwHow & DIAH_MAPMASK ) )
                    {
                        continue;
                    }
                }
                else
                {
                    if( pAction->dwHow & DIAH_MAPMASK )
                    {
                        continue;
                    }
                }

                if( iMap < eMapClassSemantic )
                {
                    if( !IsEqualGUID( &pAction->guidInstance, guidDevInst ) )
                    {
                        continue;
                    }


                    /*
                     *  Check that the physical genre is compatible with this device
                     */
                    if( DISEM_GENRE_GET( pAction->dwSemantic ) != DISEM_GENRE_GET( dwPhysicalGenre ) )
                    {
                        SquirtSqflPtszV(sqflDf | sqflError,
                                        TEXT("Device specified for action does not match physical genre"));
                        break;
                    }
                }
                else
                if( !IsEqualGUID( &pAction->guidInstance, &GUID_Null) 
                 || ( DISEM_GENRE_GET( pAction->dwSemantic ) != DISEM_GENRE_GET( dwPhysicalGenre ) ) )
                {
                    continue;
                }

                if( iMap == eMapPrevious )
                {
                    /*
                     *  This match has already been validated
                     */
                    SquirtSqflPtszV(sqflDf | sqflVerbose,
                        TEXT("Action %d already mapped by 0x%08x to object 0x%08x"),
                        pAction - paf->rgoAction, pAction->dwHow, pAction->dwObjID );
                    AssertF( pAction->dwObjID != 0xFFFFFFFF );

                    /*
                     *  Find the object index
                     */
                    for( idxObj = 0; idxObj < dfDev->dwNumObjs; idxObj++ )
                    {
                        if( ( dfDev->rgodf[idxObj].dwType & DIDFT_FINDMASK ) == ( pAction->dwObjID & DIDFT_FINDMASK ) )
                        {
                            break;
                        }
                    }
                    if( idxObj < dfDev->dwNumObjs )
                    {
                        /*
                         *  Validation should have caught duplicates
                         */
                        AssertF( !pMatch[idxObj] );
                        pMatch[idxObj] = TRUE;
                        /*
                         *  Nothing else to do since we're just counting previous matches
                         */
                        continue;
                    }
                    else
                    {
                        SquirtSqflPtszV(sqflDf | sqflError,
                            TEXT("Action %d previously mapped by 0x%08x to unknown object 0x%08x"),
                            pAction - paf->rgoAction, pAction->dwHow, pAction->dwObjID );
                    }
                }
                else
                {
                    DWORD dwSemObjType = c_SemTypeToDFType[ DISEM_TYPEANDMODE_GET( pAction->dwSemantic ) ];

                    AssertF( ( iMap == eMapDeviceSemantic ) || ( iMap == eMapClassSemantic ) );

                    /*
                     *  System devices have index of the semantic = object default offset
                     *  use that to find the object index
                     */

                    for( idxObj = 0; idxObj < dfDev->dwNumObjs; idxObj++ )
                    {
                        /*
                         *  Test that this is an appropriate input type.
                         */
                        if(!( dfDev->rgodf[idxObj].dwType & dwSemObjType ) 
                         || ( dfDev->rgodf[idxObj].dwType & DIDFT_NODATA ) )
                        {
                            continue;
                        }

                        /*
                         *  All keyboards currently use the same (default) 
                         *  data format so the index can be used directly 
                         *  to match the semantic.  
                         */
                        if( dwPhysicalGenre == DIPHYSICAL_KEYBOARD )
                        {
                            if( dfDev->rgodf[idxObj].dwOfs != DISEM_INDEX_GET( pAction->dwSemantic ) )
                            {
                                continue;
                            }
                        }
                        else
                        {
                            /*
                             *  Mice are more awkward as HID mice data 
                             *  formats depend on the device so use the 
                             *  dwType instead.  
                             */
                            if( dwSemObjType & DIDFT_BUTTON )
                            {
                                /*
                                 *  A matching button is offset by the 
                                 *  caller supplied button zero instance as 
                                 *  the default button zero is instance 3.
                                 */
                                if( DIDFT_GETINSTANCE( dfDev->rgodf[idxObj].dwType ) - (BYTE)dwButtonZeroInst
                                 != DISEM_INDEX_GET( pAction->dwSemantic ) - DIMOFS_BUTTON0 )
                                {
                                    continue;
                                }
                            }
                            else
                            {
                                /*
                                 *  All mice have axis instances: x=0, y=1, z=2
                                 */
                                AssertF( dwSemObjType & DIDFT_AXIS );
                                if( ( DIDFT_GETINSTANCE( dfDev->rgodf[idxObj].dwType ) << 2 )
                                 != DISEM_INDEX_GET( pAction->dwSemantic ) )
                                {
                                    continue;
                                }
                            }
                        }

                        /*
                         *  A semantic match has been found
                         */
                        if( pMatch[idxObj] )
                        {
                            SquirtSqflPtszV(sqflDf | sqflError,
                                TEXT("Action %d maps to already mapped object 0x%08x"),
                                pAction - paf->rgoAction, pAction->dwObjID );
                        }
                        else
                        {
                            if(!( pAction->dwFlags & DIA_FORCEFEEDBACK )
                             || ( dfDev->rgodf[idxObj].dwType & ( DIDFT_FFACTUATOR | DIDFT_FFEFFECTTRIGGER ) ) )
                            {
                                /*
                                 *  If the game needs FF, only map FF objects
                                 */
                                dwObject = dfDev->rgodf[idxObj].dwType;
                            }
                        }
                        break;
                    }

                    if( dwObject == (DWORD)-1  )
                    {
                        if( ( iMap == eMapClassSemantic ) 
                         && SUCCEEDED( CMap_TestSysOffset( dwPhysicalGenre, 
                                DISEM_INDEX_GET( pAction->dwSemantic ) ) ) )
                        {
                            /*
                             *  Don't worry that this device is less capable than some
                             */
                            continue;
                        }
                    }
                }

                /*
                 *  If we get this far, we either have a possible match or the
                 *  action is invalid.  Since we could still find errors, look 
                 *  at matches first.
                 */
                if( dwObject != -1 )
                {
                    if( idxObj < dfDev->dwNumObjs )
                    {
                        if( iMap == eMapPrevious )
                        {
                            /*
                             *  Validation should have caught duplicates
                             */
                            AssertF( !pMatch[idxObj] );
                            pMatch[idxObj] = TRUE;
                            continue;
                        }
                        else
                        {
                            if( pMatch[idxObj] )
                            {
                                SquirtSqflPtszV(sqflDf | sqflError,
                                                TEXT("Object specified more than once on device"));
                                dwObject = (DWORD)-1;
                            }
                        }
                    }
                    else
                    {
                        hres = CMap_TestSysObject( dwPhysicalGenre, dwObject );
                        if( SUCCEEDED( hres ) )
                        {
                            /*
                             *  Not an unreasonable request so just carry on
                             */
                            continue;
                        }
                        else
                        {
                            dwObject = (DWORD)-1;
                        }
                    }
                }

                /*
                 *  We have either a valid object or an error
                 */
                if( dwObject != (DWORD)-1 )
                {
                    pAction->dwHow = DIAH_DEFAULT;
                    pAction->dwObjID = dwObject;
                    pAction->guidInstance = *guidDevInst;

                    SquirtSqflPtszV(sqflDf | sqflVerbose,
                        TEXT("Action %d mapped to object index 0x%08x type 0x%08x"),
                        pAction - paf->rgoAction, idxObj, dwObject );

                    pMatch[idxObj] = TRUE;
                    fSomethingMapped = TRUE;
                }
                else
                {
                    /*
                     *  Mark this action as invalid and quit.
                     */
                    pAction->dwHow = DIAH_ERROR;
                    RPF("ERROR BuildActionMap: arg %d: rgoAction[%d] invalid", 1, pAction - paf->rgoAction );
                    RPF( "Semantic 0x%08x", pAction->dwSemantic );
                    hres = DIERR_INVALIDPARAM;
                    goto free_and_exit;
                }
            } /* Action loop */
        } /* Match loop */

        /*
         *  The result should always be a successful memory allocation (S_OK)
         */
        AssertF( hres == S_OK );

        /*
         *  If nothing was mapped, let the caller know
         */
        if( !fSomethingMapped )
        {
            hres = DI_NOEFFECT;
        }

free_and_exit:;
        FreePv( pMatch );
    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMap | ActionMap_IsValidMapObject |
 *
 *          Utility function to check a DIACTIONFORMAT structure for validity.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDIACTIONFORMAT | paf |
 *
 *          Points to a structure that describes the actions needed by the
 *          application.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The structure is valid.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The structure is
 *          not valid.
 *
 *****************************************************************************/

HRESULT
CDIDev_ActionMap_IsValidMapObject
(
    LPDIACTIONFORMATW paf
#ifdef XDEBUG
    comma
    LPCSTR  pszProc
    comma
    UINT    argnum
#endif
)
{
    HRESULT hres = E_INVALIDARG;

    /*
     *  Assert that the structures are the same until the final element
     */
#if defined(_WIN64)
    CAssertF( ( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
              - ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) 
            < MAX_NATURAL_ALIGNMENT ) );
#else
    CAssertF( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
           == ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) );
#endif

    CAssertF( FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) 
           == FIELD_OFFSET( DIACTIONFORMATA, tszActionMap ) );

    CAssertF( cbX(DIACTIONA)       == cbX(DIACTIONW) );

    if( FAILED(hresFullValidWriteNoScramblePvCb_(paf, MAKELONG( cbX(DIACTIONFORMATA), cbX(DIACTIONFORMATW) ), pszProc, argnum)) )
    {
    }
    else if( paf->dwActionSize != cbX(DIACTION) )
    {
        D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMAT.dwActionSize 0x%08x",
            pszProc, paf->dwActionSize ); )
    }
    else if( paf->dwDataSize != (paf->dwNumActions * cbX( ((LPDIDEVICEOBJECTDATA)0)->dwData ) ) )
    {
        D( RPF("IDirectInputDevice::%s: DIACTIONFORMAT.dwDataSize 0x%08x not valid for DIACTIONFORMAT.dwNumActions 0x%08x",
            pszProc, paf->dwDataSize ); )
    }
    else if( IsEqualGUID(&paf->guidActionMap, &GUID_Null) )
    {
        D( RPF("IDirectInputDevice::%s: DIACTIONFORMAT.guidActionMap is a NULL GUID", pszProc ); )
    }
    else if( !DISEM_VIRTUAL_GET( paf->dwGenre ) )
    {
        D( RPF("IDirectInputDevice::%s: Invalid (1) DIACTIONFORMAT.dwGenre 0x%08x", pszProc, paf->dwGenre ); )
    }
    else if( DISEM_GENRE_GET( paf->dwGenre ) > DISEM_MAX_GENRE )
    {
        D( RPF("IDirectInputDevice::%s: Invalid (2) DIACTIONFORMAT.dwGenre 0x%08x", pszProc, paf->dwGenre ); )
    }
    else if( ( paf->lAxisMin | paf->lAxisMax ) && ( paf->lAxisMin > paf->lAxisMax ) )
    {
        D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMAT.lAxisMin 0x%08x for lAxisMax 0x%08x",
            pszProc, paf->lAxisMin, paf->lAxisMax ); )
    }
    else if( !paf->dwNumActions )
    {
        D( RPF("IDirectInputDevice::%s: DIACTIONFORMAT.dwNumActions is zero", pszProc ); )
    }
    else if( paf->dwNumActions & 0xFF000000 )
    {
        D( RPF("IDirectInputDevice::%s: DIACTIONFORMAT.dwNumActions of 0x%08x is unreasonable", paf->dwNumActions, pszProc ); )
    }
    else if( !paf->rgoAction )
    {
        D( RPF("IDirectInputDevice::%s: DIACTIONFORMAT.rgoAction is NULL", pszProc ); )
    }
    else if( FAILED( hresFullValidWriteNoScramblePvCb_(paf->rgoAction,
        cbX(*paf->rgoAction) * paf->dwNumActions, pszProc, argnum ) ) )
    {
    }
    else
    {
        hres = S_OK;
    }

    /*
     *  Warning only tests go here.  Only test if everything else was OK.
     */
#ifdef XDEBUG
    if( SUCCEEDED( hres ) )
    {
    }
#endif

    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | BitwiseReflect |
 *
 *          Reflect the bottom bits of a value.
 *          Note, this could easily be optimized but it is only used once.
 *
 *  @parm   IN DWORD | dwValue |
 *
 *          The value to be reflected.
 *
 *  @parm   IN int | iBottom |
 *
 *          The number of bits to be reflected.
 *
 *  @returns
 *          Returns the value dwValue with the bottom iBottom bits reflected
 *
 *****************************************************************************/
DWORD BitwiseReflect
( 
    DWORD   dwValue, 
    int     iBottom 
)
{
	int		BitIdx;
	DWORD	dwTemp = dwValue;

#define BITMASK(X) (1L << (X))

	for( BitIdx = 0; BitIdx < iBottom; BitIdx++ )
	{
		if( dwTemp & 1L )
			dwValue |=  BITMASK( ( iBottom - 1 ) - BitIdx );
		else
			dwValue &= ~BITMASK( ( iBottom - 1 ) - BitIdx );
		dwTemp >>= 1;
	}
	return dwValue;

#undef BITMASK
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CMap_InitializeCRCTable |
 *
 *          If needed create and initialize the global table used for CRCs.
 *
 *          Allocate memory for the 256 DWORD array and generate a set of 
 *          values used to calculate a Cyclic Redundancy Check.
 *          The algorithm used is supposedly the same as Ethernet's CRC-32.
 *
 *  @returns
 *          Returns one of the following a COM error codes:
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          <c DI_NOEFFECT> = <c S_FALSE>: The table already existed.
 *
 *          <c E_OUTOFMEMORY>: insufficient memory available for the table.
 *          The GetMapCRC function does not check that the table has been 
 *          initialized so failure of this function should not allow 
 *          processing to proceed into any function that uses GetMapCRC.
 *
 *****************************************************************************/

#define CRC_TABLE_SIZE  256

#define CRCWIDTH        32
#define POLY            0x04C11DB7

HRESULT CMap_InitializeCRCTable( void )
{
	HRESULT hres;
    int	    TableIdx;

    if( g_rgdwCRCTable )
    {
        hres = S_FALSE;
    }
    else
    {
        hres = AllocCbPpv( CRC_TABLE_SIZE * cbX( *g_rgdwCRCTable ), &g_rgdwCRCTable );
        if( SUCCEEDED( hres ) )
        {
	        /*
             *  Special case the first element so it gets a non-zero value
             */
            g_rgdwCRCTable[0] = POLY;

            for( TableIdx = 1; TableIdx < CRC_TABLE_SIZE; TableIdx++ )
	        {
	            int   BitIdx;
	            DWORD dwR;

	            dwR = BitwiseReflect( TableIdx, 8 ) << ( CRCWIDTH - 8 );

	            for( BitIdx = 0; BitIdx < 8; BitIdx++ )
	            {
		            if( dwR & 0x80000000 )
			            dwR = ( dwR << 1 ) ^ POLY;
		            else
			            dwR <<= 1;
	            }

		        g_rgdwCRCTable[TableIdx] = BitwiseReflect( dwR, CRCWIDTH );

                /*
                 *  We do not want a value of zero or identical values to be 
                 *  generated.
                 */
                AssertF( g_rgdwCRCTable[TableIdx] );
                AssertF( g_rgdwCRCTable[TableIdx] != g_rgdwCRCTable[TableIdx-1] );
	        }

        }
    }

    return hres;
}
#undef CRCWIDTH

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | GetMapCRC |
 *
 *          Calculate a CRC based on the passed DIACTIONFORMAT contents.
 *          The algorithm used is based on "CRC-32" which is supposedly what 
 *          Ethernet uses, however some changes have been made to suit the 
 *          specific use.
 *
 *  @parm   IN LPDIACTIONFORMAT | lpaf |
 *
 *          Points to a structure that describes the actions to be mapped
 *          for which a CRC is to be generated.
 *
 *  @returns
 *
 *          The 32 bit CRC as a DWORD value.
 *
 *****************************************************************************/
DWORD GetMapCRC
( 
    LPDIACTIONFORMATW   paf,
    REFGUID             guidInst
)
{
    DWORD               dwCRC;
    PBYTE               pBuffer;
    LPCDIACTIONW        pAction;
    
    /*
     *  It is the caller's responsibility to make sure g_rgdwCRCTable has 
     *  been allocated and initialized.
     */    
    AssertF( g_rgdwCRCTable );

    /*
     *  Initialize to dwNumActions to avoid having to CRC it
     */
    dwCRC = paf->dwNumActions;

    /* Assert that the action map guid and the genre can be tested in series */
    CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwGenre ) 
           == FIELD_OFFSET( DIACTIONFORMATW, guidActionMap ) + cbX( paf->guidActionMap ) );

    for( pBuffer = ((PBYTE)&paf->guidActionMap) + cbX( paf->guidActionMap ) + cbX( paf->dwGenre );
         pBuffer >= ((PBYTE)&paf->guidActionMap); pBuffer-- )
    {
        dwCRC = g_rgdwCRCTable[( LOBYTE(dwCRC) ^ *pBuffer )] ^ (dwCRC >> 8);
    }

    /* Assert that the device instance guid and object ID can be tested in series */
    CAssertF( FIELD_OFFSET( DIACTIONW, dwObjID ) 
           == FIELD_OFFSET( DIACTIONW, guidInstance ) + cbX( pAction->guidInstance ) );

    for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
    {
        /*
         *  Make sure this action is really relevant before including it in 
         *  the CRC.  It is assumed that any change in which actions are 
         *  included will be picked up in the resultant CRC.
         */
        if( IsEqualGUID( &pAction->guidInstance, guidInst )
         && ( pAction->dwHow & DIAH_MAPMASK )
         && ( ( pAction->dwFlags & DIA_APPNOMAP ) == 0 ) )
        {
        	/*
             *  Besides which actions are taken into account, the only fields 
             *  need to be verified are those that would change a SetActionMap.
             *  Although flags such as DIA_FORCEFEEDBACK could alter the 
             *  mappings they do not change a SetActionMap.
             */
            for( pBuffer = ((PBYTE)&pAction->guidInstance) + cbX( pAction->guidInstance ) + cbX( pAction->dwObjID );
                 pBuffer >= ((PBYTE)&pAction->guidInstance); pBuffer-- )
            {
        		dwCRC = g_rgdwCRCTable[( LOBYTE(dwCRC) ^ *pBuffer )] ^ (dwCRC >> 8);
            }
        }
    }

    return dwCRC;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | CDIDev_BuildActionMapCore |
 *
 *          Worker function for BuildActionMapA and BuildActionMapW.
 *          This does the real work once the external entry points have done 
 *          dialect specific validation and set up.
 *
 *****************************************************************************/

STDMETHODIMP CDIDev_BuildActionMapCore
(
    PDD                 this,
    LPDIACTIONFORMATW   paf,
    LPCWSTR             lpwszUserName,
    DWORD               dwFlags
)
{
    HRESULT hres;

    EnterProcI(CDIDev_BuildActionMapCore, (_ "pWx", paf, lpwszUserName, dwFlags ));

    // This application uses the mapper
    AhAppRegister(this->dwVersion, 0x1);

    switch( dwFlags & ( DIDBAM_PRESERVE | DIDBAM_INITIALIZE | DIDBAM_HWDEFAULTS ) )
    {
    case DIDBAM_DEFAULT:
    case DIDBAM_PRESERVE:
    case DIDBAM_INITIALIZE:
    case DIDBAM_HWDEFAULTS:
        hres = S_OK;
        break;
    default:
        RPF("ERROR %s: arg %d: Must not combine "
            "DIDBAM_PRESERVE, DIDBAM_INITIALIZE and DIDBAM_HWDEFAULTS", s_szProc, 3);
        hres = E_INVALIDARG;
    }

    if( SUCCEEDED(hres)
     && SUCCEEDED(hres = hresFullValidFl(dwFlags, DIDBAM_VALID, 3))
     && SUCCEEDED(hres = CMap_ValidateActionMapSemantics( paf, dwFlags ) ) )
    {
        LPDIPROPSTRING pdipMapFile;

        if( SUCCEEDED( hres = AllocCbPpv(cbX(*pdipMapFile), &pdipMapFile) ) )
        {
            HRESULT hresExactMaps = E_FAIL;
            PWCHAR pwszMapFile;
            DWORD dwCommsType;

            if( dwFlags & DIDBAM_HWDEFAULTS )
            {
                hres = CMap_DeviceValidateActionMap( (PV)this, paf, DVAM_DEFAULT, &dwCommsType );
                hresExactMaps = hres;
                if( hres == S_OK )
                {
                    hresExactMaps = DI_NOEFFECT;
                }
            }
            else
            {
                /*
                 *  Do a generic test and map of any exact device matches
                 */
                hres = CMap_DeviceValidateActionMap( (PV)this, paf, DVAM_GETEXACTMAPPINGS, &dwCommsType );

                if( SUCCEEDED( hres ) )
                {
                    /*
                     *  Save the exact mapping result to combine with the result
                     *  of semantic mapping.
                     */
                    hresExactMaps = hres;
                }
            }

            if( SUCCEEDED( hres ) )
            {
                pdipMapFile->diph.dwSize = cbX(DIPROPSTRING);
                pdipMapFile->diph.dwHeaderSize = cbX(DIPROPHEADER);
                pdipMapFile->diph.dwObj = 0;
                pdipMapFile->diph.dwHow = DIPH_DEVICE;

                /*
                 *  Try to get a configured mapping.
                 *  If there is no IHV file there may still be a user file
                 */
                hres = CDIDev_GetPropertyW( &this->ddW, DIPROP_MAPFILE, &pdipMapFile->diph );
                pwszMapFile = SUCCEEDED( hres ) ? pdipMapFile->wsz : NULL;

                if( dwCommsType ) 
                {
                    /*
                     *  Communications control device
                     */
                    if( !pwszMapFile )
                    {
                        /*
                         *  If there's no IHV mapping there's nothing to add.
                         */
                        hres = DI_NOEFFECT;
                    }
                    else
                    {
                        /*
                         *  Modify the genre over the call to the mapper so 
                         *  that we get physical genre mappings from the IHV 
                         *  file if no user mappings are available
                         */

                        DWORD dwAppGenre = paf->dwGenre;

                        paf->dwGenre = DIPHYSICAL_VOICE;

                        hres = this->pMS->lpVtbl->GetActionMap(this->pMS, &this->guid, pwszMapFile, 
                            (LPDIACTIONFORMATW)paf, lpwszUserName, NULL, dwFlags );

                        /*
                         *  ISSUE-2001/03/29-timgill Only want the timestamp for hardcoded devices
                         *  ->Read again for mappings
                         */
                        if( ( dwCommsType == DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED ) 
                         &&!( dwFlags & DIDBAM_HWDEFAULTS ) )
                        {
                            DWORD dwLowTime;
                            DWORD dwHighTime;

                            dwLowTime = paf->ftTimeStamp.dwLowDateTime;
                            dwHighTime = paf->ftTimeStamp.dwHighDateTime;

                            hres = this->pMS->lpVtbl->GetActionMap(this->pMS, &this->guid, pwszMapFile, 
                                (LPDIACTIONFORMATW)paf, lpwszUserName, NULL, DIDBAM_HWDEFAULTS );

                            paf->ftTimeStamp.dwLowDateTime = dwLowTime;
                            paf->ftTimeStamp.dwHighDateTime = dwHighTime; 
                        }
                        paf->dwGenre = dwAppGenre;

                        if( SUCCEEDED( hres ) )
                        {
                            if( hres == S_NOMAP )
                            {
                                /*
                                 *  Make sure we do not attempt defaults and 
                                 *  the exact match return code gets back to the 
                                 *  caller
                                 */
                                hres = DI_NOEFFECT;
                            }
                        }
                        else
                        {
                            /*
                             *  If there was an error, there are no defaults 
                             *  so quit now.
                             */
                            if( ( HRESULT_FACILITY( hres ) == FACILITY_ITF ) 
                             && ( HRESULT_CODE( hres ) > 0x0600 ) )
                            {
                                AssertF( HRESULT_CODE( hres ) < 0x0680 );
                                RPF( "Internal GetActionMap error 0x%08x for hardwired device", hres );
                                hres = DIERR_MAPFILEFAIL;
                            }
                            goto FreeAndExitCDIDev_BuildActionMapCore;
                        }
                    }
                }
                else if( !pwszMapFile && ( dwFlags & DIDBAM_HWDEFAULTS ) )
                {
                    /*
                     *  Make sure we get defaults
                     */
                    SquirtSqflPtszV(sqflDf | sqflBenign,
                        TEXT("Failed to GetProperty DIPROP_MAPFILE 0x%08x, default will be generated"), hres );
                    hres = S_NOMAP;
                }
                else
                {
                    hres = this->pMS->lpVtbl->GetActionMap(this->pMS, &this->guid, pwszMapFile, 
                        (LPDIACTIONFORMATW)paf, lpwszUserName, NULL, dwFlags);

                    if( ( paf->ftTimeStamp.dwHighDateTime == DIAFTS_UNUSEDDEVICEHIGH )
                     && ( paf->ftTimeStamp.dwLowDateTime == DIAFTS_UNUSEDDEVICELOW )
                     && SUCCEEDED( hres ) )
                    {
                        /*
                         *  If the device has never been used, the saved 
                         *  mappings are either the IHV defaults or cooked up 
                         *  defaults.  Unfortunately, DIMap will have marked 
                         *  them as DIAH_USERCONFIG.  Some day DIMap should 
                         *  either return the true flags or return without 
                         *  changing the flags, until then, reset all the 
                         *  flags and then do a second request for defaults.
                         */
                        LPDIACTIONW     pAction;

                        for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
                        {
                            if( ( ( pAction->dwFlags & ( DIA_APPMAPPED | DIA_APPNOMAP ) ) == 0 )
                             && ( pAction->dwHow & DIAH_USERCONFIG )
                             && IsEqualGUID( &pAction->guidInstance, &this->guid ) )
                            {
                                pAction->dwHow = DIAH_UNMAPPED;
                            }
                        }

                        hres = this->pMS->lpVtbl->GetActionMap(this->pMS, &this->guid, pwszMapFile, 
                            (LPDIACTIONFORMATW)paf, lpwszUserName, NULL, DIDBAM_HWDEFAULTS);

                        /*
                         *  Make sure the timestamps are still set for unused.
                         */
                        paf->ftTimeStamp.dwLowDateTime = DIAFTS_UNUSEDDEVICELOW;
                        paf->ftTimeStamp.dwHighDateTime = DIAFTS_UNUSEDDEVICEHIGH;
                    }

                    if( FAILED( hres ) )
                    {
                        if( ( HRESULT_FACILITY( hres ) == FACILITY_ITF ) 
                         && ( HRESULT_CODE( hres ) > 0x0600 ) )
                        {
                            AssertF( HRESULT_CODE( hres ) < 0x0680 );
                            RPF( "Internal GetActionMap error 0x%08x for configurable device", hres );
                            hres = DIERR_MAPFILEFAIL;
                        }
                    }
                }

            }

            if( SUCCEEDED( hresExactMaps ) )
            {
                /*
                 *  If we took an IHV mapping, do a default mapping on top.
                 *  This allows IHVs to only map objects that are special 
                 *  leaving other objects to be used for whatever semantics 
                 *  match.
                 *  Some day we should have a return code that indicates which 
                 *  type of mapping DIMap produced, until then, search the 
                 *  mappings for a HWDefault.
                 */
                if( SUCCEEDED( hres ) && ( hres != S_NOMAP )
                 && ( dwCommsType != DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED ) )
                {
                    LPDIACTIONW     pAction;

                    for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
                    {
                        if( ( ( pAction->dwFlags & ( DIA_APPMAPPED | DIA_APPNOMAP ) ) == 0 )
                         && ( pAction->dwHow & DIAH_HWDEFAULT )
                         && IsEqualGUID( &pAction->guidInstance, &this->guid ) )
                        {
                            hres = S_NOMAP;
                            break;
                        }
                    }
                }

                if( FAILED( hres ) || ( hres == S_NOMAP ) )
                {
                    hres = this->pdcb->lpVtbl->BuildDefaultActionMap( this->pdcb, paf, dwFlags, &this->guid );

                    if( SUCCEEDED( hres ) )
                    {
                        paf->ftTimeStamp.dwLowDateTime = DIAFTS_NEWDEVICELOW;
                        paf->ftTimeStamp.dwHighDateTime = DIAFTS_NEWDEVICEHIGH;
                        SquirtSqflPtszV(sqflDf | sqflVerbose, TEXT("Default action map used"));
                    }
                    else
                    {
                        SquirtSqflPtszV(sqflDf | sqflError, TEXT("Default action map failed"));
                    }
                }
                else
                {
                    hres = CMap_DeviceValidateActionMap( (PV)this, paf, DVAM_DEFAULT, &dwCommsType );
                    if( SUCCEEDED( hres ) )
                    {
                        SquirtSqflPtszV(sqflDf | sqflVerbose, TEXT("Action map validated"));
                    }
                    else
                    {
                        RPF( "Initially valid action map invalidated by mapper!" );
                    }
                }

                /*
                 *  If no semantics mapped, return the exact map result.
                 */
                if( hres == DI_NOEFFECT )
                {
                    hres = hresExactMaps;
                }

                if( dwFlags & DIDBAM_HWDEFAULTS )
                {
                    /*
                     *  Timestamps are meaningless for hardware defaults
                     *  so just make sure the values are consistent.
                     */
                    paf->ftTimeStamp.dwLowDateTime = DIAFTS_UNUSEDDEVICELOW;
                    paf->ftTimeStamp.dwHighDateTime = DIAFTS_UNUSEDDEVICEHIGH;
                }
                else if( ( paf->ftTimeStamp.dwHighDateTime == DIAFTS_NEWDEVICEHIGH )
                      && ( paf->ftTimeStamp.dwLowDateTime == DIAFTS_NEWDEVICELOW )
                      && SUCCEEDED( hres ) )
                {
                    if( FAILED( this->pMS->lpVtbl->SaveActionMap( this->pMS, &this->guid, 
                        pwszMapFile, paf, lpwszUserName, dwFlags ) ) )
                    {
                        SquirtSqflPtszV(sqflDf | sqflBenign,
                            TEXT("Failed to save action map on first use 0x%08x"), hres );
                        paf->ftTimeStamp.dwLowDateTime = DIAFTS_UNUSEDDEVICELOW;
                        paf->ftTimeStamp.dwHighDateTime = DIAFTS_UNUSEDDEVICEHIGH;
                        /*
                         *  Don't return an internal DIMap result, convert it to a published one
                         */
                        if( ( HRESULT_FACILITY( hres ) == FACILITY_ITF ) 
                         && ( HRESULT_CODE( hres ) > 0x0600 ) )
                        {
                            AssertF( HRESULT_CODE( hres ) < 0x0680 );
                            hres = DIERR_MAPFILEFAIL;
                        }
                    }
                }
            }
            else
            {
                SquirtSqflPtszV(sqflDf | sqflError, TEXT("Invalid mappings in action array"));
            }

FreeAndExitCDIDev_BuildActionMapCore:;
            FreePv( pdipMapFile );

            if( SUCCEEDED( hres ) )
            {
                paf->dwCRC = GetMapCRC( paf, &this->guid );
            }
        }
        else
        {
            /*
             *  Note, we could try to do a default map even though we could not
             *  allocate space for the file name property but if allocations
             *  are failing we're better of quitting ASAP.
             */
            SquirtSqflPtszV(sqflDf | sqflError, TEXT("Mem allocation failure") );
        }
    }

#if 0
    {
        LPDIACTIONW pAction;

        RPF( "Action map leaving build" );
//        RPF( "Act#  Semantic    Flags       Object      How         App Data" );
        RPF( "A#  Semantic  Device                                  Object   How" );
        for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
        {
            RPF( "%02d  %08x  {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}  %08x %08x", 
                pAction - paf->rgoAction, 
                pAction->dwSemantic,
                pAction->guidInstance.Data1, pAction->guidInstance.Data2, pAction->guidInstance.Data3, 
                pAction->guidInstance.Data4[0], pAction->guidInstance.Data4[1], 
                pAction->guidInstance.Data4[2], pAction->guidInstance.Data4[3], 
                pAction->guidInstance.Data4[4], pAction->guidInstance.Data4[5], 
                pAction->guidInstance.Data4[6], pAction->guidInstance.Data4[7],
                pAction->dwObjID,
                pAction->dwHow,
                pAction->uAppData );
//            RPF( "%02d    %08x    %08x    %08x    %08x    %08x", 
//                pAction - paf->rgoAction, 
//                pAction->dwSemantic,
//                pAction->dwFlags,
//                pAction->dwObjID,
//                pAction->dwHow,
//                pAction->uAppData );
        }
        RPF( "--" );
    }
#endif
    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | BuildActionMap |
 *
 *          Obtains the mapping of actions described in the <t DIACTIONFORMAT>
 *          to controls for this device.
 *          Information about user preferences and hardware manufacturer 
 *          provided defaults is used to create the association between game 
 *          actions and device controls. 
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDIACTIONFORMAT | paf |
 *
 *          Points to a structure that describes the actions needed by the
 *          application.
 *
 *  @parm   LPCSTR | lpszUserName |
 *
 *          Name of user for whom mapping is requested.  This may be a NULL
 *          pointer in which case the current user is assumed.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to control the mapping.  Must be a valid combination
 *          of the <c DIDBAM_*> flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_NOEFFECT> = <c S_OK>: The operation completed successfully
 *          but no actions were mapped.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  A parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP CDIDev_BuildActionMapW
(
    PV                  pdidW,
    LPDIACTIONFORMATW   paf,
    LPCWSTR             lpwszUserName,
    DWORD               dwFlags
)
{
    HRESULT hres;

    EnterProcR(IDirectInputDevice8W::BuildActionMap, (_ "ppWx", pdidW, paf, lpwszUserName, dwFlags));

    if( SUCCEEDED(hres = hresPvW( pdidW ) )
     && SUCCEEDED(hres = CDIDev_ActionMap_IsValidMapObject( paf D(comma s_szProc comma 1) ) ) )
    {
        if( paf->dwSize != cbX(DIACTIONFORMATW) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMATW.dwSize 0x%08x",
                s_szProc, paf->dwSize ); )
            hres = E_INVALIDARG;
        }
        else
        {
            LPWSTR pwszGoodUserName;

            hres = GetWideUserName( NULL, lpwszUserName, &pwszGoodUserName );
            if( SUCCEEDED( hres ) )
            {
                hres = CDIDev_BuildActionMapCore( _thisPvNm(pdidW, ddW), paf, lpwszUserName, dwFlags );

                if( !lpwszUserName )
                {
                    FreePv( pwszGoodUserName );
                }
            }
        }
    }

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | BuildActionMapA |
 *
 *          ANSI version of BuildActionMap.
 *
 *****************************************************************************/

STDMETHODIMP CDIDev_BuildActionMapA
(
    PV                  pdidA,
    LPDIACTIONFORMATA   pafA,
    LPCSTR              lpszUserName,
    DWORD               dwFlags
)
{
    HRESULT hres;

    EnterProcR(IDirectInputDevice8A::BuildActionMap, (_ "ppAx", pdidA, pafA, lpszUserName, dwFlags));

    if( SUCCEEDED(hres = hresPvA( pdidA ) )
     && SUCCEEDED(hres = CDIDev_ActionMap_IsValidMapObject( (LPDIACTIONFORMATW)pafA D(comma s_szProc comma 1) ) ) )
    {
        if( pafA->dwSize != cbX(DIACTIONFORMATA) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMATA.dwSize 0x%08x",
                s_szProc, pafA->dwSize ); )
            hres = E_INVALIDARG;
        }
        else
        {
            LPWSTR pwszGoodUserName;

            hres = GetWideUserName( lpszUserName, NULL, &pwszGoodUserName );
            if( SUCCEEDED( hres ) )
            {
                /*
                 *  For the sake of the mapper DLLs validation set the size to 
                 *  the UNICODE version.  If we ever send this to an external 
                 *  component we should do this differently.
                 */
                pafA->dwSize = cbX(DIACTIONFORMATW);

                hres = CDIDev_BuildActionMapCore( _thisPvNm(pdidA, ddA), (LPDIACTIONFORMATW)pafA, pwszGoodUserName, dwFlags );
                
                pafA->dwSize = cbX(DIACTIONFORMATA);

                FreePv( pwszGoodUserName );
            }
        }
    }

    ExitOleProc();

    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | CDIDev_SaveActionMap |
 *
 *          Worker function for SetActionMapA and SetActionMapW.
 *          Used to save an actions map.
 *
 *****************************************************************************/

STDMETHODIMP CDIDev_SaveActionMap
(
    PDD                 this,
    LPDIACTIONFORMATW   paf,
    LPWSTR              lpwszUserName,
    DWORD               dwFlags
)
{
    HRESULT hres;
    LPDIPROPSTRING pdipMapFile;

    EnterProcI(CDIDev_SaveActionMap, (_ "pWAx", paf, lpwszUserName, dwFlags));

    if( SUCCEEDED( hres = AllocCbPpv(cbX(*pdipMapFile), &pdipMapFile) ) )
    {
        DWORD dwLowTime;
        DWORD dwHighTime;

        // Save user's pass-in timestamps
        dwLowTime = paf->ftTimeStamp.dwLowDateTime;
        dwHighTime = paf->ftTimeStamp.dwHighDateTime;

        pdipMapFile->diph.dwSize = cbX(DIPROPSTRING);
        pdipMapFile->diph.dwHeaderSize = cbX(DIPROPHEADER);
        pdipMapFile->diph.dwObj = 0;
        pdipMapFile->diph.dwHow = DIPH_DEVICE;

        paf->ftTimeStamp.dwLowDateTime = DIAFTS_UNUSEDDEVICELOW;
        paf->ftTimeStamp.dwHighDateTime = DIAFTS_UNUSEDDEVICEHIGH;

        hres = CDIDev_GetPropertyW( &this->ddW, DIPROP_MAPFILE, &pdipMapFile->diph );

        hres = this->pMS->lpVtbl->SaveActionMap( this->pMS, &this->guid, 
                /* No map file if the GetProperty failed */
                (SUCCEEDED( hres )) ? pdipMapFile->wsz : NULL, 
                paf, lpwszUserName, dwFlags );

        // restore user's pass-in timestamps
        paf->ftTimeStamp.dwLowDateTime = dwLowTime;
        paf->ftTimeStamp.dwHighDateTime = dwHighTime;

        FreePv( pdipMapFile );
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | ParseActionFormat |
 *
 *          Parse the action format passed by the application and
 *          convert it into a format that we can use to translate
 *          the device data into application data.
 *
 *  @parm   IN LPDIACTIONFORMAT | lpaf |
 *
 *          Points to a structure that describes the actions to be mapped
 *          to this device.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_ParseActionFormat
(
    PDD                     this,
    LPDIACTIONFORMATW       paf
)
{
    PDIXLAT pdix;
    PINT rgiobj;
    VXDDATAFORMAT vdf;
    HRESULT hres;


#ifdef DEBUG
    EnterProc(CDIDev_ParseActionFormat, (_ "pp", this, paf));
#endif

    /*
     *  Caller should've nuked the old translation table.
     */
    AssertF(this->pdix == 0);
    AssertF(this->rgiobj == 0);

    if( paf->dwDataSize != paf->dwNumActions * cbX( ((LPDIDEVICEOBJECTDATA)0)->dwData ) )
    {
        SquirtSqflPtszV(sqflDf | sqflError,
	        TEXT("Incorrect dwDataSize (0x%08X) for dwNumActions (0x%08X)"),
		    paf->dwDataSize, paf->dwNumActions );
        hres = E_INVALIDARG;
        goto done_without_free;
    }

    vdf.cbData = this->df.dwDataSize;
    vdf.pDfOfs = 0;
    rgiobj = 0;

    if( SUCCEEDED(hres = AllocCbPpv(cbCxX(this->df.dwNumObjs, DIXLAT), &pdix))
     && SUCCEEDED(hres = AllocCbPpv(cbCdw(this->df.dwDataSize), &vdf.pDfOfs)) 
     && SUCCEEDED(hres = AllocCbPpv(cbCdw(paf->dwDataSize), &rgiobj)) )
    {
        LPCDIACTIONW    pAction;
        DIPROPDWORD     dipdw;
        DIPROPRANGE     diprange;
        DWORD           dwAxisMode = DIPROPAXISMODE_REL;
        BOOL            fSomethingMapped = FALSE;
        BOOL            fAxisModeKnown = FALSE;

        /*
         * Pre-init all the translation tags to -1,
         * which means "not in use"
         */
        memset(pdix, 0xFF, cbCxX(this->df.dwNumObjs, DIXLAT));
        memset(vdf.pDfOfs, 0xFF, cbCdw(this->df.dwDataSize));
        memset(rgiobj, 0xFF, cbCdw(paf->dwDataSize) );

        /*
         *  Set up the property invariants
         */
        dipdw.diph.dwSize = sizeof(DIPROPDWORD);
        dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        dipdw.diph.dwHow = DIPH_BYID;
        diprange.diph.dwSize = sizeof(DIPROPRANGE);
        diprange.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        diprange.diph.dwHow = DIPH_BYID;
        diprange.lMin = paf->lAxisMin;
        diprange.lMax = paf->lAxisMax;

        for( pAction = paf->rgoAction; pAction < &paf->rgoAction[paf->dwNumActions]; pAction++ )
        {
            if( IsEqualGUID( &pAction->guidInstance, &this->guid ) )
            {
                /*
                 *  These flags have already been validated but it does not hurt to assert
                 */
                AssertF( ( pAction->dwHow & ~DIAH_VALID ) == 0 );
                AssertF( ( pAction->dwHow & DIAH_ERROR ) == 0 );
                AssertF( ( pAction->dwFlags & ~DIA_VALID ) == 0 );

                if( ( pAction->dwHow & DIAH_MAPMASK )
                 && ( ( pAction->dwFlags & DIA_APPNOMAP ) == 0 ) )
                {
                    int iobjDev = -1;
                    PCODF podfFound;

                    for( podfFound = this->df.rgodf; podfFound < &this->df.rgodf[this->df.dwNumObjs]; podfFound++ )
                    {
                        iobjDev++;
                        /*
                         *  Look for an exact type flags match
                         */
                        if( podfFound->dwType == pAction->dwObjID )
                        {
                            break;
                        }
                    }

                    if( podfFound < &this->df.rgodf[this->df.dwNumObjs] )
                    {
                        DWORD dwAppOffset = (DWORD)(pAction - paf->rgoAction) * cbX( ((LPDIDEVICEOBJECTDATA)0)->dwData );

                        fSomethingMapped = TRUE;

                        vdf.pDfOfs[podfFound->dwOfs] = iobjDev;
                        rgiobj[dwAppOffset] = iobjDev;

                        pdix[iobjDev].dwOfs = dwAppOffset;
                        pdix[iobjDev].uAppData = pAction->uAppData;

                        if ( podfFound->dwFlags & DIDOI_POLLED ) {
                            this->fPolledDataFormat = TRUE;
                        }

                        dipdw.diph.dwObj = podfFound->dwType;
                        dipdw.dwData     = 0x1;   // Enable this report ID
                        hres = CDIDev_RealSetProperty(this, DIPROP_ENABLEREPORTID, &dipdw.diph);
                        if ( hres == E_NOTIMPL )
                        {
                            hres = S_OK;
                        }
                        else if( FAILED( hres ) )
                        {
                            SquirtSqflPtszV(sqflDf | sqflError,
                                            TEXT("Could not set DIPROP_ENABLEREPORTID for object 0x%08x, error 0x%08x"),
                                            pAction->dwObjID, hres);
                            /* 
                             *  Ouch! Can't carry on or the error will be lost so quit
                             */
                            break;
                        }


                        /*
                         *  Set the default axis parameters
                         */
                        if( DISEM_TYPE_GET( pAction->dwSemantic ) == DISEM_TYPE_GET( DISEM_TYPE_AXIS ) )
                        {
                            if( podfFound->dwType & DIDFT_ABSAXIS )
                            {
                                if( !fAxisModeKnown )
                                {
                                    fAxisModeKnown = TRUE;
                                    dwAxisMode = DIPROPAXISMODE_ABS;
                                }
                                    
                                if( !( pAction->dwFlags & DIA_NORANGE )
                                  && ( diprange.lMin | diprange.lMax ) )
                                {
                                    diprange.diph.dwObj = podfFound->dwType;
                                    hres = CDIDev_RealSetProperty(this, DIPROP_RANGE, &diprange.diph);
                                    if( FAILED( hres ) )
                                    {
                                        SquirtSqflPtszV(sqflDf | sqflBenign,
                                            TEXT("failed (0x%08x) to set range on mapped axis action"),
                                            hres );
                                    }
                                    /*
                                     *  Ranges cannot be set on natively relative
                                     *  axes so don't worry what the result is.
                                     */
                                    hres = S_OK;
                                }
                            }
                            else
                            {
                                /*
                                 *  dwAxisMode is initialized to DIPROPAXISMODE_REL 
                                 *  so that this code path is the same as the one 
                                 *  for DIDF_ABSAXIS as far as it goes.  Compilers 
                                 *  are good at delaying branches to remove such 
                                 *  duplication.
                                 */
                                if( !fAxisModeKnown )
                                {
                                    fAxisModeKnown = TRUE;
                                }
                            }
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqflDf | sqflError,
                            TEXT("mapped action format contains invalid object 0x%08x"),
                            pAction->dwObjID );
                        hres = E_INVALIDARG;
                        goto done;
                    }
                }
            }
#ifdef XDEBUG
            else
            {
                if( ( pAction->dwHow & ~DIAH_VALID ) 
                 || ( pAction->dwHow & DIAH_ERROR ) 
                 || ( pAction->dwFlags & ~DIA_VALID ) )
                {
                    SquirtSqflPtszV(sqflDf | sqflBenign,
                        TEXT("action format contains invalid object 0x%08x"),
                        pAction->dwObjID );
                    RPF("rgoAction[%d].dwHow 0x%08x or rgoAction[%d].dwFlags 0x%08x is invalid", 
                        pAction - paf->rgoAction, pAction->dwHow, 
                        pAction - paf->rgoAction, pAction->dwFlags );
                }
            }
#endif
        }

        if( !fSomethingMapped )
        {
            SquirtSqflPtszV(sqflDf | sqflBenign, TEXT("No actions mapped") );
            hres = DI_NOEFFECT;
            goto done;
        }

#ifdef DEBUG
        /*
         *  Double-check the lookup tables just to preserve our sanity.
         */
        {
            UINT dwOfs;

            for ( dwOfs = 0; dwOfs < paf->dwNumActions; dwOfs++ )
            {
                if ( rgiobj[dwOfs] >= 0 ) {
                    AssertF(pdix[rgiobj[dwOfs]].dwOfs == dwOfs);
                } else {
                    AssertF(rgiobj[dwOfs] == -1);
                }
            }
        }
#endif

        vdf.pvi = this->pvi;

        if ( fLimpFF(this->pvi,
                     SUCCEEDED(hres = Hel_SetDataFormat(&vdf))) ) {
            this->pdix = pdix;
            pdix = 0;
            this->rgiobj = rgiobj;
            rgiobj = 0;
            this->dwDataSize = paf->dwDataSize;

            /*
             *  Now that the lower level knows what it's dealing with set
             *  the default buffer size.
             */
            dipdw.diph.dwObj = 0;
            dipdw.diph.dwHow = DIPH_DEVICE;
            dipdw.dwData = paf->dwBufferSize;

            hres = CDIDev_RealSetProperty(this, DIPROP_BUFFERSIZE, &dipdw.diph);
            if( SUCCEEDED( hres ) )
            {
                if( fAxisModeKnown )
                {
                    AssertF( ( dwAxisMode == DIPROPAXISMODE_REL ) || ( dwAxisMode == DIPROPAXISMODE_ABS ) );
                    dipdw.dwData = dwAxisMode;
                    D( hres = )
                    CDIDev_RealSetProperty(this, DIPROP_AXISMODE, &dipdw.diph);
                    AssertF( SUCCEEDED( hres ) );
                }

                /*
                 *  Complete success, whatever (success) SetProperty returns
                 *  assume that DIPROP_AXISMODE will never fail from here.
                 */
                hres = S_OK;
            }
            else
            {
                SquirtSqflPtszV(sqflDf | sqflError,
                    TEXT("failed (0x%08x) to set buffer size 0x%0x8 for device"),
                    hres );
                hres = E_INVALIDARG;
            }
        } else {
            AssertF(FAILED(hres));
        }

    } else {
        /* Out of memory */
    }

    done:;
    FreePpv(&pdix);
    FreePpv(&rgiobj);
    FreePpv(&vdf.pDfOfs);

    done_without_free:;
#ifdef DEBUG
    ExitOleProc();
#endif
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | CDIDev_SetDataFormatFromMap |
 *
 *          Worker function for SetActionMapA and SetActionMapW.
 *          Used to set a data format based on passed mapped actions.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_SetDataFormatFromMap
(
    PDD                     this,
    LPDIACTIONFORMATW       paf
)
{
    HRESULT hres;

    EnterProcI(CDIDev_SetDataFormatFromMap, (_ "p", paf));

    if( !paf->dwBufferSize )
    {
        SquirtSqflPtszV(sqflDf | sqflVerbose,
            TEXT("%S: zero DIACTIONFORMAT.dwBufferSize, may need to set yourself"),
            s_szProc );
    }
    if( paf->dwBufferSize > DEVICE_MAXBUFFERSIZE )
    {
        RPF("IDirectInputDevice::%s: DIACTIONFORMAT.dwBufferSize of 0x%08x is very large",
            s_szProc, paf->dwBufferSize );
    }

    /*
     *  Must protect with the critical section to prevent two people
     *  from changing the format simultaneously, or one person from
     *  changing the data format while somebody else is reading data.
     */
    CDIDev_EnterCrit(this);

    if( !this->fAcquired )
    {
        DIPROPDWORD dipdw;

        /*
         *  Nuke the old data format stuff before proceeding.
         *  Include the "failed POV" array as we can't fail and continue.
         */
        FreePpv(&this->pdix);
        FreePpv(&this->rgiobj);
        FreePpv(&this->rgdwPOV);

        this->cdwPOV = 0;
        D(this->GetState = 0);
        this->fPolledDataFormat = FALSE;

        /*
         * Wipe out the report IDs
         */
        dipdw.diph.dwSize = sizeof(DIPROPDWORD);
        dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        dipdw.diph.dwObj = 0x0;
        dipdw.diph.dwHow = DIPH_DEVICE;
        dipdw.dwData     = 0;   // Nuke all knowledge of reportId's
        hres = CDIDev_RealSetProperty(this, DIPROP_ENABLEREPORTID, &dipdw.diph);
        if( SUCCEEDED(hres) || hres == E_NOTIMPL )
        {
            hres = CDIDev_ParseActionFormat(this, paf);

            /*
             *  If other success codes are implemented, this check should
             *  be modified to ( SUCCEEDED( hres ) && ( hres != DI_NOEFFECT ) )
             */
            AssertF( ( hres == S_OK ) || ( hres == DI_NOEFFECT ) || FAILED( hres ) );
            if( hres == S_OK )
            {
                hres = CDIDev_OptimizeDataFormat(this);
            }
        }
        else
        {
            SquirtSqflPtszV(sqflDf | sqflVerbose,
                            TEXT("Could not set DIPROP_ENABLEREPORTID to 0x0"));
        }
    }
    else
    {                                /* Already acquired */
        hres = DIERR_ACQUIRED;
    }
    CDIDev_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetActionMapCore |
 *
 *          Worker function, does all the real work for SetActionMapW and
 *          SetActionMapA.  See SetActionMapW for details.
 *
 *****************************************************************************/
STDMETHODIMP CDIDev_SetActionMapCore
(
    PDD                 this,
    LPDIACTIONFORMATW   paf,
    LPWSTR              lpwszUserName,
    LPSTR               lpszUserName,
    DWORD               dwFlags
)
{
    HRESULT hres;

    EnterProcI(IDirectInputDevice8::SetActionMapCore, (_ "pxWA", paf, dwFlags, lpwszUserName, lpszUserName ));

    if( SUCCEEDED( hres = hresFullValidFl( dwFlags, DIDSAM_VALID, 3 ) ) )
    {
        if( dwFlags & DIDSAM_NOUSER )
        {
            if( dwFlags & ~DIDSAM_NOUSER )
            {
                RPF( "IDirectInputDevice8::SetActionMap: Invalid dwFlags 0x%08x, cannot use DIDSAM_NOUSER with other flags" );
                hres = E_INVALIDARG;
            }
            else
            {
                hres = CMap_SetDeviceUserName( &this->guid, NULL );
            }
        }
        else
        {
            DWORD dwCRC;
            LPWSTR pwszGoodUserName;

            hres = GetWideUserName( lpszUserName, lpwszUserName, &pwszGoodUserName );

            if( SUCCEEDED( hres ) )
            {
                dwCRC = GetMapCRC( paf, &this->guid );

                if( ( paf->dwCRC != dwCRC )
                 || CMap_IsNewDeviceUserName( &this->guid, pwszGoodUserName ) )
                {
                    /*
                     *  Set the force save flag so we only have to test one bit later
                     */
                    dwFlags |= DIDSAM_FORCESAVE;
                }

                if( dwFlags & DIDSAM_FORCESAVE )
                {
                    hres = CMap_ValidateActionMapSemantics( paf, DIDBAM_PRESERVE );
                    if( SUCCEEDED( hres ) )
                    {
                        DWORD dwDummy;
                        hres = CMap_DeviceValidateActionMap( (PV)this, paf, DVAM_DEFAULT, &dwDummy );
                        if( FAILED( hres ) )
                        {
                            SquirtSqflPtszV(sqflDf | sqflError, TEXT("Action map invalid on SetActionMap"));
                        }
                        else if( ( hres == DI_WRITEPROTECT ) && ( paf->dwCRC != dwCRC ) )
                        {
                            RPF( "Refusing changed mappings for hardcoded device" );
                            hres = DIERR_INVALIDPARAM;
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqflDf | sqflError, TEXT("Action map invalid on SetActionMap"));
                    }
                }

                if( SUCCEEDED( hres ) )
                {
                    if( SUCCEEDED( hres = CMap_SetDeviceUserName( &this->guid, pwszGoodUserName ) )
                     && SUCCEEDED( hres = CDIDev_SetDataFormatFromMap( this, paf ) ) )
                    {
                        if( dwFlags & DIDSAM_FORCESAVE )
                        {
                            hres = CDIDev_SaveActionMap( this, paf, pwszGoodUserName, dwFlags );

                            if( SUCCEEDED( hres ) )
                            {
                                //We don't remap success code anywhere so
                                //assert it is what we expected
                                AssertF(hres==S_OK);
                                paf->dwCRC = dwCRC;
                            }
                            else
                            {
                                RPF( "Ignoring internal SaveActionMap error 0x%08x", hres );
                                hres = DI_SETTINGSNOTSAVED;
                            }
                        }
                    }
                }

                if( !lpwszUserName )
                {
                    /*
                     *  Free either the default name or the ANSI translation
                     */
                    FreePv( pwszGoodUserName );
                }
            }
        }
    }

    ExitOleProc();

    return hres;
}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetActionMap |
 *
 *          Set the data format for the DirectInput device from
 *          an action map for the passed application and user.
 *
 *          If the action map has been changed (as determined by a CRC check) 
 *          this latest map is saved after it has been applied.
 *
 *          The data format must be set before the device can be
 *          acquired.
 *
 *          It is necessary to set the data format only once.
 *
 *          The data format may not be changed while the device
 *          is acquired.
 *
 *          If the attempt to set the data format fails, all data
 *          format information is lost, and a valid data format
 *          must be set before the device may be acquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDIACTIONFORMAT | paf |
 *
 *          Points to a structure that describes the actions needed by the
 *          application.
 *
 *  @parm   LPCTSTR | lptszUserName |
 *
 *          Name of user for whom mapping is being set.  This may be a NULL
 *          pointer in which case the current user is assumed.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to control how the mapping should be set.
 *          Must be a valid combination of the <c DIDSAM_*> flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  A parameter is invalid.
 *
 *          <c DIERR_ACQUIRED>: Cannot apply an action map while the device
 *          is acquired.
 *
 *****************************************************************************/
STDMETHODIMP CDIDev_SetActionMapW
(
    PV                  pdidW,
    LPDIACTIONFORMATW   pafW,
    LPCWSTR             lpwszUserName,
    DWORD               dwFlags
)
{
    HRESULT hres;

    EnterProcR(IDirectInputDevice8W::SetActionMap, (_ "ppWx", pdidW, pafW, lpwszUserName, dwFlags));

    if( ( SUCCEEDED( hres = hresPvW( pdidW ) ) )
     && ( SUCCEEDED( hres = CDIDev_ActionMap_IsValidMapObject( pafW D(comma s_szProc comma 1) ) ) ) )
    {
        if( pafW->dwSize != cbX(DIACTIONFORMATW) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMAT.dwSize 0x%08x",
                s_szProc, pafW->dwSize ); )
            hres = E_INVALIDARG;
        }
        else
        {    
            hres = CDIDev_SetActionMapCore( _thisPvNm( pdidW, ddW ), 
                pafW, (LPWSTR)lpwszUserName, NULL, dwFlags );
        }
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetActionMapA |
 *
 *          ANSI version of SetActionMap, see SetActionMapW for details.
 *
 *
 *****************************************************************************/
STDMETHODIMP CDIDev_SetActionMapA
(
    PV                  pdidA,
    LPDIACTIONFORMATA   pafA,
    LPCSTR              lpszUserName,
    DWORD               dwFlags
)
{
    HRESULT hres;

    EnterProcR(IDirectInputDevice8A::SetActionMap, (_ "ppAx", pdidA, pafA, lpszUserName, dwFlags));

    if( ( SUCCEEDED( hres = hresPvA( pdidA ) ) )
     && ( SUCCEEDED( hres = CDIDev_ActionMap_IsValidMapObject( 
        (LPDIACTIONFORMATW)pafA D(comma s_szProc comma 1) ) ) ) )
    {
        if( pafA->dwSize != cbX(DIACTIONFORMATA) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMAT.dwSize 0x%08x",
                s_szProc, pafA->dwSize ); )
            hres = E_INVALIDARG;
        }
        else
        {    
            /*
             *  For the sake of the mapper DLLs validation set the size to 
             *  the UNICODE version.  If we ever send this to an external 
             *  component we should do this differently.
             */
            pafA->dwSize = cbX(DIACTIONFORMATW);

            /*
             *  Note, the ANSI user name is passed on as there may be no need 
             *  to translate it.  CDIDev_SetActionMapCore deals with this.
             */
            hres = CDIDev_SetActionMapCore( _thisPvNm( pdidA, ddA ), 
                (LPDIACTIONFORMATW)pafA, NULL, (LPSTR)lpszUserName, dwFlags );

            pafA->dwSize = cbX(DIACTIONFORMATA);
        }
    }

    ExitOleProc();

    return hres;
}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetImageInfo |
 *
 *          Retrieves device image information for use in displaying a 
 *          configuration UI for a single device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDIDEVICEIMAGEINFOHEADER | pih |
 *
 *          Pointer to structure into which the info is retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  A parameter is invalid.
 *
 *          <c DIERR_NOTFOUND>:  The device has no image information.
 *
 *****************************************************************************/

STDMETHODIMP CDIDev_GetImageInfoCore
(
    PDD                         this,
    LPDIDEVICEIMAGEINFOHEADERW  piih
)
{
    HRESULT hres;

    EnterProcI(CDIDev_GetImageInfoCore, (_ "p", piih));

    if( piih->dwSize != cbX( *piih ) )
    {
        D( RPF("IDirectInputDevice::%s: Invalid DIDEVICEIMAGEINFOHEADER.dwSize 0x%08x",
            s_szProc, piih->dwSize ); )
        hres = E_INVALIDARG;
    }
    else if( ( piih->lprgImageInfoArray )
     && ( piih->dwBufferSize < piih->dwSizeImageInfo ) )
    {
        D( RPF("IDirectInputDevice::%s: Invalid DIDEVICEIMAGEINFOHEADER.dwBufferSize 0x%08x",
            s_szProc, piih->dwBufferSize ); )
        hres = E_INVALIDARG;
    }
    else if( piih->dwBufferSize && !piih->lprgImageInfoArray )
    {
        D( RPF("IDirectInputDevice::%s: Invalid DIDEVICEIMAGEINFOHEADERW has dwBufferSize 0x%08x but NULL lprgImageInfoArray",
            s_szProc, piih->dwBufferSize ); )
        hres = E_INVALIDARG;
    }
    else
    {
        LPDIPROPSTRING pdipMapFile;

        if( SUCCEEDED( hres = AllocCbPpv(cbX(*pdipMapFile), &pdipMapFile) ) )
        {
            pdipMapFile->diph.dwSize = cbX(DIPROPSTRING);
            pdipMapFile->diph.dwHeaderSize = cbX(DIPROPHEADER);
            pdipMapFile->diph.dwObj = 0;
            pdipMapFile->diph.dwHow = DIPH_DEVICE;

            /*
             *  Must have an IHV file for image info
             */
            hres = CDIDev_GetPropertyW( &this->ddW, DIPROP_MAPFILE, &pdipMapFile->diph );
            if( SUCCEEDED( hres ) )
            {
                /*
                 *  ISSUE-2001/03/29-timgill workaraound code needs to be removed
                 *  Initializing this to zero works around most of 34453 
                 *  Remove when that is fixed in DIMap.dll
                 */
                piih->dwBufferUsed = 0;
                
                hres = this->pMS->lpVtbl->GetImageInfo( this->pMS, &this->guid, pdipMapFile->wsz, piih );
                if( SUCCEEDED( hres ) )
                {
                    piih->dwcButtons = this->dc3.dwButtons;
                    piih->dwcAxes    = this->dc3.dwAxes;
                    piih->dwcPOVs    = this->dc3.dwPOVs;

                    AssertF( ( piih->dwBufferSize == 0 )
                          || ( piih->dwBufferSize >= piih->dwBufferUsed ) );
                }
                else
                {
                    /*
                     *  Use the same return code for all internal DIMap errors
                     */
                    if( ( HRESULT_FACILITY( hres ) == FACILITY_ITF ) 
                     && ( HRESULT_CODE( hres ) > 0x0600 ) )
                    {
                        AssertF( HRESULT_CODE( hres ) < 0x0680 );
                        RPF( "Internal GetImageInfo error 0x%08x", hres );
                        hres = DIERR_MAPFILEFAIL;
                    }
                }
            }
            else
            {
                /*
                 *  Use the same return code for all forms of not found
                 */
                hres = DIERR_NOTFOUND;
            }

            FreePv( pdipMapFile );
        }
    }

#ifdef DEBUG
    ExitOleProc();
#endif

    return hres;
}


STDMETHODIMP CDIDev_GetImageInfoW
(
    PV                          pdidW,
    LPDIDEVICEIMAGEINFOHEADERW  piih
)
{
    HRESULT hres;

    EnterProcR(IDirectInputDevice8W::GetImageInfo, (_ "pp", pdidW, piih));

    if( SUCCEEDED(hres = hresPvW( pdidW ) )
     && SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb( piih, *piih, 1 ) ) )
    {
        ScrambleBuf( &piih->dwcViews, cbX( piih->dwcViews ) );
        ScrambleBuf( &piih->dwcButtons, cbX( piih->dwcButtons ) );
        ScrambleBuf( &piih->dwcAxes, cbX( piih->dwcAxes ) );
        ScrambleBuf( &piih->dwBufferUsed, cbX( piih->dwBufferUsed ) );

        if( piih->dwSizeImageInfo != cbX( *piih->lprgImageInfoArray ) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIDEVICEIMAGEINFOHEADERW.dwSizeImageInfo 0x%08x",
                s_szProc, piih->dwSizeImageInfo ); )
            hres = E_INVALIDARG;
        }
        else if( SUCCEEDED(hres = hresFullValidWriteLargePvCb( 
            piih->lprgImageInfoArray, piih->dwBufferSize, 1 ) ) )
        {
            PDD this;

            this = _thisPvNm(pdidW, ddW);

            hres = CDIDev_GetImageInfoCore( this, piih );
        }
    }

    ExitOleProc();

    return hres;
}


STDMETHODIMP CDIDev_GetImageInfoA
(
    PV                          pdidA,
    LPDIDEVICEIMAGEINFOHEADERA  piih
)
{
    HRESULT hres;

    EnterProcR(IDirectInputDevice8A::GetImageInfo, (_ "pp", pdidA, piih));

    if( SUCCEEDED(hres = hresPvA( pdidA ) )
     && SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb( piih, *piih, 1 ) ) )
    {
        ScrambleBuf( &piih->dwcViews, cbX( piih->dwcViews ) );
        ScrambleBuf( &piih->dwcButtons, cbX( piih->dwcButtons ) );
        ScrambleBuf( &piih->dwcAxes, cbX( piih->dwcAxes ) );
        ScrambleBuf( &piih->dwBufferUsed, cbX( piih->dwBufferUsed ) );

        if( piih->dwSizeImageInfo != cbX( *piih->lprgImageInfoArray ) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIDEVICEIMAGEINFOHEADERA.dwSizeImageInfo 0x%08x",
                s_szProc, piih->dwSizeImageInfo ); )
            hres = E_INVALIDARG;
        }
        else if( SUCCEEDED(hres = hresFullValidWriteLargePvCb( 
            piih->lprgImageInfoArray, piih->dwBufferSize, 1 ) ) )
        {
            PDD this;
            DIDEVICEIMAGEINFOHEADERW ihPrivate;

            ihPrivate.dwSize          = cbX( ihPrivate );
            ihPrivate.dwSizeImageInfo = cbX( *ihPrivate.lprgImageInfoArray );
            ihPrivate.dwBufferSize    = cbX( *ihPrivate.lprgImageInfoArray ) 
                * ( piih->dwBufferSize / cbX( *piih->lprgImageInfoArray ) );

            hres = AllocCbPpv( ihPrivate.dwBufferSize, &ihPrivate.lprgImageInfoArray );
            if( SUCCEEDED( hres ) )
            {
                this = _thisPvNm(pdidA, ddA);

                hres = CDIDev_GetImageInfoCore( this, &ihPrivate );

                if( SUCCEEDED( hres ) )
                {
                    LPDIDEVICEIMAGEINFOW piiW;
                    LPDIDEVICEIMAGEINFOA piiA = piih->lprgImageInfoArray;

                    CAssertF( cbX( *piiA ) - cbX( piiA->tszImagePath ) == cbX( *piiW ) - cbX( piiW->tszImagePath ) );
                    CAssertF( FIELD_OFFSET( DIDEVICEIMAGEINFOA, tszImagePath ) == 0 );
                    CAssertF( FIELD_OFFSET( DIDEVICEIMAGEINFOW, tszImagePath ) == 0 );
                    CAssertF( FIELD_OFFSET( DIDEVICEIMAGEINFOW, dwFlags ) == cbX( piiW->tszImagePath ) );
                    
                    if(ihPrivate.lprgImageInfoArray)
                    {
                        for( piiW = ihPrivate.lprgImageInfoArray; 
                                (PBYTE)piiW < (PBYTE)ihPrivate.lprgImageInfoArray + ihPrivate.dwBufferUsed;
                                piiW++ )
                        {
                            UToA( piiA->tszImagePath, cbX( piiA->tszImagePath ), piiW->tszImagePath );
                            memcpy( (PV)&piiA->dwFlags, (PV)&piiW->dwFlags, 
                                cbX( *piiA ) - cbX( piiA->tszImagePath ) );
                            piiA++;
                        }
                    }

                    piih->dwBufferUsed = cbX( *piih->lprgImageInfoArray )
                        * ( ihPrivate.dwBufferUsed / cbX( *ihPrivate.lprgImageInfoArray ) );

                    piih->dwcViews = ihPrivate.dwcViews;
                    piih->dwcButtons = ihPrivate.dwcButtons;
                    piih->dwcAxes = ihPrivate.dwcAxes;
                    piih->dwcPOVs = ihPrivate.dwcPOVs;
                }

                FreePv( ihPrivate.lprgImageInfoArray );
            }
        }
    }
    ExitOleProc();
    
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetDeviceState |
 *
 *          Obtains instantaneous data from the DirectInput device.
 *
 *          Before device data can be obtained, the data format must
 *          be set via <mf IDirectInputDevice::SetDataFormat>, and
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | cbData |
 *
 *          The size of the buffer pointed to by <p lpvData>, in bytes.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Points to a structure that receives the current state
 *          of the device.
 *          The format of the data is established by a prior call
 *          to <mf IDirectInputDevice::SetDataFormat>.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_PENDING>: The device does not have data yet.
 *          Some devices (such as USB joysticks) require a delay
 *          between the time the device is turned on and the time
 *          the device begins sending data.  During this "warm-up" time,
 *          <mf IDirectInputDevice::GetDeviceState> will return
 *          <c E_PENDING>.  When data becomes available, the event
 *          notification handle will be signalled.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer or
 *          the <p cbData> parameter does not match the data size
 *          set by a previous call to <mf IDirectInputDevice::SetDataFormat>.
 *
 *****************************************************************************/
extern  STDMETHODIMP CDIDev_Acquire(PV pdd _THAT);


STDMETHODIMP
CDIDev_GetDeviceState(PV pdd, DWORD cbDataSize, LPVOID pvData _THAT)
{
    HRESULT hres;
    PDD this;
    EnterProcR(IDirectInputDevice8::GetDeviceState, (_ "pp", pdd, pvData));

    /*
     *  Note that we do not validate the parameters.
     *  The reason is that GetDeviceState is an inner loop function,
     *  so it should be as fast as possible.
     */
#ifdef XDEBUG
    hresPvT(pdd);
    hresFullValidWritePvCb(pvData, cbDataSize, 1);
#endif
    this = _thisPv(pdd);

    /*
     *  Must protect with the critical section to prevent somebody from
     *  unacquiring while we're reading.
     */
    CDIDev_EnterCrit(this);

    /*
     *  Reacquire is not allowed until after Win98 SE, see OSR Bug # 89958
     */
    if ( this->diHacks.fReacquire &&
         !this->fAcquired && (this->fOnceAcquired || this->fOnceForcedUnacquired) )
    {
        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
			// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            RPF(" DirectInput: Auto acquired (0x%p)", pdd);
        }
    }

  #ifdef WINNT
    if( this->fUnacquiredWhenIconic && !IsIconic(this->hwnd) ) {
        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
            this->fUnacquiredWhenIconic = 0;
            RPF(" DirectInput: Auto acquired device (0x%p) after being iconic. ", pdd);
        }
    }
  #endif

    if ( this->fAcquired ) {
        AssertF(this->pdix);    /* Acquire shouldn't let you get this far */
        AssertF(this->GetState);
        AssertF(this->GetDeviceState);
        AssertF(this->pdcb);

        if ( this->dwDataSize == cbDataSize ) {
#ifndef DEBUG_STICKY
            hres = this->GetState(this, pvData);
#else
            PBYTE pbDbg;
            TCHAR tszDbg[80];

            hres = this->GetState(this, pvData);

            for( pbDbg=(PBYTE)pvData; pbDbg<((PBYTE)pvData+cbDataSize); pbDbg++ )
            {
                if( *pbDbg )
                {
                    wsprintf( tszDbg, TEXT("GotState @ 0x%02x, 0x%02x\r\n"), pbDbg-(PBYTE)pvData, *pbDbg );
                    OutputDebugString( tszDbg );
                }
            }
#endif /* DEBUG_STICKY */            

            if ( SUCCEEDED(hres) ) {
                UINT idw;

                AssertF(hres == S_OK);
                /*
                 *  Icky POV hack for apps that don't check if they have
                 *  a POV before reading from it.
                 */
                for ( idw = 0; idw < this->cdwPOV; idw++ ) {
                    DWORD UNALIGNED *pdw = pvAddPvCb(pvData, this->rgdwPOV[idw]);
                    *pdw = JOY_POVCENTERED;
                }
                hres = S_OK;
            } else if ( hres == DIERR_INPUTLOST ) {
                RPF("%s: Input lost", s_szProc);
                CDIDev_InternalUnacquire(this);

                hres = DIERR_INPUTLOST;
            }
        } else {
            RPF("ERROR %s: arg %d: invalid value", s_szProc, 1);
            hres = E_INVALIDARG;
        }
    } else {
        hres = this->hresNotAcquired;
    }

    if ( FAILED(hres) ) {
        ScrambleBuf(pvData, cbDataSize);
    }

    CDIDev_LeaveCrit(this);
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | CookDeviceData |
 *
 *          Cook device data that was recently obtained from the
 *          device buffer.
 *
 *          Right now, only the joystick device requires cooking,
 *          and nobody in their right mind uses buffered joystick
 *          data, and the joystick has only a few objects, so we
 *          can afford to be slow on this.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | cdod |
 *
 *          Number of objects to cook.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.  The dwOfs are really
 *          device object indexes (relative to the device format).
 *          After calling the callback, we convert them into
 *          application data format offsets.
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_CookDeviceData(PDD this, DWORD cdod, LPDIDEVICEOBJECTDATA rgdod)
{
    EnterProc(IDirectInputDevice8::CookDeviceData,
              (_ "pxp", this, cdod, rgdod));

    AssertF(this->fCook);

    /*
     *  Relative data does not need to be cooked by the callback.
     */
    if( ( this->pvi->fl & VIFL_RELATIVE ) == 0 )
    {
        this->pdcb->lpVtbl->CookDeviceData(this->pdcb, cdod, rgdod);
    }

    /*
     *  Step through array converting to application data format offsets 
     *  including adding the uAppData
     */

    for( ; cdod; cdod--,rgdod++ )
    {
        rgdod->uAppData = this->pdix[rgdod->dwOfs].uAppData;
        rgdod->dwOfs = this->pdix[rgdod->dwOfs].dwOfs;
    }

    ExitProc();
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SOMEDEVICEDATA |
 *
 *          Instance data used by <mf IDirectInputDevice::GetSomeDeviceData>.
 *
 *  @field  DWORD | celtIn |
 *
 *          Number of elements remaining in output buffer.
 *
 *  @field  PDOD | rgdod |
 *
 *          Output buffer for data elements, or <c NULL> if
 *          elements should be discarded.
 *
 *  @field  DWORD | celtOut |
 *
 *          Number of elements actually copied (so far).
 *
 *****************************************************************************/

typedef struct SOMEDEVICEDATA {
    DWORD   celtIn;
    PDOD    rgdod;
    DWORD   celtOut;
} SOMEDEVICEDATA, *PSOMEDEVICEDATA;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method PDOD | IDirectInputDevice | GetSomeDeviceData |
 *
 *          Obtains a small amount of
 *          buffered data from the DirectInput device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   PDOD | pdod |
 *
 *          First element to copy.
 *
 *  @parm   DWORD | celt |
 *
 *          Maximum number of elements to copy.
 *
 *  @parm   PSOMEDEVICEDATA | psdd |
 *
 *          Structure describing the state of the ongoing
 *          <mf IDirectInputDevice::GetDeviceData>.
 *
 *  @returns
 *
 *          Returns a pointer to the first uncopied item.
 *
 *****************************************************************************/

LPDIDEVICEOBJECTDATA_DX3 INTERNAL
CDIDev_GetSomeDeviceData
(
    PDD                         this,
    LPDIDEVICEOBJECTDATA_DX3    pdod,
    DWORD                       celt,
    PSOMEDEVICEDATA             psdd
)
{
#ifdef XDEBUG
    DWORD cCopied;
#endif

    EnterProc(IDirectInputDevice8::GetSomeDeviceData,
              (_ "ppxx", this, pdod, celt, psdd->celtIn));

    /*
     *  Copy as many elements as fit, but not more than exist
     *  in the output buffer.
     */
    if ( celt > psdd->celtIn ) {
        celt = psdd->celtIn;
    }

#ifdef XDEBUG
    cCopied = celt;
#endif
    /*
     *  Copy the elements (if requested) and update the state.
     *  Note that celt might be zero.
     */
    psdd->celtOut += celt;
    psdd->celtIn -= celt;

    if( psdd->rgdod )
    {
        LPDIDEVICEOBJECTDATA pdod8;
        pdod8 = psdd->rgdod;

        if( this->fCook )
        {
            /*
             *  For a cooked device, leave the offset untranslated so that it 
             *  can be used to find the appropriate calibration data.
             */
            for( ; celt ; celt-- )
            {
                pdod8->dwOfs = pdod->dwOfs;
                pdod8->dwData = pdod->dwData;
                pdod8->dwTimeStamp = pdod->dwTimeStamp;
                pdod8->dwSequence = pdod->dwSequence;

                pdod++;
                pdod8++;
            }
        }
        else
        {
            for( ; celt ; celt-- )
            {
                pdod8->dwOfs = this->pdix[pdod->dwOfs].dwOfs;
                pdod8->uAppData = this->pdix[pdod->dwOfs].uAppData;
                pdod8->dwData = pdod->dwData;
                pdod8->dwTimeStamp = pdod->dwTimeStamp;
                pdod8->dwSequence = pdod->dwSequence;

                pdod++;
                pdod8++;
            }
        }
        psdd->rgdod = pdod8;
    }
    else
    {
        pdod += celt;
    }


    if ( pdod == this->pvi->pEnd ) {
        pdod = this->pvi->pBuffer;
    }

    ExitProcX(cCopied);

    return pdod;
}

/*
 *  Keep GetDeviceData, SendDeviceData and Poll in sqflDev
 */
#undef sqfl
#define sqfl sqflDev

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetDeviceData |
 *
 *          Obtains buffered data from the DirectInput device.
 *
 *          DirectInput devices are, by default, unbuffered.  To
 *          turn on buffering, you must set the buffer size
 *          via <mf IDirectInputDevice::SetProperty>, setting the
 *          <c DIPROP_BUFFERSIZE> property to the desired size
 *          of the input buffer.
 *
 *          Before device data can be obtained, the data format must
 *          be set via <mf IDirectInputDevice::SetDataFormat>, and
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | cbObjectData |
 *
 *          The size of a single <t DIDEVICEOBJECTDATA> structure in bytes.
 *
 *  @parm   OUT LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures to receive
 *          the buffered data.  It must consist of
 *          *<p pdwInOut> elements.
 *
 *          If this parameter is <c NULL>, then the buffered data is
 *          not stored anywhere, but all other side-effects take place.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          On entry, contains the number of elements in the array
 *          pointed to by <p rgdod>.  On exit, contains the number
 *          of elements actually obtained.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags which control the manner in which data is obtained.
 *          It may be zero or more of the following flags:
 *
 *          <c DIGDD_PEEK>: Do not remove the items from the buffer.
 *          A subsequent <mf IDirectInputDevice::GetDeviceData> will
 *          read the same data.  Normally, data is removed from the
 *          buffer after it is read.
 *
;begin_internal dx4
 *          <c DIGDD_RESIDUAL>:  Read data from the device buffer
 *          even if the device is not acquired.  Normally, attempting
 *          to read device data from an unacquired device will return
 *          <c DIERR_NOTACQUIRED> or <c DIERR_INPUTLOST>.
;end_internal dx4
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: All data were retrieved
 *          successfully.  Note that the application needs to check
 *          the output value of *<p pdwInOut> to determine whether
 *          and how much data was retrieved:  The value may be zero,
 *          indicating that the buffer was empty.
 *
 *          <c DI_BUFFEROVERFLOW> = <c S_FALSE>: Some data
 *          were retrieved successfully, but some data were lost
 *          because the device's buffer size was not large enough.
 *          The application should retrieve buffered data more frequently
 *          or increase the device buffer size.  This status code is
 *          returned only on the first <mf IDirectInput::GetDeviceData>
 *          call after the buffer has overflowed.  Note that this is
 *          a success status code.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  One or more
 *          parameters was invalid.  A common cause for this is
 *          neglecting to set a buffer size.
 *
 *          <c DIERR_NOTBUFFERED>:  The device is not buffered.
 *          Set the <c DIPROP_BUFFERSIZE> property to enable buffering.
 *
 *  @ex
 *
 *          The following sample reads up to ten buffered data elements,
 *          removing them from the device buffer as they are read.
 *
 *          |
 *
 *          DIDEVICEOBJECTDATA rgdod[10];
 *          DWORD dwItems = 10;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      rgdod,
 *                      &dwItems,
 *                      0);
 *          if (SUCCEEDED(hres)) {
 *              // Buffer successfully flushed.
 *              // dwItems = number of elements flushed
 *              if (hres == DI_BUFFEROVERFLOW) {
 *                  // Buffer had overflowed.
 *              }
 *          }
 *
 *
 *
 *
 *  @ex
 *
 *          If you pass <c NULL> for the <p rgdod> and request an
 *          infinite number of items, this has the effect of flushing
 *          the buffer and returning the number of items that were
 *          flushed.
 *
 *          |
 *
 *          dwItems = INFINITE;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      NULL,
 *                      &dwItems,
 *                      0);
 *          if (SUCCEEDED(hres)) {
 *              // Buffer successfully flushed.
 *              // dwItems = number of elements flushed
 *              if (hres == DI_BUFFEROVERFLOW) {
 *                  // Buffer had overflowed.
 *              }
 *          }
 *
 *  @ex
 *
 *          If you pass <c NULL> for the <p rgdod>, request an
 *          infinite number of items, and ask that the data not be
 *          removed from the device buffer, this has the effect of
 *          querying for the number of elements in the device buffer.
 *
 *          |
 *
 *          dwItems = INFINITE;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      NULL,
 *                      &dwItems,
 *                      DIGDD_PEEK);
 *          if (SUCCEEDED(hres)) {
 *              // dwItems = number of elements in buffer
 *              if (hres == DI_BUFFEROVERFLOW) {
 *                  // Buffer overflow occurred; not all data
 *                  // were successfully captured.
 *              }
 *          }
 *
 *  @ex
 *
 *          If you pass <c NULL> for the <p rgdod> and request zero
 *          items, this has the effect of querying whether buffer
 *          overflow has occurred.
 *
 *          |
 *
 *          dwItems = 0;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      NULL,
 *                      &dwItems,
 *                      0);
 *          if (hres == DI_BUFFEROVERFLOW) {
 *              // Buffer overflow occurred
 *          }
 *
 *
 *//**************************************************************************
 *
 *      When reading this code, the following pictures will come in handy.
 *
 *
 *      Buffer not wrapped.
 *
 *      pBuffer                                                pEnd
 *      |                                                      |
 *      v                                                      v
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      |    |    |    |data|data|data|data|data|    |    |    |
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *                     ^                        ^
 *                     |                        |
 *                     pTail                    pHead
 *
 *
 *      Buffer wrapped.
 *
 *      pBuffer                                                pEnd
 *      |                                                      |
 *      v                                                      v
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      |data|data|    |    |    |    |    |    |data|data|data|
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *                ^                             ^
 *                |                             |
 *                pHead                         pTail
 *
 *
 *      Boundary wrap case.
 *
 *
 *      pBuffer                                                pEnd
 *      |                                                      |
 *      v                                                      v
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      |    |    |    |    |    |    |data|data|data|data|data|
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      ^                             ^
 *      |                             |
 *      pHead                         pTail
 *
 *
 *      Note!  At no point is pTail == pEnd or pHead == pEnd.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceData(PV pdd, DWORD cbdod, PDOD rgdod,
                     LPDWORD pdwInOut, DWORD fl _THAT)
{
    HRESULT hres;
    PDD this;
    SOMEDEVICEDATA sdd;
    EnterProcR(IDirectInputDevice8::GetDeviceData,
               (_ "pxpxx", pdd, cbdod, rgdod,
                IsBadReadPtr(pdwInOut, cbX(DWORD)) ? 0 : *pdwInOut, fl));

    /*
     *  Note that we do not validate the parameters.
     *  The reason is that GetDeviceData is an inner loop function,
     *  so it should be as fast as possible.
     *
     *  Note also that it is legal to get device data after the device
     *  has been unacquired.  This lets you "turn on the faucet" for
     *  a short period of time, and then parse the data out later.
     */
    this = _thisPv(pdd);

#ifdef XDEBUG
    hresPvT(pdd);
    if ( IsBadWritePtr(pdwInOut, cbX(*pdwInOut)) ) {
        RPF("ERROR %s: arg %d: invalid value; crash soon", s_szProc, 3);
    }
#endif
    if( cbdod == cbX(DOD) )
    {
#ifdef XDEBUG
        /*
         *  Only check the buffer if the size is correct otherwise
         *  we can smash the stack of the caller when we've already
         *  detected the error.
         */
        if ( rgdod ) {
            hresFullValidWritePvCb(rgdod, *pdwInOut * cbdod, 2);
        }
#endif

        /*
         *  Must protect with the critical section to prevent somebody from
         *  acquiring/unacquiring or changing the data format or calling
         *  another GetDeviceData while we're reading.  (We must be serialized.)
         */
        CDIDev_EnterCrit(this);

        AssertF(CDIDev_IsConsistent(this));

        if ( SUCCEEDED(hres = hresFullValidFl(fl, DIGDD_VALID, 4)) ) {
            if ( this->celtBuf ) {
                /*
                 *  Don't try to read more than there possibly could be.
                 *  This avoids overflow conditions in case celtIn is
                 *  some absurdly huge number.
                 */
                sdd.celtIn = *pdwInOut;
                sdd.celtOut = 0;
                if ( sdd.celtIn > this->celtBuf ) {
                    sdd.celtIn = this->celtBuf;
                }
                sdd.rgdod = rgdod;


                /*
                 *  For this version of DirectInput, we do not allow
                 *  callbacks to implement their own GetDeviceData.
                 */
                if ( this->pvi ) {

                    /*
                     *  Reacquire is not allowed until after Win98 SE, see OSR Bug # 89958
                     */
                    if ( this->diHacks.fReacquire &&
                         !this->fAcquired && (this->fOnceAcquired || this->fOnceForcedUnacquired) )
                    {
                        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
							// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
                            RPF(" DirectInput: Auto acquired device (0x%p)", pdd);
                        }
                    }

                  #ifdef WINNT
                    if( this->fUnacquiredWhenIconic && !IsIconic(this->hwnd) ) {
                        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
                            this->fUnacquiredWhenIconic = 0;
                            RPF(" DirectInput: Auto acquired device (0x%p) after being iconic. ", pdd);
                        }
                    }
                  #endif

                    if ( (this->fAcquired && (this->pvi->fl & VIFL_ACQUIRED)) ||
                         (fl & DIGDD_RESIDUAL) ) {
                        /*
                         *  The device object data from the driver is always a 
                         *  DX3 (<DX8) structure
                         */
                        LPDIDEVICEOBJECTDATA_DX3 pdod, pdodHead;
                        DWORD celt;

                        /*
                         *  Snapshot the value of pdodHead, because it can
                         *  change asynchronously.  The other fields won't
                         *  change unless we ask for them to be changed.
                         */
                        pdodHead = this->pvi->pHead;

                        /*
                         *  Throughout, pdod points to the first unprocessed
                         *  element.
                         */
                        pdod = this->pvi->pTail;

                        /*
                         *  If we are wrapped, handle the initial run.
                         */
                        if ( pdodHead < this->pvi->pTail ) {
                            celt = (DWORD)(this->pvi->pEnd - this->pvi->pTail);
                            AssertF(celt);

                            pdod = CDIDev_GetSomeDeviceData( this, pdod, celt, &sdd );

                        }

                        /*
                         *  Now handle the glob from pdod to pdodHead.
                         *  Remember, pvi->pdodHead may have changed
                         *  behind our back; use the cached value to
                         *  ensure consistency.  (If we miss data,
                         *  it'll show up later.)
                         */

                        AssertF(fLimpFF(sdd.celtIn, pdodHead >= pdod));

                        celt = (DWORD)(pdodHead - pdod);
                        if ( celt ) {
                            pdod = CDIDev_GetSomeDeviceData( this, pdod, celt, &sdd );
                        }

                        *pdwInOut = sdd.celtOut;

                        if ( !(fl & DIGDD_PEEK) ) {
                            this->pvi->pTail = pdod;
                        }

                        if ( rgdod && sdd.celtOut && this->fCook ) {
                            CDIDev_CookDeviceData(this, sdd.celtOut, rgdod );
                        }

                        CAssertF(S_OK == 0);
                        CAssertF(DI_BUFFEROVERFLOW == 1);

                        hres = (HRESULT)(UINT_PTR)pvExchangePpvPv(&this->pvi->fOverflow, 0);
#ifdef DEBUG_STICKY
                        if( hres == 1 )
                        {
                            OutputDebugString( TEXT( "Device buffer overflowed\r\n" ) );
                        }
                        if( sdd.celtOut )
                        {
                            PDOD pdoddbg;
                            TCHAR tszDbg[80];

                            wsprintf( tszDbg, TEXT("GotData %d elements:  "), sdd.celtOut );
                            OutputDebugString( tszDbg );
                            for( pdoddbg=rgdod; pdoddbg<&rgdod[sdd.celtOut]; pdoddbg++ )
                            {
                                wsprintf( tszDbg, TEXT("0x%02x:x0x%08x  "), pdoddbg->dwOfs, pdoddbg->dwData );
                                OutputDebugString( tszDbg );
                            }
                            OutputDebugString( TEXT("\r\n") );
                        }
#endif /* DEBUG_STICKY */
                    } else if (this->fAcquired && !(this->pvi->fl & VIFL_ACQUIRED)) {
                        RPF("ERROR %s - %s", s_szProc, "input lost");
                        hres = DIERR_INPUTLOST;
                        CDIDev_InternalUnacquire(this);
                    } else {
                        RPF("ERROR %s: %s", s_szProc,
                            this->hresNotAcquired == DIERR_NOTACQUIRED
                            ? "Not acquired" : "Input lost");
                        hres = this->hresNotAcquired;
                    }
                } else {            /* Don't support device-side GetData yet */
                    hres = E_NOTIMPL;
                }
            } else {                /* Device is not buffered */
#ifdef XDEBUG
                if ( !this->fNotifiedNotBuffered ) {
                    this->fNotifiedNotBuffered = 1;
                    RPF("ERROR %s: arg %d: device is not buffered", s_szProc, 0);
                }
#endif
                hres = DIERR_NOTBUFFERED;
            }
        }
    }
    else
    {
        if( cbdod == cbX(DIDEVICEOBJECTDATA_DX3) )
        {
            RPF("ERROR %s: arg %d: old size, invalid for DX8", s_szProc, 1);
        }
        else
        {
            RPF("ERROR %s: arg %d: invalid value", s_szProc, 1);
        }
        hres = E_INVALIDARG;
    }

    CDIDev_LeaveCrit(this);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | Poll |
 *
 *          Retrieves data from polled objects on a DirectInput device.
 *          If the device does not require polling, then calling this
 *          method has no effect.   If a device that requires polling
 *          is not polled periodically, no new data will be received
 *          from the device.
 *
 *          Before a device data can be polled, the data format must
 *          be set via <mf IDirectInputDevice::SetDataFormat>, and
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_NOEFFECT> = <c S_FALSE>: The device does not require
 *          polling.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_Poll(PV pdd _THAT)
{
    HRESULT hres;
    PDD this;
    EnterProcR(IDirectInputDevice8::Poll, (_ "p", pdd));

    /*
     *  Note that we do not validate the parameters.
     *  The reason is that Poll is an inner loop function,
     *  so it should be as fast as possible.
     */
    #ifdef XDEBUG
    hresPvT(pdd);
    #endif
    this = _thisPv(pdd);

    /*
     *  Fast out:  If the device doesn't require polling,
     *  then don't bother with the critical section or other validation.
     */
    if ( this->fPolledDataFormat ) {
        /*
         *  Must protect with the critical section to prevent somebody from
         *  unacquiring while we're polling.
         */
        CDIDev_EnterCrit(this);

        if ( this->fAcquired ) {
            hres = this->pdcb->lpVtbl->Poll(this->pdcb);

        } else {
            hres = this->hresNotAcquired;
        }

        CDIDev_LeaveCrit(this);

    } else {
        if ( this->fAcquired ) {
            hres = S_FALSE;
        } else {
            hres = this->hresNotAcquired;
        }
    }

    /*
     *  Failing polls are really annoying so don't use ExitOleProc
     */
    if( FAILED( hres ) )
    {
        SquirtSqflPtszV(sqfl | sqflVerbose, TEXT("IDirectInputDevice::Poll failed 0x%08x"), hres );
    }

    ExitProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | SendDeviceData |
 *
 *          Sends data to the device.
 *
 *          Before device data can be sent to a device,
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *          Note that no guarantees
 *          are made on the order in which the individual data
 *          elements are sent.  However, data sent by
 *          successive calls to
 *          <mf IDirectInputDevice8::SendDeviceData>
 *          will not be interleaved.
 *          Furthermore, if multiple pieces of
 *          data are sent to the same object, it is unspecified
 *          which actual piece of data is sent.
 *
 *          Consider, for example, a device which can be sent
 *          data in packets, each packet describing two pieces
 *          of information, call them A and B.  Suppose the
 *          application attempts to send three data elements,
 *          "B = 2", "A = 1", and "B = 0".
 *
 *          The actual device will be sent a single packet.
 *          The "A" field of the packet will contain the value 1,
 *          and the "B" field of the packet will be either 2 or 0.
 *
 *          If the application wishes the data to be sent to the
 *          device exactly as specified, then three calls to
 *          <mf IDirectInputDevice8::SendDeviceData> should be
 *          performed, each call sending one data element.
 *
 *          In response to the first call,
 *          the device will be sent a packet where the "A" field
 *          is blank and the "B" field contains the value 2.
 *
 *          In response to the second call,
 *          the device will be sent a packet where the "A" field
 *          contains the value 1, and the "B" field is blank.
 *
 *          Finally, in response to the third call,
 *          the device will be sent a packet where the "A" field
 *          is blank and the "B" field contains the value 0.
 *
 *
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | cbObjectData |
 *
 *          The size of a single <t DIDEVICEOBJECTDATA> structure in bytes.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures containing
 *          the data to send to the device.  It must consist of
 *          *<p pdwInOut> elements.
 *
 *          <y Note>:  The <e DIDEVICEOBJECTDATA.dwOfs> field of
 *          the <t DIDEVICEOBJECTDATA> structure must contain the
 *          device object identifier (as obtained from the
 *          <e DIDEVICEOBJECTINSTANCE.dwType> field of the
 *          <t DIDEVICEOBJECTINSTANCE> sturcture) for the device
 *          object at which the data is directed.
 *
 *          Furthermore, the <e DIDEVICEOBJECTDATA.dwTimeStamp>
 *          <e DIDEVICEOBJECTDATA.dwSequence> and
 *          <e DIDEVICEOBJECTDATA.uAppData> fields are
 *          reserved for future use and must be zero.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          On entry, contains the number of elements in the array
 *          pointed to by <p rgdod>.  On exit, contains the number
 *          of elements actually sent to the device.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags which control the manner in which data is sent.
 *          It may consist of zero or more of the following flags:
 *
 *          <c DISDD_CONTINUE>:  If this flag is set, then
 *          the device data sent will be overlaid upon the previously
 *          sent device data.  Otherwise, the device data sent
 *          will start from scratch.
 *
 *          For example, suppose a device supports two button outputs,
 *          call them A and B.
 *          If an application first calls
 *          <mf IDirectInputDevice8::SendDeviceData> passing
 *          "button A pressed", then
 *          a packet of the form "A pressed, B not pressed" will be
 *          sent to the device.
 *          If an application then calls
 *          <mf IDirectInputDevice8::SendDeviceData> passing
 *          "button B pressed" and the <c DISDD_CONTINUE> flag, then
 *          a packet of the form "A pressed, B pressed" will be
 *          sent to the device.
 *          However, if the application had not passed the
 *          <c DISDD_CONTINUE> flag, then the packet sent to the device
 *          would have been "A not pressed, B pressed".
 *
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_SendDeviceData(PV pdd, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                      LPDWORD pdwInOut, DWORD fl _THAT)
{
    HRESULT hres;
    PDD this;
    EnterProcR(IDirectInputDevice8::SendDeviceData,
               (_ "pxpxx", pdd, cbdod, rgdod,
                IsBadReadPtr(pdwInOut, cbX(DWORD)) ? 0 : *pdwInOut, fl));

    /*
     *  Note that parameter validation is limited as SendDeviceData is 
     *  intended to be an inner loop function.  In practice SendDeviceData is 
     *  rarely used so speed is not that important.
     */
    #ifdef XDEBUG
    hresPvT(pdd);
    if ( IsBadWritePtr(pdwInOut, cbX(*pdwInOut)) ) {
        RPF("ERROR %s: arg %d: invalid value; crash soon", s_szProc, 3);
    }
    hresFullValidReadPvCb(rgdod, cbX(*pdwInOut) * cbdod, 2);
    #endif

    this = _thisPv(pdd);

    /*
     *  Must protect with the critical section to prevent somebody from
     *  unacquiring while we're sending data.
     */
    CDIDev_EnterCrit(this);

    if ( SUCCEEDED(hres = hresFullValidFl(fl, DISDD_VALID, 4)) ) {
        if( cbdod == cbX(DOD) )
        {
    #ifdef XDEBUG
            UINT iodDbg;
            LPCDIDEVICEOBJECTDATA pcdod;

            for ( iodDbg = 0, pcdod=rgdod; iodDbg < *pdwInOut; iodDbg++ ) {
                if ( pcdod->dwTimeStamp ) {
                    RPF("%s: ERROR: dwTimeStamp must be zero", s_szProc);
                }
                if ( pcdod->dwSequence ) {
                    RPF("%s: ERROR: dwSequence must be zero", s_szProc);
                }
                if( pcdod->uAppData ){
                    RPF("%s: ERROR: uAppData must be zero", s_szProc);
                }
                pcdod++;
            }
    #endif
            if ( this->fAcquired ) {
				UINT iod;
                LPDIDEVICEOBJECTDATA pdodCopy;

                hres = AllocCbPpv( cbCxX( *pdwInOut, *pdodCopy ), &pdodCopy );
                if( SUCCEEDED( hres ) )
                {
                    LPDIDEVICEOBJECTDATA pdod;
                    memcpy( pdodCopy, rgdod, cbCxX( *pdwInOut, *pdodCopy ) );

                    for( iod=0, pdod=pdodCopy; iod < *pdwInOut; iod++ ) 
                    {
                        int   iobj = CDIDev_OffsetToIobj(this, pdod->dwOfs);
                        pdod->dwOfs = this->df.rgodf[iobj].dwType;
                        pdod++;
                    }

                    hres = this->pdcb->lpVtbl->SendDeviceData(this->pdcb, cbdod,
                                                              pdodCopy, pdwInOut, fl );
                    FreePv( pdodCopy );
                }
            } else {
                hres = this->hresNotAcquired;
            }
        } else {
            RPF("ERROR %s: arg %d: invalid value", s_szProc, 1);
        }
    }

    CDIDev_LeaveCrit(this);
    ExitOleProc();
    return hres;
}


#undef sqfl
#define sqfl sqflDf

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIDev_CheckId |
 *
 *          Verify that the item has the appropriate type.
 *
 *  @parm   DWORD | dwId |
 *
 *          ID to locate.
 *
 *  @parm   UINT | fl |
 *
 *          Bitmask of flags for things to validate.
 *
 *          The <c DEVCO_TYPEMASK> fields describe what type
 *          of object we should be locating.
 *
 *          The <c DEVCO_ATTRMASK> fields describe the attribute
 *          bits that are required.
 *
 *****************************************************************************/

BOOL INLINE
CDIDev_CheckId(DWORD dwId, DWORD fl)
{
    CAssertF(DIDFT_ATTRMASK == DEVCO_ATTRMASK);

    return(dwId & fl & DEVCO_TYPEMASK) &&
    fHasAllBitsFlFl(dwId, fl & DIDFT_ATTRMASK);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | IdToIobj |
 *
 *          Locate an item which matches the specified ID.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   DWORD | dwId |
 *
 *          ID to locate.
 *
 *  @returns
 *
 *          Returns the index of the object found, or -1 on error.
 *
 *****************************************************************************/

int INTERNAL
CDIDev_IdToIobj(PDD this, DWORD dwId)
{
    int iobj;

    /* Someday: Perf:  Should have xlat table */

    for ( iobj = this->df.dwNumObjs; --iobj >= 0; ) {
        PODF podf = &this->df.rgodf[iobj];
        if ( DIDFT_FINDMATCH(podf->dwType, dwId) ) {
            goto done;
        }
    }

    iobj = -1;

    done:;
    return iobj;

}

#if 0
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | IdToId |
 *
 *          Convert a single <t DWORD> from an ID to an ID.
 *
 *          This is clearly a very simple operation.
 *
 *          It's all validation.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDWORD | pdw |
 *
 *          Single item to convert.
 *
 *  @parm   UINT | fl |
 *
 *          Bitmask of flags that govern the conversion.
 *          The function should look only at
 *          <c DEVCO_AXIS> or <c DEVCO_BUTTON>.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIDev_IdToId(PDD this, LPDWORD pdw, UINT fl)
{
    HRESULT hres;
    int iobj;

    iobj = CDIDev_FindId(this, *pdw, fl);
    if ( iobj >= 0 ) {
        *pdw = this->df.rgodf[iobj].dwType;
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | OffsetToIobj |
 *
 *          Convert a single <t DWORD> from an offset to an object index.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Offset to convert.
 *
 *****************************************************************************/

int INTERNAL
CDIDev_OffsetToIobj(PDD this, DWORD dwOfs)
{
    int iobj;

    AssertF(this->pdix);
    AssertF(this->rgiobj);

    if ( dwOfs < this->dwDataSize ) {
        iobj = this->rgiobj[dwOfs];
        if ( iobj >= 0 ) {
            AssertF(this->pdix[iobj].dwOfs == dwOfs);
        } else {
            AssertF(iobj == -1);
        }
    } else {
        iobj = -1;
    }

    return iobj;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | IobjToId |
 *
 *          Convert an object index to an ID.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   int | iobj |
 *
 *          Single item to convert.
 *
 *****************************************************************************/

DWORD INLINE
CDIDev_IobjToId(PDD this, int iobj)
{
    AssertF((DWORD)iobj < this->df.dwNumObjs);

    return this->df.rgodf[iobj].dwType;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | IobjToOffset |
 *
 *          Convert an object index to an offset.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   int | iobj |
 *
 *          Single item to convert.
 *
 *****************************************************************************/

DWORD INLINE
CDIDev_IobjToOffset(PDD this, int iobj)
{
    AssertF((DWORD)iobj < this->df.dwNumObjs);
    AssertF(this->pdix);

    return this->pdix[iobj].dwOfs;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | ConvertObjects |
 *
 *          Convert between the ways of talking about device gizmos.
 *
 *          Since this is used only by the force feedback subsystem,
 *          we also barf if the device found does not support
 *          force feedback.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   UINT | cdw |
 *
 *          Number of elements to convert (in-place).
 *
 *  @parm   LPDWORD | rgdw |
 *
 *          Array of elements to convert.
 *
 *  @parm   UINT | fl |
 *
 *          Flags that describe how to do the conversion.
 *
 *          <c DEVCO_AXIS> or <c DEVCO_BUTTON> indicate whether
 *          the item being converted is an axis or button.
 *
 *          <c DEVCO_FROM*> specifies what the existing value is.
 *
 *          <c DEVCO_TO*> specifies what the new values should be.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_ConvertObjects(PDD this, UINT cdw, LPDWORD rgdw, UINT fl)
{
    HRESULT hres;

    /*
     *  Don't let somebody change the data format while we're
     *  looking at it.
     */
    CDIDev_EnterCrit(this);

    AssertF((fl & ~DEVCO_VALID) == 0);

    if ( fLimpFF(fl & (DEVCO_FROMOFFSET | DEVCO_TOOFFSET),
                 this->pdix && this->rgiobj) ) {
        UINT idw;

        for ( idw = 0; idw < cdw; idw++ ) {

            /*
             *  Convert from its source to an object index,
             *  validate the object index, then convert to
             *  the target.
             */
            int iobj;

            switch ( fl & DEVCO_FROMMASK ) {
            default:
                AssertF(0);                     /* Huh? */
            case DEVCO_FROMID:
                iobj = CDIDev_IdToIobj(this, rgdw[idw]);
                break;

            case DEVCO_FROMOFFSET:
                iobj = CDIDev_OffsetToIobj(this, rgdw[idw]);
                break;
            }

            if ( iobj < 0 ) {
                hres = E_INVALIDARG;            /* Invalid object */
                goto done;
            }

            AssertF((DWORD)iobj < this->df.dwNumObjs);

            if ( !CDIDev_CheckId(this->df.rgodf[iobj].dwType, fl) ) {
                hres = E_INVALIDARG;            /* Bad attributes */
                goto done;
            }

            switch ( fl & DEVCO_TOMASK ) {

            default:
                AssertF(0);                     /* Huh? */
            case DEVCO_TOID:
                rgdw[idw] = CDIDev_IobjToId(this, iobj);
                break;

            case DEVCO_TOOFFSET:
                rgdw[idw] = CDIDev_IobjToOffset(this, iobj);
                break;
            }

        }

        hres = S_OK;

        done:;

    } else {
        RPF("ERROR: Must have a data format to use offsets");
        hres = E_INVALIDARG;
    }

    CDIDev_LeaveCrit(this);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\didevef.c ===
/*****************************************************************************
 *
 *  DIDevEf.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The part of IDirectInputDevice that worries about
 *      IDirectInputEffect.
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "didev.h"


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | CreateEffectDriver |
 *
 *          If we don't already have one, create the effect
 *          driver shepherd
 *          so we can do force feedback goo.  If we already
 *          have one, then there's nothing to do.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device does
 *          not support force feeback, or there was an error loading
 *          the force feedback driver.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIDev_CreateEffectDriver(PDD this)
{
    HRESULT hres;

    CDIDev_EnterCrit(this);

    if (this->pes) {
        hres = S_OK;
    } else {
        hres = this->pdcb->lpVtbl->CreateEffect(this->pdcb, &this->pes);

        /*
         *  If we have acquisition, then do a force feedback
         *  acquire to get everything back in sync.
         */
        if (SUCCEEDED(hres) && this->fAcquired) {
            CDIDev_FFAcquire(this);
            hres = S_OK;
        }
    }

    CDIDev_LeaveCrit(this);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | CreateEffect |
 *
 *          Creates and initializes an instance of an effect
 *          identified by the effect GUID.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          The identity of the effect to be created.  This can be
 *          a predefined effect GUID, or it can be a GUID obtained
 *          from <mf IDirectInputDevice8::EnumEffects>.
 *
 *  @parm   IN LPCDIEFFECT | lpeff |
 *
 *          Pointer to a <t DIEFFECT> structure which provides
 *          parameters for the created effect.  This parameter
 *          is optional.  If it is <c NULL>, then the effect object
 *          is created without parameters.  The application must
 *          call <mf IDirectInputEffect::SetParameters> to set
 *          the parameters of the effect before it can download
 *          the effect.
 *
 *  @parm   OUT LPDIRECTINPUTEFFECT * | ppdeff |
 *
 *          Points to where to return
 *          the pointer to the <i IDirectInputEffect> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter |
 *
 *          Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The object was created and initialized
 *          successfully.
 *
 *          <c DI_TRUNCATED>: The effect was successfully created,
 *          but some of the effect parameters were
 *          beyond the capabilities of the device and were truncated
 *          to the nearest valid value.
 *          Note that this is a success code, because the effect was
 *          successfully created.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID is not supported
 *          by the device.
 *
 *          <c DIERR_DEVICEFULL>: The device is full.
 *
 *          <c DIERR_INVALIDPARAM>: At least one of the parameters
 *          was invalid.
 *
 *
 *  @devnote
 *
 *          Future versions of DirectX will allow <p lpeff> to be NULL,
 *          indicating that the effect should not be initialized.
 *          This is important to support effects which are created
 *          but which aren't downloaded until the app explicitly
 *          requests it.
 *
 *****************************************************************************/

/*
 *  Helper function which decides how many parameters to set,
 *  based on the incoming DIEFFECT structure.
 */
DWORD INLINE
CDIDev_DiepFromPeff(LPCDIEFFECT peff)
{
    /*
     *  If we received a DIEFFECT_DX5, then we need to
     *  pass DIEP_ALLPARAMS_DX5 instead of DIEP_ALLPARAMS.
     */
    return peff->dwSize < cbX(DIEFFECT_DX6)
                        ? DIEP_ALLPARAMS_DX5
                        : DIEP_ALLPARAMS;
}

STDMETHODIMP
CDIDev_CreateEffect(PV pdd, REFGUID rguid, LPCDIEFFECT peff,
                    LPDIRECTINPUTEFFECT *ppdeff, LPUNKNOWN punkOuter _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::CreateEffect,
               (_ "pGpp", pdd, rguid, peff, punkOuter));

    /*
     *  CDIEff_New will validate the ppdeff and punkOuter, but
     *  we need to validate ppdeff because we're going to
     *  shove a zero into it.
     *
     *  We also need to check peff->dwSize as we need to test it 
     *  before calling IDirectInputEffect_SetParameters.
     *
     *  CDIEff_Initialize will validate the rguid.
     *
     *  CDIEff_SetParameters will validate the peff.
     */
    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = (peff && IsBadReadPtr(&peff->dwSize, cbX(peff->dwSize))) ? E_POINTER : S_OK) &&
        SUCCEEDED(hres = hresFullValidPcbOut(ppdeff, cbX(*ppdeff), 4))) {

        PDD this = _thisPv(pdd);

        hres = CDIDev_CreateEffectDriver(this);

        *ppdeff = 0;                /* If CDIDev_CreateEffectDriver fails */

        if (SUCCEEDED(hres)) {

            hres = CDIEff_New(this, this->pes, punkOuter,
                              &IID_IDirectInputEffect, (PPV)ppdeff);

            /*
             *  We assume that IDirectInputEffect is the primary interface.
             */
            AssertF(fLimpFF(SUCCEEDED(hres),
                            (PV)*ppdeff == _thisPv(*ppdeff)));

            if (SUCCEEDED(hres) && punkOuter == 0) {
                LPDIRECTINPUTEFFECT pdeff = *ppdeff;

                hres = IDirectInputEffect_Initialize(pdeff, g_hinst,
                                                     this->dwVersion, rguid);
                if (SUCCEEDED(hres)) {
                    if (fLimpFF(peff,
                                SUCCEEDED(hres =
                                    IDirectInputEffect_SetParameters(
                                        pdeff, peff,
                                        CDIDev_DiepFromPeff(peff))))) {
                        /*
                         *  Woo-hoo, all is well.
                         */
                        hres = S_OK;
                    } else {
                        Invoke_Release(ppdeff);
                    }
                } else {
                    /*
                     *  Error initializing.
                     */
                    Invoke_Release(ppdeff);
                }
            } else {
                /*
                 *  Error creating, or object is aggregated and therefore
                 *  should not be initialized.
                 */
            }
        } else {
            /*
             *  Error creating effect driver, or no effect driver.
             */
        }
    }

    ExitOleProcPpv(ppdeff);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SyncShepHandle |
 *
 *          Synchronize the caller's <t SHEPHANDLE> with the
 *          <t SHEPHANDLE> of the parent.  This lets
 *          dieshep.c know that the two are talking about the same thing.
 *
 *  @cwrap  PDD | this
 *
 *  @returns
 *          Returns <c S_OK> if the tags already matched,
 *          or <c S_FALSE> if the tag changed.  If the tag changed,
 *          then the handle inside the <t SHEPHANDLE> is zero'd.
 *
 *          Note that <f CDIEff_DownloadWorker> assumes that the
 *          return value is exactly <c S_OK> or <c S_FALSE>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_SyncShepHandle(PDD this, PSHEPHANDLE psh)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if (psh->dwTag == this->sh.dwTag) {
        hres = S_OK;
    } else {
        psh->dwTag = this->sh.dwTag;
        psh->dwEffect = 0;
        hres = S_FALSE;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | NotifyCreateEffect |
 *
 *          Add the effect pointer to the list of effects that
 *          have been created by the device.
 *
 *          The device critical section must not be owned by the
 *          calling thread.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   IN struct CDIEff * | pdeff |
 *
 *          The effect pointer to add.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: Everything is okay.
 *
 *          <c DIERR_OUTOFMEMORY> =
 *          <c E_OUTOFMEMORY>: No memory to record the effect.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIDev_NotifyCreateEffect(PDD this, struct CDIEff *pdeff)
{
    HRESULT hres;

    AssertF(!CDIDev_InCrit(this));

    CDIDev_EnterCrit(this);
    hres = GPA_Append(&this->gpaEff, pdeff);

    CDIDev_LeaveCrit(this);

    /*
     *  Note that we must leave the device critical section
     *  before talking to the effect, in order to preserve
     *  the synchronization hierarchy.
     */
    if (SUCCEEDED(hres)) {
        Common_Hold(pdeff);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | NotifyDestroyEffect |
 *
 *          Remove the effect pointer from the list of effects that
 *          have been created by the device.
 *
 *          The device critical section must not be owned by the
 *          calling thread.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   IN struct CDIEff * | pdeff |
 *
 *          The effect pointer to remove.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIDev_NotifyDestroyEffect(PDD this, struct CDIEff *pdeff)
{
    HRESULT hres;

    AssertF(!CDIDev_InCrit(this));

    CDIDev_EnterCrit(this);
    hres = GPA_DeletePtr(&this->gpaEff, pdeff);

    CDIDev_LeaveCrit(this);

    /*
     *  Note that we must leave the device critical section
     *  before talking to the effect, in order to preserve
     *  the synchronization hierarchy.
     *
     *  Note that there you might think there's a deadlock here if
     *  effect A notifies us, and we in turn try to unhold
     *  effect B.  But that won't happen, because we only
     *  unhold the effect that notified us.
     */
    if (SUCCEEDED(hres)) {
        Common_Unhold(pdeff);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | FindEffectGUID |
 *
 *          Look for an effect <t GUID>; if found, fetch associated
 *          information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   REFGUID | rguid |
 *
 *          Effect <t GUID> to locate.
 *
 *  @parm   PEFFECTMAPINFO | pemi |
 *
 *          Receives associated information for the effect.
 *          We must return a copy instead of a pointer, because
 *          the original might disappear suddenly if the
 *          device gets <mf CDIDev::Reset>().
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *          <c DIERR_DEVICENOTREG> = <c REGDB_E_CLASSNOTREG>:
 *          The effect is not supported by the device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_FindEffectGUID_(PDD this, REFGUID rguid, PEFFECTMAPINFO pemi,
                       LPCSTR s_szProc, int iarg)
{
    UINT iemi;
    HRESULT hres;

  D(iarg);

    CDIDev_EnterCrit(this);

    for (iemi = 0; iemi < this->cemi; iemi++) {
        if (IsEqualGUID(rguid, &this->rgemi[iemi].guid)) {
            *pemi = this->rgemi[iemi];
            hres = S_OK;
            goto found;
        }
    }

    RPF("%s: Effect not supported by device", s_szProc);
    hres = DIERR_DEVICENOTREG;      /* Effect not found */

found:;

    CDIDev_LeaveCrit(this);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | GetEffectInfoHelper |
 *
 *          Transfer information from an
 *          <t EFFECTMAPINFO> to a <t DIEFFECTINFOW>.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDIEFFECTINFOW | pdeiW |
 *
 *          Destination.
 *
 *  @parm   PCEFFECTMAPINFO | pemi |
 *
 *          Source.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_GetEffectInfoHelper(PDD this, LPDIEFFECTINFOW pdeiW,
                           PCEFFECTMAPINFO pemi)
{
    AssertF(pdeiW->dwSize == cbX(*pdeiW));

    pdeiW->guid            = pemi->guid;
    pdeiW->dwEffType       = pemi->attr.dwEffType;
    pdeiW->dwStaticParams  = pemi->attr.dwStaticParams;
    pdeiW->dwDynamicParams = pemi->attr.dwDynamicParams;
    CAssertF(cbX(pdeiW->tszName) == cbX(pemi->wszName));
    CopyMemory(pdeiW->tszName, pemi->wszName, cbX(pemi->wszName));
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | EnumEffects |
 *
 *          Enumerates all of the effects supported by the force
 *          feedback system on the device.  The enumerated GUIDs
 *          may represent predefined effects as well as effects
 *          peculiar to the device manufacturer.
 *
 *          An application
 *          can use the <e DIEFFECTINFO.dwEffType> field of the
 *          <t DIEFFECTINFO> structure to obtain general
 *          information about the effect, such as its type and
 *          which envelope and condition parameters are supported
 *          by the effect.
 *
 *          In order to exploit an effect to its fullest,
 *          you must contact the device manufacturer to obtain
 *          information on the semantics of the effect and its
 *          effect-specific parameters.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDIENUMEFFECTSCALLBACK | lpCallback |
 *
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumEffectsProc> callback function.
 *
 *  @parm   LPVOID | pvRef |
 *
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @parm   DWORD | dwEffType |
 *
 *          Effect type filter.  If <c DIEFT_ALL>, then all
 *          effect types are
 *          enumerated.  Otherwise, it is a <c DIEFT_*> value,
 *          indicating the device type that should be enumerated.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumEffectsProc |
 *
 *          An application-defined callback function that receives
 *          device effects as a result of a call to the
 *          <om IDirectInputDevice8::EnumEffects> method.
 *
 *  @parm   IN LPCDIEFFECTINFO | pdei |
 *
 *          A <t DIEFFECTINFO> structure that describes the enumerated
 *          effect.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice8::EnumEffects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *//**************************************************************************
 *
 *      In DEBUG/RDEBUG, if the callback returns a bogus value, raise
 *      a validation exception.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumEffectsW
    (PV pddW, LPDIENUMEFFECTSCALLBACKW pecW, PV pvRef, DWORD dwEffType)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8W::EnumEffects,
               (_ "pppx", pddW, pecW, pvRef, dwEffType));

    if (SUCCEEDED(hres = hresPvW(pddW)) &&
        SUCCEEDED(hres = hresFullValidPfn(pecW, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(dwEffType, DIEFT_ENUMVALID, 3))) {

        PDD this = _thisPvNm(pddW, ddW);
        PEFFECTMAPINFO rgemi;
        UINT iemi, cemi;


        /*
         *  We need to make a private copy of the GUID list,
         *  because somebody else might suddenly Reset() the
         *  device and mess up everything.
         *
         *  Indeed, it might've been Reset() during this comment!
         *  That's why we need to create the private copy
         *  while under the critical section.
         */

        CDIDev_EnterCrit(this);

        cemi = this->cemi;
        hres = AllocCbPpv(cbCxX(this->cemi, EFFECTMAPINFO), &rgemi);

        if (SUCCEEDED(hres)) {
            if (this->cemi) {
                CopyMemory(rgemi, this->rgemi,
                           cbCxX(this->cemi, EFFECTMAPINFO));
            }
        }

        CDIDev_LeaveCrit(this);

        if (SUCCEEDED(hres)) {
            for (iemi = 0; iemi < cemi; iemi++) {
                PEFFECTMAPINFO pemi = &rgemi[iemi];
                if (fLimpFF(dwEffType,
                            dwEffType == LOBYTE(pemi->attr.dwEffType))) {
                    BOOL fRc;
                    DIEFFECTINFOW deiW;

                    deiW.dwSize = cbX(deiW);
                    CDIDev_GetEffectInfoHelper(this, &deiW, pemi);

                    fRc = Callback(pecW, &deiW, pvRef);

                    switch (fRc) {
                    case DIENUM_STOP: goto enumdoneok;
                    case DIENUM_CONTINUE: break;
                    default:
                        RPF("%s: Invalid return value from callback",
                            s_szProc);
                        ValidationException();
                        break;
                    }
                }
            }

        enumdoneok:;

            FreePpv(&rgemi);
            hres = S_OK;

        }

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8A | EnumEffectsCallbackA |
 *
 *          Custom callback that wraps
 *          <mf IDirectInputDevice8::EnumObjects> which
 *          translates the UNICODE string to an ANSI string.
 *
 *  @parm   IN LPCDIEFFECTINFOA | pdoiA |
 *
 *          Structure to be translated to ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Pointer to <t struct ENUMEFFECTSINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMEFFECTSINFO {
    LPDIENUMEFFECTSCALLBACKA pecA;
    PV pvRef;
} ENUMEFFECTSINFO, *PENUMEFFECTSINFO;

BOOL CALLBACK
CDIDev_EnumEffectsCallbackA(LPCDIEFFECTINFOW pdeiW, PV pvRef)
{
    PENUMEFFECTSINFO peei = pvRef;
    BOOL fRc;
    DIEFFECTINFOA deiA;
    EnterProc(CDIObj_EnumObjectsCallbackA,
              (_ "GxWp", &pdeiW->guid,
                         &pdeiW->dwEffType,
                          pdeiW->tszName, pvRef));

    deiA.dwSize = cbX(deiA);
    EffectInfoWToA(&deiA, pdeiW);

    fRc = peei->pecA(&deiA, peei->pvRef);

    ExitProcX(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8A | EnumEffects |
 *
 *          Enumerate the effects available on a device, in ANSI.
 *          See <mf IDirectInputDevice8::EnumEffects> for more information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMEFFECTSCALLBACKA | lpCallback |
 *
 *          Same as <mf IDirectInputDevice8W::EnumObjects>, except in ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Same as <mf IDirectInputDevice8W::EnumObjects>.
 *
 *  @parm   IN DWORD | fl |
 *
 *          Same as <mf IDirectInputDevice8W::EnumObjects>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumEffectsA
    (PV pddA, LPDIENUMEFFECTSCALLBACKA pecA, PV pvRef, DWORD dwEffType)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8A::EnumEffects,
               (_ "pppx", pddA, pecA, pvRef, dwEffType));

    /*
     *  EnumEffectsW will validate the rest.
     */
    if (SUCCEEDED(hres = hresPvA(pddA)) &&
        SUCCEEDED(hres = hresFullValidPfn(pecA, 1))) {
        ENUMEFFECTSINFO eei = { pecA, pvRef };
        PDD this = _thisPvNm(pddA, ddA);

        hres = CDIDev_EnumEffectsW(&this->ddW, CDIDev_EnumEffectsCallbackA,
                                   &eei, dwEffType);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | GetEffectInfo |
 *
 *          Obtains information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIEFFECTINFO | pdei |
 *
 *          Receives information about the effect.
 *          The caller "must" initialize the <e DIEFFECTINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the effect for which information is being requested.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetEffectInfoW(PV pddW, LPDIEFFECTINFOW pdeiW, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8W::GetEffectInfo,
               (_ "ppG", pddW, pdeiW, rguid));

    if (SUCCEEDED(hres = hresPvW(pddW)) &&
        SUCCEEDED(hres = hresFullValidWritePxCb(pdeiW,
                                                DIEFFECTINFOW, 1))) {
        PDD this = _thisPvNm(pddW, ddW);
        EFFECTMAPINFO emi;

        if (SUCCEEDED(hres = CDIDev_FindEffectGUID(this, rguid, &emi, 2))) {

            CDIDev_GetEffectInfoHelper(this, pdeiW, &emi);
            hres = S_OK;
        }

        if (FAILED(hres)) {
            ScrambleBuf(&pdeiW->guid,
                cbX(DIEFFECTINFOW) - FIELD_OFFSET(DIEFFECTINFOW, guid));
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8A | GetEffectInfo |
 *
 *          ANSI version of same.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIEFFECTINFO | pdei |
 *
 *          Receives information about the effect.
 *          The caller "must" initialize the <e DIEFFECTINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the effect for which information is being requested.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetEffectInfoA(PV pddA, LPDIEFFECTINFOA pdeiA, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8A::GetEffectInfo,
               (_ "ppG", pddA, pdeiA, rguid));

    if (SUCCEEDED(hres = hresPvA(pddA)) &&
        SUCCEEDED(hres = hresFullValidWritePxCb(pdeiA,
                                                DIEFFECTINFOA, 1))) {
        PDD this = _thisPvNm(pddA, ddA);
        DIEFFECTINFOW deiW;

        deiW.dwSize = cbX(deiW);

        hres = CDIDev_GetEffectInfoW(&this->ddW, &deiW, rguid);

        if (SUCCEEDED(hres)) {
            EffectInfoWToA(pdeiA, &deiW);
            hres = S_OK;
        } else {
            ScrambleBuf(&pdeiA->guid,
                cbX(DIEFFECTINFOA) - FIELD_OFFSET(DIEFFECTINFOA, guid));
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | GetForceFeedbackState |
 *
 *          Retrieves the state of the device's force feedback system.
 *          The device must be acquired for this method to succeed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDWORD | pdwOut |
 *
 *          Receives a <t DWORD> of flags which describe the current
 *          state of the device's force feedback system.
 *
 *          The value is a combination of zero or more <c DIGFFS_*>
 *          flags.
 *
 *          Note that future versions of DirectInput may define
 *          additional flags.  Applications should ignore any flags
 *          that are not currently defined.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdwOut> parameter is not a valid pointer.
 *
 *          <c DIERR_INPUTLOST>: Acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetForceFeedbackState(PV pdd, LPDWORD pdwOut _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetForceFeedbackState, (_ "p", pdd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPcbOut(pdwOut, cbX(*pdwOut), 1))) {
        PDD this = _thisPv(pdd);

        /*
         *  I just know people aren't going to check the error code,
         *  so don't let them see garbage.
         */
        *pdwOut = 0;

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {
            DIDEVICESTATE ds;

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
             */

            ds.dwSize = cbX(ds);
            /*
             *  Prefix raises a warning (mb:34564) that this->pes could 
             *  be NULL however CDIDev_CreateEffectDriver only succeeds 
             *  if it is not.
             */
            hres = this->pes->lpVtbl->
                        GetForceFeedbackState(this->pes, &this->sh, &ds);

            /*
             *  We put as many flags in matching places in
             *  DISFFC_* and DIGFFS_* because I just know
             *  app writers are going to mess it up.
             */
            if (SUCCEEDED(hres)) {

                CAssertF(DISFFC_RESET           == DIGFFS_EMPTY);
                CAssertF(DISFFC_STOPALL         == DIGFFS_STOPPED);
                CAssertF(DISFFC_PAUSE           == DIGFFS_PAUSED);
                CAssertF(DISFFC_SETACTUATORSON  == DIGFFS_ACTUATORSON);
                CAssertF(DISFFC_SETACTUATORSOFF == DIGFFS_ACTUATORSOFF);

                *pdwOut = ds.dwState;
                hres = S_OK;
            }

            CDIDev_LeaveCrit(this);

        }
        ScrambleBit(pdwOut, DIGFFS_RANDOM);

    }

    /*
     *  Can't use ExitOleProcPpv here because pdwOut might have
     *  DIFFS_RANDOM set in it, even on error.
     */
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | SendForceFeedbackCommand |
 *
 *          Sends a command to the the device's force feedback system.
 *          The device must be acquired for this method to succeed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | dwCommand |
 *
 *          One of the <c DISFFC_*> values indicating
 *          the command to send.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p dwFlags> parameter is invalid.
 *
 *          <c DIERR_INPUTLOST>: Acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

HRESULT INLINE
CDIDev_SendForceFeedbackCommand_IsValidCommand(DWORD dwCmd)
{
    HRESULT hres;
 RD(static char s_szProc[] = "IDirectInputDevice8::SendForceFeedbackCommand");

    /*
     *  dwCmd must not be zero (therefore at least one bit set).
     *  !(dwCmd & (dwCmd - 1)) checks that at most one bit is set.
     *  (dwCmd & ~DISFFC_VALID) checks that no bad bits are set.
     */
    if (dwCmd && !(dwCmd & ~DISFFC_VALID) && !(dwCmd & (dwCmd - 1))) {

        hres = S_OK;

    } else {
        RPF("ERROR %s: arg %d: invalid command", s_szProc, 1);
        hres = E_INVALIDARG;
    }
    return hres;
}

STDMETHODIMP
CDIDev_SendForceFeedbackCommand(PV pdd, DWORD dwCmd _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SendForceFeedbackCommand,
               (_ "px", pdd, dwCmd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = CDIDev_SendForceFeedbackCommand_IsValidCommand
                                                                (dwCmd))) {
        PDD this = _thisPv(pdd);

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
             */

            /*
             *  Prefix raises a warning (mb:34564) that this->pes could 
             *  be NULL however CDIDev_CreateEffectDriver only succeeds 
             *  if it is not.
             */
            hres = this->pes->lpVtbl->
                        SendForceFeedbackCommand(this->pes,
                                                 &this->sh, dwCmd);

            if (SUCCEEDED(hres) && (dwCmd & DISFFC_RESET)) {
                /*
                 *  Re-establish the gain after a reset.
                 */
                CDIDev_RefreshGain(this);
            }

            CDIDev_LeaveCrit(this);

        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | EnumCreatedEffectObjects |
 *
 *          Enumerates all of the currently created effect objects for
 *          this device.  Effect objects created via
 *          <mf IDirectInputDevice::CreateEffect>
 *          are enumerated.
 *
 *          Note that results will be unpredictable if you destroy
 *          or create an effect object while an enumeration is in progress.
 *          The sole exception is that the callback function itself
 *          <f DIEnumCreatedEffectObjectsProc> is permitted to
 *          <mf IDirectInputEffect::Release> the effect that it is
 *          passed as its first parameter.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMCREATEDEFFECTOBJECTSCALLBACK | lpCallback |
 *
 *          Callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Reference data (context) for callback.
 *
 *  @parm   IN DWORD | fl |
 *
 *          No flags are currently defined.  This parameter must be 0.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumCreatedEffectObjectsProc |
 *
 *          An application-defined callback function that receives
 *          IDirectInputEffect effect objects as a result of a call to the
 *          <om IDirectInputDevice8::EnumCreatedEffects> method.
 *
 *  @parm   LPDIRECTINPUTEFFECT | peff |
 *
 *          A pointer to an effect object that has been created.
 *
 *  @parm   LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice8::EnumCreatedEffectObjects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumCreatedEffectObjects(PV pdd,
                          LPDIENUMCREATEDEFFECTOBJECTSCALLBACK pec,
                          LPVOID pvRef, DWORD fl _THAT)

{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::EnumCreatedEffects,
               (_ "ppx", pdd, pec, fl));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPfn(pec, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIECEFL_VALID, 3))) {
        PDD this = _thisPv(pdd);
        GPA gpaEff;

        CDIDev_EnterCrit(this);

        /*
         *  We must snapshot the list to make sure we don't run
         *  with a stale handle later.  Actually, we also need
         *  to Hold the guys as we transfer them across so they
         *  won't vanish until we're ready.
         *
         *  Note: It is important that we Hold and not AddRef,
         *  because AddRef will talk to the controlling unknown,
         *  which is not safe to do while holding a critical
         *  section.
         */

        hres = GPA_Clone(&gpaEff, &this->gpaEff);

        if (SUCCEEDED(hres)) {
            int ipv;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                Common_Hold(gpaEff.rgpv[ipv]);
            }
        }

        CDIDev_LeaveCrit(this);

        if (SUCCEEDED(hres)) {
            int ipv;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                BOOL fRc;

                fRc = Callback(pec, gpaEff.rgpv[ipv], pvRef);

                switch (fRc) {
                case DIENUM_STOP: goto enumdoneok;
                case DIENUM_CONTINUE: break;
                default:
                    RPF("%s: Invalid return value from callback", s_szProc);
                    ValidationException();
                    break;
                }

            }

        enumdoneok:;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                Common_Unhold(gpaEff.rgpv[ipv]);
            }

            GPA_Term(&gpaEff);
        }

        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetLoad |
 *
 *          Retrieve the memory load setting for the device.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDWORD | pdwLoad |
 *
 *          Receives memory load.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetLoad(PDD this, LPDWORD pdwOut)
{
    HRESULT hres;
    EnterProc(CDIDev_GetLoad, (_ "p", this));

    hres = CDIDev_CreateEffectDriver(this);

    if (SUCCEEDED(hres)) {
        DIDEVICESTATE ds;

        CDIDev_EnterCrit(this);

        /*
         *  Note that it isn't necessary to check
         *  CDIDev_IsExclAcquired(), because the effect shepherd
         *  will deny us access to a device we don't own.
         *
         *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
         */

        ds.dwSize = cbX(ds);
        /*
         *  Prefix raises a warning (mb:34564) that this->pes could 
         *  be NULL however CDIDev_CreateEffectDriver only succeeds 
         *  if it is not.
         */
        hres = this->pes->lpVtbl->
                    GetForceFeedbackState(this->pes, &this->sh, &ds);

        *pdwOut = ds.dwLoad;

        CDIDev_LeaveCrit(this);

    }

    /*
     *  Can't use ExitOleProcPpv here because pdwOut is garbage on error.
     */
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | Escape |
 *
 *          Send a hardware-specific command to the driver.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_Escape(PV pdd, LPDIEFFESCAPE pesc _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::Escape, (_ "p", pdd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPesc(pesc, 1))) {
        PDD this = _thisPv(pdd);

        AssertF(this->sh.dwEffect == 0);

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
             */

            /*
             *  Prefix raises a warning (mb:34564) that this->pes could 
             *  be NULL however CDIDev_CreateEffectDriver only succeeds 
             *  if it is not.
             */
            hres = IDirectInputEffectShepherd_DeviceEscape(
                                    this->pes, &this->sh, pesc);

            CDIDev_LeaveCrit(this);

        }

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | RefreshGain |
 *
 *          Set the device gain setting appropriately.
 *
 *          The device shepherd will take care of muxing in the
 *          global gain.
 *
 *  @cwrap  PDD | this
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_RefreshGain(PDD this)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if (this->pes) {
        hres = this->pes->lpVtbl->SetGain(this->pes, &this->sh, this->dwGain);
    } else {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | SnapOneEffect |
 *
 *          Read one force feedback effect key and record the
 *          information stored therein.  We also tally the
 *          flag into the <e CDIDev.didcFF> so we can return
 *          the global flags from <mf IDirectInputDevice::GetCapabilities>.
 *
 *          The <e CDIDev.rgemi> field already points to a
 *          preallocated array
 *          of <t EFFECTMAPINFO> structures, and
 *          the <e CDIDev.cemi> field contains the number
 *          of entries in that array which are already in use.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   HKEY | hkEffects |
 *
 *          The registry key containing the effects.
 *
 *  @parm   DWORD | iKey |
 *
 *          Index number of the subkey.
 *
 *  @returns
 *
 *          None.
 *
 *          If the specified subkey is damaged, it is skipped.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_SnapOneEffect(PDD this, HKEY hkEffects, DWORD ihk)
{
    TCHAR tszGuid[ctchGuid];
    LONG lRc;
    PEFFECTMAPINFO pemi;

    /*
     *  Make sure that DIEFT_* and DIDC_* agree where they overlap.
     */
    CAssertF(DIEFT_FORCEFEEDBACK      == DIDC_FORCEFEEDBACK);
    CAssertF(DIEFT_FFATTACK           == DIDC_FFATTACK);
    CAssertF(DIEFT_FFFADE             == DIDC_FFFADE);
    CAssertF(DIEFT_SATURATION         == DIDC_SATURATION);
    CAssertF(DIEFT_POSNEGCOEFFICIENTS == DIDC_POSNEGCOEFFICIENTS);
    CAssertF(DIEFT_POSNEGSATURATION   == DIDC_POSNEGSATURATION);

    pemi = &this->rgemi[this->cemi];

    /*
     *  First get the GUID for the effect.
     */
    lRc = RegEnumKey(hkEffects, ihk, tszGuid, cA(tszGuid));

    if (lRc == ERROR_SUCCESS &&
        ParseGUID(&pemi->guid, tszGuid)) {
        HKEY hk;

        /*
         *  Note that we don't need to check for duplicates.
         *  The registry itself does not allow two keys to have
         *  the same name.
         */

        lRc = RegOpenKeyEx(hkEffects, tszGuid, 0, KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {

            DWORD cb;

            cb = cbX(pemi->wszName);
            lRc = RegQueryStringValueW(hk, 0, pemi->wszName, &cb);
            if (lRc == ERROR_SUCCESS) {
                HRESULT hres;
                hres = JoyReg_GetValue(hk, TEXT("Attributes"), REG_BINARY,
                                       &pemi->attr, cbX(pemi->attr));
                if (SUCCEEDED(hres) &&
                    (pemi->attr.dwCoords & DIEFF_COORDMASK)) {

                    this->didcFF |= (pemi->attr.dwEffType & DIEFT_VALIDFLAGS);
                    this->cemi++;

                }
            }

            RegCloseKey(hk);
        }
    }
 }

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | InitFF |
 *
 *          Initialize the force-feedback portion of the device.
 *
 *          Collect the force feedback attributes.
 *
 *          Snapshot the list of force feedback effects.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>:  The device
 *          does not support force feedback.
 *
 *****************************************************************************/
STDMETHODIMP
CDIDev_InitFF(PDD this)
{
    HKEY hkFF;
    HRESULT hres;
    EnterProcI(CDIDev_InitFF, (_ "p", this));

    AssertF(this->didcFF == 0);

    hres = this->pdcb->lpVtbl->GetFFConfigKey(this->pdcb,
                             KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                             &hkFF);

    if( hres == S_FALSE )
    {
        /*
         *  Try causing the driver to be loaded so that it can initialize 
         *  the effects in the registry before we proceed.
         * 
         *   Need to exercise caution here. A driver that expects to use this
         *   functionality cannot call into Dinput query for device attributes.
         *   Can result in endless loop where we call the driver and the driver
         *   calls us back
         */
        hres = CDIDev_CreateEffectDriver(this);
        if( SUCCEEDED( hres ) )
        {
            hres = this->pdcb->lpVtbl->GetFFConfigKey(this->pdcb,
                                     KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                     &hkFF);
            if( hres == S_FALSE )
            {
                hres = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hres)) {
        DWORD chk;
        HKEY hkEffects;
        LONG lRc;
        
        AssertF( hkFF );

        lRc = JoyReg_GetValue(hkFF, TEXT("Attributes"),
                              REG_BINARY, &this->ffattr, cbX(this->ffattr));
        if (lRc != S_OK) {
            ZeroX(this->ffattr);
        }

        lRc = RegOpenKeyEx(hkFF, TEXT("Effects"), 0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                           &hkEffects);
        if (lRc == ERROR_SUCCESS) {
            lRc = RegQueryInfoKey(hkEffects, 0, 0, 0, &chk,
                                  0, 0, 0, 0, 0, 0, 0);
            if (lRc == ERROR_SUCCESS) {
                hres = AllocCbPpv(cbCxX(chk, EFFECTMAPINFO),
                                        &this->rgemi);
                if (SUCCEEDED(hres)) {
                    DWORD ihk;

                    this->cemi = 0;
                    for (ihk = 0; ihk < chk; ihk++) {

                        CDIDev_SnapOneEffect(this, hkEffects, ihk);

                    }
                    this->didcFF &= DIDC_FFFLAGS;

                    /*
                     *  Note that we mark DIDC_FORCEFEEDBACK only if
                     *  we actually find any effects.
                     */
                    if (this->cemi) {
                        this->didcFF |= DIDC_FORCEFEEDBACK;
                    }

                    hres = S_OK;
                } else {
                    RPF("Warning: Insufficient memory for force feedback");
                }

            } else {
                hres = E_FAIL;
            }
            RegCloseKey(hkEffects);

        } else {
            hres = E_NOTIMPL;
        }

        RegCloseKey(hkFF);
    }

    ExitBenignOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dieff.c ===
/*****************************************************************************
 *
 *  DIEff.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The standard implementation of IDirectInputEffect.
 *
 *      This is the device-independent part.  the device-dependent
 *      part is handled by the IDirectInputEffectShepherd.
 *
 *  Contents:
 *
 *      CDIEff_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"


/*****************************************************************************
 *
 *      Note!
 *
 *      Out of laziness, all effects share the same critical section as
 *      their parent device.  This saves us from all sorts of race
 *      conditions.  Not all of them, but a big chunk of them.
 *
 *      A common race condition that this protects us against is
 *      where an application tries to download an effect at the same
 *      time another thread decides to unacquire the device.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      More laziness:  "TypeSpecificParams" is such a long thing.
 *
 *****************************************************************************/

#define cbTSP       cbTypeSpecificParams
#define lpvTSP      lpvTypeSpecificParams

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEff

/*****************************************************************************
 *
 *    The flags for dwMessage
 *
 *****************************************************************************/
#define EFF_DEFAULT 0
#define EFF_PLAY    1
#define EFF_STOP    2

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CDIEff, IDirectInputEffect);

Interface_Template_Begin(CDIEff)
    Primary_Interface_Template(CDIEff, IDirectInputEffect)
Interface_Template_End(CDIEff)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIEff |
 *
 *          The generic <i IDirectInputEffect> object.
 *
 *  @field  IDirectInputEffect | def |
 *
 *          <i DirectInputEffect> object (containing vtbl).
 *
 *  @field  struct CDIDev * | pdev |
 *
 *          Reference to parent device tracked via <f Common_Hold>.
 *
 *  @field  DICREATEEFFECTINFO | cei |
 *
 *          Parameters that tell us how to talk to the effect driver.
 *
 *  @field  BOOL | fInitialized:1 |
 *
 *          Do we know who we are?
 *
 *  @field  BOOL | fDadNotified:1 |
 *
 *          Does our parent know that we exist?
 *
 *  @field  BOOL | fDadDead:1 |
 *
 *          Has our parent been destroyed (from the app's point of view)?
 *
 *  @field  TSDPROC | hresValidTsd |
 *
 *          Callback function that validates the type-specific data.
 *
 *  @field  HANDLE | hEventDelete |
 *
 *          Event to signal to the timer thread that the app performed final release on the effect.
 *
 *  @field  HANDLE | hEventThreadDead |
 *
 *          Event to signal AppFinalize to perform the final release on the effect.
 *
 *  @field  HANDLE | hEventGeneral |
 *
 *          Event to signal to the timer thread that the app called Start(...) or Stop() the effect.
 *
 *  @field  HANDLE | hThread |
 *
 *          Handle to the timer thread.
 *
 *  @field  DWORD | dwMessage |
 *
 *			Message to the thread as to which event hEventGeneral is actually signaling.
 *			Can be EFF_DEFAULT, EFF_PLAY or EFF_STOP>
 *
 *  @field  DIEFFECTATTRIBUTES | dEffAttributes |
 *
 *         Attributes of the effect (includes dwEffectType and dwEffectId, among others).
 *
 *  @field  DWORD | dwcLoop|
 *
 *			Loop count for playing the effect (passed in the call to Start(...))
 *
 *  @field  DWORD | dwFlags |
 *
 *          Flags for playing the effect (passed in the call to Start(...))
 *
 *  @field  DWORD | diepDirty |
 *
 *          The parts of the effect which are "dirty" and need to
 *          be updated by the next <mf IDirectInputEffect::Download>.
 *
 *  @field  DWORD | diepUnset |
 *
 *          The parts of the effect which have yet to be set by the
 *          application.  Items which we can set decent defaults for
 *          are not counted.
 *
 *  @field  DWORD | dwDirFlags |
 *
 *          Flags that record the direction format the application
 *          last set.
 *
 *  @field  DWORD | dwCoords |
 *
 *          Coordinate systems supported by device.
 *
 *  @field  LPVOID | lpvTSP |
 *
 *          Temporary buffer used to cache type-specific parameters
 *          during Try'ing of proposed effect parameters.
 *
 *  @field  SHEPHANDLE | sh |
 *
 *          Effect handle information.
 *
 *  @field  DIEFFECT | eff |
 *
 *          Cached effect parameters as they exist (or should exist)
 *          on the device.
 *          Direction parameters are in device-preferred coordinates.
 *
 *  @field  DIENVELOPE | env |
 *
 *          Cached envelope parameters as they exist (or should exist)
 *          on the device.
 *
 *  @field  LONG | rglDirApp[DIEFFECT_MAXAXES] |
 *
 *          Cached direction list, in application native format.
 *          The format of this array is kept in the
 *          <e CDIEff.dwDirFlags> field.
 *
 *  @field  DWORD | rgdwAxes[DIEFFECT_MAXAXES] |
 *
 *          Cached axis list, stored as item numbers.
 *
 *  @field  LONG | rglDirDev[DIEFFECT_MAXAXES] |
 *
 *          Cached direction list, in device native format.
 *          The format of this array is kept in the
 *          <e DIEFFECT.dwFlags> field of the
 *          <e CDIEff.eff>.
 *
 *  @field  GUID | guid |
 *
 *          Identity.
 *
 *****************************************************************************/

typedef STDMETHOD(TSDPROC)(LPCDIEFFECT peff, DWORD cAxes);

typedef struct CDIEff {

    /* Supported interfaces */
    IDirectInputEffect def;

    struct CDIDev *pdev;
    LPDIRECTINPUTEFFECTSHEPHERD pes;

    BOOL fDadNotified:1;
    BOOL fDadDead:1;
    BOOL fInitialized:1;

    TSDPROC hresValidTsd;

    /* WARNING!  EVERYTHING AFTER THIS LINE IS ZERO'd ON A RESET */

	HANDLE hEventDelete;
	HANDLE hEventGeneral;
	HANDLE hEventThreadDead;
	HANDLE hThread;
	DWORD dwMessage;

	DIEFFECTATTRIBUTES dEffAttributes;

	DWORD dwcLoop;
	DWORD dwFlags;

    DWORD diepDirty;
    DWORD diepUnset;
    DWORD dwDirFlags;
    DWORD dwCoords;
    LPVOID lpvTSP;
    SHEPHANDLE sh;

    DIEFFECT effDev;
    DIEFFECT effTry;
    DIENVELOPE env;

    GUID guid;

    LONG rglDirApp[DIEFFECT_MAXAXES];
    DWORD rgdwAxes[DIEFFECT_MAXAXES];
    LONG rglDirDev[DIEFFECT_MAXAXES];
    LONG rglDirTry[DIEFFECT_MAXAXES];

    /* WARNING!  EVERYTHING ABOVE THIS LINE IS ZERO'd ON A RESET */

    /*
     *  The Reset() function assumes that the entire remainder
     *  of the structure is to be zero'd out, so if you add a field
     *  here, make sure to adjust Reset() accordingly.
     */

} CDIEff, DE, *PDE;

#define ThisClass CDIEff
#define ThisInterface IDirectInputEffect

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

STDMETHODIMP CDIEff_IsValidUnknownTsd(LPCDIEFFECT peff, DWORD cAxes);

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIEff)
Default_AddRef(CDIEff)
Default_Release(CDIEff)

#else

#define CDIEff_QueryInterface           Common_QueryInterface
#define CDIEff_AddRef                   Common_AddRef
#define CDIEff_Release                  Common_Release
#endif

#define CDIEff_QIHelper                 Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  PDE | this
 *
 *****************************************************************************/

void INLINE  
CDIEff_EnterCrit(PDE this)
{
    AssertF(this->pdev);
    CDIDev_EnterCrit(this->pdev);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  PDE | this
 *
 *****************************************************************************/

void INLINE
CDIEff_LeaveCrit(PDE this)
{
    AssertF(this->pdev);
    CDIDev_LeaveCrit(this->pdev);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | CanAccess |
 *
 *          Check if the effect can be accessed.  For this to succeeed,
 *          the effect must be initialized, and the parent device
 *          must be acquired in exclusive mode.
 *
 *  @cwrap  PDE | this
 *
 *  @returns
 *
 *          <c S_OK> if the device is exclusively acquired.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *          <c DIERR_NOTINITIALIZED> if the effect object has not
 *          yet been initialized.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_CanAccess_(this, z)                                  \
       _CDIEff_CanAccess_(this)                                     \

#endif

STDMETHODIMP
CDIEff_CanAccess_(PDE this, LPCSTR s_szProc)
{
    HRESULT hres;

    AssertF(this->pdev);
    AssertF(CDIDev_InCrit(this->pdev));

    if (this->fInitialized) {
        hres = CDIDev_IsExclAcquired(this->pdev);
    } else {
        if (s_szProc) {
            RPF("ERROR %s: Effect not initialized", s_szProc);
        }
        hres = DIERR_NOTINITIALIZED;
    }

    return hres;
}

#define CDIEff_CanAccess(this)                                      \
        CDIEff_CanAccess_(this, s_szProc)                           \

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_Reset |
 *
 *          Releases all the resources of a generic effect that
 *          are associated with a particular device effect instance.
 *
 *          This method is called in preparation for reinitialization.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being reset.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Reset(PDE this)
{
	HRESULT hres;

    AssertF(this->pdev);
    CDIEff_EnterCrit(this);

    /*
     *  Destroying an effect implicitly stops it.
     *
     *  It's okay if this fails (and in fact it usually will).
     *  We're just playing it safe.
     */
    hres = IDirectInputEffectShepherd_DestroyEffect(this->pes, &this->sh);

    AssertF(this->lpvTSP == 0);
    FreePpv(&this->effDev.lpvTSP);

	//rezero the entire DIEFFECTATTRIBUTES!
	ZeroBuf(&this->dEffAttributes, 
                         cbX(DE) -
                         FIELD_OFFSET(DE, dEffAttributes));


	if (this->hEventDelete != NULL) {
            if( SetEvent(this->hEventDelete) && this->hEventThreadDead != NULL ) 
            {
				DWORD dwRc = 0xFFFFFFFF;
                do
                {
                    dwRc = WaitForSingleObject(this->hEventThreadDead, INFINITE);
                } while( dwRc != WAIT_OBJECT_0 );
                
                CloseHandle(this->hEventThreadDead);
                this->hEventThreadDead = NULL;

                CloseHandle(this->hEventDelete);
                this->hEventDelete = NULL;

                if (this->hEventGeneral != NULL)
                {
                    CloseHandle(this->hEventGeneral);
                    this->hEventGeneral = NULL;
                }

                if (this->hThread != NULL)
                {
                    CloseHandle(this->hThread);
                    this->hThread = NULL;
                }

            }
	}
	this->dwMessage = EFF_DEFAULT;

    this->effDev.dwSize = cbX(this->effDev);
    this->env.dwSize = cbX(this->env);

    /*
     *  DIEP_DURATION               - Defaults to zero.
     *  DIEP_SAMPLEPERIOD           - Defaults to zero.
     *  DIEP_GAIN                   - Defaults to zero.
     *  DIEP_TRIGGERBUTTON          - Defaults to DIEB_NOTRIGGER.
     *  DIEP_TRIGGERREPEATINTERVAL  - Defaults to INFINITE (no autorepeat).
     *  DIEP_AXES                   - Must be set manually.
     *  DIEP_DIRECTION              - Must be set manually.
     *  DIEP_ENVELOPE               - No envelope.
     *  DIEP_TYPESPECIFICPARAMS     - Must be set manually.
     *  DIEP_STARTDELAY             - Defaults to zero. (new in DX6.1)
     */

    this->effDev.dwTriggerButton = DIEB_NOTRIGGER;

    this->diepUnset = DIEP_AXES |
                      DIEP_DIRECTION |
                      DIEP_TYPESPECIFICPARAMS;

    this->effDev.rgdwAxes = this->rgdwAxes;
    this->effDev.rglDirection = this->rglDirDev;

    this->fInitialized = 0;

    CDIEff_LeaveCrit(this);

    hres = S_OK;

    return hres;


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | UnloadWorker |
 *
 *          Remove the effect from the device.  All parameters have
 *          been validated.
 *
 *  @cwrap  PDE | this
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The effect was not previously downloaded,
 *          so there was nothing to unload.  Note that this is a
 *          success code.
 *
 *          <c DI_PROPNOEFFECT> = <c S_FALSE>: The effect was not
 *          previously downloaded.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_UnloadWorker_(this, z)                               \
       _CDIEff_UnloadWorker_(this)                                  \

#endif

HRESULT INTERNAL
CDIEff_UnloadWorker_(PDE this, LPCSTR s_szProc)
{

	HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
        /*
         *  The effect driver will stop the effect (if it is playing)
         *  before destroying it.
         */
            hres = IDirectInputEffectShepherd_DestroyEffect(
                        this->pes, &this->sh);
    } else {
        /*
         *  The effect is dead.  Long live the effect.
         */
        this->sh.dwEffect = 0;
    }

    this->diepDirty = DIEP_ALLPARAMS;

    return hres;

}

#define CDIEff_UnloadWorker(this)                                   \
        CDIEff_UnloadWorker_(this, s_szProc)                        \

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIEff_AppFinalize |
 *
 *          The application has performed its final release.
 *
 *          Tell our parent that we are officially dead, so that
 *          dad will stop tracking us and release its hold on us.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CDIEff_AppFinalize(PV pvObj)
{
    PDE this = pvObj;
    DWORD dwRc = 0xFFFFFFFF;

    EnterProcR(CDIEff_AppFinalize, (_ "p", pvObj));

    if (this->fDadNotified) {
        this->fDadNotified = 0;

        CDIEff_EnterCrit(this);

		/*
		 * Kill the timer thread, if any.
		 * For this, fire off the effect's event.
		 */
		
		if (this->hEventDelete != NULL) {
            if( SetEvent(this->hEventDelete) && this->hEventThreadDead != NULL ) 
            {
                do
                {
                    dwRc = WaitForSingleObject(this->hEventThreadDead, INFINITE);
                } while( dwRc != WAIT_OBJECT_0 );
                
                CloseHandle(this->hEventThreadDead);
                this->hEventThreadDead = NULL;

                CloseHandle(this->hEventDelete);
                this->hEventDelete = NULL;

                if (this->hEventGeneral != NULL)
                {
                    CloseHandle(this->hEventGeneral);
                    this->hEventGeneral = NULL;
                }

                if (this->hThread != NULL)
                {
                    CloseHandle(this->hThread);
                    this->hThread = NULL;
                }

            }
        }

        CDIEff_UnloadWorker_(this, 0);
        CDIEff_LeaveCrit(this);
        CDIDev_NotifyDestroyEffect(this->pdev, this);
    }

    ExitProcR();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIEff_Finalize |
 *
 *          Releases the resources of an effect.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CDIEff_Finalize(PV pvObj)
{
    HRESULT hres;
    PDE this = pvObj;

#if 0 // def XDEBUG
    if (this->cCrit) {
        RPF("IDirectInputEffect::Release: Another thread is using the object; crash soon!");
    }
#endif

    AssertF(this->sh.dwEffect == 0);

    if (this->pdev) {
        hres = CDIEff_Reset(this);
        AssertF(SUCCEEDED(hres));
    }

    Invoke_Release(&this->pes);
    Common_Unhold(this->pdev);

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | GetEffectGuid |
 *
 *          Retrieve the GUID for the effect represented by the
 *          <i IDirectInputEffect> object.  Additional information
 *          about the effect can be obtained by passing the
 *          <t GUID> to <mf IDirectInputDevice8::GetEffectInfo>.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   OUT LPGUID | pguid |
 *
 *          Points to a <t GUID> structure that is filled in
 *          by the function.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputEffect> or
 *          <p lpdc> parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_GetEffectGuid(PDIE pdie, LPGUID pguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::GetEffectGuid, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidWritePguid(pguid, 1))) {
        PDE this = _thisPvNm(pdie, def);

        /*
         *  Race condition:  If the caller reinitializes and
         *  does a GetEffectGuid simultaneously, the return value
         *  is random.  That's okay; it's the caller's problem.
         */
        if (this->fInitialized) {
            *pguid = this->guid;
            hres = S_OK;
        } else {
            hres = DIERR_NOTINITIALIZED;
        }

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   __int64 | _ftol |
 *
 *          Convert a floating point number to an integer.
 *
 *          We do it ourselves because of the C runtime.
 *
 *          It's the caller's job to worry about the rounding mode.
 *
 *  @parm   double | lf |
 *
 *          Floating point number to convert.
 *
 *****************************************************************************/

#if defined(WIN95)

#pragma warning(disable:4035)           /* no return value (duh) */

BYTE _fltused;

__declspec(naked) __int64 __cdecl
_ftol(double lf)
{
    lf;
    _asm {
        sub     esp, 8
        fistp   qword ptr [esp]
        pop     eax
        pop     edx
        ret
    }
}

#pragma warning(default:4035)

#endif

/*
 *  The floating point type we use for intermediates.
 */
typedef long double FPTYPE;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FPTYPE | CDIEff_IntToAngle |
 *
 *          Convert an integer angle to a floating point angle.
 *
 *  @parm   LONG | l |
 *
 *          Integer angle to convert.
 *
 *****************************************************************************/

#ifndef M_PI
#define M_PI 3.1415926535897932384
#endif

FPTYPE INLINE
CDIEff_IntToAngle(LONG l)
{
    FPTYPE theta;

    /*
     *  2pi radians equals 360 degrees.
     */
    theta = l * (2 * M_PI) / (360 * DI_DEGREES);

    return theta;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | CDIEff_IntAtan2 |
 *
 *          Compute the floating point arctangent of y/x and
 *          convert the resulting angle to an integer in DI_DEGREES.
 *
 *  @parm   FPTYPE | y |
 *
 *          Vertical coordinate.
 *
 *  @parm   FPTYPE | x |
 *
 *          Horizontal coordinate.
 *
 *  @returns
 *
 *          A value in the range [ 0 .. 360 * DI_DEGREES ).
 *
 *****************************************************************************/

LONG INLINE
CDIEff_IntAtan2(FPTYPE y, FPTYPE x)
{
    FPTYPE theta;
    LONG l;

#if defined(_X86_)
    /*
     *  The Intel FPU doesn't care about (0, 0).
     */
    theta = atan2(y, x);
#else
    /*
     *  The Alpha gets really upset about (0, 0).
     */
    if (y != 0.0 || x != 0.0) {
        theta = atan2(y, x);
    } else {
        theta = 0.0;
    }
#endif

    /*
     *  atan2 returns a value in the range -M_PI to +M_PI.
     *  On the Intel x86, there are four rounding modes:
     *
     *      Round to nearest or even
     *      Round towards minus infinity
     *      Round towards plus infinity
     *      Round towards zero
     *
     *  By ensuring that the value being rounded is positive, we
     *  reduce to three cases:
     *
     *      Round to nearest or even
     *      Round down
     *      Round up
     *
     *  And as long as the app doesn't change its rounding mode
     *  (few do), the values will be consistent.  (Whereas if we
     *  let negative numbers through, you would get weird behavior
     *  as the angle neared M_PI aka -M_PI.)
     *
     *  Method 1:
     *
     *      if (theta < 0) theta += 2 * M_PI;
     *      l = convert(theta);
     *      return l;
     *
     *  This is bad because if theta starts out as -epsilon, then
     *  we end up converting 2 * M_PI - epsilon, which might get
     *  rounded up to 360 * DI_DEGREES.  But our return value
     *  must be in the range 0 <= l < 360 * DI_DEGREES.
     *
     *  So instead, we use method 2:
     *
     *  l = convert(theta + 2 * M_PI);
     *  if (l >= 360 * DI_DEGREES) l -= 360 * DI_DEGREES;
     *
     *  The value being converted ends up in the range M_PI .. 3 * M_PI,
     *  which after rounding becomes 180 * DI_DEGREES .. 540 * DI_DEGREES.
     *  The final check then pulls the value into range.
     */

    /*
     *  2pi radians equals 360 degrees.
     */
    l = (LONG)((theta + 2 * M_PI) * (360 * DI_DEGREES) / (2 * M_PI));
    if (l >= 360 * DI_DEGREES) {
        l -= 360 * DI_DEGREES;
    }

    return l;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FPTYPE | atan2Z |
 *
 *          Just like <f atan2>, except it doesn't barf on
 *          (0, 0).
 *
 *  @parm   FPTYPE | y |
 *
 *          Vertical coordinate.
 *
 *  @parm   FPTYPE | x |
 *
 *          Horizontal coordinate.
 *
 *****************************************************************************/

FPTYPE INLINE
atan2Z(FPTYPE y, FPTYPE x)
{

#if defined(_X86_)
    /*
     *  The Intel FPU doesn't care about (0, 0).
     */
    return atan2(y, x);
#else
    /*
     *  The Alpha gets really upset about (0, 0).
     */
    if (y != 0.0 || x != 0.0) {
        return atan2(y, x);
    } else {
        return 0.0;
    }
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_CartToAngles |
 *
 *          Convert cartesian coordinates to angle-based coordinates
 *          (either polar or spherical).  Note that the resulting
 *          angles have not been normalized.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes involved, never zero.
 *
 *  @parm   LPLONG | rglAngles |
 *
 *          Buffer to receive angle-base coordinates.
 *          The final entry of the array contains nothing of interest.
 *
 *  @parm   LPCLONG | rglCart |
 *
 *          Buffer containing existing cartesian coordinates.
 *
 *  @parm   DWORD | dieff |
 *
 *          Flags specifying whether the target coordinates should
 *          be <c DIEFF_POLAR> or <c DIEFF_SPHERICAL>.
 *
 *          Polar and spherical coordinates differ only in their
 *          treatment of the first angle.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_CartToAngles(DWORD cAxes,
                    LPLONG rglAngles, const LONG *rglCart, DWORD dieff)
{
    HRESULT hres;
    FPTYPE r;
    DWORD iAxis;

    AssertF(cAxes);
    AssertF(dieff == DIEFF_POLAR || dieff == DIEFF_SPHERICAL);

	/*
	 * If we're converting a 1-axis cartesian effect
	 * the value of rglAngles[0] will not be overwritten;
	 * the value that is put there initially can be random, 
	 * since rglAngles is never initialized (Whistler bug 228280).
	 * but we can't change this behaviour without potentially
	 * breaking compatibility w/ some devices.
	 * The best we can do is to print out a warning in debug.
	 */
	if (cAxes == 1)
	{
		RPF("Warning: converting a 1-axis cartesian effect to polar or spherical coordinates: the results will be undefined.");
	}

    /*
     *  Prime the pump.
     */
    r = rglCart[0];

    /*
     *  Then walk the coordinates, converting to angles as we go.
     */
    for (iAxis = 1; iAxis < cAxes; iAxis++) {
        FPTYPE y = rglCart[iAxis];
        rglAngles[iAxis-1] = CDIEff_IntAtan2(y, r);
        r = sqrt(r * r + y * y);
    }

    /*
     *  The last coordinate is left garbage.
     *
     *  NOTE!  Mathematically, the last coordinate is r.
     */

    /*
     *  Adjust for DIEFF_POLAR.
     *
     *  theta(polar) = theta(spherical) + 90deg
     */

    if (dieff & DIEFF_POLAR) {
        rglAngles[0] += 90 * DI_DEGREES;
    }

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_AnglesToCart |
 *
 *          Convert angle-based coordinates
 *          (either polar or spherical)
 *          to cartesian coordinates.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes involved, never zero.
 *
 *  @parm   LPLONG | rglCart |
 *
 *          Buffer to receive cartesian coordinates.
 *
 *  @parm   LPCLONG | rglAngles |
 *
 *          Buffer containing existing angle-base coordinates.
 *
 *  @parm   DWORD | dieff |
 *
 *          Flags specifying whether the source coordinates are
 *          <c DIEFF_POLAR> or <c DIEFF_SPHERICAL>.
 *
 *          Polar and spherical coordinates differ only in their
 *          treatment of the first angle.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_AnglesToCart(DWORD cAxes,
                    LPLONG rglCart, const LONG *rglAngles, DWORD dieff)
{
    HRESULT hres;
    FPTYPE x[DIEFFECT_MAXAXES];
    DWORD iAxis;
    DWORD lAngle;

    AssertF(cAxes);
    AssertF(cAxes <= DIEFFECT_MAXAXES);
    AssertF(dieff == DIEFF_POLAR || dieff == DIEFF_SPHERICAL);

    /*
     *  Prime the pump.
     */
    x[0] = 1.0;

    /*
     *  For each angle, rotate in that direction.
     *
     *  If polar, then the first angle is biased by 90deg,
     *  so unbias it.
     *
     *  theta(spherical) = theta(polar) - 90deg
     */
    lAngle = rglAngles[0];
    if (dieff & DIEFF_POLAR) {
        lAngle -= 90 * DI_DEGREES;
    }

    for (iAxis = 1; iAxis < cAxes; iAxis++) {
        DWORD iX;
        FPTYPE theta, costh;

        theta = CDIEff_IntToAngle(lAngle);

        x[iAxis] = sin(theta);

        /*
         *  Compiler is too *naive* to hoist this expression.
         *
         *  It's also too *naive* to use the FSINCOS instruction.
         */
        costh = cos(theta);
        for (iX = 0; iX < iAxis; iX++) {
            x[iX] *= costh;
        }

        /*
         *  Note that this is safe because the angle array
         *  always contains an extra zero.
         */
        lAngle = rglAngles[iAxis];
    }

    /*
     *  Now convert the floating point values to scaled integers.
     */
    for (iAxis = 0; iAxis < cAxes; iAxis++) {
        rglCart[iAxis] = (LONG)(x[iAxis] * DI_FFNOMINALMAX);
    }

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CDIEff_ConvertDirection |
 *
 *          Given coordinates in a source system and a target system,
 *          convert them.
 *
 *          There are three possible source systems and three
 *          possible destination systems.
 *
 *          Yes, this is the most annoying thing you could imagine.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes involved, never zero.
 *
 *  @parm   LPLONG | rglDst |
 *
 *          Buffer to receive target coordinates.
 *
 *  @parm   DWORD | dieffDst |
 *
 *          Coordinate systems supported by target.  As many bits
 *          may be set as are supported by the target, but at least
 *          one must be set.
 *
 *  @parm   LPCLONG | rglSrc |
 *
 *          Buffer containing source coordinates.
 *
 *  @parm   DWORD | dieffSrc |
 *
 *          Coordinate system of source.  Exactly one bit should be set.
 *
 *  @returns
 *
 *          Returns the coordinate system stored into the target.
 *
 *****************************************************************************/

DWORD INTERNAL
CDIEff_ConvertDirection(DWORD cAxes,
                        LPLONG rglDst, DWORD dieffDst,
                        const LONG *rglSrc, DWORD dieffSrc)
{
    DWORD dieffRc;
    HRESULT hres;

    dieffSrc &= DIEFF_COORDMASK;
    dieffDst &= DIEFF_COORDMASK;

    AssertF(cAxes);
    AssertF(dieffDst);

    AssertF(dieffSrc == DIEFF_CARTESIAN ||
            dieffSrc == DIEFF_POLAR     ||
            dieffSrc == DIEFF_SPHERICAL);

    if (dieffSrc & dieffDst) {
        /*
         *  The easy case:  The two are directly compatible.
         *
         *  Just slam the bits across and copy the format.
         */
        CopyMemory(rglDst, rglSrc, cbCdw(cAxes));
        dieffRc = dieffSrc;

    } else

    /*
     *  If they two are not directly compatible, see if
     *  the source is cartesian.
     */

    if (dieffSrc & DIEFF_CARTESIAN) {
        /*
         *  Source is cartesian, dest is something angular.
         *  Choose DIEFF_SPHERICAL if possible.
         */
        AssertF(dieffDst & DIEFF_ANGULAR);

        dieffRc = dieffDst & DIEFF_SPHERICAL;
        if (dieffRc == 0) {
            AssertF(dieffDst & DIEFF_POLAR);
            dieffRc = DIEFF_POLAR;
        }

        hres = CDIEff_CartToAngles(cAxes, rglDst, rglSrc, dieffRc);
        AssertF(SUCCEEDED(hres));

    } else

    /*
     *  The two are not directly compatible, and the source is
     *  not cartesian.  This means that the source is one of the
     *  angular forms.  The destination is a combination of
     *  the other angular form or cartesian.
     */

    if (dieffDst & DIEFF_ANGULAR) {
        /*
         *  Source is angular, dest is the other angular.
         */

        AssertF(dieffSrc & DIEFF_ANGULAR);
        AssertF((dieffSrc & dieffDst) == 0);

        /*
         *  First copy everything over,
         */
        CopyMemory(rglDst, rglSrc, cbCdw(cAxes));

        /*
         *  Now rotate left or right, depending on which way
         *  we're going.
         */
        if (dieffSrc & DIEFF_POLAR) {
            /*
             *  Polar to spherical:  Subtract 90deg.
             */
            rglDst[0] -= 90 * DI_DEGREES;
        } else {
            /*
             *  Spherical to polar: Add 90deg.
             */
            rglDst[0] += 90 * DI_DEGREES;
        }

        dieffRc = dieffDst & DIEFF_ANGULAR;

    } else

    /*
     *  All that's left is the source is angular and the destination
     *  is cartesian.
     */
    {
        AssertF(dieffSrc & DIEFF_ANGULAR);
        AssertF(dieffDst & DIEFF_CARTESIAN);

        hres = CDIEff_AnglesToCart(cAxes, rglDst, rglSrc, dieffSrc);
        dieffRc = DIEFF_CARTESIAN;

    }

    /*
     *  If the resulting coordinate system is angular, then
     *  normalize all the angles.
     */
    if (dieffRc & DIEFF_ANGULAR) {
        DWORD iAxis;

        /*
         *  Remember, the last entry is not a direction.
         */
        for (iAxis = 0; iAxis < cAxes - 1; iAxis++) {

            /*
             *  An annoying artifact of the C language is that
             *  the sign of the result of a % operation when the
             *  numerator is negative and the denominator is
             *  positive is implementation-defined.  The standard
             *  does require that the absolute value of the result
             *  not exceed the denominator, so a quick final
             *  check brings things back into focus.
             */
            rglDst[iAxis] %= 360 * DI_DEGREES;
            if (rglDst[iAxis] < 0) {
                rglDst[iAxis] += 360 * DI_DEGREES;
            }
        }

        /*
         *  As always, the last coordinate is zero.
         */
        rglDst[cAxes - 1] = 0;
    }

    return dieffRc;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | SyncShepHandle |
 *
 *          Synchronize our private <t SHEPHANDLE> with the
 *          <t SHEPHANDLE> of the parent device.  If they were
 *          out of sync, then mark the efect as completely dirty
 *          so it will get re-downloaded in full.
 *
 *  @cwrap  PDE | this
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The two were already in sync.
 *
 *          <c S_FALSE>: The two were not in sync and are now in sync.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIEff_SyncShepHandle(PDE this)
{
    HRESULT hres;

    hres = CDIDev_SyncShepHandle(this->pdev, &this->sh);

    if (hres == S_OK) {
    } else {
        /*
         *  We were out of sync with our dad.  CDIDev_SyncShepHandle
         *  already sync'd us with dad and wiped out the effect handle.
         *  All that's left is to dirty everything because there is
         *  nothing to update.
         */
        AssertF(hres == S_FALSE);
        this->diepDirty = DIEP_ALLPARAMS;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | DownloadWorker |
 *
 *          Place the effect on the device.  All parameters have
 *          been validated and the critical section has already been
 *          taken.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Effect to send down to the device.
 *
 *          If we are downloading for real, then this is the
 *          <e CDIEff.effDev>.
 *
 *          If we are hoping to download, then this is the
 *          <e CDIEff.effTry>.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags which specify which parameters are to be sent down
 *          to the driver as changed since last time.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_DEVICEFULL>: The device does not have enough
 *          available memory to download the effect.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_DownloadWorker_(this, peff, fl, z)                   \
       _CDIEff_DownloadWorker_(this, peff, fl)                      \

#endif

HRESULT INTERNAL
CDIEff_DownloadWorker_(PDE this, LPCDIEFFECT peff, DWORD fl, LPCSTR s_szProc)
{

	HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  If we do not have acquisition, but we are coming from
     *  SetParameters, then turn it into a DIEP_NODOWNLOAD so
     *  the call will go through.
     */

    hres = CDIEff_CanAccess(this);
    if ((hres == DIERR_INPUTLOST || hres == DIERR_NOTEXCLUSIVEACQUIRED) &&
        peff == &this->effTry) {
        fl |= DIEP_NODOWNLOAD;
        hres = S_OK;
    }

    if (SUCCEEDED(hres)) {

        hres = CDIEff_SyncShepHandle(this);

        if (!(fl & DIEP_NODOWNLOAD)) {          /* If we are downloading */

            /*
             *  If there are still unset bits, then barf.
             */
            if (this->diepUnset & ~fl) {
                RPF("%s: Effect still incomplete; "
                    "DIEP flags %08x need to be set",
                    s_szProc, this->diepUnset);
                hres = DIERR_INCOMPLETEEFFECT;
                goto done;
            }

            /*
             *  Since we are downloading, pass down all dirty bits.
             */
            fl |= this->diepDirty;
        }

        /*
         *  Now call the driver to do the validation or
         *  the download (accordingly).
         *
         *  Note that if nothing is to be done, then there is no need
         *  to call the driver.
         */
		hres = IDirectInputEffectShepherd_DownloadEffect(
				this->pes, (this->dEffAttributes).dwEffectId, &this->sh, peff, fl);

        if (SUCCEEDED(hres)) {
            if (fl & DIEP_NODOWNLOAD) {
                hres = DI_DOWNLOADSKIPPED;
            } else {
                this->diepDirty = 0;
            }
        }

        AssertF(hres != DIERR_NOTDOWNLOADED);

    }

done:;
    return hres;


}

#define CDIEff_DownloadWorker(this, peff, fl)                       \
        CDIEff_DownloadWorker_(this, peff, fl, s_szProc)            \

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Download |
 *
 *          Place the effect on the device.  If the effect is already
 *          on the device, then the existing effect is updated to
 *          match the values set via <mf IDirectInputEffect::SetParameters>.
 *
 *          It is valid to update an effect while it is playing.
 *          The semantics of such an operation are explained in the
 *          documentation for <mf IDirectInputEffect::SetParameters>.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>:  The effect has already been downloaded to the
 *          device.  Note that this is a success code.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_DEVICEFULL>: The device does not have enough
 *          available memory to download the effect.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *          <c DIERR_EFFECTPLAYING>: The parameters were updated in
 *          memory but were not downloaded to the device because
 *          the device does not support updating an effect while
 *          it is still playing.  In such case, you must stop the
 *          effect, change its parameters, and restart it.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Download(PDIE pdie)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Download, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie))) {
        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        hres = CDIEff_DownloadWorker(this, &this->effDev, 0);

        CDIEff_LeaveCrit(this);

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Unload |
 *
 *          Remove the effect from the device.
 *
 *          If the effect is playing, it is automatically stopped before
 *          it is unloaded.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Unload(PDIE pdie)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Unload, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie))) {
        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        hres = CDIEff_UnloadWorker(this);

        CDIEff_LeaveCrit(this);

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePeff |
 *
 *          Verify that the recipient buffer is valid to receive
 *          effect information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDIEFFECT | peff |
 *
 *          Structure that receives effect information.  It has
 *          already been validate in size and for general writeability.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information is to be retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define hresFullValidWritePeff_(this, peff, fl, z, i)               \
       _hresFullValidWritePeff_(this, peff, fl)                     \

#endif

#define hresFullValidWritePeff(this, peff, fl, iarg)                \
        hresFullValidWritePeff_(this, peff, fl, s_szProc, iarg)     \


HRESULT INTERNAL
hresFullValidWritePeff_(PDE this, LPDIEFFECT peff, DWORD fl,
                        LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  You can't get the parameters of a nonexistent effect.
     */
    if (!this->fInitialized) {
        hres = DIERR_NOTINITIALIZED;
        goto done;
    }

    /*
     *  Flags are always validated.
     */
    if (peff->dwFlags & ~DIEFF_VALID) {
        RPF("ERROR %s: arg %d: Invalid value 0x%08x in DIEFFECT.dwFlags",
            s_szProc, iarg, peff->dwFlags);
        hres = E_INVALIDARG;
        goto done;
    }

    /*
     *  If requesting something that requires object ids or offsets,
     *  make sure the caller picks one or the other.
     */
    if (fl & DIEP_USESOBJECTS) {
        switch (peff->dwFlags & DIEFF_OBJECTMASK) {
        case DIEFF_OBJECTIDS:
        case DIEFF_OBJECTOFFSETS:
            break;

        default:
            RPF("ERROR %s: arg %d: Must specify one of "
                "DIEFF_OBJECTIDS or DIEFF_OBJECTOFFSETS", s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  If requesting something that requires direction coordinates,
     *  make sure the caller picks something we can return.
     */
    if (fl & DIEP_USESCOORDS) {

        /*
         *  Polar coordinates require cAxes == 2.  If not, then
         *  turn off DIEFF_POLAR so we won't return it.
         *
         *  But the place where we check the number of axes is
         *  in the effect itself, not in the input buffer.
         *  The reason is that the caller might be passing cAxes=0
         *  intending to ping the number of axes, and I don't
         *  want to return an error or the app will get confused
         *  and panic.
         */
        if (this->effDev.cAxes != 2 && (peff->dwFlags & DIEFF_POLAR)) {
            RPF("WARNING %s: arg %d: DIEFF_POLAR requires DIEFFECT.cAxes=2",
                s_szProc, 1);
            peff->dwFlags &= ~DIEFF_POLAR;
        }

        /*
         *  There'd better be a coordinate system left.
         */
        if ((peff->dwFlags & DIEFF_COORDMASK) == 0) {
            RPF("ERROR %s: arg %d: No (valid) coordinate system "
                "in DIEFFECT.dwFlags", s_szProc, 1);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  DIEP_DURATION
     *  DIEP_SAMPLEPERIOD
     *  DIEP_GAIN
     *  DIEP_TRIGGERBUTTON
     *  DIEP_TRIGGERREPEATINTERVAL
     *                - Simple dwords.  No extra validation needed.
     */

    /*
     *  DIEP_STARTDELAY
     *                - Although this is a simple DWORD, we do some
     *                  sanity warnings because vendors will probably
     *                  forget to initialize it.  Also, you can't pass
     *                  this flag if your structure isn't big enough.
     */
    if (fl & DIEP_STARTDELAY) {
        if (peff->dwSize < cbX(DIEFFECT_DX6)) {
            RPF("ERROR %s: arg %d: Can't use DIEP_STARTDELAY with "
                "DIEFFECT_DX5 structure", s_szProc, 1);
        }

        /*
         *  Sanity checks.  A delay that isn't a multiple of 50ms is
         *  probably a bug.
         */
        if (peff->dwStartDelay % 50000) {
            RPF("WARNING %s: DIEFFECT.dwStartDelay = %d seems odd",
                s_szProc, peff->dwStartDelay);
        }
    }

    /*
     *  DIEP_TYPESPECIFICPARAMS
     *                - Validate that the buffer is big enough.
     */

    AssertF(this->hresValidTsd);
    if ((fl & DIEP_TYPESPECIFICPARAMS) &&
        FAILED(hres = hresFullValidWritePvCb(peff->lpvTypeSpecificParams,
                                             peff->cbTypeSpecificParams,
                                             iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in "
            "DIEFFECT.lpvTypeSpecificParams", s_szProc, iarg);
        goto done;
    }

    /*
     *  DIEP_AXES
     *  DIEP_DIRECTION
     *                - The buffers must be of necessary size.
     */
    if ((fl & DIEP_AXES) &&
        FAILED(hres = hresFullValidWritePvCb(peff->rgdwAxes,
                                             cbCdw(peff->cAxes), iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in DIEFFECT.rgdwAxes",
            s_szProc, iarg);
        goto done;
    }

    if ((fl & DIEP_DIRECTION) &&
        FAILED(hres = hresFullValidWritePvCb(peff->rglDirection,
                                             cbCdw(peff->cAxes), iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in DIEFFECT.rglDirection",
            s_szProc, iarg);
        goto done;
    }

    /*
     *  DIEP_ENVELOPE - The pointer must be valid to receive the envelope.
     */
    if ((fl & DIEP_ENVELOPE) &&
        FAILED(hres = hresFullValidWritePxCb(peff->lpEnvelope,
                                             DIENVELOPE, iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in DIEFFECT.lpEnvelope",
            s_szProc, iarg);
        goto done;
    }

    hres = S_OK;

done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | MapDwords |
 *
 *          Map a few <t DWORD>s based on the desired mapping mode
 *          of the caller.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   DWORD | dwFlags |
 *
 *          The mapping mode desired by the caller.
 *
 *  @parm   UINT | cdw |
 *
 *          Number of items to convert.
 *
 *  @parm   LPDWORD | rgdwOut |
 *
 *          Destination buffer.
 *
 *  @parm   LPCDWORD | rgdwIn |
 *
 *          Source buffer.
 *
 *  @parm   UINT | devco |
 *
 *          Conversion code describing what we're converting.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The caller
 *          requested offsets but there is no data format selected.
 *
 *****************************************************************************/

#if 0

#ifndef XDEBUG

#define CDIEff_MapDwords_(this, fl, cdw, rgdwOut, rgdwIn, devco, z, i)  \
       _CDIEff_MapDwords_(this, fl, cdw, rgdwOut, rgdwIn, devco)        \

#endif

#define CDIEff_MapDwords(this, fl, cdw, rgdwOut, rgdwIn, devco, i)      \
        CDIEff_MapDwords_(this, fl, cdw, rgdwOut, rgdwIn, devco, s_szProc, i) \

#endif

HRESULT INTERNAL
CDIEff_MapDwords(PDE this, DWORD dwFlags,
                 UINT cdw, LPDWORD rgdwOut, const DWORD *rgdwIn, UINT devco)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    if (cdw) {

        CopyMemory(rgdwOut, rgdwIn, cbCdw(cdw));

        /*
         *  Okay, now things get weird.  We internally keep the
         *  items as item IDs, because that's what drivers
         *  want.  So we need to convert them to whatever the
         *  caller really wants.
         */

        if (dwFlags & DIEFF_OBJECTOFFSETS) {
            if (devco & DEVCO_FROMID) {
                devco |= DEVCO_TOOFFSET;
            } else {
                AssertF(devco & DEVCO_TOID);
                devco |= DEVCO_FROMOFFSET;
            }
        } else {
            AssertF(dwFlags & DIEFF_OBJECTIDS);
            if (devco & DEVCO_FROMID) {
                devco |= DEVCO_TOID;
            } else {
                AssertF(devco & DEVCO_TOID);
                devco |= DEVCO_FROMID;
            }
        }
        hres = CDIDev_ConvertObjects(this->pdev, cdw, rgdwOut, devco);

    } else {
        /* Vacuous success */
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | GetDirectionParameters |
 *
 *          Retrieve information about the direction of an effect.
 *
 *          If no direction has yet been set, then wipe out the
 *          direction pointer and erase the coordinate system.
 *
 *          Always convert from the cached application coordinate
 *          system instead of the device coordinate system, in
 *          order to maximize fidelity.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPDIEFFECT | peff |
 *
 *          Structure to receive effect information.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes to return.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_GetDirectionParameters_(this, peff, cAxes, z, iarg)  \
       _CDIEff_GetDirectionParameters_(this, peff, cAxes)           \

#endif

#define CDIEff_GetDirectionParameters(this, peff, cAxes, iarg)      \
        CDIEff_GetDirectionParameters_(this, peff, cAxes, s_szProc, iarg)  \

void INTERNAL
CDIEff_GetDirectionParameters_(PDE this, LPDIEFFECT peff, DWORD cAxes,
                               LPCSTR s_szProc, int iarg)
{
    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  Make sure there are no non-coordinate bits in dwDirFlags.
     *  And validation should've made sure the app is asking for *something*.
     */
    AssertF((this->dwDirFlags & ~DIEFF_COORDMASK) == 0);
    AssertF(peff->dwFlags & DIEFF_COORDMASK);
    AssertF(cAxes <= DIEFFECT_MAXAXES);

    if (this->dwDirFlags) {
        DWORD dieffRc;
        LONG rgl[DIEFFECT_MAXAXES];     /* Holding buffer */

        /*
         *  We must double-buffer in case the target is not big enough.
         */
        /*
         *  Prefix does not like the lack of initialization of rgl (Manbugs 34566, Whistler 228280) 
         *  but unfortunately we can't fix it without potentially breaking compatibility
		 *  with some devices. See comment in CDIEff_CartToAngles() about this issue.
		 */
        dieffRc = CDIEff_ConvertDirection(
                        this->effDev.cAxes,
                        rgl, peff->dwFlags,
                        this->rglDirApp, this->dwDirFlags);

        peff->dwFlags = (peff->dwFlags & ~DIEFF_COORDMASK) | dieffRc;

        CopyMemory(peff->rglDirection, rgl, cbCdw(cAxes));

    } else {
        /*
         *  No direction set; vacuous success.
         */
        RPF("Warning: %s: arg %d: Effect has no direction", s_szProc, iarg);
        peff->rglDirection = 0;
        peff->dwFlags &= ~DIEFF_COORDMASK;
    }

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | GetParameters |
 *
 *          Retrieve information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDIEFFECT | peff |
 *
 *          Structure that receives effect information.
 *          The <e DIEFFECT.dwSize> field must be filled in by
 *          the application before calling this function.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information is to be retrieved.
 *
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has never had any effect parameters set into it.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.  Common errors include
 *          not setting the <e DIEFFECT.dwSize> field of the
 *          <t DIEFFECT> structure, passing invalid flags,
 *          or not setting up the fields in the <t DIEFFECT> structure
 *          properly in preparation for receiving the effect information.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_GetParameters(PDIE pdie, LPDIEFFECT peff, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::GetParameters, (_ "ppx", pdie, peff, fl));

    /*
     *  Note that we cannot use hresFullValidWritePxCb() because
     *  that will scramble the buffer, but we still need the values
     *  in it.
     */
    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED( hres = ( IsBadReadPtr(&peff->dwSize, cbX(peff->dwSize)) ) ? E_POINTER : S_OK ) &&
        ( ( (peff->dwSize != cbX(DIEFFECT_DX5)) &&
            SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(peff, DIEFFECT_DX6, 1) ) &&
            SUCCEEDED(hres = hresFullValidFl(fl, DIEP_GETVALID, 2)) )
          ||
          ( SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(peff, DIEFFECT_DX5, 1)) &&
            SUCCEEDED(hres = hresFullValidFl(fl, DIEP_GETVALID_DX5, 2)) )
        ) ) {

        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = hresFullValidWritePeff(this, peff, fl, 1))) {

            if (fl == 0) {
                RPF("Warning: %s(dwFlags=0) is pretty useless",
                    s_szProc);
            }

            /*
             *  Assume everything is okay.
             */
            hres = S_OK;

            /*
             *  Pull out the effect parameters.
             */

            if (fl & DIEP_DURATION) {
                peff->dwDuration = this->effDev.dwDuration;
            }

            if (fl & DIEP_SAMPLEPERIOD) {
                peff->dwSamplePeriod = this->effDev.dwSamplePeriod;
            }

            if (fl & DIEP_GAIN) {
                peff->dwGain = this->effDev.dwGain;
            }

            if (fl & DIEP_STARTDELAY) {
                peff->dwStartDelay = this->effDev.dwStartDelay;
            }

            if (fl & DIEP_TRIGGERBUTTON) {
                peff->dwTriggerButton = this->effDev.dwTriggerButton;
                if (peff->dwTriggerButton != DIEB_NOTRIGGER) {
                    hres = CDIEff_MapDwords(this, peff->dwFlags, 1,
                                            &peff->dwTriggerButton,
                                            &peff->dwTriggerButton,
                                            DEVCO_BUTTON |
                                            DEVCO_FROMID);

                    /*
                     *  We should never allow a bad id to sneak in.
                     */
                    AssertF(SUCCEEDED(hres));

                    if (FAILED(hres)) {
                        goto done;
                    }
                }
            }

            if (fl & DIEP_TRIGGERREPEATINTERVAL) {
                peff->dwTriggerRepeatInterval =
                                    this->effDev.dwTriggerRepeatInterval;
            }

            if (fl & DIEP_TYPESPECIFICPARAMS) {
                DWORD cb = this->effDev.cbTSP;
                if (peff->cbTSP < this->effDev.cbTSP) {
                    cb = peff->cbTSP;
                    hres = DIERR_MOREDATA;
                }
                peff->cbTSP = this->effDev.cbTSP;

                CopyMemory(peff->lpvTSP, this->effDev.lpvTSP, cb);
            }

            if (fl & DIEP_ENVELOPE) {
                if (this->effDev.lpEnvelope) {
                    *peff->lpEnvelope = *this->effDev.lpEnvelope;
                } else {
                    /*
                     *  Zero out the envelope because apps are too
                     *  *lazy* to check whether peff->lpEnvelope == 0;
                     *  they're just going to peek at the envelope
                     *  even if the effect doesn't have one.
                     */
                    ZeroMemory(pvAddPvCb(peff->lpEnvelope,
                                         cbX(peff->lpEnvelope->dwSize)),
                               cbX(DIENVELOPE) -
                                         cbX(peff->lpEnvelope->dwSize));
                    peff->lpEnvelope = this->effDev.lpEnvelope;
                }
            }

            /*
             *  Do axes and direction last because weird error
             *  codes can come out of here.
             */
            if (fl & (DIEP_AXES | DIEP_DIRECTION)) {

                DWORD cAxes = this->effDev.cAxes;
                if (peff->cAxes < this->effDev.cAxes) {
                    cAxes = peff->cAxes;
                    peff->cAxes = this->effDev.cAxes;
                    hres = DIERR_MOREDATA;
                }
                peff->cAxes = this->effDev.cAxes;

                if (fl & DIEP_AXES) {
                    HRESULT hresT;
                    hresT = CDIEff_MapDwords(this, peff->dwFlags, cAxes,
                                             peff->rgdwAxes,
                                             this->effDev.rgdwAxes,
                                             DEVCO_AXIS |
                                             DEVCO_FROMID);
                    if (FAILED(hresT)) {
                        RPF("ERROR: %s: arg %d: Axes not in data format",
                             s_szProc, 1);
                        hres = hresT;
                        goto done;
                    }
                }

                if (fl & DIEP_DIRECTION) {
                    CDIEff_GetDirectionParameters(this, peff, cAxes, 1);
                }

            }
        }

    done:;
        CDIEff_LeaveCrit(this);
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidUnknownTsd |
 *
 *          Verify that the buffer is a valid buffer for unknown
 *          type-specific data.  Since we don't know what it is,
 *          the buffer is assumed valid because we can't validate it.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidUnknownTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    peff;
    cAxes;

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidConstantTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICONSTANTFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidConstantTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DICONSTANTFORCE)) {
            hres = S_OK;
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidRampTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIRAMPFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidRampTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DIRAMPFORCE)) {
            hres = S_OK;
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidPeriodicTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIPERIODIC> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidPeriodicTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DIPERIODIC)) {
            hres = S_OK;
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidConditionTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICONDITION> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidConditionTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    /*
     *  Conditions are weird.  The size of the type-specific data
     *  must be equal to cAxes * cbX(DICONDITION) or equal to
     *  exactly one cbX(DICONDITION), depending on whether you want
     *  multiple conditions on multiple axes or a single condition
     *  rotated across multiple axes.
     *
     *  Note that we do not enforce that the parameters are in range;
     *  this allows for "overgain"-type behaviors.
     */

    if (peff->cbTypeSpecificParams ==         cbX(DICONDITION) ||
        peff->cbTypeSpecificParams == cAxes * cbX(DICONDITION)) {
        hres = S_OK;
    } else {
        RPF("IDirectInputEffect::SetParameters: "
            "Size of type-specific data (%d) "
            "not compatible with number of axes (%d)",
            peff->cbTypeSpecificParams, cAxes);
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidCustomForceTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICUSTOMFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidCustomForceTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DICUSTOMFORCE)) {
            LPCDICUSTOMFORCE pcf = peff->lpvTypeSpecificParams;
            if (pcf->cChannels == 0) {
                RPF("ERROR: IDirectInputEffect::SetParameters: "
                    "DICUSTOMFORCE.cChannels == 0 is invalid");
                hres = E_INVALIDARG;
            } else if (pcf->cSamples % pcf->cChannels != 0) {
                RPF("ERROR: IDirectInputEffect::SetParameters: "
                    "DICUSTOMFORCE.cSamples must be multiple of "
                    "DICUSTOMFORCE.cChannels");
                hres = E_INVALIDARG;
            } else if (IsBadReadPtr(pcf->rglForceData,
                                    cbCxX((pcf->cSamples)*(pcf->cChannels), LONG))) {
                RPF("ERROR: IDirectInputEffect::SetParameters: "
                    "DICUSTOMFORCE.rglForceData invalid");
                hres = E_INVALIDARG;
            } else {
                hres = S_OK;
            }
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

#if DIRECTINPUT_VERSION >= 0x0900
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidRandomTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIRANDOM> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidRandomTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

    if (peff->cbTypeSpecificParams == cbX(DIRANDOM)) {
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidAbsoluteTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIABSOLUTE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidAbsoluteTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

    /*
     *  Unlike other effects, "overgain" is not permitted for absolute effects.
     */
    if (peff->cbTypeSpecificParams == cbX(DIABSOLUTE)) 
    {
        LPCDIABSOLUTE pabs = peff->lpvTypeSpecificParams;
        if( fInOrder( -10000, pabs->lTarget, 10000 ) )
        {
            hres = S_OK;
        }
        else
        {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIABSOLUTE.lTarget %d not in range -10000 to 100000", 
                pabs->lTarget );
            hres = E_INVALIDARG;
        }
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidBumpForceTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIBUMPFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidBumpForceTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

    if (peff->cbTypeSpecificParams == cbX(DIBUMPFORCE)) {
        LPCDIBUMPFORCE pbf = peff->lpvTypeSpecificParams;
        if (pbf->cChannels == 0) {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIBUMPFORCE.cChannels == 0 is invalid");
            hres = E_INVALIDARG;
        } else if (pbf->cSamples % pbf->cChannels != 0) {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIBUMPFORCE.cSamples must be multiple of "
                "DIBUMPFORCE.cChannels");
            hres = E_INVALIDARG;
        } else if (IsBadReadPtr(pbf->rglForceData,
                                cbCxX(pbf->cSamples, LONG))) {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIBUMPFORCE.rglForceData invalid");
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidConditionExTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICONDITIONEX> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidConditionExTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    /*
     *  Extended conditions, like conditions are weird.  
     *  The size of the type-specific data
     *  must be equal to cAxes * cbX(DICONDITIONEX) or equal to
     *  exactly one cbX(DICONDITIONEX), depending on whether you want
     *  multiple conditions on multiple axes or a single condition
     *  rotated across multiple axes.
     *
     *  Note that we do not enforce that the parameters are in range;
     *  this allows for "overgain"-type behaviors.
     */

    if (peff->cbTypeSpecificParams ==         cbX(DICONDITIONEX) ||
        peff->cbTypeSpecificParams == cAxes * cbX(DICONDITIONEX)) {
        hres = S_OK;
    } else {
        RPF("IDirectInputEffect::SetParameters: "
            "Size of type-specific data (%d) "
            "not compatible with number of axes (%d)",
            peff->cbTypeSpecificParams, cAxes);
        hres = E_INVALIDARG;
    }

    return hres;
}
#endif /* DIRECTINPUT_VERSION >= 0x0900 */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPeff |
 *
 *          Verify that the recipient buffer contains valid information.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.  It has
 *          already been validate in size and for general readability.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information should be validated.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define hresFullValidPeff_(this, peff, fl, z, i)                    \
       _hresFullValidPeff_(this, peff, fl)                          \

#endif

#define hresFullValidPeff(this, peff, fl, iarg)                     \
        hresFullValidPeff_(this, peff, fl, s_szProc, iarg)          \


HRESULT INTERNAL
hresFullValidPeff_(PDE this, LPCDIEFFECT peff, DWORD fl,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    DWORD cAxes;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  You can't set the parameters of a nonexistent effect.
     */
    if (!this->fInitialized) {
        hres = DIERR_NOTINITIALIZED;
        goto done;
    }

    /*
     *  Flags are always validated.
     */
    if (peff->dwFlags & ~DIEFF_VALID) {
        RPF("ERROR %s: arg %d: Invalid flags specific parms in DIEFFECT",
            s_szProc, iarg);
        hres = E_INVALIDARG;
        goto done;
    }

    /*
     *  If setting something that requires object ids or offsets,
     *  make sure the caller picks one or the other.
     */
    if (fl & DIEP_USESOBJECTS) {
        switch (peff->dwFlags & DIEFF_OBJECTMASK) {
        case DIEFF_OBJECTIDS:
        case DIEFF_OBJECTOFFSETS:
            break;

        default:
            RPF("ERROR %s: arg %d: Must specify one of "
                "DIEFF_OBJECTIDS or DIEFF_OBJECTOFFSETS", s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  If setting something that requires direction coordinates,
     *  make sure the caller picks exactly one.
     */
    if (fl & DIEP_USESCOORDS) {
        switch (peff->dwFlags & DIEFF_COORDMASK) {
        case DIEFF_CARTESIAN:
        case DIEFF_SPHERICAL:
            break;

        /*
         *  Polar coordinates mandate two (and only two) axes.
         */
        case DIEFF_POLAR:
            if (peff->cAxes != 2) {
                RPF("ERROR %s: arg %d: DIEFF_POLAR requires DIEFFECT.cAxes=2",
                    s_szProc, 1);
                hres = E_INVALIDARG;
                goto done;
            }
            break;

        default:
            RPF("ERROR %s: arg %d: Must specify one of "
                "DIEFF_CARTESIAN, DIEFF_POLAR, or DIEFF_SPHERICAL",
                s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  DIEP_DURATION
     *  DIEP_SAMPLEPERIOD
     *  DIEP_GAIN
     *  DIEP_TRIGGERBUTTON
     *                - Simple dwords.  No extra validation needed.
     */

    /*
     *  DIEP_AXES
     *  DIEP_DIRECTION
     *                - The buffers must be of necessary size.
     *
     *  We will validate the other goo later, because there
     *  are annoying interactions between them.
     */

    AssertF(fLeqvFF(this->effDev.cAxes == 0, this->diepUnset & DIEP_AXES));

    cAxes = this->effDev.cAxes;
    if (fl & (DIEP_AXES | DIEP_DIRECTION)) {

        /*
         *  The number of axes had better not be zero.
         */

        if (peff->cAxes == 0) {
            RPF("ERROR %s: arg %d: DIEFFECT.cAxes = 0 is invalid",
                s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

        /*
         *  And it better not be too big either.
         */

        if (peff->cAxes > DIEFFECT_MAXAXES) {
            RPF("ERROR %s: arg %d: DIEFFECT.cAxes = %d is too large (max %d)",
                s_szProc, iarg, peff->cAxes, DIEFFECT_MAXAXES);
            hres = E_INVALIDARG;
            goto done;
        }

        if (fl & DIEP_AXES) {

            /*
             *  If the axes have already been set (which we know because
             *  this->effDev.cAxes will be nonzero), then don't
             *  let the caller change them.
             */

            if (this->effDev.cAxes) {
                RPF("ERROR %s: arg %d: Cannot change axes once set",
                    s_szProc, iarg);
                hres = DIERR_ALREADYINITIALIZED;
                goto done;
            }

            cAxes = peff->cAxes;

            if (IsBadReadPtr(peff->rgdwAxes, cbCdw(peff->cAxes))) {
                RPF("ERROR %s: arg %d: Invalid rgdwAxes in DIEFFECT",
                    s_szProc, iarg);
                hres = E_INVALIDARG;
                goto done;
            }
        }

        if (fl & DIEP_DIRECTION) {

            /*
             *  We want to disallow cAxes == 0 as well,
             *  but we get that for free because
             *  peff->cAxes != cAxes, and peff->cAxes is already
             *  validated as nonzero.
             */
            if (peff->cAxes != cAxes) {
                if (cAxes) {
                    RPF("ERROR %s: arg %d: Wrong number of DIEFFECT.cAxes",
                        s_szProc, 1);
                } else {
                    RPF("ERROR %s: arg %d: "
                        "Must set number of axes before directions", s_szProc);
                }
                hres = E_INVALIDARG;
                goto done;
            }

            /*
             *  Direction validation should've already checked above.
             */
            AssertF(fLimpFF(peff->dwFlags & DIEFF_POLAR, peff->cAxes == 2));

            if (IsBadReadPtr(peff->rglDirection, cbCdw(peff->cAxes))) {
                RPF("ERROR %s: arg %d: Invalid rglDirection in DIEFFECT",
                    s_szProc, iarg);
                hres = E_INVALIDARG;
                goto done;

            }
        }
    }

    /*
     *  DIEP_TYPESPECIFICPARAMS
     *                - Validate that the buffer is valid
     *                  and passes type-specific tests.
     *
     *  This must be done after axes so we know how many
     *  axes there are.
     */

    AssertF(this->hresValidTsd);
    if (fl & DIEP_TYPESPECIFICPARAMS) {
        hres = hresFullValidReadPvCb(peff->lpvTypeSpecificParams,
                                     peff->cbTypeSpecificParams, iarg);
        if (FAILED(hres)) {
            RPF("ERROR %s: arg %d: Invalid pointer in "
                "DIEFFECT.lpvTypeSpecificParams",
                s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

        hres = this->hresValidTsd(peff, cAxes);
        if (FAILED(hres)) {
            RPF("ERROR %s: arg %d: Invalid type-specific data",
                s_szProc, iarg);
            goto done;
        }
    }

    /*
     *  DIEP_ENVELOPE - The pointer must be valid if present.
     */
    if ((fl & DIEP_ENVELOPE) &&
        peff->lpEnvelope &&
        FAILED(hres = hresFullValidReadPxCb(peff->lpEnvelope,
                                            DIENVELOPE, iarg))) {
        RPF("ERROR %s: arg %d: Invalid lpEnvelope in DIEFFECT",
            s_szProc, iarg);
        hres = E_INVALIDARG;
        goto done;
    }

    hres = S_OK;

done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | TryTriggerButton |
 *
 *          Set information about the trigger button for an effect into the
 *          temporary buffer.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_TryTriggerButton_(this, peff, z, iarg)               \
       _CDIEff_TryTriggerButton_(this, peff)                        \

#endif

#define CDIEff_TryTriggerButton(this, peff, iarg)                   \
        CDIEff_TryTriggerButton_(this, peff, s_szProc, iarg)        \


STDMETHODIMP
CDIEff_TryTriggerButton_(PDE this, LPCDIEFFECT peff, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  We can copy directly in, because if something goes wrong,
     *  we just throw away effTry without damaging effDev.
     */

    this->effTry.dwTriggerButton = peff->dwTriggerButton;

    if (fLimpFF(this->effTry.dwTriggerButton != DIEB_NOTRIGGER,
        SUCCEEDED(hres = CDIEff_MapDwords(this, peff->dwFlags, 1,
                                          &this->effTry.dwTriggerButton,
                                          &this->effTry.dwTriggerButton,
                                          DEVCO_BUTTON |
                                          DEVCO_FFEFFECTTRIGGER |
                                          DEVCO_TOID)))) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: Invalid button identifier/offset "
            "or button is not DIEB_NOTRIGGER",
            s_szProc);
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | TryAxis |
 *
 *          Set information about the axes of an effect into the
 *          temporary buffer.  Note that since you can't change the
 *          axes once they've been set, we can put our try directly
 *          into the final buffer.
 *
 *          The only tricky thing is making sure no axes are repeated
 *          in the array.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_TryAxis_(this, peff, z, iarg)                        \
       _CDIEff_TryAxis_(this, peff)                                 \

#endif

#define CDIEff_TryAxis(this, peff, iarg)                            \
        CDIEff_TryAxis_(this, peff, s_szProc, iarg)                 \


STDMETHODIMP
CDIEff_TryAxis_(PDE this, LPCDIEFFECT peff, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT idw;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  You can change the axes only once.  Therefore, rgdwAxes
     *  always points to this->rgdwAxes.
     */
    AssertF(this->effDev.cAxes == 0);
    AssertF(this->effTry.cAxes == 0);
    AssertF(this->effDev.rgdwAxes == this->effTry.rgdwAxes);
    AssertF(this->effTry.rgdwAxes == this->rgdwAxes);

    hres = CDIEff_MapDwords(this, peff->dwFlags, peff->cAxes,
                            this->effTry.rgdwAxes, peff->rgdwAxes,
                            DEVCO_AXIS | DEVCO_FFACTUATOR | DEVCO_TOID);
    if (FAILED(hres)) {
        RPF("ERROR %s: Invalid axis identifiers/offsets"
            "or axes are not all DIDFT_FFACTUATOR", s_szProc);
        goto done;
    }

    /*
     *  Make sure there are no dups in the axis list.
     *
     *  The outer loop starts at 1 because the 0'th axis
     *  can't possibly conflict with any others.
     */
    for (idw = 1; idw < peff->cAxes; idw++) {
        DWORD idwT;
        for (idwT = 0; idwT < idw; idwT++) {
            if (this->effTry.rgdwAxes[idw] == this->effTry.rgdwAxes[idwT]) {
                RPF("ERROR %s: arg %d: Duplicate axes in axis array",
                    s_szProc, iarg);
                hres = E_INVALIDARG;
                goto done;
            }
        }
    }

    this->effTry.cAxes = peff->cAxes;

done:;
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | TryDirection |
 *
 *          Set information about the direction of an effect into the
 *          temporary buffer.
 *
 *          This is particularly gruesome, because we need to keep
 *          two sets of books: The values passed by the app (which
 *          we regurgitate back when queried) and the values passed
 *          to the driver.
 *
 *          We must keep two sets of books, because I just know
 *          that some apps are going to get confused if the
 *          parameters they read back do not <y exactly> match
 *          the values they set in.  For example, they might
 *          read the value, subtract five, and write it back.
 *          Due to rounding, <y n> and <y n>-5 have the same
 *          value in the driver, so if we translated down and
 *          back, the value wouldn't change, and the app would
 *          get stuck in an infinite loop.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_TryDirection_(this, peff, z, iarg)                   \
       _CDIEff_TryDirection_(this, peff)                            \

#endif

#define CDIEff_TryDirection(this, peff, iarg)                       \
        CDIEff_TryDirection_(this, peff, s_szProc, iarg)            \

STDMETHODIMP
CDIEff_TryDirection_(PDE this, LPCDIEFFECT peff, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    DWORD dieffRc;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  These should've been caught by validation.
     */
    AssertF(this->effTry.cAxes);
    AssertF(peff->cAxes == this->effTry.cAxes);
    AssertF(fLimpFF(peff->dwFlags & DIEFF_POLAR, peff->cAxes == 2));

    /*
     *  Translate the coordinates into device coordinates.
     */
    AssertF((this->dwCoords & ~DIEFF_COORDMASK) == 0);
    AssertF(this->dwCoords);

    this->effTry.rglDirection = this->rglDirTry;
    dieffRc = CDIEff_ConvertDirection(
                    this->effTry.cAxes,
                    this->rglDirTry, this->dwCoords,
                    peff->rglDirection, peff->dwFlags & DIEFF_COORDMASK);
    AssertF(dieffRc);

    this->effTry.dwFlags = (this->effTry.dwFlags & ~DIEFF_COORDMASK) | dieffRc;

    hres = S_OK;

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method void | CDIEff | TryParameters |
 *
 *          Build the Try structure based on the new parameters.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The original effect structure passed by the application.
 *
 *  @parm   DWORD | fl |
 *
 *          The <c DIEP_*> flags which specify what changed.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIEff_TryParameters(PDE this, LPCDIEFFECT peff, DWORD fl)
{
    HRESULT hres = S_OK;  
    EnterProcR(IDirectInputEffect::SetParameters, (_ "ppx", this, peff, fl));

    AssertF(this->lpvTSP == 0);

    /*
     *  Copy the current device parameters so we
     *  can modify the copy without damaging the original.
     */
    this->effTry = this->effDev;

    /*
     *  Install the appropriate effect parameters.
     */

    if (fl & DIEP_DURATION) {
        this->effTry.dwDuration = peff->dwDuration;
    }

    if (fl & DIEP_SAMPLEPERIOD) {
        this->effTry.dwSamplePeriod = peff->dwSamplePeriod;
    }

    if (fl & DIEP_GAIN) {
        this->effTry.dwGain = peff->dwGain;
    }

    if (fl & DIEP_STARTDELAY) {
        this->effTry.dwStartDelay = peff->dwStartDelay;
    }

    if (fl & DIEP_TRIGGERBUTTON) {
        hres = CDIEff_TryTriggerButton(this, peff, 1);
        if (FAILED(hres)) {
            goto done;
        }
    }

    if (fl & DIEP_TRIGGERREPEATINTERVAL) {
        this->effTry.dwTriggerRepeatInterval =
                                    peff->dwTriggerRepeatInterval;
    }

    if (fl & DIEP_TYPESPECIFICPARAMS) {
        this->effTry.cbTSP = peff->cbTSP;
        this->effTry.lpvTSP = peff->lpvTSP;

        /*
         *  Preallocate memory to hold the type-specific parameters
         *  to make sure we can proceed on success.
         */
        if (this->effDev.cbTSP != this->effTry.cbTSP) {
            hres = AllocCbPpv(this->effTry.cbTSP, &this->lpvTSP);
            if (FAILED(hres)) {
                goto done;
            }
        }

    }

    /*
     *  Must do axes before directions because directions
     *  depends on the number of axes.
     */

    if (fl & DIEP_AXES) {
        hres = CDIEff_TryAxis(this, peff, 1);
        if (FAILED(hres)) {
            goto done;
        }
    }

    if (fl & DIEP_DIRECTION) {
        hres = CDIEff_TryDirection(this, peff, 1);
        if (FAILED(hres)) {
            goto done;
        }
    }

    if (fl & DIEP_ENVELOPE) {
        this->effTry.lpEnvelope = peff->lpEnvelope;
    }

done:;
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method void | CDIEff | SaveTry |
 *
 *          A Try'd effect worked.  Save its parameters in the
 *          driver parameter cache.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The original effect structure passed by the application.
 *
 *  @parm   DWORD | fl |
 *
 *          The <c DIEP_*> flags which specify what changed.
 *
 *****************************************************************************/

void INTERNAL
CDIEff_SaveTry(PDE this, LPCDIEFFECT peff, DWORD fl)
{

    /*
     *  For the easy stuff, just copy them blindly.
     *  It doesn't hurt to copy something that didn't change.
     */
    this->effDev.dwDuration              = this->effTry.dwDuration;
    this->effDev.dwSamplePeriod          = this->effTry.dwSamplePeriod;
    this->effDev.dwGain                  = this->effTry.dwGain;
    this->effDev.dwTriggerButton         = this->effTry.dwTriggerButton;
    this->effDev.dwTriggerRepeatInterval = this->effTry.dwTriggerRepeatInterval;
	this->effDev.dwStartDelay            = this->effTry.dwStartDelay;

    /*
     *  Axes count as "easy" because CDIEff_TryAxes put the
     *  axis info directly into this->rgdwAxes.
     */
    this->effDev.cAxes                   = this->effTry.cAxes;

    /*
     *  Now the hard parts: The things that require
     *  memory allocation or block copying.
     */

    if (fl & DIEP_TYPESPECIFICPARAMS) {
        if (this->effDev.cbTSP == this->effTry.cbTSP) {
            AssertF(this->lpvTSP == 0);
        } else {
            AssertF(this->lpvTSP);
            this->effDev.cbTSP = this->effTry.cbTSP;
            FreePpv(&this->effDev.lpvTSP);
            this->effDev.lpvTSP = this->lpvTSP;
            this->lpvTSP = 0;
        }
        CopyMemory(this->effDev.lpvTSP, this->effTry.lpvTSP,
                   this->effTry.cbTSP);
    }

    if (fl & DIEP_DIRECTION) {
        /*
         *  Save the app coordinate and the coordinate system into our cache.
         */
        this->dwDirFlags = peff->dwFlags & DIEFF_COORDMASK;
        CopyMemory(this->rglDirApp, peff->rglDirection,
                   cbCdw(this->effDev.cAxes));

        /*
         *  And propagate the Try'd coordinates into the Drv coordinates.
         */
        this->effDev.dwFlags= this->effTry.dwFlags;
        CopyMemory(this->rglDirDev, this->rglDirTry, cbX(this->rglDirTry));
    }

    if (fl & DIEP_ENVELOPE) {
        if (this->effTry.lpEnvelope) {
            this->effDev.lpEnvelope = &this->env;
            this->env = *this->effTry.lpEnvelope;
        } else {
            this->effDev.lpEnvelope = 0;
        }
    }

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | SetParameters |
 *
 *          Set information about an effect.
 *
 *          It is valid to update the parameters of an effect while
 *          it is playing.  The new parameters take effect immediately
 *          upon download if the device supports dynamic updating of effect
 *          parameters.  The <mf IDirectInputEffect::SetParameters>
 *          method automatically downloads the effect, but this behavior
 *          can be suppressed by setting the <c DIEP_NODOWNLOAD> flag.
 *
 *          If automatic download has been suppressed, then you can
 *          manually download the effect by invoking the
 *          <mf IDirectInputEffect::Download> method.
 *
 *          If the effect is playing while the parameters are changed,
 *          then the new parameters take effect as if they were the
 *          parameters when the effect started.
 *
 *          For example, suppose a periodic effect with a duration
 *          of three seconds is started.
 *          After two seconds, the direction of the effect is changed.
 *          The effect will then continue for one additional second
 *          in the new direction.  The envelope, phase, amplitude,
 *          and other parameters of the effect continue smoothly
 *          as if the direction had not changed.
 *
 *          In the same scenario, if after two seconds, the duration
 *          of the effect were changed to 1.5 seconds, then the effect
 *          would stop, because two seconds have already elapsed from
 *          the beginning of effect playback.
 *
 *          Two additional flags control the download behavior.
 *          The <c DIEP_START> flag indicates that the effect should
 *          be started (or restarted if it is currently playing) after
 *          the parameters are updated.  By default, the play state
 *          of the effect is not altered.
 *
 *          Normally, if the driver cannot update the parameters
 *          of a playing effect, it is permitted to stop the effect,
 *          update the parameters, and then restart the effect.
 *          Passing the <c DIEP_NORESTART> flag suppresses this
 *          behavior.  If the driver cannot update the parameters
 *          of an effect while it is playing, the error code
 *          <c DIERR_EFFECTPLAYING> is returned and the parameters
 *          are not updated.
 *
 *          To summarize the behavior of the three flags that control
 *          download and playback behavior:
 *
 *          If <c DIEP_NODOWNLOAD> is set, then the effect parameters
 *          are updated but not downloaded to the device.
 *
 *          Otherwise, the <c DIEP_NODOWNLOAD> flag is clear.
 *
 *          If the <c DIEP_START> flag is set, then the effect
 *          parameters are updated and downloaded to the device,
 *          and the effect is started,
 *          as if the <mf IDirectInputEffect::Start> method were
 *          called.  Combining the update with <c DIEP_START> is
 *          slightly faster than calling
 *          <mf IDirectInputEffect::Start> separately, because
 *          it requires less information to be transmitted to the
 *          device.
 *
 *          Otherwise, both the <c DIEP_NODOWNLOAD> and
 *          <c DIEP_START> flags are clear.
 *
 *          If the effect is not playing, then the parameters
 *          are updated and downloaded to the device.
 *
 *          Otherwise, both the <c DIEP_NODOWNLOAD> and
 *          <c DIEP_START> flags are clear, and the effect is
 *          already playing.
 *
 *          If the parameters of the effect can be updated
 *          "on the fly", then the update is so performed.
 *
 *          Otherwise, both the <c DIEP_NODOWNLOAD> and
 *          <c DIEP_START> flags are clear, and the effect is
 *          already playing, and the parameters cannot be updated
 *          while the effect is playing.
 *
 *          If the <c DIEP_NORESTART> flag is set, then the
 *          error code <c DIERR_EFFECTPLAYING> is returned.
 *
 *          Otherwise, all three of the flags
 *          <c DIEP_NODOWNLOAD>, <c DIEP_START> and
 *          <c DIEP_NORESTART> are clear, and the effect is
 *          already playing, and the parameters cannot be
 *          updated while the effect is playing.
 *
 *          The effect is stopped, the parameters updated, and
 *          the effect is restarted.  The return code is
 *          <c DI_EFFECTRESTARTED>.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The <e DIEFFECT.dwSize> field must be filled in by
 *          the application before calling this function, as well
 *          as any fields specified by corresponding bits in
 *          the <p dwFlags> parameter.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information is to be set
 *          and how the downloading of the effect parameters
 *          should be handled.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_NOTDOWNLOADED>: The parameters of the effect were
 *          successfully
 *          updated, but the effect could not be downloaded because
 *          the associated device is not acquired in exclusive mode.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DI_TRUNCATED>: The parameters of the effect were
 *          successfully updated,
 *          but some of the effect parameters were
 *          beyond the capabilities of the device and were truncated
 *          to the nearest valid value.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DI_EFFECTRESTARTED>: The parameters of the effect
 *          were successfully updated, and the effect was restarted.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DI_TRUNCATEDANDRESTARTED>: The parameters of the effect
 *          were successfully updated, but some of the effect parameters
 *          were truncated, and the effect was restarted.  This code
 *          combines <c DI_TRUNCATED> and <c DI_EFFECTRESTARTED>.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *          <c DIERR_EFFECTPLAYING>: The parameters were not updated
 *          because
 *          the device does not support updating an effect while
 *          it is still playing, and the <c DIEP_NORESTART> flag was
 *          passed, prohibiting the driver from stopping the effect,
 *          updating its parameters, and restarting it.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_SetParameters(PDIE pdie, LPCDIEFFECT peff, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::SetParameters, (_ "ppx", pdie, peff, fl));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidReadPxCb2(peff,
                                                DIEFFECT_DX6,
                                                DIEFFECT_DX5, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, ((peff->dwSize == cbX(DIEFFECT_DX6)) 
                                              ? DIEP_SETVALID : DIEP_SETVALID_DX5 ), 2))) {

        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = hresFullValidPeff(this, peff, fl, 1))) {

            BOOL fChangeEmulatedStartDelay = FALSE;
    
            /*
             *  Note that if fl == 0 (or nearly so),
             *  TryParameters doesn't do anything,
             *  albeit rather inefficiently.
             */
            hres = CDIEff_TryParameters(this, peff, fl);
            if (FAILED(hres)) {
                goto done;
            }

			/*
			 * Special case for DIEP_STARTDELAY.
			 */
			if (fl & DIEP_STARTDELAY)
			{
				if (this->dEffAttributes.dwStaticParams & DIEP_STARTDELAY)
				{
					/*
					 * Driver supports it, so don't worry.
					 */
					;
				}
				else
				{
					/*
					 * Driver doesn't support it.
					 * Take start delay out...
					 */
					fl &= ~(DIEP_STARTDELAY);
				    this->diepUnset &= ~(DIEP_STARTDELAY);

                    /*
                     * ...but remember that we may need to do something
                     */
                    fChangeEmulatedStartDelay = ( this->effDev.dwStartDelay != this->effTry.dwStartDelay );
					if (fl == 0)
					{
						hres = DI_OK;
						goto save;
					}

				}


			}

            /*
             *  Now pass the effTry to the device driver for
             *  final validation.
             *
             *  Passing fl=0 is a really slow way of downloading
             *  the effect, except that we return DI_DOWNLOADSKIPPED
             *  instead of an error code if the device is not exclusive
             *  acquired.
             *
             *  Passing fl=DIEP_NODOWNLOAD is a really slow NOP.
             *
             *  Note that inability to download due to lack of
             *  proper acquisition is not an error, merely a warning.
             */
            hres = CDIEff_DownloadWorker_(this, &this->effTry, fl, 0);
            AssertF(hres != DIERR_NOTDOWNLOADED);

            /*
             *  If the driver approves, then make the changes permanent.
             *  but first a check on the emulated driver
             */
			save:;

            if( SUCCEEDED(hres) ) 
            {
                if( fChangeEmulatedStartDelay )
                {
                    /*
                     * The start delay for parameter has been changed, so 
                     * any future iteration is OK also the driver has 
                     * SUCCEEDED any other changes.
                     */
                    if( this->dwMessage != EFF_PLAY )
                    {
                        /*
                         * We're not in the delay, so declare everything OK.
                         */
                    }
                    else
                    {
                        /*
                         * If the download was skipped don't bother.
                         */
                        if( hres != DI_DOWNLOADSKIPPED )
                        {
                            if( fl & DIEP_NORESTART )
                            {
                                /*
                                 * We don't support changing the delay during the 
                                 * delay.  Since the driver has already had its 
                                 * parameters changed, only fail this if the 
                                 * delay was the only change requested.
                                 */
                                if( fl == 0 )
                                {
                                    hres = DIERR_EFFECTPLAYING;
                                }
                            }
                            else
                            {
                                /*
                                 * Since we don't support modifying the delay 
                                 * whilst we're in it, restart with the new 
                                 * delay.
                                 * If we were being really smart, we could 
                                 * try to adjust the delay without restarting.
                                 */
                                if( this->hEventDelete && this->hEventGeneral )
                                {
                                    this->dwMessage = EFF_PLAY;
                                    ResetEvent(this->hEventGeneral);
                                    SetEvent(this->hEventGeneral);
                                    if( ( hres & ~DI_TRUNCATEDANDRESTARTED ) == 0 ) 
                                    {
                                        hres |= DI_EFFECTRESTARTED;
                                    }
                                    else if( hres == DI_NOEFFECT )
                                    {
                                        hres = DI_EFFECTRESTARTED;
                                    }
                                }
                                else
                                {
                                    AssertF( !"Effect synchronization event(s) NULL" );
                                }
                            }
                        }
                    }
                }
                else
                {
                    /*
                     *  If there was no change to an emulated start delay then 
                     *  the result we have is already what we need.
                     */
                }
            }

            if (SUCCEEDED(hres)) {
                this->diepUnset &= ~fl;             /* No longer unset */

                /*
                 *  If we didn't download, then the parameters are
                 *  dirty and need to be downloaded later.
                 */
                if (hres == DI_DOWNLOADSKIPPED) {
                    this->diepDirty |= (fl & DIEP_ALLPARAMS);
                }

                CDIEff_SaveTry(this, peff, fl);     /* Save permanently */

            }


        done:;
            FreePpv(&this->lpvTSP);

        }

        CDIEff_LeaveCrit(this);

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | RealStart |
 *
 *          Actually begin playing an effect.  The parent device must
 *          be acquired.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *          If the effect has not been downloaded or has been
 *          modified since its last download, then it will be
 *          downloaded before being started.  This default
 *          behavior can be suppressed by passing the
 *          <c DIES_NODOWNLOAD> flag.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   DWORD | dwIterations |
 *
 *          Number of times to play the effect in sequence.
 *          The envelope is re-articulated with each iteration.
 *
 *          To play the effect exactly once, pass 1.
 *
 *          To play the effect repeatedly until explicitly stopped,
 *          pass <c INFINITE>.
 *
 *          To play the effect until explicitly stopped without
 *          re-articulating the envelope, modify the effect
 *          parameters via <mf IDirectInputEffect::SetParameters>
 *          and change its <e DIEFFECT.dwDuration> to <c INFINITE>.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags that describe how the effect should be played
 *          by the device.  It can be zero or more of the
 *          <c DIES_*> flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_RealStart(PDIE pdie, DWORD dwcLoop, DWORD fl)
{
	HRESULT hres;
    EnterProcR(IDirectInputEffect::Start, (_ "ppx", pdie, dwcLoop, fl));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIES_VALID, 2))) {

        PDE this = _thisPvNm(pdie, def);
		
        if( SUCCEEDED( hres= (IsBadReadPtr(this, cbX(this))) ? E_POINTER : S_OK ) )
        {
            CDIEff_EnterCrit(this);
    
            if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
    
                if (fl & DIES_NODOWNLOAD) {
                    /*
                     *  App wants fine control.  Let him have it.
                     */
                    hres = IDirectInputEffectShepherd_StartEffect(
                              this->pes, &this->sh, fl & DIES_DRIVER, dwcLoop);
                } else {
                    /*
                     *  App wants us to do the work.  First thing to do
                     *  is see if the effect needs to be downloaded.
                     *
                     *  SyncShepHandle checks if the effect is downloaded.
                     */
                    hres = CDIEff_SyncShepHandle(this);
    
                    if (this->diepDirty == 0 && this->sh.dwEffect) {
                        /*
                         *  Effect is clean and downloaded.
                         *  Just start it normally.
                         */
                        hres = IDirectInputEffectShepherd_StartEffect(
                                    this->pes, &this->sh,
                                    fl & DIES_DRIVER, dwcLoop);
    
                    } else {
                        /*
                         *  Effect needs to be downloaded.  We can
                         *  optimize it if no special flags are set
                         *  and the loop count is exactly unity.
                         */
                        if (fl == 0 && dwcLoop == 1) {
                            hres = CDIEff_DownloadWorker(this, &this->effDev,
                                                         DIEP_START);
                        } else {
                            /*
                             *  Cannot optimize; must do separate download
                             *  followed by Start.
                             */
                            hres = CDIEff_DownloadWorker(this, &this->effDev, 0);
                            if (SUCCEEDED(hres)) {
                                hres = IDirectInputEffectShepherd_StartEffect(
                                            this->pes, &this->sh,
                                            fl & DIES_DRIVER, dwcLoop);
                            }
                        }
                    }
                }
            }
    
            CDIEff_LeaveCrit(this); 
        }
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | WINAPI | CDIEff_ThreadProc |
 *
 *			Used to simulate dwStartDelay for drivers that do not support it.
 *          Begin playing an effect that has already been downloaded.  The parent device must
 *          be acquired.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *          If the effect has not been downloaded or has been
 *          modified since its last download, then it will be
 *          downloaded before being started.  This default
 *          behavior can be suppressed by passing the
 *          <c DIES_NODOWNLOAD> flag.
 *	
 *			After starting the effect, kills the timer whose event activated CDIEff_TimerProc
 *
 *
 *  @parm   LPVOID | lpParameter |
 *
 *			LPDIRECTINPUTEFFECT pointer.
 *
 *  @returns
 *
 *         0 if succeeded in starting the effect, or if the effect has been deleted by the app.
 *         -1 otherwise
 *
 *****************************************************************************/

 DWORD WINAPI CDIEff_ThreadProc(LPVOID lpParameter)
 {

	LPDIRECTINPUTEFFECT pdie = (LPDIRECTINPUTEFFECT) lpParameter;

	HRESULT hres = E_FAIL;
	DWORD dwWait;
	HANDLE hArray[2];
	BOOL startCalled = FALSE;

    PDE this = _thisPvNm(pdie, def);
    
    if( SUCCEEDED( hres= (IsBadReadPtr(this, cbX(this))) ? E_POINTER : S_OK ) )
    {
        if( this->hEventDelete != NULL && this->hEventThreadDead != NULL ) 
        {
        	hArray[0] = this->hEventDelete;
        	hArray[1] = this->hEventGeneral;
        
            ResetEvent( this->hEventThreadDead );
    
        	/*
        	 * Wait till the timeout expires, or till one of the events happens -- 
        	 * the effect is deleted by the app (hEventDelete) or the effect is started (hEventStart),
        	 * or the effect is stopped (hEventStop).
        	 */
        
            dwWait = WAIT_TIMEOUT; 
            while (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_FAILED)
            {
                if (dwWait == WAIT_TIMEOUT) 
                {
                    if (startCalled)
                    {
                        /* 
                         * Start have been called, and timeout has expired.
                         * Start the effect. And wait again.
                         */
                        hres = CDIEff_RealStart(pdie, this->dwcLoop, this->dwFlags);
                        startCalled = FALSE;
                        this->dwMessage = EFF_DEFAULT;
                    }
    
                }
    
                else
                {
                    if (dwWait == (WAIT_OBJECT_0 + 1))
                    {
                        /* 
                         * App called Start on the effect.
                         * Set flag  and start waiting anew.
                         */
                        if (this->dwMessage == EFF_PLAY)
                        {
                            if ((this->effDev).dwStartDelay/1000 == 0)
                            {
                                /*
                                 * If time delay is 0 ms, start immediately.
                                 */
                                hres = CDIEff_RealStart(pdie, this->dwcLoop, this->dwFlags);
                                startCalled = FALSE;
                                this->dwMessage = EFF_DEFAULT;
                            }
    
                            else
                            {
                                startCalled = TRUE;
                            }
                        }
                        else
                        {
                            if (this->dwMessage == EFF_STOP)
                            {
                                startCalled = FALSE;
                                this->dwMessage = EFF_DEFAULT;
                            }
                        }
                        
                        ResetEvent(this->hEventGeneral);
                    }
    
                }
    
    
                /*
                 * And wait again.
                 */
                    
                if (startCalled == TRUE) {
                    dwWait = WaitForMultipleObjects(2, hArray, FALSE, (this->effDev).dwStartDelay/1000);
                } else {
                    dwWait = WaitForMultipleObjects(2, hArray, FALSE, INFINITE);
                }
            }
            
            SetEvent( this->hEventThreadDead );
        }

        /* 
         * App has deleted the effect.
         * Exit.
         */

        hres = DI_OK;
    	
    }

	if (SUCCEEDED(hres))
		return 0;
	else
		return -1;
 }


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Start |
 *
 *          Begin playing an effect.  The parent device must
 *          be acquired.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *          If the effect has not been downloaded or has been
 *          modified since its last download, then it will be
 *          downloaded before being started.  This default
 *          behavior can be suppressed by passing the
 *          <c DIES_NODOWNLOAD> flag.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   DWORD | dwIterations |
 *
 *          Number of times to play the effect in sequence.
 *          The envelope is re-articulated with each iteration.
 *
 *          To play the effect exactly once, pass 1.
 *
 *          To play the effect repeatedly until explicitly stopped,
 *          pass <c INFINITE>.
 *
 *          To play the effect until explicitly stopped without
 *          re-articulating the envelope, modify the effect
 *          parameters via <mf IDirectInputEffect::SetParameters>
 *          and change its <e DIEFFECT.dwDuration> to <c INFINITE>.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags that describe how the effect should be played
 *          by the device.  It can be zero or more of the
 *          <c DIES_*> flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Start(PDIE pdie, DWORD dwcLoop, DWORD fl)
{

	HRESULT hres;
	EnterProcR(IDirectInputEffect::Start, (_ "ppx", pdie, dwcLoop, fl));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIES_VALID, 2))) {

        PDE this = _thisPvNm(pdie, def);

        if( SUCCEEDED( hres= (IsBadReadPtr(this, cbX(this))) ? E_POINTER : S_OK ) )
        {
            CDIEff_EnterCrit(this);
        
            if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
        
                this->dwcLoop = dwcLoop;
                this->dwFlags = fl;
        
                if (this->hThread == NULL)
                    hres = CDIEff_RealStart(pdie, dwcLoop, fl);
                else 
                {
                    /* 
                     * Activate the thread's waiting period
                     */
                    hres = CDIEff_DownloadWorker(this, &this->effDev, 0);
                    if (this->hEventGeneral != NULL)
                    {
                        this->dwMessage = EFF_PLAY;
                        ResetEvent(this->hEventGeneral);
                        SetEvent(this->hEventGeneral);
                    }
                    
                }	
        
            }
        
            CDIEff_LeaveCrit(this);
        }
	}

	ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Stop |
 *
 *          Stop playing an effect.  The parent device must
 *          be acquired.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Stop(PDIE pdie)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Stop, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie))) {

        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
            hres = IDirectInputEffectShepherd_StopEffect(this->pes, &this->sh);
        }

		if (this->hEventGeneral != NULL)
		{
			this->dwMessage = EFF_STOP;
			ResetEvent(this->hEventGeneral);
			SetEvent(this->hEventGeneral);
		}

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | GetEffectStatus |
 *
 *          Retrieves the status of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDWORD | pdwFlags |
 *
 *          Receives the status flags for the effect.  It may
 *          consist of zero or more <c DIEGES_*> flag values.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_GetEffectStatus(PDIE pdie, LPDWORD pdwOut)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Stop, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidPcbOut(pdwOut, cbX(*pdwOut), 1))) {

        PDE this = _thisPvNm(pdie, def);

        CAssertF(DEV_STS_EFFECT_RUNNING == DIEGES_PLAYING);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {

			/*
			 * Check the dwMessage first -- 
			 * if it says PLAYING, report DIEGES_PLAYING
			 */
			if (this->dwMessage == EFF_PLAY)
			{
				*pdwOut = DIEGES_PLAYING;
				hres = DI_OK;
			}
			else
			{
				hres = IDirectInputEffectShepherd_GetEffectStatus(
							this->pes, &this->sh, pdwOut);
			}
        }

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Escape |
 *
 *          Send a hardware-specific command to the driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED>:  The effect is not downloaded.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Escape(PDIE pdie, LPDIEFFESCAPE pesc)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Escape, (_ "p", pdie));

    /*
     *  The output buffer is NoScramble because some people like
     *  to pass overlapping in and out buffers.
     */
    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidPesc(pesc, 1))) {
        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        /*
         *  Download the effect if it isn't downloaded yet,
         *  so we have a valid effect to Escape on.
         */
        hres = CDIEff_DownloadWorker(this, &this->effDev, 0);
        if (SUCCEEDED(hres)) {
            hres = IDirectInputEffectShepherd_Escape(
                        this->pes, &this->sh, pesc);
        } else {
            hres = DIERR_NOTDOWNLOADED;
        }

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Initialize |
 *
 *          Initialize a DirectInputEffect object.
 *
 *          Note that if this method fails, the underlying object should
 *          be considered to be an an indeterminate state and needs to
 *          be reinitialized before it can be subsequently used.
 *
 *          The <mf IDirectInputDevice::CreateEffect> method automatically
 *          initializes the device after creating it.  Applications
 *          normally do not need to call this function.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInputEffect object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          Identifies the effect for which the interface
 *          should be associated.
 *          The <mf IDirectInputDevice::EnumEffects> method
 *          can be used to determine which effect GUIDs are supported by
 *          the device.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TSDPROC c_rgtsd[] = {
    CDIEff_IsValidConstantTsd,      /* DIEFT_CONSTANTFORCE  */
    CDIEff_IsValidRampTsd,          /* DIEFT_RAMPFORCE      */
    CDIEff_IsValidPeriodicTsd,      /* DIEFT_PERIODIC       */
    CDIEff_IsValidConditionTsd,     /* DIEFT_CONDITION      */
    CDIEff_IsValidCustomForceTsd,   /* DIEFT_CUSTOMFORCE    */
#if DIRECTINPUT_VERSION >= 0x0900
    CDIEff_IsValidRandomTsd,        /* DIEFT_RANDOM         */
    CDIEff_IsValidAbsoluteTsd,      /* DIEFT_ABSOLUTE       */
    CDIEff_IsValidBumpForceTsd,     /* DIEFT_BUMPFORCE      */
    CDIEff_IsValidConditionExTsd,   /* DIEFT_CONDITIONEX    */
#endif /* DIRECTINPUT_VERSION >= 0x0900 */
};

STDMETHODIMP
CDIEff_Initialize(PDIE pdie, HINSTANCE hinst, DWORD dwVersion, REFGUID rguid)
{

	HRESULT hres;
    EnterProcR(IDirectInputEffect::Initialize,
               (_ "pxxG", pdie, hinst, dwVersion, rguid));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion)) &&
        SUCCEEDED(hres = hresFullValidGuid(rguid, 1))) {
        PDE this = _thisPv(pdie);
        EFFECTMAPINFO emi;

        AssertF(this->pes);

        /*
         *  Don't let somebody mess with the effect while we're
         *  resetting it.
         */
        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = CDIDev_FindEffectGUID(this->pdev, rguid,
                                                   &emi, 3)) &&
            SUCCEEDED(hres = CDIEff_Reset(this))) {

            /*
             *  ISSUE-2001/03/29-timgill Need to check for actual hardware FF effect support
             */

			/*
			 * Initialize dEffAttributes 
			 */
            this->fInitialized = 1;
            this->dEffAttributes = emi.attr;
            this->guid = *rguid;

		
			/* 
			 * Check if the driver supports dwStartDelay.
			 * If it does, no need for us to do anything in that respect.
			 */

			if( this->dEffAttributes.dwStaticParams & DIEP_STARTDELAY )
			{
				/*
				 * No need to emulate dwStartDelay.
				 */
			}
			else
			{
					/*
					 * Driver doesn't support start delay.
					 * Start a thread that will emulate dwStartDelay.
					 */
	
					DWORD dwThreadId;
					HANDLE hThread;

					this->hEventDelete = CreateEvent(NULL, TRUE, FALSE, NULL);
					this->hEventThreadDead = CreateEvent(NULL, TRUE, FALSE, NULL);

					hThread = CreateThread(NULL, 0, CDIEff_ThreadProc, (LPVOID)pdie, 0, &dwThreadId);
					if (hThread == NULL)
					{
						/* Failed to create the thread.
						 * Clean up all our preparations.
						 */
						CloseHandle(this->hEventDelete);
						this->hEventDelete = NULL;
						CloseHandle(this->hEventThreadDead);
						this->hEventThreadDead = NULL;
						hres = hresLe(GetLastError());		
					}

					else
					{
						/*
						 * Create an event to signal effect started or stopped
						 */
						this->hThread = hThread;
						this->hEventGeneral = CreateEvent(NULL, TRUE, FALSE, NULL);
					}
			}


            this->dwCoords = emi.attr.dwCoords & DIEFF_COORDMASK;
            AssertF(this->dwCoords);


            /*
             *  Note, we allow non-hardware specific types that are not 
             *  recognized to pass through untested.  This effects to be run 
             *  from a device which has newer effects than this version of 
             *  DInput can check.  However if this DInput recognizes the 
             *  effect type, it will be checked, even if the application was 
             *  written for a version that could not check it.
             */
            if (fInOrder(DIEFT_PREDEFMIN, DIEFT_GETTYPE(emi.attr.dwEffType),
                         DIEFT_PREDEFMAX)) {
                this->hresValidTsd = c_rgtsd[
                            DIEFT_GETTYPE(emi.attr.dwEffType) -
                                                        DIEFT_PREDEFMIN];
            } else {
                this->hresValidTsd = CDIEff_IsValidUnknownTsd;
            }

            hres = S_OK;

        }

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Init |
 *
 *          Initialize the internal parts of the DirectInputEffect object.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD | pes |
 *
 *          The shepherd that lets us talk to the driver.
 *
 *****************************************************************************/

HRESULT INLINE
CDIEff_Init(struct CDIDev *pdev, LPDIRECTINPUTEFFECTSHEPHERD pes, PDE this)
{
    HRESULT hres;

    /*
     *  The critical section must be the very first thing we do,
     *  because only Finalize checks for its existence.
     *
     *  (We might be finalized without being initialized if the user
     *  passed a bogus interface to CDIEff_New.)
     */
    this->pdev = pdev;
    Common_Hold(this->pdev);

    this->pes = pes;
    OLE_AddRef(this->pes);

    hres = CDIDev_NotifyCreateEffect(this->pdev, this);
    if (SUCCEEDED(hres)) {
        this->fDadNotified = 1;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | New |
 *
 *          Create a new DirectInputEffect object, uninitialized.
 *
 *  @parm   IN struct CDIDev * | pdd |
 *
 *          Parent device, which we keep a <f Common_Hold> on.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD | pes |
 *
 *          The shepherd that lets us talk to the driver.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_New(struct CDIDev *pdev, LPDIRECTINPUTEFFECTSHEPHERD pes,
           PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::<constructor>,
               (_ "ppGp", pdev, pes, riid, punkOuter));

	if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 5)))
	{
		LPVOID pvTry = NULL;
		hres = Common_NewRiid(CDIEff, punkOuter, riid, &pvTry);

		if (SUCCEEDED(hres)) {
			PDE this = _thisPv(pvTry);
			hres = CDIEff_Init(pdev, pes, this);
			if (SUCCEEDED(hres)) {
				*ppvObj = pvTry;
			} else {
				Invoke_Release(&pvTry);
				*ppvObj = NULL;
			}
		}
	}

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CDIEff_Signature        0x20464643      /* "EFF " */

Primary_Interface_Begin(CDIEff, IDirectInputEffect)
    CDIEff_Initialize,
    CDIEff_GetEffectGuid,
    CDIEff_GetParameters,
    CDIEff_SetParameters,
    CDIEff_Start,
    CDIEff_Stop,
    CDIEff_GetEffectStatus,
    CDIEff_Download,
    CDIEff_Unload,
    CDIEff_Escape,
Primary_Interface_End(CDIEff, IDirectInputEffect)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dieffj.c ===
/*****************************************************************************
 *
 *  DIEffJ.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Dummy effect driver for joystick.
 *
 *  Contents:
 *
 *      CJoyEff_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef DEMONSTRATION_FFDRIVER

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyEff

/****************************************************************************
 *
 *  @doc    DDK
 *
 *  @topic  DirectInput force feedback effect drivers |
 *
 *          DirectInput instantiates the force feedback effect driver
 *          by creating the object named by the CLSID stored in the
 *          OEMForceFeedback registry subkey of the joystick type
 *          key.
 *
 *          Note, however, that since applications using DirectInput
 *          need not load OLE, the effect driver should be careful
 *          not to rely on OLE-specific behavior.
 *          For example, applications using DirectInput cannot be
 *          relied upon to call <f CoFreeUnusedLibraries>.
 *          DirectInput will perform the standard COM operations to
 *          instantiate the effect driver object.  The only visible
 *          effect this should have on the implementation of the
 *          effect driver is as follows:
 *
 *          When DirectInput has released the last effect driver
 *          object, it will manually perform a <f FreeLibrary> of
 *          the effect driver DLL.  Consequently, if the effect
 *          driver DLL creates additional resources that are not
 *          associated with the effect driver object, it should
 *          manually <f LoadLibrary> itself to artificially
 *          increase its DLL reference count, thereby preventing
 *          the <f FreeLibrary> from DirectInput from unloading
 *          the DLL prematurely.
 *
 *          In particular, if the effect driver DLL creates a worker
 *          thread, the effect driver must perform this artificial
 *          <f LoadLibrary> for as long as the worker thread exists.
 *          When the worker thread is no longer needed (for example, upon
 *          notification from the last effect driver object as it
 *          is being destroyed), the worker thread should call
 *          <f FreeLibraryAndExitThread> to decrement the DLL reference
 *          count and terminate the thread.
 *
 *          All magnitude and gain values used by DirectInput
 *          are uniform and linear across the range.  Any
 *          nonlinearity in the physical device must be
 *          handled by the device driver so that the application
 *          sees a linear device.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoyEff_New!
 *
 *****************************************************************************/

Primary_Interface(CJoyEff, IDirectInputEffectDriver);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct JEFFECT |
 *
 *          Dummy structure that records information about an effect.
 *
 *  @field  DWORD | tmDuration |
 *
 *          Putative duration for effect.
 *
 *  @field  DWORD | tmStart |
 *
 *          Time the effect started, or zero if not playing.
 *
 *  @field  BOOL | fInUse |
 *
 *          Nonzero if this effect is allocated.
 *
 *****************************************************************************/

typedef struct JEFFECT {
    DWORD   tmDuration;
    DWORD   tmStart;
    BOOL    fInUse;
} JEFFECT, *PJEFFECT;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoyEff |
 *
 *          A dummy <i IDirectInputEffectDriver> object for the
 *          generic joystick.
 *
 *  @field  IDirectInputEffectDriver | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  DWORD | state |
 *
 *          The current device state.
 *
 *  @field  LONG | cCrit |
 *
 *          Number of times the critical section has been taken.
 *          Used only in XDEBUG to check whether the caller is
 *          releasing the object while another method is using it.
 *
 *  @field  DWORD | thidCrit |
 *
 *          The thread that is currently in the critical section.
 *          Used only in DEBUG for internal consistency checking.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Object critical section.  Must be taken when accessing
 *          volatile member variables.
 *
 *  @field  JEFFECT | rgjeff[cjeffMax] |
 *
 *          Information for each effect.
 *
 *****************************************************************************/

#define cjeffMax        8           /* Up to 8 simultaneous effects */

typedef struct CJoyEff {

    /* Supported interfaces */
    IDirectInputEffectDriver ded;

    BOOL fCritInited;

    DWORD state;
    DWORD dwGain;

   RD(LONG cCrit;)
    D(DWORD thidCrit;)
    CRITICAL_SECTION crst;

    JEFFECT rgjeff[cjeffMax];

} CJoyEff, DJE, *PDJE;

typedef IDirectInputEffectDriver DED, *PDED;

#define ThisClass CJoyEff
#define ThisInterface IDirectInputEffectDriver
#define riidExpected &IID_IDirectInputEffectDriver

/*****************************************************************************
 *
 *      CJoyEff::QueryInterface   (from IUnknown)
 *      CJoyEff::AddRef           (from IUnknown)
 *      CJoyEff::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CJoyEff)
Default_AddRef(CJoyEff)
Default_Release(CJoyEff)

#else

#define CJoyEff_QueryInterface      Common_QueryInterface
#define CJoyEff_AddRef              Common_AddRef
#define CJoyEff_Release             Common_Release

#endif

#define CJoyEff_QIHelper            Common_QIHelper
#define CJoyEff_AppFinalize         Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoyEff_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CJoyEff_Finalize(PV pvObj)
{
    PDJE this = pvObj;

    if (this->fCritInited) {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoyEff | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  PDJE | this
 *
 *****************************************************************************/

void EXTERNAL
CJoyEff_EnterCrit(PDJE this)
{
    EnterCriticalSection(&this->crst);
  D(this->thidCrit = GetCurrentThreadId());
 RD(InterlockedIncrement(&this->cCrit));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoyEff | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  PDJE | this
 *
 *****************************************************************************/

void EXTERNAL
CJoyEff_LeaveCrit(PDJE this)
{
#ifdef XDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    if (InterlockedDecrement(&this->cCrit) == 0) {
      D(this->thidCrit = 0);
    }
#endif
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CJoyEff | InCrit |
 *
 *          Nonzero if we are in the critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
CJoyEff_InCrit(PDJE this)
{
    return this->cCrit && this->thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | IsValidId |
 *
 *          Determine whether the effect pseudo-handle is valid.
 *          If so, returns a pointer to the <t JEFFECT>.
 *
 *  @cwrap  PDJE | this
 *
 *  @parm   DWORD | dwId |
 *
 *          Putative ID number.
 *
 *  @parm   PJEFFECT * | ppjeff |
 *
 *          Receives pointer to the <t JEFFECT> on success.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoyEff_IsValidId(PDJE this, DWORD dwId, PJEFFECT *ppjeff)
{
    HRESULT hres;

    AssertF(CJoyEff_InCrit(this));

    if (dwId) {
        PJEFFECT pjeff = &this->rgjeff[dwId - 1];
        if (pjeff->fInUse) {
            *ppjeff = pjeff;
            hres = S_OK;
        } else {
            hres = E_HANDLE;
        }
    } else {
        hres = E_HANDLE;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *
 *          For example, if a device driver is passed
 *          <p dwExternalID> = 2 and <p dwInteralID> = 1,
 *          then this means that unit 1 on the device
 *          corresponds to joystick ID number 2.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwDirectInputVersion |
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *          If the <p lpHIDInfo> field is non-<c NULL> then this
 *          parameter should be ignored.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  @parm   DWORD | dwInternalID |
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *          If the <p lpHIDInfo> field is non-<c NULL> then this
 *          parameter should be ignored.
 *
 *  @parm   LPVOID | lpHIDInfo |
 *
 *          If the underlying device is not a HID device, then this
 *          parameter is <c NULL>.
 *
 *          If the underlying device is a HID device, then this
 *          parameter points to a <t DIHIDFFINITINFO> structure
 *          which informs the driver of HID information.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DeviceID(PDED pded, DWORD dwDIVer, DWORD dwExternalID, DWORD fBegin,
                 DWORD dwInternalID, LPVOID pvReserved)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DeviceID,
               (_ "pxuuu", pded, dwDIVer, dwExternalID, fBegin, dwInternalID));

    this = _thisPvNm(pded, ded);

    dwDIVer;
    dwExternalID;
    fBegin;
    dwInternalID;
    pvReserved;

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Escape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputDevice8::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          If the application invoked the
 *          <mf IDirectInputEffect::Escape> method, then
 *          <p dwEffect> contains the handle (returned by
 *          <mf IDirectInputEffectDriver::DownloadEffect>)
 *          of the effect at which the command is directed.
 *
 *          If the application invoked the
 *          <mf IDirectInputDevice8::Escape> method, then
 *          <p dwEffect> is zero.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *          DirectInput has already validated that the
 *          <e DIEFFESCAPE.lpvOutBuffer> and
 *          <e DIEFFESCAPE.lpvInBuffer> and fields
 *          point to valid memory.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_Escape(PDED pded, DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::Escape,
               (_ "puxx", pded, dwId, dwEffect, pesc->dwCommand));

    this = _thisPvNm(pded, ded);

    dwId;
    dwEffect;
    pesc;

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | SetGain |
 *
 *          Set the overall device gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwGain |
 *
 *          The new gain value.
 *
 *          If the value is out of range for the device, the device
 *          should use the nearest supported value and return
 *          <c DI_TRUNCATED>.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_SetGain(PDED pded, DWORD dwId, DWORD dwGain)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::SetGain,
               (_ "puu", pded, dwId, dwGain));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    this->dwGain = dwGain;

    CJoyEff_LeaveCrit(this);

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | SendForceFeedbackCommand |
 *
 *          Send a command to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwCommand |
 *
 *          Command, one of the <c DISFFC_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_SendForceFeedbackCommand(PDED pded, DWORD dwId, DWORD dwCmd)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::SendForceFeedbackCommand,
               (_ "pux", pded, dwId, dwCmd));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    dwCmd;

    this->state = dwCmd;

    /*
     *  On a reset, all effects are destroyed.
     */
    if (dwCmd & DISFFC_RESET) {
        DWORD ijeff;

        for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
            this->rgjeff[ijeff].fInUse = FALSE;
        }

    }

    CJoyEff_LeaveCrit(this);

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   LPDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *          DirectInput will set the <e DIDEVICESTATE.dwSize> field
 *          to sizeof(DIDEVICESTATE) before calling this method.
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetForceFeedbackState(PDED pded, DWORD dwId, LPDIDEVICESTATE pds)
{
    PDJE this;
    HRESULT hres;
    DWORD ijeff, cjeff, cjeffPlaying;
    EnterProcI(IDirectInputEffectDriver::Joy::GetForceFeedbackState,
               (_ "pup", pded, dwId, pds));

    this = _thisPvNm(pded, ded);

    dwId;
    pds;

    if (pds->dwSize == cbX(*pds)) {
        CJoyEff_EnterCrit(this);

        /*
         *  Count how many effects are in use, and return it as a percentage.
         */
        cjeff = cjeffPlaying = 0;
        for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
            PJEFFECT pjeff = &this->rgjeff[ijeff];
            if (pjeff->fInUse) {
                cjeff++;
                if (pjeff->tmStart &&
                    GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                    cjeffPlaying++;
                }
            }
        }

        pds->dwLoad = MulDiv(100, cjeff, cjeffMax);

        /*
         *  If there are no effects downloaded, then we are empty.
         */
        pds->dwState = 0;

        if (cjeff == 0) {
            pds->dwState |= DIGFFS_EMPTY;
        } else

        /*
         *  If there are no effects playing, then we are stopped.
         */
        if (cjeffPlaying == 0) {
            pds->dwState |= DIGFFS_STOPPED;
        }

        /*
         *  Actuators are always on (dumb fake hardware)
         */
        pds->dwState |= DIGFFS_ACTUATORSON;

        CJoyEff_LeaveCrit(this);
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DownloadEffect |
 *
 *          Send an effect to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Internal identifier for the effect, taken from
 *          the <t DIEFFECTATTRIBUTES> structure for the effect
 *          as stored in the registry.
 *
 *  @parm   IN OUT LPDWORD | pdwEffect |
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *          On failure, set to zero if the effect is lost,
 *          or left alone if the effect is still valid with
 *          its old parameters.
 *
 *          Note that zero is never a valid effect handle.
 *
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to object identifiers
 *          as follows:
 *
 *          - One type specifier:
 *          <c DIDFT_RELAXIS>,
 *          <c DIDFT_ABSAXIS>,
 *          <c DIDFT_PSHBUTTON>,
 *          <c DIDFT_TGLBUTTON>,
 *          <c DIDFT_POV>.
 *
 *          - One instance specifier:
 *          <c DIDFT_MAKEINSTANCE>(n).
 *
 *          Other bits are reserved and should be ignored.
 *
 *          For example, the value 0x0200104 corresponds to
 *          the type specifier <c DIDFT_PSHBUTTON> and
 *          the instance specifier <c DIDFT_MAKEINSTANCE>(1),
 *          which together indicate that the effect should
 *          be associated with button 1.  Axes, buttons, and POVs
 *          are each numbered starting from zero.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information has changed from
 *          the effect already on the device.
 *
 *          This information is passed to drivers to allow for
 *          optimization of effect modification.  If an effect
 *          is being modified, a driver may be able to update
 *          the effect <y in situ> and transmit to the device
 *          only the information that has changed.
 *
 *          Drivers are not, however, required to implement this
 *          optimization.  All fields in the <t DIEFFECT> structure
 *          pointed to by the <p peff> parameter are valid, and
 *          a driver may choose simply to update all parameters of
 *          the effect at each download.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          This implies that 0 is never a valid effect handle value.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DownloadEffect(PDED pded, DWORD dwId, DWORD dwEffectId,
                       LPDWORD pdwEffect, LPCDIEFFECT peff, DWORD fl)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DownloadEffect,
               (_ "puxxpx", pded, dwId, dwEffectId, *pdwEffect, peff, fl));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    fl;

    if (dwEffectId == 1) {

        PJEFFECT pjeff;
        DWORD dwGain;

        /*
         *  Parameter validation goes here, if any.
         *
         *  Envelope parameter is ignored.
         */

        if (peff->cAxes == 0) {     /* Zero axes?  Nice try */
            hres = E_INVALIDARG;
            goto done;
        }

        /*
         *  Pin above-nominal values to DI_FFNOMINALMAX because
         *  we don't support overgain.
         */
        dwGain = min(peff->dwGain, DI_FFNOMINALMAX);

        /*
         *  We do not support triggers.
         */
        if (peff->dwTriggerButton != DIEB_NOTRIGGER) {
            hres = E_NOTIMPL;
            goto done;
        }

        /*
         *  If no downloading in effect, then we're done.
         */
        if (fl & DIEP_NODOWNLOAD) {
            hres = S_OK;
            goto done;
        }

        if (*pdwEffect) {
            hres = CJoyEff_IsValidId(this, *pdwEffect, &pjeff);
            if (FAILED(hres)) {
                goto done;
            }
        } else {
            DWORD ijeff;

            for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
                if (!this->rgjeff[ijeff].fInUse) {
                    this->rgjeff[ijeff].fInUse = TRUE;
                    pjeff = &this->rgjeff[ijeff];
                    goto haveEffect;
                }
            }
            hres = DIERR_DEVICEFULL;
            goto done;
        }

    haveEffect:;

        SquirtSqflPtszV(sqfl, TEXT("dwFlags=%08x"), peff->dwFlags);
        SquirtSqflPtszV(sqfl, TEXT("cAxes=%d"), peff->cAxes);
        for (fl = 0; fl < peff->cAxes; fl++) {
            SquirtSqflPtszV(sqfl, TEXT(" Axis%2d=%08x Direction=%5d"),
                            fl, peff->rgdwAxes[fl],
                                peff->rglDirection[fl]);
        }

        SquirtSqflPtszV(sqfl, TEXT("dwTrigger=%08x"), peff->dwTriggerButton);

        pjeff->tmDuration = peff->dwDuration / 1000;

        *pdwEffect = (DWORD)(pjeff - this->rgjeff) + 1;		//we are sure this cast will not cause problem
        hres = S_OK;

    } else {
        hres = E_NOTIMPL;
    }

done:;
    CJoyEff_LeaveCrit(this);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DestroyEffect |
 *
 *          Remove an effect from the device.
 *
 *          If the effect is playing, the driver should stop it
 *          before unloading it.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be destroyed.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DestroyEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DestroyEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);
    dwId;

    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        pjeff->fInUse = 0;
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | StartEffect |
 *
 *          Begin playback of an effect.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *          This parameter consists of zero or more
 *          <c DIES_*> flags.  Note, however, that the driver
 *          will never receive the <c DIES_NODOWNLOAD> flag;
 *          the <c DIES_NODOWNLOAD> flag is managed by
 *          DirectInput and not the driver.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_StartEffect(PDED pded, DWORD dwId, DWORD dwEffect,
                    DWORD dwMode, DWORD dwCount)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StartEffect,
               (_ "puxxu", pded, dwId, dwEffect, dwMode, dwCount));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        if (pjeff->tmStart) {
            if (GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                /* Already playing */
                hres = hresLe(ERROR_BUSY);
            } else {
                pjeff->tmStart = GetTickCount();
                hres = S_OK;
            }
        } else {
            pjeff->tmStart = GetTickCount();
            hres = S_OK;
        }
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | StopEffect |
 *
 *          Halt playback of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_StopEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        if (pjeff->tmStart) {
            if (GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                /* It is still playing; stop it */
                hres = S_OK;
            } else {
                hres = S_FALSE;         /* It already stopped on its own */
            }
            pjeff->tmStart = 0;
        } else {
            hres = S_FALSE;         /* It was never started */
        }
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetEffectStatus(PDED pded, DWORD dwId, DWORD dwEffect,
                        LPDWORD pdwStatus)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        DWORD dwStatus;

        dwStatus = 0;
        if (pjeff->tmStart &&
            GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
            dwStatus |= DEV_STS_EFFECT_RUNNING;
        }
        *pdwStatus = dwStatus;
        hres = S_OK;
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetVersions(PDED pded, LPDIDRIVERVERSIONS pvers)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::GetVersions, (_ "pux", pded));

    this = _thisPvNm(pded, ded);

    /*
     *  Returning E_NOTIMPL causes DirectInput to ask the VxD for the same
     *  information.
     */
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CJoyEff_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CJoyEff, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv if multiple interfaces supported */
        PDJE this = _thisPvNm(*ppvObj, ded);

        /*
         *  The critical section must be the very first thing we do,
         *  because only Finalize checks for its existence.
         *
         *  (We might be finalized without being initialized if the user
         *  passed a bogus interface to CJoyEff_New.)
         */
        this->fCritInited = fInitializeCriticalSection(&this->crst);
        if( !this->fCritInited )
        {
            Common_Unhold(this);
            *ppvObj = NULL;
            hres = E_OUTOFMEMORY;
        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CJoyEff_Signature        0x4645454B      /* "JEFF" */

Interface_Template_Begin(CJoyEff)
    Primary_Interface_Template(CJoyEff, IDirectInputEffectDriver)
Interface_Template_End(CJoyEff)

Primary_Interface_Begin(CJoyEff, IDirectInputEffectDriver)
    CJoyEff_DeviceID,
    CJoyEff_GetVersions,
    CJoyEff_Escape,
    CJoyEff_SetGain,
    CJoyEff_SendForceFeedbackCommand,
    CJoyEff_GetForceFeedbackState,
    CJoyEff_DownloadEffect,
    CJoyEff_DestroyEffect,
    CJoyEff_StartEffect,
    CJoyEff_StopEffect,
    CJoyEff_GetEffectStatus,
Primary_Interface_End(CJoyEff, IDirectInputEffectDriver)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\didev.h ===
/*****************************************************************************
 *
 *  DIDev.h
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Common header file for IDirectInputDevice implementation.
 *
 *      The original didev.c file was getting too big, so the
 *      stuff that supports IDirectInputEffect has been split out
 *      into didevef.c.  Since both files need to access the
 *      internal structure of an IDirectInputDevice, we need this
 *      common header file.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDev

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

#define ThisClass CDIDev
    #define ThisInterface TFORM(IDirectInputDevice8)
    #define ThisInterfaceA IDirectInputDevice8A
    #define ThisInterfaceW IDirectInputDevice8W
    #define ThisInterfaceT IDirectInputDevice8
Primary_Interface(CDIDev, TFORM(ThisInterfaceT));
Secondary_Interface(CDIDev, SFORM(ThisInterfaceT));

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @enum   DIOPT |
 *
 *          Device data format optimization levels.
 *
 *  @emem   dioptNone |
 *
 *          Device data format is not optimized at all.  We must read
 *          the device data into a private buffer and copy each field
 *          into the application buffer.
 *
 *  @emem   dioptMatch |
 *
 *          Application data format matches the device data format
 *          in the places where the application requests data at all.
 *          We can read the device data into a private buffer, then
 *          block copy the data into the application buffer.
 *
 *
 *  @emem   dioptDirect |
 *
 *          <e DIOPT.dioptMatch>, plus the entire device data
 *          format fits inside the application format.
 *          We can read the device data directly into the application
 *          buffer.
 *
 *  @emem   dioptEqual |
 *
 *          <e DIOPT.dioptDirect>, plus the device data format
 *          and application data formats are completely equal
 *          (except for fields that the app doesn't explicitly
 *          ask for).
 *          We can issue buffered reads directly into the application
 *          buffer.
 *
 *****************************************************************************/

typedef enum DIOPT
{
    dioptNone       =       0,
    dioptMatch      =       1,
    dioptDirect     =       2,
    dioptEqual      =       3,
} DIOPT;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIDev |
 *
 *          The generic <i IDirectInputDevice> object.
 *
 *          The A and W versions are simply alternate interfaces on the same
 *          underlying object.
 *
 *  @field  IDirectInputDeviceA | ddA |
 *
 *          ANSI DirectInputDevice object (containing vtbl).
 *
 *  @field  IDirectInputDeviceW | ddW |
 *
 *          UNICODE DirectInputDevice object (containing vtbl).
 *
 *  @field  IDirectInputDeviceCallback * | pdcb |
 *
 *          Callback object which handles the low-level device access.
 *
 *  @field  BOOL | fAcquired:1 |
 *
 *          Set if the device has been acquired.  Before the device
 *          can be acquired, the <e CDIDev.pdix> must be set.
 *
 *  @field  BOOL | fAcquiredInstance:1 |
 *
 *          Set if the device instance has been acquired by us.
 *          This lets us know how much needs to be done on the
 *          unacquire.
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  BOOL | fCook:1 |
 *
 *          Set if the device requires that data be cooked.
 *
 *  @field  BOOL | fPolledDataFormat:1 |
 *
 *          Set if the device's data format requires explicit polling.
 *
 *  @field  BOOL | fOnceAcquired:1 |
 *
 *          Set once the device is acquired.
 *
 *  @field  BOOL | fOnceForcedUnacquired:1 |
 *
 *          Set once the device is forced unacquired.
 *
 *  @field  BOOL | fUnacqiredWhenIconic:1 |
 *
 *          Set once the device is unacquired (in CDIDev_CallWndProc) when the app is minimized.
 *
 *  @field  HWND | hwnd |
 *
 *          Window that has requested exclusive access when acquired.
 *
 *  @field  DWORD | discl |
 *
 *          Current value of
 *          <mf IDirectInputDevice8::SetCooperativeLevel> flags.
 *
 *  @field  HANDLE | hNotify |
 *
 *          The notification handle that should be set when the
 *          state of the device changes.  Note that this is actually
 *          a copy of the original handle supplied by the application,
 *          so the handle should be closed when no longer needed.
 *
 *  @field  FARPROC | GetState |
 *
 *          Function that transfers the device data in response
 *          to <mf IDirectInputDevice8::GetDeviceState>.  This field
 *          is computed when the data format is set.
 *
 *  @field  PDIXLAT | pdix |
 *
 *          Pointer to table used for data format translation.
 *          It is indexed by device object; the dwOfs value is the location 
 *          in the application data format where the data should be stored,
 *          the uAppData is the application specified data associated with 
 *          the object.
 *
 *          For example, if the object described by <e CDIDev.df.rgodf[3]> 
 *          should be placed at offset 8 in the application data format, 
 *          then <e CDIDev.pdix[3].dwOfs> = 8.
 *          
 *
 *  @field  PING | rgiobj |
 *
 *          The inverse of <e CDIDev.pdix.dwOfs>.  Given an offset,
 *          converts it to the device object index.
 *
 *          For example, if the object described by <e CDIDev.df.rgodf[3]> 
 *          should be placed at offset 8 in the application data format, 
 *          then <e CDIDev.rgiobj[8]> = 3.
 *          Entries for invalid offsets are -1.
 *
 *  @field  DWORD | dwDataSize |
 *
 *          Size of the data, as requested by the application.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          Device data format.
 *
 *  @field  DIOPT | diopt |
 *
 *          Device optimization level.
 *
 *  @field  int | ibDelta |
 *
 *          If <e CDIDev.diopt> is at least <e DIOPT.dioptMatch>,
 *          contains the shift necessary in order to align the
 *          application data format with the device data format.
 *
 *  @field  int | ibMin |
 *
 *          If <e CDIDev.diopt> is at least <e DIOPT.dioptMatch>,
 *          contains the offset of the first field in the device
 *          format which is valid in both the application and
 *          device data formats.
 *
 *  @field  DWORD | cbMatch |
 *
 *          If <e CDIDev.diopt> is at least <e DIOPT.dioptMatch>,
 *          contains the number of bytes which matched.  This is the
 *          number of bytes that can be block-copied.
 *
 *  @field  PV | pvBuffer |
 *
 *          if <e CDIDev.diopt> is <e DIOPT.dioptMatch> or less,
 *          then contains a scratch buffer equal in size to the
 *          device data format which is used when an unoptimized
 *          data format has been selected.
 *
 *  @field  PV | pvLastBuffer |
 *
 *          Last instantaneous device state received.  This is used
 *          to emulate relative axes.  Only the axis fields of the
 *          structure are valid.
 *
 *  @field  PVXDINSTANCE | pvi |
 *
 *          Instance handle for talking to the VxD.
 *
 *  @field  DWORD | cAxes |
 *
 *          Number of axes on the device.  This in turn yields the
 *          size of the axis offset table.
 *
 *  @field  LPDWORD | rgdwAxesOfs |
 *
 *          Axis offset table.  This is used during relative axis
 *          acquisition mode to convert the absolute numbers into
 *          relative numbers.
 *
 *  @field  HRESULT | hresPolled |
 *
 *          <c S_OK> if the device is interrupt-driven.
 *          <c DI_POLLEDDEVICE> if the device is polled.
 *
 *  @field  HRESULT | hresNotAcquired |
 *
 *          <c DIERR_INPUTLOST> if the device was unacquired without
 *          the application's consent.  <c DIERR_NOTACQUIRED> if
 *          the application should have known better.
 *
 *  @field  DWORD | celtBuf |
 *
 *          Size of the device buffer.
 *
 *  @field  DWORD | celtBufMax |
 *
 *          The largest buffer size we will permit.  There is
 *          a secret property that lets you increase the value,
 *          in case an ISV comes up with a good reason for having
 *          a larger buffer.
 *
 *  @field  LPDWORD | rgdwPOV |
 *
 *          An array of DWORDs listing the locations (data offsets)
 *          of all the optional POVs that were in the app's requested
 *          data format and which we were unable to satisfy.  We
 *          need this so we can set them to -1 in the device state
 *          because most apps are lazy and don't check if the object
 *          actually exists before reading from it.  To keep them safe,
 *          we normally return zeros in nonexistent objects, but for
 *          POVs, the "safe" value is -1, not zero.
 *
 *  @field  DWORD | cdwPOV |
 *
 *          Number of failed optional POVs in the <e CDIDev.rgdwPOV> array.
 *
 *
 *  @field  LPDIRECTINPUTEFFECTSHEPHERD | pes |
 *
 *          The <i IDirectInputEffectShepherd>
 *          object which does the
 *          low-level goo related to the force feedback part of the device.
 *
 *  @field  SHEPHANDLE | sh |
 *
 *          The joystick "tag" which is used by dieshep.c
 *          to determine who owns the joystick.
 *          The <e SHEPHANDLE.dwEffect> field is permanently
 *          zero, so that we can pass it to
 *          <mf IDirectInputEffectShepherd::Escape>
 *          to perform a device escape.
 *
 *  @field  DWORD | dwVersion |
 *
 *          Version number of DirectInput we are emulating.
 *
 *  @field  GPA | gpaEff |
 *
 *          Pointer array of (held) <i IDirectInputEffect> objects
 *          that have been created for this device.
 *
 *  @field  PEFFECTMAPINFO | rgemi |
 *
 *          Array of <t EFFECTMAPINFO> structures, one for each
 *          effect supported by the device.
 *
 *  @field  UINT | cemi |
 *
 *          Number of elements in the <e CDIDev.rgemi> array.
 *
 *  @field  DWORD | didcFF |
 *
 *          Cached device capability flags related to force-feedback.
 *
 *  @field  DIFFDEVICEATTRIBUTES | ffattr |
 *
 *          Contains force feedback device attributes.
 *
 *  @field  DWORD | dwGain |
 *
 *          The gain setting for the device.
 *
 *  @field  DWORD | dwAutoCenter |
 *
 *          The autocenter setting for the device.
 *
 *  @field  BOOL | fNotifiedNotBuffered:1 |
 *
 *          Used only in XDEBUG to remember whether we
 *          notified the caller that the device isn't buffered.
 *
 *  @field  LONG | cCrit |
 *
 *          Number of times the critical section has been taken.
 *          Used only in XDEBUG to check whether the caller is
 *          releasing the object while another method is using it.
 *
 *  @field  DWORD | thidCrit |
 *
 *          The thread that is currently in the critical section.
 *          Used only in DEBUG for internal consistency checking.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Object critical section.  Must be taken when accessing
 *          volatile member variables.
 *
 *  @field  GUID | guid |
 *
 *          The instance GUID of the device we are.
 *
 *****************************************************************************/

typedef struct DIXLAT
{
    DWORD       dwOfs;
    UINT_PTR    uAppData;
} DIXLAT, *PDIXLAT;

typedef struct CDIDev
{

    /* Supported interfaces */
    TFORM(IDirectInputDevice) TFORM(dd);
    SFORM(IDirectInputDevice) SFORM(dd);

    /* 
     *  All interfaces currently have vtbls that are unmodified supersets of 
     *  all previous versions of the interface, so we use the latest interface
     *  for all versions and do not need to keep multiple interfaces.
     */

    IDirectInputDeviceCallback *pdcb;

    BOOL fAcquired:1;
    BOOL fAcquiredInstance:1;
    BOOL fCritInited:1;
    BOOL fCook:1;
    BOOL fPolledDataFormat:1;
    BOOL fOnceAcquired:1;
    BOOL fOnceForcedUnacquired:1;
  #ifdef WINNT  
    BOOL fUnacquiredWhenIconic:1;
  #endif

    /* WARNING!  EVERYTHING AFTER THIS LINE IS ZERO'd ON A RESET */

    HWND hwnd;
    DWORD discl;
    HANDLE hNotify;

    STDMETHOD(GetState)(struct CDIDev *, PV);
    STDMETHOD(GetDeviceState)(struct CDIDev *, PV);
    PDIXLAT pdix;
    PINT rgiobj;
    DWORD dwDataSize;
    DIDATAFORMAT df;
    DIOPT diopt;
    int ibDelta;
    int ibMin;
    DWORD cbMatch;
    PV pvBuffer;
    PV pvLastBuffer;

    PVXDINSTANCE pvi;
    PV pvData;
    DWORD cAxes;
    LPDWORD rgdwAxesOfs;
    HRESULT hresPolled;
    HRESULT hresNotAcquired;
    DWORD celtBuf;
    LPDWORD rgdwPOV;
    DWORD cdwPOV;

    PEFFECTMAPINFO rgemi;
    UINT           cemi;
    DWORD          didcFF;
    SHEPHANDLE     sh;
    DIFFDEVICEATTRIBUTES  ffattr;

    DIDEVCAPS_DX3 dc3;

    /* WARNING!  EVERYTHING ABOVE THIS LINE IS ZERO'd ON A RESET */
    DWORD celtBufMax;           /* Must be first field after zero'd region */

    LPDIRECTINPUTEFFECTSHEPHERD pes;
    DWORD dwVersion;
    GPA gpaEff;
    DWORD dwGain;
    DWORD dwAutoCenter;

    RD(BOOL fNotifiedNotBuffered:1;)
    LONG cCrit;
    DWORD thidCrit;
    CRITICAL_SECTION crst;

    GUID guid;                  /* This is also zero'd on a reset */

    DIAPPHACKS  diHacks;

    LPDIRECTINPUTMAPSHEPHERD pMS;
    
} CDIDev, DD, *PDD;


typedef IDirectInputDeviceA DDA, *PDDA;
typedef IDirectInputDeviceW DDW, *PDDW;
typedef DIDEVICEOBJECTDATA DOD, *PDOD;
typedef LPCDIDEVICEOBJECTDATA PCDOD;

/*****************************************************************************
 *
 *  Methods that live outside didev.c
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  IDirectInputDevice8::SetDataFormat
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetDataFormat(PV pdd, LPCDIDATAFORMAT lpdf _THAT);

#ifdef INCLUDED_BY_DIDEV
    #ifdef XDEBUG

CSET_STUBS(SetDataFormat, (PV pdd, LPCDIDATAFORMAT lpdf), (pdd, lpdf THAT_))

    #else

        #define CDIDev_SetDataFormatA           CDIDev_SetDataFormat
        #define CDIDev_SetDataFormatW           CDIDev_SetDataFormat

    #endif
#endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::GetDeviceState
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceState(PV pdd, DWORD cbDataSize, LPVOID pvData _THAT);

#ifdef INCLUDED_BY_DIDEV
    #ifdef XDEBUG

CSET_STUBS(GetDeviceState, (PV pdd, DWORD cbDataSize, LPVOID pvData),
           (pdd, cbDataSize, pvData THAT_))

    #else

        #define CDIDev_GetDeviceStateA          CDIDev_GetDeviceState
        #define CDIDev_GetDeviceStateW          CDIDev_GetDeviceState

    #endif
#endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::GetDeviceData
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceData(PV pdd, DWORD cbdod, PDOD rgdod,
                         LPDWORD pdwInOut, DWORD fl _THAT);

#ifdef INCLUDED_BY_DIDEV
    #ifdef XDEBUG

CSET_STUBS(GetDeviceData,
           (PV pdd, DWORD cbdod, PDOD rgdod, LPDWORD pdwInOut, DWORD fl),
           (pdd, cbdod, rgdod, pdwInOut, fl THAT_))

    #else

        #define CDIDev_GetDeviceDataA           CDIDev_GetDeviceData
        #define CDIDev_GetDeviceDataW           CDIDev_GetDeviceData

    #endif
#endif


/*****************************************************************************
 *
 *  IDirectInputDevice8::CreateEffect
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_CreateEffect(PV pdd, REFGUID rguid, LPCDIEFFECT peff,
                        LPDIRECTINPUTEFFECT *ppdeff, LPUNKNOWN punkOuter _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(CreateEffect, (PV pdd, REFGUID rguid, LPCDIEFFECT peff,
                          LPDIRECTINPUTEFFECT *ppdeff, LPUNKNOWN punkOuter),
           (pdd, rguid, peff, ppdeff, punkOuter THAT_))

        #else

            #define CDIDev_CreateEffectA            CDIDev_CreateEffect
            #define CDIDev_CreateEffectW            CDIDev_CreateEffect

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::EnumEffects
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumEffectsW(PV pdd, LPDIENUMEFFECTSCALLBACKW pecW, PV pvRef, DWORD fl);

STDMETHODIMP
    CDIDev_EnumEffectsA(PV pdd, LPDIENUMEFFECTSCALLBACKA pecA, PV pvRef, DWORD fl);

/*****************************************************************************
 *
 *  IDirectInputDevice8::GetEffectInfo
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetEffectInfoW(PV pddW, LPDIEFFECTINFOW peiW, REFGUID rguid);

STDMETHODIMP
    CDIDev_GetEffectInfoA(PV pddA, LPDIEFFECTINFOA peiA, REFGUID rguid);

/*****************************************************************************
 *
 *  IDirectInputDevice8::GetForceFeedbackState
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetForceFeedbackState(PV pdd, LPDWORD pdwOut _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(GetForceFeedbackState, (PV pdd, LPDWORD pdwOut),
           (pdd, pdwOut THAT_))

        #else

            #define CDIDev_GetForceFeedbackStateA   CDIDev_GetForceFeedbackState
            #define CDIDev_GetForceFeedbackStateW   CDIDev_GetForceFeedbackState

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::SendForceFeedbackCommand
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SendForceFeedbackCommand(PV pdd, DWORD dwCmd _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(SendForceFeedbackCommand, (PV pdd, DWORD dwCmd),
           (pdd, dwCmd THAT_))

        #else

            #define CDIDev_SendForceFeedbackCommandA    CDIDev_SendForceFeedbackCommand
            #define CDIDev_SendForceFeedbackCommandW    CDIDev_SendForceFeedbackCommand

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::EnumCreatedEffects
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumCreatedEffectObjects(PV pdd,
                                    LPDIENUMCREATEDEFFECTOBJECTSCALLBACK pec,
                                    LPVOID pvRef, DWORD dwFlags _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(EnumCreatedEffectObjects, (PV pdd,
                                      LPDIENUMCREATEDEFFECTOBJECTSCALLBACK pec,
                                      LPVOID pvRef, DWORD dwFlags),
           (pdd, pec, pvRef, dwFlags THAT_))

        #else

            #define CDIDev_EnumCreatedEffectObjectsA CDIDev_EnumCreatedEffectObjects
            #define CDIDev_EnumCreatedEffectObjectsW CDIDev_EnumCreatedEffectObjects

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::Escape
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Escape(PV pdd, LPDIEFFESCAPE pesc _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(Escape, (PV pdd, LPDIEFFESCAPE pesc), (pdd, pesc THAT_))

        #else

            #define CDIDev_EscapeA                  CDIDev_Escape
            #define CDIDev_EscapeW                  CDIDev_Escape

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::Poll
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Poll(PV pdd _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(Poll, (PV pdd), (pdd THAT_))

        #else

            #define CDIDev_PollA                    CDIDev_Poll
            #define CDIDev_PollW                    CDIDev_Poll

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice8::SendDeviceData
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SendDeviceData(PV pdd, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                          LPDWORD pdwInOut, DWORD fl _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(SendDeviceData,
           (PV pdd, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut, DWORD fl),
           (pdd, cbdod, rgdod, pdwInOut, fl THAT_))

        #else

            #define CDIDev_SendDeviceDataA          CDIDev_SendDeviceData
            #define CDIDev_SendDeviceDataW          CDIDev_SendDeviceData

        #endif
    #endif



/*****************************************************************************
 *
 *  IDirectInputDevice8::CDIDev_BuildActionMap
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_BuildActionMapW( PV pdd, LPDIACTIONFORMATW pAFW, LPCWSTR wszName, DWORD fl);

STDMETHODIMP
    CDIDev_BuildActionMapA( PV pdd, LPDIACTIONFORMATA pAFA, LPCSTR szName, DWORD fl);


/*****************************************************************************
 *
 *  IDirectInputDevice8::CDIDev_SetActionMap
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetActionMapW( PV pdd, LPDIACTIONFORMATW pAFW, LPCWSTR wszName, DWORD fl);

STDMETHODIMP
    CDIDev_SetActionMapA( PV pdd, LPDIACTIONFORMATA pAFA, LPCSTR szName, DWORD fl);


/*****************************************************************************
 *
 *  IDirectInputDevice8::CDIDev_GetImageInfo
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetImageInfoW( PV pdd, LPDIDEVICEIMAGEINFOHEADERW piih);

STDMETHODIMP
    CDIDev_GetImageInfoA( PV pdd, LPDIDEVICEIMAGEINFOHEADERA piih);


/*****************************************************************************
 *
 *  Methods in didev.c needed in supporting files
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  IDirectInputDevice8::GetProperty
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetProperty(PV pdd, REFGUID rguid, LPDIPROPHEADER pdiph _THAT);

#ifdef XDEBUG
STDMETHODIMP
    CDIDev_GetPropertyA(PV pdd, REFGUID rguid, LPDIPROPHEADER pdiph);
STDMETHODIMP
    CDIDev_GetPropertyW(PV pdd, REFGUID rguid, LPDIPROPHEADER pdiph);
#else
    #define CDIDev_GetPropertyA             CDIDev_GetProperty
    #define CDIDev_GetPropertyW             CDIDev_GetProperty
#endif

/*****************************************************************************
 *
 *      More internal worker functions.
 *
 *      IsConsists is used for assertion checking.
 *
 *      Finalize calls Unacquire to clean up in the case where the
 *      caller forgot.
 *
 *      Similarly, Reset needs to reset the GetDeviceState pointer.
 *
 *      SetDataFormat needs to set the axis mode property.
 *
 *      CDIDev_InitFF is used by CDIDev_Initialize to initialize
 *      the force-feedback portion of the device.
 *
 *****************************************************************************/

#ifdef DEBUG
BOOL INTERNAL CDIDev_IsConsistent(PDD this);
#endif

STDMETHODIMP CDIDev_InternalUnacquire(PV pdd);

STDMETHODIMP CDIDev_GetAbsDeviceState(PDD this, LPVOID pvData);
STDMETHODIMP CDIDev_GetRelDeviceState(PDD this, LPVOID pvData);

STDMETHODIMP
    CDIDev_RealSetProperty(PDD this, REFGUID rguid, LPCDIPROPHEADER pdiph);

STDMETHODIMP CDIDev_FFAcquire(PDD this);
STDMETHODIMP CDIDev_InitFF(PDD this);
STDMETHODIMP CDIDev_GetLoad(PDD this, LPDWORD pdw);
STDMETHODIMP CDIDev_RefreshGain(PDD this);
HRESULT INTERNAL CDIDev_CreateEffectDriver(PDD this);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diem.h ===
/*****************************************************************************
 *
 *  DIEm.h
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput internal header file for emulation.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEd |
 *
 *          Emulation descriptor.  One of these is created for each
 *          device.  It is never destroyed, so the variable must
 *          be a global variable or memory allocated inside a
 *          container that will eventually be destroyed.
 *
 *          ISSUE-2001/03/29-timgill  Need a better destructor function
 *
 *  @field  LPVOID const | pState |
 *
 *          State buffer that everybody parties into.
 *
 *          It too is never destroyed, so once again it should be
 *          a global variable or live inside something else that
 *          will be destroyed.
 *
 *  @field  LPDWORD const | pDevType |
 *
 *          Array of device type descriptors, indexed by data format
 *          offset.  Used to determine whether a particular piece of
 *          data belongs to an axis, button, or POV.
 *
 *  @field  EMULATIONPROC | Acquire |
 *
 *          Callback function for acquisition and loss thereof.
 *          It is called once when the first client acquires,
 *          and again when the last app unacquires.  It is not
 *          informed of nested acquisition.
 *
 *  @field  LONG | cAcquire |
 *
 *          Number of times the device emulation has been acquired (minus one). 
 *
 *  @field  DWORD | cbData |
 *
 *          Size of the device data type.  In other words, size of
 *          <p pState> in bytes.
 *
 *****************************************************************************/

typedef STDMETHOD(EMULATIONPROC)(struct CEm *, BOOL fAcquire);

typedef struct CEd {

    LPVOID const    pState;
    LPDWORD const   pDevType;
    EMULATIONPROC   Acquire;
    LONG            cAcquire;
    DWORD           cbData;
    ULONG           cRef;
} CEd, ED, *PED;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEm |
 *
 *          Emulation state information.
 *
 *  @field  VXDINSTANCE | vi |
 *
 *          Information shared with parent device.
 *
 *  @field  PEM | pemNext |
 *
 *          Next item in linked list of all active device instances.
 *
 *  @field  LPDWORD | rgdwDf |
 *
 *          Array of items (one for each byte in the device
 *          data format).  This maps each device data format byte
 *          into an application device data offset, or -1 if the
 *          application doesn't care about the corresponding object.
 *
 *  @field  ULONG_PTR  | dwExtra |
 *
 *          Extra information passed in the <t VXDDEVICEFORMAT>
 *          when the device was created.  This is used by each
 *          particular device to encode additional instance infomation.
 *
 *  @field  PED | ped |
 *
 *          The device that owns this instance.  Multiple instances
 *          of the same device share the same <e CEm.ped>.
 *
 *  @field  LONG | cRef |
 *
 *          Reference count.
 *
 *
 *  @field  LONG | cAcquire |
 *
 *          Number of times the device instance has been acquired (minus one). 
 *
 *
 *  @field  BOOL | fWorkerThread |
 *
 *          This is used by low-level hooks and HID devices, which
 *          require a worker thread to collect the data.
 *          This is not cheap, so
 *          instead, we spin up the thread on the first acquire, and
 *          on the unacquire, we keep the thread around so that the next
 *          acquire is fast.  When the last object is released, we finally
 *          kill the thread.
 *
 *****************************************************************************/

typedef struct CEm {

    VXDINSTANCE vi;             /* This must be first */
    struct CEm *pemNext;
    LPDWORD rgdwDf;
    ULONG_PTR   dwExtra;
    PED     ped;
    LONG    cAcquire;
    LONG    cRef;
#ifdef WORKER_THREAD
    BOOL    fWorkerThread;
#endif
#ifdef DEBUG
    DWORD   dwSignature;
#endif
    BOOL    fHidden;
} CEm, EM, *PEM;

#define CEM_SIGNATURE       0x4D4D4545      /* "EEMM" */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PEM | pemFromPvi |
 *
 *          Given an interior pointer to a <t VXDINSTANCE>, retrieve
 *          a pointer to the parent <t CEm>.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PEM INLINE
pemFromPvi(PVXDINSTANCE pvi)
{
    return pvSubPvCb(pvi, FIELD_OFFSET(CEm, vi));
}

/*****************************************************************************
 *
 *          NT low-level hook support
 *
 *          Low-level hooks live on a separate thread which we spin
 *          up when first requested and take down when the last
 *          DirectInput device that used a thread has been destroyed.
 *
 *          If we wanted, we could destroy the thread when the
 *          device is unacquired (rather than when the device is
 *          destroyed), but we cache the thread instead, because
 *          a device that once has been acquired will probably be
 *          acquired again.
 *
 *          To prevent race conditions from crashing us, we addref
 *          our DLL when the thread exists and have the thread
 *          perform a FreeLibrary as its final act.
 *
 *          Note that this helper thread is also used by the HID data
 *          collector.
 *
 *****************************************************************************/

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LLHOOKSTATE |
 *
 *          Low-level hook information about a single hook.
 *
 *  @field  int | cHook |
 *
 *          Number of times the hook has been requested.  If zero,
 *          then there should be no hook.  All modifications to
 *          this field must be interlocked to avoid race conditions
 *          when two threads try to hook or unhook simultaneously.
 *
 *  @field  int | cExcl |
 *
 *          Number of times the hook has been requested in an exclusive 
 *          mode.  This value should always be less than or equal to the 
 *          cHook value.  All modifications to this field must be 
 *          interlocked to avoid race conditions when two threads try to 
 *          hook or unhook simultaneously.
 *
 *  @field  HHOOK | hhk |
 *
 *          The actual hook, if it is installed.  Only the hook thread
 *          touches this field, so it does not need to be protected.
 *
 *  @field  BOOLEAN | fExcluded |
 *
 *          Flag to indicate whether or not exclusivity has been applied.  
 *          Only the hook thread touches this field, so it does not need to 
 *          be protected.
 *
 *****************************************************************************/

typedef struct LLHOOKSTATE {

    int     cHook;
    int     cExcl;
    HHOOK   hhk;
    BOOLEAN fExcluded;
} LLHOOKSTATE, *PLLHOOKSTATE;

LRESULT CALLBACK CEm_LL_KbdHook(int nCode, WPARAM wp, LPARAM lp);
LRESULT CALLBACK CEm_LL_MseHook(int nCode, WPARAM wp, LPARAM lp);

#endif  /* USE_SLOW_LL_HOOKS */

#ifdef WORKER_THREAD

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LLTHREADSTATE |
 *
 *          Low-level hook state for a thread.  Note that this is
 *          a dynamically
 *          allocated structure instead of a static.  This avoids various
 *          race conditions where, for example, somebody terminates the
 *          worker thread and somebody else starts it up before the
 *          worker thread is completely gone.
 *
 *          A pointer to the hThread is passed as the pointer to an array 
 *          of two handles in calls to WaitForMultipleObject so hEvent must 
 *          follow it directly.
 *
 *  @field  DWORD | idThread |
 *
 *          The ID of the worker thread.
 *
 *  @field  LONG | cRef |
 *
 *          Thread reference count.  The thread kills itself when this
 *          drops to zero.
 *
 *  @field  LLHOOKSTATE | rglhs[2] |
 *
 *          Hook states, indexed by LLTS_* values.
 *
 *          These are used only if low-level hooks are enabled.
 *
 *  @field  HANDLE | hThread |
 *
 *          The handle (from the create) of the worker thread.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  HANDLE | hEvent |
 *
 *          The handle to the event used to synchronize with the worker thread.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  GPA | gpaHid |
 *
 *          Pointer array of HID devices which are acquired.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  PEM | pemCheck |
 *
 *          Pointer to Emulation state information.
 *
 *          This is used only if HID support is enabled.
 *
 *****************************************************************************/

#define LLTS_KBD    0
#define LLTS_MSE    1
#define LLTS_MAX    2

typedef struct LLTHREADSTATE {
    DWORD       idThread;
    LONG        cRef;
#ifdef USE_SLOW_LL_HOOKS
    LLHOOKSTATE rglhs[LLTS_MAX];
#endif
    HANDLE      hThread;    /* MUST be followed by hEvent, see above */
    HANDLE      hEvent;     /* MUST follow hThread, see above */
    GPA         gpaHid;
    PEM         pemCheck;
} LLTHREADSTATE, *PLLTHREADSTATE;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  Communicating with the worker thread |
 *
 *          Communication with the worker thread is performed via
 *          <c WM_NULL> messages.  Extra care must be taken to make
 *          sure that someone isn't randomly sending messages to us.
 *
 *          We use the <c WM_NULL> message because there are race
 *          windows where we might post a message to a thread after
 *          it is gone.  During this window, the thread ID might get
 *          recycled, and we end up posting the message to some random
 *          thread that isn't ours.  By using the <c WM_NULL> message,
 *          we are safe in knowing that the target thread won't barf
 *          on the unexpected message.
 *
 *          The <t WPARAM> of the <c WM_NULL> is the magic value
 *          <c WT_WPARAM>.
 *
 *          The <t LPARAM> of the <c WM_NULL> is either a pointer
 *          to the <t CEm> that needs to be refreshed or is
 *          zero if we merely want to check our bearings.
 *
 *****************************************************************************/

#define WT_WPARAM       0

#define PostWorkerMessage(thid, lp)                                     \
        PostThreadMessage(thid, WM_NULL, WT_WPARAM, (LPARAM)(lp))       \

#define NudgeWorkerThread(thid)                                         \
        PostThreadMessage(thid, WM_NULL, WT_WPARAM, (LPARAM)NULL)

HRESULT EXTERNAL NudgeWorkerThreadPem( PLLTHREADSTATE plts, PEM pem );

HRESULT EXTERNAL NotifyWorkerThreadPem(DWORD idThread, PEM pem);

STDMETHODIMP CEm_GetWorkerThread(PEM pem, PLLTHREADSTATE *pplts);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PLLTHREADSTATE | g_plts |
 *
 *          The thread state of the currently-active thread.
 *
 *          This variable needs to be externally accessible
 *          because you can't pass instance data to a windows
 *          hook function.  (Whose idea was that?)
 *
 *****************************************************************************/

extern PLLTHREADSTATE g_plts;

void EXTERNAL CEm_Mouse_OnMouseChange(void);

#endif  /* WORKER_THREAD */

/*
 *  Private helper functions in diem.c
 */

#define FDUFL_NORMAL       0x0000           /* Nothing unusual */
#define FDUFL_UNPLUGGED    VIFL_UNPLUGGED   /* Device disconnected */

void  EXTERNAL CEm_ForceDeviceUnacquire(PED ped, UINT fdufl);
void  EXTERNAL CEm_AddState(PED ped, LPVOID pvData, DWORD tm);
DWORD EXTERNAL CEm_AddEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm);
BOOL  EXTERNAL CEm_ContinueEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq);

STDMETHODIMP CEm_LL_Acquire(PEM this, BOOL fAcquire, ULONG fl, UINT ilts);

HRESULT EXTERNAL
CEm_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut, PED ped);

void EXTERNAL CEm_FreeInstance(PEM this);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_AddRef |
 *
 *          Bump the reference count because we're doing something with it.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void INLINE
CEm_AddRef(PEM this)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    InterlockedIncrement(&this->cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Release |
 *
 *          Drop the reference count and blow it away if it's gone.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void INLINE
CEm_Release(PEM this)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    if (InterlockedDecrement(&this->cRef) == 0) {
        CEm_FreeInstance(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diemk.c ===
/*****************************************************************************
 *
 *  DIEmK.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for keyboard.
 *
 *  Contents:
 *
 *      CEm_Kbd_CreateInstance
 *      CEm_Kbd_InitKeys
 *      CEm_LL_KbdHook
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

/*****************************************************************************
 *
 *          Keyboard emulation
 *
 *****************************************************************************/

STDMETHODIMP CEm_Kbd_Acquire(PEM this, BOOL fAcquire);

static BYTE s_rgbKbd[DIKBD_CKEYS];
HHOOK g_hhkKbd;
LPBYTE g_pbKbdXlat;

ED s_edKbd = {
    &s_rgbKbd,
    0,
    CEm_Kbd_Acquire,
    -1,
    cbX(s_rgbKbd),
    0x0,
};

static BOOL s_fFarEastKbd;
static BOOL fKbdCaptured;
static BOOL fNoWinKey;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_Kbd_KeyboardHook |
 *
 *          Thread-specific keyboard hook filter.
 *
 *          Note that we need only one of these, since only the foreground
 *          window will require a hook.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          VK_* code.
 *
 *  @parm   LPARAM | lp |
 *
 *          Key message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_Kbd_KeyboardHook(int nCode, WPARAM wp, LPARAM lp)
{
    BYTE bScan = 0x0;
    BYTE bAction;
    LRESULT lr;
    
    if (nCode == HC_ACTION || nCode == HC_NOREMOVE) {
        bScan = LOBYTE(HIWORD(lp));
        
        if (HIWORD(lp) & KF_EXTENDED) {
            bScan |= 0x80;
        }
        if (HIWORD(lp) & KF_UP) {
            bAction = 0;
        } else {
            bAction = 0x80;
        }

        bScan = g_pbKbdXlat[bScan];

        if( s_fFarEastKbd )
        {
            /*
             *  Manually toggle these keys on make, ignore break
             */
            if( ( bScan == DIK_KANA ) 
              ||( bScan == DIK_KANJI ) 
              ||( bScan == DIK_CAPITAL ) )
            {
                if( bAction )
                {
                    bAction = s_rgbKbd[bScan] ^ 0x80;
                }
                else
                {
                    goto KbdHook_Skip;
                }
            }
        }

       CEm_AddEvent(&s_edKbd, bAction, bScan, GetMessageTime());
KbdHook_Skip:;
    }

    lr = CallNextHookEx(g_hhkKbd, nCode, wp, lp);

    if( fKbdCaptured ) {
        // test Alt+Tab
        if( ((HIWORD(lp) & KF_ALTDOWN) && (bScan == 0x0F))
            || ((bScan == 0x38 || bScan == 0xb8) && bAction == 0)
        ) {
        } else {
            return TRUE;
        }
    } else if (fNoWinKey) {
        //If left_Winkey or right_WinKey pressed. We really should use virtual keys
        // if we could, but unfortunately no virtual key info is available.
        if( bScan == 0xdb || bScan == 0xdc ) {
            return TRUE;
        }
    }

    return lr;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_Hook_Acquire |
 *
 *          Acquire/unacquire a keyboard via a thread hook.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Kbd_Hook_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Kbd_Hook_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    DllEnterCrit();
    if (fAcquire) {                 /* Install the hook */
        if (this->vi.hwnd) {
            if (!g_hhkKbd) {
                g_hhkKbd = SetWindowsHookEx(WH_KEYBOARD,
                                CEm_Kbd_KeyboardHook, g_hinst,
                                GetWindowThreadProcessId(this->vi.hwnd, 0));
                hres = S_OK;
            }
			else
				hres = E_FAIL;  //already hooked
        } else {
            RPF("Kbd::Acquire: Background mode not supported");
            hres = E_FAIL;
        }
    } else {                        /* Remove the hook */
        UnhookWindowsHookEx(g_hhkKbd);
        g_hhkKbd = 0;
        hres = S_OK;
    }

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_Acquire |
 *
 *          Acquire/unacquire a keyboard in a manner consistent with the
 *          emulation level.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Kbd_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Kbd_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    fKbdCaptured = FALSE;
    fNoWinKey = FALSE;
    if( fAcquire ) {
       if( this->vi.fl & VIFL_CAPTURED ) {
           fKbdCaptured = TRUE;
       } else if( this->vi.fl & VIFL_NOWINKEY ) {
           fNoWinKey = TRUE;
       }
    }

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_KBD ||
            DIGETEMFL(this->vi.fl) == DIEMFL_KBD2);

    if (this->vi.fl & DIMAKEEMFL(DIEMFL_KBD)) {
        AssertF(g_fUseLLHooks);
        hres = CEm_LL_Acquire(this, fAcquire, this->vi.fl, LLTS_KBD);
    } else {
        hres = CEm_Kbd_Hook_Acquire(this, fAcquire);
    }
#else
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_KBD2);
    hres = CEm_Kbd_Hook_Acquire(this, fAcquire);
#endif

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_CreateInstance |
 *
 *          Create a keyboard thing.  Also record what emulation
 *          level we ended up with so the caller knows.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.  The
 *          <e VXDDEVICEFORMAT.dwEmulation> field is updated to specify
 *          exactly what emulation we ended up with.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    LPBYTE pbKbdXlat;

#ifdef WINNT
    /* 
     * In Win2K/WinXP, for legacy free machine, GetKeyboardType will return
     * unreliable result for non-PS2 keyboard. We will use the first time result
     * from GetKeyboardType (for GUID_SysKeyboard) which is also used by Generic 
     * Input to do translation.
     * Related Windows bug: 363700.
     */
    if( !g_pbKbdXlat ) {
#endif        
        pbKbdXlat = (LPBYTE)pdevf->dwExtra;
        if (!pbKbdXlat) {
            pbKbdXlat = pvFindResource(g_hinst, IDDATA_KBD_PCENH, RT_RCDATA);
        }

        AssertF(pbKbdXlat);
        AssertF(fLimpFF(g_pbKbdXlat, g_pbKbdXlat == pbKbdXlat));
        g_pbKbdXlat = pbKbdXlat;
#ifdef WINNT
    }
#endif

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully the test.  It handles the cases where
     *
     *  0.  The app did not ask for emulation, so we give it the
     *      best we can.  (dwEmulation == 0)
     *  1.  The app explicitly asked for emulation 1.
     *      (dwEmulation == DIEMFL_KBD)
     *  2.  The app explicitly asked for emulation 2.
     *      (dwEmulation == DIEMFL_KBD2)
     *  3.  The registry explicitly asked for both emulation modes.
     *      (dwEmulation == DIEMFL_KBD | DIEMFL_KBD2)
     *      Give it the best we can.  (I.e., same as case 0.)
     *
     *  All platforms support emulation 2.  Not all platforms support
     *  emulation 1.  If we want emulation 1 but can't get it, then
     *  we fall back on emulation 2.
     */

    /*
     *  First, if we don't have support for emulation 1, then clearly
     *  we have to use emulation 2.
     */
    
    if (!g_fUseLLHooks 
#ifdef DEBUG
        || (g_flEmulation & DIEMFL_KBD2)
#endif
    ) {
        pdevf->dwEmulation = DIEMFL_KBD2;
    } else

    /*
     *  Otherwise, we have to choose between 1 and 2.  The only case
     *  where we choose 2 is if 2 is explicitly requested.
     */
    if (pdevf->dwEmulation == DIEMFL_KBD2) {
        /* Do nothing */
    } else

    /*
     *  All other cases get 1.
     */
    {
        pdevf->dwEmulation = DIEMFL_KBD;
    }

    /*
     *  Assert that we never give emulation 1 when it doesn't exist.
     */
    AssertF(fLimpFF(pdevf->dwEmulation & DIEMFL_KBD, g_fUseLLHooks));

    /*
     *  Assert that exactly one emulation flag is selected.
     */
    AssertF(pdevf->dwEmulation == DIEMFL_KBD ||
            pdevf->dwEmulation == DIEMFL_KBD2);
#else
    /*
     *  We are being compiled for "emulation 2 only", so that simplifies
     *  matters immensely.
     */
    pdevf->dwEmulation = DIEMFL_KBD2;
#endif

    return CEm_CreateInstance(pdevf, ppviOut, &s_edKbd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_InitKeys |
 *
 *          Initialize pieces of the keyboard state in preparation for
 *          acquisition.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The states of the <c VK_KANA> and <c VK_CAPITAL> keys.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Kbd_InitKeys(PVXDDWORDDATA pvdd)
{

    /* Do this only when not acquired */
    if (s_edKbd.cAcquire < 0) {
        ZeroX(s_rgbKbd);
        if (pvdd->dw & 1) {
            s_rgbKbd[DIK_KANA] = 0x80;
        }
        if (pvdd->dw & 2) {
            s_rgbKbd[DIK_CAPITAL] = 0x80;
        }
        if (pvdd->dw & 8) {
            s_rgbKbd[DIK_KANJI] = 0x80;
        }
        s_fFarEastKbd = ((pvdd->dw & 16)) != 0;
    }

    return S_OK;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_LL_KbdHook |
 *
 *          Low-level keyboard hook filter.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          WM_* keyboard message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Key message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_LL_KbdHook(int nCode, WPARAM wp, LPARAM lp)
{
    PLLTHREADSTATE plts;
    PKBDLLHOOKSTRUCT pllhs = (PV)lp;

    if (nCode == HC_ACTION) {
        BYTE bScan = 0x0;
        BYTE bAction;
      D(DWORD tmStart = GetTickCount());

        wp;                         /* We don't care what the msg is */

        bScan = (BYTE)pllhs->scanCode;

        if( !bScan )
        {
            /* 
             *  ISSUE-2001/03/29-timgill  Special case for non-standard VK codes
             *  The bonus keys on some USB keyboards have zero scan code and 
             *  the extended key flag is clear.
             *  Get the scan code by mapping the VK, then map the 
             *  scan code back, if it is the same as the original VK assume 
             *  the scan code is not extended otherwise assume it is.
             *  This is no where near full proof and only works at all 
             *  because non-extended scan codes are matched first so extended 
             *  scan codes normally fail to translate back.
             */
            bScan = (BYTE)MapVirtualKey( pllhs->vkCode, 0 );
            if( MapVirtualKey( bScan, 3 ) != pllhs->vkCode )
            {
                bScan |= 0x80;
            }
        }
        else if (pllhs->flags & LLKHF_EXTENDED) {
            bScan |= 0x80;
        }

        if (pllhs->flags & LLKHF_UP) {
            bAction = 0;
        } else {
            bAction = 0x80;
        }

        bScan = g_pbKbdXlat[bScan];
        if( s_fFarEastKbd )
        {
            /*
             *  Manually toggle these keys on make, ignore break
             */
            if( ( bScan == DIK_KANA ) 
              ||( bScan == DIK_KANJI ) 
              ||( bScan == DIK_CAPITAL ) )
            {
                if( bAction )
                {
                    bAction = s_rgbKbd[bScan] ^ 0x80;
                }
                else
                {
                  D(SquirtSqflPtszV(sqflTrace | sqfl,
                                    TEXT("KBD! vk=%02x, scan=%02x, fl=%08x, tm=%08x")
                                    TEXT(" being skipped"),
                                    pllhs->vkCode, pllhs->scanCode, pllhs->flags,
                                    pllhs->time );)
                    goto LLKbdHook_Skip;
                }
            }
        }

        CEm_AddEvent(&s_edKbd, bAction, bScan, GetTickCount());

      D(SquirtSqflPtszV(sqflTrace | sqfl,
                        TEXT("KBD! vk=%02x, scan=%02x, fl=%08x, tm=%08x, ")
                        TEXT("in=%08x, out=%08x"),
                        pllhs->vkCode, pllhs->scanCode, pllhs->flags,
                        pllhs->time, tmStart, GetTickCount()));
LLKbdHook_Skip:;

    }

    /*
     *  ISSUE-2001/03/29-timgill  Need method for detecting Ctrl-Alt-Del
     *  If Ctrl+Alt+Del, then force global unacquire!
     *  Need to re-sync Ctrl, Alt, and Del on next keypress.
     *  Unfortunately, there is no way to find out if Ctrl+Alt+Del
     *  has been pressed...
     */

    plts = g_plts;
    if (plts) {
        LRESULT lr;

        lr = CallNextHookEx(plts->rglhs[LLTS_KBD].hhk, nCode, wp, lp);

        if( fKbdCaptured ) {
            if( ((pllhs->flags & LLKHF_ALTDOWN) && (pllhs->vkCode == VK_TAB)) ||
                ((pllhs->flags & LLKHF_UP) && (pllhs->vkCode == VK_LMENU || pllhs->vkCode == VK_RMENU))
            ) {
                return lr;
            } else {
                return TRUE;
            }
        } else if (fNoWinKey) {
            if( pllhs->vkCode == VK_LWIN || pllhs->vkCode == VK_RWIN ) {
                return TRUE;
            } else {
                return lr;
            }
        } else {
            return lr;
        }
    } else {
        /*
         *  This can happen if a message gets posted to the hook after 
         *  releasing the last acquire but before we completely unhook.
         */
        RPF( "DINPUT: Keyboard hook not passed on to next hook" );
        return 1;
    }

}

#endif  /* USE_SLOW_LL_HOOKS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diemm.c ===
/*****************************************************************************
 *
 *  DIEmM.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for mouse.
 *
 *  Contents:
 *
 *      CEm_Mouse_CreateInstance
 *      CEm_Mouse_InitButtons
 *      CEm_LL_MseHook
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

/*****************************************************************************
 *
 *          Mouse globals
 *
 *****************************************************************************/

STDMETHODIMP CEm_Mouse_Acquire(PEM this, BOOL fAcquire);

DIMOUSESTATE_INT s_msEd;

ED s_edMouse = {
    &s_msEd,
    0,
    CEm_Mouse_Acquire,
    -1,
    cbX(DIMOUSESTATE_INT),
    0x0,
};

/*****************************************************************************
 *
 *      The algorithm for applying acceleration is:
 *
 *      dxC = dxR
 *      if A >= 1 and abs(dxR) > T1 then
 *          dxC = dxR * 2
 *          if A >= 2 and abs(dxR) > Thres2 then
 *              dxC = dxR * 4
 *          end if
 *      end if
 *
 *      where
 *          dxR is the raw mouse motion
 *          dxC is the cooked mouse motion
 *          A   is the acceleration
 *          T1  is the first threshold
 *          T2  is the second threshold
 *
 *      Repeat for dy instead of dx.
 *
 *      We can optimize this by simply setting the thresholds to MAXLONG
 *      if they are disabled; that way, abs(dx) will never exceed it.
 *
 *      The result is the following piecewise linear function:
 *
 *      if  0 < abs(dxR) <= T1:         dxC = dxR
 *      if T1 < abs(dxR) <= T2:         dxC = dxR * 2
 *      if T2 < abs(dxR):               dxC = dxR * 4
 *
 *      If you graph this function, you'll see that it's discontinuous!
 *
 *      The inverse mapping of this function is what concerns us.
 *      It looks like this:
 *
 *      if      0 < abs(dxC) <= T1:         dxR = dxC
 *      if T1 * 2 < abs(dxC) <= T2 * 2:     dxR = dxC / 2
 *      if T2 * 4 < abs(dxC):               dxR = dxC / 4
 *
 *      Notice that there are gaps in the graph, so we can fill them in
 *      any way we want, as long as it isn't blatantly *wrong*.  (In the
 *      case where we are using emulation, it is possible to get relative
 *      mouse motions that live in the "impossible" limbo zone due to
 *      clipping.)
 *
 *      if      0 < abs(dxC) <= T1:         dxR = dxC
 *      if T1     < abs(dxC) <= T2 * 2:     dxR = dxC / 2
 *      if T2 * 2 < abs(dxC):               dxR = dxC / 4
 *
 *      Therefore:          (you knew the punch line was coming)
 *
 *      s_rgiMouseThresh[0] = T1 (or MAXLONG)
 *      s_rgiMouseThresh[1] = T2 * 2 (or MAXLONG)
 *
 *
 *****************************************************************************/

static int s_rgiMouseThresh[2];

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_OnMouseChange |
 *
 *          The mouse acceleration changed.  Go recompute the
 *          unacceleration variables.
 *
 *****************************************************************************/

void EXTERNAL
CEm_Mouse_OnMouseChange(void)
{
    int rgi[3];             /* Mouse acceleration information */

    /*
     *  See the huge comment block at the definition of
     *  s_rgiMouseThresh for an explanation of the math
     *  that is happening here.
     *
     *  If acceleration is enabled at all...
     */

    if (SystemParametersInfo(SPI_GETMOUSE, 0, &rgi, 0) && rgi[2]) {
        s_rgiMouseThresh[0] = rgi[0];

        if (rgi[2] >= 2) {
            s_rgiMouseThresh[1] = rgi[1] * 2;

        } else {        /* Disable level 2 acceleration */
            s_rgiMouseThresh[1] = MAXLONG;
        }

    } else {            /* Disable all acceleration */
        s_rgiMouseThresh[0] = MAXLONG;
    }

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_OnMouseChange: ")
                          TEXT("New accelerations %d / %d"),
                          s_rgiMouseThresh[0], s_rgiMouseThresh[1]);

}

/*****************************************************************************
 *
 *          Mouse emulation
 *
 *          Mouse emulation is done by subclassing the window that
 *          captured the mouse.  We then do the following things:
 *
 *          (1) Hide the cursor for the entire vwi.
 *
 *          (2) Capture the mouse.
 *
 *          (3) Clip the cursor to the window.  (If we let the cursor
 *              leave our window, then it messes up capture.)
 *
 *          (4) Keep re-centering the mouse whenever it moves.
 *
 *          (5) Release the capture on WM_SYSCOMMAND so we don't
 *              mess up menus, Alt+F4, etc.
 *
 *          If we are using NT low-level hooks then mouse emulation
 *          is done by spinning a thread to service ll hook
 *          notifications. The victim window is not subclassed.
 *
 *****************************************************************************/

#define dxMinMouse  10
#define dyMinMouse  10

typedef struct MOUSEEMULATIONINFO {
    POINT   ptCenter;               /* Center of client rectangle (screen coords) */
    POINT   ptCenterCli;            /* Center of client rectangle (client coords) */
    LPARAM  lpCenter;               /* ptCenter in the form of an LPARAM */

    BOOL    fInitialized:1;         /* Have we gotten started? */
    BOOL    fNeedExit:1;            /* Should we leave now? */
    BOOL    fExiting:1;             /* Are we trying to leave already? */
    BOOL    fCaptured:1;            /* Have we captured the mouse? */
    BOOL    fHidden:1;              /* Have we hidden the mouse? */
    BOOL    fClipped:1;             /* Have we clipped the mouse? */

    RECT    rcClip;                 /* ClipCursor rectangle */

} MOUSEEMULATIONINFO, *PMOUSEEMULATIONINFO;

LRESULT CALLBACK
CEm_Mouse_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                       UINT_PTR uid, ULONG_PTR dwRef);

/*****************************************************************************
 *
 *          CEm_Mouse_InitCoords
 *
 *
 *****************************************************************************/

BOOL INTERNAL
CEm_Mouse_InitCoords(HWND hwnd, PMOUSEEMULATIONINFO this)
{
    RECT rcClient;
    RECT rcDesk;

    GetClientRect(hwnd, &rcClient);
    MapWindowPoints(hwnd, 0, (LPPOINT)&rcClient, 2);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Client (%d,%d)-(%d,%d)"),
                    rcClient.left,
                    rcClient.top,
                    rcClient.right,
                    rcClient.bottom);

    /*
     *  Clip this with the screen, in case the window extends
     *  off-screen.
     *
     *  Someday: This will need to change when we get multiple monitors.
     */
    GetWindowRect(GetDesktopWindow(), &rcDesk);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Desk (%d,%d)-(%d,%d)"),
                    rcDesk.left,
                    rcDesk.top,
                    rcDesk.right,
                    rcDesk.bottom);

    IntersectRect(&this->rcClip, &rcDesk, &rcClient);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Clip (%d,%d)-(%d,%d)"),
                    this->rcClip.left,
                    this->rcClip.top,
                    this->rcClip.right,
                    this->rcClip.bottom);

    this->ptCenter.x = (this->rcClip.left + this->rcClip.right) >> 1;
    this->ptCenter.y = (this->rcClip.top + this->rcClip.bottom) >> 1;

    this->ptCenterCli.x = this->ptCenter.x - rcClient.left;
    this->ptCenterCli.y = this->ptCenter.y - rcClient.top;

    this->lpCenter = MAKELPARAM(this->ptCenterCli.x, this->ptCenterCli.y);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: lpCenter (%d, %d)"),
                    MAKEPOINTS(this->lpCenter).x,
                    MAKEPOINTS(this->lpCenter).y);

    return this->rcClip.bottom - this->rcClip.top > dyMinMouse &&
           this->rcClip.right - this->rcClip.left > dxMinMouse;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_OnSettingChange |
 *
 *          If the mouse acceleration changed, then update our globals
 *          so we can unaccelerate the mouse properly.
 *
 *  @parm   WPARAM | wp |
 *
 *          SystemParametersInfo value.
 *
 *  @parm   LPARAM | lp |
 *
 *          Name of section that changed.
 *
 *****************************************************************************/

void INTERNAL
CEm_Mouse_OnSettingChange(WPARAM wp, LPARAM lp)
{
    /*
     *  If wp is nonzero, then it is an SPI value.
     *
     *  If wp is zero, then be paranoid if lp == 0 or lp = "windows".
     */
    switch (wp) {

    case 0:                 /* wp == 0; must test lp */
        if (lp == 0) {
            CEm_Mouse_OnMouseChange();
        } else if (lstrcmpi((LPTSTR)lp, TEXT("windows")) == 0) {
            CEm_Mouse_OnMouseChange();
        }
        break;

    case SPI_SETMOUSE:
        CEm_Mouse_OnMouseChange();
        break;

    default:
        /* Some other SPI */
        break;
    }

}

/*****************************************************************************
 *
 *          CEm_Mouse_Subclass_OnNull
 *
 *          WM_NULL is a nudge message that makes us reconsider our
 *          place in the world.
 *
 *          We need this special signal because you cannot call
 *          SetCapture() or ReleaseCapture() from the wrong thread.
 *
 *****************************************************************************/

void INTERNAL
CEm_Mouse_Subclass_OnNull(HWND hwnd, PMOUSEEMULATIONINFO this)
{
    /*
     *  Initialize me if I haven't been already.
     */
    if (!this->fInitialized) {

        this->fInitialized = 1;

        if (!this->fCaptured) {
            this->fCaptured = 1;
            SetCapture(hwnd);
        }

        if (!this->fHidden) {
            this->fHidden = 1;
            SquirtSqflPtszV(sqflCursor,
                            TEXT("CEm_Mouse_Subclass: Hiding mouse"));
            ShowCursor(0);
        }

        /*
         *  Remove any clipping we performed so our math
         *  comes out right again.
         */
        if (this->fClipped) {
            this->fClipped = 0;
            ClipCursor(0);
        }

        /*
         *  (Re)compute mouse acceleration information.
         */
        CEm_Mouse_OnMouseChange();

        if (CEm_Mouse_InitCoords(hwnd, this)) {

            /*
             *  Force the LBUTTON up during the recentering move.
             *
             *  Otherwise, if the user activates the app by clicking
             *  the title bar, USER sees the cursor move while the
             *  left button is down on the title bar and moves the
             *  window.  Oops.
             *
             *  We don't bother forcing the mouse back down after we
             *  have recentered.  I can't figure out how, and it's
             *  not worth it.
             *
             */
            if (GetAsyncKeyState(VK_LBUTTON) < 0) {
                mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
            }

            SetCursorPos(this->ptCenter.x, this->ptCenter.y);

            this->fClipped = 1;
            ClipCursor(&this->rcClip);

        } else {                    /* Can't emulate; window too small */
            this->fNeedExit = 1;
        }

    }

    if (this->fNeedExit && !this->fExiting) {

        /*
         *  Must do this first!  ReleaseCapture() will re-enter us,
         *  and if we continued onward, we'd end up partying on freed
         *  memory.
         */
        this->fExiting = 1;

        if (this->fCaptured) {
            ReleaseCapture();
        }
        if (this->fHidden) {
            SquirtSqflPtszV(sqflCursor,
                            TEXT("CEm_Mouse_Subclass: Showing mouse"));
            ShowCursor(1);
        }

        if (this->fClipped) {
            ClipCursor(0);
        }

        CEm_ForceDeviceUnacquire(&s_edMouse, FDUFL_NORMAL);

		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Subclass %p unhook"), hwnd);
        ConfirmF(RemoveWindowSubclass(hwnd, CEm_Mouse_SubclassProc, 0));
        FreePv(this);

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_RemoveAccel |
 *
 *          Remove any acceleration from the mouse motion.
 *
 *          See the huge comment block at s_rgiMouseThresh
 *          for an explanation of what we are doing.
 *
 *  @parm   int | dx |
 *
 *          Change in coordinate, either dx or dy.
 *
 *****************************************************************************/

int INTERNAL
CEm_Mouse_RemoveAccel(int dx)
{
    int x = abs(dx);
    if (x > s_rgiMouseThresh[0]) {
        dx /= 2;
        if (x > s_rgiMouseThresh[1]) {
            dx /= 2;
        }
    }
    return dx;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | CEm_Mouse_AddState |
 *
 *          Add a mouse state change.
 *
 *          The mouse coordinates are relative, not absolute.
 *
 *  @parm   LPDIMOUSESTATE_INT | pms |
 *
 *          New mouse state, except that coordinates are relative.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the state change was generated.
 *
 *****************************************************************************/

void EXTERNAL
CEm_Mouse_AddState(LPDIMOUSESTATE_INT pms, DWORD tm)
{

    /* Sanity check: Make sure the device has been initialized */
    if( s_edMouse.pDevType ) 
    {
        pms->lX = s_msEd.lX + pms->lX;
        pms->lY = s_msEd.lY + pms->lY;

        /*
         *  HACK!
         *
         *  Memphis and NT5 USER both mess up the case where the presence
         *  of a wheel mouse changes dynamically.  So if we do not have
         *  a wheel in our data format, then don't record it.
         *
         *  The consequence of this is that we will not see any more
         *  buttons or wheels than were present when we queried the number
         *  of buttons in the first place.
         */

         /* If we use Subclassing, the movement of wheel can't be accumulated. 
          * Otherwise, you will see the number keep increasing. Fix bug: 182774.
          * However, if we use low level hook, we need the code. Fix bug: 238987
          */

#ifdef USE_SLOW_LL_HOOKS
       if (s_edMouse.pDevType[DIMOFS_Z]) {
           pms->lZ = s_msEd.lZ + pms->lZ;
       }
#endif

        CEm_AddState(&s_edMouse, pms, tm);
    }
}

/*****************************************************************************
 *
 *          Mouse window subclass procedure
 *
 *****************************************************************************/

#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL   (WM_MOUSELAST + 1)
#endif

#define WM_SETACQUIRE   WM_USER
#define WM_QUITSELF     (WM_USER+1)

LRESULT CALLBACK
CEm_Mouse_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                       UINT_PTR uid, ULONG_PTR dwRef)
{
    PMOUSEEMULATIONINFO this = (PMOUSEEMULATIONINFO)dwRef;
    DIMOUSESTATE_INT ms;
	static BOOL  fWheelScrolling = FALSE;

    switch (wm) {

    case WM_NCDESTROY:
        SquirtSqflPtszV(sqfl, TEXT("CEm_Subclass: window destroyed while acquired"));
        goto unhook;

    case WM_CAPTURECHANGED:
        /*
         *  "An application should not attempt to set the mouse capture
         *   in response to [WM_CAPTURECHANGED]."
         *
         *  So we just unhook.
         */
        SquirtSqflPtszV(sqfl, TEXT("CEm_Subclass: %04x lost to %04x"),
                        hwnd, lp);
        goto unhook;

    case WM_SYSCOMMAND:
        /*
         *  We've got to unhook because WM_SYSCOMMAND will punt if
         *  the mouse is captured.  Otherwise, you couldn't type Alt+F4
         *  to exit the app, which is kind of a bummer.
         */

    unhook:;
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Acquire: %p ")
                              TEXT("exiting because of %04x"), hwnd, wm);
        this->fNeedExit = 1;
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    case WM_NULL:
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    /*
     *  Note that we use WM_WINDOWPOSCHANGED and not WM_SIZE, because
     *  an application which doesn't send WM_WINDOWPOSCHANGED to
     *  DefWindowProc will will never receive a WM_SIZE message.
     *
     *  We need to start over to handle the new screen dimensions,
     *  recenter the mouse, and possibly abandon the operation if
     *  things don't look right.
     */
    case WM_WINDOWPOSCHANGED:
    case WM_DISPLAYCHANGE:
        this->fInitialized = 0;
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    /*
     *  The mouse acceleration may have changed.
     */
    case WM_SETTINGCHANGE:
        CEm_Mouse_OnSettingChange(wp, lp);
        break;

    case WM_MOUSEWHEEL:
        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_SubclassProc: (%d,%d,%d)"),
                        MAKEPOINTS(lp).x, MAKEPOINTS(lp).y, (short)HIWORD(wp));

        ms.lZ = (short)HIWORD(wp);
        fWheelScrolling = TRUE;

        goto lparam;

    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MBUTTONDBLCLK:
  #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
    case WM_XBUTTONDBLCLK:
  #endif

        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_SubclassProc: (%d,%d)"),
                        MAKEPOINTS(lp).x, MAKEPOINTS(lp).y);

        ms.lZ = 0;
    lparam:;

        /*
         *  Don't move the cursor if it hasn't moved.
         *  Otherwise, we recurse ourselves to death.
         *
         *  In fact, if the cursor hasn't moved, ignore this
         *  motion and do only buttons.  Otherwise, you get
         *  into the situation where we end up reacting to
         *  our own recentering.  (D'oh!)
         */
        ms.lX = 0;
        ms.lY = 0;

        if (lp != this->lpCenter && !fWheelScrolling ) {
            SetCursorPos(this->ptCenter.x, this->ptCenter.y);
            ms.lX = MAKEPOINTS(lp).x - this->ptCenterCli.x;
            ms.lY = MAKEPOINTS(lp).y - this->ptCenterCli.y;
        }

        fWheelScrolling = FALSE;

        /*
         *  Note that these return unswapped mouse button data.
         *  Arguably a bug, but it's documented, so it's now a
         *  feature.
         */
        #define GetButton(n) ((GetAsyncKeyState(n) & 0x8000) >> 8)
        ms.rgbButtons[0] = GetButton(VK_LBUTTON);
        ms.rgbButtons[1] = GetButton(VK_RBUTTON);
        ms.rgbButtons[2] = GetButton(VK_MBUTTON);
    #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
        ms.rgbButtons[3] = GetButton(VK_XBUTTON1);
        ms.rgbButtons[4] = GetButton(VK_XBUTTON2);
    #else
        ms.rgbButtons[3] = 0;
        ms.rgbButtons[4] = 0;
    #endif        
        ms.rgbButtons[5] = 0;
        ms.rgbButtons[6] = 0;
        ms.rgbButtons[7] = 0;

        #undef GetButton

        /*
         *  Note that we cannot unaccelerate the mouse when using
         *  mouse capture, because we don't know what sort of
         *  coalescing USER has done for us.
         */

        CEm_Mouse_AddState(&ms, GetMessageTime());

        return 0;

    }

    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_Subclass_Acquire |
 *
 *          Acquire/unacquire a mouse via subclassing.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Mouse_Subclass_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Mouse_Subclass_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    if (fAcquire) {                 /* Install the hook */
        if (this->vi.hwnd && (this->vi.fl & VIFL_CAPTURED)) {
            PMOUSEEMULATIONINFO pmei;
            /*
             *  Prefix considers this memory leaked (mb:34652) because we 
             *  don't save the pointer here.  The memory is freed when the 
             *  hook is removed so this is not really a problem.
             */
            hres = AllocCbPpv(cbX(MOUSEEMULATIONINFO), &pmei);
            if (SUCCEEDED(hres)) {
                if (SetWindowSubclass(this->vi.hwnd,
                                      CEm_Mouse_SubclassProc, 0,
                                      (ULONG_PTR)pmei)) {
                    /* Nudge it */
                    SendNotifyMessage(this->vi.hwnd, WM_NULL, 0, 0L);
                    hres = S_OK;
                } else {
                    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
					SquirtSqflPtszV(sqfl,
                                    TEXT("Mouse::Acquire: ")
                                    TEXT("Window %p is not valid"),
                                    this->vi.hwnd);
                    FreePv(pmei);
                    hres = E_INVALIDARG;
                }
            }

        } else {
            RPF("Mouse::Acquire: Non-exclusive mode not supported");
            hres = E_FAIL;
        }
    } else {                        /* Remove the hook */
        PMOUSEEMULATIONINFO pmei;
        if (GetWindowSubclass(this->vi.hwnd, CEm_Mouse_SubclassProc,
                              0, (PULONG_PTR)&pmei)) {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Acquire: ")
                                  TEXT("Telling %p to exit"), this->vi.hwnd);
            pmei->fNeedExit = 1;
            SendNotifyMessage(this->vi.hwnd, WM_NULL, 0, 0L);
        } else {                    /* Window was already unhooked */
        }
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_Acquire |
 *
 *          Acquire/unacquire a mouse.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Mouse_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Mouse_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE ||
            DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE2);

    if (this->vi.fl & DIMAKEEMFL(DIEMFL_MOUSE)) {
        /* 
         *  This used to use the subclass technique for exclusive mode 
         *  even if low-level hooks were available because low-level 
         *  hooks turn out to be even slower that subclassing.  However, 
         *  subclassing is not transparent as it uses SetCapture which 
         *  causes Accellerator translation to be disabled for the app
         *  which would be a more serious regression from Win9x than 
         *  performance being even worse than we thought.
         */
        AssertF(g_fUseLLHooks);
        hres = CEm_LL_Acquire(this, fAcquire, this->vi.fl, LLTS_MSE);
        if( SUCCEEDED(hres) ) {
            if( fAcquire && this->vi.fl & VIFL_CAPTURED ) {
                if( !this->fHidden ) {
                    ShowCursor(0);
                    this->fHidden = TRUE;
                }
            } else {
                if( this->fHidden ) {
                    ShowCursor(1);
                    this->fHidden = FALSE;
                }
            }
        }
    } else {
        hres = CEm_Mouse_Subclass_Acquire(this, fAcquire);
    }
#else
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE2);
    hres = CEm_Mouse_Subclass_Acquire(this, fAcquire);
#endif

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_CreateInstance |
 *
 *          Create a mouse thing.  Also record what emulation
 *          level we ended up with so the caller knows.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully the test.  It handles the cases where
     *
     *  0.  The app did not ask for emulation, so we give it the
     *      best we can.  (dwEmulation == 0)
     *  1.  The app explicitly asked for emulation 1.
     *      (dwEmulation == DIEMFL_MOUSE)
     *  2.  The app explicitly asked for emulation 2.
     *      (dwEmulation == DIEMFL_MOUSE2)
     *  3.  The registry explicitly asked for both emulation modes.
     *      (dwEmulation == DIEMFL_MOUSE | DIEMFL_MOUSE2)
     *      Give it the best we can.  (I.e., same as case 0.)
     *
     *  All platforms support emulation 2.  Not all platforms support
     *  emulation 1.  If we want emulation 1 but can't get it, then
     *  we fall back on emulation 2.
     */

    /*
     *  First, if we don't have support for emulation 1, then clearly
     *  we have to use emulation 2.
     */
    
    if (!g_fUseLLHooks 
#ifdef DEBUG
        || (g_flEmulation & DIEMFL_MOUSE2)
#endif
    ) {
        pdevf->dwEmulation = DIEMFL_MOUSE2;
    } else

    /*
     *  Otherwise, we have to choose between 1 and 2.  The only case
     *  where we choose 2 is if 2 is explicitly requested.
     */
    if (pdevf->dwEmulation == DIEMFL_MOUSE2) {
        /* Do nothing */
    } else

    /*
     *  All other cases get 1.
     */
    {
        pdevf->dwEmulation = DIEMFL_MOUSE;
    }

    /*
     *  Assert that we never give emulation 1 when it doesn't exist.
     */
    AssertF(fLimpFF(pdevf->dwEmulation & DIEMFL_MOUSE, g_fUseLLHooks));
#else
    /*
     *  We are being compiled for "emulation 2 only", so that simplifies
     *  matters immensely.
     */
    pdevf->dwEmulation = DIEMFL_MOUSE2;
#endif

    hres = CEm_CreateInstance(pdevf, ppviOut, &s_edMouse);

    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_InitButtons |
 *
 *          Initialize the mouse button state in preparation for
 *          acquisition.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The button states.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Mouse_InitButtons(PVXDDWORDDATA pvdd)
{
    /* Do this only when nothing is yet acquired */
    if (s_edMouse.cAcquire < 0) {
       *(LPDWORD)&s_msEd.rgbButtons = pvdd->dw;

        /* randomly initializing axes as well as mouse buttons
           X and Y are not buttons 
           Randomize initial values of X and Y */
        while( !s_msEd.lX )
        {
            s_msEd.lX = GetTickCount();
            s_msEd.lY = (s_msEd.lX << 16) | (s_msEd.lX >> 16);
            s_msEd.lX = s_msEd.lY * (DWORD)((UINT_PTR)&pvdd);
        }
    }
    return S_OK;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_LL_MseHook |
 *
 *          Low-level mouse hook filter.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          WM_* mouse message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Mouse message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_LL_MseHook(int nCode, WPARAM wp, LPARAM lp)
{
    PLLTHREADSTATE plts;

    if (nCode == HC_ACTION) {
        DIMOUSESTATE_INT ms;
        POINT pt;
        PMSLLHOOKSTRUCT pllhs = (PV)lp;

        /*
         *  We are called only on mouse messages, so we may as
         *  well prepare ourselves up front.
         *
         *  Note! that we *cannot* use GetAsyncKeyState on the
         *  buttons, because the buttons haven't been pressed yet!
         *  Instead, we must update the button state based on the
         *  received message.
         */

        ms.lX = 0;
        ms.lY = 0;
        ms.lZ = 0;

        memcpy(ms.rgbButtons, s_msEd.rgbButtons, cbX(ms.rgbButtons));

        /*
         *
         *  Annoying!  We receive swapped buttons, so we need to
         *  unswap them.  I mark this as `annoying' because
         *  GetAsyncKeyState returns unswapped buttons, so sometimes
         *  I do and sometimes I don't.  But it isn't `*wrong*'
         *  because it is the right thing.  Arguably, GetAsyncKeyState
         *  is the one that is broken.
         */

        if (GetSystemMetrics(SM_SWAPBUTTON)) {

            /*
             *  Assert that the left and right button messages
             *  run in parallel.
             */

            CAssertF(WM_RBUTTONDOWN - WM_LBUTTONDOWN     ==
                     WM_RBUTTONDBLCLK - WM_LBUTTONDBLCLK &&
                     WM_RBUTTONDBLCLK - WM_LBUTTONDBLCLK ==
                     WM_RBUTTONUP     - WM_LBUTTONUP);

            switch (wp) {

            case WM_LBUTTONDOWN:
            case WM_LBUTTONDBLCLK:
            case WM_LBUTTONUP:
                wp = (wp - WM_LBUTTONUP) + WM_RBUTTONUP;
                break;

            case WM_RBUTTONDOWN:
            case WM_RBUTTONDBLCLK:
            case WM_RBUTTONUP:
                wp = (wp - WM_RBUTTONUP) + WM_LBUTTONUP;
                break;

            }
        }

        switch (wp) {           /* wp = message number */

        case WM_MOUSEWHEEL:
            SquirtSqflPtszV(sqfl, TEXT("CEm_LL_MseHook: (%d,%d,%d)"),
                            pllhs->pt.x,
                            pllhs->pt.y,
                            pllhs->mouseData);

            ms.lZ = (short int)HIWORD(pllhs->mouseData);
            goto lparam;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
            ms.rgbButtons[0] = 0x80;
            goto move;

        case WM_LBUTTONUP:
            ms.rgbButtons[0] = 0x00;
            goto move;

        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
            ms.rgbButtons[1] = 0x80;
            goto move;

        case WM_RBUTTONUP:
            ms.rgbButtons[1] = 0x00;
            goto move;

        case WM_MBUTTONDOWN:
        case WM_MBUTTONDBLCLK:
            ms.rgbButtons[2] = 0x80;
            goto move;

        case WM_MBUTTONUP:
            ms.rgbButtons[2] = 0x00;
            goto move;

    #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
        case WM_XBUTTONDOWN:
        case WM_XBUTTONDBLCLK:
            /*
             * Using switch can be easily extended to support more buttons.
             */
            switch ( HIWORD(pllhs->mouseData) ) {
            	case XBUTTON1:
            	    ms.rgbButtons[3] = 0x80;
            	    break;

            	case XBUTTON2:
            	    ms.rgbButtons[4] = 0x80;
            	    break;

                /*
                 * When we support more than 5 buttons, take care of them.
            	case XBUTTON3:
            	    ms.rgbButtons[5] = 0x80;
            	    break;

            	case XBUTTON4:
            	    ms.rgbButtons[6] = 0x80;
            	    break;

            	case XBUTTON5:
            	    ms.rgbButtons[7] = 0x80;
            	    break;
                 */
            }
            
            goto move;

        case WM_XBUTTONUP:
            /*
             * Using switch can be easily extended to support more buttons.
             */
            switch ( HIWORD(pllhs->mouseData) ) {
            	case XBUTTON1:
            	    ms.rgbButtons[3] = 0x00;
            	    break;

            	case XBUTTON2:
            	    ms.rgbButtons[4] = 0x00;
            	    break;
                /*
                 * When we support more than 5 buttons, take care of them.
            	case XBUTTON3:
            	    ms.rgbButtons[5] = 0x00;
            	    break;

            	case XBUTTON4:
            	    ms.rgbButtons[6] = 0x00;
            	    break;

            	case XBUTTON5:
            	    ms.rgbButtons[7] = 0x00;
            	    break;
                 */
            }
            goto move;
    #endif

        case WM_MOUSEMOVE:
            SquirtSqflPtszV(sqfl, TEXT("CEm_LL_MseHook: (%d,%d)"),
                            pllhs->pt.x, pllhs->pt.y);

        move:;

        lparam:;

            GetCursorPos(&pt);

            ms.lX = CEm_Mouse_RemoveAccel(pllhs->pt.x - pt.x);
            ms.lY = CEm_Mouse_RemoveAccel(pllhs->pt.y - pt.y);

            CEm_Mouse_AddState(&ms, GetTickCount());

        }

    }

    /*
     *  Eat the message by returning non-zero if at least one client 
     *  is exclusive.
     */

    plts = g_plts;
    if (plts) {
        LRESULT rc;

        rc = CallNextHookEx(plts->rglhs[LLTS_MSE].hhk, nCode, wp, lp);
        if (!plts->rglhs[LLTS_MSE].cExcl) {
            return rc;
        }
    } else {
        /*
         *  This can happen if a message gets posted to the hook after 
         *  releasing the last acquire but before we completely unhook.
         */
        RPF( "DINPUT: Mouse hook not passed on to next hook" );
    }

    return 1;
}


#endif  /* USE_SLOW_LL_HOOKS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diexcl.c ===
/*****************************************************************************
 *
 *  DIExcl.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Management and negotiation of exclusive access.
 *
 *  Contents:
 *
 *      Excl_Acquire
 *      Excl_Unacquire
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflExcl

#pragma BEGIN_CONST_DATA

#ifndef WINNT
TCHAR c_tszVxd[] = TEXT("\\\\.\\DINPUT.VXD");
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHAREDOBJECT |
 *
 *          Each object that can be taken exclusively receives one of
 *          these structures.  This structure is shared across processes,
 *          so you must protect access with the global DLL mutex.
 *
 *          You would think that we could just use a named semaphore.
 *          Well, that won't work because if the app crashes, nobody
 *          will release the semaphore token and the device will be
 *          unavailable forever.
 *
 *          And we can't use a named mutex because mutexes are tracked
 *          on a per-thread basis, but device acquisition is maintained
 *          on a per-process basis.
 *
 *          So instead we have to roll our own "process-level mutex".
 *
 *          To conserve memory, we dump all our tiny <t SHAREDOBJECT>
 *          structures into a single page.  This means that we cannot
 *          support more than about 4000 / sizeof(SHAREDOBJECT) =
 *          140 devices simultaneously acquired exclusively.
 *
 *          Since USB maxes out at 64 devices, we've got plenty of room.
 *
 *          WARNING!  This structure may not change between DEBUG and
 *          RETAIL.  Otherwise, you have problems if one DirectInput
 *          app is using DEBUG and another is using RETAIL.
 *
 *  @field  GUID | guid |
 *
 *          The identifier for the device that is acquired exclusively.
 *
 *  @field  HWND | hwndOwner |
 *
 *          The window handle associated with the device that has
 *          obtained exclusive access.
 *
 *  @field  DWORD | pidOwner |
 *
 *          The process ID of the owner window.  This is used as a
 *          cross-check against <f hwndOwner> in case the application
 *          which is the owner suddenly crashes.
 *
 *  @field  DWORD | discl |
 *
 *          Cooperative level with which the device was acquired.
 *          We care about foreground-ness so that
 *          we can steal acquisition from a window that
 *          has stopped responding.
 *
 *****************************************************************************/

typedef struct SHAREDOBJECT
{
    GUID    guid;
    HWND    hwndOwner;
    DWORD   pidOwner;
    DWORD   discl;
} SHAREDOBJECT, *PSHAREDOBJECT;

typedef const SHAREDOBJECT *PCSHAREDOBJECT;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @define csoMax | (cbShared - cbX(SHAREDOBJECTHEADER)) / cbX(SHAREDOBJECT) |
 *
 *          The maximum number of simultaneously acquired devices.
 *
 *****************************************************************************/

    #define cbShared    4096
    #define csoMax ((cbShared - cbX(SHAREDOBJECTHEADER)) / cbX(SHAREDOBJECT))

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHAREDOBJECTPAGE |
 *
 *          A header followed by an array of shared objects.
 *
 *          The header must be first.  <c g_soh> relies on it.
 *
 *  @field  SHAREDOBJECTHEADER | soh |
 *
 *          The header.
 *
 *  @field  SHAREDOBJECT | rgso[csoMax] |
 *
 *          Array of shared object structures.
 *
 *****************************************************************************/

typedef struct SHAREDOBJECTPAGE
{
    SHAREDOBJECTHEADER soh;
    SHAREDOBJECT rgso[csoMax];
} SHAREDOBJECTPAGE, *PSHAREDOBJECTPAGE;

void INLINE
    CheckSharedObjectPageSize(void)
{
    CAssertF(cbX(SHAREDOBJECTPAGE) <= cbShared);
    CAssertF(cbX(SHAREDOBJECTPAGE) + cbX(SHAREDOBJECT) > cbShared);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSHAREDOBJECT | Excl_FindGuid |
 *
 *          Locate a GUID in the shared object array.
 *
 *          The shared global mutex must already be taken.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to locate.
 *
 *  @returns
 *
 *          A pointer to the entry, or 0 if not found.
 *
 *
 *****************************************************************************/

PSHAREDOBJECT INTERNAL
    Excl_FindGuid(PCGUID pguid)
{
    PSHAREDOBJECTPAGE psop;
    PSHAREDOBJECT pso, psoMax;
    DWORD Data1;
    EnterProcI(Excl_FindGuid, (_ "G", pguid));

    psop = g_psop;
    Data1 = pguid->Data1;

    AssertF(g_psop);
    for(pso = &psop->rgso[0], psoMax = &psop->rgso[psop->soh.cso];
       pso < psoMax; pso++)
    {
        if(pso->guid.Data1 == Data1 && IsEqualGUID(pguid, &pso->guid))
        {
            goto done;
        }
    }

    pso = 0;

    done:;
    ExitProcX((UINT_PTR)pso);
    return pso;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_CanStealPso |
 *
 *          Determine whether the <t SHAREDOBJECT> is self-consistent
 *          and represents an instance which validly holds the
 *          exclusive acquisition.  If so, then it cannot be stolen.
 *          Else, it is dead and can be stolen.
 *
 *  @parm   PCSHAREDOBJECT | pso |
 *
 *          The <t SHAREDOBJECT> structure to validate.
 *
 *  @returns
 *
 *          <c S_OK> if acquisition can be stolen, or
 *          <c DIERR_OTHERAPPHASPRIO> if acquisition is validly
 *          held by another instance.
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_CanStealPso(PCSHAREDOBJECT pso)
{
    HRESULT hres = S_OK;

    /*
     *  The window handle should be valid and still refer to the pid.
     */
    if(GetWindowPid(pso->hwndOwner) == pso->pidOwner)
    {

        if( pso->discl & DISCL_FOREGROUND  )
        {
            if( GetForegroundWindow() != pso->hwndOwner)
            {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				RPF("Acquire: can't steal Pso because it belongs to another app. (current hwnd=0x%p)",
                    pso->hwndOwner);
                hres = DIERR_OTHERAPPHASPRIO;
            } else
            {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				RPF("Acquire: Current owner hwnd=0x%p has priority; "
                    "stealing", pso->hwndOwner);
                hres = S_OK;
            }
        }
    } else
    {
        /*
         *  App died.  Can steal.
         */
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		RPF("Acquire: Previous owner pid=0x%p mysteriously died; "
            "stealing", pso->pidOwner);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_Acquire |
 *
 *          Attempt to acquire the device exclusively.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to acquire.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle with which to associate the device.
 *
 *  @parm   DWORD | discl |
 *
 *          Flags describing cooperative level.
 *          We are interested only in devices acquired exclusively.
 *
 *  @returns
 *
 *          S_OK on success, or
 *
 *          DIERR_OTHERAPPHASPRIO
 *          hresLe(ERROR_INVALID_WINDOW_HANDLE)
 *
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_Acquire(PCGUID pguid, HWND hwnd, DWORD discl)
{
    HRESULT hres;

    AssertF(g_psop);
    if(discl & DISCL_EXCLUSIVE)
    {

        /*
         *  Window must be owned by this process.
         */
        if(GetWindowPid(hwnd) == GetCurrentProcessId())
        {

            PSHAREDOBJECT pso;

            WaitForSingleObject(g_hmtxGlobal, INFINITE);

            pso = Excl_FindGuid(pguid);

            /*
             *  If we found a match, then it might be a sharing violation.
             */
            if(pso)
            {
                hres = Excl_CanStealPso(pso);
            } else
            {
                /*
                 *  Allocate a slot for it.
                 */
                if(g_psop->soh.cso < csoMax)
                {
                    pso = &g_psop->rgso[g_psop->soh.cso++];
                    pso->guid = *pguid;
                    hres = S_OK;
                } else
                {
                    //ISSUE-2001/03/29-timgill hard limit on number of exclusive devices
                    //Can be annoying
                    RPF("Too many devices acquired exclusively");
                    hres = E_FAIL;
                }
            }

            if(SUCCEEDED(hres))
            {

                pso->hwndOwner = hwnd;
                pso->pidOwner = GetCurrentProcessId();
                pso->discl = discl;

                hres = S_OK;
            }

            ReleaseMutex(g_hmtxGlobal);
        } else
        {
            hres = hresLe(ERROR_INVALID_WINDOW_HANDLE);
        }
    } else
    {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_Unacquire |
 *
 *          Undo the effects of an acquire.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to acquire.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle with which to associate the device.
 *
 *  @parm   DWORD | discl |
 *
 *          Flags describing cooperative level.
 *          We are interested only in devices acquired exclusively.
 *
 *****************************************************************************/

void EXTERNAL
    Excl_Unacquire(PCGUID pguid, HWND hwnd, DWORD discl)
{

    AssertF(g_psop);
    if(discl & DISCL_EXCLUSIVE)
    {

        PSHAREDOBJECT pso;

        WaitForSingleObject(g_hmtxGlobal, INFINITE);

        pso = Excl_FindGuid(pguid);

        /*
         *  Make sure it's really ours.
         */
        if(pso && pso->hwndOwner == hwnd &&
           pso->pidOwner == GetCurrentProcessId())
        {

            /*
             *  Delete the entry and close up the gap.
             */

            *pso = g_psop->rgso[--g_psop->soh.cso];

        }

        ReleaseMutex(g_hmtxGlobal);

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_Init |
 *
 *          Initialize the exclusive device manager.
 *
 *  @returns
 *
 *          <c S_OK> if all is well.
 *
 *          <c E_FAIL> if something is horribly wrong.
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_Init(void)
{
    HRESULT hres;
    TCHAR tszName[ctchNameGuid];

    DllEnterCrit();


    /*
     *  Create the global mutex used to gate access to shared memory.
     */

    if(g_hmtxGlobal == 0)
    {

        NameFromGUID(tszName, &IID_IDirectInputW);
        g_hmtxGlobal = CreateMutex(0, TRUE, tszName);

        if(g_hmtxGlobal)
        {
			/*
			 * If we need to do smth only once, we can do:
			 * if ( GetLastError() != ERROR_ALREADY_EXISTS )
			 * {
			 *		do our stuff
			 *	}
			 */
            
            g_flEmulation = RegQueryDIDword(NULL, REGSTR_VAL_EMULATION, 0);

#ifndef WINNT
            /*
             *  We have to open the VxD while we own the global mutex in order 
             *  to avoid a race condition that occurs when two processes try 
             *  to open a VxD at the same time.  See DInput VxD for details.
             */
            if (_OpenVxDHandle)
            {
                /*
                 *  CreateFile on a \\.\ name does not check the dwCreationDisposition 
                 *  parameter but BoundsChecker does so use a valid value.
                 */
                g_hVxD = CreateFile(c_tszVxd, 0, 0, 0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);

                if( g_hVxD != INVALID_HANDLE_VALUE )
                {
                    LONG lGranularity;

                    /*
                     *  If we can't get the sequence number (weird), then set it
                     *  back to NULL so it will point at the shared memory
                     *  block just like on NT.
                     */
                    if (FAILED(IoctlHw(IOCTL_GETSEQUENCEPTR, 0, 0,
                                       &g_pdwSequence, cbX(g_pdwSequence))))
                    {
                        g_pdwSequence = 0;
                    }

                    if (SUCCEEDED(IoctlHw(IOCTL_MOUSE_GETWHEEL, 0, 0,
                                          &lGranularity, cbX(lGranularity))))
                    {
                        g_lWheelGranularity = lGranularity;
                    }
                } 
                else
                {
                    RPF( "ERROR: Cannot load %s", &c_tszVxd[4] );
                }
            }
#endif
 
            /*
             *  We defer ExtDll work until now, because it is not safe to
             *  call LoadLibrary during PROCESS_ATTACH.
             *
             *  We also steal g_hmtxGlobal to protect us from doing it twice.
             */
            ExtDll_Init();


            ReleaseMutex(g_hmtxGlobal);

        } 
        else
        {
            RPF("Cannot create shared semaphore %s", tszName);
            hres = E_FAIL;
            goto fail;
        }

    }

    /*
     *  Create the shared memory.
     *
     *  Warning!  The file mapping handle must be kept alive
     *  so its name stays alive.  NT destroys the file mapping
     *  object when you close the handle; as a result, the
     *  name goes away with it and another instance of
     *  DirectInput fails to find it.
     */

    if(g_psop == 0)
    {

        NameFromGUID(tszName, &IID_IDirectInputDeviceW);

        g_hfm = CreateFileMapping(INVALID_HANDLE_VALUE, 0,
                                  PAGE_READWRITE, 0,
                                  cbShared, tszName);

        if(g_hfm)
        {
            g_psop = MapViewOfFile(g_hfm, FILE_MAP_WRITE | FILE_MAP_READ,
                                   0, 0, 0);
            if(g_psop)
            {

            } else
            {
                RPF("Cannot map shared memory block %s", tszName);
                hres = E_FAIL;
                goto fail;
            }

        } else
        {
            RPF("Cannot create shared memory block %s", tszName);
            hres = E_FAIL;
            goto fail;
        }
    }

    /*
     *  Create the global mutex used to gate access to joystick info.
     */

    if(g_hmtxJoy == 0)
    {
        NameFromGUID(tszName, &IID_IDirectInputDevice2A);
        g_hmtxJoy = CreateMutex(0, 0, tszName);

        if(g_hmtxJoy)
        {

        } else
        {
            RPF("Cannot create shared semaphore %s", tszName);
            hres = E_FAIL;
            goto fail;
        }
    
    
        /* 
         * We shall steal the joystick Mutex to build the Bus list
         * for the first time. 
         * It is very unlikely that the list will change. ( PCMCIA cards ! )
         * And when it does change we can expect the joyConfig interface will
         * be pinged.     
         */
        DIBus_BuildList(FALSE);
    }


    /*
     *  If we don't have a global sequence number from the driver,
     *  then use the one in the shared memory block instead.
     */
    if(g_pdwSequence == 0)
    {
        g_pdwSequence = &g_psoh->dwSequence;
    }
    
    hres = S_OK;

fail:;
    DllLeaveCrit();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | Excl_UniqueGuidInteger |
 *
 *          Generate a unique number used by DICreateGuid to make sure
 *          that we don't generate two pseudoGUIDs with the same value.
 *
 *  @returns
 *
 *          An integer that has not been returned by this function
 *          yet.
 *
 *****************************************************************************/

LONG EXTERNAL
    Excl_UniqueGuidInteger(void)
{
    LONG lRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    lRc = ++g_psop->soh.cguid;

    ReleaseMutex(g_hmtxGlobal);

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | Excl_GetConfigChangedTime |
 *
 *          Retrieves tmConfigChanged in g_psop->soh. 
 *
 *  @returns
 *
 *          tmConfigChanged
 *****************************************************************************/

DWORD EXTERNAL
    Excl_GetConfigChangedTime()
{
    DWORD dwRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    dwRc = g_psop->soh.tmConfigChanged;

    ReleaseMutex(g_hmtxGlobal);

    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_SetConfigChangedTime |
 *
 *          Sets tmConfigChanged in g_psop->soh. 
 *
 *  @returns
 *
 *          void
 *****************************************************************************/

void EXTERNAL
    Excl_SetConfigChangedTime(DWORD tm)
{
    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    g_psop->soh.tmConfigChanged = tm;

    ReleaseMutex(g_hmtxGlobal);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dieshep.c ===
/*****************************************************************************
 *
 *  DIEShep.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInputEffectDriver shepherd.
 *
 *      The shepherd does the annoying work of babysitting the
 *      external IDirectInputDriver.
 *
 *      It makes sure nobody parties on bad handles.
 *
 *      It handles cross-process (or even intra-process) effect
 *      management.
 *
 *      It caches the joystick ID so you don't have to.
 *
 *  Contents:
 *
 *      CEShep_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEShep

#pragma BEGIN_CONST_DATA


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

  Primary_Interface(CEShep, IDirectInputEffectShepherd);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEShep |
 *
 *          The <i IDirectInputEffectShepherd> object, which
 *          babysits an <i IDirectInputEffectDriver>.
 *
 *  @field  IDirectInputEffectShepherd | des |
 *
 *          DirectInputEffectShepherd object (containing vtbl).
 *
 *  @field  IDirectInputEffectDriver * | pdrv |
 *
 *          Delegated effect driver interface.
 *
 *  @field  UINT | idJoy |
 *
 *          Joystick identification number.
 *
 *  @field  HINSTANCE | hinst |
 *
 *          The instance handle of the DLL that contains the effect
 *          driver.
 *
 *****************************************************************************/

typedef struct CEShep {

    /* Supported interfaces */
    IDirectInputEffectShepherd des;

    IDirectInputEffectDriver *pdrv;

    UINT        idJoy;
    HINSTANCE   hinst;

} CEShep, ES, *PES;

typedef IDirectInputEffectShepherd DES, *PDES;
#define ThisClass CEShep
#define ThisInterface IDirectInputEffectShepherd

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CEShep)
Default_AddRef(CEShep)
Default_Release(CEShep)

#else

#define CEShep_QueryInterface   Common_QueryInterface
#define CEShep_AddRef           Common_AddRef
#define CEShep_Release          Common_Release

#endif

#define CEShep_QIHelper         Common_QIHelper
#define CEShep_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEShep_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CEShep_Finalize(PV pvObj)
{
    PES this = pvObj;

    Invoke_Release(&this->pdrv);

    if (this->hinst) {
        FreeLibrary(this->hinst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CEShep | UnlockDevice |
 *
 *          Unlock the joystick table after we are finished messing
 *          with the device.
 *
 *****************************************************************************/

void INLINE
CEShep_UnlockDevice(void)
{
    ReleaseMutex(g_hmtxJoy);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | LockDevice |
 *
 *          Validate that the the device access token is still valid.
 *
 *          If so, then take the joystick mutex to prevent someone
 *          from dorking with the device while we're using it.
 *          Call <f CEShep_UnlockDevice> when done.
 *
 *          If not, then try to steal ownership if requested.
 *
 *          Else, fail.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Handle to lock.
 *
 *  @parm   DWORD | dwAccess |
 *
 *          If <c DISFFC_FORCERESET>, then force ownership of the device.
 *          This is done as part of device acquisition to kick out the
 *          previous owner.
 *
 *          Otherwise, if the device belongs to somebody else, then
 *          leave it alone.
 *
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> if the lock failed.
 *          Note that
 *          <mf IDirectInputEffectDevice2::SetForceFeedbackState>
 *          and
 *          <mf IDirectInputEffectDevice2::GetForceFeedbackState>
 *          are particularly keen on this error code.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_LockDevice(PES this, PSHEPHANDLE psh, DWORD dwAccess)
{
    HRESULT hres;
    EnterProc(CEShep_LockDevice, (_ "puu", this, psh->dwTag, dwAccess));

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    /*
     *  Note that DISFFC_FORCERESET allows unconditional access.
     *  DISFFC_FORCERESET is used when we perform the initial reset
     *  after acquiring, so we can legitimately steal the device
     *  from the previous owner.
     */
    if (dwAccess & DISFFC_FORCERESET) {
        hres = S_OK;
    } else if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
        hres = S_OK;
    } else {
        ReleaseMutex(g_hmtxJoy);
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CEShep | UnlockEffect |
 *
 *          Unlock the joystick table after we are finished messing
 *          with an effect.
 *
 *****************************************************************************/

void INLINE
CEShep_UnlockEffect(void)
{
    ReleaseMutex(g_hmtxJoy);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | LockEffect |
 *
 *          Validate that the the effect handle is still valid.
 *
 *          If so, then take the joystick mutex to prevent someone
 *          from dorking with the device while we're using the handle.
 *          Call <f CEShep_UnlockEffect> when done.
 *
 *          If not, then set the effect handle to zero to indicate
 *          that it's bogus.  The
 *          <mf IDirectInputEffectShepherd::DownloadEffect>
 *          method relies on the zero-ness.
 *          It is also asserted in <i IDirectInputEffect> to make
 *          sure we don't accidentally leave effects on the device
 *          when we leave.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Handle to lock.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED> if the lock failed.
 *          Note that
 *          <mf IDirectInputEffectShepherd::DownloadEffect> and
 *          <mf IDirectInputEffectShepherd::DestroyEffect> assume
 *          that this is the only possible error code.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_LockEffect(PES this, PSHEPHANDLE psh)
{
    HRESULT hres;
    EnterProc(CEShep_LockEffect, (_ "pux", this, psh->dwTag, psh->dwEffect));

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag && psh->dwEffect) {
        hres = S_OK;
    } else {
        psh->dwEffect = 0;
        ReleaseMutex(g_hmtxJoy);
        hres = DIERR_NOTDOWNLOADED;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *
 *          For example, if a device driver is passed
 *          <p dwExternalID> = 2 and <p dwInteralID> = 1,
 *          then this means that unit 1 on the device
 *          corresponds to joystick ID number 2.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is begining.
 *          Zero if the access to the device is ending.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Reserved for future use (HID).
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DeviceID(PDES pdes, DWORD dwExternalID, DWORD fBegin, LPVOID pvReserved)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DeviceID,
               (_ "puu", pdes, dwExternalID, fBegin));

    this = _thisPvNm(pdes, des);

    AssertF(dwExternalID < cJoyMax);

    if (dwExternalID < cJoyMax) {
        VXDINITPARMS vip;

        /*
         *  If this device has never been used before,
         *  go grab its global gain.
         */
        WaitForSingleObject(g_hmtxJoy, INFINITE);

        if (g_psoh->rggjs[dwExternalID].dwTag == 0) {
            DIJOYCONFIG cfg;

            g_psoh->rggjs[dwExternalID].dwTag = 1;

            hres = JoyReg_GetConfig(dwExternalID, &cfg, DIJC_GAIN);
            if (SUCCEEDED(hres)) {
                SquirtSqflPtszV(sqfl,
                                TEXT("Joystick %d global gain = %d"),
                                     dwExternalID, cfg.dwGain);
                g_psoh->rggjs[dwExternalID].dwCplGain = cfg.dwGain;
            } else {
                g_psoh->rggjs[dwExternalID].dwCplGain = DI_FFNOMINALMAX;
            }

            /*
             *  Set to DI_FFNOMINALMAX until we learn better.
             */
            g_psoh->rggjs[dwExternalID].dwDevGain = DI_FFNOMINALMAX;

        }

        ReleaseMutex(g_hmtxJoy);

        /*
         *  Ask the HEL for the internal ID.
         */
        hres = Hel_Joy_GetInitParms(dwExternalID, &vip);

        if (SUCCEEDED(hres)) {
            this->idJoy = dwExternalID;
            hres = this->pdrv->lpVtbl->DeviceID(this->pdrv,
                                                DIRECTINPUT_VERSION,
                                                dwExternalID,
                                                fBegin, vip.dwId,
                                                pvReserved);
        }
    } else {
        hres = E_FAIL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | Escape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputEffect::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect at which the command is directed.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED> if the effect is not downloaded.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_Escape(PDES pdes, PSHEPHANDLE psh, LPDIEFFESCAPE pesc)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::Escape,
               (_ "puxx", pdes, psh->dwTag, psh->dwEffect, pesc->dwCommand));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        if (psh->dwEffect) {
            hres = this->pdrv->lpVtbl->Escape(this->pdrv, this->idJoy,
                                              psh->dwEffect, pesc);
        } else {
            hres = DIERR_NOTDOWNLOADED;
        }
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DeviceEscape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputDevice8::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the ownership of the device.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DeviceEscape(PDES pdes, PSHEPHANDLE psh, LPDIEFFESCAPE pesc)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DeviceEscape,
               (_ "pux", pdes, psh->dwTag, pesc->dwCommand));

    this = _thisPvNm(pdes, des);

    AssertF(psh->dwEffect == 0);

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
        hres = this->pdrv->lpVtbl->Escape(this->pdrv, this->idJoy,
                                          0, pesc);
    } else {
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | SetPhysGain |
 *
 *          Set the physical gain based on the global gain
 *          and the local gain.
 *
 *          The caller must already have the global joystick lock.
 *
 *
 *  @cwrap  PES | this
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetPhysGain(PES this)
{
    HRESULT hres;

    hres = this->pdrv->lpVtbl->SetGain(
                 this->pdrv, this->idJoy,
                 MulDiv(g_psoh->rggjs[this->idJoy].dwDevGain,
                        g_psoh->rggjs[this->idJoy].dwCplGain,
                        DI_FFNOMINALMAX));
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SetGlobalGain |
 *
 *          Set the global gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwCplGain |
 *
 *          The new global gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetGlobalGain(PDES pdes, DWORD dwCplGain)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetGlobalGain,
               (_ "pu", pdes, dwCplGain));

    this = _thisPvNm(pdes, des);

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    g_psoh->rggjs[this->idJoy].dwCplGain = dwCplGain;

    hres = CEShep_SetPhysGain(this);

    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SetGain |
 *
 *          Set the overall device gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   DWORD | dwDevGain |
 *
 *          The new local gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetGain(PDES pdes, PSHEPHANDLE psh, DWORD dwDevGain)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetGain,
               (_ "puu", pdes, psh->dwTag, dwDevGain));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, DISFFC_NULL))) {
        g_psoh->rggjs[this->idJoy].dwDevGain = dwDevGain;

        hres = CEShep_SetPhysGain(this);
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SendForceFeedbackCommand |
 *
 *          Send a command to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   DWORD | dwCmd |
 *
 *          Command, one of the <c DISFFC_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetForceFeedbackState(PDES pdes, PSHEPHANDLE psh, DWORD dwCmd)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetForceFeedbackState,
               (_ "pux", pdes, psh->dwTag, dwCmd));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, dwCmd))) {

        if (dwCmd & DISFFC_FORCERESET) {
            dwCmd &= ~DISFFC_FORCERESET;
            dwCmd |= DISFFC_RESET;
        }

        hres = this->pdrv->lpVtbl->SendForceFeedbackCommand(
                        this->pdrv, this->idJoy, dwCmd);

        if (SUCCEEDED(hres) && (dwCmd & DISFFC_RESET)) {
            psh->dwTag = ++g_psoh->rggjs[this->idJoy].dwTag;
        }
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   LPDIDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetForceFeedbackState(PDES pdes, PSHEPHANDLE psh, LPDIDEVICESTATE pds)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetForceFeedbackState,
               (_ "pup", pdes, psh->dwTag, pds));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, DISFFC_NULL))) {
        hres = this->pdrv->lpVtbl->GetForceFeedbackState(
                            this->pdrv, this->idJoy, pds);
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DownloadEffect |
 *
 *          Send an effect to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Magic cookie dword that identifies the effect.
 *
 *  @parm   IN OUT PSHEPHANDLE | psh |
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to axis/button indexes.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *          <c S_FALSE> if no change was made.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DownloadEffect(PDES pdes, DWORD dwEffectId,
                       PSHEPHANDLE psh, LPCDIEFFECT peff, DWORD fl)
{
    PES this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputEffectShepherd::DownloadEffect,
               (_ "pxuppx", pdes, dwEffectId, psh->dwTag,
                            psh->dwEffect, peff, fl));

    this = _thisPvNm(pdes, des);

    /*
     *  Downloading an effect is sufficiently different from all
     *  other methods that we do the locking manually.
     */
    WaitForSingleObject(g_hmtxJoy, INFINITE);

    /*
     *  If not downloading, then it doesn't matter whether or not
     *  the tag matches.  However, if the tag doesn't match, then
     *  we must wipe out the download handle because it's dead.
     */
    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
    } else {
        psh->dwEffect = 0;
        if (fl & DIEP_NODOWNLOAD) {     /* It's okay if not downloading */
        } else {
            hres = DIERR_NOTEXCLUSIVEACQUIRED;
            goto done;
        }
    }

    /*
     *  If downloading and creating a new effect,
     *  then all parameters need to be downloaded.
     */
    if (!(fl & DIEP_NODOWNLOAD) && psh->dwEffect == 0) {
        fl |= DIEP_ALLPARAMS;
    }
    if (fl) {
        hres = this->pdrv->lpVtbl->DownloadEffect(
                    this->pdrv, this->idJoy, dwEffectId,
                    &psh->dwEffect, peff, fl);
    } else {
        hres = S_FALSE;
    }

done:;
    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DestroyEffect |
 *
 *          Remove an effect from the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be destroyed.  On exit,
 *          the <e SHEPHANDLE.dwEffect> is zero'd so nobody will use
 *          it any more.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *          <c S_FALSE> if the effect was already destroyed.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DestroyEffect(PDES pdes, PSHEPHANDLE psh)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DestroyEffect,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        DWORD dwEffect = psh->dwEffect;
        psh->dwEffect = 0;
        hres = this->pdrv->lpVtbl->DestroyEffect(
                    this->pdrv, this->idJoy, dwEffect);
        CEShep_UnlockEffect();
    } else {
        hres = S_FALSE;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | StartEffect |
 *
 *          Begin playback of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_StartEffect(PDES pdes, PSHEPHANDLE psh, DWORD dwMode, DWORD dwCount)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::StartEffect,
               (_ "puxxu", pdes, psh->dwTag, psh->dwEffect, dwMode, dwCount));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->StartEffect(this->pdrv, this->idJoy,
                                               psh->dwEffect, dwMode, dwCount);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | StopEffect |
 *
 *          Halt playback of an effect.
 *
 *          ISSUE-2001/03/29-timgill There is no way to pause an effect
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_StopEffect(PDES pdes, PSHEPHANDLE psh)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::StopEffect,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->StopEffect(this->pdrv, this->idJoy,
                                              psh->dwEffect);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetEffectStatus(PDES pdes, PSHEPHANDLE psh, LPDWORD pdwStatus)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetEffectStatus,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->GetEffectStatus(this->pdrv, this->idJoy,
                                                   psh->dwEffect, pdwStatus);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which will be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetVersions(PDES pdes, LPDIDRIVERVERSIONS pvers)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetVersions, (_ "p", pdes));

    this = _thisPvNm(pdes, des);

    AssertF(pvers->dwSize == cbX(*pvers));

    hres = this->pdrv->lpVtbl->GetVersions(this->pdrv, pvers);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | InitInstance |
 *
 *          Initialize a new instance of
 *          an IDirectInputEffectShepherd object.
 *
 *          If an in-proc OLE server is needed, then load it.
 *
 *          Otherwise, use our private interface that goes down
 *          to our helper driver.
 *
 *  @parm   IN HKEY | hkFF |
 *
 *          Force feedback registry key.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_InitInstance(PES this, HKEY hkFF)
{
    LONG lRc;
    HRESULT hres;
    TCHAR tszClsid[ctchGuid];

    EnterProcI(IDirectInputEffectShepherd::InitInstance, (_ "x", hkFF));

    if( hkFF == 0x0 )
    {
        TCHAR tszName[ctchNameGuid];
        NameFromGUID(tszName, &IID_IDirectInputPIDDriver );
        memcpy(tszClsid, &tszName[ctchNamePrefix], cbX(tszClsid) );
        lRc = ERROR_SUCCESS;
    }else
    {
        lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
        /*
         *  Prefix warns that tszClsid could be uninitialized through this 
         *  path (mb:35346) however RegQueryString only returns ERROR_SUCCESS 
         *  if a nul terminated string has been read into tszClsid.
         */
    }

    if (lRc == ERROR_SUCCESS) {
        hres = DICoCreateInstance(tszClsid, 0,
                                  &IID_IDirectInputEffectDriver,
                                  &this->pdrv,
                                  &this->hinst);

        /*
         *  If anything went wrong, change the error to
         *  E_NOTIMPL so the app won't see a wacky CoCreateInstance
         *  error code.
         */
        if (FAILED(hres)) {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Substituting E_NOTIMPL for FF driver CoCreateInstance error 0x%08x"),
                hres );
            hres = E_NOTIMPL;
        }

    } else {
#ifdef WINNT
        hres = E_NOTIMPL;
#else
        {
            DWORD cb = 0;
            lRc = RegQueryValueEx(hkFF, TEXT("VJoyD"), 0, 0, 0, &cb);
            if (lRc == ERROR_SUCCESS || lRc == ERROR_MORE_DATA) {
                hres = CEffVxd_New(0, &IID_IDirectInputEffectDriver, &this->pdrv);
            } else {
                hres = E_NOTIMPL;
            }
        }
#endif
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | New |
 *
 *          Create a new instance of an IDirectInputEffectShepherd object.
 *
 *  @parm   IN HKEY | hkFF |
 *
 *          Force feedback registry key.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_New(HKEY hkFF, PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffectShepherd::<constructor>, (_ "G", riid));

    AssertF(g_hmtxJoy);

    hres = Common_NewRiid(CEShep, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PES this = _thisPv(*ppvObj);
        if (SUCCEEDED(hres = CEShep_InitInstance(this, hkFF))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CEShep_Signature        0x50454853      /* "SHEP" */

Interface_Template_Begin(CEShep)
    Primary_Interface_Template(CEShep, IDirectInputEffectShepherd)
Interface_Template_End(CEShep)

Primary_Interface_Begin(CEShep, IDirectInputEffectShepherd)
    CEShep_DeviceID,
    CEShep_GetVersions,
    CEShep_Escape,
    CEShep_DeviceEscape,
    CEShep_SetGain,
    CEShep_SetForceFeedbackState,
    CEShep_GetForceFeedbackState,
    CEShep_DownloadEffect,
    CEShep_DestroyEffect,
    CEShep_StartEffect,
    CEShep_StopEffect,
    CEShep_GetEffectStatus,
    CEShep_SetGlobalGain,
Primary_Interface_End(CEShep, IDirectInputEffectShepherd)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dieffv.c ===
/*****************************************************************************
 *
 *  DIEffV.c
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Effect driver for VJOYD devices.
 *
 *  Contents:
 *
 *      CEffVxd_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"
#ifndef WINNT


/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflVxdEff

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CEffVxd_New!
 *
 *****************************************************************************/

Primary_Interface(CEffVxd, IDirectInputEffectDriver);

Interface_Template_Begin(CEffVxd)
    Primary_Interface_Template(CEffVxd, IDirectInputEffectDriver)
Interface_Template_End(CEffVxd)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEffVxd |
 *
 *          An <i IDirectInputEffectDriver> wrapper for VJOYD
 *          joysticks.
 *
 *  @field  IDirectInputEffectDriver | didc |
 *
 *          The object (containing vtbl).
 *
 *****************************************************************************/

typedef struct CEffVxd {

    /* Supported interfaces */
    IDirectInputEffectDriver ded;

} CEffVxd, DVE, *PDVE;

typedef IDirectInputEffectDriver DED, *PDED;

#define ThisClass CEffVxd
#define ThisInterface IDirectInputEffectDriver
#define riidExpected &IID_IDirectInputEffectDriver

/*****************************************************************************
 *
 *      CEffVxd::QueryInterface   (from IUnknown)
 *      CEffVxd::AddRef           (from IUnknown)
 *      CEffVxd::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/
/*
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | Finalize |
 *
 *          We don't have any instance data, so we can just
 *          forward to <f Common_Finalize>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CEffVxd)
Default_AddRef(CEffVxd)
Default_Release(CEffVxd)

#else

#define CEffVxd_QueryInterface      Common_QueryInterface
#define CEffVxd_AddRef              Common_AddRef
#define CEffVxd_Release             Common_Release

#endif

#define CEffVxd_QIHelper            Common_QIHelper
#define CEffVxd_AppFinalize         Common_AppFinalize
#define CEffVxd_Finalize            Common_Finalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *          See <mf IDirectInputEffectDriver::DeviceID>
 *          for more information.
 *
 *          Doesn't do anything because VJOYD will already
 *          have told the driver its identity.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwDirectInputVersion |
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  @parm   DWORD | dwInternalID |
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Reserved for future use (HID).
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DeviceID(PDED pded, DWORD dwDIVer, DWORD dwExternalID, DWORD fBegin,
                 DWORD dwInternalID, LPVOID pvReserved)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DeviceID,
               (_ "pxuuu", pded, dwDIVer, dwExternalID, fBegin, dwInternalID));

    this = _thisPvNm(pded, ded);

    dwDIVer;
    dwExternalID;
    fBegin;
    dwInternalID;
    pvReserved;

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEffVxd_Ioctl |
 *
 *          Perform an IOCTL to VJOYD.
 *
 *  @parm   DWORD | dwIOCode |
 *
 *          The function to perform.
 *
 *  @parm   PV | pvIn |
 *
 *          Input arguments, the number of which depends on the
 *          function code.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_Ioctl(DWORD dwIOCode, PV pvIn)
{
    HRESULT hres;
    HRESULT hresFF;
    EnterProc(CEffVxD_Ioctl, (_ "u", dwIOCode));

    /*
     *  Once again, we rely on the fact that STDCALL passes
     *  parameters right to left, so our arguments are exactly
     *  in the form of a VXDFFIO structure.
     */
    CAssertF(cbX(VXDFFIO) == cbX(dwIOCode) + cbX(pvIn));
    CAssertF(FIELD_OFFSET(VXDFFIO, dwIOCode) == 0);
    CAssertF(FIELD_OFFSET(VXDFFIO, pvArgs) == cbX(dwIOCode));
    AssertF(cbSubPvPv(&pvIn, &dwIOCode) == cbX(dwIOCode));

    hres = IoctlHw(IOCTL_JOY_FFIO, &dwIOCode, cbX(VXDFFIO),
                   &hresFF, cbX(hresFF));
    if (SUCCEEDED(hres)) {
        hres = hresFF;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | Escape |
 *
 *          Escape to the driver.
 *          See <mf IDirectInputEffectDriver::Escape>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect at which the command is directed.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_Escape(PDED pded, DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::Escape,
               (_ "puxx", pded, dwId, dwEffect, pesc->dwCommand));

    this = _thisPvNm(pded, ded);

    dwId;
    dwEffect;
    pesc;

    hres = CEffVxd_Ioctl(FFIO_ESCAPE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | SetGain |
 *
 *          Set the overall device gain.
 *          See <mf IDirectInputEffectDriver::SetGain>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwGain |
 *
 *          The new gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_SetGain(PDED pded, DWORD dwId, DWORD dwGain)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::SetGain,
               (_ "puu", pded, dwId, dwGain));

    this = _thisPvNm(pded, ded);

    dwId;
    hres = CEffVxd_Ioctl(FFIO_SETGAIN, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | SetForceFeedbackState |
 *
 *          Change the force feedback state for the device.
 *          See <mf IDirectInputEffectDriver::SetForceFeedbackState>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwState |
 *
 *          New state, one of the <c DEV_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_SetForceFeedbackState(PDED pded, DWORD dwId, DWORD dwState)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::SetForceFeedbackState,
               (_ "pux", pded, dwId, dwState));

    this = _thisPvNm(pded, ded);

    dwId;
    dwState;

    hres = CEffVxd_Ioctl(FFIO_SETFFSTATE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *          See <mf IDirectInputEffectDriver::GetForceFeedbackState>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   LPDIDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetForceFeedbackState(PDED pded, DWORD dwId, LPDIDEVICESTATE pds)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::GetForceFeedbackState,
               (_ "pup", pded, dwId, pds));

    this = _thisPvNm(pded, ded);

    dwId;
    pds;

    hres = CEffVxd_Ioctl(FFIO_GETFFSTATE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DownloadEffect |
 *
 *          Send an effect to the device.
 *          See <mf IDirectInputEffectDriver::SetGain>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Magic cookie dword that identifies the effect.
 *
 *  @parm   IN OUT LPDWORD | pdwEffect |
 *
 *          The effect being modified.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DownloadEffect(PDED pded, DWORD dwId, DWORD dwEffectId,
                       LPDWORD pdwEffect, LPCDIEFFECT peff, DWORD fl)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DownloadEffect,
               (_ "puxxpx", pded, dwId, dwEffectId, *pdwEffect, peff, fl));

    this = _thisPvNm(pded, ded);

    dwEffectId;
    pdwEffect;
    peff;
    fl;

    hres = CEffVxd_Ioctl(FFIO_DOWNLOADEFFECT, &dwId);

    ExitOleProcPpv(pdwEffect);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DestroyEffect |
 *
 *          Remove an effect from the device.
 *          See <mf IDirectInputEffectDriver::DestroyEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be destroyed.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DestroyEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DestroyEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;

    hres = CEffVxd_Ioctl(FFIO_DESTROYEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | StartEffect |
 *
 *          Begin playback of an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_StartEffect(PDED pded, DWORD dwId, DWORD dwEffect,
                    DWORD dwMode, DWORD dwCount)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StartEffect,
               (_ "puxxu", pded, dwId, dwEffect, dwMode, dwCount));

    this = _thisPvNm(pded, ded);

    dwEffect;
    dwMode;
    dwCount;
    hres = CEffVxd_Ioctl(FFIO_STARTEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | StopEffect |
 *
 *          Halt playback of an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_StopEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;
    hres = CEffVxd_Ioctl(FFIO_STOPEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetEffectStatus(PDED pded, DWORD dwId, DWORD dwEffect,
                        LPDWORD pdwStatus)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;
    pdwStatus;
    hres = CEffVxd_Ioctl(FFIO_GETEFFECTSTATUS, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | CEffVxd | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetVersions(PDED pded, LPDIDRIVERVERSIONS pvers)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::GetVersions, (_ "pux", pded));

    this = _thisPvNm(pded, ded);

    /*
     *  Returning E_NOTIMPL causes DirectInput to ask the VxD for the same
     *  information.
     */
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CEffVxd_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CEffVxd, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PDVE this;
        if (Num_Interfaces(CEffVxd) == 1) {
            this = _thisPvNm(*ppvObj, ded);
        } else {
            this = _thisPv(*ppvObj);
        }

        /* No initialization needed */
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CEffVxd_Signature        0x46454556      /* "VEFF" */

Primary_Interface_Begin(CEffVxd, IDirectInputEffectDriver)
    CEffVxd_DeviceID,
    CEffVxd_GetVersions,
    CEffVxd_Escape,
    CEffVxd_SetGain,
    CEffVxd_SetForceFeedbackState,
    CEffVxd_GetForceFeedbackState,
    CEffVxd_DownloadEffect,
    CEffVxd_DestroyEffect,
    CEffVxd_StartEffect,
    CEffVxd_StopEffect,
    CEffVxd_GetEffectStatus,
Primary_Interface_End(CEffVxd, IDirectInputEffectDriver)

#endif /* ndef WINNT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diem.c ===
/*****************************************************************************
 *
 *  DIEm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput VxD emulation layer.  (I.e., do the things that
 *      dinput.vxd normally does.)  You may find large chunks of this
 *      code familiar:  It's exactly the same thing that happens in
 *      the VxD.
 *
 *  Contents:
 *
 *      CEm_AcquireInstance
 *      CEm_UnacquireInstance
 *      CEm_SetBufferSize
 *      CEm_DestroyInstance
 *      CEm_SetDataFormat
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

#define ThisClass CEm

#define CEM_SIGNATURE       0x4D4D4545      /* "EEMM" */

PEM g_pemFirst;

#ifdef WORKER_THREAD

PLLTHREADSTATE g_plts;      /* The currently active input thread */

#ifdef USE_WM_INPUT
  BOOL  g_fFromKbdMse;
#endif

#endif  /* WORKER_THREAD */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_FreeInstance |
 *
 *          It's really gone now.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void EXTERNAL
CEm_FreeInstance(PEM this)
{
    PEM *ppem;
    EnterProc(CEm_FreeInstance, (_ "p", this));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF(this->cRef == 0);

    /*
     *  It is the owner's responsibility to unacquire before releasing.
     */
    AssertF(!(this->vi.fl & VIFL_ACQUIRED));

    /*
     *  If this device has a reference to a hook, then remove
     *  the reference.
     */
#ifdef WORKER_THREAD
    if (this->fWorkerThread) {
        PLLTHREADSTATE  plts;
        DWORD           idThread;

        /*
         *  Protect test and access of g_plts with DLLCrit
         */
        DllEnterCrit();
        plts = g_plts;

        if (plts ) {
            AssertF(plts->cRef);

            /*
             *  Note that we need to keep the thread ID because
             *  the InterlockedDecrement might cause us to lose
             *  the object.
             *
             *  Note that this opens a race condition where the
             *  thread might decide to kill itself before we
             *  post it the nudge message.  That's okay, because
             *  even if the thread ID gets recycled, the message
             *  that appears is a dummy WM_NULL message that
             *  causes no harm.
             */

            idThread = plts->idThread;      /* Must save before we dec */
            if( InterlockedDecrement(&plts->cRef) == 0 ) {
                g_plts = 0;
            }
        }

        DllLeaveCrit();

        if( plts )
        {
            NudgeWorkerThread(idThread);
        }
    }
#endif

    /*
     *  Unlink the node from the master list.
     */
    DllEnterCrit();
    for (ppem = &g_pemFirst; *ppem; ppem = &(*ppem)->pemNext) {
        AssertF((*ppem)->dwSignature == CEM_SIGNATURE);
        if (*ppem == this) {
            *ppem = (*ppem)->pemNext;
            break;
        }
    }
    AssertF(ppem);
    DllLeaveCrit();

    FreePpv(&this->rgdwDf);
    FreePpv(&this->vi.pBuffer);

    if( InterlockedDecrement(&this->ped->cRef) == 0x0 )
    {
        FreePpv(&this->ped->pDevType);
    }

    D(this->dwSignature++);

    FreePv(this);

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_CreateInstance |
 *
 *          Create a device thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *  @parm   PED | ped |
 *
 *          Descriptor.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut, PED ped)
{
    HRESULT hres;
    EnterProc(CEm_CreateInstance, (_ "pp", pdevf, ped));

    AssertF(pdevf->cbData == ped->cbData);

    CAssertF(FIELD_OFFSET(CEm, vi) == 0);

    hres = AllocCbPpv(cbX(CEm), ppviOut);
    if (SUCCEEDED(hres)) {
        PEM pem = (PV)*ppviOut;

      D(pem->dwSignature = CEM_SIGNATURE);
        pem->dwExtra = pdevf->dwExtra;
        pem->ped = ped;
        pem->cAcquire = -1;
        /*
         *  Make sure these functions are inverses.
         */
        AssertF(DIGETEMFL(DIMAKEEMFL(pdevf->dwEmulation)) ==
                                     pdevf->dwEmulation);

        pem->vi.fl = VIFL_EMULATED | DIMAKEEMFL(pdevf->dwEmulation);
        pem->vi.pState = ped->pState;
        CEm_AddRef(pem);

        DllEnterCrit();
        /*
         *  Build the devtype array.  This consists of one dword
         *  for each byte in the data format.
         *
         *  Someday: Do the button thing too.
         */
        if (ped->pDevType == 0) {
            hres = ReallocCbPpv(cbCdw(pdevf->cbData), &ped->pDevType);
            if (SUCCEEDED(hres)) {
                UINT iobj;

                /*
                 *  If HID is messed up, we will end up with
                 *  entries whose dwType is zero (because HID
                 *  said they existed, but when we went around
                 *  enumerating, they never showed up).
                 *
                 *  And don't put no-data items into the array!
                 */
                for (iobj = 0; iobj < pdevf->cObj; iobj++) {
                    if (pdevf->rgodf[iobj].dwType &&
                        !(pdevf->rgodf[iobj].dwType & DIDFT_NODATA)) {
                        ped->pDevType[pdevf->rgodf[iobj].dwOfs] =
                                      pdevf->rgodf[iobj].dwType;
                    }
                }
            }
        } else {
            hres = S_OK;
        }

        if (SUCCEEDED(hres)) {
            /*
             *  Link this node into the list.  This must be done
             *  under the critical section.
             */
             pem->pemNext = g_pemFirst;
             g_pemFirst = pem;

             InterlockedIncrement(&ped->cRef);

            *ppviOut = &pem->vi;
        } else {
            FreePpv(ppviOut);
        }
        DllLeaveCrit();
    }

    ExitOleProcPpv(ppviOut);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CEm_NextSequence |
 *
 *          Increment the sequence number wherever it may be.
 *
 *****************************************************************************/

DWORD INTERNAL
CEm_NextSequence(void)
{
    /*
     *  Stashing the value into a local tells the compiler that
     *  the value can be cached.  Otherwise, the compiler has
     *  to assume that InterlockedIncrement can modify g_pdwSequence
     *  so it keeps reloading it.
     */
    LPDWORD pdwSequence = g_pdwSequence;

    AssertF(pdwSequence);

    /*
     *  Increment through zero.
     */
    if (InterlockedIncrement((LPLONG)pdwSequence) == 0) {
        InterlockedIncrement((LPLONG)pdwSequence);
    }

    return *pdwSequence;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PEM | CEm_BufferEvent |
 *
 *          Add a single event to the device, returning the next device
 *          on the global list.
 *
 *          This routine is entered with the global critical section
 *          taken exactly once.
 *
 *****************************************************************************/

PEM INTERNAL
CEm_BufferEvent(PEM pem, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq)
{
    PEM pemNext;

    /*
     *  We must release the global critical section in order to take
     *  the device critical section.
     */
    CEm_AddRef(pem);                /* Make sure it doesn't vanish */

    DllLeaveCrit();
    AssertF(!InCrit());

    /*
     * ---Windows Bug 238305---
     * Run the buffering code in __try block so that if an
     * input is receive after the device is released, we can
     * catch the AV and clean up from there.
     */
    __try
    {
        CDIDev_EnterCrit(pem->vi.pdd);

        AssertF(dwOfs < pem->ped->cbData);
        AssertF(pem->rgdwDf);

        /*
         *  If the user cares about the object...
         */
        if (pem->rgdwDf[dwOfs] != 0xFFFFFFFF) {
            LPDIDEVICEOBJECTDATA_DX3 pdod = pem->vi.pHead;

            /*
             *  Set the node value.
             */

            pdod->dwOfs       = pem->rgdwDf[dwOfs];
            pdod->dwData      = dwData;
            pdod->dwTimeStamp = tm;
            pdod->dwSequence  = dwSeq;

            /*
             *  Append the node to the list if there is room.
             *  Note that we rely above on the fact that the list is
             *  never totally full.
             */
            pdod++;

            AssertF(pdod <= pem->vi.pEnd);

            if (pdod >= pem->vi.pEnd) {
                pdod = pem->vi.pBuffer;
            }

            /*
             * always keep the new data
             */
            pem->vi.pHead = pdod;

            if (pdod == pem->vi.pTail) {
                if (!pem->vi.fOverflow) {
                    RPF("Buffer overflow; discard old data");
                }

                pem->vi.pTail++;
                if (pem->vi.pTail == pem->vi.pEnd) {
                    pem->vi.pTail = pem->vi.pBuffer;
                }

                pem->vi.fOverflow = 1;
            }

        }

        CDIDev_LeaveCrit(pem->vi.pdd);
    }
    /*
     * If we get an AV, most likely input is received after the device has
     * been released.  In this case, we clean up the thread and exit as
     * soon as possible.
     */
    __except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH )
    {
        /* Do nothing here, so we clean up the thread and exit below. */
        RPF("CEm_BufferEvent: Access Violation catched! Most likely the device has been released");
    }

    DllEnterCrit();
    pemNext = pem->pemNext;
    AssertF(fLimpFF(pemNext, pemNext->dwSignature == CEM_SIGNATURE));
    CEm_Release(pem);
    return pemNext;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | CEm_ContinueEvent |
 *
 *          Add a single event to the queues of all acquired devices
 *          of the indicated type.
 *
 *  @returns
 *
 *          TRUE if someone is interested in this data (even if they are not 
 *          buffered).
 *
 *****************************************************************************/

BOOL EXTERNAL
CEm_ContinueEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq)
{
    DWORD ddwData;                  /* delta in dwData */
    BOOL  fRtn = FALSE;

    AssertF(!InCrit());

    /* Sanity check: Make sure the ped has been initialized */
    if (ped->pDevType) {
        PEM pem, pemNext;

        if (ped->pDevType[dwOfs] & DIDFT_DWORDOBJS) {
            DWORD UNALIGNED *pdw = pvAddPvCb(ped->pState, dwOfs);
            if (*pdw != dwData) {
                if (ped->pDevType[dwOfs] & DIDFT_POV ) {
                    ddwData = dwData;   /* Don't do deltas for POV */
                } else {
                    ddwData = dwData - *pdw;
                }
                *pdw = dwData;
            } else {
                goto nop;
            }
        } else {
            LPBYTE pb = pvAddPvCb(ped->pState, dwOfs);

            AssertF((dwData & ~0x80) == 0);

            if (*pb != (BYTE)dwData) {
                *pb = (BYTE)dwData;
                ddwData = dwData;       /* Don't do deltas for buttons */
                /* Someday: Button sequences go here */
            } else {
                goto nop;
            }
        }

        AssertF(!InCrit());         /* You can never be too paranoid */

        DllEnterCrit();
        for (pem = g_pemFirst; pem; pem = pemNext) {
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            if ((pem->vi.fl & (VIFL_ACQUIRED|VIFL_INITIALIZE)) && pem->ped == ped) {

                if (pem->vi.pBuffer) {
                    if( pem->vi.fl & VIFL_RELATIVE )
                    {
                        pemNext = CEm_BufferEvent(pem, ddwData, dwOfs, tm, dwSeq);
                    }
                    else
                    {
                        pemNext = CEm_BufferEvent(pem, dwData, dwOfs, tm, dwSeq);
                    }
                    AssertF(fLimpFF(pemNext,
                                    pemNext->dwSignature == CEM_SIGNATURE));
                } else {
                    pemNext = pem->pemNext;
                    AssertF(fLimpFF(pemNext,
                                    pemNext->dwSignature == CEM_SIGNATURE));
                }
                /*
                 *  It would be easy to avoid setting the event if nothing 
                 *  was buffered but somebody would rely on getting them 
                 *  without setting a buffer.
                 */
                fRtn = TRUE;
            } else {
                pemNext = pem->pemNext;
                AssertF(fLimpFF(pemNext,
                                pemNext->dwSignature == CEM_SIGNATURE));
            }
        }
        DllLeaveCrit();
    }

nop:;
    return fRtn;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CEm_AddEvent |
 *
 *          Increment the DirectInput sequence number, then
 *          add a single event to the queues of all acquired devices
 *          of the indicated type.
 *
 *  @parm   PED | ped |
 *
 *          Device which is adding the event.
 *
 *  @parm   DWORD | dwData |
 *
 *          The event data.
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Device data format-relative offset for <p dwData>.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the event was generated.
 *
 *  @returns
 *
 *          Returns the sequence number added, so that it may be
 *          continued.
 *
 *****************************************************************************/

DWORD EXTERNAL
CEm_AddEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm)
{
    PEM pem, pemNext;

    DWORD dwSeq = CEm_NextSequence();

    AssertF(!InCrit());         /* You can never be too paranoid */

    if( CEm_ContinueEvent(ped, dwData, dwOfs, tm, dwSeq) )
    {
        DllEnterCrit();
        for (pem = g_pemFirst; pem; pem = pemNext) {
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            if ((pem->vi.fl & VIFL_ACQUIRED) && pem->ped == ped) {
                CDIDev_SetNotifyEvent(pem->vi.pdd);
            }
            pemNext = pem->pemNext;
            AssertF(fLimpFF(pemNext,
                            pemNext->dwSignature == CEM_SIGNATURE));
        }
        DllLeaveCrit();
    }

    return dwSeq;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_AddState |
 *
 *          Record a brand new device state.
 *
 *  @parm   PED | ped |
 *
 *          Device which has changed state.
 *
 *  @parm   DWORD | dwData |
 *
 *          The value to record.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the state change was generated.
 *
 *****************************************************************************/

void EXTERNAL
CEm_AddState(PED ped, LPVOID pvData, DWORD tm)
{
    DWORD dwSeq = CEm_NextSequence();

    /* Sanity check: Make sure the ped has been initialized */
    if (ped->pDevType) {
        DWORD dwOfs;
        BOOL  fEvent = FALSE;

        /*
         *  Note, it is too late to improve performance by only doing events 
         *  if somebody is listening.
         */
        dwOfs = 0;
        while (dwOfs < ped->cbData) {
            /*
             *  There shouldn't be any no-data items.
             */
            AssertF(!(ped->pDevType[dwOfs] & DIDFT_NODATA));

            if (ped->pDevType[dwOfs] & DIDFT_DWORDOBJS) {
                DWORD UNALIGNED *pdw = pvAddPvCb(pvData, dwOfs);
                if( CEm_ContinueEvent(ped, *pdw, dwOfs, tm, dwSeq) ){
                    fEvent = TRUE;
                }
                dwOfs += cbX(DWORD);
            } else {
                LPBYTE pb = pvAddPvCb(pvData, dwOfs);
                if( CEm_ContinueEvent(ped, *pb, dwOfs, tm, dwSeq) ) {
                    fEvent = TRUE;
                }
                dwOfs++;
            }
        }

        if( fEvent ) {
            PEM pem, pemNext;

            AssertF(!InCrit());         /* You can never be too paranoid */
    
            DllEnterCrit();
            for (pem = g_pemFirst; pem; pem = pemNext) {
                AssertF(pem->dwSignature == CEM_SIGNATURE);
                if ((pem->vi.fl & VIFL_ACQUIRED) && pem->ped == ped) {
                    CDIDev_SetNotifyEvent(pem->vi.pdd);
                }
                pemNext = pem->pemNext;
                AssertF(fLimpFF(pemNext,
                                pemNext->dwSignature == CEM_SIGNATURE));
            }
            DllLeaveCrit();
        }

    }
}

#if 0
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_InputLost |
 *
 *          Remove global hooks because something weird happened.
 *
 *          We don't need to do anything because our hooks are local.
 *
 *****************************************************************************/

HRESULT INLINE
CEm_InputLost(LPVOID pvIn, LPVOID pvOut)
{
    return S_OK;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_UnacquirePem |
 *
 *          Unacquire the device in the device-specific way.
 *
 *  @parm   PEM | pem |
 *
 *          Information about the gizmo being mangled.
 *
 *  @parm   UINT | fdufl |
 *
 *          Assorted flags describing why we are being unacquired.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_UnacquirePem(PEM this, UINT fdufl)
{
    HRESULT hres;
#ifdef DEBUG
    EnterProcR(CEm_UnacquirePem, (_ "px", this, fdufl));
#else
    EnterProcR(IDirectInputDevice8::Unacquire, (_ "p", this));
#endif

    AssertF(this->dwSignature == CEM_SIGNATURE);

    AssertF((fdufl & ~FDUFL_UNPLUGGED) == 0);
    CAssertF(FDUFL_UNPLUGGED == VIFL_UNPLUGGED);

    if (this->vi.fl & VIFL_ACQUIRED) {
        this->vi.fl &= ~VIFL_ACQUIRED;
        this->vi.fl |= fdufl;
        if (InterlockedDecrement(&this->cAcquire) < 0) {
            InterlockedDecrement(&this->ped->cAcquire);
            hres = this->ped->Acquire(this, 0);
        } else {
            SquirtSqflPtszV(sqfl, TEXT("%S: Still acquired %d"),
                            s_szProc, this->cAcquire);
            hres = S_OK;
        }
    } else {
        SquirtSqflPtszV(sqfl, TEXT("%S: Not acquired %d"),
                        s_szProc, this->cAcquire);
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_ForceDeviceUnacquire |
 *
 *          Force all users of a device to unacquire.
 *
 *  @parm   PEM | pem |
 *
 *          Information about the gizmo being mangled.
 *
 *  @parm   UINT | fdufl |
 *
 *          Assorted flags describing why we are being unacquired.
 *
 *****************************************************************************/

void EXTERNAL
CEm_ForceDeviceUnacquire(PED ped, UINT fdufl)
{
    PEM pem, pemNext;

    AssertF((fdufl & ~FDUFL_UNPLUGGED) == 0);

    AssertF(!DllInCrit());

    DllEnterCrit();
    for (pem = g_pemFirst; pem; pem = pemNext) {
        AssertF(pem->dwSignature == CEM_SIGNATURE);
        if (pem->ped == ped && (pem->vi.fl & VIFL_ACQUIRED)) {
            CEm_AddRef(pem);
            DllLeaveCrit();
            CEm_UnacquirePem(pem, fdufl);

            CDIDev_SetForcedUnacquiredFlag(pem->vi.pdd);
            /*
             *  Since this happens only when the device is acquired,
             *  we don't need to worry about the notify event changing
             *  asynchronously.
             */
            CDIDev_SetNotifyEvent(pem->vi.pdd);
            DllEnterCrit();
            pemNext = pem->pemNext;
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            CEm_Release(pem);
        } else {
            pemNext = pem->pemNext;
            AssertF(pem->dwSignature == CEM_SIGNATURE);
        }
    }
    DllLeaveCrit();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_DestroyInstance |
 *
 *          Clean up an instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_DestroyInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
    EnterProc(CEm_DestroyInstance, (_ "p", *ppvi));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF((PV)this == (PV)*ppvi);

    if (this) {
        CEm_Release(this);
    }
    hres = S_OK;

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_SetDataFormat |
 *
 *          Record the application data format in the device so that
 *          we can translate it for buffering purposes.
 *
 *  @parm   PVXDDATAFORMAT | pvdf |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_SetDataFormat(PVXDDATAFORMAT pvdf)
{
    HRESULT hres;
    PEM this = _thisPvNm(pvdf->pvi, vi);
    EnterProc(CEm_SetDataFormat, (_ "p", pvdf->pvi));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    hres = ReallocCbPpv( cbCdw(pvdf->cbData), &this->rgdwDf);
    if (SUCCEEDED(hres)) {
        AssertF(pvdf->cbData == this->ped->cbData);
        memcpy(this->rgdwDf, pvdf->pDfOfs, cbCdw(pvdf->cbData) );
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_AcquireInstance |
 *
 *          Acquire the device in the device-specific way.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          The instance to acquire.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_AcquireInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
#ifdef DEBUG
    EnterProc(CEm_AcquireInstance, (_ "p", *ppvi));
#else
    EnterProcR(IDirectInputDevice8::Acquire, (_ "p", *ppvi));
#endif

    AssertF(this->dwSignature == CEM_SIGNATURE);
    this->vi.fl |= VIFL_ACQUIRED;
    if (InterlockedIncrement(&this->cAcquire) == 0) {
        InterlockedIncrement(&this->ped->cAcquire);
        hres = this->ped->Acquire(this, 1);
        if (FAILED(hres)) {
            this->vi.fl &= ~VIFL_ACQUIRED;
            InterlockedDecrement(&this->cAcquire);
        }
    } else {
        SquirtSqflPtszV(sqfl, TEXT("%S: Already acquired %d"),
                        s_szProc, this->cAcquire);
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_UnacquireInstance |
 *
 *          Unacquire the device in the device-specific way.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_UnacquireInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
    EnterProc(CEm_UnacquireInstance, (_ "p", *ppvi));

    hres = CEm_UnacquirePem(this, FDUFL_NORMAL);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_SetBufferSize |
 *
 *          Allocate a buffer of the appropriate size.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The <p dwData> is the buffer size.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_SetBufferSize(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    PEM this = _thisPvNm(pvdd->pvi, vi);
    EnterProc(CEm_SetBufferSize, (_ "px", pvdd->pvi, pvdd->dw));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    hres = ReallocCbPpv(cbCxX(pvdd->dw, DIDEVICEOBJECTDATA),
                        &this->vi.pBuffer);
    if (SUCCEEDED(hres)) {
        this->vi.pHead = this->vi.pBuffer;
        this->vi.pTail = this->vi.pBuffer;
        this->vi.pEnd  = &this->vi.pBuffer[pvdd->dw];
    }

    ExitOleProc();
    return hres;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @struct LLHOOKINFO |
 *
 *          Information about how to install a low-level hook.
 *
 *  @field  int | idHook |
 *
 *          The Windows hook identifier.
 *
 *  @field  HOOKPROC | hp |
 *
 *          The hook procedure itself.
 *
 *****************************************************************************/

typedef struct LLHOOKINFO {

    int      idHook;
    HOOKPROC hp;

} LLHOOKINFO, *PLLHOOKINFO;
typedef const LLHOOKINFO *PCLLHOOKINFO;

#pragma BEGIN_CONST_DATA

const LLHOOKINFO c_rgllhi[] = {
    {   WH_KEYBOARD_LL, CEm_LL_KbdHook },   /* LLTS_KBD */
    {   WH_MOUSE_LL,    CEm_LL_MseHook },   /* LLTS_MSE */
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_LL_SyncHook |
 *
 *          Install or remove a hook as needed.
 *
 *  @parm   UINT | ilts |
 *
 *          Which hook is being handled?
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          Thread hook state containing hook information to synchronize.
 *
 *****************************************************************************/

void INTERNAL
CEm_LL_SyncHook(PLLTHREADSTATE plts, UINT ilts)
{
    PLLHOOKSTATE plhs = &plts->rglhs[ilts];

    if (!fLeqvFF(plhs->cHook, plhs->hhk)) {
        if (plhs->hhk) {
            UnhookWindowsHookEx(plhs->hhk);
            plhs->hhk = 0;
        } else {
            PCLLHOOKINFO pllhi = &c_rgllhi[ilts];
            plhs->hhk = SetWindowsHookEx(pllhi->idHook, pllhi->hp, g_hinst, 0);
        }
    }

}

#endif /* USE_SLOW_LL_HOOKS */

#ifdef WORKER_THREAD

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | FakeMsgWaitForMultipleObjectsEx |
 *
 *          Stub function which emulates
 *          <f MsgWaitForMultipleObjectsEx>
 *          on platforms that do not support it.
 *
 *          Such platforms (namely, Windows 95) do not support HID
 *          and therefore the inability to go into an alertable
 *          wait state constitutes no loss of amenity.
 *
 *  @parm   DWORD | nCount |
 *
 *          Number of handles in handle array.
 *
 *  @parm   LPHANDLE | pHandles |
 *
 *          Pointer to an object-handle array.
 *
 *  @parm   DWORD | ms |
 *
 *          Time-out interval in milliseconds.
 *
 *  @parm   DWORD | dwWakeMask |
 *
 *          Type of input events to wait for.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Wait flags.
 *
 *  @returns
 *
 *          Same as <f MsgWaitForMultipleObjectsEx>.
 *
 *****************************************************************************/

DWORD WINAPI
FakeMsgWaitForMultipleObjectsEx(
    DWORD nCount,
    LPHANDLE pHandles,
    DWORD ms,
    DWORD dwWakeMask,
    DWORD dwFlags)
{
    /*
     *  We merely call the normal MsgWaitForMultipleObjects because
     *  the only way we can get here is on a platform that doesn't
     *  support HID.
     */
    return MsgWaitForMultipleObjects(nCount, pHandles,
                                     dwFlags & MWMO_WAITALL, ms, dwWakeMask);
}

#ifdef WINNT
// On win2k non-exclusive mode user thinks the Dinput thread is hung.
// In order to fix this we set a TimerEvent and wake up every so 
// often and execute the FakeTimerProc. This keeps user happy and
// keeps dinput thread from being marked as hung and we can get 
// events to our low level hooks
VOID CALLBACK FakeTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{
}
#endif

#ifdef USE_WM_INPUT

#pragma BEGIN_CONST_DATA
TCHAR c_szEmClassName[] = TEXT("DIEmWin");
#pragma END_CONST_DATA

/****************************************************************************
 *
 *      CEm_WndProc
 *
 *      Window procedure for simple sample.
 *
 ****************************************************************************/

LRESULT CALLBACK
CEm_WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch (msg) {
    //case WM_INPUT:
    //    RPF("in WM_INPUT message");
    //    break;

    default:
        break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HWND 
CEm_InitWindow(void)
{
    HWND hwnd;
    WNDCLASS wc;
    static BOOL fFirstTime = TRUE;

    if( fFirstTime ) {
        wc.hCursor        = LoadCursor(0, IDC_ARROW);
        wc.hIcon          = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION));
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = c_szEmClassName;
        wc.hbrBackground  = 0;
        wc.hInstance      = g_hinst;
        wc.style          = 0;
        wc.lpfnWndProc    = CEm_WndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;

        if (!RegisterClass(&wc)) {
            return NULL;
        }

        fFirstTime = FALSE;
    }
    
    hwnd = CreateWindow(
                    c_szEmClassName,                     // Class name
                    TEXT("DIEmWin"),                     // Caption
                    WS_OVERLAPPEDWINDOW,                 // Style
                    -1, -1,                              // Position
                    1, 1,                                // Size
                    NULL,                                //parent
                    NULL,                                // No menu
                    g_hinst,                             // inst handle
                    0                                    // no params
                    );

    if( !hwnd ) {
        RPF("CreateWindow failed.");
    }

    return hwnd;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | CEm_LL_ThreadProc |
 *
 *          The thread that manages our low-level hooks.
 *
 *          ThreadProcs are prototyped to return a DWORD but since the return
 *          would follow some form of ExitThread, it will never be reached so
 *          this function is declared to return VOID and cast.
 *
 *          When we get started, and whenever we receive any message
 *          whatsoever, re-check to see which hooks should be installed
 *          and re-synchronize ourselves with them.
 *
 *          Note that restarting can be slow, since it happens only
 *          when we get nudged by a client.
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          The thread state to use.
 *
 *****************************************************************************/

VOID INTERNAL
CEm_LL_ThreadProc(PLLTHREADSTATE plts)
{
    MSG msg;
    DWORD dwRc;
  #ifdef USE_WM_INPUT
    HWND hwnd = NULL;
  #endif

    AssertF(plts->idThread == GetCurrentThreadId());
    SquirtSqflPtszV(sqflLl, TEXT("CEm_LL_ThreadProc: Thread started"));

  #ifdef USE_SLOW_LL_HOOKS
    /*
     *  Refresh the mouse acceleration values.
     *
     *  ISSUE-2001/03/29-timgill Need a window to listen for WM_SETTINGCHANGE
     *  We need to create a window to listen for
     *  WM_SETTINGCHANGE so we can refresh the mouse acceleration
     *  as needed.
     */
    CEm_Mouse_OnMouseChange();
  #endif

    /*
     *  Create ourselves a queue before we go into our "hey what happened
     *  before I got here?" phase.  The thread that created us is waiting on
     *  the thread event, holding DLLCrit, so let it go as soon as the queue
     *  is ready.  We create the queue by calling a function that requires a
     *  queue.  We use this very simple one.
     */
    GetInputState();

  #ifdef WINNT
    // Look at comment block in FakeTimerProc
    SetTimer(NULL, 0, 2 * 1000 /*2 seconds*/, FakeTimerProc);
  #endif
 
    SetEvent(plts->hEvent);

  #ifdef USE_WM_INPUT
    ResetEvent(g_hEventThread);
  
    if( g_fRawInput ) {
        hwnd = CEm_InitWindow();
    
        if (!hwnd) {
            g_fRawInput = FALSE;
        }
    }

    g_hwndThread = hwnd;

    // Tell CEm_LL_Acquire that windows has been created.
    SetEvent( g_hEventAcquire );

    if( g_fFromKbdMse ) {
        DWORD rc;
        rc = WaitForSingleObject(g_hEventThread, INFINITE);
        g_fFromKbdMse = FALSE;
    }
  #endif
  
#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully that we sync the hooks before entering our
     *  fake GetMessage loop.  This is necessary to avoid the race
     *  condition when CEm_LL_Acquire posts us a thread message
     *  before our thread gets a queue.  By sync'ing the hooks
     *  first, we do what the lost message would've had us do
     *  anyway.
     *  ISSUE-2001/03/29-timgill  Following branch should be no longer necessary
     *  This is should not be needed now that CEm_GetWorkerThread waits for
     *  this thread to respond before continuing on to post any messages.
     */
#endif /* USE_SLOW_LL_HOOKS */
    
    do {

      #ifdef USE_SLOW_LL_HOOKS
        if( !g_fRawInput ) {
            CEm_LL_SyncHook(plts, LLTS_KBD);
            CEm_LL_SyncHook(plts, LLTS_MSE);
        }
      #endif

        /*
         *  We can wake up for three reasons.
         *
         *  1.  We received an APC due to an I/o completion.
         *      Just go back to sleep.
         *
         *  2.  We need to call Peek/GetMessage so that
         *      USER can dispatch a low-level hook or SendMessage.
         *      Go into a PeekMessage loop to let that happen.
         *
         *  3.  A message got posted to us.
         *      Go into a PeekMessage loop to process it.
         */

        do {
            dwRc = _MsgWaitForMultipleObjectsEx(0, 0, INFINITE, QS_ALLINPUT,
                                                MWMO_ALERTABLE);
        } while (dwRc == WAIT_IO_COMPLETION);

        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
            if (msg.hwnd == 0 && msg.message == WM_NULL && msg.lParam) 
            {
                /*
                 *  See if maybe the lParam is a valid PEM that we're
                 *  processing.
                 */
                PEM pem = (PEM)msg.lParam;

                if( pem && pem == plts->pemCheck  )
                {
                    AssertF(GPA_FindPtr(&plts->gpaHid, pem));

                    CEm_HID_Sync(plts, pem);
                    plts->pemCheck = NULL;

                    SetEvent(plts->hEvent);
                  
                  #ifdef USE_WM_INPUT
                    if( g_fRawInput ) {
                        SetEvent(g_hEventHid);
                    }
                  #endif

                    continue;
                }
            }
          #ifdef USE_WM_INPUT
            else if ( g_fRawInput && msg.message == WM_INPUT && 
                      (msg.wParam == RIM_INPUT || msg.wParam == RIM_INPUTSINK) )
            {
                CDIRaw_OnInput(&msg);
            }
          #endif

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    } while (plts->cRef);

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Remove our hooks before we go.
     *
     *  It is possible that there was a huge flurry of disconnects,
     *  causing us to notice that our refcount disappeared before
     *  we got a chance to remove the hooks in our message loop.
     */

    AssertF(plts->rglhs[LLTS_KBD].cHook == 0);
    AssertF(plts->rglhs[LLTS_KBD].cExcl == 0);
    AssertF(plts->rglhs[LLTS_MSE].cHook == 0);
    AssertF(plts->rglhs[LLTS_MSE].cExcl == 0);

    if( !g_fRawInput ) {
        if (plts->rglhs[LLTS_KBD].hhk) {
            UnhookWindowsHookEx(plts->rglhs[LLTS_KBD].hhk);
        }

        if (plts->rglhs[LLTS_MSE].hhk) {
            UnhookWindowsHookEx(plts->rglhs[LLTS_MSE].hhk);
        }
    }
#endif /* USE_SLOW_LL_HOOKS */

  #ifdef USE_WM_INPUT
    if( g_hwndThread ) {
        DestroyWindow( g_hwndThread );
        g_hwndThread = NULL;
    }

    ResetEvent( g_hEventAcquire );
    ResetEvent( g_hEventHid );
  #endif

    if( plts->gpaHid.rgpv ) {
        FreePpv(&plts->gpaHid.rgpv);
    }

    if( plts->hEvent ) {
        CloseHandle( plts->hEvent );
    }

    if( plts->hThread) {
        CloseHandle(plts->hThread);
    }

    FreePpv( &plts );

    SquirtSqflPtszV(sqflLl, TEXT("CEm_LL_ThreadProc: Thread terminating"));

    FreeLibraryAndExitThread(g_hinst, 0);
    /*NOTREACHED*/
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_GetWorkerThread |
 *
 *          Piggyback off the existing worker thread if possible;
 *          else create a new one.
 *
 *  @parm   PEM | pem |
 *
 *          Emulation state which requires a worker thread.
 *
 *  @parm   PLLTHREADSTATE * | pplts |
 *
 *          Receives thread state for worker thread.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_GetWorkerThread(PEM pem, PLLTHREADSTATE *pplts)
{
    PLLTHREADSTATE plts;
    HRESULT hres;

    DllEnterCrit();

    /*
     *  Normally, we can piggyback off the one we already have.
     */
    plts = g_plts;

    /*
     *  If we already have a ref to a worker thread, then use it.
     */
    if (pem->fWorkerThread) {

        /*
         *  The reference we created when we created the worker thread
         *  ensures that g_plts is valid.
         */
        AssertF(plts);
        AssertF(plts->cRef);
        if (plts) {
            hres = S_OK;
        } else {
            AssertF(0);                 /* Can't happen */
            hres = E_FAIL;
        }
    } else

    if (plts) {
        /*
         *  Create a reference to the existing thread.
         */
        pem->fWorkerThread = TRUE;
        InterlockedIncrement(&plts->cRef);
        hres = S_OK;
    } else {

        /*
         *  There is no worker thread (or it is irretrievably
         *  on its way out) so create a new one.
         */
        hres = AllocCbPpv(cbX(LLTHREADSTATE), &plts);
        if (SUCCEEDED(hres)) {
            DWORD dwRc = 0;
            TCHAR tsz[MAX_PATH];

            /*
             *  Assume the worst unless we find otherwise
             */
            hres = E_FAIL;

            if( GetModuleFileName(g_hinst, tsz, cA(tsz))
             && ( LoadLibrary(tsz) == g_hinst ) )
            {

                /*
                 *  Must set up everything to avoid racing with
                 *  the incoming thread.
                 */
                g_plts = plts;
                InterlockedIncrement(&plts->cRef);
                plts->hEvent = CreateEvent(0x0, 0, 0, 0x0);
                if( plts->hEvent )
                {
                    plts->hThread= CreateThread(0, 0, (LPTHREAD_START_ROUTINE)CEm_LL_ThreadProc, plts,
                                               0, &plts->idThread);
                    if( plts->hThread )
                    {
                        /*
                         *  Boost our priority to make sure we
                         *  can handle the messages.
                         *
                         *  RaymondC commented this out saying that it does not
                         *  help but we're hoping that it may on Win2k.
                         */
                        SetThreadPriority(plts->hThread, THREAD_PRIORITY_HIGHEST);

                        /*
                         *  Wait for the thread to signal that it is up and running
                         *  or for it to terminate.
                         *  This means that we don't have to consider the
                         *  possibility that the thread is not yet running in
                         *  NotifyWorkerThreadPem so we know a failure there is
                         *  terminal and don't retry.
                         *
                         *  Assert that the handle fields make a two handle array.
                         */
                        CAssertF( FIELD_OFFSET( LLTHREADSTATE, hThread) + sizeof(plts->hThread)
                               == FIELD_OFFSET( LLTHREADSTATE, hEvent) );

                        /*
                         *  According to a comment in CEm_LL_ThreadProc Win95 may
                         *  fail with an invalid parameter error, so if it does,
                         *  keep trying.  (Assume no valid case will occur.)
                         *
                         *  ISSUE-2001/03/29-timgill  Need to minimise waits while holding sync. objects
                         *  Waiting whilst holding DLLCrit is bad.
                         */
                        do
                        {
                            dwRc = WaitForMultipleObjects( 2, &plts->hThread, FALSE, INFINITE);
                        } while ( ( dwRc == WAIT_FAILED ) && ( GetLastError() == ERROR_INVALID_PARAMETER ) );

                        if( dwRc == WAIT_OBJECT_0 ) {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("CEm_GetWorkerThread: Created Thread terminated on first wait") );
                        } else {
                            pem->fWorkerThread = TRUE;
                            hres = S_OK;
                            if( dwRc != WAIT_OBJECT_0 + 1 )
                            {
                                /*
                                 *  This would be a bad thing if it ever happened
                                 *  but we have to assume that the thread is still
                                 *  running so we return a success anyway.
                                 */
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("CEm_GetWorkerThread: First wait returned 0x%08x with LastError %d"),
                                    dwRc, GetLastError() );
                            }
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("CEm_GetWorkerThread: CreateThread failed with error %d"),
                            GetLastError() );
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("CEm_GetWorkerThread: CreateEvent failed with error %d"),
                        GetLastError() );
                }


                if( FAILED( hres ) )
                {
                    if( plts->hEvent ) {
                        CloseHandle( plts->hEvent );
                    }
                    FreeLibrary(g_hinst);
                }

            }
            else
            {
                RPF( "CEm_GetWorkerThread: failed to LoadLibrary( self ), le = %d", GetLastError() );
            }

            if( FAILED( hres ) )
            {
                FreePv(plts);
                g_plts = 0;
            }
        }
    }

    DllLeaveCrit();

    *pplts = plts;
    return hres;
}

#endif /* WORKER_THREAD */

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_LL_Acquire |
 *
 *          Acquire/unacquire a mouse or keyboard via low-level hooks.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *  @parm   ULONG | fl |
 *
 *          Flags in VXDINSTANCE (vi.fl).
 *
 *  @parm   UINT | ilts |
 *
 *          LLTS_KBD or LLTS_MSE, depending on which is happening.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_LL_Acquire(PEM this, BOOL fAcquire, ULONG fl, UINT ilts)
{
    PLLTHREADSTATE plts;
    BOOL fExclusive = fl & VIFL_CAPTURED;
    BOOL fNoWinkey = fl & VIFL_NOWINKEY;
    HRESULT hres = S_OK;

    EnterProc(CEm_LL_Acquire, (_ "puuu", this, fAcquire, fExclusive, ilts));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF(ilts==LLTS_KBD || ilts==LLTS_MSE);

  #ifdef USE_WM_INPUT
    g_fFromKbdMse = fAcquire ? TRUE : FALSE;
    ResetEvent( g_hEventAcquire );
  #endif  

    hres = CEm_GetWorkerThread(this, &plts);

    if (SUCCEEDED(hres)) {
        AssertF( plts->rglhs[ilts].cHook >= plts->rglhs[ilts].cExcl );

      #ifdef USE_WM_INPUT
        if( g_fRawInput && !g_hwndThread) {
            DWORD dwRc;
            dwRc = WaitForSingleObject(g_hEventAcquire, INFINITE);
        }
      #endif
        
        if (fAcquire) {
            InterlockedIncrement(&plts->rglhs[ilts].cHook);

            if (fExclusive) {
                InterlockedIncrement(&plts->rglhs[ilts].cExcl);
            }

          #ifdef USE_WM_INPUT
            if( g_hwndThread ) {
                if( fExclusive ) {
                    hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_EXCL, g_hwndThread);
                } 
                else if( fNoWinkey ) {
                    AssertF( ilts == 0 );
                    if( ilts == 0 ) {
                        hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_NOHOTKEYS, g_hwndThread);
                    } else {
                        hres = E_FAIL;
                    }
                } 
                else {
                    hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_NONEXCL, g_hwndThread);
                }

                if(FAILED(hres)) {
                    hres = S_FALSE;
                    g_fRawInput = FALSE;
                    RPF("CEm_LL_Acquire: RegisterRawInput failed. LL will be used.");
                }
            }
          #endif
          
        } else {                        /* Remove the hook */
            AssertF(plts->cRef);

            if (fExclusive) {
                InterlockedDecrement(&plts->rglhs[ilts].cExcl);
            }

            InterlockedDecrement(&plts->rglhs[ilts].cHook);

          #ifdef USE_WM_INPUT
            if( g_fRawInput ) {
                CDIRaw_UnregisterRawInputDevice(1-ilts, g_hwndThread);
                
                if( plts->rglhs[ilts].cHook ) {
                    CDIRaw_RegisterRawInputDevice(1-ilts, 0, g_hwndThread);
                }
            }
          #endif
        }

        NudgeWorkerThread(plts->idThread);
    
      #ifdef USE_WM_INPUT
        // tell CEm_LL_ThreadProc that acquire finished.
        SetEvent( g_hEventThread );
      #endif

    }

    ExitOleProc();
    return hres;
}

#endif  /* USE_SLOW_LL_HOOKS */

/*****************************************************************************
 *
 *          Joystick emulation
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_Acquire |
 *
 *          Acquire a joystick.  Nothing happens.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Joy_Acquire(PEM this, BOOL fAcquire)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    return S_OK;
}

/*****************************************************************************
 *
 *          Joystick globals
 *
 *          Since we don't use joystick emulation by default, we allocate
 *          the emulation variables dynamically so we don't blow a page
 *          of memory on them.
 *
 *****************************************************************************/

typedef struct JOYEMVARS {
    ED rged[cJoyMax];
    DIJOYSTATE2 rgjs2[cJoyMax];
} JOYEMVARS, *PJOYEMVARS;

static PJOYEMVARS s_pjev;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_CreateInstance |
 *
 *          Create a joystick thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

#define OBJAT(T, v) (*(T *)(v))
#define PUN(T, v)   OBJAT(T, &(v))

HRESULT INTERNAL
CEm_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

    DllEnterCrit();
    if (s_pjev == 0) {
        DWORD uiJoy;

        hres = AllocCbPpv(cbX(JOYEMVARS), &s_pjev);
        if (SUCCEEDED(hres)) {
            for (uiJoy = 0; uiJoy < cJoyMax; uiJoy++) {
                PUN(PV, s_pjev->rged[uiJoy].pState) = &s_pjev->rgjs2[uiJoy];
                s_pjev->rged[uiJoy].Acquire = CEm_Joy_Acquire;
                s_pjev->rged[uiJoy].cbData = cbX(s_pjev->rgjs2[uiJoy]);
                s_pjev->rged[uiJoy].cRef   = 0x0;
            }
        }
    } else {
        hres = S_OK;
    }
    DllLeaveCrit();

    if (SUCCEEDED(hres)) {
        hres = CEm_CreateInstance(pdevf, ppviOut,
                                  &s_pjev->rged[pdevf->dwExtra]);
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_Ping |
 *
 *          Read data from the joystick.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_Joy_Ping(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    JOYINFOEX ji;
    MMRESULT mmrc;
    PEM this = _thisPvNm(*ppvi, vi);

    AssertF(this->dwSignature == CEM_SIGNATURE);
    ji.dwSize = cbX(ji);
    ji.dwFlags = JOY_RETURNALL + JOY_RETURNRAWDATA;
    ji.dwPOV = JOY_POVCENTERED;         /* joyGetPosEx forgets to set this */

    mmrc = joyGetPosEx((DWORD)(UINT_PTR)this->dwExtra, &ji);
    if (mmrc == JOYERR_NOERROR) {
        DIJOYSTATE2 js;
        UINT uiButtons;

        ZeroX(js);                      /* Wipe out the bogus things */

        js.lX = ji.dwXpos;
        js.lY = ji.dwYpos;
        js.lZ = ji.dwZpos;
        js.lRz = ji.dwRpos;
        js.rglSlider[0] = ji.dwUpos;
        js.rglSlider[1] = ji.dwVpos;
        js.rgdwPOV[0] = ji.dwPOV;
        js.rgdwPOV[1] = JOY_POVCENTERED;
        js.rgdwPOV[2] = JOY_POVCENTERED;
        js.rgdwPOV[3] = JOY_POVCENTERED;

        for (uiButtons = 0; uiButtons < 32; uiButtons++) {
            if (ji.dwButtons & (1 << uiButtons)) {
                js.rgbButtons[uiButtons] = 0x80;
            }
        }

        CEm_AddState(&s_pjev->rged[this->dwExtra], &js, GetTickCount());

        hres = S_OK;
    } else {
        /*
         *  dinput.dll forces the device unacquired here
         *  in DX8 we just return an error
         */
        hres = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,
                                            ERROR_DEV_NOT_EXIST);
    }

    return hres;
}


HRESULT EXTERNAL
NotifyWorkerThreadPem(DWORD idThread, PEM pem)
{
    PLLTHREADSTATE plts;
    HRESULT hres;

    hres = CEm_GetWorkerThread(pem, &plts);

    if( SUCCEEDED(hres) )
    {
        AssertF(plts->idThread == idThread);

        hres = NudgeWorkerThreadPem( plts, pem );
    }
    return hres;
}


HRESULT EXTERNAL
NudgeWorkerThreadPem( PLLTHREADSTATE plts, PEM pem )
{
    HRESULT hres = S_FALSE;

    plts->pemCheck = pem;

    if( !PostWorkerMessage(plts->idThread, pem))
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("NudgeWorkerThreadPem: PostThreadMessage Failed with error %d"),
                        GetLastError() );
    }
    else if( pem )
    {
        DWORD dwRc;

        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("NudgeWorkerThreadPem: PostThreadMessage SUCCEEDED, waiting for event ... "));


        /*
         *  According to a comment in CEm_LL_ThreadProc Win95 may
         *  fail with an invalid parameter error, so if it does,
         *  keep trying.  (Assume no valid case will occur.)
         */
        do
        {
            dwRc = WaitForMultipleObjects( 2, &plts->hThread, FALSE, INFINITE);
        } while ( ( dwRc == WAIT_FAILED ) && ( GetLastError() == ERROR_INVALID_PARAMETER ) );

        switch( dwRc )
        {
        case WAIT_OBJECT_0:
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("NotifyWorkerThreadPem: Not expecting response from dead worker thread") );
            break;
        case WAIT_OBJECT_0 + 1:
            /*
             *  The worker thread responded OK
             */
            hres = S_OK;
            AssertF(plts->pemCheck == NULL );
            break;
        default:
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("NotifyWorkerThreadPem: WaitForMultipleObjects returned 0x%08x with LastError %d"),
                dwRc, GetLastError() );
            hres = E_FAIL;
            break;
        }

    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diemh.c ===
/*****************************************************************************
 *
 *  DIEmH.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for HID.  HID is always run at ring 3,
 *      so "emulation" is a bit of a misnomer.
 *
 *  Contents:
 *
 *      CEm_HID_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

    #define sqfl sqflEm


/*****************************************************************************
 *
 *      Forward declarations
 *
 *      CEm_HID_ReadComplete and CEm_HID_IssueRead schedule each other
 *      back and forth.
 *
 *****************************************************************************/

void CALLBACK
    CEm_HID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po);
/*****************************************************************************
 *
 *          HID "emulation"
 *
 *****************************************************************************/

STDMETHODIMP CEm_HID_Acquire(PEM this, BOOL fAcquire);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeCancelIO |
 *
 *          Stub function which doesn't do anything but
 *          keeps us from crashing.
 *
 *  @parm   HANDLE | h |
 *
 *          The handle whose I/O is supposed to be cancelled.
 *
 *****************************************************************************/

BOOL WINAPI
    FakeCancelIO(HANDLE h)
{
    AssertF(0);
    return FALSE;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeTryEnterCriticalSection |
 *
 *          We use TryEnterCriticalSection in DEBUG to detect deadlock
 *          If the function does not exist, just enter CritSection and report
 *          true. This compromises some debug functionality.           
 *
 *  @parm   LPCRITICAL_SECTION | lpCriticalSection |
 *
 *          Address of Critical Section to be entered. 
 *
 *****************************************************************************/
#ifdef XDEBUG
BOOL WINAPI
    FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    EnterCriticalSection(lpCriticalSection);
    return TRUE;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Hold |
 *
 *          Place a hold on both the parent device and the
 *          emulation structure, so neither will go away while
 *          we aren't paying attention.
 *
 *  @parm   PCHID | this |
 *
 *          The item to be held.
 *
 *****************************************************************************/

void INTERNAL
    CEm_Hid_Hold(PCHID this)
{
    CEm_AddRef(pemFromPvi(this->pvi));
    Common_Hold(this);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Unhold |
 *
 *          Release the holds we placed via <f CEm_HID_Hold>.
 *
 *  @parm   PCHID | this |
 *
 *          The item to be unheld.
 *
 *****************************************************************************/

void INTERNAL
    CEm_Hid_Unhold(PCHID this)
{
    CEm_Release(pemFromPvi(this->pvi));
    Common_Unhold(this);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   BOOL | CEm_HID_IssueRead |
 *
 *          Issue another read request.
 *
 *  @parm   PCHID | this |
 *
 *          The device on which the read is to be issued.
 *
 *  @returns
 *
 *          Returns nonzero if the read was successfully issued.
 *
 *****************************************************************************/

BOOL EXTERNAL
    CEm_HID_IssueRead(PCHID this)
{
    BOOL fRc;

    fRc = ReadFileEx(this->hdevEm, this->hriIn.pvReport,
                     this->hriIn.cbReport, &this->o,
                     CEm_HID_ReadComplete);

    if(!fRc)
    {
        /*
         *  Couldn't issue read; force an unacquire.
         *
         *  Unhold the device once, since the read loop is gone.
         */
        // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("IssueRead: Access to HID device(%p, handle=0x%x) lost le=0x%x!"), 
                        this, this->hdevEm, GetLastError() );

        DllEnterCrit();
        ConfirmF(SUCCEEDED(GPA_DeletePtr(&g_plts->gpaHid, pemFromPvi(this->pvi))));
        DllLeaveCrit();

        CEm_ForceDeviceUnacquire(&this->ed,
                                 (!(this->pvi->fl & VIFL_ACQUIRED)) ? FDUFL_UNPLUGGED : 0);

        CEm_Hid_Unhold(this);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("Removed HID device(%p) from GPA "), this);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_PrepareState |
 *
 *          Prepare the staging area for a new device state
 *          by assuming that nothing has changed.
 *
 *  @parm   PCHID | this |
 *
 *          The device on which a read has just completed.
 *
 *****************************************************************************/

void INLINE
    CEm_HID_PrepareState(PCHID this)
{
    /*
     *  Copy over everything...
     */
    CopyMemory(this->pvStage, this->pvPhys, this->cbPhys);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_ReadComplete |
 *
 *          APC function which is called when an I/O has completed.
 *
 *  @parm   DWORD | dwError |
 *
 *          Error code, or zero on success.
 *
 *  @parm   DWORD | cbRead |
 *
 *          Number of bytes actually read.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          I/O packet that completed.
 *
 *****************************************************************************/

void CALLBACK
    CEm_HID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
    PCHID this = pchidFromPo(po);

    //EnterProc(Cem_HID_ReadComplete, (_"ddp", dwError, cbRead, po ));


    /*
     *  Cannot own any critical sections because CEm_ForceDeviceUnacquire
     *  assumes that no critical sections are taken.
     */
    AssertF(!CDIDev_InCrit(this->pvi->pdd));
    AssertF(!DllInCrit());

    /*
     *  Process the data.
     *
     *  Note: We can get error STATUS_DEVICE_NOT_CONNECTED
     *  or ERROR_READ_FAULT if the device is unplugged.
     */
    if(dwError == 0 &&
       this->o.InternalHigh == this->caps.InputReportByteLength)
    {

        NTSTATUS stat;

        CEm_HID_PrepareState(this);

        stat = CHid_ParseData(this, HidP_Input, &this->hriIn);

        if(SUCCEEDED(stat))
        {
            CEm_AddState(&this->ed, this->pvStage, GetTickCount());
        }

        CEm_HID_IssueRead(this);
    } else
    {

        if(!dwError)
        {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqflError | sqfl,
                            TEXT("ReadComplete HID(%p) short read! Got %d wanted %d"),
                            this,
                            this->o.InternalHigh,
                            this->caps.InputReportByteLength);

        } else
        {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqflError | sqfl,
                            TEXT("ReadComplete HID(%p) read failed! error=0x%08x "),
                            this, dwError);
        }

        DllEnterCrit();
        ConfirmF(SUCCEEDED(GPA_DeletePtr(&g_plts->gpaHid, pemFromPvi(this->pvi))));
        DllLeaveCrit();

        CEm_ForceDeviceUnacquire(&this->ed,
                                 (!(this->pvi->fl & VIFL_ACQUIRED)) ? FDUFL_UNPLUGGED : 0);

        CEm_Hid_Unhold(this);
    }

    /*
     *  And wait for more data.
     *  If the read failed, then CEm_HID_IssueRead() will its Reference 
     */
    //    CEm_HID_IssueRead(this);

    //ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Sync |
 *
 *          Kick off a read or kill the existing one.
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          Thread hook state containing hook information to synchronize.
 *
 *  @parm   PEM | pem |
 *
 *          Who is the poor victim?
 *
 *****************************************************************************/

void EXTERNAL
    CEm_HID_Sync(PLLTHREADSTATE plts, PEM pem)
{
    PCHID this;

    EnterProc(CEm_HID_Sync, (_ "pp", plts, pem ));

    this = pchidFromPem(pem);

    AssertF(GPA_FindPtr(&plts->gpaHid, pem));
    AssertF(this->pvi == &pem->vi);
    AssertF(pem->ped == &this->ed);

    /*
     *  Cannot own any critical sections because CEm_HID_IssueRead
     *  may result in a call to CEm_ForceDeviceUnacquire, which
     *  in turn assumes that no critical sections are taken.
     */
    AssertF(!CDIDev_InCrit(this->pvi->pdd));
    AssertF(!DllInCrit());

    if( pem->vi.fl & VIFL_ACQUIRED )
    {
        AssertF(this->hdevEm == INVALID_HANDLE_VALUE);
        /*
         *  Start reading.
         *
         *  While underneath the device critical section, duplicate
         *  the handle so we can avoid race conditions with the
         *  main thread (when the main thread closes the handle,
         *  we need to keep our private version alive so we can
         *  clean it up nicely).
         */

        /*
         *  Need to look again, in case the device has already
         *  been unacquired before we get a chance to synchronize
         *  with the main thread.  This can happen, for example,
         *  if the app quickly does an Acquire/Unacquire without
         *  an intervening thread switch.
         */
        AssertF(!CDIDev_InCrit(this->pvi->pdd));
        //CDIDev_EnterCrit(this->pvi->pdd);
        if(this->hdev != INVALID_HANDLE_VALUE)
        {
            HANDLE hProcessMe = GetCurrentProcess();
            HANDLE hdevEm;

            if(DuplicateHandle(hProcessMe, this->hdev,
                               hProcessMe, &hdevEm, GENERIC_READ,
                               0, 0))
            {
                this->hdevEm = hdevEm;
            }
        }
        //CDIDev_LeaveCrit(this->pvi->pdd);

        if(this->hdevEm != INVALID_HANDLE_VALUE)
        {
            /*
             *  On Win98, HidD_FlushQueue will fail if the underlying
             *  device is dead.  Whereas on NT, it blindly succeeds.
             *  Therefore, we cannot trust the return value.
             */
            HidD_FlushQueue(this->hdevEm);
        }

        /*
         * Even if we have failed to duplicate the handle
         * we still want to issue the read. A error in read
         * will force the device to be unacquired
         */
        CEm_HID_IssueRead(this);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT(" StartReading(%p) "),
                        this);
    } else 
    {
        HANDLE hdev;
        /*
         *  Stop reading. There is still another outstanding
         *  hold by the read loop, which will be cleaned up when
         *  the the I/O cancel is received.
         */
        AssertF(this->hdevEm != INVALID_HANDLE_VALUE);

        hdev = this->hdevEm;
        this->hdevEm = INVALID_HANDLE_VALUE;

        if(hdev != INVALID_HANDLE_VALUE)
        {
            /*
             *  We don't need to call CancelIo because we're closing
             *  the handle soon anyway.  Which is good, because Memphis
             *  B#55771 prevents CancelIo from working on read-only
             *  handles (which we are).
             *
             */
            /* Need CancelIo on NT otherwise HID devices appear only on every
             * consecutive plug in 
             */

            _CancelIO(hdev);
            CloseHandle(hdev);
        }

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT(" StopReading(%p) "),
                        this);
    }

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_HID_Acquire |
 *
 *          Acquire/unacquire a HID device.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
    CEm_HID_Acquire(PEM pem, BOOL fAcquire)
{
    HRESULT hres;
    PLLTHREADSTATE plts;
    PCHID pchid;

    EnterProc(CEm_HID_Acquire, (_ "pu", pem, fAcquire));

    AssertF(pem->dwSignature == CEM_SIGNATURE);

    pchid = pchidFromPem(pem);

    if( fAcquire )
    {
        pchid->hdev = CHid_OpenDevicePath(pchid, FILE_FLAG_OVERLAPPED);

        if(pchid->hdev != INVALID_HANDLE_VALUE )
        {
            hres = S_OK;
        } else {
            hres = DIERR_UNPLUGGED;
        }

    } else
    {
        AssertF(pchid->hdev != INVALID_HANDLE_VALUE);

        _CancelIO(pchid->hdev);
        CloseHandle(pchid->hdev);
        pchid->hdev = INVALID_HANDLE_VALUE;

        hres = S_OK;
    }

    if( pchid->IsPolledInput )
    {
        hres = S_OK;
        AssertF(pchid->hdevEm == INVALID_HANDLE_VALUE);

    } else if( SUCCEEDED(hres) )
    {
      #ifdef USE_WM_INPUT
        ResetEvent( g_hEventHid );
      #endif
            
        hres = CEm_GetWorkerThread(pem, &plts);

        if(SUCCEEDED(hres)  )
        {
            if(fAcquire  )
            {  /* Begin the I/O */
                /*
                 *  Must apply the hold before adding to the list
                 *  to avoid a race condition where the worker thread
                 *  unholds the pchid before we can hold it.
                 *
                 *  The rule is that there is a hold to track each copy
                 *  of the device on the gpaHid.
                 */
                CEm_Hid_Hold(pchid);

                /*
                 *  Add ourselves to the busy list, and wake up
                 *  the worker thread to tell him to start paying attention.
                 */

                DllEnterCrit();
                hres = GPA_Append(&plts->gpaHid, pem);
                DllLeaveCrit();

                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("Added HID device(%p) to GPA "), pchid );

                if(FAILED(hres))
                {
                    CEm_Hid_Unhold(pchid);
                }

                NudgeWorkerThreadPem(plts, pem);

              #ifdef USE_WM_INPUT
                if( g_fRawInput ) {
                    DWORD dwRc;
                    dwRc = WaitForSingleObject( g_hEventHid, INFINITE );
                }
              #endif

            } else
            {
                HANDLE hdev;

                hdev = pchid->hdevEm;
                pchid->hdevEm = INVALID_HANDLE_VALUE;

                if(hdev != INVALID_HANDLE_VALUE)
                {
                    _CancelIO(hdev);
                    CloseHandle(hdev);
                }
            }

        }

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_HID_CreateInstance |
 *
 *          Create a HID thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CEm_HID_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    PCHID pchid = (PCHID)pdevf->dwExtra;
    PED ped = &pchid->ed;

    AssertF(ped->pState == 0);
    AssertF(ped->pDevType == 0);
    *(PPV)&ped->pState = pchid->pvPhys;      /* De-const */
    ped->Acquire = CEm_HID_Acquire;
    ped->cAcquire = -1;
    ped->cbData = pdevf->cbData;
    ped->cRef = 0x0;

    return CEm_CreateInstance(pdevf, ppviOut, &pchid->ed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diextdll.c ===
/*****************************************************************************
 *
 *  DIExtDll.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Dynamic loading of optional external DLLs.
 *
 *  Contents:
 *
 *      ExtDll_Init
 *      ExtDll_Term
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflExtDll

/*****************************************************************************
 *
 *  @define T | TEXT(ch) |
 *
 *          Either "A" or "W", depending on whether we are building
 *          the ANSI or UNICODE version.
 *
 *****************************************************************************/

    #ifdef UNICODE
        #define T       "W"
    #else
        #define T       "A"
    #endif

/*****************************************************************************
 *
 *  @define MAKEAPINAME | nm |
 *
 *          Emit a c_sz that records the name of the API.
 *
 *****************************************************************************/

    #define MAKEAPINAME(nm)     CHAR c_sz##nm[] = #nm

#ifndef STATIC_DLLUSAGE

/*****************************************************************************
 *
 *  CFGMGR32
 *
 *  Note that this must match the CFGMGR32 structure in diextdll.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(CM_Get_Child);
MAKEAPINAME(CM_Get_Sibling);
MAKEAPINAME(CM_Get_Parent);
MAKEAPINAME(CM_Get_DevNode_Registry_Property) T;
MAKEAPINAME(CM_Set_DevNode_Registry_Property) T;
MAKEAPINAME(CM_Get_Device_ID) T;
        #pragma END_CONST_DATA

#ifndef WINNT
LPSTR g_cfgmgr32_fn[] = {
    c_szCM_Get_Child,
    c_szCM_Get_Sibling,
    c_szCM_Get_Parent,
    c_szCM_Get_DevNode_Registry_Property,
    c_szCM_Set_DevNode_Registry_Property,
    c_szCM_Get_Device_ID
};

HINSTANCE g_hinstcfgmgr32;

CFGMGR32 g_cfgmgr32 = {
    (FARPROC)DIDummy_CM_Get_Child,
    (FARPROC)DIDummy_CM_Get_Sibling,
    (FARPROC)DIDummy_CM_Get_Parent,
    (FARPROC)DIDummy_CM_Get_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Set_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Get_Device_ID
};
#endif


/*****************************************************************************
 *
 *  SETUPAPI
 *
 *  Note that this must match the SETUPAPI structure in diextdll.h
 *
 *****************************************************************************/

       #pragma BEGIN_CONST_DATA
MAKEAPINAME(SetupDiGetClassDevs) T;
MAKEAPINAME(SetupDiDestroyDeviceInfoList);
MAKEAPINAME(SetupDiGetDeviceInterfaceDetail) T;
MAKEAPINAME(SetupDiEnumDeviceInterfaces);
MAKEAPINAME(SetupDiCreateDeviceInterfaceRegKey) T;
MAKEAPINAME(SetupDiCallClassInstaller);
MAKEAPINAME(SetupDiGetDeviceRegistryProperty) T;
MAKEAPINAME(SetupDiSetDeviceRegistryProperty) T;
MAKEAPINAME(SetupDiGetDeviceInstanceId) T;
MAKEAPINAME(SetupDiOpenDeviceInfo) T;
MAKEAPINAME(SetupDiCreateDeviceInfoList);
MAKEAPINAME(SetupDiOpenDevRegKey);
        #pragma END_CONST_DATA

LPSTR g_setupapi_fn[] = {
    c_szSetupDiGetClassDevs,
    c_szSetupDiDestroyDeviceInfoList,
    c_szSetupDiGetDeviceInterfaceDetail,
    c_szSetupDiEnumDeviceInterfaces,
    c_szSetupDiCreateDeviceInterfaceRegKey,
    c_szSetupDiCallClassInstaller,
    c_szSetupDiGetDeviceRegistryProperty,
    c_szSetupDiSetDeviceRegistryProperty,
    c_szSetupDiGetDeviceInstanceId,
    c_szSetupDiOpenDeviceInfo,
    c_szSetupDiCreateDeviceInfoList,
    c_szSetupDiOpenDevRegKey,
  #ifdef WINNT
    c_szCM_Get_Child,
    c_szCM_Get_Sibling,
    c_szCM_Get_Parent,
    c_szCM_Get_DevNode_Registry_Property,
    c_szCM_Set_DevNode_Registry_Property,
    c_szCM_Get_Device_ID
  #endif
};

HINSTANCE g_hinstSetupapi;

SETUPAPI g_setupapi = {
    (FARPROC)DIDummy_SetupDiGetClassDevs,
    (FARPROC)DIDummy_SetupDiDestroyDeviceInfoList,
    (FARPROC)DIDummy_SetupDiGetDeviceInterfaceDetail,
    (FARPROC)DIDummy_SetupDiEnumDeviceInterfaces,
    (FARPROC)DIDummy_SetupDiCreateDeviceInterfaceRegKey,
    (FARPROC)DIDummy_SetupDiCallClassInstaller,
    (FARPROC)DIDummy_SetupDiGetDeviceRegistryProperty,
    (FARPROC)DIDummy_SetupDiSetDeviceRegistryProperty,
    (FARPROC)DIDummy_SetupDiGetDeviceInstanceId,
    (FARPROC)DIDummy_SetupDiOpenDeviceInfo,
    (FARPROC)DIDummy_SetupDiCreateDeviceInfoList,
    (FARPROC)DIDummy_SetupDiOpenDevRegKey,
  #ifdef WINNT
    (FARPROC)DIDummy_CM_Get_Child,
    (FARPROC)DIDummy_CM_Get_Sibling,
    (FARPROC)DIDummy_CM_Get_Parent,
    (FARPROC)DIDummy_CM_Get_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Set_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Get_Device_ID
  #endif    
};

/*****************************************************************************
 *
 *  HIDDLL
 *
 *  Note that this must match the HIDDLL structure in diextdll.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(HidD_GetHidGuid);
MAKEAPINAME(HidD_GetPreparsedData);
MAKEAPINAME(HidD_FreePreparsedData);
MAKEAPINAME(HidD_FlushQueue);
MAKEAPINAME(HidD_GetAttributes);
MAKEAPINAME(HidD_GetFeature);
MAKEAPINAME(HidD_SetFeature);
MAKEAPINAME(HidD_GetProductString);
MAKEAPINAME(HidD_GetInputReport);
MAKEAPINAME(HidP_GetCaps);
MAKEAPINAME(HidP_GetButtonCaps);
MAKEAPINAME(HidP_GetValueCaps);
MAKEAPINAME(HidP_GetLinkCollectionNodes);
MAKEAPINAME(HidP_MaxDataListLength);
MAKEAPINAME(HidP_GetUsagesEx);
MAKEAPINAME(HidP_GetScaledUsageValue);
MAKEAPINAME(HidP_GetData);
MAKEAPINAME(HidP_SetData);
MAKEAPINAME(HidP_GetUsageValue);
MAKEAPINAME(HidP_MaxUsageListLength);
MAKEAPINAME(HidP_GetSpecificButtonCaps);
MAKEAPINAME(HidP_TranslateUsagesToI8042ScanCodes);
        #pragma END_CONST_DATA

LPSTR g_hiddll_fn[] = {
    c_szHidD_GetHidGuid,
    c_szHidD_GetPreparsedData,
    c_szHidD_FreePreparsedData,
    c_szHidD_FlushQueue,
    c_szHidD_GetAttributes,
    c_szHidD_GetFeature,
    c_szHidD_SetFeature,
    c_szHidD_GetProductString,
    c_szHidD_GetInputReport,
    c_szHidP_GetCaps,
    c_szHidP_GetButtonCaps,
    c_szHidP_GetValueCaps,
    c_szHidP_GetLinkCollectionNodes,
    c_szHidP_MaxDataListLength,
    c_szHidP_GetUsagesEx,
    c_szHidP_GetScaledUsageValue,
    c_szHidP_GetData,
    c_szHidP_SetData,
    c_szHidP_GetUsageValue,
    c_szHidP_MaxUsageListLength,
    c_szHidP_GetSpecificButtonCaps,
    c_szHidP_TranslateUsagesToI8042ScanCodes
};

HINSTANCE g_hinstHid;

HIDDLL g_hiddll = {
    (FARPROC)DIDummy_HidD_GetHidGuid,
    (FARPROC)DIDummy_HidD_GetPreparsedData,
    (FARPROC)DIDummy_HidD_FreePreparsedData,
    (FARPROC)DIDummy_HidD_FlushQueue,
    (FARPROC)DIDummy_HidD_GetAttributes,
    (FARPROC)DIDummy_HidD_GetFeature,
    (FARPROC)DIDummy_HidD_SetFeature,
    (FARPROC)DIDummy_HidD_GetProductString,
    (FARPROC)DIDummy_HidD_GetInputReport,
    (FARPROC)DIDummy_HidP_GetCaps,
    (FARPROC)DIDummy_HidP_GetButtonCaps,
    (FARPROC)DIDummy_HidP_GetValueCaps,
    (FARPROC)DIDummy_HidP_GetLinkCollectionNodes,
    (FARPROC)DIDummy_HidP_MaxDataListLength,
    (FARPROC)DIDummy_HidP_GetUsagesEx,
    (FARPROC)DIDummy_HidP_GetScaledUsageValue,
    (FARPROC)DIDummy_HidP_GetData,
    (FARPROC)DIDummy_HidP_SetData,
    (FARPROC)DIDummy_HidP_GetUsageValue,
    (FARPROC)DIDummy_HidP_MaxUsageListLength,
    (FARPROC)DIDummy_HidP_GetSpecificButtonCaps,
    (FARPROC)DIDummy_HidP_TranslateUsagesToI8042ScanCodes,
};

/*****************************************************************************
 *
 *  Winmm
 *
 *  Note that this must match the Winmm structure in diextdll.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(joyGetDevCaps) T;
MAKEAPINAME(joyGetPosEx);
MAKEAPINAME(joyGetPos);
MAKEAPINAME(joyConfigChanged);
MAKEAPINAME(mmioClose);
MAKEAPINAME(mmioOpenA);
MAKEAPINAME(mmioDescend);
MAKEAPINAME(mmioCreateChunk);
MAKEAPINAME(mmioRead);
MAKEAPINAME(mmioWrite);
MAKEAPINAME(mmioAscend);
        #pragma END_CONST_DATA

LPSTR g_winmmdll_fn[] = {
    c_szjoyGetDevCaps,
    c_szjoyGetPosEx,
    c_szjoyGetPos,
    c_szjoyConfigChanged,
    c_szmmioClose,      
    c_szmmioOpenA,
    c_szmmioDescend,    
    c_szmmioCreateChunk,
    c_szmmioRead,       
    c_szmmioWrite,      
    c_szmmioAscend
};      
        
HINSTANCE g_hinstwinmmdll;
        
WINMMDLL g_winmmdll = {
    (FARPROC)DIDummy_joyGetDevCaps,
    (FARPROC)DIDummy_joyGetPosEx,
    (FARPROC)DIDummy_joyGetPos,
    (FARPROC)DIDummy_joyConfigChanged,
    (FARPROC)DIDummy_mmioClose,
    (FARPROC)DIDummy_mmioOpenA,
    (FARPROC)DIDummy_mmioDescend,
    (FARPROC)DIDummy_mmioCreateChunk,
    (FARPROC)DIDummy_mmioRead,
    (FARPROC)DIDummy_mmioWrite,
    (FARPROC)DIDummy_mmioAscend,
};

/*****************************************************************************
 *
 *  User32
 *
 *  Note that this must match the User32 structure in dihid.h
 *
 *****************************************************************************/

#ifdef USE_WM_INPUT

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(RegisterRawInputDevices);
MAKEAPINAME(GetRawInputData);
        #pragma END_CONST_DATA

LPSTR g_user32_fn[] = {
    c_szRegisterRawInputDevices,
    c_szGetRawInputData,
};

HINSTANCE g_hinstuser32;

USER32 g_user32 = {
    (FARPROC)DIDummy_RegisterRawInputDevices,
    (FARPROC)DIDummy_GetRawInputData,
};

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HINSTANCE | ExtDll_LoadDll |
 *
 *          Loads a DLL and resolves all the imports.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the DLL to load.
 *
 *  @parm   PMANUALIMPORT | rgmi |
 *
 *          Array of <t MANUALIMPORT> structures to resolve.
 *
 *  @parm   int | cmi |
 *
 *          Number of <t MANUALIMPORT> structures to resolve.
 *
 *  @parm   LPSTR * | ppszProcName |
 * 
 *          Function names.
 *
 *  @returns
 *
 *          Returns the instance handle of the DLL if one or more of the imports
 *          were resolved successfully; otherwise, unloads the DLL
 *          and returns 0.
 *
 *          If none of the imports was resolved successfully, the value
 *          of the entries of <p rgmi> are not changed.
 *
 *****************************************************************************/

HINSTANCE INTERNAL
    ExtDll_LoadDll(LPCTSTR ptszName, PMANUALIMPORT rgmi, int cmi, LPSTR *ppszProcName)
{
    HINSTANCE hinst = 0;
    BOOL      fNeedFreeLib = TRUE;

    EnterProcR(ExtDll_LoadDll, (_ "spuup", ptszName, rgmi, cmi, ppszProcName));

    hinst = LoadLibrary(ptszName);
    if(hinst)
    {
        int     imi;
        FARPROC fp;

        for(imi = 0; imi < cmi; imi++)
        {
            fp = GetProcAddress(hinst, ppszProcName[imi]);
            if( fp ) {
                rgmi[imi].pfn = fp;
                fNeedFreeLib = FALSE;
            }
        }
    }

    if( fNeedFreeLib ) {
        FreeLibrary(hinst);
        hinst = 0;
    }
        
    ExitProcX((UINT_PTR)hinst);
    
    return hinst;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ExtDll_Init |
 *
 *          Try to load our optional DLLs.  Don't get upset if they
 *          don't load.
 *
 *****************************************************************************/

void EXTERNAL
    ExtDll_Init(void)
{
    g_hinstHid =      ExtDll_LoadDll(TEXT("HID.DLL"),
                                g_hiddll.rgmi,
                                cA(g_hiddll.rgmi),
                                g_hiddll_fn ); 
    
    g_hinstSetupapi = ExtDll_LoadDll(TEXT("SETUPAPI.DLL"),
                                g_setupapi.rgmi,
                                cA(g_setupapi.rgmi),
                                g_setupapi_fn );
    
    #ifndef WINNT
    g_hinstcfgmgr32 = ExtDll_LoadDll( TEXT("CFGMGR32.DLL" ),
                                g_cfgmgr32.rgmi,
                                cA(g_cfgmgr32.rgmi),
                                g_cfgmgr32_fn );
    #endif
    
  #ifdef WINNT
    #define JOYPROCNUM  4
    g_hinstwinmmdll = ExtDll_LoadDll( TEXT("WINMM.DLL" ),
                                &g_winmmdll.rgmi[JOYPROCNUM],
                                cA(g_winmmdll.rgmi) - JOYPROCNUM,
                                &g_winmmdll_fn[JOYPROCNUM] );
    #undef JOYPROCNUM
  #else
    g_hinstwinmmdll = ExtDll_LoadDll( TEXT("WINMM.DLL" ),
                                g_winmmdll.rgmi,
                                cA(g_winmmdll.rgmi),
                                g_winmmdll_fn );
  #endif
  
  #ifdef USE_WM_INPUT
    g_hinstuser32   = ExtDll_LoadDll( TEXT("USER32.DLL" ),
                                g_user32.rgmi,
                                cA(g_user32.rgmi),
                                g_user32_fn );
  #endif
      
}

#endif /* STATIC_DLLUSAGE */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ExtDll_Term |
 *
 *          Unload any optional DLLs that we loaded.
 *
 *****************************************************************************/

void EXTERNAL
    ExtDll_Term(void)
{
  #ifndef STATIC_DLLUSAGE
    if(g_hinstSetupapi)
    {
  #endif /* STATIC_DLLUSAGE */

        DllEnterCrit();
        if(g_phdl)
        {
            DIHid_EmptyHidList();
            FreePpv(&g_phdl);
        }

        DIBus_FreeMemory();

        DllLeaveCrit();

#ifndef STATIC_DLLUSAGE
        FreeLibrary(g_hinstSetupapi);
        g_hinstSetupapi = NULL;
    }

  #ifndef WINNT
    if(g_hinstcfgmgr32)
    {
        FreeLibrary(g_hinstcfgmgr32);
        g_hinstcfgmgr32 = NULL;
    }
  #endif

    if(g_hinstHid)
    {
        FreeLibrary(g_hinstHid);
        g_hinstHid = NULL;
    }

    if( g_hinstwinmmdll)
    {
        FreeLibrary(g_hinstwinmmdll);
        g_hinstwinmmdll = NULL;
    }

  #ifdef USE_WM_INPUT    
    if( g_hinstuser32)
    {
        FreeLibrary(g_hinstuser32);
        g_hinstuser32 = NULL;
    }
  #endif

#endif /* STATIC_DLLUSAGE */

}

#ifndef STATIC_DLLUSAGE

////////////////////////////////////////
// cfgmgr32.dll dummy functions
////////////////////////////////////////

CONFIGRET WINAPI DIDummy_CM_Get_Child
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Child( %08x, %08x, %u )"),
                     pdnDevInst, dnDevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Sibling
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  DevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Sibling( %08x, %08x, %u )"),
                     pdnDevInst, DevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Parent
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Parent( %08x, %08x, %u )"),
                     pdnDevInst, dnDevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
OUT PULONG      pulRegDataType,   OPTIONAL
OUT PVOID       Buffer,           OPTIONAL
IN  OUT PULONG  pulLength,
IN  ULONG       ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_DevNode_Registry_Property( %08x, %u, %08x, %08x, %08x, %u )"),
                     dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Set_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
IN  PVOID       Buffer,           OPTIONAL
IN  ULONG       ulLength,
IN  ULONG       ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Set_DevNode_Registry_Property( %08x, %u, %08x, %u, %u )"),
                     dnDevInst, ulProperty, Buffer, ulLength, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Device_ID
(
 IN  DEVINST  dnDevInst,
 OUT PTCHAR   Buffer,
 IN  ULONG    BufferLen,
 IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Device_ID( %08x, %08x, %u, %u )"),
                     dnDevInst, Buffer, BufferLen, ulFlags );

    return CR_FAILURE;
}

////////////////////////////////////////
//Setupapi.dll dummy functions
////////////////////////////////////////

HDEVINFO WINAPI DIDummy_SetupDiGetClassDevs
(
IN LPGUID ClassGuid,  OPTIONAL
IN LPCTSTR Enumerator, OPTIONAL
IN HWND   hwndParent, OPTIONAL
IN DWORD  Flags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetClassDevs( %08x, %08x, %08x, %u )"),
                     ClassGuid, Enumerator, hwndParent, Flags );

    return INVALID_HANDLE_VALUE;    
}

BOOL WINAPI DIDummy_SetupDiDestroyDeviceInfoList
(
IN HDEVINFO DeviceInfoSet
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiDestroyDeviceInfoList( %08x )"),
                     DeviceInfoSet );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceInterfaceDetail
(
IN  HDEVINFO                         DeviceInfoSet,
IN  PSP_DEVICE_INTERFACE_DATA        pdid,
OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
IN  DWORD                            cbDidd,
OUT PDWORD                           RequiredSize,  OPTIONAL
OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInterfaceDetail( %08x, %08x, %08x, %u, %08x, %08x )"),
                     DeviceInfoSet, pdid, pdidd, cbDidd, RequiredSize, DeviceInfoData );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiEnumDeviceInterfaces
(
IN  HDEVINFO                  DeviceInfoSet,
IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
IN  LPGUID                    InterfaceClassGuid,
IN  DWORD                     MemberIndex,
OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiEnumDeviceInterfaces( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, MemberIndex, DeviceInterfaceData );

    return FALSE;
}

HKEY WINAPI DIDummy_SetupDiCreateDeviceInterfaceRegKey
(
IN HDEVINFO                  hdev,
IN PSP_DEVICE_INTERFACE_DATA pdid,
IN DWORD                     Reserved,
IN REGSAM                    samDesired,
IN HINF                      InfHandle,           OPTIONAL
IN PCSTR                     InfSectionName       OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCreateDeviceInterfaceRegKey( %08x, %08x, %u, %u, %08x, %s )"),
                     hdev, pdid, Reserved, samDesired, InfHandle, InfSectionName );

    return INVALID_HANDLE_VALUE;
}

BOOL WINAPI DIDummy_SetupDiCallClassInstaller
(
IN DI_FUNCTION      InstallFunction,
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCallClassInstaller( %08x, %08x, %08x )"),
                     InstallFunction, DeviceInfoSet, DeviceInfoData );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceRegistryProperty
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
IN  DWORD            Property,
OUT PDWORD           PropertyRegDataType, OPTIONAL
OUT PBYTE            PropertyBuffer,
IN  DWORD            PropertyBufferSize,
OUT PDWORD           RequiredSize         OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceRegistryProperty( %08x, %08x, %u, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiSetDeviceRegistryProperty
(
IN     HDEVINFO         DeviceInfoSet,
IN OUT PSP_DEVINFO_DATA DeviceInfoData,
IN     DWORD            Property,
IN     CONST BYTE*      PropertyBuffer,
IN     DWORD            PropertyBufferSize
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInstanceId( %08x, %08x, %u, %08x, %u )"),
                     DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceInstanceId
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
OUT PTSTR            DeviceInstanceId,
IN  DWORD            DeviceInstanceIdSize,
OUT PDWORD           RequiredSize          OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInstanceId( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, RequiredSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiOpenDeviceInfo
(
IN  HDEVINFO         DeviceInfoSet,
IN  LPCTSTR          DeviceInstanceId,
IN  HWND             hwndParent,       OPTIONAL
IN  DWORD            OpenFlags,
OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiOpenDeviceInfo( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData );

    return FALSE;
}

HDEVINFO WINAPI DIDummy_SetupDiCreateDeviceInfoList
(
IN LPGUID ClassGuid, OPTIONAL
IN HWND   hwndParent OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCreateDeviceInfoList( %08x, %08x )"),
                     ClassGuid, hwndParent );

    return INVALID_HANDLE_VALUE;
}

HKEY WINAPI DIDummy_SetupDiOpenDevRegKey
(
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData,
IN DWORD            Scope,
IN DWORD            HwProfile,
IN DWORD            KeyType,
IN REGSAM           samDesired
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiOpenDevRegKey( %08x, %08x, %u, %u, %u, %u )"),
                     DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, samDesired );

    return INVALID_HANDLE_VALUE;
}

////////////////////////////////////////
// hid.dll dummy functions
////////////////////////////////////////

void __stdcall DIDummy_HidD_GetHidGuid
(
OUT   LPGUID   HidGuid
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetHidGuid( %08x )"),
                     HidGuid );

    return;
}

BOOLEAN __stdcall DIDummy_HidD_GetPreparsedData
(
IN    HANDLE                  HidDeviceObject,
OUT   PHIDP_PREPARSED_DATA  * PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetPreparsedData( %08x, %08x )"),
                     HidDeviceObject, PreparsedData );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_FreePreparsedData
(
IN    PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_FreePreparsedData( %08x )"),
                     PreparsedData );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_FlushQueue  //unused
(
IN    HANDLE                HidDeviceObject
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_FlushQueue( %08x )"),
                     HidDeviceObject );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetAttributes
(
IN  HANDLE              HidDeviceObject,
OUT PHIDD_ATTRIBUTES    Attributes
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetAttributes( %08x, %08x )"),
                     HidDeviceObject, Attributes );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetFeature
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetFeature( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_SetFeature
(
IN    HANDLE   HidDeviceObject,
IN    PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_SetFeature( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetProductString
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    Buffer,
IN    ULONG    BufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetProductString( %08x, %08x, %u )"),
                     HidDeviceObject, Buffer, BufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetInputReport
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetProductString( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

NTSTATUS __stdcall DIDummy_HidP_GetCaps
(
IN      PHIDP_PREPARSED_DATA      PreparsedData,
OUT     PHIDP_CAPS                Capabilities
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetCaps( %08x, %08x )"),
                     PreparsedData, Capabilities );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetButtonCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetButtonCaps( %08x, %08x, %08x, %08x )"),
                     ReportType, ButtonCaps, ButtonCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetValueCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_VALUE_CAPS     ValueCaps,
IN OUT   PUSHORT              ValueCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetValueCaps( %08x, %08x, %08x, %08x )"),
                     ReportType, ValueCaps, ValueCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetLinkCollectionNodes
(
OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
IN OUT   PULONG                     LinkCollectionNodesLength,
IN       PHIDP_PREPARSED_DATA       PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetLinkCollectionNodes( %08x, %08x, %08x )"),
                     LinkCollectionNodes, LinkCollectionNodesLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

ULONG __stdcall DIDummy_HidP_MaxDataListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN PHIDP_PREPARSED_DATA  PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_MaxDataListLength( %08x, %08x )"),
                     ReportType, PreparsedData );

    return 0;
}

NTSTATUS __stdcall DIDummy_HidP_GetUsagesEx   //unused
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USHORT               LinkCollection,
OUT      PUSAGE_AND_PAGE      ButtonList,
IN OUT   ULONG *              UsageLength,
IN       PHIDP_PREPARSED_DATA PreparsedData,
IN       PCHAR                Report,
IN       ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetUsagesEx( %08x, %u, %08x, %08x, %08x, %08x, %u )"),
                     ReportType, LinkCollection, ButtonList, UsageLength, PreparsedData, Report, ReportLength );
	
    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetScaledUsageValue  //unused
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PLONG                UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetScaledUsageValue( %08x, %u, %u, %u, %08x, %08x, %08x, %u )"),
                     ReportType, UsagePage, LinkCollection, Usage, UsageValue, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetData
(
IN       HIDP_REPORT_TYPE      ReportType,
OUT      PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN       PCHAR                 Report,
IN       ULONG                 ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetData( %08x, %08x, $08x, %08x, %08x, %u )"),
                     ReportType, DataList, DataLength, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_SetData
(
IN       HIDP_REPORT_TYPE      ReportType,
IN       PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN OUT   PCHAR                 Report,
IN       ULONG                 ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_SetData( %08x, %08x, $08x, %08x, %08x, %u )"),
                     ReportType, DataList, DataLength, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetUsageValue
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PULONG               UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetUsageValue( %08x, %u, %u, %u, %08x, %08x, %08x, %u )"),
                     ReportType, UsagePage, LinkCollection, Usage, UsageValue, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

ULONG __stdcall DIDummy_HidP_MaxUsageListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN USAGE                 UsagePage,
IN PHIDP_PREPARSED_DATA  PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_MaxUsageListLength( %08x, %u, %08x )"),
                     ReportType, UsagePage, PreparsedData );

    return 0;
}

NTSTATUS __stdcall DIDummy_HidP_GetSpecificButtonCaps 
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USAGE                UsagePage,      
IN       USHORT               LinkCollection, 
IN       USAGE                Usage,          
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetSpecificButtonCaps( %08x, %u, %u, %u, %08x, %08x, %08x )"),
                     ReportType, UsagePage, LinkCollection, Usage, ButtonCaps, ButtonCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_TranslateUsagesToI8042ScanCodes
(
IN       PUSAGE               ChangedUsageList, // Those usages that changed
IN       ULONG                UsageListLength,
IN       HIDP_KEYBOARD_DIRECTION KeyAction,
IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
IN       PVOID                InsertCodesContext
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_TranslateUsagesToI8042ScanCodes( %08x, %u, %08x, %08x, %08x, %08x )"),
                     ChangedUsageList, UsageListLength, KeyAction, ModifierState, InsertCodesProcedure, InsertCodesContext );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

////////////////////////////////////////
// winmm.dll dummy functions
////////////////////////////////////////

MMRESULT WINAPI DIDummy_joyGetDevCaps
(
IN  UINT uJoyID,
OUT LPJOYCAPS pjc,
IN  UINT cbjc
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetDevCaps( %u, %08x, %u )"),
                     uJoyID, pjc, cbjc );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_joyGetPosEx
(
IN  UINT        uJoyID,
OUT LPJOYINFOEX pji
)
{   
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetPosEx( %u, %08x )"),
                     uJoyID, pji );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_joyGetPos
(
IN  UINT        uJoyID,
OUT LPJOYINFO   pji
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetPos( %u, %08x )"),
                     uJoyID, pji );

    return MMSYSERR_ERROR;
}

UINT WINAPI DIDummy_joyConfigChanged
(
IN DWORD dwFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyConfigChanged( %u )"),
                     dwFlags );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_mmioClose
( 
IN HMMIO hmmio, 
IN UINT fuClose
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioClose( %08x, %u )"),
                     hmmio, fuClose );
	
    return MMSYSERR_ERROR;
}

HMMIO WINAPI DIDummy_mmioOpenA
( 
IN OUT LPSTR pszFileName, 
IN OUT LPMMIOINFO pmmioinfo, 
IN DWORD fdwOpen
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioOpenA( %s, %08x, %u )"),
                     pszFileName, pmmioinfo, fdwOpen );

    return NULL;
}

MMRESULT WINAPI DIDummy_mmioDescend
( 
IN HMMIO hmmio, 
IN OUT LPMMCKINFO pmmcki, 
IN const MMCKINFO FAR* pmmckiParent, 
IN UINT fuDescend
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioDescend( %08x, %08x, %08x, %u )"),
                     hmmio, pmmcki, pmmckiParent, fuDescend );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_mmioCreateChunk
(
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuCreate
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioCreateChunk( %08x, %08x, %u )"),
                     hmmio, pmmcki, fuCreate );

    return MMSYSERR_ERROR;
}

LONG WINAPI DIDummy_mmioRead
( 
IN HMMIO hmmio, 
OUT HPSTR pch, 
IN LONG cch
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioRead( %08x, %08x, %u )"),
                     hmmio, pch, cch );
	
    return 0;
}

LONG WINAPI DIDummy_mmioWrite
( 
IN HMMIO hmmio, 
IN const char _huge* pch, 
IN LONG cch
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioWrite( %08x, %08x, %u )"),
                     hmmio, pch, cch );

    return 0;
}

MMRESULT WINAPI DIDummy_mmioAscend
( 
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuAscend
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioAscend( %08x, %08x, %u )"),
                     hmmio, pmmcki, fuAscend );
                           
    return MMSYSERR_ERROR;
}

////////////////////////////////////////
// user32.dll dummy functions
////////////////////////////////////////

#ifdef USE_WM_INPUT

BOOL WINAPI DIDummy_RegisterRawInputDevices
(
PCRAWINPUTDEVICE pRawInputDevices,
UINT uiNumDevices,
UINT cbSize
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_RegisterRawInputDevices( %08x, %u, %u )"),
                     pRawInputDevices, uiNumDevices, cbSize );
                           
    return FALSE;
}

UINT WINAPI DIDummy_GetRawInputData
(
HRAWINPUT   hRawInput,
UINT        uiCommand,
LPVOID      pData,
PUINT       pcbSize,
UINT        cbSizeHeader
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_GetRawInputData( %08x, %u, %08x, %08x, %u )"),
                     hRawInput, uiCommand, pData, pcbSize, cbSizeHeader );
                           
    return -1;
}

#endif //#ifdef USE_WM_INPUT

#endif /* STATIC_DLLUSAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diextdll.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       diextdll.h
 *  Content:    DirectInput internal include file for external DLL access
 *
 ***************************************************************************/

#ifndef _DIEXTDLL_H
#define _DIEXTDLL_H

/*****************************************************************************
 *
 *      diextdll.c - Imports from optional external DLLs
 *
 *      It is very important that HidD_GetHidGuid be the very last one.
 *
 *****************************************************************************/

    #ifdef STATIC_DLLUSAGE
        #define ExtDll_Init()
    #else
void EXTERNAL ExtDll_Init(void);
    #endif
void EXTERNAL ExtDll_Term(void);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct MANUALIMPORT |
 *
 *          Records a single manual import.  If it hasn't
 *          yet been resolved, then the <e MANUALIMPORT.ptsz>
 *          points to the procedure name.  If it has been resolved
 *          successfully, then <e MANUALIMPORT.pfn> points to
 *          the resolved address.  If it has not been resolved
 *          successfully, then <e MANUALIMPORT.pfn> is garbage.
 *
 *  @field  LPCSTR | psz |
 *
 *          Procdure name.  Note that this is always an ANSI string.
 *
 *  @field  FARPROC | pfn |
 *
 *          Procedure address.
 *
 *****************************************************************************/

typedef struct MANUALIMPORT
{
    FARPROC pfn;                    /* Procedure address */
} MANUALIMPORT, *PMANUALIMPORT;

#ifndef STATIC_DLLUSAGE

#ifndef WINNT
/*****************************************************************************
 *
 * CFGMGR32
 *
 *  Note that this must match the CFGMGR32 section in diextdll.c
 *
 *****************************************************************************/

typedef union CFGMGR32
{

    MANUALIMPORT rgmi[6];              /* number of functions we import */

    struct
    {
        CONFIGRET ( WINAPI * _CM_Get_Child)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Sibling)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  DevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Parent)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        OUT PULONG      pulRegDataType,   OPTIONAL
        OUT PVOID       Buffer,           OPTIONAL
        IN  OUT PULONG  pulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Set_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        IN  PVOID       Buffer,           OPTIONAL
        IN  ULONG       ulLength,
        IN  ULONG       ulFlags
        );
    
        CONFIGRET( WINAPI * _CM_Get_Device_ID)
        (
         IN  DEVINST  dnDevInst,
         OUT PTCHAR   Buffer,
         IN  ULONG    BufferLen,
         IN  ULONG    ulFlags
        );    

    };

} CFGMGR32, *PFGMGR32;

extern CFGMGR32 g_cfgmgr32;

        #undef CM_Get_Child
        #undef CM_Get_Sibling
        #undef CM_Get_Parent
        #undef CM_Get_DevNode_Registry_Property
        #undef CM_Set_DevNode_Registry_Property
        #undef CM_Get_Device_ID

        #define             CM_Get_Child                       \
        g_cfgmgr32._CM_Get_Child

        #define             CM_Get_Sibling                     \
        g_cfgmgr32._CM_Get_Sibling

        #define             CM_Get_Parent                      \
        g_cfgmgr32._CM_Get_Parent

        #define             CM_Get_DevNode_Registry_Property   \
        g_cfgmgr32._CM_Get_DevNode_Registry_Property

        #define             CM_Set_DevNode_Registry_Property    \
        g_cfgmgr32._CM_Set_DevNode_Registry_Property
        
        #define             CM_Get_Device_ID                    \
        g_cfgmgr32._CM_Get_Device_ID
#endif  //#ifndef WINNT

/*****************************************************************************
 *
 *  SETUPAPI
 *
 *  Note that this must match the SETUPAPI section in diextdll.c
 *
 *****************************************************************************/

typedef union SETUPAPI
{

  #ifdef WINNT
    MANUALIMPORT rgmi[18];              /* number of functions we import */
  #else
    MANUALIMPORT rgmi[12];              /* number of functions we import */
  #endif
    
    struct
    {

        HDEVINFO (WINAPI *_SetupDiGetClassDevs)
        (
        IN LPGUID ClassGuid,  OPTIONAL
        IN LPCTSTR Enumerator, OPTIONAL
        IN HWND   hwndParent, OPTIONAL
        IN DWORD  Flags
        );

        BOOL (WINAPI *_SetupDiDestroyDeviceInfoList)
        (
        IN HDEVINFO DeviceInfoSet
        );

        BOOL (WINAPI *_SetupDiGetDeviceInterfaceDetail)
        (
        IN  HDEVINFO                         DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA        pdid,
        OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
        IN  DWORD                            cbDidd,
        OUT PDWORD                           RequiredSize,  OPTIONAL
        OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
        );

        BOOL (WINAPI *_SetupDiEnumDeviceInterfaces)
        (
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
        IN  LPGUID                    InterfaceClassGuid,
        IN  DWORD                     MemberIndex,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
        );

        HKEY (WINAPI *_SetupDiCreateDeviceInterfaceRegKey)
        (
        IN HDEVINFO                  hdev,
        IN PSP_DEVICE_INTERFACE_DATA pdid,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired,
        IN HINF                      InfHandle,           OPTIONAL
        IN PCSTR                     InfSectionName       OPTIONAL
        );

        BOOL (WINAPI *_SetupDiCallClassInstaller)
        (
        IN DI_FUNCTION      InstallFunction,
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
        );

        BOOL (WINAPI *_SetupDiGetDeviceRegistryProperty)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  PSP_DEVINFO_DATA DeviceInfoData,
        IN  DWORD            Property,
        OUT PDWORD           PropertyRegDataType, OPTIONAL
        OUT PBYTE            PropertyBuffer,
        IN  DWORD            PropertyBufferSize,
        OUT PDWORD           RequiredSize         OPTIONAL
        );

        BOOL (WINAPI *_SetupDiSetDeviceRegistryProperty)
        (
        IN     HDEVINFO         DeviceInfoSet,
        IN OUT PSP_DEVINFO_DATA DeviceInfoData,
        IN     DWORD            Property,
        IN     CONST BYTE*      PropertyBuffer,
        IN     DWORD            PropertyBufferSize
        );

        BOOL (WINAPI *_SetupDiGetDeviceInstanceId)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  PSP_DEVINFO_DATA DeviceInfoData,
        OUT PTSTR            DeviceInstanceId,
        IN  DWORD            DeviceInstanceIdSize,
        OUT PDWORD           RequiredSize          OPTIONAL
        );

        BOOL (WINAPI *_SetupDiOpenDeviceInfo)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  LPCTSTR          DeviceInstanceId,
        IN  HWND             hwndParent,       OPTIONAL
        IN  DWORD            OpenFlags,
        OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
        );

        HDEVINFO (WINAPI *_SetupDiCreateDeviceInfoList)
        (
        IN LPGUID ClassGuid, OPTIONAL
        IN HWND   hwndParent OPTIONAL
        );

        HKEY (WINAPI *_SetupDiOpenDevRegKey)
        (
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData,
        IN DWORD            Scope,
        IN DWORD            HwProfile,
        IN DWORD            KeyType,
        IN REGSAM           samDesired
        );
        
      #ifdef WINNT
        CONFIGRET ( WINAPI * _CM_Get_Child)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Sibling)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  DevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Parent)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        OUT PULONG      pulRegDataType,   OPTIONAL
        OUT PVOID       Buffer,           OPTIONAL
        IN  OUT PULONG  pulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Set_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        IN  PVOID       Buffer,           OPTIONAL
        IN  ULONG       ulLength,
        IN  ULONG       ulFlags
        );
    
        CONFIGRET( WINAPI * _CM_Get_Device_ID)
        (
         IN  DEVINST  dnDevInst,
         OUT PTCHAR   Buffer,
         IN  ULONG    BufferLen,
         IN  ULONG    ulFlags
        );    
        
      #endif

    };
} SETUPAPI, *PSETUPAPI;

extern SETUPAPI g_setupapi;

        #undef SetupDiGetClassDevs
        #undef SetupDiDestroyDeviceInfoList
        #undef SetupDiGetDeviceInterfaceDetail
        #undef SetupDiEnumDeviceInterfaces
        #undef SetupDiCreateDeviceInterfaceRegKey
        #undef SetupDiCallClassInstaller
        #undef SetupDiGetDeviceRegistryProperty
        #undef SetupDiSetDeviceRegistryProperty
        #undef SetupDiGetDeviceInstanceId
        #undef SetupDiOpenDeviceInfo
        #undef SetupDiCreateDeviceInfoList
        #undef SetupDiOpenDevRegKey

        #define             SetupDiGetClassDevs                 \
        g_setupapi._SetupDiGetClassDevs

        #define             SetupDiDestroyDeviceInfoList        \
        g_setupapi._SetupDiDestroyDeviceInfoList

        #define             SetupDiGetDeviceInterfaceDetail     \
        g_setupapi._SetupDiGetDeviceInterfaceDetail

        #define             SetupDiEnumDeviceInterfaces         \
        g_setupapi._SetupDiEnumDeviceInterfaces

        #define             SetupDiCreateDeviceInterfaceRegKey  \
        g_setupapi._SetupDiCreateDeviceInterfaceRegKey

        #define             SetupDiCallClassInstaller           \
        g_setupapi._SetupDiCallClassInstaller

        #define             SetupDiGetDeviceRegistryProperty    \
        g_setupapi._SetupDiGetDeviceRegistryProperty

        #define             SetupDiSetDeviceRegistryProperty    \
        g_setupapi._SetupDiSetDeviceRegistryProperty

        #define             SetupDiGetDeviceInstanceId          \
        g_setupapi._SetupDiGetDeviceInstanceId

        #define             SetupDiOpenDeviceInfo               \
        g_setupapi._SetupDiOpenDeviceInfo

        #define             SetupDiCreateDeviceInfoList         \
        g_setupapi._SetupDiCreateDeviceInfoList

        #define             SetupDiOpenDevRegKey                \
        g_setupapi._SetupDiOpenDevRegKey

      #ifdef WINNT
        #undef CM_Get_Child
        #undef CM_Get_Sibling
        #undef CM_Get_Parent
        #undef CM_Get_DevNode_Registry_Property
        #undef CM_Set_DevNode_Registry_Property
        #undef CM_Get_Device_ID

        #define             CM_Get_Child                        \
        g_setupapi._CM_Get_Child

        #define             CM_Get_Sibling                      \
        g_setupapi._CM_Get_Sibling

        #define             CM_Get_Parent                       \
        g_setupapi._CM_Get_Parent

        #define             CM_Get_DevNode_Registry_Property    \
        g_setupapi._CM_Get_DevNode_Registry_Property

        #define             CM_Set_DevNode_Registry_Property    \
        g_setupapi._CM_Set_DevNode_Registry_Property
        
        #define             CM_Get_Device_ID                   \
        g_setupapi._CM_Get_Device_ID
      #endif

/*****************************************************************************
 *
 *  HIDDLL
 *
 *  Note that this must match the HID section in diextdll.c
 *
 *****************************************************************************/

typedef union HIDDLL
{

    MANUALIMPORT rgmi[22];              /* number of functions we import */

    struct
    {
        void (__stdcall *_HidD_GetHidGuid)
        (
        OUT   LPGUID   HidGuid
        );

        BOOLEAN (__stdcall *_HidD_GetPreparsedData)
        (
        IN    HANDLE                  HidDeviceObject,
        OUT   PHIDP_PREPARSED_DATA  * PreparsedData
        );

        BOOLEAN (__stdcall *_HidD_FreePreparsedData)
        (
        IN    PHIDP_PREPARSED_DATA PreparsedData
        );

        BOOLEAN (__stdcall *_HidD_FlushQueue)
        (
        IN    HANDLE                HidDeviceObject
        );

        BOOLEAN (__stdcall *_HidD_GetAttributes)
        (
        IN  HANDLE              HidDeviceObject,
        OUT PHIDD_ATTRIBUTES    Attributes
        );

        BOOLEAN (__stdcall *_HidD_GetFeature)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        BOOLEAN (__stdcall *_HidD_SetFeature)
        (
        IN    HANDLE   HidDeviceObject,
        IN    PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        BOOLEAN (__stdcall *_HidD_GetProductString)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    Buffer,
        IN    ULONG    BufferLength
        );

        BOOLEAN (__stdcall *_HidD_GetInputReport)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        NTSTATUS (__stdcall *_HidP_GetCaps)
        (
        IN      PHIDP_PREPARSED_DATA      PreparsedData,
        OUT     PHIDP_CAPS                Capabilities
        );

        NTSTATUS (__stdcall *_HidP_GetButtonCaps)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
        IN OUT   PUSHORT              ButtonCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetValueCaps)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        OUT      PHIDP_VALUE_CAPS     ValueCaps,
        IN OUT   PUSHORT              ValueCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetLinkCollectionNodes)
        (
        OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
        IN OUT   PULONG                     LinkCollectionNodesLength,
        IN       PHIDP_PREPARSED_DATA       PreparsedData
        );

        ULONG (__stdcall *_HidP_MaxDataListLength)
        (
        IN HIDP_REPORT_TYPE      ReportType,
        IN PHIDP_PREPARSED_DATA  PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetUsagesEx)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        IN       USHORT               LinkCollection,
        OUT      PUSAGE_AND_PAGE      ButtonList,
        IN OUT   ULONG *              UsageLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData,
        IN       PCHAR                Report,
        IN       ULONG                ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetScaledUsageValue)
        (
        IN    HIDP_REPORT_TYPE     ReportType,
        IN    USAGE                UsagePage,
        IN    USHORT               LinkCollection,
        IN    USAGE                Usage,
        OUT   PLONG                UsageValue,
        IN    PHIDP_PREPARSED_DATA PreparsedData,
        IN    PCHAR                Report,
        IN    ULONG                ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetData)
        (
        IN       HIDP_REPORT_TYPE      ReportType,
        OUT      PHIDP_DATA            DataList,
        IN OUT   PULONG                DataLength,
        IN       PHIDP_PREPARSED_DATA  PreparsedData,
        IN       PCHAR                 Report,
        IN       ULONG                 ReportLength
        );

        NTSTATUS (__stdcall *_HidP_SetData)
        (
        IN       HIDP_REPORT_TYPE      ReportType,
        IN       PHIDP_DATA            DataList,
        IN OUT   PULONG                DataLength,
        IN       PHIDP_PREPARSED_DATA  PreparsedData,
        IN OUT   PCHAR                 Report,
        IN       ULONG                 ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetUsageValue)
        (
        IN    HIDP_REPORT_TYPE     ReportType,
        IN    USAGE                UsagePage,
        IN    USHORT               LinkCollection,
        IN    USAGE                Usage,
        OUT   PULONG               UsageValue,
        IN    PHIDP_PREPARSED_DATA PreparsedData,
        IN    PCHAR                Report,
        IN    ULONG                ReportLength
        );

        ULONG (__stdcall *_HidP_MaxUsageListLength)
        (
        IN HIDP_REPORT_TYPE      ReportType,
        IN USAGE                 UsagePage,
        IN PHIDP_PREPARSED_DATA  PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetSpecificButtonCaps) 
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        IN       USAGE                UsagePage,      // Optional (0 => ignore)
        IN       USHORT               LinkCollection, // Optional (0 => ignore)
        IN       USAGE                Usage,          // Optional (0 => ignore)
        OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
        IN OUT   PUSHORT              ButtonCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_TranslateUsagesToI8042ScanCodes)
        (
        IN       PUSAGE               ChangedUsageList, // Those usages that changed
        IN       ULONG                UsageListLength,
        IN       HIDP_KEYBOARD_DIRECTION KeyAction,
        IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
        IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
        IN       PVOID                InsertCodesContext
        );

    };

} HIDDLL, *PHIDDLL;

extern HIDDLL g_hiddll;

        #undef HidD_GetHidGuid
        #undef HidD_GetPreparsedData
        #undef HidD_FreePreparsedData
        #undef HidD_FlushQueue
        #undef HidD_GetAttributes
        #undef HidD_GetFeature
        #undef HidD_SetFeature
        #undef HidD_GetProductString
        #undef HidD_GetInputReport
        #undef HidP_GetCaps
        #undef HidP_GetButtonCaps
        #undef HidP_GetValueCaps
        #undef HidP_GetLinkCollectionNodes
        #undef HidP_MaxDataListLength
        #undef HidP_GetUsagesEx
        #undef HidP_GetScaledUsageValue
        #undef HidP_GetData
        #undef HidP_SetData
        #undef HidP_GetUsageValue
        #undef HidP_MaxUsageListLength
        #undef HidP_GetSpecificButtonCaps
        #undef HidP_TranslateUsagesToI8042ScanCodes

        #define           HidD_GetHidGuid                       \
        g_hiddll._HidD_GetHidGuid

        #define           HidD_GetPreparsedData                 \
        g_hiddll._HidD_GetPreparsedData

        #define           HidD_FreePreparsedData                \
        g_hiddll._HidD_FreePreparsedData

        #define           HidD_FlushQueue                       \
        g_hiddll._HidD_FlushQueue

        #define           HidD_GetAttributes                    \
        g_hiddll._HidD_GetAttributes                    \

        #define           HidD_GetFeature                       \
        g_hiddll._HidD_GetFeature                       \

        #define           HidD_SetFeature                       \
        g_hiddll._HidD_SetFeature                       \

        #define           HidD_GetProductString                 \
        g_hiddll._HidD_GetProductString                 \

        #define           HidD_GetInputReport                   \
        g_hiddll._HidD_GetInputReport                   \

        #define           HidP_GetCaps                          \
        g_hiddll._HidP_GetCaps

        #define           HidP_GetButtonCaps                    \
        g_hiddll._HidP_GetButtonCaps

        #define           HidP_GetValueCaps                     \
        g_hiddll._HidP_GetValueCaps

        #define           HidP_GetLinkCollectionNodes           \
        g_hiddll._HidP_GetLinkCollectionNodes

        #define           HidP_MaxDataListLength                \
        g_hiddll._HidP_MaxDataListLength                \

        #define           HidP_GetUsagesEx                      \
        g_hiddll._HidP_GetUsagesEx                      \

        #define           HidP_GetScaledUsageValue              \
        g_hiddll._HidP_GetScaledUsageValue              \

        #define           HidP_GetData                          \
        g_hiddll._HidP_GetData                          \

        #define           HidP_SetData                          \
        g_hiddll._HidP_SetData                          \

        #define           HidP_GetUsageValue                    \
        g_hiddll._HidP_GetUsageValue                    \

        #define           HidP_MaxUsageListLength               \
        g_hiddll._HidP_MaxUsageListLength               \

        #define           HidP_GetSpecificButtonCaps            \
        g_hiddll._HidP_GetSpecificButtonCaps            \

        #define           HidP_TranslateUsagesToI8042ScanCodes  \
        g_hiddll._HidP_TranslateUsagesToI8042ScanCodes  \

/*****************************************************************************
 *
 * WINMMDLL
 *
 *  Note that this must match the WINMM section in diextdll.c
 *
 *****************************************************************************/

typedef union WINMMDLL
{
    MANUALIMPORT rgmi[11];             /* number of functions we import */

    struct
    {
        MMRESULT ( WINAPI * _joyGetDevCaps)
        (
        IN  UINT uJoyID,
        OUT LPJOYCAPS pjc,
        IN  UINT cbjc
        );

        MMRESULT ( WINAPI * _joyGetPosEx)
        (
        IN  UINT        uJoyID,
        OUT LPJOYINFOEX pji
        );

        MMRESULT ( WINAPI * _joyGetPos)
        (
        IN  UINT        uJoyID,
        OUT LPJOYINFO   pji
        );

        UINT ( WINAPI * _joyConfigChanged)
        (
        IN DWORD dwFlags
        );

        MMRESULT ( WINAPI * _mmioClose )
        ( 
        IN HMMIO hmmio, 
        IN UINT fuClose
        );

        HMMIO ( WINAPI * _mmioOpenA )
        ( 
        IN OUT LPSTR pszFileName, 
        IN OUT LPMMIOINFO pmmioinfo, 
        IN DWORD fdwOpen
        );

        MMRESULT ( WINAPI * _mmioDescend )
        ( 
        IN HMMIO hmmio, 
        IN OUT LPMMCKINFO pmmcki, 
        IN const MMCKINFO FAR* pmmckiParent, 
        IN UINT fuDescend
        );

        MMRESULT ( WINAPI * _mmioCreateChunk )
        (
        IN HMMIO hmmio, 
        IN LPMMCKINFO pmmcki, 
        IN UINT fuCreate
        );

        LONG ( WINAPI * _mmioRead )
        ( 
        IN HMMIO hmmio, 
        OUT HPSTR pch, 
        IN LONG cch
        );

        LONG ( WINAPI * _mmioWrite )
        ( 
        IN HMMIO hmmio, 
        IN const char _huge* pch, 
        IN LONG cch
        );

        MMRESULT ( WINAPI * _mmioAscend )
        ( 
        IN HMMIO hmmio, 
        IN LPMMCKINFO pmmcki, 
        IN UINT fuAscend
        );
    };

} WINMMDLL, *PWINMMDLL;

extern WINMMDLL g_winmmdll;

        #undef joyGetDevCaps
        #undef joyGetPosEx
        #undef joyGetPos
        #undef joyConfigChanged
        #undef mmioClose
        #undef mmioOpenA
        #undef mmioDescend
        #undef mmioCreateChunk
        #undef mmioRead
        #undef mmioWrite
        #undef mmioAscend

        #define             joyGetDevCaps                  \
        g_winmmdll._joyGetDevCaps

        #define             joyGetPosEx                    \
        g_winmmdll._joyGetPosEx

        #define             joyGetPos                      \
        g_winmmdll._joyGetPos

        #define             joyConfigChanged               \
        g_winmmdll._joyConfigChanged

        #define             mmioClose                      \
        g_winmmdll._mmioClose

        #define             mmioOpenA                      \
        g_winmmdll._mmioOpenA

        #define             mmioDescend                    \
        g_winmmdll._mmioDescend

        #define             mmioCreateChunk                \
        g_winmmdll._mmioCreateChunk

        #define             mmioRead                       \
        g_winmmdll._mmioRead

        #define             mmioWrite                      \
        g_winmmdll._mmioWrite

        #define             mmioAscend                     \
        g_winmmdll._mmioAscend


/*****************************************************************************
 *
 * USER32
 *
 *  Note that this must match the USER32 section in diextdll.c
 *
 *****************************************************************************/

#ifdef USE_WM_INPUT

typedef union USER32
{

    MANUALIMPORT rgmi[2];              /* number of functions we import */

    struct
    {
        BOOL ( WINAPI * _RegisterRawInputDevices)
        (
        PCRAWINPUTDEVICE pRawInputDevices,
        UINT             uiNumDevices,
        UINT             cbSize
        );

        UINT ( WINAPI * _GetRawInputData)
        (
        HRAWINPUT   hRawInput,
        UINT        uiCommand,
        LPVOID      pData,
        PUINT       pcbSize,
        UINT        cbSizeHeader
        );
    };

} USER32, *PUSER32;

extern USER32 g_user32;

        #undef RegisterRawInputDevices
        #undef GetRawInputData

        #define             RegisterRawInputDevices        \
        g_user32._RegisterRawInputDevices

        #define             GetRawInputData                \
        g_user32._GetRawInputData

#endif

/*****************************************************************************
 *
 * Dummy functions
 *
 *   These functions are used only when some DLLs can't be loaded.
 *
 *****************************************************************************/

//cfgmgr32.dll 

CONFIGRET WINAPI DIDummy_CM_Get_Child
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Sibling
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  DevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Parent
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
OUT PULONG      pulRegDataType,   OPTIONAL
OUT PVOID       Buffer,           OPTIONAL
IN  OUT PULONG  pulLength,
IN  ULONG       ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Set_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
IN  PVOID       Buffer,           OPTIONAL
IN  ULONG       ulLength,
IN  ULONG       ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Device_ID
(
 IN  DEVINST  dnDevInst,
 OUT PTCHAR   Buffer,
 IN  ULONG    BufferLen,
 IN  ULONG    ulFlags
);

//Setupapi.dll

HDEVINFO WINAPI DIDummy_SetupDiGetClassDevs
(
IN LPGUID ClassGuid,  OPTIONAL
IN LPCTSTR Enumerator, OPTIONAL
IN HWND   hwndParent, OPTIONAL
IN DWORD  Flags
);

BOOL WINAPI DIDummy_SetupDiDestroyDeviceInfoList
(
IN HDEVINFO DeviceInfoSet
);

BOOL WINAPI DIDummy_SetupDiGetDeviceInterfaceDetail
(
IN  HDEVINFO                         DeviceInfoSet,
IN  PSP_DEVICE_INTERFACE_DATA        pdid,
OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
IN  DWORD                            cbDidd,
OUT PDWORD                           RequiredSize,  OPTIONAL
OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiEnumDeviceInterfaces
(
IN  HDEVINFO                  DeviceInfoSet,
IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
IN  LPGUID                    InterfaceClassGuid,
IN  DWORD                     MemberIndex,
OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
);

HKEY WINAPI DIDummy_SetupDiCreateDeviceInterfaceRegKey
(
IN HDEVINFO                  hdev,
IN PSP_DEVICE_INTERFACE_DATA pdid,
IN DWORD                     Reserved,
IN REGSAM                    samDesired,
IN HINF                      InfHandle,           OPTIONAL
IN PCSTR                     InfSectionName       OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiCallClassInstaller
(
IN DI_FUNCTION      InstallFunction,
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiGetDeviceRegistryProperty
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
IN  DWORD            Property,
OUT PDWORD           PropertyRegDataType, OPTIONAL
OUT PBYTE            PropertyBuffer,
IN  DWORD            PropertyBufferSize,
OUT PDWORD           RequiredSize         OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiSetDeviceRegistryProperty
(
IN     HDEVINFO         DeviceInfoSet,
IN OUT PSP_DEVINFO_DATA DeviceInfoData,
IN     DWORD            Property,
IN     CONST BYTE*      PropertyBuffer,
IN     DWORD            PropertyBufferSize
);

BOOL WINAPI DIDummy_SetupDiGetDeviceInstanceId
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
OUT PTSTR            DeviceInstanceId,
IN  DWORD            DeviceInstanceIdSize,
OUT PDWORD           RequiredSize          OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiOpenDeviceInfo
(
IN  HDEVINFO         DeviceInfoSet,
IN  LPCTSTR          DeviceInstanceId,
IN  HWND             hwndParent,       OPTIONAL
IN  DWORD            OpenFlags,
OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
);

HDEVINFO WINAPI DIDummy_SetupDiCreateDeviceInfoList
(
IN LPGUID ClassGuid, OPTIONAL
IN HWND   hwndParent OPTIONAL
);

HKEY WINAPI DIDummy_SetupDiOpenDevRegKey
(
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData,
IN DWORD            Scope,
IN DWORD            HwProfile,
IN DWORD            KeyType,
IN REGSAM           samDesired
);

// hid.dll

void __stdcall DIDummy_HidD_GetHidGuid
(
OUT   LPGUID   HidGuid
);

BOOLEAN __stdcall DIDummy_HidD_GetPreparsedData
(
IN    HANDLE                  HidDeviceObject,
OUT   PHIDP_PREPARSED_DATA  * PreparsedData
);

BOOLEAN __stdcall DIDummy_HidD_FreePreparsedData
(
IN    PHIDP_PREPARSED_DATA PreparsedData
);

BOOLEAN __stdcall DIDummy_HidD_FlushQueue
(
IN    HANDLE                HidDeviceObject
);

BOOLEAN __stdcall DIDummy_HidD_GetAttributes
(
IN  HANDLE              HidDeviceObject,
OUT PHIDD_ATTRIBUTES    Attributes
);

BOOLEAN __stdcall DIDummy_HidD_GetFeature
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

BOOLEAN __stdcall DIDummy_HidD_SetFeature
(
IN    HANDLE   HidDeviceObject,
IN    PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

BOOLEAN __stdcall DIDummy_HidD_GetProductString
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    Buffer,
IN    ULONG    BufferLength
);

BOOLEAN __stdcall DIDummy_HidD_GetInputReport
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

NTSTATUS __stdcall DIDummy_HidP_GetCaps
(
IN      PHIDP_PREPARSED_DATA      PreparsedData,
OUT     PHIDP_CAPS                Capabilities
);

NTSTATUS __stdcall DIDummy_HidP_GetButtonCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetValueCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_VALUE_CAPS     ValueCaps,
IN OUT   PUSHORT              ValueCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetLinkCollectionNodes
(
OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
IN OUT   PULONG                     LinkCollectionNodesLength,
IN       PHIDP_PREPARSED_DATA       PreparsedData
);

ULONG __stdcall DIDummy_HidP_MaxDataListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN PHIDP_PREPARSED_DATA  PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetUsagesEx   //unused
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USHORT               LinkCollection,
OUT      PUSAGE_AND_PAGE      ButtonList,
IN OUT   ULONG *              UsageLength,
IN       PHIDP_PREPARSED_DATA PreparsedData,
IN       PCHAR                Report,
IN       ULONG                ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetScaledUsageValue  //unused
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PLONG                UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetData
(
IN       HIDP_REPORT_TYPE      ReportType,
OUT      PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN       PCHAR                 Report,
IN       ULONG                 ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_SetData
(
IN       HIDP_REPORT_TYPE      ReportType,
IN       PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN OUT   PCHAR                 Report,
IN       ULONG                 ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetUsageValue
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PULONG               UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
);

ULONG __stdcall DIDummy_HidP_MaxUsageListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN USAGE                 UsagePage,
IN PHIDP_PREPARSED_DATA  PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetSpecificButtonCaps 
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USAGE                UsagePage,      
IN       USHORT               LinkCollection, 
IN       USAGE                Usage,          
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_TranslateUsagesToI8042ScanCodes
(
IN       PUSAGE               ChangedUsageList, // Those usages that changed
IN       ULONG                UsageListLength,
IN       HIDP_KEYBOARD_DIRECTION KeyAction,
IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
IN       PVOID                InsertCodesContext
);

// winmm.dll

MMRESULT WINAPI DIDummy_joyGetDevCaps
(
IN  UINT uJoyID,
OUT LPJOYCAPS pjc,
IN  UINT cbjc
);

MMRESULT WINAPI DIDummy_joyGetPosEx
(
IN  UINT        uJoyID,
OUT LPJOYINFOEX pji
);

MMRESULT WINAPI DIDummy_joyGetPos
(
IN  UINT        uJoyID,
OUT LPJOYINFO   pji
);

UINT WINAPI DIDummy_joyConfigChanged
(
IN DWORD dwFlags
);

MMRESULT WINAPI DIDummy_mmioClose 
( 
IN HMMIO hmmio, 
IN UINT fuClose
);

HMMIO WINAPI DIDummy_mmioOpenA 
( 
IN OUT LPSTR pszFileName, 
IN OUT LPMMIOINFO pmmioinfo, 
IN DWORD fdwOpen
);

MMRESULT WINAPI DIDummy_mmioDescend 
( 
IN HMMIO hmmio, 
IN OUT LPMMCKINFO pmmcki, 
IN const MMCKINFO FAR* pmmckiParent, 
IN UINT fuDescend
);

MMRESULT WINAPI DIDummy_mmioCreateChunk 
(
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuCreate
);

LONG WINAPI DIDummy_mmioRead 
( 
IN HMMIO hmmio, 
OUT HPSTR pch, 
IN LONG cch
);

LONG WINAPI DIDummy_mmioWrite 
( 
IN HMMIO hmmio, 
IN const char _huge* pch, 
IN LONG cch
);

MMRESULT WINAPI DIDummy_mmioAscend 
( 
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuAscend
);

// user32.dll

#ifdef USE_WM_INPUT

BOOL WINAPI DIDummy_RegisterRawInputDevices
(
PCRAWINPUTDEVICE pRawInputDevices,
UINT uiNumDevices,
UINT cbSize
);

UINT WINAPI DIDummy_GetRawInputData
(
HRAWINPUT   hRawInput,
UINT        uiCommand,
LPVOID      pData,
PUINT       pcbSize,
UINT        cbSizeHeader
);

#endif // #ifdef USE_WM_INPUT

#endif /* STATIC_DLLUSAGE */

#endif /* _DIEXTDLL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\digenj.c ===
/*****************************************************************************
 *
 *  DIGenJ.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for joystick.
 *
 *  Contents:
 *
 *      CJoy_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifndef WINNT

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoy

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoy_New!
 *
 *****************************************************************************/

Primary_Interface(CJoy, IDirectInputDeviceCallback);

/*****************************************************************************
 *
 *      Macro "lookup tables".
 *
 *      iJoyStateAxis# converts an axis name to an axis number in the
 *      DIJOYSTATE structure.
 *
 *      ibJoyStateAxis# converts the name to an offset.
 *
 *      Note that the extra axes in DIJOYSTATE2 are arranged in relative
 *      positions just like a DIJOYSTATE.  We will exploit this
 *      arrangement frequently.
 *
 *****************************************************************************/

#define iJoyStateAxisX      0
#define iJoyStateAxisY      1
#define iJoyStateAxisZ      2
#define iJoyStateAxisRx     3
#define iJoyStateAxisRy     4
#define iJoyStateAxisRz     5
#define iJoyStateAxisS0     6
#define iJoyStateAxisS1     7
#define cJoyStateAxisMax    8

#define iJoyStateAxisSlider iJoyStateAxisS0     /* Hack for macros */

#define cJoyStateAxis       8

#define iobjPositions       (cJoyStateAxis * 0)
#define iobjVelocities      (cJoyStateAxis * 1)
#define iobjAccels          (cJoyStateAxis * 2)
#define iobjForces          (cJoyStateAxis * 3)

#define cJoyStateAxisTotal  (cJoyStateAxis * 4)

#define ibJoyStateAxisX      (iJoyStateAxisX  * cbX(LONG))
#define ibJoyStateAxisY      (iJoyStateAxisY  * cbX(LONG))
#define ibJoyStateAxisZ      (iJoyStateAxisZ  * cbX(LONG))
#define ibJoyStateAxisRx     (iJoyStateAxisRx * cbX(LONG))
#define ibJoyStateAxisRy     (iJoyStateAxisRy * cbX(LONG))
#define ibJoyStateAxisRz     (iJoyStateAxisRz * cbX(LONG))
#define ibJoyStateAxisS0     (iJoyStateAxisS0 * cbX(LONG))
#define ibJoyStateAxisS1     (iJoyStateAxisS1 * cbX(LONG))

#define ibJoyStateAxisSlider ibJoyStateAxisS0    /* Hack for macros */

#define cJoyStatePOVTotal   4
#define cJoyStateButtonTotal 128

#define cJoyStateObjTotal   (cJoyStateAxisTotal + \
                             cJoyStatePOVTotal + \
                             cJoyStateButtonTotal)

/*
 *  The worst-case data format for joysticks.  (Christmas-tree)
 */
VXDAXISCAPS c_vacMax = {
    JOYPF_ALLCAPS | JOYPF_POSITION,         /*  dwPos   */
    JOYPF_ALLCAPS | JOYPF_VELOCITY,         /*  dwVel   */
    JOYPF_ALLCAPS | JOYPF_ACCELERATION,     /*  dwAccel */
    JOYPF_ALLCAPS | JOYPF_FORCE,            /*  dwForce */
};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | ibJoyStateAxisFromPosAxis |
 *
 *          Returns the offset of the <p iPosAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYPOS> axis.
 *          X, Y, Z, R, U and V are respectively zero through five.
 *
 *          Remember that we map R to Rz, U to Slider0 and V to Slider1.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgibJoyStateAxisFromPosAxis[6] = {
    FIELD_OFFSET(DIJOYSTATE, lX),           /* X */
    FIELD_OFFSET(DIJOYSTATE, lY),           /* Y */
    FIELD_OFFSET(DIJOYSTATE, lZ),           /* Z */
    FIELD_OFFSET(DIJOYSTATE, lRz),          /* R */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[0]), /* U */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[1]), /* V */
};

UINT INLINE
ibJoyStateAxisFromPosAxis(UINT uiPosAxis)
{
    AssertF(uiPosAxis < cA(c_rgibJoyStateAxisFromPosAxis));
    return c_rgibJoyStateAxisFromPosAxis[uiPosAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | iJoyStateAxisFromPosAxis |
 *
 *          Returns the index of the <p iPosAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYPOS> axis.
 *          X, Y, Z, R, U and V are respectively zero through five.
 *
 *          Remember that we map R to Rz, U to Slider0 and V to Slider1.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgiJoyStateAxisFromPosAxis[6] = {
    iJoyStateAxisX,             /* X */
    iJoyStateAxisY,             /* Y */
    iJoyStateAxisZ,             /* Z */
    iJoyStateAxisRz,            /* R */
    iJoyStateAxisS0,            /* U */
    iJoyStateAxisS1,            /* V */
};

UINT INLINE
iJoyStateAxisFromPosAxis(UINT uiPosAxis)
{
    AssertF(uiPosAxis < cA(c_rgiJoyStateAxisFromPosAxis));
    return c_rgiJoyStateAxisFromPosAxis[uiPosAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | ibJoyStateAxisFromStateAxis |
 *
 *          Returns the offset of the <p iStateAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYSTATE> axis.
 *          The first eight axes live at the top, and the
 *          later ones (corresponding to velocity, etc.)
 *          live down at the bottom.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgibJoyStateAxisFromStateAxis[cJoyStateAxisMax] = {
    FIELD_OFFSET(DIJOYSTATE, lX),           /* X  */
    FIELD_OFFSET(DIJOYSTATE, lY),           /* Y  */
    FIELD_OFFSET(DIJOYSTATE, lZ),           /* Z  */
    FIELD_OFFSET(DIJOYSTATE, lRx),          /* Rx */
    FIELD_OFFSET(DIJOYSTATE, lRy),          /* Ry */
    FIELD_OFFSET(DIJOYSTATE, lRz),          /* Rz */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[0]), /* S0 */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[1]), /* S1 */
};

UINT INLINE
ibJoyStateAxisFromStateAxis(UINT uiStateAxis)
{
    AssertF(uiStateAxis < cA(c_rgibJoyStateAxisFromStateAxis));
    return c_rgibJoyStateAxisFromStateAxis[uiStateAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | iJoyPosAxisFromStateAxis |
 *
 *          Convert a <t DIJOYSTATE> axis number back to
 *          a <t JOYPOS> axis number.
 *
 *  @parm   UINT | uiPosAxis |
 *
 *          The index of the requested <t JOYSTATE> axis.
 *
 *  @returns
 *
 *          The corresponding <t JOYPOS> axis number.
 *
 *****************************************************************************/

const int c_rgiJoyPosAxisFromStateAxis[8] = {
    iJoyPosAxisX,               /* X    */
    iJoyPosAxisY,               /* Y    */
    iJoyPosAxisZ,               /* Z    */
    -1,                         /* Rx   */
    -1,                         /* Ry   */
    iJoyPosAxisR,               /* Rz   */
    iJoyPosAxisU,               /* S0   */
    iJoyPosAxisV,               /* S1   */
};

UINT INLINE
iJoyPosAxisFromStateAxis(UINT uiStateAxis)
{
    AssertF(uiStateAxis < cA(c_rgiJoyPosAxisFromStateAxis));
    return c_rgiJoyPosAxisFromStateAxis[uiStateAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  Cooking Joystick Data |
 *
 *          We always fetch joystick data raw, then cook it before
 *          returning it to the application.
 *
 *          If the app is in "raw" mode, then we don't cook anything.
 *
 *          If the app is in "cooked" mode, then things get interesting.
 *
 *          If there is `centered' cooking, then the center point of the
 *          joystick is reported in the center of the virtual range.
 *
 *
 *          Joystick properties work like this:
 *
 *          <c DIPROP_BUFFERSIZE> - No special semantics.
 *
 *          <c DIPROP_CALIBRATIONMODE> - Specifies whether
 *          cooked or raw data should be returned.  If raw data
 *          is requested, then most other properties have no effect.
 *
 *          The default is cooked.
 *
 *          <c DIPROP_GRANULARITY> - No special semantics.
 *
 *          <c DIPROP_RANGE> - This returns the range of values that
 *          can be returned by the axis.  For joysticks, this is a
 *          read/write property.  (For most devices, it is a read-only
 *          property.)  If you change the property, it affects only
 *          your device instance; it does not affect the ranges of other
 *          devices.
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *          We also define a few new properties:
 *
 *          <c DIPROP_CENTER> - This returns the joystick center (neutral)
 *          position.  In other words, this is the position that
 *          DirectInput returns when the user has released the joystick
 *          and allowed it to self-center.
 *          When a joystick device is created, the center position is
 *          initially set to midway between the lower and
 *          upper bounds of the range.  An application may change the
 *          center position (although I don't see any reason why).
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *          <c DIPROP_DEADZONE> - This returns the size of the joystick
 *          dead zone, as a percentage of total range.
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoy |
 *
 *          The <i IDirectInputDeviceCallback> object for the
 *          generic joystick.
 *
 *  @field  IDirectInputDeviceCallback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PDIJOYSTATE2 | pjsPhys |
 *
 *          Pointer to physical joystick status information kept down in the
 *          VxD.
 *
 *  @field  UINT | idJoy |
 *
 *          Joystick identifier for <f joyGetPosEx> and friends.
 *
 *  @field  DWORD | dwPOVGranularity |
 *
 *          Granularity of the POV control.
 *
 *  @field  HWND | hwnd |
 *
 *          The window which we have subclassed in order to watch
 *          for joystick reconfiguration messages.
 *
 *  @field  HKEY | hkType |
 *
 *          The joystick type key opened with <c MAXIMUM_ALLOWED> access.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *  @field  DIDEVCAPS | dc |
 *
 *          Device capability information.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          joystick type.
 *
 *  @field  JOYRANGECONVERT | rgjrc |
 *
 *          Range conversion structures for each axis.
 *
 *  @field  DIJOYCONFIG | cfg |
 *
 *          Joystick configuration information.
 *
 *  @field  DIJOYTYPEINFO | typi |
 *
 *          Joystick type information.
 *
 *  @field  PDIDOBJDEFSEM | rgObjSem |
 *
 *          Pointer to array of semantics mapped to this device, 
 *          calculated during init.  
 *
 *  @field  DWORD | dwVersion |
 *
 *          DirectInput version requested by application
 *
 *  @field  DIAPPHACKS | diHacks |
 *
 *          Application hack flags
 *
 *  @field HKEY | hkProp |
 *
 *          Extended properties for device type. Currently we keep 
 *          OEMMapFile under this key. 
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CJoy {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    LPDIJOYSTATE2 pjsPhys;

    UINT idJoy;
    DWORD dwPOVGranularity;

    HWND hwnd;
    HKEY hkType;
    VXDINSTANCE *pvi;
    DIDEVCAPS dc;
    DIDATAFORMAT df;
    JOYRANGECONVERT rgjrc[cJoyStateAxisMax];

    DIJOYCONFIG cfg;
    DIJOYTYPEINFO typi;

    PDIDOBJDEFSEM rgObjSem;

    DWORD dwVersion;

    DIAPPHACKS  diHacks;

    HKEY    hkProp;

} CJoy, DJ, *PDJ;

#define ThisClass CJoy
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

STDMETHODIMP CJoy_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk);
void INTERNAL CJoy_InitPhysRanges(PDJ this, LPJOYREGHWCONFIG phwc);

LRESULT CALLBACK
CJoy_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                  UINT uid, ULONG_PTR dwRef);

/*****************************************************************************
 *
 *      CJoy::QueryInterface      (from IUnknown)
 *      CJoy::AddRef              (from IUnknown)
 *      CJoy::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CJoy)
Default_AddRef(CJoy)
Default_Release(CJoy)

#else

#define CJoy_QueryInterface   Common_QueryInterface
#define CJoy_AddRef           Common_AddRef
#define CJoy_Release          Common_Release

#endif

#define CJoy_QIHelper         Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | RemoveSubclass |
 *
 *          Remove our subclass hook on the window.
 *
 *          The parameter is intentionally misdeclared as a <t PV>
 *          so that this function can double as the <f CJoy_AppFinalize>.
 *
 *****************************************************************************/

void INTERNAL
CJoy_RemoveSubclass(PV pvObj)
{
    PDJ this = pvObj;

    /*
     *  If there was an old window, then un-subclass it
     *  and release the hold associated with it.
     *
     *  You might think that there's a race condition here, where
     *  we might unhold the device while the subclass procedure is
     *  still using it.
     *
     *  Ah, but that's not a problem, because the only message that
     *  the subclass procedure cares about is the joystick
     *  reconfiguration message, and when it is processing that message,
     *  it does its own artificial hold/unhold to keep the device alive
     *  while it dorks on the device.
     *
     *  Okay, so there *is* a really tiny race condition where we
     *  might nuke the device while the window procedure is studying
     *  the message to decide whether it cares or not.
     *
     *  Since that is so extremely rare, we close that window by
     *  hacking it:  We revalidate the device before partying on it.
     *  Note that the hack is not perfect, but the race window becomes
     *  only a few instructions long that I'm not going to worry about it.
     *
     *  By wiping out this->hwnd before removing the subclass, we
     *  can reduce the window to very small indeed.
     */
    if (this->hwnd) {
        HWND hwnd = this->hwnd;
        this->hwnd = 0;
        if (!RemoveWindowSubclass(hwnd, CJoy_SubclassProc, 0)) {
            /*
             *  The RemoveWindowSubclass can fail if the window
             *  was destroyed behind our back.
             */
//            AssertF(!IsWindow(hwnd));
        }
        Sleep(0);                   /* Let the worker thread drain */
        Common_Unhold(this);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoy_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CJoy_Finalize(PV pvObj)
{
    PDJ this = pvObj;

    if (this->pvi) {
        HRESULT hres;

        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
        FreePpv(&this->df.rgodf);
        FreePpv(&this->rgObjSem );

        if (this->hkType) {
            RegCloseKey(this->hkType);
        }
        if( this->hkProp) {
            RegCloseKey(this->hkProp);
        }
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoy_AppFinalize |
 *
 *          The application has performed its final release.
 *          Remove our window subclass at this point.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

#define CJoy_AppFinalize      CJoy_RemoveSubclass

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CJoy_SubclassProc |
 *
 *          Window subclass procedure which watches for
 *          joystick configuration change notifications.
 *
 *  @parm   HWND | hwnd |
 *
 *          The victim window.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Message-specific data.
 *
 *  @parm   LPARAM | lp |
 *
 *          Message-specific data.
 *
 *  @parm   UINT | uid |
 *
 *          Callback identification number, always zero.
 *
 *  @parm   DWORD | dwRef |
 *
 *          Reference data, a pointer to our joystick device callback.
 *
 *****************************************************************************/

LRESULT CALLBACK
CJoy_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                  UINT uid, ULONG_PTR dwRef)
{
#ifdef XDEBUG
    static CHAR s_szProc[] = "";
#endif
    AssertF(uid == 0);

    if (wm == g_wmJoyChanged) {
        PDJ this = (PDJ)dwRef;

        /*
         *  Wacky subtlety going on here to avoid race conditions.
         *  See the mondo comment block in CJoy_RemoveSubclass
         *  for details.
         *
         *  We can get faked out if the memory associated with the
         *  CJoy is still physically allocated, the vtbl is magically
         *  still there and the hwnd field somehow matches our hwnd.
         */
        if (SUCCEEDED(hresPv(this)) && this->hwnd == hwnd) {

            HRESULT hres;

            Common_Hold(this);
            /*
             *  We must ask for DIJC_CALLOUT even though we don't care,
             *  because that will trigger the Microsoft Gamepad hack-o-rama.
             *
             *  Also, make sure we don't decide that we tried recently
             */
#ifndef WINNT
            g_dwLastBonusPoll = GetTickCount() ^ 0x80000000;
#endif
            hres = JoyReg_GetConfig(this->idJoy, &this->cfg,
                                    DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT);
            if (SUCCEEDED(hres)) {
                CJoy_InitPhysRanges(this, &this->cfg.hwc);
            }
            Common_Unhold(this);

        }
    }

    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDJ this;

    EnterProcI(IDirectInputDeviceCallback::Joy::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    /*
     *  Unlike mouse and keyboard, there can be multiple instances of
     *  the same joystick product, so we can't just leave guidProduct
     *  equal to guidInstance.
     */

    pdiW->guidProduct = GUID_Joystick;
    AssertF(pdiW->guidInstance.Data1 ==
            (pdiW->guidProduct.Data1 | this->idJoy));

    pdiW->dwDevType = this->dc.dwDevType;

  #ifdef UNICODE
    lstrcpyn(pdiW->tszProductName, this->typi.wszDisplayName,
             cA(pdiW->tszProductName));
  #else
    CAssertF(cA(pdiW->tszProductName) >= cA(this->typi.wszDisplayName));
    CopyMemory(pdiW->tszProductName, this->typi.wszDisplayName,
               cbX(this->typi.wszDisplayName));
  #endif


/*
 * Since we use HID path, there is no meaning to distinguish 
 * the devices by using "Joystick x" name.
 * We'd better use the same DisplayName for InstanceName.
 * Shall we do this?
 *
    LoadString(g_hinst, IDS_STDJOYSTICK, tszFormat, cA(tszFormat));

#ifdef UNICODE
    wsprintf(pdiW->tszInstanceName, tszFormat, this->idJoy + 1);
#else
    wsprintf(tszName, tszFormat, this->idJoy + 1);
    AToU(pdiW->tszInstanceName, cA(pdiW->tszInstanceName), tszName);
#endif
 */

#ifdef UNICODE
    lstrcpyn(pdiW->tszInstanceName, this->typi.wszDisplayName,
             cA(pdiW->tszInstanceName));
#else
    CAssertF(cA(pdiW->tszInstanceName) >= cA(this->typi.wszDisplayName));
    CopyMemory(pdiW->tszInstanceName, this->typi.wszDisplayName,
               cbX(this->typi.wszDisplayName));
#endif

    if (pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W)) {
        HKEY hkFF;

        /*
         *  If there is a force feedback driver, then fetch the driver CLSID
         *  as the FF GUID.
         */
        hres = CJoy_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hkFF);
        if (SUCCEEDED(hres)) {
            LONG lRc;
            TCHAR tszClsid[ctchGuid];

            lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
            if (lRc == ERROR_SUCCESS &&
                ParseGUID(&pdiW->guidFFDriver, tszClsid)) {
            } else {
                ZeroX(pdiW->guidFFDriver);
            }
            RegCloseKey(hkFF);
        }
    }


    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | SetAxisProperty |
 *
 *          If the request is to set a property on the device,
 *          then convert it into separate requests, one for each
 *          axis.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   GETSETJOYPROP | GetSetJoyProp |
 *
 *          Callback function that gets or sets the property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @parm   int | ibField |
 *
 *          Offset to field being set.  (Really: Reference data to
 *          pass to callback.)
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetAxisProperty(PDJ this, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;

    /*
     *  Note that we never pass the type key to CCal_SetProperty
     *  because we keep our calibration data elsewhere.
     */

    if (ppropi->dwDevType == 0) {           /* For device */
        int iAxis;

        for (iAxis = 0; iAxis < cA(this->rgjrc); iAxis++) {

            PJOYRANGECONVERT pjrc = &this->rgjrc[iAxis];

            hres = CCal_SetProperty(pjrc, ppropi, pdiph, NULL);

            if (FAILED(hres)) {
                goto done;
            }
        }
        hres = S_OK;

    } else if ((ppropi->dwDevType & DIDFT_ABSAXIS) &&
               DIDFT_GETINSTANCE(ppropi->dwDevType) < cA(this->rgjrc)) {

        PJOYRANGECONVERT pjrc;
        pjrc = &this->rgjrc[DIDFT_GETINSTANCE(ppropi->dwDevType)];

        hres = CCal_SetProperty(pjrc, ppropi, pdiph, NULL);

    } else {
        hres = E_NOTIMPL;
    }

done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | UpdateAxisCalibration |
 *
 *          Take our cached calibration information and smash it into
 *          the configuration section of the registry.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_UpdateAxisCalibration(PDJ this)
{
    HRESULT hres;
    DIJOYCONFIG cfg;

    hres = JoyReg_GetConfig(this->idJoy, &cfg, DIJC_REGHWCONFIGTYPE);
    if (SUCCEEDED(hres)) {
        UINT uiPosAxis;

#define JoyPosValue(phwc, f, i)                                         \
        *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,                 \
                            ibJoyPosAxisFromPosAxis(i))                 \


        for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {
            PJOYRANGECONVERT pjrc;
            UINT uiStateAxis;

            uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

            pjrc = &this->rgjrc[uiStateAxis];

            JoyPosValue(&cfg.hwc, jpMin,    uiPosAxis) = pjrc->dwPmin;
            JoyPosValue(&cfg.hwc, jpMax,    uiPosAxis) = pjrc->dwPmax;
            JoyPosValue(&cfg.hwc, jpCenter, uiPosAxis) = pjrc->dwPc;

#undef JoyPosValue
        }

        hres = JoyReg_SetConfig(this->idJoy, &cfg.hwc, &cfg,
                                DIJC_UPDATEALIAS | DIJC_REGHWCONFIGTYPE);

    }

    if (FAILED(hres)) {
        RPF("Joystick::SetProperty::Calibration: "
            "Unable to update calibration in registry");
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> for something we didn't handle natively.
 *          The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {

    case (DWORD)(UINT_PTR)DIPROP_RANGE:
    case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
    case (DWORD)(UINT_PTR)DIPROP_SATURATION:
    case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
    case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
        hres = CJoy_SetAxisProperty(this, ppropi, pdiph);
        if (SUCCEEDED(hres) && ppropi->pguid == DIPROP_CALIBRATION) {
            hres = CJoy_UpdateAxisCalibration(this);
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
    case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
        {
            USHORT uVid, uPid;
            
            /*
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             *
             *  Prefix warns (240487) that ParseVIDPID could leave uVid 
             *  uninitialized and succeed but it won't.  
             *  See the comment in _ParseHex for more details.
             */
            if( ParseVIDPID( &uVid, &uPid, this->cfg.wszType ) &&
                ( uVid == MSFT_SYSTEM_VID ) &&
                ( uPid >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) &&
                ( ( uPid & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_SetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        hres = S_OK;
                    } else {
                        hres = E_FAIL;
                    }
                }
            }
            else
            {
                hres = E_NOTIMPL;
            }
            break;
        }

    default:
        SquirtSqflPtszV(sqflJoy,
                        TEXT("CJoy_SetProperty: E_NOTIMPL on guid: %08x"),
                        ppropi->pguid);

        hres = E_NOTIMPL;
        break;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetAxisProperty |
 *
 *          Handle an axis property.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetAxisProperty(PDJ this, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    LPDIPROPRANGE pdiprg = (PV)pdiph;
    HRESULT hres;

    if ((ppropi->dwDevType & DIDFT_ABSAXIS) &&
        DIDFT_GETINSTANCE(ppropi->dwDevType) < cA(this->rgjrc)) {

        PJOYRANGECONVERT pjrc;
        pjrc = &this->rgjrc[DIDFT_GETINSTANCE(ppropi->dwDevType)];

        hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph);

    } else {
        SquirtSqflPtszV(sqflJoy,
                        TEXT("CJoy_GetProperty: E_NOTIMPL on guid: %08x"),
                        ppropi->pguid);

        hres = E_NOTIMPL;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetGuidAndPath |
 *
 *          Get a Joy device's class GUID (namely, the MEDIA guid)
 *          and device interface (path).  The path is for the equivalent 
 *          HID device if possible, otherwise a NULL string.
 *
 *  @parm   PCHID | this |
 *
 *          The Joy object.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *****************************************************************************/

VOID INTERNAL
    CJoy_GetGuidAndPath(PDJ this, LPDIPROPHEADER pdiph)
{

/*
 *  This should never happen on Win2k because all devices are HID
 *  but just in case we build an NT4 SP5 version or something...
 */
#ifdef WINNT
    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;

    UNREFERENCED_PARAMETER( this );

    pgp->guidClass = GUID_MediaClass;
    pgp->wszPath[0] = TEXT( '\0' );
#else

    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;
    VXDINITPARMS    vip;
    TCHAR           szPath[MAX_PATH];
    PTCHAR          pszPath;

    pgp->guidClass = GUID_MediaClass;

    pszPath = JoyReg_JoyIdToDeviceInterface_95( this->idJoy, &vip, szPath );
    if( pszPath )
    {
        TToU( pgp->wszPath, cA(pgp->wszPath), pszPath );
    }
    else
    {
        pgp->wszPath[0] = TEXT( '\0' );
    }
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres = E_NOTIMPL;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {
        case (DWORD)(UINT_PTR)DIPROP_GRANULARITY:
            /*
             *  ISSUE-2001/03/29-timgill All POVs have the same granularity
             */
            if (ppropi->dwDevType & DIDFT_POV) {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData = this->dwPOVGranularity;
                hres = S_OK;
            }
            break;
    
        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            if(ppropi->iobj == 0xFFFFFFFF)
            {
                CJoy_GetGuidAndPath(this, pdiph);
                hres = S_OK;
            }
            break;

        /*
         * In DX7, INSTANCENAME and PRODUCTNAME are the same for VJOYD devices.
         * It is different before DX7. Probably we need make them different again
         * after DX7.
         */
        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                
                /*
                 * lstrcpW doesn't work in Win95. We have to use memcpy instead.
                 */
                //lstrcpyW(pstr->wsz, this->typi.wszDisplayName);
                if( cbX(pdipstr->wsz) > cbX(this->typi.wszDisplayName) )
                {
                    memset( &pdipstr->wsz[cA(this->typi.wszDisplayName)], 0, cbX(pdipstr->wsz) - cbX(this->typi.wszDisplayName) );
                }

                CAssertF( cbX(pdipstr->wsz) >= cbX(this->typi.wszDisplayName) );
                memcpy( pdipstr->wsz, this->typi.wszDisplayName, cbX(this->typi.wszDisplayName));
                if( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) ) {
                    pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                }
                hres = S_OK;
                break;
            }


        case (DWORD)(UINT_PTR)DIPROP_JOYSTICKID:
            if(ppropi->iobj == 0xFFFFFFFF)
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData =  this->idJoy;
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_MAPFILE):
            AssertF( ppropi->iobj == 0xFFFFFFFF );

            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                LONG    lRes;
                DWORD   dwBufferSize = cbX(pdipstr->wsz);

                lRes = RegQueryStringValueW( this->hkProp, REGSTR_VAL_JOYOEMMAPFILE, pdipstr->wsz, &dwBufferSize );
                hres = ( pdipstr->wsz[0] && ( lRes == ERROR_SUCCESS ) ) ? S_OK : DIERR_OBJECTNOTFOUND;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_TYPENAME):
            AssertF( ppropi->iobj == 0xFFFFFFFF );

            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;

                if( this->cfg.hwc.dwType >= JOY_HW_PREDEFMIN && this->cfg.hwc.dwType < JOY_HW_PREDEFMAX ) {
                    pdipstr->wsz[0] = L'#';
                    pdipstr->wsz[1] = L'0' + (WCHAR)this->cfg.hwc.dwType;
                    pdipstr->wsz[2] = L'\0';
                    hres = S_OK;
                } 
                else if( this->cfg.wszType[0] != L'\0' ) 
                {
                    /*
                     *  The type MUST be NULL terminated
                     */
#ifdef WINNT
                    lstrcpyW( pdipstr->wsz, this->cfg.wszType );
#else
                    UINT uiLen;

                    uiLen = lstrlenW( this->cfg.wszType ) + 1;
                    AssertF( uiLen <= cA( pdipstr->wsz ) );
                    memcpy( pdipstr->wsz, this->cfg.wszType, uiLen * cbX(this->cfg.wszType[0]) );
#endif
                    hres = S_OK;
                }
                else
                {
                    /*
                     *  Don't think this should ever happen so Assert for now
                     *  Assert that the hres is a failure (if not quite right)
                     */
                    AssertF( hres == E_NOTIMPL );
                    AssertF( !"No type name available in GetProperty" );
                }
            }
            break;

            

    /*
     *  Else, it might be something axis-specific.
     */
    default:
        hres = CJoy_GetAxisProperty(this, ppropi, pdiph);
        break;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetCapabilities |
 *
 *          Get joystick device capabilities.
 *
 *  @parm   PDJ | this |
 *
 *          The joystick object.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDJ this;
    JOYINFOEX jix;
    MMRESULT mmrc = MMSYSERR_ERROR;

    EnterProcI(IDirectInputDeviceCallback::Joy::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVCAPS(pdc->dwSize));
    CopyMemory(pvAddPvCb(pdc, cbX(DWORD)),
               pvAddPvCb(&this->dc, cbX(DWORD)),
               pdc->dwSize - cbX(DWORD));

    /*
     *  Joysticks can come and go.  Re-query each time.
     */

    /*
     *  Determine if joystick is physically attached
     *  or is possibly even phantom.
     *
     *  JOYERR_ATTACHED  - Is attached
     *  JOYERR_UNPLUGGED - Is not attached
     *  Anything else    - Is phantom
     */
    jix.dwSize = sizeof(JOYINFOEX);
    jix.dwFlags = JOY_CAL_READALWAYS | JOY_RETURNALL;
    mmrc = joyGetPosEx(this->idJoy, &jix);

    pdc->dwFlags &= ~DIDC_ATTACHED;
    if (mmrc == JOYERR_NOERROR) {
        pdc->dwFlags |= DIDC_ATTACHED;
    } else if (mmrc == JOYERR_UNPLUGGED) {
    } else {
        pdc->dwFlags |= DIDC_PHANTOM;
    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetPhysicalState |
 *
 *          Read the physical joystick state into <p pjsOut>.
 *
 *          After getting the physical data,
 *          we cook the axes as necessary.
 *
 *  @parm   LPDIJOYSTATE2 | pjsOut |
 *
 *          Where to put the joystick state.
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void INLINE
CJoy_GetPhysicalState(PDJ this, LPDIJOYSTATE2 pjsOut)
{
    UINT uiStateAxis;

    AssertF(this->pjsPhys);

    *pjsOut = *this->pjsPhys;

    /*
     *  Note only absolute positional data gets calibrated 
     */
    if( ( this->pvi->fl & VIFL_RELATIVE ) == 0 )
    {
        for (uiStateAxis = 0; uiStateAxis < cA(this->rgjrc); uiStateAxis++) {
            PLONG pl = pvAddPvCb(pjsOut,
                                 ibJoyStateAxisFromStateAxis(uiStateAxis));
            CCal_CookRange(&this->rgjrc[uiStateAxis], pl);
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Poll |
 *
 *          Ping down into the driver to get the latest data.
 *
 *  @returns
 *
 *          <c S_OK> if we pinged okay.
 *          <c DIERR_UNPLUGGED> if we did not
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_Poll(PDICB pdcb)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::Poll, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = Hel_Joy_Ping(this->pvi);
    if (FAILED(hres)) {
        AssertF(hres ==
            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,
                                         ERROR_DEV_NOT_EXIST));
        hres = DIERR_UNPLUGGED;
    }
    /*
     *  Note, we don't keep this->pvi->fl:VIFL_UNPLUGGED up-to-date because 
     *  we don't use the flag and always retest the connectivity in GetCaps.
     */

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDeviceState |
 *
 *          Obtains the state of the joystick device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          joystick data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDJ this;
    LPDIJOYSTATE2 pjsOut = pvData;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pjsPhys);

    if (this->pvi->fl & VIFL_ACQUIRED) {
        CJoy_GetPhysicalState(this, pjsOut);
        hres = S_OK;
    } else {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | CookDeviceData |
 *
 *          Manipulate buffered device data.
 *
 *          If the item describe an axis, we need to cook it.
 *
 *  @parm   DWORD | cdod |
 *
 *          Number of objects to cook; zero is a valid value.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | pdod |
 *
 *          Array of object data to cook.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The callback does
 *          not cook device data.
 *
 *          <c DIERR_NOTACQUIRED>: The device could not be acquired.
 *
 ***************************************************************************/

STDMETHODIMP
CJoy_CookDeviceData
(
    PDICB                   pdcb, 
    DWORD                   cdod, 
    LPDIDEVICEOBJECTDATA    pdod
)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::CookDeviceData,
               (_ "pxp", pdcb, cdod, pdod));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Step through array of either element size cooking the data.
     */
    for( ; cdod; cdod-- )
    {
        DWORD dwType = this->df.rgodf[pdod->dwOfs].dwType;
        if( dwType & DIDFT_ABSAXIS )
        {
            PJOYRANGECONVERT pjrc;

            AssertF( DIDFT_GETINSTANCE( dwType ) < cA( this->rgjrc ) );
            pjrc = &this->rgjrc[DIDFT_GETINSTANCE( dwType )];

            CCal_CookRange(pjrc, (PV)&pdod->dwData);
        }
        pdod++;
    }

    hres = S_OK;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | OpenIdSubkey |
 *
 *          Given an object ID, attempt to open the subkey that
 *          corresponds to it.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_OpenIdSubkey(PDJ this, DWORD dwId, PHKEY phk)
{
      return CType_OpenIdSubkey(this->hkType, dwId, KEY_QUERY_VALUE, phk);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetObjectInfo |
 *
 *          Obtain the friendly name and FF/HID information
 *          of an object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          <e DIDEVICEOBJECTINSTANCE.dwFlags>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));
    if (ppropi->iobj < this->df.dwNumObjs) {

        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);

        CType_RegGetObjectInfo(this->hkType, ppropi->dwDevType, pdidoiW);

        /*
         *  If we couldn't get a name from the registry,
         *  then grab one of the standard names.
         */
        if (pdidoiW->tszName[0] == L'\0') {
            UINT dids;

            if (ppropi->dwDevType & DIDFT_AXIS) {
                dids = 0;
                LoadStringW(g_hinst, IDS_JOYSTICKOBJECT + dids +
                                     DIDFT_GETINSTANCE(ppropi->dwDevType),
                                     pdidoiW->tszName, cA(pdidoiW->tszName));
            } else if (ppropi->dwDevType & DIDFT_BUTTON) {
                GetNthButtonString(pdidoiW->tszName,
                                   DIDFT_GETINSTANCE(ppropi->dwDevType));
            } else {
                AssertF(ppropi->dwDevType & DIDFT_POV);
                GetNthPOVString(pdidoiW->tszName,
                                DIDFT_GETINSTANCE(ppropi->dwDevType));
            }

        }

        /*
         *  ISSUE-2001/03/29-timgill Need a faster way of checking VJoyD devices
         *  On Win9x, many HID devices cannot use our ring 3 HID path so try
         *  to get any axis or POV usage from VJoyD
         *  This is not cheap to get but until we have a better way to 
         *  make sure the VJoyD device has not changed under us this is better 
         *  than caching it.  This is not inner loop code anyway.
         */
#ifndef WINNT
        if( pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W) )
        {
            VXDINITPARMS vip;
            hres = Hel_Joy_GetInitParms(this->idJoy, &vip);

            if( SUCCEEDED( hres ) && ( vip.dwFlags & VIP_ISHID ) ) 
            {
                if( ppropi->dwDevType & DIDFT_AXIS )
                {
                    int AxisIdx;

                    AxisIdx = c_rgiJoyPosAxisFromStateAxis[DIDFT_GETINSTANCE(ppropi->dwDevType)];
                    pdidoiW->wUsagePage = HIWORD( vip.Usages[AxisIdx] );
                    pdidoiW->wUsage = LOWORD( vip.Usages[AxisIdx] );
                }
                else if( ppropi->dwDevType & DIDFT_BUTTON )
                {
                    /*
                     *  Only JoyHID uses this interface and it only counts 
                     *  button page buttons so assume the simplest case.
                     */
                    pdidoiW->wUsagePage = HID_USAGE_PAGE_BUTTON;
                    pdidoiW->wUsage = 1 + DIDFT_GETINSTANCE( ppropi->dwDevType );
                }
                else
                {
                    AssertF(ppropi->dwDevType & DIDFT_POV);
                    pdidoiW->wUsagePage = HIWORD( ((PDWORD)(&vip.dwPOV0usage))[DIDFT_GETINSTANCE(ppropi->dwDevType)] );
                    pdidoiW->wUsage = LOWORD( ((PDWORD)(&vip.dwPOV0usage))[DIDFT_GETINSTANCE(ppropi->dwDevType)] );
                }
            }
        }
        /*
         *  Ignore any errors getting params.
         */
#endif

        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetCooperativeLevel |
 *
 *          The app changed the cooperative level.
 *          Un-subclass the old window and en-subclass the new window.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  First get out of the old window.
     */
    CJoy_RemoveSubclass(this);
    /*
     *  Prefix warns that "this" may have been freed (mb:34574) however 
     *  If you're in SetCooperativeLevel and you have a window subclassed 
     *  then there must be a hold for the subclassed window as well as 
     *  one for the unreleased interface so the Common_Unhold won't free 
     *  the pointer.
     */

    /*
     *  If a new window is passed, then subclass it so we can
     *  watch for joystick configuration change messages.
     *
     *  If we can't, don't worry.  All it means that we won't
     *  be able to catch when the user recalibrates the joystick,
     *  which isn't very often.
     */
    if (hwnd) {
        if (SetWindowSubclass(hwnd, CJoy_SubclassProc, 0, (ULONG_PTR)this)) {
            this->hwnd = hwnd;
            Common_Hold(this);
        }

    } else {
        RPF("SetCooperativeLevel: You really shouldn't pass hwnd = 0; "
            "joystick calibration may be dodgy");
    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | RunControlPanel |
 *
 *          Run the joystick control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

TCHAR c_tszJoyCpl[] = TEXT("joy.cpl");

STDMETHODIMP
CJoy_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = hresRunControlPanel(c_tszJoyCpl);

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetFFConfigKey,
               (_ "px", pdcb, sam));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = JoyReg_OpenFFKey(this->hkType, sam, phk);

    AssertF(fLeqvFF(SUCCEEDED(hres), *phk));

    ExitBenignOleProcPpvR(phk);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    PDJ this;
    HKEY hk;
    EnterProcI(IDirectInputDeviceCallback::Joy::CreateEffect, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = CJoy_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hk);
    if (SUCCEEDED(hres)) {
        hres = CEShep_New(hk, 0, &IID_IDirectInputEffectShepherd, ppes);
        if (SUCCEEDED(hres)) {
#ifndef WINNT
            VXDINITPARMS    vip;
            CHAR           szPath[MAX_PATH];
            PCHAR          pszPath;

            pszPath = JoyReg_JoyIdToDeviceInterface_95( this->idJoy, &vip, szPath );
            if( pszPath )
            {
                DIHIDFFINITINFO init;
                WCHAR           wszPath[MAX_PATH];

                ZeroX(init);
                init.dwSize = cbX(init);

                TToU( wszPath, cA(wszPath), pszPath );
                init.pwszDeviceInterface = wszPath;
                hresFindHIDDeviceInterface(pszPath, &init.GuidInstance);

                hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, &init);
            }
            else
#endif
            {
                hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, 0);
            }
        }
        if (SUCCEEDED(hres)) {
        } else {
            Invoke_Release(ppes);
        }
        RegCloseKey(hk);
    } else {
        hres = E_NOTIMPL;
        *ppes = 0;
    }

    ExitOleProcPpvR(ppes);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetVersions |
 *
 *          Ping down into the driver to get the driver version info.
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *
 *          <c S_OK> if we succeeded.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetVersions(PDICB pdcb, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;
    PDJ this;
    VXDINITPARMS vip;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetVersions, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(pvers->dwSize == cbX(*pvers));

    hres = Hel_Joy_GetInitParms(this->idJoy, &vip);

    if (SUCCEEDED(hres)) {
        pvers->dwFirmwareRevision = vip.dwFirmwareRevision;
        pvers->dwHardwareRevision = vip.dwHardwareRevision;
        pvers->dwFFDriverVersion  = vip.dwFFDriverVersion;
    }

    return hres;
}


/*****************************************************************************
 *
 *  Joystick registry usage
 *
 *****************************************************************************
 *
 *  Global joystick information is kept under
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaProperties\
 *                      Joystick\
 *                          OEM
 *
 *  Under this key is a number of subkeys, each corresponding to a brand
 *  of joystick.
 *
 *  Under each OEM\<name> key, you can find the following values:
 *
 *      OEMData
 *
 *          This is a binary value containing a structure of two dwords.
 *          The first is the JOYREGHWCONFIG.hws.dwFlags and the second
 *          is the JOYREGHWCONFIG.hws.dwNumButtons.
 *
 *      OEMName
 *
 *          This is a string which gives a friendly name for the unit.
 *
 *
 *****************************************************************************
 *
 *  Under the driver key is kept information about the particular joystick.
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaResources\
 *                      Joystick\
 *                          <driver key name>\
 *                              CurrentJoystickSettings
 *
 *  Under this key, there are a bunch of values named
 *  Joystick##Configuration, where ## is the joystick number
 *  (1 through 16).  Each value contains binary data in the form
 *  of a JOYREGHWCONFIG, which looks like this:
 *
 *      DWORD hws.dwFlags;    // JOY_HWS_*    \
 *      DWORD hws.dwNumButtons;               _\ JOYREGHWSETTINGS
 *      DWORD dwUsageSettings;// JOY_US_*    _____
 *      DWORD hwv.jrvHardware.jpMin.dwX;    \     |
 *      DWORD hwv.jrvHardware.jpMin.dwY;     \    |
 *      DWORD hwv.jrvHardware.jpMin.dwZ;      \
 *      DWORD hwv.jrvHardware.jpMin.dwR;      |
 *      DWORD hwv.jrvHardware.jpMin.dwU;       > JOYREGHWVALUES.JOYRANGE
 *      DWORD hwv.jrvHardware.jpMin.dwV;      |
 *      DWORD hwv.jrvHardware.jpMax.dwX;      |   |
 *      DWORD hwv.jrvHardware.jpMax.dwY;      |   |
 *      DWORD hwv.jrvHardware.jpMax.dwZ;      |   \
 *      DWORD hwv.jrvHardware.jpMax.dwR;      |    > JOYREGHWVALUES
 *      DWORD hwv.jrvHardware.jpMax.dwU;      |   /
 *      DWORD hwv.jrvHardware.jpMax.dwV;      |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwX;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwY;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwZ;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwR;   /   |
 *      DWORD hwv.jrvHardware.jpCenter.dwU;  /    |
 *      DWORD hwv.jrvHardware.jpCenter.dwV; /     |
 *      DWORD hwv.dwPOVValues[4];                 |
 *      DWORD hwv.dwCalFlags;               ______|
 *      DWORD dwType;         // JOY_HW_*
 *      DWORD dwReserved;
 *
 *
 *  Also under this key are optional values named Joystick##OEMName.
 *  If present, it is a string-data key whose contents are the name
 *  of another key that describes the joystick, stored in the global
 *  section described above.
 *
 *  Meanwhile, under the key
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaResources\
 *                      Joystick\
 *                          <driver key name>
 *
 *  is a value called "JoystickUserValues".  This is a binary key
 *  that contains a JOYREGUSERVALUES structure:
 *
 *      DWORD   dwTimeOut;
 *      DWORD   jrvRanges.jpMin.dwX;    \
 *      DWORD   jrvRanges.jpMin.dwY;     \
 *      DWORD   jrvRanges.jpMin.dwZ;      \
 *      DWORD   jrvRanges.jpMin.dwR;      |
 *      DWORD   jrvRanges.jpMin.dwU;       > JOYRANGE
 *      DWORD   jrvRanges.jpMin.dwV;      |
 *      DWORD   jrvRanges.jpMax.dwX;      |
 *      DWORD   jrvRanges.jpMax.dwY;      |
 *      DWORD   jrvRanges.jpMax.dwZ;      |
 *      DWORD   jrvRanges.jpMax.dwR;      |
 *      DWORD   jrvRanges.jpMax.dwU;      |
 *      DWORD   jrvRanges.jpMax.dwV;      |
 *      DWORD   jrvRanges.jpCenter.dwX;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwY;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwZ;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwR;   / (ignored)
 *      DWORD   jrvRanges.jpCenter.dwU;  /  (ignored)
 *      DWORD   jrvRanges.jpCenter.dwV; /   (ignored)
 *      DWORD   jpDeadZone.dwX;         \
 *      DWORD   jpDeadZone.dwY;          \
 *      DWORD   jpDeadZone.dwZ;           \ JOYPOS
 *      DWORD   jpDeadZone.dwR;           / Dead zone is recorded as a
 *      DWORD   jpDeadZone.dwU;          /  percentage of total range
 *      DWORD   jpDeadZone.dwV;         /
 *
 *  If there is no JoystickUserValues, then the following defaults
 *  are used:
 *
 *      jpMin.dw# = 0;
 *      jpMax.dw# = 65535;
 *      jpCenter.dw# = jpMax.dw# / 2;
 *      jrvDeadZone.dw# = 5;
 *
 *  (See ibmjoy\msjstick.c, function jsReadRegistry for the code that
 *  sets the defaults.)
 *
 *  We will also use the defaults if Min > Max or if Max >= 0x80000000
 *  or if DeadZone > 100.
 *
 *****************************************************************************/


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | InitPhysRanges |
 *
 *          Initialize (or re-initialize)
 *          the physical min/max/center values.  This is
 *          done as part of device initialization as well as in response
 *          to a notification that the Joystick control panel has been
 *          dinked with.
 *
 *          It is assumed that the <e DJ.hwc> already contains the
 *          registry hardware settings.
 *
 *          After the phys ranges are set, the ramps are recalculated.
 *
 *
 *****************************************************************************/

void INTERNAL
CJoy_InitPhysRanges(PDJ this, LPJOYREGHWCONFIG phwc)
{
    UINT uiPosAxis;
    UINT uiStateAxis;

#define GetJoyPosValue(phwc, f, i)                                      \
        *(LPDWORD)pvAddPvCb(&phwc->hwv.jrvHardware.f,                   \
                            ibJoyPosAxisFromPosAxis(i))                 \

    for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {
        DWORD dwMax, dwC;
        PJOYRANGECONVERT pjrc;

        uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

        pjrc = &this->rgjrc[uiStateAxis];

        pjrc->dwPmin = GetJoyPosValue(phwc, jpMin, uiPosAxis);

        /*
         *  HACKHACK - Uncalibrated joysticks will have max == 0, in which
         *  case we use a fake max of 655, just like VJOYD.
         */
        dwMax = GetJoyPosValue(phwc, jpMax, uiPosAxis);
        if (dwMax == 0) {
            dwMax = 655;
        }

        pjrc->dwPmax = dwMax;

        /*
         *  HACKHACK - Uncalibrated joysticks will have center == 0,
         *  in which case we use a fake center of midway between min and
         *  max, just like VJOYD.
         *
         *  Quirk - Z, R, U, and V typically are not center-calibrated,
         *  so if the jpCenter value is not strictly between min and
         *  max, then assume it's one of the bogus cases and slam it
         *  into the middle of the range.
         */

        dwC = GetJoyPosValue(phwc, jpCenter, uiPosAxis);
        if (dwC <= pjrc->dwPmin || dwC >= pjrc->dwPmax) {
            dwC = (pjrc->dwPmin + pjrc->dwPmax) / 2;
        }

        pjrc->dwPc = dwC;

        if( pjrc->dwCPointsNum == 0 ) {
            //use two control points by default
            pjrc->dwCPointsNum = 2;
            pjrc->cp[0].lP = pjrc->dwPmin;
            pjrc->cp[0].dwLog = 0;
            pjrc->cp[1].lP = pjrc->dwPmax;
            pjrc->cp[1].dwLog = RANGEDIVISIONS;
        } else {
            pjrc->cp[0].lP = pjrc->dwPmin;
            pjrc->cp[pjrc->dwCPointsNum-1].lP = pjrc->dwPmax;
        }
    
        SquirtSqflPtszV(sqfl,
                        TEXT("CJoy_PhysRange %d -> %d: %08x / %08x / %08x"),
                        uiPosAxis,
                        uiStateAxis,
                        pjrc->dwPmin,
                        pjrc->dwPc,
                        pjrc->dwPmax);

    }

#undef GetJoyValue

    /*
     *  These two phantom axes are always raw because they don't exist.
     */
    this->rgjrc[iJoyStateAxisRx].fRaw = TRUE;
    this->rgjrc[iJoyStateAxisRy].fRaw = TRUE;

    /*
     *  Now compute all the dependent variables.
     */
    for (uiStateAxis = 0; uiStateAxis < cA(this->rgjrc); uiStateAxis++) {
        CCal_RecalcRange(&this->rgjrc[uiStateAxis]);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | InitLogRanges |
 *
 *          Initialize the logical ranges from the user values.
 *
 *****************************************************************************/

void INLINE
CJoy_InitLogRanges(PDJ this)
{
    HRESULT hres;
    UINT uiPosAxis;
    UINT uiStateAxis;
    DIJOYUSERVALUES juv;

    hres = JoyReg_GetUserValues(&juv, DIJU_USERVALUES);
    AssertF(SUCCEEDED(hres));

#define pJoyValue(jp, i)                                            \
        (LPDWORD)pvAddPvCb(&(jp), ibJoyPosAxisFromPosAxis(i))       \


    for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {

        PJOYRANGECONVERT pjrc;

        AssertF((int)*pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis) >= 0);
        AssertF(*pJoyValue(juv.ruv.jrvRanges.jpMin, uiPosAxis) <
                *pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis));

        uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

        pjrc = &this->rgjrc[uiStateAxis];

        pjrc->lMin = *pJoyValue(juv.ruv.jrvRanges.jpMin, uiPosAxis);
        pjrc->lMax = *pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis);

        /*
         *  Note that we do *not* use the jpCenter value.  Strange
         *  but true.
         *
         *  The sum cannot overflow due to the sanity checks we did above.
         */

        pjrc->lC = CCal_Midpoint(pjrc->lMin, pjrc->lMax);

        /*
         *  Now do the dead zone.  Convert from percent to range units.
         */
        pjrc->dwDz = *pJoyValue(juv.ruv.jpDeadZone, uiPosAxis) *
                                    (RANGEDIVISIONS / 100);

        if (pjrc->dwDz > RANGEDIVISIONS) {
            pjrc->dwDz = 5 * (RANGEDIVISIONS / 100);
        }

        /*
         *  Now do the saturation level.  It always defaults to 100%.
         */
        pjrc->dwSat = RANGEDIVISIONS;

    }

}

#undef pJoyValue


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | BuildAxes |
 *
 *          Study a single capabilities flag and add axis items to the data
 *          format accordingly.
 *
 *  @parm   DWORD | dwCaps |
 *
 *          Collection of <c JOYPF_*> flags describing the axes supported.
 *
 *  @parm   UINT | ib |
 *
 *          Data format offset at which this data is provided.
 *
 *  @parm   UINT | uiObj |
 *
 *          Instance index for the first item.
 *
 *  @parm   DWORD | dwAspect |
 *
 *          <c DIDOI_ASPECT*> for these axes.
 *
 *****************************************************************************/


typedef struct AXISATTRIBUTES {
    DWORD dwMask;                   /* Mask that identifies the axis */
    UINT  uidObj;                   /* Object index delta from X axis */
} AXISATTRIBUTES, *PAXISATTRIBUTES;
typedef const AXISATTRIBUTES *PCAXISATTRIBUTES;

typedef struct AXISMAPPINGS {
    PCGUID pguid;                   /* GUID for the object */
    DWORD  dwSemantic;              /* Default semantic map */
} AXISMAPPINGS, *PAXISMAPPINGS;
typedef const AXISMAPPINGS *PCAXISMAPPINGS;

const AXISATTRIBUTES c_rgaattrJoy[] = {
    {   JOYPF_X,    iJoyStateAxisX,  },
    {   JOYPF_Y,    iJoyStateAxisY,  },
    {   JOYPF_Z,    iJoyStateAxisZ,  },
    {   JOYPF_R,    iJoyStateAxisRz, },
    {   JOYPF_U,    iJoyStateAxisS0, },
    {   JOYPF_V,    iJoyStateAxisS1, },
};


const AXISMAPPINGS c_rgamapJoy[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_Y | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_R | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamap6DOF[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_Y | DISEM_TYPE_AXIS }, 
    { &GUID_ZAxis,  DISEM_FLAGS_Z | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_R | DISEM_TYPE_AXIS }, 
    { &GUID_RyAxis, DISEM_FLAGS_U | DISEM_TYPE_AXIS }, 
    { &GUID_RxAxis, DISEM_FLAGS_V | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamapZJoy[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_Y | DISEM_TYPE_AXIS }, 
    { &GUID_ZAxis,  DISEM_FLAGS_Z | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_R | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

/*
 *  Since default HID mapping maps accel to Y and brake to Rz 
 *  use the GUIDs to match the correct axis to those mappings 
 *  and set appropriate semantics.
 */

const AXISMAPPINGS c_rgamapCarZY[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_B | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_A | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamapCarYR[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_A | DISEM_TYPE_AXIS }, 
    { &GUID_ZAxis,  DISEM_FLAGS_Z | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_B | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamapCarZR[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_A | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_B | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitFromHwc |
 *
 *          Initialize the information that is kept in the
 *          <t JOYREGHWCONFIG>.
 *
 *          Broken out from CJoy_InitRing3 to make things less monolithic.
 *
 *          The <e CJoy.cfg> structure already contains joystick
 *          configuration information.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_InitFromHwc(PDJ this)
{
    HRESULT hres;
    DWORD dwTestType;

    if( this->cfg.hwc.dwType >= JOY_HW_PREDEFMIN && this->cfg.hwc.dwType < JOY_HW_PREDEFMAX ) {
        WCHAR wszType[4];
        
        wszType[0] = L'#';
        wszType[1] = L'0' + (WCHAR)this->cfg.hwc.dwType;
        wszType[2] = L'\0';
        
        hres = JoyReg_GetPredefTypeInfo( wszType, &this->typi, DITC_DISPLAYNAME);
    } else if (this->cfg.wszType[0] != L'\0' ) {
        hres = JoyReg_GetTypeInfo(this->cfg.wszType, &this->typi, DITC_DISPLAYNAME | DITC_FLAGS2 );

        if (SUCCEEDED(hres)) {
        } else {
#ifdef WINNT
            ZeroMemory(&this->typi, cbX(this->typi));
#else
            //lstrcpyW( this->typi.wszDisplayName, this->cfg.wszType );
            memset( &this->typi.wszDisplayName[0], 0, sizeof(this->typi.wszDisplayName) );
            memcpy( &this->typi.wszDisplayName[0], &this->cfg.wszType[0], sizeof(this->cfg.wszType));
#endif
        }
    } else {
        ZeroMemory(&this->typi, cbX(this->typi));
    }

    #define hwc this->cfg.hwc
    

    if( ( this->typi.dwFlags2 & ( JOYTYPE_HIDEACTIVE | JOYTYPE_GAMEHIDE ) )
     == ( JOYTYPE_HIDEACTIVE | JOYTYPE_GAMEHIDE ) )
    {
        this->dc.dwFlags |= DIDC_HIDDEN;
    }

    dwTestType = GetValidDI8DevType( this->typi.dwFlags2, this->dc.dwButtons, hwc.hws.dwFlags );

    if( dwTestType )
    {
        /*
         *  If a valid override exists just use it
         */
        this->dc.dwDevType = dwTestType;
    }
    else
    {
#ifdef XDEBUG
        if( GET_DIDEVICE_TYPEANDSUBTYPE( this->typi.dwFlags2 ) )
        {
            RPF( "Ignoring invalid type/subtype Flags2 value 0x%08x for joystick", this->typi.dwFlags2 );
        }
#endif

        if (hwc.hws.dwFlags & JOY_HWS_ISYOKE) 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_FLIGHT, DI8DEVTYPEFLIGHT_STICK);
        } 
        else if (hwc.hws.dwFlags & JOY_HWS_ISGAMEPAD) 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_GAMEPAD, DI8DEVTYPEGAMEPAD_STANDARD);
        } 
        else if (hwc.hws.dwFlags & JOY_HWS_ISCARCTRL) 
        {
            AssertF( this->dc.dwAxes > 1 );
            if ( this->dc.dwAxes <= 2 )
            {
                dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
            }
            else
            {
                dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_DUALPEDALS );
            }
        } 
        else if (hwc.hws.dwFlags & JOY_HWS_ISHEADTRACKER) 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_SUPPLEMENTAL, DI8DEVTYPESUPPLEMENTAL_HEADTRACKER);
        } 
        else 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_JOYSTICK, DI8DEVTYPEJOYSTICK_STANDARD);
        }

        /*
         *  Use the common function to make this a limited type if the 
         *  number of buttons or flags dictate it.
         *  Since the type and subtype are known to be valid, the return 
         *  value should never be a failure (zero).
         */
        this->dc.dwDevType = GetValidDI8DevType( dwTestType, this->dc.dwButtons, hwc.hws.dwFlags );
        AssertF( this->dc.dwDevType );
    }


    #undef hwc

    /*
     *  Now that we know the type, then make up a name ourselves if we 
     *  previously failed to do so.
     */
    if (this->typi.wszDisplayName[0] == TEXT('\0'))
    {
        CType_MakeGameCtrlName( this->typi.wszDisplayName, 
            this->dc.dwDevType, this->dc.dwAxes, this->dc.dwButtons, this->dc.dwPOVs );
    }


     
    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | AddObject |
 *
 *          Add one object to the device format.
 *
 *          If the device is polled, then the object is polled, too.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   PCGUID | pguid |
 *
 *          The <t GUID> that classifies the device.
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Data offset.
 *
 *  @parm   DWORD | dwDevType |
 *
 *          Device type flags to apply to the object.
 *
 *  @parm   UINT | uiObj |
 *
 *          Object instance number.
 *
 *  @parm   DWORD | dwAspect |
 *
 *          Optional <c DIDOI_ASPECT*> flag.
 *
 *****************************************************************************/

void INTERNAL
CJoy_AddObject(PDJ this, PCGUID pguid, DWORD dwOfs,
               DWORD dwDevType, UINT uiObj, DWORD dwAspect, BOOL fReal)
{
    LPDIOBJECTDATAFORMAT podf;

    podf = &this->df.rgodf[this->df.dwNumObjs++];
    podf->pguid = pguid;
    podf->dwOfs = dwOfs;
    podf->dwType = dwDevType | DIDFT_MAKEINSTANCE(uiObj);
    podf->dwFlags = dwAspect;

    if (this->dc.dwFlags & DIDC_POLLEDDEVICE) {
        podf->dwFlags |= DIDOI_POLLED;
    }

    if( fReal )
    {
        CType_RegGetTypeInfo(this->hkType, podf, FALSE);
        if( ( GET_DIDEVICE_TYPE( this->dc.dwDevType ) == DI8DEVTYPE_DRIVING )
         && ( podf->dwFlags & DIDOI_FFACTUATOR )
         && ( podf->pguid != &GUID_XAxis ) )
        {
            /*
             *  IHVs set FF attributes on non-FF axes for wheels because 
             *  first generation FF apps were only written to support joysticks.
             *  Since we now munge the various configurations of pedal axes to 
             *  report all split pedals in the same way, the fake Y axis can 
             *  land up on different axes, usually Slider0.  Rather than have 
             *  people code to these different fake axes, strip out actuator 
             *  status from any driving axis except the wheel.
             */
            podf->dwFlags &= ~DIDOI_FFACTUATOR;
            podf->dwType &= ~DIDFT_FFACTUATOR;
        }
    }
}

void INTERNAL
CJoy_BuildAxes(PDJ this, DWORD dwCaps, UINT ib, UINT uiObj, 
               DWORD dwAspect, PCAXISMAPPINGS pamap, BOOL fReal )
{
    int iaattr;

    for (iaattr = 0; iaattr < cA(c_rgaattrJoy); iaattr++) {
        PCAXISATTRIBUTES paattr = &c_rgaattrJoy[iaattr];
        if (dwCaps & paattr->dwMask) {
            CJoy_AddObject(this, pamap[iaattr].pguid, (cbX(LONG)*paattr->uidObj) + ib,
                DIDFT_ABSAXIS, paattr->uidObj + uiObj, dwAspect, fReal);
        }
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | BuildDataFormat |
 *
 *          Study the device capabilities and build the device
 *          data format.
 *
 *****************************************************************************/

void INTERNAL
CJoy_BuildDataFormat(PDJ this, PVXDAXISCAPS pvac, DWORD dwButtons, PCAXISMAPPINGS pamap, BOOL fReal)
{
    DWORD dw;

    this->dc.dwAxes = 0;
    this->dc.dwButtons = 0;
    this->dc.dwPOVs = 0;

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = sizeof(DIJOYSTATE2);
    AssertF(this->df.dwFlags == 0);
    this->df.dwNumObjs = 0;

    /*
     *  Repeat for each set of axes.
     */

    #define CheckAxisOrder(fStart, p, f)                                    \
            CAssertF(FIELD_OFFSET(DIJOYSTATE2, p##f) ==                     \
                     FIELD_OFFSET(DIJOYSTATE2, fStart) + ibJoyStateAxis##f) \

    CheckAxisOrder(lX, l, X);
    CheckAxisOrder(lX, l, Y);
    CheckAxisOrder(lX, l, Z);
    CheckAxisOrder(lX, l, Rx);
    CheckAxisOrder(lX, l, Ry);
    CheckAxisOrder(lX, l, Rz);
    CheckAxisOrder(lX, rgl, Slider);

    if (pvac->dwPos & JOYPF_POSITION) {
        CJoy_BuildAxes(this, pvac->dwPos, FIELD_OFFSET(DIJOYSTATE2, lX),
                       iobjPositions, DIDOI_ASPECTPOSITION, pamap, fReal);
    }

    CheckAxisOrder(lVX, lV, X);
    CheckAxisOrder(lVX, lV, Y);
    CheckAxisOrder(lVX, lV, Z);
    CheckAxisOrder(lVX, lV, Rx);
    CheckAxisOrder(lVX, lV, Ry);
    CheckAxisOrder(lVX, lV, Rz);
    CheckAxisOrder(lVX, rglV, Slider);

    if (pvac->dwPos & JOYPF_VELOCITY) {
        CJoy_BuildAxes(this, pvac->dwVel, FIELD_OFFSET(DIJOYSTATE2, lVX),
                       iobjVelocities, DIDOI_ASPECTVELOCITY, pamap, fReal);
    }

    CheckAxisOrder(lAX, lA, X);
    CheckAxisOrder(lAX, lA, Y);
    CheckAxisOrder(lAX, lA, Z);
    CheckAxisOrder(lAX, lA, Rx);
    CheckAxisOrder(lAX, lA, Ry);
    CheckAxisOrder(lAX, lA, Rz);
    CheckAxisOrder(lAX, rglA, Slider);

    if (pvac->dwPos & JOYPF_ACCELERATION) {
        CJoy_BuildAxes(this, pvac->dwAccel, FIELD_OFFSET(DIJOYSTATE2, lAX),
                       iobjAccels, DIDOI_ASPECTACCEL, pamap, fReal);
    }

    CheckAxisOrder(lFX, lF, X);
    CheckAxisOrder(lFX, lF, Y);
    CheckAxisOrder(lFX, lF, Z);
    CheckAxisOrder(lFX, lF, Rx);
    CheckAxisOrder(lFX, lF, Ry);
    CheckAxisOrder(lFX, lF, Rz);
    CheckAxisOrder(lFX, rglF, Slider);

    if (pvac->dwPos & JOYPF_FORCE) {
        CJoy_BuildAxes(this, pvac->dwForce, FIELD_OFFSET(DIJOYSTATE2, lFX),
                       iobjForces, DIDOI_ASPECTFORCE, pamap, fReal);
    }

    #undef CheckAxisOrder

    this->dc.dwAxes = this->df.dwNumObjs;

    /*
     *  Doing the POVs is a bit tricky but not that bad.
     */
    for (dw = 0; dw < cJoyStatePOVTotal; dw++) {
        if (pvac->dwPos & JOYPF_POV(dw)) {
            CJoy_AddObject(this, &GUID_POV,
                           FIELD_OFFSET(DIJOYSTATE2, rgdwPOV[dw]),
                           DIDFT_POV, dw, DIDOI_ASPECTUNKNOWN, fReal);
            this->dc.dwPOVs++;
        }
    }

    /*
     *  Doing the buttons is easy since they don't have
     *  any interesting attributes.
     */
    this->dc.dwButtons = min(dwButtons, cJoyStateButtonTotal);

    for (dw = 0; dw < this->dc.dwButtons; dw++) {
        CJoy_AddObject(this, &GUID_Button,
                       FIELD_OFFSET(DIJOYSTATE2, rgbButtons[dw]),
                       DIDFT_PSHBUTTON, dw, DIDOI_ASPECTUNKNOWN, fReal);
    }

    AssertF(this->df.dwNumObjs <= cJoyStateObjTotal);

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | PreInit |
 *
 *          Preallocate all the memory we will need up front, so we
 *          don't waste time reallocating later.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_PreInit(PDJ this)
{
    HRESULT hres;

    hres = ReallocCbPpv(cbCxX(cJoyStateObjTotal, DIOBJECTDATAFORMAT),
                        &this->df.rgodf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitRing0 |
 *
 *          Initialize the ring 0 information maintained about the object.
 *
 *          Broken out from CJoy_Init to make things less monolithic.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_InitRing0(PDJ this)
{
    HRESULT hres;
    VXDDEVICEFORMAT devf;

    /*
     *  Note that we now allow the device to be created even if
     *  the joystick doesn't physically exist.  This is necessary
     *  so that IDirectInputJoyConfig8 can calibrate the joystick
     *  that doesn't exist yet.
     *
     *  This won't confuse applications, however, because
     *  IDirectInput::EnumDevices will not return phantom devices
     *  unless the application explicitly asks for phantom devices
     *  to be included.
     */

    /*
     *  See if this joystick supports fancy notifications.
     *  The default is "no".
     *
     *  Also see if this is really a HID device (and hence our
     *  interface is an alias).
     *
     *  These things are all 9x-specific.
     */
#ifdef WINNT
    this->dc.dwFlags |= DIDC_POLLEDDEVICE;
#else

    VXDINITPARMS vip;

    this->dc.dwFlags |= DIDC_POLLEDDEVICE;

    hres = Hel_Joy_GetInitParms(this->idJoy, &vip);
    if (SUCCEEDED(hres)) 
    {
        if (vip.dwFlags & VIP_SENDSNOTIFY) 
        {
            this->dc.dwFlags &= ~DIDC_POLLEDDEVICE;
        }
       
        if (vip.dwFlags & VIP_ISHID) 
        {
            /*
             *  Use VJOYD as Alias if the device is HID 
             *  (the may be revised in CJoy_InitRing3).
             */
            this->dc.dwFlags |= DIDC_ALIAS;
        }
    }
#endif /* WINNT */

    this->dc.dwSize = cbX(DIDEVCAPS);

    /*
     *  Build the worst-case data format for the VxD.
     *
     *  We must always build worst-case because sometime
     *  later, a newer more capable joystick might show up,
     *  with more objects than the one we imprinted on.
     *
     *  Use the GUIDs for a joystick for now, and pass the flag 
     *  indicating that there is no need to check registry settings.
     */

    CJoy_BuildDataFormat(this, &c_vacMax, cJoyStateButtonTotal, c_rgamapJoy, FALSE);

    /*
     *  It won't actually get that high because of the
     *  nonexistent Rx and Ry axes.
     */
    AssertF(this->df.dwNumObjs <= cJoyStateObjTotal);

    devf.cbData = cbX(DIJOYSTATE2);
    devf.dwExtra = this->idJoy;
    devf.cObj = this->df.dwNumObjs;
    devf.rgodf = this->df.rgodf;
    devf.dwEmulation = 0;

    hres = Hel_Joy_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {
        AssertF(this->pvi);
        this->pjsPhys = this->pvi->pState;
    } else {                /* IOCTL failed; hres already set */
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitSemanticMap |
 *
 *          Initialize the semantic mapping information.
 *
 *****************************************************************************/

void INLINE
CJoy_GetAxisMap( PDJ this, PCAXISMAPPINGS* ppamap )
{
    if( GET_DIDEVICE_TYPEANDSUBTYPE( this->dc.dwDevType ) 
          == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_1STPERSON, DI8DEVTYPE1STPERSON_SIXDOF ) )
    {
        *ppamap = &c_rgamap6DOF[0];
    }
    else if( ( GET_DIDEVICE_TYPE( this->dc.dwDevType ) == DI8DEVTYPE_DRIVING )
          && ( this->dc.dwAxes > 2 ) )
    {
        /*
         *  There are three common forms of pedals
         *      a.  Split Y axis, below center accel, above brake
         *      b.  Y break, Z accel
         *      c.  Y accel, R brake
         *  a. is just like a joystick but b and c need their own look ups
         *
         *  Use a registry flag if one is set, otherwise, select using HASR 
         *  as there is at least one case of an X,Y,R device that reports 
         *  the presence of a bogus Z axis.
         */
        switch( this->typi.dwFlags2 & JOYTYPE_INFOMASK )
        {
        case JOYTYPE_INFOYYPEDALS:
            *ppamap = &c_rgamapJoy[0];
            break;

        case JOYTYPE_INFOZYPEDALS:
            *ppamap = &c_rgamapCarZY[0];
            break;

        case JOYTYPE_INFOYRPEDALS:
            *ppamap = &c_rgamapCarYR[0];
            break;

        case JOYTYPE_INFOZRPEDALS:
            *ppamap = &c_rgamapCarZR[0];
            break;

        default:
            if( ( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASR )
             && ( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASZ ) )
            {
                *ppamap = &c_rgamapCarZR[0];
            }
            else if( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASR )
            {
                *ppamap = &c_rgamapCarYR[0];
            }
            else if( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASZ )
            {
                *ppamap = &c_rgamapCarZY[0];
            }
            else
            {
                *ppamap = &c_rgamapJoy[0];
            }
        }
    }
    else 
    {
        /*
         *  The default map is joystick
         *
         *  Check for Z axis behavior override
         *  Since the default behavior is to use Z as a slider, 
         *  only the override to a Z axis is needed here.
         */
        if( this->typi.dwFlags2 & JOYTYPE_INFOZISZ )
        {
            *ppamap = &c_rgamapZJoy[0];
        }
        else
        {
            *ppamap = &c_rgamapJoy[0];
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitSemanticMap |
 *
 *          Initialize the semantic mapping information.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_InitSemanticMap( PDJ this, DWORD dwAxisMask, PCAXISMAPPINGS pamap )
{
    HRESULT hres;
    
    /*
     *  Prefix warns (mb:34681) that the pointer would be null if the 
     *  number of objects on the device is zero.
     *  This cannot be, so assert it but don't check in retail.
     */
    AssertF( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons != 0 );
    if( SUCCEEDED( hres = AllocCbPpv(cbCxX( 
        (this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons ), DIDOBJDEFSEM), 
        &this->rgObjSem) ) )
    {
        UINT            Idx;
        PDIDOBJDEFSEM   pObjSem = this->rgObjSem;
        LPDIOBJECTDATAFORMAT podf;

        /*
         *  The axis mapping table does most of the work
         */
        for( Idx = 0; Idx < cA(c_rgaattrJoy); Idx++ ) 
        {
            PCAXISATTRIBUTES paattr = &c_rgaattrJoy[Idx];
            if( dwAxisMask & c_rgaattrJoy[Idx].dwMask) 
            {
                pObjSem->dwID = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE(c_rgaattrJoy[Idx].uidObj);
                pObjSem->dwSemantic = pamap[Idx].dwSemantic;
                pObjSem++;
            }
        }

        AssertF( pObjSem == &this->rgObjSem[this->dc.dwAxes] );

        /*
         *  POVs and buttons require no look ups.
         */

        for( Idx = 0; Idx < this->dc.dwPOVs; Idx++ )
        {
            pObjSem->dwID = DIDFT_POV | DIDFT_MAKEINSTANCE(Idx);
            pObjSem->dwSemantic = DISEM_TYPE_POV | DISEM_INDEX_SET(Idx+1);
            pObjSem++;
        }

        AssertF( pObjSem == &this->rgObjSem[this->dc.dwAxes + this->dc.dwPOVs] );

        for( Idx = 0; Idx < this->dc.dwButtons; Idx++ )
        {
            pObjSem->dwID = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(Idx);
            pObjSem->dwSemantic = DISEM_TYPE_BUTTON | DISEM_INDEX_SET(Idx+1);
            pObjSem++;
        }

        AssertF( pObjSem == &this->rgObjSem[this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons] );

        /*
         *  Now go back to pick up any extra type bits, such as FF.
         *  Because we use the same order in creating the semantic table as 
         *  is used to create the data format, this is optimized to only 
         *  search from where the previous match was found.  We cannot rely 
         *  on a one-to-one mapping because of the non-positional axes.
         */

        podf = &this->df.rgodf[this->df.dwNumObjs];
        for( pObjSem--; pObjSem >= this->rgObjSem; pObjSem-- )
        {
            do 
            {
                podf--;
                if( ( podf->dwType & (DIDFT_INSTANCEMASK | DIDFT_TYPEMASK) ) 
                  == pObjSem->dwID )
                {
                    pObjSem->dwID = podf->dwType;
                    break;
                }
            } while( podf >= this->df.rgodf );

            AssertF( podf >= this->df.rgodf );
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitRing3 |
 *
 *          Initialize the ring 3 information maintained about the object.
 *
 *          Broken out from CJoy_Init to make things less monolithic.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_InitRing3(PDJ this )
{
    HRESULT hres;
    VXDAXISCAPS vac;
    PCAXISMAPPINGS pamap;

    /*
     *  We must ask for DIJC_CALLOUT even though we don't care,
     *  because that will trigger the Microsoft Gamepad hack-o-rama.
     */
    hres = JoyReg_GetConfig(this->idJoy, &this->cfg,
                            DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT );
    if (SUCCEEDED(hres)) {
        /*
         * Fix phantom devices bug. See manbug: 23186
         */
        if( this->cfg.hwc.dwType == JOY_HW_NONE ) {
            hres = E_FAIL;
            goto done;
        }

        /*
         *  Open the type key so we can grovel into the type info.
         *  If the RegOpenKeyEx fails, the value of this->hkType
         *  will stay zero so we won't run with garbage.
         *
         *  Note that failure to open the type key is not an error.
         *
         *  We need to do this before building the data format, because
         *  BuildDataFormat needs the hkType to get the attributes.
         */
        AssertF(this->hkType == 0);
        
        /*
         *  Only open the key if it is intended to exist
         */
        if( this->cfg.hwc.dwUsageSettings & JOY_US_ISOEM )
        {
            JoyReg_OpenTypeKey(this->cfg.wszType, MAXIMUM_ALLOWED,
                               REG_OPTION_NON_VOLATILE, &this->hkType);
        }

        if FAILED (JoyReg_OpenPropKey(this->cfg.wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkProp))
        {
            /*
             * If we fail to open the prop key - we will continue to function with loss in functionality
             * Specifically no device images, etc
             */
        }

        ZeroX(vac);

        hres = Hel_Joy_GetAxisCaps(this->idJoy, &vac, &this->cfg.hwc );
        /*
         *  HACKHACK
         *  In the case of a DX5 VJoyD, the POV0 flag can be stripped out of 
         *  the vac if the poll returns a POV0 value other than (DWORD)-1.
         *  So add it back if the registry says we have it.
         */
        if( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASPOV )
        {
            DWORD dwVersion = GetVersion();

            /*
             *  Check for any Win95 version
             */
            if( ( LOBYTE( dwVersion ) == 4 )
             && ( HIBYTE( LOWORD( dwVersion ) ) < 10 ) )
            {
                vac.dwPos |= JOYPF_POV0;
            }

        }

        AssertF(SUCCEEDED(hres));

        /*
         *  Previous versions of DInput allow a POV granularity of 1 if 
         *  joyGetCaps returned a wCaps with JOYCAPS_POV4DIR set.
         *  This does no good as neither drivers nor WinMM really 
         *  support this.  
         */
        this->dwPOVGranularity = 9000;

        /*
         *  Logical ranges must be done before physical ranges,
         *  because initializing the physical ranges will also
         *  recompute the ramp conversion parameters.
         */
        CJoy_InitLogRanges(this);

        CJoy_InitPhysRanges(this, &this->cfg.hwc);


        /*
         *  Need to init from HWC before building real data format so type 
         *  overrides can be taken into account.  Unfortunately, until the 
         *  data format is built, we don't know what axes are available.
         *  Since the code is already here, build the data format again.
         *  Use the joystick look-ups and don't bother with registry flags.
         */
        CJoy_BuildDataFormat(this, &vac, this->cfg.hwc.hws.dwNumButtons, c_rgamapJoy, FALSE );
        hres = CJoy_InitFromHwc( this );

        if( SUCCEEDED( hres ) )
        {
            CJoy_GetAxisMap( this, &pamap );
            /*
             *  At last, time to build the data format for real
             */
            CJoy_BuildDataFormat(this, &vac, this->cfg.hwc.hws.dwNumButtons, pamap, TRUE );
            hres = CJoy_InitSemanticMap( this, vac.dwPos, pamap );
        }


      #ifndef WINNT
        if( this->hkType )
        {
            DWORD dwFlags1;
            if( SUCCEEDED( JoyReg_GetValue( this->hkType,
                    REGSTR_VAL_FLAGS1, REG_BINARY, 
                    &dwFlags1, 
                    cbX(dwFlags1) ) ) )
            {
                if( dwFlags1 & JOYTYPE_NOHIDDIRECT )
                {
                    this->dc.dwFlags &= ~DIDC_ALIAS;
                }
            }
        }
      #endif

        this->diHacks.nMaxDeviceNameLength = MAX_PATH;

    } else {
        RPF("Unexpected error 0x%08x obtaining joystick capabilities",hres);
        hres = E_FAIL;
    }

done:
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the joystick capabilities.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_Init(PDJ this, REFGUID rguid)
{
    HRESULT hres;
    EnterProc(CJoy_Init, (_ "pG", this, rguid));

    this->idJoy = rguid->Data1 & 0xF;

    /* If joystick number is vaguely valid */
    if (this->idJoy < cJoyMax) {

        if (SUCCEEDED(hres = CJoy_PreInit(this)) &&
            SUCCEEDED(hres = CJoy_InitRing0(this)) &&
            SUCCEEDED(hres = CJoy_InitRing3(this))) {
        }
    } else {
        hres = DIERR_DEVICENOTREG;
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      CJoy_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Joy::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CJoy, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PDJ this = _thisPv(*ppvObj);

        if (SUCCEEDED(hres = CJoy_Init(this, rguid))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetDIData |
 *
 *          Set DirectInput version and apphack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c S_OK> because we cannot fail.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetDIData,
               (_ "pup", pdcb, dwVer, lpdihacks));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    this->dwVersion = dwVer;

    CopyMemory(&this->diHacks, (LPDIAPPHACKS)lpdihacks, sizeof(this->diHacks));

    ExitProcR();
    return S_OK;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | BuildDefaultActionMap |
 *
 *          Generate default mappings for the objects on this device.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT             hres;
    PDJ                 this;
    PDIDOBJDEFSEM       pObjDefSemTemp;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::Joy::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    /*
     *  Prefix warns (win:199090) that the pointer would be null if the 
     *  size of the semantic object list is zero.
     *  This cannot be, so assert it but don't check in retail.
     */
    AssertF( cbCxX( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons, DIDOBJDEFSEM ) );
    hres = AllocCbPpv( cbCxX( 
        ( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons ), DIDOBJDEFSEM ), 
        &pObjDefSemTemp );

    if( SUCCEEDED( hres ) )
    {
        memcpy( pObjDefSemTemp, this->rgObjSem, cbCxX( 
            ( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons ), DIDOBJDEFSEM ) );
        hres = CMap_BuildDefaultDevActionMap( paf, dwFlags, guidInst, 
            pObjDefSemTemp, this->dc.dwAxes, this->dc.dwPOVs, this->dc.dwButtons );
        FreePv( pObjDefSemTemp );
    }

    ExitOleProcR();
    return hres;
}



/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#define CJoy_Signature        0x2044424B      /* "Joy " */

Interface_Template_Begin(CJoy)
    Primary_Interface_Template(CJoy, IDirectInputDeviceCallback)
Interface_Template_End(CJoy)

Primary_Interface_Begin(CJoy, IDirectInputDeviceCallback)
    CJoy_GetInstance,
    CJoy_GetVersions,
    CJoy_GetDataFormat,
    CJoy_GetObjectInfo,
    CJoy_GetCapabilities,
    CDefDcb_Acquire,
    CDefDcb_Unacquire,
    CJoy_GetDeviceState,
    CJoy_GetDeviceInfo,
    CJoy_GetProperty,
    CJoy_SetProperty,
    CDefDcb_SetEventNotification,
    CJoy_SetCooperativeLevel,
    CJoy_RunControlPanel,
    CJoy_CookDeviceData,
    CJoy_CreateEffect,
    CJoy_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CJoy_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CJoy_SetDIData,
    CJoy_BuildDefaultActionMap,
Primary_Interface_End(CJoy, IDirectInputDeviceCallback)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\digenx.c ===
/*****************************************************************************
 *
 *  DIGenX.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for uninitialized devices.
 *
 *  Contents:
 *
 *      CNil_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflNil

/*****************************************************************************
 *
 *      Note!  This is not a normal refcounted interface.  It is
 *      a static object whose sole purpose is to keep the seat warm
 *      until the IDirectInputDevice gets Initialize()d.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *          We're not a real object, so we don't have any interfaces.
 *
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_QueryInterface(PDICB pdcb, REFIID riid, PPV ppvObj)
{
    return E_NOTIMPL;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *          We are always here, so the refcount is meaningless.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Release |
 *
 *          Increments the reference count for the interface.
 *
 *          We are always here, so the refcount is meaningless.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CNil_AddRefRelease(PDICB pdcb)
{
    return 0;
}

#define CNil_AddRef                 CNil_AddRefRelease
#define CNil_Release                CNil_AddRefRelease

/*****************************************************************************
 *
 *      You might think we could just write a bunch of stubs,
 *      <f CNil_NotInit0>,
 *      <f CNil_NotInit4>,
 *      <f CNil_NotInit8>, and so on, one for each arity, and
 *      point all of the methods at the appropriate stub.
 *
 *      However, you would be wrong.  Some processors (especially
 *      the 68k series) have weird calling conventions which depend
 *      on things other than just the number of bytes of parameters.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetInstance |
 *
 *          Called by DirectInput to obtain the DirectInput instance
 *          handle that was created by the DirectInput device driver.
 *
 *  @parm   LPVOID * | ppvInst |
 *
 *          Receives the DirectInput instance handle created by the
 *          DirectInput device driver.  This instance handle is returned
 *          to the device-specific driver, which in turn is given to
 *          the device callback via a private mechanism.
 *
 *          If the device callback does not use a device driver, then
 *          0 is returned in this variable.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_GetInstance(PDICB pdcb, LPVOID *ppvInst)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDataFormat |
 *
 *          Called by DirectInput to obtain the device's preferred
 *          data format.
 *
 *  @parm   OUT LPDIDATAFORMAT * | ppdidf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdidf)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidioiW)
{
    /*
     *  This should never happen; didev.c validates the device
     *  before calling us.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetCapabilities |
 *
 *          Obtain device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdidc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdidc)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetCapabilities.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Acquire |
 *
 *          Begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_Acquire(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until
     *  after the data format is set.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Unacquire |
 *
 *          End data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_Unacquire(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until
     *  we've acquired, which never works.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDeviceState |
 *
 *          Obtain instantaneous device state.
 *
 *  @parm   OUT LPVOID | lpvBuf |
 *
 *          Buffer to receive device state.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetDeviceState(PDICB pdcb, LPVOID lpvBuf)
{
    /*
     *  This may legitimately be called, because it happens only
     *  when the device is already acquired, which never happens.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDeviceInfo |
 *
 *          Obtain the product id.
 *
 *  @parm   LPDIDEVICEINSTANCEW | lpdidiW |
 *
 *          (out) <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW lpdidiW)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetDeviceInfo.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER lpdiph)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetProperty.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   IN LPCDIPROPHEADER | pdiph |
 *
 *          Value of property.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER lpdiph)
{
    /*
     *  This should never happen; didev.c validates the device
     *  before calling us.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetEventNotification |
 *
 *          Set the handle associated with the device.
 *
 *  @parm   HANDLE | h |
 *
 *          Handle to be signalled when new data arrives.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SetEventNotification(PDICB pdcb, HANDLE h)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::SetEventNotification.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetCooperativeLevel |
 *
 *          Set the device cooperativity level.  Device callbacks
 *          typically need only respond to the <c DISCL_EXCLUSIVE> bit.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::SetCooperativeLevel.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | RunControlPanel |
 *
 *          Run the control panel for the device.
 