  }

    if ( lpszWorkstation == NULL )
    {
        DWORD dwL = MAX_COMPUTERNAME_LENGTH+1;
        if ( !GetComputerNameW( achComputerName, &dwL ) )
        {
            return(FALSE);
        }
        lpszWorkstation = achComputerName;
    }

    //
    // Initialize LSA stuff only once
    //
    
    if ( !fLsaInitialized )
    {
        LockLogon();

        if ( !fLsaInitialized )
        {
            if ( !L32pInitLsa() )
            {
                UnlockLogon();
                return FALSE;
            }
        }

        UnlockLogon();
    }

    //
    // Validate the parameters.  NULL or empty domain or NULL or empty
    // user name is invalid.
    //

    RtlInitUnicodeString(&Username, lpszUsername);
    if (Username.Length == 0)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitUnicodeString(&Domain, lpszDomain);
    RtlInitString(&Password, lpszPassword);

    //
    // Finally, init the workstation
    //
    RtlInitUnicodeString(&Workstation, lpszWorkstation);


    //
    // Get a logon sid to refer to this guy (not that anyone will be able to
    // use it...
    //
    pLogonSid = L32CreateLogonSid(NULL);
    if (!pLogonSid)
    {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return(FALSE);
    }


    //
    // Attempt the logon
    //
    Status = L32pLogonNetUser(
                    Logon32LsaHandle,
                    Logon32MsvHandle,
                    LogonType,
                    &Username,
                    &Domain,
                    &Password,
                    &Workstation,
                    dwSubAuth,
                    pLogonSid,
                    &LogonId,
                    phToken,
                    &Logon32QuotaLimits,
                    &Profile,
                    &ProfileLength,
                    &SubStatus);

    //
    // Done with logon sid, regardless of result:
    //

    LocalFree( pLogonSid );

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_ACCOUNT_RESTRICTION)
        {
            BaseSetLastNTError(SubStatus);
        }
        else
        {
            BaseSetLastNTError(Status);
        }

        return(FALSE);
    }

    if (Profile != NULL)
    {
        if ( pExpiry != NULL )
        {
            switch ( dwLogonType )
            {
                case LOGON32_LOGON_IIS_NETWORK:
                case LOGON32_LOGON_NETWORK:
                    memcpy( pExpiry,
                            &(((PMSV1_0_LM20_LOGON_PROFILE)Profile)
                                ->LogoffTime),
                            sizeof(LARGE_INTEGER) );
                    break;

                default:
                    //
                    // if pwd never expire, MustChange.HighPart == 0x7fffffff
                    // if user cannot change pwd, CanChange == LastSet
                    //

                    if ( ((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                             ->PasswordMustChange.HighPart
                         != 0x7fffffff )
                    {
                        memcpy( pExpiry,
                                &(((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                                  ->PasswordMustChange),
                                sizeof(LARGE_INTEGER) );
                    }
                    else
                    {
                        ((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                            ->PasswordMustChange.LowPart = 0xffffffff;
                        ((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                            ->PasswordMustChange.HighPart = 0x7fffffff;
                    }
                    break;
            }
        }

        LsaFreeReturnBuffer(Profile);
    }

    return(TRUE);
}


BOOL
WINAPI
IISLogonNetUserA(
    PSTR            lpszUsername,
    PSTR            lpszDomain,
    PSTR            lpszPassword,
    PSTR            lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    UNICODE_STRING Workstation;
    NTSTATUS Status;
    BOOL    bRet;

    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Workstation.Buffer = NULL;

    if ( !RtlCreateUnicodeStringFromAsciiz(&Username, lpszUsername) )
    {
        bRet = FALSE;
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz(&Domain, lpszDomain))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    if ( lpszWorkstation )
    {
        if (!RtlCreateUnicodeStringFromAsciiz(&Workstation, lpszWorkstation))
        {
            bRet = FALSE;
            goto Cleanup;
        }
    }

    bRet = IISLogonNetUserW(
        Username.Buffer,
        Domain.Buffer,
        lpszPassword,
        Workstation.Buffer,
        dwSubAuth,
        dwLogonType,
        dwLogonProvider,
        phToken,
        pExpiry
        ) ;

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if (Workstation.Buffer)
    {
        RtlFreeUnicodeString(&Workstation);
    }

    return bRet;
}


BOOL
WINAPI
IISNetUserCookieA(
    LPSTR       lpszUsername,
    DWORD       dwSeed,
    LPSTR       lpszCookieBuff,
    DWORD       dwBuffSize
    )
/*++

Routine Description:

    Compute logon validator ( to be used as password )
    for IISSuba

Arguments:

    lpszUsername -- user name
    dwSeed -- start value of cookie

Returns:

    TRUE if success, FALSE if error

--*/
{
    UNICODE_STRING Username;
    LPWSTR lpwszUserName;
    NTSTATUS Status;
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    if ( dwBuffSize < sizeof(dwSeed)*2 + 1 )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    if ( !RtlCreateUnicodeStringFromAsciiz(&Username, lpszUsername) )
    {
        return FALSE;
    }

    lpwszUserName = Username.Buffer;
    while ( *lpwszUserName )
    {
        dwSeed = ((dwSeed << 5) | ( dwSeed >> 27 )) ^ ((*lpwszUserName++)&0xff);
    }

    RtlFreeUnicodeString(&Username);

    lpszCookieBuff[0] = '0' + IISSUBA_COOKIE;
    lpszCookieBuff[1] = '"';

    for ( UINT x = 0, y = 2 ; x < sizeof(dwSeed) ; ++x )
    {
        UINT v;
        v = ((LPBYTE)&dwSeed)[x]>>4;
        lpszCookieBuff[y++] = TOHEX( v );
        v = ((LPBYTE)&dwSeed)[x]&0x0f;
        lpszCookieBuff[y++] = TOHEX( v );
    }
    lpszCookieBuff[y] = '\0';

    return TRUE;
}


BOOL
WINAPI
IISLogonDigestUserA(
    PDIGEST_LOGON_INFO      pDigestLogonInfo,
    DWORD                   dwAlgo,
    HANDLE *                phToken
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA using Digest authentication

Arguments:

    pDigestLogonInfo - Digest parameters for use in logon
    dwAlgo - type of logon
    phToken -- created access token

Returns:

    TRUE if success, FALSE if error

--*/
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    STRING         Password;
    NTSTATUS       Status;
    BOOL           bRet;
    char           achA[3];
    int            l;

    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Password.Buffer = NULL;

    if (!RtlCreateUnicodeStringFromAsciiz(&Username, 
                                          pDigestLogonInfo->pszNtUser))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz(&Domain, 
                                          pDigestLogonInfo->pszDomain))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    achA[0] = (int)dwAlgo + '0';
    achA[1] = '"';
    achA[2] = '\0';

    l = strlen(achA) + 
        strlen(pDigestLogonInfo->pszRealm) + 
        strlen(pDigestLogonInfo->pszURI) + 
        strlen(pDigestLogonInfo->pszMethod) +
        strlen(pDigestLogonInfo->pszNonce) + 
        strlen(pDigestLogonInfo->pszCurrentNonce) + 
        strlen(pDigestLogonInfo->pszResponse) +
        strlen(pDigestLogonInfo->pszUser) + 
        strlen(pDigestLogonInfo->pszQOP) + 
        strlen(pDigestLogonInfo->pszCNonce) +
        strlen(pDigestLogonInfo->pszNC) + 
        32;
        
    if ( Password.Buffer = (CHAR*)RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, l) )
    {
        Password.MaximumLength = (USHORT)l;
    }
    else
    {
        Password.MaximumLength = 0;
    }
    Password.Length = 0;

    if( !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, achA)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszRealm)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszURI)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszMethod)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszNonce)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszCurrentNonce)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszResponse)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszUser)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszQOP)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszCNonce)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszNC)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) )
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = IISLogonNetUserW(
        Username.Buffer,
        Domain.Buffer,
        Password.Buffer,
        NULL,
        IIS_SUBAUTH_ID,
        LOGON32_LOGON_IIS_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        phToken,
        NULL
        ) ;

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if ( Password.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, Password.Buffer );
    }

    return bRet;
}

BOOL
WINAPI
IISLogonPassportUserW(
    WCHAR *                 pszUserName,
    WCHAR *                 pszDomainName,
    HANDLE *                phToken
    )
/*++

Routine Description:

    Get a passport user

Arguments:

    pszUserName - User name
    pszDomainName - Domain name
    phToken - Receives token

Returns:

    TRUE if success, FALSE if error

--*/
{

    BOOL            bRet;
    STRING          OriginName;
    NTSTATUS        Status;
    KERB_S4U_LOGON* pLogonInfo;
    ULONG           cbLogonInfo;
    STACK_BUFFER(   buffLogonInfo, 256 );
    DWORD           cchUserName;
    DWORD           cchDomainName;
    HANDLE          hToken;
    TOKEN_SOURCE    SourceContext;
    PKERB_INTERACTIVE_PROFILE pProfile = NULL;
    LUID            LogonId;
    QUOTA_LIMITS    Quotas;
    NTSTATUS        SubStatus;
    DWORD           cbProfile;

    //
    // Initialize LSA stuff only once
    //
    
    if ( !fLsaInitialized )
    {
        LockLogon();

        if ( !fLsaInitialized )
        {
            if ( !L32pInitLsa() )
            {
                UnlockLogon();
                return FALSE;
            }
        }

        UnlockLogon();
        
        DBG_ASSERT( fLsaInitialized == TRUE );
    }

    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "IIS security API");

    //
    // Determine the size of the logon buffer
    //
    
    cchUserName = wcslen( pszUserName );
    cchDomainName = wcslen( pszDomainName );
    
    cbLogonInfo = sizeof( KERB_S4U_LOGON );
    cbLogonInfo += ( cchUserName + 1 ) * sizeof( WCHAR );
    cbLogonInfo += ( cchDomainName + 1 ) * sizeof( WCHAR );

    bRet = buffLogonInfo.Resize( cbLogonInfo );
    if ( !bRet )
    {
        return FALSE;
    }
    
    pLogonInfo = (KERB_S4U_LOGON*) buffLogonInfo.QueryPtr(); 
    
    //
    // Setup the logon buffer
    //
    
    pLogonInfo->MessageType = KerbS4ULogon;
    pLogonInfo->Flags = 0;

    memcpy( pLogonInfo + 1,
            pszUserName,
            ( cchUserName + 1 ) * sizeof( WCHAR ) );
            
    memcpy( (PBYTE)( pLogonInfo + 1 ) + ( cchUserName + 1 ) * sizeof( WCHAR ),
            pszDomainName,
            ( cchDomainName + 1 ) );

    pLogonInfo->ClientUpn.Length = (USHORT) cchUserName * sizeof( WCHAR );
    pLogonInfo->ClientUpn.MaximumLength = (USHORT) cchUserName * sizeof( WCHAR );
    pLogonInfo->ClientUpn.Buffer = (WCHAR*) (pLogonInfo + 1);
    
    pLogonInfo->ClientRealm.Length = (USHORT) cchDomainName * sizeof( WCHAR );
    pLogonInfo->ClientRealm.MaximumLength = (USHORT) cchDomainName * sizeof( WCHAR );
    pLogonInfo->ClientRealm.Buffer = (WCHAR*) ((PBYTE)(pLogonInfo+1) + (cchUserName + 1)*sizeof(WCHAR));

    //
    // Do the logon
    //
    
    Status = LsaLogonUser( Logon32LsaHandle,
                           &OriginName,
                           Network,
                           Logon32KerberosHandle,
                           pLogonInfo,
                           cbLogonInfo,                   
                           NULL,
                           &SourceContext,
                           (PVOID*) &pProfile,
                           &cbProfile,
                           &LogonId,
                           &hToken,
                           &Quotas,
                           &SubStatus );

    if ( !NT_SUCCESS( Status ) )
    {
        SetLastError( Status );
        return FALSE;
    }

    DBG_ASSERT( hToken != NULL );

    *phToken = hToken;
    
    return TRUE;
}


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    TRUE if successful, FALSE if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/
BOOL
IISGetDefaultDomainName(
    CHAR  * pszDomainName,
    DWORD   cchDomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF((  DBG_CONTEXT,
                    "cannot open lsa policy, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );

        // Failure LsaOpenPolicy() does not guarantee that 
        // LsaPolicyHandle was not touched.

        LsaPolicyHandle = NULL;

        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length / sizeof(WCHAR),
                                  pszDomainName,
                                  cchDomainName - 1,    // save room for '\0'
                                  NULL,
                                  NULL );

    if( Result <= 0 )
    {
        err = GetLastError();

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot convert domain name to ANSI, error %d\n",
                     err ));

        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //


    DBG_ASSERT( (DWORD)Result < cchDomainName );

    pszDomainName[Result] = '\0';

    //
    //  Success!
    //


    DBG_ASSERT( err == 0 );

Cleanup:

    if( DomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    if ( err )
    {
        SetLastError( err );
        return FALSE;
    }

    return TRUE;

}   // IISGetDefaultDomainName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\cofact.cxx ===
#include "precomp.hxx"

CMDCOMSrvFactory::CMDCOMSrvFactory()
    :m_mdcObject()
{
    m_dwRefCount=0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_mdcObject.AddRef();
}

CMDCOMSrvFactory::~CMDCOMSrvFactory()
{
    m_mdcObject.Release();
}

HRESULT
CMDCOMSrvFactory::CreateInstance(
    IUnknown            *pUnkOuter,
    REFIID              riid,
    void                ** ppObject)
{
    HRESULT             hr = S_OK;

    // Check arguments
    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize
    *ppObject = NULL;

    // Check for aggregation
    if ( pUnkOuter != NULL )
    {
        // Aggregation is not supported by CMDCOM
        hr = CLASS_E_NOAGGREGATION;
        goto exit;
    }

    // Delegate
    hr = m_mdcObject.QueryInterface( riid, ppObject );
    if ( FAILED(hr) )
    {
        goto exit;
    }

exit:
    return hr;
}

HRESULT
CMDCOMSrvFactory::LockServer(
    BOOL                fLock)
{
    if (fLock)
    {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else
    {
        InterlockedDecrement((long *)&g_dwRefCount);
    }

    return S_OK;
}

HRESULT
CMDCOMSrvFactory::QueryInterface(
    REFIID              riid,
    void                **ppObject)
{
    HRESULT             hr = S_OK;

    // Check arguments
    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize
    *ppObject = NULL;

    if ( ( riid != IID_IUnknown ) &&
         ( riid != IID_IClassFactory ) )
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    hr = m_mdcObject.GetConstructorError();
    if ( FAILED(hr) )
    {
        goto exit;
    }

    // Return the requested inteface
    *ppObject = (IClassFactory *) this;
    AddRef();

 exit:
    // Done
    return hr;
}

ULONG
CMDCOMSrvFactory::AddRef()
{
    DWORD               dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}

ULONG
CMDCOMSrvFactory::Release()
{
    DWORD               dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
    return dwRefCount;
}

STDAPI
DllGetClassObject(
    REFCLSID        rclsid,
    REFIID          riid,
    void            ** ppObject)
{
    HRESULT         hr = S_OK;

    // Check arguments
    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize
    *ppObject = NULL;

    // Check the class id
    if ( rclsid != CLSID_MDCOM )
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto exit;
    }

    // If the class factory is NULL than we are not running in a service
    if ( g_pFactory == NULL )
    {
        hr = E_ACCESSDENIED;
        goto exit;
    }

    // Return the requested interface
    hr = g_pFactory->QueryInterface( riid, ppObject );
    if ( FAILED(hr) )
    {
        goto exit;
    }

exit:
    // Done
    return hr;
}

HRESULT _stdcall
DllCanUnloadNow()
{
    if (g_dwRefCount)
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

STDAPI
DllRegisterServer(void)
{
    HKEY                hKeyCLSID;
    HKEY                hKeyInproc32;
    DWORD               dwDisposition;
    HMODULE             hModule;
    DWORD               dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS)
    {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("MD COM Server"),
                                 sizeof(TEXT("MD COM Server")));
        if (dwReturn == ERROR_SUCCESS)
        {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                "InprocServer32",
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS)
            {
                hModule=GetModuleHandle(TEXT("METADATA.DLL"));
                if (!hModule)
                {
                    dwReturn = GetLastError();
                }
                else
                {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL)
                    {
                        dwReturn = GetLastError();
                    }
                    else
                    {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS)
                        {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if( dwReturn == ERROR_SUCCESS )
    {
        dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                  TEXT("CLSID\\{8ad3dcf8-869e-4c0e-89c2-86d7710610aa}"),
                                  NULL,
                                  TEXT(""),
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);
        if (dwReturn == ERROR_SUCCESS)
        {
            dwReturn = RegSetValueEx(hKeyCLSID,
                                     TEXT(""),
                                     NULL,
                                     REG_SZ,
                                     (BYTE*) TEXT("MD COM2 Server"),
                                     sizeof(TEXT("MD COM2 Server")));
            if (dwReturn == ERROR_SUCCESS)
            {
                dwReturn = RegCreateKeyEx(hKeyCLSID,
                    "InprocServer32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyInproc32, &dwDisposition);

                if (dwReturn == ERROR_SUCCESS)
                {
                    hModule=GetModuleHandle(TEXT("METADATA.DLL"));
                    if (!hModule)
                    {
                        dwReturn = GetLastError();
                    }
                    else
                    {
                        TCHAR szName[MAX_PATH+1];
                        if (GetModuleFileName(hModule,
                                              szName,
                                              sizeof(szName)) == NULL)
                        {
                            dwReturn = GetLastError();
                        }
                        else
                        {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT(""),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) szName,
                                                     sizeof(TCHAR)*(lstrlen(szName)+1));
                            if (dwReturn == ERROR_SUCCESS)
                            {
                                dwReturn = RegSetValueEx(hKeyInproc32,
                                                         TEXT("ThreadingModel"),
                                                         NULL,
                                                         REG_SZ,
                                                         (BYTE*) TEXT("Both"),
                                                         sizeof(TEXT("Both")));
                            }
                        }
                    }
                    RegCloseKey(hKeyInproc32);
                }
            }
            RegCloseKey(hKeyCLSID);
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

STDAPI
DllUnregisterServer(void)
{
    DWORD               dwReturn = ERROR_SUCCESS;

    dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}\\InprocServer32"));
    if (dwReturn == ERROR_SUCCESS)
    {
        dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}"));
    }

    if( dwReturn == ERROR_SUCCESS )
    {
        dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                        TEXT("CLSID\\{8ad3dcf8-869e-4c0e-89c2-86d7710610aa}\\InprocServer32"));
        if (dwReturn == ERROR_SUCCESS)
        {
            dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                        TEXT("CLSID\\{8ad3dcf8-869e-4c0e-89c2-86d7710610aa}"));
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\baseobj.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Basic Object Class for IIS MetaBase.

Author:

    Michael W. Thomas            20-May-96

Revision History:

--*/

#include "precomp.hxx"


CMDBaseObject::CMDBaseObject(
    LPSTR strName,
    LPSTR
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey();
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::CMDBaseObject(
    LPWSTR strName,
    LPWSTR
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey();
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::~CMDBaseObject()
/*++

Routine Description:

    Destructor for an object. Deletes all data and recursively deletes
    all child objects.

Arguments:

Return Value:

--*/
{
    PDATA_CONTAINER pdcIndex, pdcSave;
    PBASEOBJECT_CONTAINER pbocIndex, pbocSave;
    int i;

    for (i = 1; i < INVALID_END_METADATA; i++) {
        for (pdcIndex=m_pdcarrayDataHead[i];pdcIndex!=NULL;pdcIndex=pdcSave) {
            pdcSave=pdcIndex->NextPtr;
            DeleteDataObject(pdcIndex->pbdDataObject);
            delete(pdcIndex);
        }
    }

    if (m_phtChildren)
        delete(m_phtChildren);

    for (pbocIndex=m_pbocChildHead;pbocIndex!=NULL;pbocIndex=pbocSave) {
        pbocSave=pbocIndex->NextPtr;
        delete(pbocIndex->pboMetaObject);
        delete(pbocIndex);
    }
}



BOOL
CMDBaseObject::SetName(
    LPSTR strName,
    BOOL bUnicode
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

     BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    if (bUnicode)
        fRet = m_strMDName.SafeCopy((LPWSTR)strName);
    else
        fRet = m_strMDName.SafeCopy((LPSTR)strName);

    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



BOOL
CMDBaseObject::SetName(
    LPWSTR strName
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

    BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    fRet = m_strMDName.SafeCopy(strName);
    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



HRESULT
CMDBaseObject::InsertChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Inserts a child object into the list of child objects.

Arguments:

    Child - the object to insert.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME
--*/

{
    MD_ASSERT(pboChild != NULL);
    MD_ASSERT(pboChild->m_bufKey.QuerySize() > 0);

    HRESULT hresReturn = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER pbocNew = new BASEOBJECT_CONTAINER;

    // Bail if not enough memory.
    if (pbocNew == NULL)
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

    pbocNew->pboMetaObject = pboChild;
    pbocNew->NextPtr = NULL;
    pboChild->SetParent(this);


    hresReturn = AddChildObjectToHash(pboChild,
                                      pbocNew);

    // Attach to the chain at the end (to keep enumeration ordering)
    if (SUCCEEDED(hresReturn))
    {
        if (m_pbocChildHead == NULL)
            m_pbocChildHead = pbocNew;
        else
            m_pbocChildTail->NextPtr = pbocNew;
        m_pbocChildTail = pbocNew;

        m_cbo++;
        SetLastChangeTime();
    }
    else
        delete pbocNew;

    return(hresReturn);
}

CMDBaseObject *
CMDBaseObject::GetChildObject(
    IN OUT LPSTR &strName,
    OUT HRESULT *phresReturn,
    IN BOOL bUnicode
    )
/*++

Routine Description:

    Gets a child object by name. Updates strName to point past the end of the Name if found.

Arguments:

    Name - name of the object. End delimeter can be '\0', '\\', or '/'.

Return Value:

    CBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    CMDBaseObject *pboReturn = NULL;
    LPSTR pchDelimiter = strName;

    // Find the delimiter.  Change to terminate character.
    if (bUnicode)
    {
        LPWSTR pchDelimiterW = (LPWSTR) pchDelimiter;
        WCHAR chW;

        while ((chW = *pchDelimiterW) != MD_ALT_PATH_DELIMETERW &&
                                  chW != MD_PATH_DELIMETERW &&
                                  chW != (WCHAR)L'\0')
            {
            pchDelimiterW++;
            }
        pchDelimiter = (LPSTR) pchDelimiterW;
    }
    else
    {
        CHAR chA;

        while ((chA = *(LPSTR) pchDelimiter) != MD_ALT_PATH_DELIMETERA &&
                                         chA != MD_PATH_DELIMETERA &&
                                         chA != (CHAR) '\0')
            {
            (LPSTR) pchDelimiter = CharNextExA(CP_ACP,
                                               (LPSTR) pchDelimiter,
                                               0);
            }
    }

    // Find the child.
    pboReturn = FindChild(strName, (int)DIFF(pchDelimiter-strName), bUnicode, phresReturn);

    // If we found the name, move up the pointer to the delimiter
    if (pboReturn != NULL)
    {
        MD_ASSERT(*phresReturn == ERROR_SUCCESS);

        strName = pchDelimiter;
    }

#if 0    // SAB
    // If we didn't find the name, return the "not found" error.
    else if (*phresReturn == ERROR_SUCCESS)
    {
        *phresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }
#endif

    return(pboReturn);
}

CMDBaseObject *
CMDBaseObject::EnumChildObject(
         IN DWORD dwEnumObjectIndex
         )
/*++

Routine Description:

    Gets a child object by index.

Arguments:

    EnumObjectIndex - The 0 based index of the object to get.

Return Value:

    CMDBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    PBASEOBJECT_CONTAINER pbocCurrent;
    CMDBaseObject *pboReturn;
    DWORD i;

    for (pbocCurrent = m_pbocChildHead, i=0;
        (pbocCurrent!=NULL) && (i < dwEnumObjectIndex);
        pbocCurrent=pbocCurrent->NextPtr, i++) {
    }
    if (pbocCurrent != NULL) {
        pboReturn = pbocCurrent->pboMetaObject;
    }
    else {
        pboReturn = NULL;
    }
    return (pboReturn);
}

PBASEOBJECT_CONTAINER
CMDBaseObject::NextChildObject(
         IN PBASEOBJECT_CONTAINER pbocCurrent
         )
/*++

Routine Description:

    Given a BASEOBJECT_CONTAINER returns the next BASEOBJECT_CONTAINER in the linked list.
        Much more efficient than EnumchildObject, if the whole list is being traversed.

Arguments:

    pbocCurrent - Current container object.

Return Value:

    PBASEOBJECT_CONTAINER - The child object container or NULL if the container is not found.

Notes:

--*/
{
        if (pbocCurrent == NULL)
        {
                return m_pbocChildHead;
        }

        return pbocCurrent->NextPtr;
}


HRESULT
CMDBaseObject::RemoveChildObject(
         IN LPTSTR strName,
         IN BOOL bUnicode
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (strName != NULL);

    CMDBaseObject*          pboCurrent;
    BASEOBJECT_CONTAINER*   pbocPrev;
    HRESULT hresReturn;

    // Find the object, including the previous container.
    pboCurrent = FindChild(strName,
                           /* Length */ -1,
                           bUnicode,
                           &hresReturn,
                           /* fUseHash */ FALSE,
                           &pbocPrev);

    if (hresReturn == ERROR_SUCCESS)
    {   // Either we found it, or it's not there.  But no errors occurred.
        if (pboCurrent != NULL)
        {   // We found it.
            BASEOBJECT_CONTAINER* pbocCurrent;

            RemoveChildObjectFromHash(pboCurrent);

            // Remove from the container chain, keeping a pointer to the container to delete.
            if (pbocPrev == NULL)
            {
                pbocCurrent = m_pbocChildHead;
                MD_ASSERT(pbocCurrent != NULL);
                m_pbocChildHead = pbocCurrent->NextPtr;
                // If tail pointed to pbocCurrent, then head will become NULL,
                // in which case tail will be ignored.
            }
            else
            {
                pbocCurrent = pbocPrev->NextPtr;
                MD_ASSERT(pbocCurrent != NULL);
                pbocPrev->NextPtr = pbocCurrent->NextPtr;
                if (m_pbocChildTail == pbocCurrent)
                {
                    MD_ASSERT(pbocPrev->NextPtr == NULL);
                    m_pbocChildTail = pbocPrev;
                }
            }

            // Delete the container.  The base object itself is deleted as part of
            // CMDHandle::RemoveNotifications.
            delete pbocCurrent;

            MD_ASSERT(m_cbo != 0);
            m_cbo--;
            SetLastChangeTime();
        }

        // If FindChild() succeeded but didn't find anything, return the error.
        else
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        }
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::AddChildObjectToHash(
         IN CMDBaseObject *pboChild,
         IN BASEOBJECT_CONTAINER* pbocChild
         )
/*++

Routine Description:

    Add child object from the hash table.

Arguments:

    Child       - The object to remove.
    pbocChild   - The container for the child object. If NULL,
                  the child must already be on the child list.
                  This routine will find the child container, and will
                  not check the child list for ERROR_DUP_NAME.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME

--*/
{
    HRESULT hresReturn = NO_ERROR;
    BOOL bCheckForDups = (pbocChild == NULL) ? FALSE : TRUE;

    // Should we create the hash table now?
    if (m_phtChildren == NULL && m_cbo >= cboCreateHashThreashold)
    {   // Time to create hash table
        // Just skip if we can't create table for some reason.

        m_phtChildren = new CChildNodeHashTable;
        if (m_phtChildren != NULL)
        {   // Create successful.  Let's fill the sucker.
            BASEOBJECT_CONTAINER* pboc = m_pbocChildHead;
            while (pboc != NULL)
            {
                LK_RETCODE ret;

                MD_ASSERT(pboc->pboMetaObject != NULL);
                MD_ASSERT(pboc->pboMetaObject->m_bufKey.QuerySize() > 0);

                ret = m_phtChildren->InsertRecord(pboc,
                                                  /* fOverwrite */ FALSE);
                MD_ASSERT(ret == LK_SUCCESS);
                if (ret != LK_SUCCESS)
                {
                    delete m_phtChildren;
                    m_phtChildren = NULL;
                    break;
                }

                pboc = pboc->NextPtr;
            }
        }
    }

    // Use hash table if it exists.
    if (m_phtChildren != NULL)
    {
        LK_RETCODE ret;

        if (pbocChild == NULL) {

            //
            // Need container for insert function.
            // If it came in as NULL, then the node is not
            // really new (ie. rename) and should already be
            // on the list, so find it.
            //


            BASEOBJECT_CONTAINER* pbocIndex = m_pbocChildHead;
            while ((pbocIndex != NULL) && (pbocIndex->pboMetaObject != pboChild)) {
                pbocIndex = pbocIndex->NextPtr;
            }

            DBG_ASSERT((pbocIndex != NULL) && (pbocIndex->pboMetaObject == pboChild));
            pbocChild = pbocIndex;
        }


        // Put in hash table.  This looks for dups.
        ret = m_phtChildren->InsertRecord(pbocChild,
                                         /* fOverwrite */ FALSE);
        DBG_ASSERT( ret != LK_KEY_EXISTS);
        if (ret == LK_KEY_EXISTS)
        {
            return RETURNCODETOHRESULT(ERROR_DUP_NAME);
        }
        if (ret != LK_SUCCESS)
        {
            MD_ASSERT(ret == LK_SUCCESS);   // Put up debug assert now.
            delete m_phtChildren;
            m_phtChildren = NULL;
            goto NoHashTable;
        }
    }

    // If hash table doesn't exist, check for duplicate by searching chain.
    else
    {
NoHashTable:
        if (m_pbocChildHead != NULL && bCheckForDups)
        {
            LPSTR strChildName;

            // Check for duplicates
            strChildName = pboChild->GetName(/* bUnicode */ TRUE);
            if (strChildName == NULL)
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            else if (FindChild(strChildName,
                              /* Length */ -1,
                              /* bUnicode */ TRUE,
                              &hresReturn,
                              /* fUseHash */ FALSE,
                              NULL) != NULL)
            {
                hresReturn = RETURNCODETOHRESULT(ERROR_DUP_NAME);
            }
        }
    }

    return hresReturn;
}

VOID
CMDBaseObject::RemoveChildObjectFromHash(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the hash table.

Arguments:

    Child       - The object to remove.

Return Value:

    none

--*/
{
    // Delete from the hash table.
    if (m_phtChildren != NULL)
    {
        m_phtChildren->DeleteKey(&pboChild->m_bufKey);

        // Delete the hash table if we've gone below the threashold.
        if (m_cbo <= cboDeleteHashThreashold)
        {
            delete m_phtChildren;
            m_phtChildren = NULL;
        }
    }
}

HRESULT
CMDBaseObject::RemoveChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (pboChild != NULL);

    BASEOBJECT_CONTAINER* pbocCurrent;
    BASEOBJECT_CONTAINER* pbocPrev;
    HRESULT hresReturn;

    // Find the object in the container chain.
    pbocPrev = NULL;
    pbocCurrent = m_pbocChildHead;
    while (pbocCurrent != NULL && pbocCurrent->pboMetaObject != pboChild)
    {
        pbocPrev = pbocCurrent;
        pbocCurrent = pbocCurrent->NextPtr;
    }

    if (pbocCurrent != NULL)
    {    // Found it
        MD_ASSERT (pbocCurrent->pboMetaObject == pboChild);

        RemoveChildObjectFromHash(pboChild);

        // Remove from the container chain.
        if (pbocPrev == NULL)
        {
            m_pbocChildHead = pbocCurrent->NextPtr;
            // If tail pointed to pbocCurrent, then head will become NULL,
            // in which case tail will be ignored.
        }
        else
        {
            pbocPrev->NextPtr = pbocCurrent->NextPtr;
            if (m_pbocChildTail == pbocCurrent)
            {
                MD_ASSERT(pbocPrev->NextPtr == NULL);
                m_pbocChildTail = pbocPrev;
            }
        }

        // Delete it.  Actual base object is deleted as part of
        // CMDHandle::RemoveNotifications.
        delete pbocCurrent;
        hresReturn = ERROR_SUCCESS;

        MD_ASSERT(m_cbo != 0);
        m_cbo--;
        SetLastChangeTime();
    }
    else {
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::InsertDataObject(
         IN CMDBaseData *pbdInsert
         )
/*++

Routine Description:

    Inserts a data object into the list of data objects of that type.

Arguments:

    Data    - The data object to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_INTERNAL_ERROR

Notes:

    Does not check for duplicates. This should be checked by the calling routine.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    MD_ASSERT (pbdInsert != NULL);
    PDATA_CONTAINER *pdcHead;
    PDATA_CONTAINER pdcNew;

    pdcNew = new (DATA_CONTAINER);
    if (pdcNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        pdcHead = &(m_pdcarrayDataHead[pbdInsert->GetDataType()]);
        pdcNew->NextPtr = NULL;
        pdcNew->pbdDataObject = pbdInsert;
        if (*pdcHead == NULL) {
            *pdcHead = pdcNew;
        }
        else {
            //
            // It seems likely that the first paths read in will be the most common
            // paths, so insert at end of list
            //
            PDATA_CONTAINER pdcIndex;
            for (pdcIndex = *pdcHead;
                pdcIndex->NextPtr != NULL;
                pdcIndex = pdcIndex->NextPtr) {
            }
            MD_ASSERT(pdcIndex!=NULL);
            MD_ASSERT(pdcIndex->NextPtr==NULL);
            pdcIndex->NextPtr = pdcNew;
            if ((pbdInsert->GetAttributes() & METADATA_INHERIT) == 0) {
                m_dwNumNonInheritableData++;
            }
        }
    }
    if (SUCCEEDED(hresReturn)) {
        SetLastChangeTime();
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN CMDBaseData *pbdNew
         )
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data       - The data to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdNew != NULL);
    CMDBaseData *pbdOld = GetDataObject(pbdNew->GetIdentifier(), METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if (pbdOld == pbdNew) {
        //
        // It's already there, leave it alone.
        //
        hresReturn = ERROR_SUCCESS;
    }
    else {
        //
        // Insert the new first so if there's a problem leave the old.
        //
        hresReturn = InsertDataObject(pbdNew);
        if (SUCCEEDED(hresReturn)) {
            pbdNew->IncrementReferenceCount();
            if (pbdOld != NULL) {
                hresReturn = RemoveDataObject(pbdOld, TRUE);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN PMETADATA_RECORD pmdrMDData,
         IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data - The data to set.

        Identifier - The identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdNew;

    CMDBaseData *pbdOld = GetDataObject(pmdrMDData->dwMDIdentifier, METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if ((pbdOld != NULL) &&
        ((pbdOld->GetAttributes() & METADATA_SECURE) != 0) &&
        ((pmdrMDData->dwMDAttributes & METADATA_SECURE) == 0)) {
        hresReturn = MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE;
    }
    else {

        pbdNew = MakeDataObject(pmdrMDData, bUnicode);

        if (pbdNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (pbdOld == pbdNew) {
                //
                // It's already there, just correct the ref count,
                // which MakeDataObject incremented.
                //
                DeleteDataObject(pbdNew);
                hresReturn = ERROR_SUCCESS;
            }
            else {
                hresReturn = InsertDataObject(pbdNew);
                if (FAILED(hresReturn)) {
                    DeleteDataObject(pbdNew);
                    pbdNew = NULL;
                }
                else {
                    if (pbdOld!=NULL) {
                        //
                        // Data exists with same name.
                        // Need to delete old data.
                        //
                        hresReturn = RemoveDataObject(pbdOld, TRUE);
                        MD_ASSERT(SUCCEEDED(hresReturn));
                    }
                }
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::RemoveDataObject(
         IN CMDBaseData *pbdRemove,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Remove      - The data object to remove.

    Delete      - If true, the object is deleted.

Return Value:

    BOOL        - TRUE if the data was successfully removed.
                  FALSE if the data object is not associated with this metaobject.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdRemove != NULL);
    PDATA_CONTAINER *ppdcHead;
    PDATA_CONTAINER pdcSave;

    ppdcHead = &(m_pdcarrayDataHead[pbdRemove->GetDataType()]);
    if (*ppdcHead == NULL) {
        hresReturn = MD_ERROR_DATA_NOT_FOUND;
    }
    else {
        if ((*ppdcHead)->pbdDataObject == pbdRemove) {
            pdcSave = *ppdcHead;
            *ppdcHead = (*ppdcHead)->NextPtr;
            delete pdcSave;
            hresReturn = ERROR_SUCCESS;
        }
        else {
            PDATA_CONTAINER ppdcIndex;
            for (ppdcIndex = *ppdcHead;
                (ppdcIndex->NextPtr!=NULL) && (ppdcIndex->NextPtr->pbdDataObject!=pbdRemove);
                ppdcIndex=ppdcIndex->NextPtr) {
            }
            if (ppdcIndex->NextPtr==NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                MD_ASSERT(ppdcIndex->NextPtr->pbdDataObject == pbdRemove);
                pdcSave = ppdcIndex->NextPtr;
                ppdcIndex->NextPtr = pdcSave->NextPtr;
                delete (pdcSave);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        if ((pbdRemove->GetAttributes() & METADATA_INHERIT) == 0) {
            m_dwNumNonInheritableData--;
        }
        if (bDelete) {
            DeleteDataObject(pbdRemove);
        }
        SetLastChangeTime();
    }
    return (hresReturn);
}

CMDBaseData *
CMDBaseObject::RemoveDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Name        - The name of the data to remove.

    DataType    - Optional type of the data to remove. If specified, only data of that
                  type will be removed.

    bDelete  - If true, the object is deleted.

Return Value:

    CMDBaseData * - Pointer to the data object removed. If bDelete == TRUE, the pointer will still be
                    returned, but will not be valid.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdRemove;
    pbdRemove=GetDataObject(dwIdentifier, METADATA_NO_ATTRIBUTES, dwDataType);
    if (pbdRemove != NULL) {
        MD_REQUIRE(RemoveDataObject(pbdRemove, bDelete) == ERROR_SUCCESS);
    }
    return(pbdRemove);
}



bool
CMDBaseObject::GenerateKey()
{
    LPSTR       pstr = (LPSTR) m_strMDName.QueryStrW();

    if (pstr == NULL)
        return FALSE;

    return GenerateBufFromStr(pstr,
                              /* cch */ -1,
                              /* fUnicode */ TRUE,
                              &m_bufKey);
}



bool
CMDBaseObject::GenerateBufFromStr(
    IN const char*     pstr,
    IN int             cch,
    IN BOOL            fUnicode,
    OUT CMDKeyBuffer*  pbuf)

/*++

Routine Description:

    Fills the given buffer with the object key based on the given string.

Arguments:

    str         - The string to convert into the key.
    fUnicode    - TRUE if the string is unicode, FALSE if ansi.
    pbuf        - Pointer to the buffer that will contain the new key.

Return Value:

    BOOL        - FALSE if out-of-memory allocating the buffer.

--*/
{
    BUFFER  bufUnicode;     // Use this to hold unicode string if needed.
    int     cchRet;         // Length of actual converted string.

    MD_ASSERT(cch != 0);    // Must either be -1 or a non-null string length.

    // If not unicode, convert to unicode now.
    if (!fUnicode)
    {
        // If we know the size, guess at the unicode size.
        if (cch > 0)
            if (!bufUnicode.Resize(cch*2+50))
                return FALSE;


        // Loop until we have big enough buffer to hold unicode string
        for ( ; ; )
        {
            // Buffer length can't be zero, or MultiByteToWideChar() will
            // interpret this by returning "required buffer length" and do
            // no conversion.
            MD_ASSERT(bufUnicode.QuerySize() > 1);

            cchRet = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         pstr,
                                         cch,
                                         (LPWSTR) bufUnicode.QueryPtr(),
                                         bufUnicode.QuerySize()/2);

            // Handle error during conversion.
            if (cchRet == 0)
            {
                // If error wasn't lack of buffer, fail.
                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    return FALSE;

                // Otherwise, make the buffer larger and try again.
                /* else */
                    if (!bufUnicode.Resize(bufUnicode.QuerySize()+50))
                        return FALSE;
            }

            // Succeed, continue.
            else
                break;
        }

        // Point to the buffer now.
        pstr = (char *) bufUnicode.QueryPtr();
        cch = cchRet * 2;
    }

    // If we know the length, guess at the destination length.
    if (cch > 0)
    {
        if (!pbuf->Resize(cch))
            return FALSE;
    }

    // Otherwise, reset the length to whatever is allocated.
    else
        pbuf->SyncSize();

    // Loop until we have a buffer large enough.
    for ( ; ; )
    {
        // Buffer size can't be 0, because LCMapString will interpret
        // this by returning "required buffer length" and not actually
        // converting the string.
        MD_ASSERT(pbuf->QuerySize() > 0);
        cchRet = LCMapStringW(LOCALE_SYSTEM_DEFAULT,
                             LCMAP_UPPERCASE,
                             (LPWSTR) pstr,
                             (cch < 0) ? cch : cch/2,
                             (LPWSTR) pbuf->QueryPtr(),
                             pbuf->QuerySize()/2);

        // Handle errors
        if (cchRet == 0)
        {
            // If error wasn't lack of buffer, fail.
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                return FALSE;

            // Otherwise, make the buffer larger and try again.
            /* else */
                if (!pbuf->Resize(pbuf->QuerySize() + 50))
                    return FALSE;
        }
        else
            break;
    }

    // If last character is a null-terminator, remove it in the key.
    if (*((LPWSTR) pbuf->QueryPtr() + cchRet - 1) == (WCHAR) '\0')
        cchRet--;

    // Resize the buffer to the final length.  Length includes null-terminator.
    if (!pbuf->Resize(cchRet*2))
    {
        return FALSE;
    }

    return TRUE;
}



CMDBaseData *
CMDBaseObject::GetDataObjectByType(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    Identifier  - The identifier of the data to get.

    ListHead    - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    for (pdcIndex=m_pdcarrayDataHead[dwDataType];pdcIndex!=NULL;pdcIndex=pdcIndex->NextPtr) {
        if (dwIdentifier == pdcIndex->pbdDataObject->GetIdentifier()) {
            break;
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwAttributes,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) &&
        (dwAttributes & METADATA_INHERIT) &&
        (GetParent()!=NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetInheritableDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }

    if ((pbdReturn != NULL) &&
        ((pbdReturn->GetAttributes() & METADATA_INHERIT) == 0)) {
        pbdReturn = NULL;
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) && (GetParent() != NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *dataReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL) && dwEnumDataIndex != 0;
            pdcIndex=pdcIndex->NextPtr, dwEnumDataIndex--) {
        }
    }
    else {
        for (pdcIndex=m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        dataReturn = pdcIndex->pbdDataObject;
    }
    return (dataReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObject(
         IN DWORD dwEnumDataIndex,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Enumerates a data object.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    PVOID *ppvMainDataBuf;
    DWORD dwNumBufferEntries;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, i);
        }
    }
    else {
        pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, dwDataType);
    }

    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }

    if ((pbdReturn == NULL) && (dwAttributes & METADATA_INHERIT) && (GetParent() != NULL)) {
        //
        // Not in current object and inherited data is specified.
        // Build list of data objects in current meta object,
        // and call parent for inherited data.
        //
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumBufferEntries = 0;
        CopyDataObjectsToBuffer(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, FALSE, FALSE);
        pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                           dwUserType,
                                                           dwDataType,
                                                           ppvMainDataBuf,
                                                           dwNumBufferEntries,
                                                           ppboAssociated);
        FreeMainDataBuffer(ppvMainDataBuf);
    }

    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries)
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

    MainDataBuf   - The buffer filled with previously enumerated values.

    NumBufferEntries - The number of entries in MainDataBuf.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;
    BOOL                bRet;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    bRet = InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries);
                    MD_ASSERT(bRet);
                    if (!bRet) {
                        pdcIndex = NULL;
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType() &&
                ((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    bRet = InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries);
                    MD_ASSERT(bRet);
                    if (!bRet) {
                        pdcIndex = NULL;
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         DWORD &dwEnumDataIndex,
         DWORD dwUserType,
         DWORD dwDataType,
         CMDBaseObject **ppboAssociated)
{
    PVOID *ppvMainDataBuf = GetMainDataBuffer();
    DWORD dwNumBufferEntries = 0;
    CMDBaseData *pbdReturn;

    MD_ASSERT(ppvMainDataBuf != NULL);
    pbdReturn = EnumInheritableDataObject(dwEnumDataIndex,
                                            dwUserType,
                                            dwDataType,
                                            ppvMainDataBuf,
                                            dwNumBufferEntries,
                                            ppboAssociated);
    FreeMainDataBuffer(ppvMainDataBuf);

    return(pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         IN OUT DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         CMDBaseObject **ppboAssociated)
{
   CMDBaseData *pbdReturn = NULL;
   DWORD i;

   if (dwDataType == ALL_METADATA) {
       for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
           pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                       dwUserType,
                                                       i,
                                                       ppvMainDataBuf,
                                                       dwNumBufferEntries);
       }
   }
   else {
       pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                   dwUserType,
                                                   dwDataType,
                                                   ppvMainDataBuf,
                                                   dwNumBufferEntries);
   }

   if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
       //
       // Found data in this object
       //
       *ppboAssociated = this;
   }
   if ((pbdReturn == NULL) && (GetParent() != NULL)) {
       //
       // Not in current object.
       // Call parent for inherited data.
       //
       pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                            dwUserType,
                                                            dwDataType,
                                                            ppvMainDataBuf,
                                                            dwNumBufferEntries,
                                                            ppboAssociated);
   }

   return (pbdReturn);
}

VOID
CMDBaseObject::CopyDataObjectsToBufferByType(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly,
         IN BOOL bNonSecureOnly)
/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    ListHead      - The list of data objects.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.
    
    bNonSecureOnly - If TRUE, then only retrieve non-secure properties

Return Value:

--*/

{
    PDATA_CONTAINER pdcIndex;
    BOOL            bRet;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if ((!bInheritableOnly) ||
                (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){
                
                if (bNonSecureOnly && pdcIndex->pbdDataObject->GetAttributes() & METADATA_SECURE) {
                    continue;
                }

                bRet = InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries);
                MD_ASSERT(bRet);
                if (!bRet) {
                    break;
                }
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if ((!bInheritableOnly) ||
                    (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                    !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){

                    if (bNonSecureOnly && pdcIndex->pbdDataObject->GetAttributes() & METADATA_SECURE) {
                        continue;
                    }
                
                    bRet = InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries);
                    MD_ASSERT(bRet);
                    if (!bRet) {
                        break;
                    }
                }
            }
        }
    }
}

VOID
CMDBaseObject::CopyDataObjectsToBuffer(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly,
         IN BOOL bNonSecureOnly)

/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    DataType      - Optional UserType of the data to copy.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.

    bNonSecureOnly - If TRUE, then copy only non-secure properties

Return Value:

--*/
{
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; i < INVALID_END_METADATA; i++) {
            CopyDataObjectsToBufferByType(dwUserType, i, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly, bNonSecureOnly);
        }
    }
    else {
        CopyDataObjectsToBufferByType(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly, bNonSecureOnly);
    }
}

DWORD
CMDBaseObject::GetAllDataObjects(
         OUT PVOID *ppvMainDataBuf,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN BOOL bInheritableOnly,
         IN BOOL bNonSecureOnly
         )
/*++

Routine Description:

    Gets all data objects which match the criteria specified by the parameters.

Arguments:

    MainDataBuf   - The buffer to store the data objects in.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

    bInheritableOnly - If TRUE, only gets data objects that are
                       inheritable and not already in the buffer.

    bNonSecureOnly - If TRUE, only copy non-secure properties

Return Value:

    DWORD         - Number of Data Objects in Buffer.

--*/
{
    DWORD dwNumBufferEntries;
    CMDBaseObject *objIndex;

    //
    // Not in current object and inherited data is specified.
    // Build list of data objects in current meta object,
    // and call parent for inherited data.
    //
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumBufferEntries = 0;
    CopyDataObjectsToBuffer(dwUserType,
                            dwDataType,
                            ppvMainDataBuf,
                            dwNumBufferEntries,
                            bInheritableOnly,
                            bNonSecureOnly);
    if (dwAttributes & METADATA_INHERIT) {
        for (objIndex = GetParent(); objIndex != NULL; objIndex = objIndex->GetParent()) {
            objIndex->CopyDataObjectsToBuffer(dwUserType,
                                              dwDataType,
                                              ppvMainDataBuf,
                                              dwNumBufferEntries,
                                              TRUE,
                                              bNonSecureOnly);
        }
    }
    return (dwNumBufferEntries);
}

HRESULT
CMDBaseObject::GetDataRecursive(
         IN OUT BUFFER *pbufMainDataBuf,
         IN DWORD dwMDIdentifier,
         IN DWORD dwMDDataType,
         IN OUT DWORD &rdwNumMetaObjects)
{
    CMDBaseObject *pboChild;
    DWORD i;
    MD_ASSERT (pbufMainDataBuf != NULL);
    HRESULT hresReturn = ERROR_SUCCESS;


    if (GetDataObject(dwMDIdentifier,
                      METADATA_NO_ATTRIBUTES,
                      dwMDDataType,
                      NULL) != NULL) {
        DWORD dwSize = sizeof(CMDBaseObject *) * (rdwNumMetaObjects + 1);
        if (pbufMainDataBuf->QuerySize() < dwSize) {
            if (!pbufMainDataBuf->Resize(dwSize + (sizeof(CMDBaseObject *) * 1000))) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            ((CMDBaseObject **)(pbufMainDataBuf->QueryPtr()))[rdwNumMetaObjects++] = (CMDBaseObject *)this;
        }
    }

    for (i = 0;
         SUCCEEDED(hresReturn) &&
             (pboChild = EnumChildObject(i)) != NULL;
         i++) {
        hresReturn = pboChild->GetDataRecursive(pbufMainDataBuf,
                                                dwMDIdentifier,
                                                dwMDDataType,
                                                rdwNumMetaObjects);
    }

    return hresReturn;
}

VOID
CMDBaseObject::SetLastChangeTime(PFILETIME pftLastChangeTime)
{
    if (pftLastChangeTime != NULL) {
        m_ftLastChangeTime = *pftLastChangeTime;
    }
    else {
        GetSystemTimeAsFileTime(&m_ftLastChangeTime);
    }
}

PFILETIME
CMDBaseObject::GetLastChangeTime()
{
    return &m_ftLastChangeTime;
}

DWORD
CMDBaseObject::GetObjectLevel()
{
    DWORD dwLevel = 0;

    if (m_pboParent != NULL) {
        dwLevel = m_pboParent->GetObjectLevel() + 1;
    }

    return dwLevel;
}

BOOL
CMDBaseObject::IsDataInBuffer(
         IN DWORD dwIdentifier,
         IN PVOID *ppvMainDataBuf)
/*++

Routine Description:

    Checks if the buffer contains an object with the specified id.

Arguments:

    Identifier    - The id to check for.

    MainDataBuf   - The buffer to search.

Return Value:

    BOOL          - TRUE if the buffer contains data with the specified id.

--*/
{
    BOOL bReturn = FALSE;
    DWORD i;
    CMDBaseData *pbdDataObject;
    for (i = 0;
        (pbdDataObject = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i)) != NULL;
        i++) {
        if (pbdDataObject->GetIdentifier() == dwIdentifier) {
            bReturn = TRUE;
            break;
        }
    }
    return (bReturn);
}

#if 0   // No longer used.  /SAB

BOOL
CMDBaseObject::CompareDelimitedString(
         IN LPTSTR strNonDelimitedString,
         IN OUT LPTSTR &strDelimitedString,
         IN BOOL bUnicode)
/*++

Routine Description:

    Compared a nondelimeted string to a delimeted string.
    Updates Delimited String on success to point past the string.

Arguments:

    NonDelimiterString - The nondelimited string.

    DelimiterString - The delimited string.

Return Value:

    BOOL          - TRUE if strings are the same.

--*/
{
    LPTSTR i,j;
    BOOL RetCode = FALSE;
    j = strDelimitedString;
    DWORD dwStringLen;

/*

    //
    // Change in semantics. To differentiate between "/" and "//",
    // the leading delimeter is skipped before we get here.
    //
    // Skip leading delimeter, if any
    //
    if ((*j == MD_PATH_DELIMETER) || (*j == MD_ALT_PATH_DELIMETER)) {
        j++;
    }
*/

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (_wcsnicmp((LPWSTR)strDelimitedString, (LPWSTR)strNonDelimitedString, dwStringLen) == 0) {
            if (((*((LPWSTR)strDelimitedString + dwStringLen)==MD_ALT_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)==MD_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)== (WCHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStringLen * sizeof(WCHAR);    //Point to next section or \0
            }
        }
    }
    else {
        dwStringLen = MD_STRLEN(strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (MD_STRNICMP(strDelimitedString, strNonDelimitedString, dwStringLen) == 0) {
            DWORD dwStrBytes = MD_STRBYTES(strNonDelimitedString);
            if (((*(strDelimitedString + dwStrBytes)==MD_ALT_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)==MD_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)== (CHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStrBytes;    //Point to next section or \0
            }
        }
    }
    return (RetCode);
}

#endif


CMDBaseObject*
CMDBaseObject::FindChild(
LPSTR                   szName,     // Name of child to find.
int                     cchName,    // Length of the name.
BOOL                    fUnicode,   // TRUE if unicode name.
HRESULT*                phresult,   // Result code.
BOOL                    fUseHash,   // Allow use of hash table
BASEOBJECT_CONTAINER**  ppbocPrev)  // If non-NULL & !fUseHash, prev. object container in list.
{
    UCHAR                   localBufferForBufKey[SIZE_FOR_ON_STACK_BUFFER];
    CMDKeyBuffer            bufKey (localBufferForBufKey,SIZE_FOR_ON_STACK_BUFFER);
    BASEOBJECT_CONTAINER*   pbocCurrent = NULL;

    MD_ASSERT(phresult != NULL);

    //
    // Trap case of being called with an empty path segment.
    // GenerateBufFromStr should not be called with cch == 0
    //
    if( cchName == 0 )
    {
        *phresult = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        return NULL;
    }

    // Convert the given string to a key.
    if (!GenerateBufFromStr(szName, cchName, fUnicode, &bufKey))
        {
        *phresult = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
        }

    // Use hash table if it exists and we are allowed to.
    if (fUseHash && m_phtChildren != NULL)
    {
        m_phtChildren->FindKey(&bufKey, &pbocCurrent);
    }

    // Otherwise use brute force linear search.
    else
    {
        BASEOBJECT_CONTAINER* pbocPrev = NULL;

        pbocCurrent = m_pbocChildHead;
        while (pbocCurrent != NULL &&
               !FCompareKeys(&bufKey, &pbocCurrent->pboMetaObject->m_bufKey))
        {
            pbocPrev = pbocCurrent;
            pbocCurrent = pbocCurrent->NextPtr;
        }

        if (ppbocPrev != NULL)
            *ppbocPrev = pbocPrev;
    }

    *phresult = ERROR_SUCCESS;

    if (pbocCurrent != NULL)
        return pbocCurrent->pboMetaObject;
    /* else */
        return NULL;
}

void CMDBaseObject::CascadingDataCleanup()
/*++

Routine Description:

    Deletes all data and recursively deletes all data of child objects.

Arguments:

Return Value:

--*/
{
    PDATA_CONTAINER pdcIndex, pdcSave;
    PBASEOBJECT_CONTAINER pbocIndex, pbocSave;
    int i;

    for (i = 1; i < INVALID_END_METADATA; i++) {
        for (pdcIndex=m_pdcarrayDataHead[i];pdcIndex!=NULL;pdcIndex=pdcSave) {
            pdcSave=pdcIndex->NextPtr;
            delete(pdcIndex);
        }
        m_pdcarrayDataHead[i] = NULL;
    }

    for (pbocIndex=m_pbocChildHead;pbocIndex!=NULL;pbocIndex=pbocSave) {
        pbocSave=pbocIndex->NextPtr;
        pbocIndex->pboMetaObject->CascadingDataCleanup();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\cbin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    cbin.cxx

    This module contains a light weight binary class


    FILE HISTORY:
        MichTh      17-May-1996 Created, based on string.cxx
*/


#include "precomp.hxx"

//
//  Private Definations
//

/*******************************************************************

    NAME:       CBIN::CBIN

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/


CBIN::CBIN( DWORD cbLen, const PVOID pbInit )
{
    AuxInit(cbLen, pbInit);
}

CBIN::CBIN( const CBIN & cbin )
{
    AuxInit(cbin.QueryCB(), cbin.QueryPtr());
}

VOID CBIN::AuxInit( DWORD cbLen, PVOID pbInit)
{
    BOOL fRet;

    _fValid   = TRUE;

    if ( pbInit )
    {
        fRet = Resize( cbLen );


        if ( !fRet )
        {
            _fValid = FALSE;
            return;
        }

        SetCB(cbLen);
        ::memcpy( QueryPtr(), pbInit, cbLen );
    }
    else {
        SetCB(0);
    }
}

/*******************************************************************

    NAME:       CBIN::Append

    SYNOPSIS:   Appends the buffer onto this one.

    ENTRY:      Object to append

    NOTES:

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL CBIN::Append( DWORD cbLen, const PVOID pbBuf )
{
    if ( pbBuf )
    {

        return AuxAppend(pbBuf, cbLen);
    }

    return TRUE;
}

BOOL CBIN::Append( const CBIN   & cbin )
{
        return Append(cbin.QueryCB(), cbin.QueryPtr());
}

BOOL CBIN::AuxAppend( PVOID pbBuf, UINT cbLen, BOOL )
{
    DBG_ASSERT( pbBuf != NULL );

    UINT cbThis = QueryCB();

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbLen)
    {
        if ( !Resize( cbThis + cbLen) )
            return FALSE;
    }

    SetCB(cbThis + cbLen);
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pbBuf,
            cbLen);

    return TRUE;
}

/*******************************************************************

    NAME:       CBIN::Copy

    SYNOPSIS:   Copies the string into this one.

    ENTRY:      Object to Copy

    NOTES:      A copy is a special case of Append so we just zero terminate
                *this and append the string.

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL CBIN::Copy( DWORD cbLen, const PVOID pbBuf )
{
    SetCB(0);

    if ( pbBuf )
    {
        return AuxAppend( pbBuf, cbLen, FALSE );
    }

    return TRUE;
}

BOOL CBIN::Copy( const CBIN   & cbin )
{
    if ( cbin.IsEmpty()) {
        // To avoid pathological allocation of small chunk of memory
        SetCB(0);
        return ( TRUE);
    }

    return Copy( cbin.QueryCB(), cbin.QueryPtr() );
}

/*******************************************************************

    NAME:       CBIN::Resize

    SYNOPSIS:   Resizes or allocates string memory, NULL terminating
                if necessary

    ENTRY:      cbNewRequestedSize - New string size

    NOTES:

    HISTORY:
        Johnl   12-Sep-1994     Created

********************************************************************/

BOOL CBIN::Resize( UINT cbNewRequestedSize )
{
    if ( !BUFFER::Resize( cbNewRequestedSize ))
        return FALSE;

    return TRUE;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\comobj.cxx ===
#include "precomp.hxx"

CIdToPointerMapper  *g_PointerMapper = NULL;


CMDCOM::CMDCOM():
    m_ImpIConnectionPointContainer(),
    m_hresConstructorError(ERROR_SUCCESS)
{
    UINT i;

    m_dwRefCount = 0;
    g_hReadSaveSemaphore = NULL;

    g_PointerMapper = new CIdToPointerMapper (DEFAULT_START_NUMBER_OF_MAPS, DEFAULT_INCREASE_NUMBER_OF_MAPS);
    MD_ASSERT(g_PointerMapper);

    fFlusherInitialized = FALSE;
    dwMBFlushCookie = 0;
    msMBFlushTime = INETA_MB_FLUSH_DEFAULT;
    INITIALIZE_CRITICAL_SECTION( &csFlushLock );
    INITIALIZE_CRITICAL_SECTION( &g_csEditWhileRunning );


    // Null all entries in the connection point array.
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
      m_aConnectionPoints[i] = NULL;

    HRESULT hr = NOERROR;

    g_hReadSaveSemaphore = IIS_CREATE_SEMAPHORE(
                               "g_hReadSaveSemaphore",
                               &g_hReadSaveSemaphore,
                               1,
                               1
                               );

    if( g_hReadSaveSemaphore == NULL ) {
        hr = GetLastHResult();
        IIS_PRINTF((buff,"CreateSemaphore Failed with %x\n",hr));
    }
    else {

        COConnectionPoint* pCOConnPt;

        m_ImpIConnectionPointContainer.Init(this);
        // Rig this COPaper COM object to be connectable. Assign the connection
        // point array. This object's connection points are determined at
        // compile time--it currently has 2 connection points, one for ANSI,
        // one for UNICODE. Create a connection
        // point object for these and assign them into the array. This array could
        // easily grow to support additional connection points in the future.

        // First try creating a new connection point object. Pass 'this' as the
        // pHostObj pointer used by the connection point to pass its AddRef and
        // Release calls back to the host connectable object.
        pCOConnPt = new COConnectionPoint((IUnknown*)this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_A);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
          {
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A]);
            MD_ASSERT(SUCCEEDED(hr));
          }
          if( FAILED(hr) )
          {
            delete pCOConnPt;
          }
        }
        pCOConnPt = new COConnectionPoint((IUnknown*)this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_W);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
          {
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W]);
            MD_ASSERT(SUCCEEDED(hr));
          }
          if( FAILED(hr) )
          {
            delete pCOConnPt;
          }
        }
    }
    m_hresConstructorError = hr;
}

CMDCOM::~CMDCOM()
{
//    SetEvent(hevtDone);
    UINT i;
    IConnectionPoint* pIConnectionPoint;
    // Do final release of the connection point objects.
    // If this isn't the final release, then the client has an outstanding
    // unbalanced reference to a connection point and a memory leak may
    // likely result because the host COPaper object is now going away yet
    // a connection point for this host object will not end up deleting
    // itself (and its connections array).
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
    {
      pIConnectionPoint = m_aConnectionPoints[i];
      RELEASE_INTERFACE(pIConnectionPoint);
    }

    if (g_hReadSaveSemaphore != NULL) {
        CloseHandle(g_hReadSaveSemaphore);
    }
    DeleteCriticalSection( &csFlushLock );
    DeleteCriticalSection( &g_csEditWhileRunning );
    MD_ASSERT(g_PointerMapper);
    delete g_PointerMapper;

}

HRESULT
CMDCOM::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOM) {
        *ppObject = (IMDCOM *) this;
        AddRef();
    }
    else if ( IID_IMDCOM2 == riid )
    {
        *ppObject = (IMDCOM2 *) this;
        AddRef();
    }
    else if ( IID_IMDCOM3 == riid )
    {
        *ppObject = (IMDCOM3 *) this;
        AddRef();
    }
    else if (IID_IConnectionPointContainer == riid) {
      *ppObject = &m_ImpIConnectionPointContainer;
      AddRef();
    }
    else {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

ULONG
CMDCOM::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CMDCOM::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}

HRESULT
CMDCOM::ComMDInitialize()
/*++

Routine Description:

    Initializes the metadata database. This must be called before any other API.
    Reads in the existing database, if found. If errors occur reading in the
    existing database, warnings are returned and the metabase is initialized
    with not data.

Arguments:

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            ERROR_ALREADY_INITIALIZED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_INVALID_DATA
            MD_WARNING_PATH_NOT_FOUND
            MD_WARNING_DUP_NAME
            MD_WARNING_INVALID_DATA

Notes:
    This could take a long time to process, as it may load in a large amount of data.
    If a warning code is returned, the database has been successfully initialized, but
    some data in the database was not loaded successfully.

--*/
{
    InitializeFlusher ();
    return InitWorker(FALSE, NULL, NULL, NULL);
}

HRESULT
CMDCOM::ComMDTerminate(IN BOOL)
/*++

Routine Description:

    DeInitailizes the metadata database. This must be before the application terminates
    or dunloads the dll.

Arguments:

    SaveData      - If TRUE, the metadata is saved before terminating.
                    If the save fails, the metadata is not terminated.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_NOT_ENOUGH_MEMORY
              Errors from the file system.

Notes:
    This could take a long time to process, as it may save a large amount of data.

--*/
{
    HRESULT         hr;

    hr = TerminateWorker1(FALSE);

    return hr;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSendShutdownNotifications(VOID)
/*++
Routine Description:
    Sends the shutdown notifications.

Arguments:
    None

Return Value:
    HRESULT
--*/
{
    HRESULT             hr = S_OK;

    SendShutdownNotifications();

    return hr;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDShutdown( void)
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;

    TerminateFlusher();

    //
    // Give applications some time to close their interfaces,
    // but don't wait too long, user is waiting.
    // Wait until references are closed, unless they take too long.
    // IISADMIN and factory both have refences we do not wait for.
    //

    //
    // Note, there are four references to the CMDCOM object that
    // are allowed to be active after this point.
    // 1)  The reference taken in dllmain ( cleans up in dllmain ).
    // 2)  The reference owned by COADMIN itself
    //     ( this is called as part of it's shutdown )
    // 3)  The reference owned by the MDWriter for backup and restore
    //     ( it is released after TerminateComAdmindata is called )
    // 4)  The reference owned by the Metabase holder,
    //     which is used to validate that the metabase is up
    //     and working if iisadmin is started.
    //     ( it is also released after the TerminateComAdmindata is called )
    //
    for (int i = 0;
         (InterlockedIncrement((long *)&m_dwRefCount) > 5) &&
             (i < MD_SHUTDOWN_WAIT_SECONDS);
         i++) {
        InterlockedDecrement((long *)&m_dwRefCount);
        Sleep(1000);
    }

    InterlockedDecrement((long *)&m_dwRefCount);

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {

        //
        // Need to hold a read lock here to make sure
        // Terminate doesn't occur during SaveAllData.
        //
        // Cannot hold a write lock, as SaveAllData gets
        // a read lock after getting ReadSaveSemaphore
        //

        g_LockMasterResource.ReadLock();

        if (g_dwInitialized > 0) {
            hresReturn = SaveAllData(TRUE, &CryptoStorage, pSessionKeyBlob);
        }
        else {
            if (g_dwInitialized > 0) {
                MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
                g_bSaveDisallowed = TRUE;
                MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
            }
            else {
                g_bSaveDisallowed = TRUE;
            }
        }
        g_LockMasterResource.ReadUnlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               pszMDPath,
                               FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               (PBYTE) pszMDPath,
                               TRUE);
}

HRESULT
CMDCOM::ComMDAddMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Creates a meta object and adds it to the list of child objects for the object specified by Path.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path  - Path of the object to be added, relative to the path of Handle.
            Must not be NULL.
            eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME
            ERROR_INVALID_NAME

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    CMDHandle *hHandleObject;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        WCHAR strPath[METADATA_MAX_NAME_LEN];
        LPSTR pszTempPath = (LPSTR)pszMDPath;

        //
        // ExtractNameFromPath assumes no preceding delimeter
        //

        if (pszTempPath != NULL) {
            SkipPathDelimeter(pszTempPath, bUnicode);
        }

        //
        // Make sure at least one new object was specified
        //

        hresReturn = ExtractNameFromPath(pszTempPath,
                                         (LPSTR)strPath,
                                         bUnicode);

        if (FAILED(hresReturn)) {
            hresReturn = E_INVALIDARG;
        }
        else {
            g_LockMasterResource.WriteLock();

            hHandleObject = GetHandleObject(hMDHandle);

            if(hHandleObject != NULL)
            {
                hresReturn = AddObjectToDataBase(hMDHandle,
                                                 hHandleObject,
                                                (LPSTR)pszMDPath,
                                                bUnicode);
                if (SUCCEEDED(hresReturn)) {
                    g_dwSystemChangeNumber++;

                    INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                                   hHandleObject,
                                                   (LPSTR)pszMDPath,
                                                   bUnicode);
                }
            }
            else
            {
                hresReturn = E_HANDLE;
            }
            g_LockMasterResource.WriteUnlock();
        }
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  TRUE);
}

HRESULT
CMDCOM::ComMDDeleteMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a meta object and all of its data. Recursively deletes all descendants.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of object to be deleted, relative to the path of Handle.
           Must not be NULL.
           eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDPath == NULL) {
       hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.WriteLock();

        CMDHandle *hMDHandleObject = GetHandleObject(hMDHandle);

        if(hMDHandleObject != NULL)
        {
            hresReturn = RemoveObjectFromDataBase(hMDHandle,
                                                  hMDHandleObject,
                                                  (LPSTR)pszMDPath,
                                                  bUnicode);
        }
        else
        {
            hresReturn = E_HANDLE;
        }

        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;

            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                           hMDHandleObject,
                                           (LPSTR)pszMDPath,
                                           bUnicode);
        }
        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        pszMDPath,
                                        FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        (PBYTE)pszMDPath,
                                        TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes all child meta objects of the specified object, with all of their
    data. Recursively deletes all descendants of the child objects.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of the parent of the objects to be deleted, relative to the path of Handle.
           eg. "Root Object/Child"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    CMDBaseObject *pboParent;
    CMDBaseObject *pboChild;
    CMDHandle *phoHandle;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        g_LockMasterResource.WriteLock();
        hresReturn = GetObjectFromPath(pboParent, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            phoHandle = GetHandleObject(hMDHandle);
            MD_ASSERT (phoHandle != NULL);
            while ((pboChild = pboParent->EnumChildObject(0)) != NULL) {
                MD_REQUIRE(pboParent->RemoveChildObject(pboChild) == ERROR_SUCCESS);
                if (phoHandle->SetChangeData(pboChild, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                    delete(pboChild);
                }
            }
            g_dwSystemChangeNumber++;

            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                           phoHandle,
                                           (LPSTR)pszMDPath,
                                           bUnicode);
        }
        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 pszMDPath,
                                 pszMDName,
                                 dwMDEnumObjectIndex,
                                 FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 (PBYTE)pszMDPath,
                                 (PBYTE)pszMDName,
                                 dwMDEnumObjectIndex,
                                 TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
        /* [in] */ DWORD dwMDEnumObjectIndex,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all child metaobjects once per call. Child Objects are numbers from 0 to NumObjects - 1, where
    NumObjects is the number of current child objects. If EnumObjectIndex is >= NumObjects, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path - Path of parent object, relative to the path of Handle.
           eg. "Root Object/Child/GrandChild"
    Name - Buffer where the Name of the object is returned. Must be at least METADATA_MAX_NAME_LEN characters long.

    EnumObjectIndex - Index of the value to be retrieved. The caller is expected to set this to 0 before the first call and increment
           it by 1 on each successive call until ERROR_NO_MORE_ITEMS is returned.
Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_PATH_NOT_FOUND
            ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDName == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        g_LockMasterResource.ReadLock();
        CMDBaseObject *pboAffected, *pboChild;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if ( SUCCEEDED(hresReturn) && ( pboAffected == NULL ) )
        {
            hresReturn = E_FAIL;
        }
        if (SUCCEEDED(hresReturn)) {
            pboChild = pboAffected->EnumChildObject(dwMDEnumObjectIndex);
            if (pboChild != NULL) {
                PVOID pvName = (PVOID)pboChild->GetName(bUnicode);
                if (pvName == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = ERROR_SUCCESS;

                    if (bUnicode) {
                        if( wcslen( (LPWSTR)pvName ) < METADATA_MAX_NAME_LEN )
                        {
                            wcscpy((LPWSTR)pszMDName, (LPWSTR)pvName);
                        }
                        else
                        {
                            hresReturn = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
                        }
                    }
                    else {
                        if( strlen( (LPSTR)pvName ) < METADATA_MAX_NAME_LEN )
                        {
                            MD_STRCPY((LPSTR)pszMDName, (LPSTR)pvName);
                        }
                        else
                        {
                            hresReturn = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
                        }
                    }
                }
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                pszMDSourcePath,
                                hMDDestHandle,
                                pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                (PBYTE)pszMDSourcePath,
                                hMDDestHandle,
                                (PBYTE)pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ BOOL bMDOverwriteFlag,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves Source meta object and it's data and descendants to Dest. The
    copied object is a child of Dest.

Arguments:

    SourceHandle - The handle or the object to be copied. If copyflag is specified, read permission
                   is requried. If not, read/write permission is required.

    SourcePath  - Path of the object to be copied, relative to the path of SourceHandle.
            eg. "Root Object/Child/GrandChild"

    DestHandle - The handle of the new location for the object. Write permission is required.

    DestPath  - The path of the new location for the object, relative to the path of
            DestHandle. The new object will be a child of the object specified by
            DestHandle/DestPath. Must not be a descendant of SourceHandle/SourePath.
            eg. "Root Object/Child2"

    OverwriteFlag - Determines the behavior if the a meta object with the same name as Source is
            already a child of Dest.
            If TRUE, the existing object and all of its data and
            descandants are deleted prior to copying/moving Source.
            If FALSE, the existing object, data, and descendants remain, and Source is merged
            in. In cases of data conflicts, the Source data overwrites the Dest data.

    CopyFlag - Determines whether Source is deleted from its original location.
            If TRUE, a copy is performed. Source is not deleted from its original location.
            If FALSE, a move is performed. Source is deleted from its original location.

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME

Notes:

--*/
{
    return CopyMetaObject(
        hMDSourceHandle,
        pszMDSourcePath,
        true,
        NULL,
        hMDDestHandle,
        pszMDDestPath,
        bMDOverwriteFlag,
        bMDCopyFlag,
        bUnicode);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  pszMDNewName,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  (PBYTE)pszMDNewName,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName,
        IN BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((LPSTR)pszMDNewName == NULL) ||

        //
        // ExtractNameFromPath, below, checks name length so don't need to
        // check that here.
        //

        (bUnicode &&
            ((wcschr((LPWSTR)pszMDNewName, MD_PATH_DELIMETERW) != NULL) ||
             (wcschr((LPWSTR)pszMDNewName, MD_ALT_PATH_DELIMETERW) != NULL))) ||
        (!bUnicode &&
            ((MD_STRCHR((LPSTR)pszMDNewName, MD_PATH_DELIMETERA) != NULL) ||
             (MD_STRCHR((LPSTR)pszMDNewName, MD_ALT_PATH_DELIMETERA) != NULL)))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        WCHAR strName[METADATA_MAX_NAME_LEN];
        LPSTR pszNewName = (LPSTR)pszMDNewName;
        LPSTR pszTempName = pszNewName;

        hresReturn = ExtractNameFromPath(pszTempName, (LPSTR)strName, bUnicode);

        if (SUCCEEDED(hresReturn)) {
            g_LockMasterResource.WriteLock();
            CMDBaseObject *pboAffected, *pboParent;
            hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                pboParent = pboAffected->GetParent();
                if ( pboParent == NULL) {
                    //
                    // Can't rename MasterRoot
                    //
                    hresReturn = E_INVALIDARG;

                }
                else {
                    if (pboAffected->GetParent()->GetChildObject(pszNewName, &hresReturn, bUnicode) != NULL) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
                    }
                    if (SUCCEEDED(hresReturn)) {

                        BUFFER OriginalKeyName;
                        DWORD  dwStringLen = 0;

                        hresReturn= GetObjectPath(pboAffected,
                                                 &OriginalKeyName,
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 bUnicode);

                        if (SUCCEEDED(hresReturn)) {
                            //
                            // First Remove the object, to get it out of the hash table.
                            //

                            pboParent->RemoveChildObjectFromHash( pboAffected );

                            //
                            // Must use pszMDNewName, as this does not include delimeters
                            //

                            if (!pboAffected->SetName((LPSTR)pszMDNewName, bUnicode)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

                                //
                                // Attempt to reinsert the object
                                // Preserve previous error code by ignoreing this one.
                                //

                                pboParent->AddChildObjectToHash(pboAffected);
                            }
                            else {
                                CMDHandle *phoHandle;

                                //
                                // Reinsert the object with the new name.
                                //

                                hresReturn = pboParent->AddChildObjectToHash( pboAffected );

                                phoHandle = GetHandleObject(hMDHandle);

                                g_dwSystemChangeNumber++;

                                MD_ASSERT(phoHandle != NULL);

                                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                                               phoHandle,
                                                               (LPSTR)pszMDNewName,
                                                               bUnicode
                                                               );
                                phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_RENAME_OBJECT,
                                                         0, (LPWSTR)OriginalKeyName.QueryPtr ());
                            }
                        }


                    }

                }
            }
            g_LockMasterResource.WriteUnlock();
        }
    }
    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PMETADATA_RECORD pmdrMDData,
        IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist, it creates and
    inserts a data object into the list of data objects of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data to set. See IMD.H.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.
    Duplicate data names are not allowed, even for different types.
--*/
{
    HRESULT hresReturn;
    CMDHandle *hHandleObject;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (!ValidateData(pmdrMDData, bUnicode)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.WriteLock();
        CMDBaseObject *AffectedObject = NULL;

        hHandleObject = GetHandleObject(hMDHandle);

        if(hHandleObject != NULL)
        {
            hresReturn = GetObjectFromPathWithHandle(AffectedObject,
                                                     hMDHandle,
                                                     hHandleObject,
                                                     METADATA_PERMISSION_WRITE,
                                                     pszPath,
                                                     bUnicode);
        }
        else
        {
            hresReturn = E_HANDLE;
        }

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            pszPath = (LPSTR)pszMDPath;
            MD_ASSERT(pszMDPath != NULL);

            hresReturn = AddObjectToDataBase(hMDHandle,
                                             hHandleObject,
                                             (LPSTR)pszMDPath,
                                             bUnicode);
            if (SUCCEEDED(hresReturn)) {
                g_dwSystemChangeNumber++;

                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                               hHandleObject,
                                               (LPSTR)pszMDPath,
                                               bUnicode);

                hresReturn = GetObjectFromPath(AffectedObject, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }

        if (SUCCEEDED(hresReturn) && AffectedObject) {
            hresReturn = AffectedObject->SetDataObject(pmdrMDData, bUnicode);
        }
        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;

            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                           hHandleObject,
                                           (LPSTR)pszMDPath,
                                           bUnicode);

            hHandleObject = GetHandleObject( hMDHandle );
            if( !hHandleObject )
            {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else
            {
                hHandleObject->SetChangeData(AffectedObject, MD_CHANGE_TYPE_SET_DATA, pmdrMDData->dwMDIdentifier);
            }
        }
        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets one metadata value.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_ACCESS_DENIED
              ERROR_PATH_NOT_FOUND
              MD_ERROR_DATA_NOT_FOUND
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by
    ComMDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve = NULL;
    CMDBaseObject *pboAssociated = NULL;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if ( SUCCEEDED(hresReturn) && ( pboAffected == NULL ) )
        {
            hresReturn = E_FAIL;
        }
        if (SUCCEEDED(hresReturn)) {
            //
            // Found the object, get the data.
            //
            pbdRetrieve = pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                     pmdrMDData->dwMDAttributes,
                                                     pmdrMDData->dwMDDataType,
                                                     &pboAssociated);
        }
        else if ((hresReturn == (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            //
            // Object not found, get inheritable data.
            //
            pbdRetrieve = pboAffected->GetInheritableDataObject(pmdrMDData->dwMDIdentifier,
                                                                pmdrMDData->dwMDDataType,
                                                                &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
                        METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE) pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                }
            }
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              (PBYTE)pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [in] */ DWORD dwMDEnumDataIndex,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all metadata values once per call. Values are numbered from 0 to NumValues - 1, where
    NumValues is the number of current valules. If EnumDataIndex is >= NumValues, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, , relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_INVALID_PARAMETER
                 ERROR_PATH_NOT_FOUND
                 ERROR_ACCESS_DENIED
                 ERROR_INSUFFICIENT_BUFFER
                 ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve = NULL;
    CMDBaseObject *pboAssociated = NULL;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if ( SUCCEEDED(hresReturn) && ( pboAffected == NULL ) )
        {
            hresReturn = E_FAIL;
        }
        if (SUCCEEDED(hresReturn)) {
            pbdRetrieve = pboAffected->EnumDataObject(dwMDEnumDataIndex,
                                                      pmdrMDData->dwMDAttributes,
                                                      pmdrMDData->dwMDUserType,
                                                      pmdrMDData->dwMDDataType,
                                                      &pboAssociated);
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            pbdRetrieve = pboAffected->EnumInheritableDataObject(dwMDEnumDataIndex,
                                                                 pmdrMDData->dwMDUserType,
                                                                 pmdrMDData->dwMDDataType,
                                                                 &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
                        METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE)pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pbdRetrieve->GetIdentifier(),
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDIdentifier = pbdRetrieve->GetIdentifier();
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDIdentifier,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a data object.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Identifier - The identifier of the data to remove.

    DataType   - Optional type of the data to remove. If specified, only data of that
                 type will be removed. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              MD_ERROR_DATA_NOT_FOUND

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
       g_LockMasterResource.WriteLock();
       CMDBaseObject *pboAffected;
       hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
       if (SUCCEEDED(hresReturn)) {
           if (pboAffected->RemoveDataObject(dwMDIdentifier, dwMDDataType, TRUE) != NULL) {
               CMDHandle *phoHandle;

               hresReturn = ERROR_SUCCESS;
               g_dwSystemChangeNumber++;

               phoHandle = GetHandleObject(hMDHandle);
               if( !phoHandle )
               {
                   hresReturn = MD_ERROR_DATA_NOT_FOUND;
               }
               else
               {
                   phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwMDIdentifier);

                   INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                                  phoHandle,
                                                  (LPSTR)pszMDPath,
                                                  bUnicode);
               }
           }
           else {
               hresReturn = MD_ERROR_DATA_NOT_FOUND;
           }
       }
       g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        /* [in] */ DWORD dwMDBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all data associated with a Meta Object.

Arguments:

    Handle     - METADATA_MASTER_ROOT_HANDLE or a handle returned by ComMDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be returned. Se imd.h.

    DataType   - The Type of the data. If not set to ALL_METADATA only metadata
                 of the specified Data Type will be returned. See imd.h.

    NumDataEntries - On successful output, specifes the number of entries copied to Buffer.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if ERROR_SUCCESS or ERROR_INSUFFICIENT_BUFFER is returned. See ComMDGetDataSetNumber.

    BufferSize     - The size in bytes of buffer. If the return code is ERROR_INSUFFICIENT_BUFFER, this contains
                     the number of bytes needed.

    Buffer         - Buffer to store the data. On successful return it will
                     contain an array of METADATA_GETALL_RECORD.

    RequiredBufferSize - If ERROR_INSUFFICIENT_BUFFER is returned, This contains
        the required buffer length, in bytes.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use
    a handle returned by ComMDOpenMetaObject.

    DWORD data is aligned on non-Intel platforms. This may not hold true on remote clients.
--*/
{
    BOOL fUseInternalStructure = !!(dwMDAttributes & METADATA_REFERENCE);
    BOOL fNonSecureOnly = !!(dwMDAttributes & METADATA_NON_SECURE_ONLY);
    HRESULT hresReturn;
    BOOL bInheritableOnly = FALSE;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf = NULL;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbBuffer == NULL)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)) ||
        (dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if ( SUCCEEDED(hresReturn) && ( pboAffected == NULL ) )
        {
            hresReturn = E_FAIL;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDataSetNumber();
            }
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboAffected != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDescendantDataSetNumber();
            }
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if ( SUCCEEDED(hresReturn) )
        {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);

            if ( ppvMainDataBuf == NULL )
            {
                hresReturn = E_FAIL;
            }
        }
        if (SUCCEEDED(hresReturn)) {
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              dwMDAttributes,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              bInheritableOnly,
                                                              fNonSecureOnly
                                                              );
            PBYTE pbEnd = pbBuffer + dwMDBufferSize;
            PBYTE pbDataStart;
            if (fUseInternalStructure)
            {
                pbDataStart = pbBuffer + (dwNumDataObjects * sizeof(METADATA_GETALL_INTERNAL_RECORD));
            }
            else
            {
                pbDataStart = pbBuffer + (dwNumDataObjects * sizeof(METADATA_GETALL_RECORD));
            }
            PBYTE pbNextDataStart = pbDataStart;

            for (i = 0;
                 (i < dwNumDataObjects) ;
                 i++, pbDataStart = pbNextDataStart) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                if ( pbdCurrent == NULL )
                {
                    hresReturn = E_FAIL;
                    break;
                }
                DWORD dwDataLen = pbdCurrent->GetDataLen(bUnicode);
                PBYTE pbData = (PBYTE)(pbdCurrent->GetData(bUnicode));
                CMDBaseObject *pboAssociated;
                BUFFER bufData;
                STRAU strData;
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    break;
                }
                if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                    METADATA_REFERENCE) == 0) {
                    if ((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) != 0) {
                        //
                        // First do a get to get the metaobject associated with this data object
                        //
                        if (bInheritableOnly) {
                            MD_REQUIRE(pboAffected->GetInheritableDataObject(pbdCurrent->GetIdentifier(),
                                                                               pbdCurrent->GetDataType(),
                                                                               &pboAssociated) != NULL);
                        }
                        else {
                            MD_REQUIRE(pboAffected->GetDataObject(pbdCurrent->GetIdentifier(),
                                                                  dwMDAttributes,
                                                                  pbdCurrent->GetDataType(),
                                                                  &pboAssociated) != NULL);
                        }

                        hresReturn= InsertPathIntoData(&bufData,
                                                       &strData,
                                                       &pbData,
                                                       &dwDataLen,
                                                       pbdCurrent,
                                                       hMDHandle,
                                                       pboAssociated,
                                                       bUnicode);
                    }
                    pbNextDataStart = (pbDataStart + dwDataLen);

                    // The following will ensure that the pointer remains on a DWORD boundary.

                    pbNextDataStart = (PBYTE)(((DWORD_PTR)pbNextDataStart + 3) & ~((DWORD_PTR)(3)));

                }
                if (SUCCEEDED(hresReturn)) {
                    if (pbEnd < pbNextDataStart) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                    }
                    else {
                        if (fUseInternalStructure)
                        {
                            if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                                METADATA_REFERENCE) == 0) {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataOffset = DIFF(pbDataStart - pbBuffer);
                                MD_COPY(pbDataStart, pbData, dwDataLen);
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataTag = 0;
                            }
                            else {
                                MD_ASSERT((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) == 0);
                                MD_ASSERT(pbdCurrent->GetData(bUnicode) != NULL);
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].pbMDData = (PBYTE)pbdCurrent->GetData(bUnicode);
                                pbdCurrent->IncrementReferenceCount();
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataTag = pbdCurrent->GetMappingId();
                            }
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDIdentifier = pbdCurrent->GetIdentifier();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes = pbdCurrent->GetAttributes();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDUserType = pbdCurrent->GetUserType();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataType = pbdCurrent->GetDataType();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataLen = dwDataLen;
                        }
                        else
                        {
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataOffset = (DWORD)DIFF(pbDataStart - pbBuffer);
                            MD_COPY(pbDataStart, pbData, dwDataLen);
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataTag = 0;
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier = pbdCurrent->GetIdentifier();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes = pbdCurrent->GetAttributes();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDUserType = pbdCurrent->GetUserType();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataType = pbdCurrent->GetDataType();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataLen = dwDataLen;
                        }
                    }
                }
            }
            FreeMainDataBuffer(ppvMainDataBuf);
            if (SUCCEEDED(hresReturn)) {
                *pdwMDNumDataEntries = dwNumDataObjects;
                if ((dwNumDataObjects > 0) &&
                    (dwMDAttributes & METADATA_ISINHERITED) &&
                    (dwMDAttributes & METADATA_INHERIT)) {
                    //
                    // Set the ISINHERITED flag
                    //
                    if (bInheritableOnly) {
                        for (i = 0; i < dwNumDataObjects; i++) {
                            if (fUseInternalStructure)
                            {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                            else
                            {
                                ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                        }
                    }
                    else {

                        ppvMainDataBuf = GetMainDataBuffer();

                        dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                                          dwMDAttributes & ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                                          dwMDUserType,
                                                                          dwMDDataType,
                                                                          bInheritableOnly,
                                                                          fNonSecureOnly);

                        //
                        // Current implementation puts the local items first
                        // So just set the rest to inherited
                        //
                        // DBG loop asserts that the implementation has not changed.
                        //

                        #if DBG
                        for (i = 0; i < dwNumDataObjects ; i++) {
                            pbdCurrent = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                            MD_ASSERT(pbdCurrent != NULL);
                            if (fUseInternalStructure)
                            {
                                MD_ASSERT(pbdCurrent->GetIdentifier() == ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDIdentifier);
                            }
                            else
                            {
                                MD_ASSERT(pbdCurrent->GetIdentifier() == ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier);
                            }
                        }
                        #endif //DBG

                        for (i = dwNumDataObjects; i < *pdwMDNumDataEntries; i++) {
                            if (fUseInternalStructure)
                            {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                            else
                            {
                                ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                        }

                        FreeMainDataBuffer(ppvMainDataBuf);
                    }
                }
            }
            *pdwMDRequiredBufferSize = (DWORD)DIFF(pbNextDataStart - pbBuffer);
            #ifndef _X86_
            //
            // Alignment fluff. Alignment could cause up to 3 bytes to be added to
            // the total needed if the buffer size ends in a different modulo 4
            // than the one passed in.
            //
            if (FAILED(hresReturn)) {
                *pdwMDRequiredBufferSize +=3;
            }
            #endif
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
{
    HRESULT hresReturn;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf = NULL;
    CMDHandle *phoHandle;
    CMDBaseObject *pboAffected;
    DWORD dwCurrentDataID;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.WriteLock();
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if ( SUCCEEDED(hresReturn) && ( pboAffected == NULL ) )
        {
            hresReturn = E_FAIL;
        }
        if ( SUCCEEDED(hresReturn) )
        {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            if ( ppvMainDataBuf == NULL )
            {
                hresReturn = E_FAIL;
            }
        }
        if (SUCCEEDED(hresReturn)) {
            MD_REQUIRE((phoHandle = GetHandleObject(hMDHandle)) != NULL);
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              METADATA_NO_ATTRIBUTES,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              FALSE,
                                                              FALSE);
            for (i = 0; i < dwNumDataObjects ; i++) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                dwCurrentDataID = pbdCurrent->GetIdentifier();
                MD_REQUIRE(pboAffected->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwCurrentDataID);
            }
            if (dwNumDataObjects > 0) {
                g_dwSystemChangeNumber++;

                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                               phoHandle,
                                               (LPSTR)pszMDPath,
                                               bUnicode);
            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              pszMDSourcePath,
                              hMDDestHandle,
                              pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              (PBYTE)pszMDSourcePath,
                              hMDDestHandle,
                              (PBYTE)pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves data associated with the source object to the destination object.
    Optionally copies inherited data based on the value of Attributes.

Arguments:

    SrcHandle  - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    SrcPath    - The path of the meta object with which then source data is associated, relative to the
                 path of SrcHandle.

    DestHandle - A handle returned by MDOpenMetaObject with write permission.

    DestPath   - The path of the meta object for data to be copied to, relative to the path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be copied. See imd.h.

    DataType   - Optional type of the data to copy. If not set to ALL_METADATA,
                 only data of that type will be copied.

    CopyFlag   - If true, data will be copied. If false, data will be moved.
                 Must be true if METADATA_INHERIT is set.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid source handle if CopyFlag == TRUE,
        but provides no gaurantee that other threads will not also change
        things. If a consistent data state is desired, use a handle returned by
        MDOpenMetaObject. METADATA_MASTER_ROOT_HANDLE is not a valid destination
        handle.

    If inherited data is copied, it will be copied to the destination object,
        not the corresponding ancestor objects.
--*/
{
    HRESULT hresReturn;
    BOOL bInheritableOnly = FALSE;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf = NULL;
    CMDBaseObject *pboSource = NULL, *pboDest = NULL;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    BOOL  fReadLocked = FALSE;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((!bMDCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT))){
        hresReturn = E_INVALIDARG;
    }
    else {
        //
        // Lock for source object. If copying, just get read lock. If moving,
        // Need write lock.
        //
        if (bMDCopyFlag)
        {
            g_LockMasterResource.ReadLock();
            fReadLocked = TRUE;
        }
        else
        {
            g_LockMasterResource.WriteLock();
            fReadLocked = FALSE;
        }

        hresReturn = GetObjectFromPath(pboSource,
                                       hMDSourceHandle,
                                       ((bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE),
                                       (LPSTR)pszSourcePath,
                                       bUnicode);
        if ( SUCCEEDED(hresReturn) && ( pboSource == NULL ) )
        {
            hresReturn = E_FAIL;
        }
        if (SUCCEEDED(hresReturn)) {
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboSource != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if ( SUCCEEDED(hresReturn) )
        {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            if ( ppvMainDataBuf == NULL )
            {
                hresReturn = E_FAIL;
            }
        }
        if (SUCCEEDED(hresReturn)) {
            dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf,
                                                            dwMDAttributes,
                                                            dwMDUserType,
                                                            dwMDDataType,
                                                            bInheritableOnly,
                                                            FALSE);
            if (fReadLocked)
            {
                g_LockMasterResource.ConvertSharedToExclusive();
                fReadLocked = FALSE;
            }

            CMDHandle *hMDDestHandleObject = GetHandleObject(hMDDestHandle);
            if(hMDDestHandleObject == NULL)
            {
                hresReturn = E_HANDLE;
            }
            else
            {
                hresReturn = GetObjectFromPathWithHandle(pboDest,
                                                         hMDDestHandle,
                                                         hMDDestHandleObject,
                                                         METADATA_PERMISSION_WRITE,
                                                         (LPSTR)pszDestPath,
                                                         bUnicode);
            }

            if (SUCCEEDED(hresReturn)) {
                for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
                    pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                    MD_ASSERT(pbdCurrent != NULL);
                    hresReturn = pboDest->SetDataObject(pbdCurrent);
                    if (SUCCEEDED(hresReturn)) {
                        MD_ASSERT(GetHandleObject(hMDDestHandle) != NULL);
                        hMDDestHandleObject->SetChangeData(pboDest,
                                                           MD_CHANGE_TYPE_SET_DATA,
                                                           pbdCurrent->GetIdentifier());
                    }
                }
                if ((!bMDCopyFlag) && (SUCCEEDED(hresReturn))) {
                    for (i = 0; i < dwNumDataObjects; i++) {
                        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                        MD_ASSERT(pbdCurrent != NULL);
                        MD_REQUIRE(pboSource->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                        MD_ASSERT(GetHandleObject(hMDSourceHandle) != NULL);
                        GetHandleObject(hMDSourceHandle)->SetChangeData(pboSource,
                                                                        MD_CHANGE_TYPE_DELETE_DATA,
                                                                        pbdCurrent->GetIdentifier());
                    }
                }
                g_dwSystemChangeNumber++;

                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle,
                                               hMDDestHandleObject,
                                               pszDestPath,
                                               bUnicode);

            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        if (fReadLocked)
        {
            g_LockMasterResource.ReadUnlock();
        }
        else
        {
            g_LockMasterResource.WriteUnlock();
        }
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{

    return ComMDGetMetaDataPathsD(hMDHandle,
                                  pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ LPWSTR pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetMetaDataPathsD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  (PBYTE)pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsD(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    IN BOOL bUnicode)
{
    HRESULT hresReturn = S_OK;
    CMDHandle * phMDHandle;
    CMDBaseObject *pboAssociated;
    CMDBaseObject *pboHandle;
    LPSTR pszPath = (LPSTR)pszMDPath;
    DWORD i, dwNumMetaObjects;
    DWORD dwBytesPerChar = ((bUnicode) ? sizeof(WCHAR) : sizeof(char));

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDBufferSize != 0) && (pszMDBuffer == NULL)) ||
             (dwMDDataType >= INVALID_END_METADATA) ||
             (pdwMDRequiredBufferSize == NULL)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        hresReturn = GetObjectFromPath(pboAssociated, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            PBYTE pbDataStart = pszMDBuffer;
            PBYTE pbNextDataStart = pbDataStart;
            PBYTE pbDataEnd = pszMDBuffer + (dwMDBufferSize * dwBytesPerChar);
            CMDBaseObject *pboCurrent;
            BUFFER bufPath;
            BUFFER bufMainDataBuf;
            DWORD dwReturn;

            phMDHandle = GetHandleObject(hMDHandle);
            if( !phMDHandle )
            {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else
            {
                pboHandle = phMDHandle->GetObject();

                MD_ASSERT(pboHandle != NULL);
                dwNumMetaObjects = 0;

                hresReturn = pboAssociated->GetDataRecursive(&bufMainDataBuf,
                                                             dwMDIdentifier,
                                                             dwMDDataType,
                                                             dwNumMetaObjects);

                if (SUCCEEDED(hresReturn)) {

                    if (dwNumMetaObjects != 0) {


                        CMDBaseObject **ppboList = (CMDBaseObject **)bufMainDataBuf.QueryPtr();

                        for (i = 0;
                             (i < dwNumMetaObjects) &&
                                 ( SUCCEEDED(hresReturn) ||
                                   hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER));
                             i++, pbDataStart = pbNextDataStart) {
                            pboCurrent=ppboList[i];
                            MD_ASSERT(pboCurrent != NULL);
                            DWORD dwStringLen = 0;

                            dwReturn = GetObjectPath(pboCurrent,
                                                     &bufPath,
                                                     dwStringLen,
                                                     pboHandle,
                                                     bUnicode);
                            if (dwReturn != ERROR_SUCCESS) {
                                //
                                // Only blow away previous hresReturn if this failed.
                                //
                                hresReturn = RETURNCODETOHRESULT(dwReturn);
                            }
                            else {

                                //
                                // Need 2 extra characters for "/"
                                //

                                pbNextDataStart = pbDataStart + ((dwStringLen + 2) * dwBytesPerChar);
                                if (pbDataEnd < pbNextDataStart) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                }
                                else {
                                    MD_COPY(pbDataStart,
                                            bufPath.QueryPtr(),
                                            dwStringLen * dwBytesPerChar);
                                    if (bUnicode) {
                                        *(((LPWSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETERW;
                                        *(((LPWSTR)pbDataStart) + (dwStringLen + 1)) = (WCHAR)L'\0';
                                    }
                                    else {
                                        *(((LPSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETER;
                                        *(((LPSTR)pbDataStart) + (dwStringLen + 1)) = (CHAR)'\0';
                                    }
                                }
                            }
                        }
                        //
                        // Append a final 0 for double NULL termination
                        //
                        pbNextDataStart = pbDataStart + dwBytesPerChar;
                        if (SUCCEEDED(hresReturn)) {
                            if ((pbDataStart + dwBytesPerChar) <= pbDataEnd) {
                                if (bUnicode) {
                                    *((LPWSTR)pbDataStart) = (WCHAR)L'\0';
                                }
                                else {
                                    *((LPSTR)pbDataStart) = (CHAR)'\0';
                                }
                            }
                            else {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                            }
                        }
                    }
                    else {
                        if (pszMDBuffer != NULL) {
                            //
                            // If NULL, just return success
                            // No strings, need to append 2 0's for double NULL termination
                            //

                            pbNextDataStart = pbDataStart + (dwBytesPerChar * 2);
                            if (pbNextDataStart <= pbDataEnd) {
                                if (bUnicode) {
                                    *((LPWSTR)pbDataStart) = (WCHAR)L'\0';
                                    *(((LPWSTR)pbDataStart) + 1) = (WCHAR)L'\0';
                                }
                                else {
                                    *((LPSTR)pbDataStart) = (CHAR)'\0';
                                    *(((LPSTR)pbDataStart) + 1) = (CHAR)'\0';
                                }
                            }
                            else {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                            }
                        }
                    }
                    if (hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                        *pdwMDRequiredBufferSize = (DWORD)DIFF(pbNextDataStart - (PBYTE)pszMDBuffer) / dwBytesPerChar;
                    }
                }
            }
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAccessRequested,
        /* [in] */ DWORD dwMDTimeOut,
        /* [out] */ PMETADATA_HANDLE phMDNewHandle,
        IN BOOL bUnicode)
/*++

Routine Description:

    Opens a meta object for read and/or write access. The returned handle is
        used by several of the other API's. Opening an object for Read access
        guarantees that that view of the data will not change while the object
        is open. Opening an object for write gaurantees that no other objects
        will read or write any changed data until the handle is closed.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject.

    Path            - The path of the object to be opened.

    AccessRequested - The permissions requested. See imd.h.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    NewHandle - The handled to be passed to other MD routines.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_PATH_BUSY

Notes:
    Multiple read handles or a single  write handle can be open on any given
    object.
    Opens for read will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for write.
    Opens for write will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for read and/or write.

    If the request is for write access or Handle has write access, Handle must be closed before
    this request can succeed, unless Handle = METADATA_MASTER_ROOT_HANDLE.
    Handles should be closed as quickly as possible, as open handles can cause other requests to block.
--*/
{
    HRESULT hresReturn;
    DWORD WaitRetCode;
    METADATA_HANDLE mhTemp = NULL;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable = FALSE;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOLEAN bSchemaKey = FALSE;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((phMDNewHandle == NULL) ||
             ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        CMDBaseObject *pboOpen = NULL;
        GetSystemTimeAsFileTime(&TempTime);
        ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) +
                      (_int64)TempTime.dwLowDateTime +
                      ((_int64)dwMDTimeOut * 10000);
        TimeLeft = dwMDTimeOut;
        g_LockMasterResource.WriteLock();
        hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
        }
        //
        // Spin loop waiting for permissions. Events get pulsed whenever a handle is closed.
        // Use a wait interval in case the close comes between the Unlock and the Wait.
        //
        while ((SUCCEEDED(hresReturn)) && (!bPermissionsAvailable) && (TimeLeft > 0)) {
            g_LockMasterResource.WriteUnlock();
            if (dwMDAccessRequested & METADATA_PERMISSION_WRITE) {
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            else {
                WaitRetCode = WaitForSingleObject(g_phEventHandles[EVENT_WRITE_INDEX], LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            GetSystemTimeAsFileTime(&TempTime);

            CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
            TimeLeft = ((ExpireTime - CurrentTime) / 10000);
            g_LockMasterResource.WriteLock();
            //
            // Get object again to make sure the object hasn't been deleted
            // Should probably put an exception handler PermissionsAvailable and use
            // the current object
            //
            hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
            }
        }
        if (SUCCEEDED(hresReturn))  {
            if (bPermissionsAvailable) {

                if(METADATA_MASTER_ROOT_HANDLE == hMDHandle)
                {
                    if((pszPath != NULL) && (0 != *pszPath))
                    {
                        if(bUnicode)
                        {
                            if( (0 == _wcsnicmp((LPWSTR)(pszMDPath), WSZSCHEMA_KEY_NAME1, WSZSCHEMA_KEY_LENGTH1))  ||
                                (0 == _wcsnicmp((LPWSTR)(pszMDPath), WSZSCHEMA_KEY_NAME2, WSZSCHEMA_KEY_LENGTH2))  ||
                                (0 == _wcsnicmp((LPWSTR)(pszMDPath), WSZSCHEMA_KEY_NAME3, WSZSCHEMA_KEY_LENGTH3))
                              )
                            {
                                bSchemaKey = TRUE;
                            }
                        }
                        else
                        {
                            if( (0 == _strnicmp((LPSTR)(pszMDPath), SZSCHEMA_KEY_NAME1, SZSCHEMA_KEY_LENGTH1))  ||
                                (0 == _strnicmp((LPSTR)(pszMDPath), SZSCHEMA_KEY_NAME2, SZSCHEMA_KEY_LENGTH2))  ||
                                (0 == _strnicmp((LPSTR)(pszMDPath), SZSCHEMA_KEY_NAME3, SZSCHEMA_KEY_LENGTH3))
                              )
                            {
                                bSchemaKey = TRUE;
                            }
                        }
                    }
                }
                else
                {
                    CMDHandle *phoHandle;
                    phoHandle = GetHandleObject(hMDHandle);
                    if(phoHandle->IsSchemaHandle())
                    {
                        bSchemaKey = TRUE;
                    }
                }
                hresReturn = AddHandle(pboOpen, dwMDAccessRequested, mhTemp, bSchemaKey);
                if (SUCCEEDED(hresReturn)) {
                    *phMDNewHandle = mhTemp;
                }
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
        }

        if (bUnicode) {
            if (SUCCEEDED(hresReturn)) {
                DBGINFO((DBG_CONTEXT,
                         "Metabase  handle %u opened, From handle %u and path %S, permissions = %u\n",
                         mhTemp,
                         hMDHandle,
                         ((pszMDPath == NULL) || *((WCHAR *)pszMDPath) == (WCHAR)L'\0') ? L"NULL" : (WCHAR *)pszMDPath,
                         dwMDAccessRequested));
            }
            else {
                DBGINFO((DBG_CONTEXT,
                         "Metabase Open of handle %u and path %S failed, return code = %X\n",
                         hMDHandle,
                         ((pszMDPath == NULL) || *((WCHAR *)pszMDPath) == (WCHAR)L'\0') ? L"NULL" : (WCHAR *)pszMDPath,
                         hresReturn));
            }
        }
        else {
            if (SUCCEEDED(hresReturn)) {
                DBGINFO((DBG_CONTEXT,
                         "Metabase  handle %u opened, From handle %u and path %s, permissions = %u\n",
                         mhTemp,
                         hMDHandle,
                         ((pszMDPath == NULL) || *((CHAR *)pszMDPath) == (CHAR)'\0') ? "NULL" : (CHAR *)pszMDPath,
                         dwMDAccessRequested));
            }
            else {
                DBGINFO((DBG_CONTEXT,
                         "Metabase Open of handle %u and path %s failed, return code = %X\n",
                         hMDHandle,
                         ((pszMDPath == NULL) || *((CHAR *)pszMDPath) == (CHAR)'\0') ? "NULL" : (CHAR *)pszMDPath,
                         hresReturn));
            }
        }

        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCloseMetaObject(
            /* [in] */ METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Closes a handle to a meta object. If the handle was opened with write
    permission and changes have been made via this handle, this will cause all
    registered callback functions to be called.

Arguments:

    Handle  - The handle returned by MDOpenMetaObject.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE

--*/
{
    HRESULT hresReturn;
    CMDHandle *hoTemp = NULL;
    BOOL bPulseWrite = FALSE;
    BOOL bPulseRead = FALSE;
    BOOL bSendNotifications = FALSE;
    BOOL bDeleteChangeData = FALSE;

    DWORD dwNumChangeEntries = 0;
    PMD_CHANGE_OBJECT_W pcoBuffer = NULL;
    BUFFER **ppbufStorageArray = NULL;
    BOOL fReadLocked = FALSE;

    g_LockMasterResource.WriteLock();

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) ||
        ((hoTemp = RemoveHandleObject(hMDHandle)) == NULL)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        if (hoTemp->IsWriteAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            bPulseWrite = TRUE;
            bSendNotifications = TRUE;
            bDeleteChangeData = TRUE;
        }
        if (hoTemp->IsReadAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            bPulseRead = TRUE;
        }
        if (bPulseWrite) {
            bPulseWrite = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
        }
        if (bPulseRead && !bPulseWrite) {
            //
            // A write pulse activates everyone, so only do this if we didn't already do a write pulse
            //
            bPulseRead = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
        }
        if (bSendNotifications) {
            g_LockMasterResource.ConvertExclusiveToShared();
            fReadLocked = TRUE;
            if (FAILED(CreateNotifications(hoTemp,
                                           &dwNumChangeEntries,
                                           &pcoBuffer,
                                           &ppbufStorageArray))) {
                bSendNotifications = FALSE;
            }
        }

        hresReturn = ERROR_SUCCESS;
    }

    if (SUCCEEDED(hresReturn)) {
        DBGINFO((DBG_CONTEXT,
                 "Metabase handle %u closed\n",
                 hMDHandle));
    }

    if (fReadLocked)
    {
        g_LockMasterResource.ReadUnlock();
    }
    else
    {
        g_LockMasterResource.WriteUnlock();
    }

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                          dwNumChangeEntries,
                          pcoBuffer,
                          ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);
    }

    if (bDeleteChangeData) {

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_LockMasterResource.WriteLock();
    }

    delete (hoTemp);

    if (bDeleteChangeData) {
        g_LockMasterResource.WriteUnlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDChangePermissions(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested)
/*++

Routine Description:

    Changes permissions on an open meta object handle. If the handle had write permission and is being changed
    to read only, this will cause all registered callback functions to be called.

Arguments:

    Handle  - The handle to be modified.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    AccessRequested - The requested permissions. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
              ERROR_PATH_BUSY

Notes:
    Success or failure when adding permissions follows the same rules as OpenMetaObject.
    TimeOut values should be short for this call, as it is quite possible for 2 threads
    with read permission on the same data to attempt to update to write at the same time.
    Both will block until one read handle is closed.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoTemp = NULL;
    DWORD WaitRetCode;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable;
    BOOL bAddRead, bAddWrite, bRemoveRead, bRemoveWrite = FALSE;
    BOOL bEventPulsed = FALSE;
    BOOL bSendNotifications = FALSE;
    CMDHandle *phoNotifyHandle = NULL;

    DWORD dwNumChangeEntries = 0;
    PMD_CHANGE_OBJECT_W pcoBuffer = NULL;
    BUFFER **ppbufStorageArray = NULL;

    g_LockMasterResource.WriteLock();
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) || ((hoTemp = GetHandleObject(hMDHandle)) == NULL) ||
        ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else if ((hoTemp = GetHandleObject(hMDHandle)) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        bAddRead = (!(hoTemp->IsReadAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_READ));
        bAddWrite = (!(hoTemp->IsWriteAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_WRITE));
        bRemoveRead = ((hoTemp->IsReadAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_READ));
        bRemoveWrite = ((hoTemp->IsWriteAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_WRITE));

        MD_ASSERT(!(bAddRead && bAddWrite));
        MD_ASSERT(!(bRemoveRead && bRemoveWrite));
        MD_ASSERT(!(bAddRead && bRemoveRead));
        MD_ASSERT(!(bAddWrite && bRemoveWrite));

        //
        // Add permissions first, because if delete comes first, another
        // object could open a handle to this in the interim, and the
        // object could get deleted.
        // Also, AddWrite can fail so it must be before RemoveRead
        // to avoid partial completion.
        //

        if (bAddWrite) {
            MD_ASSERT(hoTemp->IsReadAllowed());
            GetSystemTimeAsFileTime(&TempTime);
            ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime + ((_int64)dwMDTimeOut * 10000);
            TimeLeft = dwMDTimeOut;
            bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
            while ((!bPermissionsAvailable) && (TimeLeft > 0) && (hoTemp!=NULL)) {
                g_LockMasterResource.WriteUnlock();
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
                GetSystemTimeAsFileTime(&TempTime);
                CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
                TimeLeft = ((ExpireTime - CurrentTime) / 10000);
                g_LockMasterResource.WriteLock();
                //
                // The meta object could not have been deleted while the handle is open
                // but the handle object could have been deleted, so get it again.
                //
                hoTemp = GetHandleObject(hMDHandle);
                if (hoTemp != NULL) {
                    bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
                }
            }
            if (hoTemp == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
            }
            else if (!bPermissionsAvailable) {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
            else {
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (bAddRead) {
                MD_ASSERT(hoTemp->IsWriteAllowed());
                //
                // Must already have write access
                // Just add read access
                //
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            }
            if (bRemoveRead) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
            }
            if (bRemoveWrite) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
            }
            hoTemp->SetPermissions(dwMDAccessRequested);
        }
    }
    if ((SUCCEEDED(hresReturn)) && bRemoveWrite) {
        if (SUCCEEDED(CreateNotifications(hoTemp,
                                          &dwNumChangeEntries,
                                          &pcoBuffer,
                                          &ppbufStorageArray))) {
            phoNotifyHandle = new CMDHandle(hoTemp);
            if (phoNotifyHandle == NULL) {
                DeleteNotifications(dwNumChangeEntries,
                                    pcoBuffer,
                                    ppbufStorageArray);
            }
            else {
                bSendNotifications = TRUE;
                hoTemp->ZeroChangeList();
            }
        }
        hoTemp->RemoveNotifications();
    }
    g_LockMasterResource.WriteUnlock();

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                  dwNumChangeEntries,
                  pcoBuffer,
                  ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_LockMasterResource.WriteLock();
        delete (phoNotifyHandle);
        g_LockMasterResource.WriteUnlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSaveData(
            IN METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Saves all data changed since the last load or save to permanent storage.

Arguments:

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              Errors returned by the file system.
Notes:
    If the main file has been modified by other applications, this call will overwrite them.

--*/
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;


    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        hresReturn = InitStorageAndSessionKey(
                         &CryptoStorage,
                         &pSessionKeyBlob
                         );

        if( SUCCEEDED(hresReturn) ) {
            if (g_dwInitialized == 0) {
                hresReturn = MD_ERROR_NOT_INITIALIZED;
            }
            else {
                hresReturn = SaveAllData(FALSE, &CryptoStorage, pSessionKeyBlob, NULL, NULL, hMDHandle);
            }
            ::IISCryptoFreeBlob(pSessionKeyBlob);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetHandleInfo(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo)
/*++

Routine Description:

    Gets the information associated with a handle.

Arguments:

    Handle  - The handle to get information about.

    Info    - Structure filled in with the information. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
Notes:
    pmdhiInfo->dwMDSystemChangeNumber will correspond to the System Change Number at the time
    the handle was created. It will not change if writes are done via this handle, or any other
    handle. A client can compare this number with the value returned by MDGetSystemChangeNumber
    to see if any writes have been done since the handle was opened.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *HandleObject;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pmdhiInfo == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        HandleObject = GetHandleObject(hMDHandle);
        if (HandleObject == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
        }
        else {
            HandleObject->GetHandleInfo(pmdhiInfo);
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetSystemChangeNumber(
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber)
/*++

Routine Description:

    Gets the System Change Number.

Arguments:

    SystemChangeNumber - The system change number. This is incremented every time the metadata is updated.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwSystemChangeNumber == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        *pdwSystemChangeNumber = g_dwSystemChangeNumber;
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  pszMDPath,
                                  pdwMDDataSetNumber,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  pdwMDDataSetNumber,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all the data set number associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if successful.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
All paths with the same data set number have identical data if inherited data is included.
The inverse is not true, eg. there may be paths with identical data but different data set numbers.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwMDDataSetNumber == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if ( SUCCEEDED(hresReturn) && ( pboQueried == NULL ) )
        {
            hresReturn = E_FAIL;
        }
        if (SUCCEEDED(hresReturn)) {
            *pdwMDDataSetNumber=pboQueried->GetDataSetNumber();
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL)) {
            *pdwMDDataSetNumber=pboQueried->GetDescendantDataSetNumber();
            hresReturn = ERROR_SUCCESS;
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddRefReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    AddRefs data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.WriteLock();
        #if DBG
            //
            // Make sure this is in the table
            //
            CMDBaseData *pbdAddRef = (CMDBaseData *)g_PointerMapper->FindMapping(dwMDDataTag);

            DWORD dwHash = DATA_HASH(pbdAddRef->GetIdentifier());
            CMDBaseData *pbdIndex;
            BOOL bFound = FALSE;

            if (g_ppbdDataHashTable[dwHash] == pbdAddRef) {
                bFound = TRUE;
            }
            else {
                for (pbdIndex=g_ppbdDataHashTable[dwHash];
                    (pbdIndex != NULL ) && (pbdIndex->GetNextPtr() != pbdAddRef);
                    pbdIndex = pbdIndex->GetNextPtr()) {
                }
                if (pbdIndex != NULL) {
                    bFound = TRUE;
                }
            }
            MD_ASSERT(bFound);
        #endif

        ((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)))->IncrementReferenceCount();

        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDReleaseReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    Releases data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.WriteLock();
        DeleteDataObject((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)));
        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - The new change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.WriteLock();
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pboAffected->SetLastChangeTime(pftMDLastChangeTime);
        }
        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - Place to return the change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    PFILETIME pftTemp;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_LockMasterResource.ReadLock();
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if ((SUCCEEDED(hresReturn)) ||
            ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL))) {
            pftTemp = pboQueried->GetLastChangeTime();
            *pftMDLastChangeTime = *pftTemp;
        }
        g_LockMasterResource.ReadUnlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        FALSE,
                        NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        TRUE,
                        NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupWithPasswdW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd)
{
    STRAU strauPasswd;

    if( !strauPasswd.Copy( (LPWSTR)pszPasswd ) )
    {
        return E_OUTOFMEMORY;
    }

    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        TRUE,
                        strauPasswd.QueryStrA());
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupD(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL bUnicode,
            /* [in] */ LPSTR pszPasswd)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarning = ERROR_SUCCESS;
    IIS_CRYPTO_STORAGE * pCryptoStorage = NULL;
    PIIS_CRYPTO_BLOB pSessionKeyBlob = NULL;
    OFSTRUCT ReOpenBuff;

    STRAU strauBackupLocation;
    STRAU strauSchemaLocation;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDFlags & !(MD_BACKUP_OVERWRITE |
                           MD_BACKUP_SAVE_FIRST |
                           MD_BACKUP_FORCE_BACKUP)) != 0) ||
             (((dwMDFlags & MD_BACKUP_SAVE_FIRST) == 0) &&
                 ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        if( dwMDFlags == 0 )
        {
            dwMDFlags = MD_BACKUP_SAVE_FIRST;
        }

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation,
                                          &strauSchemaLocation);
        if( FAILED( hresReturn ) )
        {
            return hresReturn;
        }

        MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
        MD_ASSERT(strauSchemaLocation.QueryStr(FALSE) != NULL);

        if( ( ( dwMDFlags & MD_BACKUP_OVERWRITE ) == 0 ) &&
            ( ( HFILE_ERROR != OpenFile( strauBackupLocation.QueryStr(FALSE),
                                          &ReOpenBuff,
                                          OF_EXIST ) )   ||
              ( HFILE_ERROR != OpenFile( strauSchemaLocation.QueryStr(FALSE),
                                          &ReOpenBuff,
                                          OF_EXIST ) ) ) )
        {
            return HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
        }

        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
        if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0 || pszPasswd != NULL) {

            if( !pszPasswd )
            {
                pCryptoStorage = new IIS_CRYPTO_STORAGE;
                if( !pCryptoStorage )
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    hresReturn = InitStorageAndSessionKey(
                                     pCryptoStorage,
                                     &pSessionKeyBlob
                                     );
                }
            }
            else
            {
                pCryptoStorage = new IIS_CRYPTO_STORAGE2;
                if( !pCryptoStorage )
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    hresReturn = InitStorageAndSessionKey2(
                                     pszPasswd,
                                     pCryptoStorage,
                                     &pSessionKeyBlob
                                     );
                }
            }

            if( SUCCEEDED(hresReturn) ) {
                if (g_dwInitialized == 0) {
                    hresReturn = MD_ERROR_NOT_INITIALIZED;
                }
                else {
                    if( !pszPasswd )
                    {
                        hresReturn = SaveAllData(FALSE,
                                                 pCryptoStorage,
                                                 pSessionKeyBlob,
                                                 NULL,
                                                 NULL,
                                                 hMDHandle,
                                                 TRUE
                                                 );
                    }
                    else
                    {
                        hresReturn = SaveAllData(FALSE,
                                                 pCryptoStorage,
                                                 pSessionKeyBlob,
                                                 (LPWSTR)strauBackupLocation.QueryStr(TRUE),
                                                 (LPWSTR)strauSchemaLocation.QueryStr(TRUE),
                                                 hMDHandle,
                                                 TRUE
                                                 );
                    }
                }

                if( !pszPasswd )
                {
                    ::IISCryptoFreeBlob(pSessionKeyBlob);
                }
                else
                {
                    ::IISCryptoFreeBlob2(pSessionKeyBlob);
                }
            }
            if (FAILED(hresReturn)) {
                hresWarning = MD_WARNING_SAVE_FAILED;
            }
        }

        if (SUCCEEDED(hresReturn) || ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0)) {

            //
            // Copy the file
            //

            if ( !pszPasswd ) {
                BOOL bFailIfExists = ((dwMDFlags & MD_BACKUP_OVERWRITE) == 0) ? TRUE : FALSE;

                //
                // Copy the file, for old backup method
                //
                if (!CopyFile(g_strRealFileName->QueryStr(),
                              strauBackupLocation.QueryStr(FALSE),
                              bFailIfExists) ||
                    !CopyFile(g_strSchemaFileName->QueryStr(),
                              strauSchemaLocation.QueryStr(FALSE),
                              bFailIfExists)) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }

            if (SUCCEEDED(hresReturn)) {

                HANDLE hTempFileHandle;

                hTempFileHandle = CreateFile(strauBackupLocation.QueryStr(FALSE),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                if (hTempFileHandle != INVALID_HANDLE_VALUE) {
                    FILETIME ftCurrent;
                    GetSystemTimeAsFileTime(&ftCurrent);
                    SetFileTime(hTempFileHandle,
                                NULL,   // Creation Time
                                &ftCurrent,   // Last AccessTime
                                &ftCurrent); // Last Change Time
                    CloseHandle(hTempFileHandle);
                }

                hresReturn = BackupCertificates ((LPCWSTR)pszMDBackupLocation,
                                                    strauBackupLocation.QueryStr(FALSE),
                                                    g_strRealFileName->QueryStr());
            }

        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if (hresReturn == ERROR_SUCCESS) {
        hresReturn = hresWarning;
    }

    if( pCryptoStorage )
    {
        delete pCryptoStorage;
        pCryptoStorage = NULL;
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         FALSE,
                         NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         TRUE,
                         NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreWithPasswdW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd
            )
{
    STRAU strauPasswd;

    if( !strauPasswd.Copy( (LPWSTR)pszPasswd ) )
    {
        return E_OUTOFMEMORY;
    }

    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         TRUE,
                         strauPasswd.QueryStrA());
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL  bUnicode,
            /* [in] */ LPSTR pszPasswd
            )
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((dwMDVersion == MD_BACKUP_NEXT_VERSION) ||
        (dwMDFlags != 0)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {

        STRAU strauBackupLocation;
        STRAU strauSchemaLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation,
                                          &strauSchemaLocation);

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = Restore(
                pszMDBackupLocation,
                &strauBackupLocation,
                &strauSchemaLocation,
                pszPasswd);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsA(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsD(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex,
            /* [in] */ BOOL bUnicode)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    DWORD               cchBackupNameLen;

    if ((pszMDBackupLocation == NULL) ||
        (pdwMDVersion == NULL)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        if (!strauBackupLocation.Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!strauBackupLocation.Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (*(LPWSTR)pszMDBackupLocation == (WCHAR)L'\0') {
                    if (!strauBackupLocation.Append(L"*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPWSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
            else {
                if (*(LPSTR)pszMDBackupLocation == '\0') {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }
        if (SUCCEEDED(hresReturn)) {
            if (SUCCEEDED(hresReturn)) {
                if (!strauBackupLocation.Append(MD_BACKUP_SUFFIX)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else {

                        //
                        // Make sure MultiByte string is valid
                        //

                        if (strauBackupLocation.QueryStrA() == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn))
        {
            //
            // Successfully created the search name
            // Enumerate files
            //
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            DWORD dwEnumIndex = (DWORD) -1;

            hFile = FindFirstFile(strauBackupLocation.QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE)
            {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else
            {
                if (CheckDigits(wfdFile.cFileName +
                                GetBackupNameLen(wfdFile.cFileName) +
                                (sizeof(MD_BACKUP_SUFFIX) - 1)))
                {
                    if ((!strauBackupLocation.Copy(wfdFile.cFileName) ||
                        (strauBackupLocation.QueryStrW() == NULL)))
                    {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else
                    {
                        if ( bUnicode )
                        {
                            cchBackupNameLen = GetBackupNameLen( strauBackupLocation.QueryStrW() );
                        }
                        else
                        {
                            cchBackupNameLen = GetBackupNameLen( strauBackupLocation.QueryStrA() );
                        }

                        if ( ( cchBackupNameLen != 0 ) &&
                             ( cchBackupNameLen <= MD_BACKUP_MAX_LEN ) )
                        {
                                //
                                // One of our files
                                //
                                dwEnumIndex++;
                        }
                    }
                }

                while (SUCCEEDED(hresReturn) && (dwEnumIndex != dwMDEnumIndex))
                {
                    //
                    // Process the remaining files
                    //
                    if (FindNextFile(hFile, &wfdFile))
                    {
                        if (CheckDigits(wfdFile.cFileName +
                                        GetBackupNameLen(wfdFile.cFileName) +
                                        (sizeof(MD_BACKUP_SUFFIX) - 1)))
                        {
                            if ((!strauBackupLocation.Copy(wfdFile.cFileName) ||
                                (strauBackupLocation.QueryStrW() == NULL)))
                            {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else
                            {
                                if ( bUnicode )
                                {
                                    cchBackupNameLen = GetBackupNameLen( strauBackupLocation.QueryStrW() );
                                }
                                else
                                {
                                    cchBackupNameLen = GetBackupNameLen( strauBackupLocation.QueryStrA() );
                                }

                                if ( ( cchBackupNameLen != 0 ) &&
                                     ( cchBackupNameLen <= MD_BACKUP_MAX_LEN ) )
                                {
                                        //
                                        // One of our files
                                        //
                                        dwEnumIndex++;
                                }
                            }
                        }
                    }
                    else
                    {
                        hresReturn = GetLastHResult();
                    }
                }
                FindClose(hFile);

            }
            if (SUCCEEDED(hresReturn))
            {
                //
                // Found the file
                // File name is in wfdFile.cFileName
                // Time is in wfdFile.ftLastWriteTime
                // Need to separate the name and version
                // Reuse strauBackupLocation
                //
                DWORD dwNameLen;

                if ((!strauBackupLocation.Copy(wfdFile.cFileName) ||
                    (strauBackupLocation.QueryStrW() == NULL)))
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    //
                    // ANSI bytes might not equal characters, so use unicode
                    //
                    dwNameLen = GetBackupNameLen(strauBackupLocation.QueryStrW());
                    strauBackupLocation.SetLen(dwNameLen);

                    if ( bUnicode )
                    {
                        cchBackupNameLen = strauBackupLocation.QueryCCH();
                    }
                    else
                    {
                        cchBackupNameLen = strauBackupLocation.QueryCBA();
                    }

                    if ( ( cchBackupNameLen == 0 ) ||
                         ( cchBackupNameLen > MD_BACKUP_MAX_LEN ) )
                    {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                    }
                    else
                    {
                        MD_COPY(pszMDBackupLocation,
                                strauBackupLocation.QueryStr(bUnicode),
                                strauBackupLocation.QueryCB(bUnicode) +
                                    ((bUnicode) ? sizeof(WCHAR) : sizeof(char)));
                        *pdwMDVersion = atol(wfdFile.cFileName +

                                             //
                                             // dwNameLen is # characters
                                             // Need to add # bytes, so
                                             // Get it from STRAU
                                             //

                                             strauBackupLocation.QueryCBA() +
                                             (sizeof(MD_BACKUP_SUFFIX) - 1));
                        MD_COPY(pftMDBackupTime,
                                &(wfdFile.ftLastWriteTime),
                                sizeof(FILETIME));
                    }
                }
            }
            else
            {
                if ((hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) ||
                    (hresReturn == RETURNCODETOHRESULT(ERROR_NO_MORE_FILES)))
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
                }
            }
        }

        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (dwMDVersion == MD_BACKUP_NEXT_VERSION) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;
        STRAU strauSchemaLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation,
                                          &strauSchemaLocation);

        if (SUCCEEDED(hresReturn)) {
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);

            //
            // Delete the file
            //

            if (!DeleteFile(strauBackupLocation.QueryStr(FALSE)) ||
                !DeleteFile(strauSchemaLocation.QueryStr(FALSE)) ) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDExportW(
            /* [in] */ METADATA_HANDLE i_hMDHandle,
            /* [string][in][unique] */ LPCWSTR i_wszPasswd,
            /* [string][in][unique] */ LPCWSTR i_wszFileName,
            /* [string][in][unique] */ LPCWSTR i_wszAbsSourcePath,
            /* [in] */ DWORD i_dwMDFlags)
{
    HRESULT             hresReturn      = ERROR_SUCCESS;
    HRESULT             hresWarning     = ERROR_SUCCESS;
    IIS_CRYPTO_STORAGE* pCryptoStorage  = NULL;
    PIIS_CRYPTO_BLOB    pSessionKeyBlob = NULL;

    //
    // Validate parameters
    //
    if(i_wszFileName == NULL || i_wszAbsSourcePath == NULL)
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }

    //
    // Validate flags
    //
    if( (i_dwMDFlags & ~(MD_EXPORT_INHERITED | MD_EXPORT_NODE_ONLY)) != 0 &&
        i_dwMDFlags != 0 )
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_FLAGS);
    }

    //
    // We need ansi versions of these
    //
    STRAU strauPasswd;

    if (g_dwInitialized == 0)
    {
        return MD_ERROR_NOT_INITIALIZED;
    }

    if(!strauPasswd.Copy(i_wszPasswd == NULL ? L"" : (LPWSTR)i_wszPasswd))
    {
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // TODO: Verify I need this semaphore.
    // I think it is needed to read/write from the xml metabase.  And, possibly
    // for a temp file.  I am not sure.
    //
    MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

    //
    // Never do machine dependent encryption.
    //
    pCryptoStorage = new IIS_CRYPTO_STORAGE2;
    if( !pCryptoStorage )
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else
    {
        hresReturn = InitStorageAndSessionKey2(
            strauPasswd.QueryStrA(),
            pCryptoStorage,
            &pSessionKeyBlob);
    }

    if( SUCCEEDED(hresReturn) ) {
        if (g_dwInitialized == 0) {
            hresReturn = MD_ERROR_NOT_INITIALIZED;
        }
        else {
            hresReturn = SaveSomeData(
                i_dwMDFlags & MD_EXPORT_INHERITED,
                i_dwMDFlags & MD_EXPORT_NODE_ONLY,
                true,                   // bOverwriteFile
                pCryptoStorage,
                pSessionKeyBlob,
                i_wszFileName,
                i_hMDHandle,
                i_wszAbsSourcePath,
                TRUE);
        }

        ::IISCryptoFreeBlob2(pSessionKeyBlob);
    }

    // Now just set the file time
    if (SUCCEEDED(hresReturn)) {

        HANDLE hTempFileHandle;

        hTempFileHandle = CreateFileW(i_wszFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
        if (hTempFileHandle != INVALID_HANDLE_VALUE) {
            FILETIME ftCurrent;
            GetSystemTimeAsFileTime(&ftCurrent);
            SetFileTime(hTempFileHandle,
                        NULL,   // Creation Time
                        &ftCurrent,   // Last AccessTime
                        &ftCurrent); // Last Change Time
            CloseHandle(hTempFileHandle);
        }

        //
        // TODO: Figure out what this is and if i need it
        //
        /*hresReturn = BackupCertificates ((LPCWSTR)pszFileName,
                                            strauFileName.QueryStr(FALSE),
                                            g_strRealFileName->QueryStr());*/
    }

    MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    if (hresReturn == ERROR_SUCCESS) {
        hresReturn = hresWarning;
    }

    if( pCryptoStorage )
    {
        delete pCryptoStorage;
        pCryptoStorage = NULL;
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDImportW(
            /* [in] */ METADATA_HANDLE i_hMDHandle,
            /* [string][in][unique] */ LPCWSTR i_wszDestPath,
            /* [string][in][unique] */ LPCWSTR i_wszKeyType,
            /* [string][in][unique] */ LPCWSTR i_wszPasswd,
            /* [string][in][unique] */ LPCWSTR i_wszFileName,
            /* [string][in][unique] */ LPCWSTR i_wszSourcePath,
            /* [in] */ DWORD i_dwMDFlags)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (i_wszFileName   == NULL ||
        i_wszSourcePath == NULL ||
        i_wszDestPath   == NULL ||
        i_wszKeyType    == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // Validate flags
    //
    if( (i_dwMDFlags & ~(MD_IMPORT_INHERITED | MD_IMPORT_NODE_ONLY | MD_IMPORT_MERGE)) != 0 &&
        i_dwMDFlags != 0 )
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_FLAGS);
    }

    //
    // We need ANSI versions of the following
    //
    STRAU strauPasswd;

    if (g_dwInitialized == 0)
    {
        return MD_ERROR_NOT_INITIALIZED;
    }
    if(!strauPasswd.Copy(i_wszPasswd == NULL ? L"" : (LPWSTR)i_wszPasswd))
    {
        return E_OUTOFMEMORY;
    }

    CMDBaseObject* pboNew = NULL;

    //
    // Clean up source path.
    //
    ULONG  cchSource = (ULONG)wcslen(i_wszSourcePath);
    LPWSTR wszSource = new WCHAR[cchSource+1];
    if(wszSource == NULL)
    {
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    for(ULONG i = 0; i <= cchSource; i++)
    {
        wszSource[i] = (i_wszSourcePath[i] == MD_ALT_PATH_DELIMETERW) ?
            MD_PATH_DELIMETERW : i_wszSourcePath[i];
    }

    //
    // Read the data from XML
    //
    if(SUCCEEDED(hresReturn))
    {
        hresReturn = ReadSomeDataFromXML(
            strauPasswd.QueryStrA(),
            (LPWSTR)i_wszFileName,
            wszSource,
            i_wszKeyType,
            i_dwMDFlags,
            FALSE, // do not have ReadSave semaphore
            &pboNew);
        if(FAILED(hresReturn)) {
            DBGPRINTF(( DBG_CONTEXT,
                "[CMDCOM::ComMDImportW] ReadSomeDataFromXML failed - error 0x%08lx\n", hresReturn));
        }
    }

    //
    // Copy the data into the metabase
    //
    if(SUCCEEDED(hresReturn)) {
        hresReturn = CopyMetaObject(
            NULL,    //hMDSourceHandle
            (LPBYTE)L"", //pszMDSourcePath
            false,   //bUseSourceHandle
            pboNew,  //we already have a pbo, use this instead
            i_hMDHandle,
            (LPBYTE)i_wszDestPath,
            !(i_dwMDFlags & MD_IMPORT_MERGE),
            TRUE,    //bMDCopyFlag
            TRUE     //bUnicode
            );
        if(FAILED(hresReturn)) {
            DBGPRINTF(( DBG_CONTEXT,
                "[CMDCOM::ComMDImportW] CopyMetaObject failed - error 0x%08lx\n", hresReturn));
        }
    }

    delete pboNew;
    delete [] wszSource;

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreHistoryW(
            /* [unique][in][string] */ LPCWSTR i_wszMDHistoryLocation,
            /* [in] */ DWORD i_dwMDMajorVersion,
            /* [in] */ DWORD i_dwMDMinorVersion,
            /* [in] */ DWORD i_dwMDFlags)
{
    int     iLenHistoryLocation = 0;
    HRESULT hresReturn = ERROR_SUCCESS;

    //
    // Validate string len
    //
    if(i_wszMDHistoryLocation)
    {
        for(iLenHistoryLocation = 0; iLenHistoryLocation < MD_BACKUP_MAX_LEN; iLenHistoryLocation++)
        {
            if(i_wszMDHistoryLocation[iLenHistoryLocation] == L'\0') break;
        }
        if(iLenHistoryLocation == MD_BACKUP_MAX_LEN)
        {
            hresReturn = E_INVALIDARG;
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            return hresReturn;
        }
    }

    //
    // Validate flags
    //
    if( (i_dwMDFlags & ~MD_HISTORY_LATEST) != 0 &&
        i_dwMDFlags != 0 )
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_FLAGS);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        return hresReturn;
    }

    LPWSTR  wszHistoryPathPlusFile     = NULL;
    LPWSTR  wszHistoryPathPlusSchema   = NULL;
    STRAU   strauHistoryPathPlusFile;
    STRAU   strauHistoryPathPlusSchema;
    LPCWSTR wszHistoryLocation         = NULL;
    ULONG   cchHistoryLocation         = NULL;

    //
    // Use i_wszMDHistoryLocation if supplied, else defaults
    //
    if(i_wszMDHistoryLocation == NULL || i_wszMDHistoryLocation[0] == L'\0' || iLenHistoryLocation == 0)
    {
        wszHistoryLocation = g_wszHistoryFileDir;
        cchHistoryLocation = g_cchHistoryFileDir;
    }
    else
    {
        wszHistoryLocation = i_wszMDHistoryLocation;
        cchHistoryLocation = iLenHistoryLocation;
    }

    //
    // Construct wszHistoryPathPlusFile, wszHistoryPathPlusSchema
    //
    hresReturn = ConstructHistoryFileName(
        &wszHistoryPathPlusFile,
        (LPWSTR)wszHistoryLocation,
        cchHistoryLocation,
        g_wszRealFileNameWithoutPathWithoutExtension,
        g_cchRealFileNameWithoutPathWithoutExtension,
        g_wszRealFileNameExtension,
        g_cchRealFileNameExtension,
        i_dwMDMajorVersion,
        i_dwMDMinorVersion);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    hresReturn = ConstructHistoryFileName(
        &wszHistoryPathPlusSchema,
        (LPWSTR)wszHistoryLocation,
        cchHistoryLocation,
        g_wszSchemaFileNameWithoutPathWithoutExtension,
        g_cchSchemaFileNameWithoutPathWithoutExtension,
        g_wszSchemaFileNameExtension,
        g_cchSchemaFileNameExtension,
        i_dwMDMajorVersion,
        i_dwMDMinorVersion);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // Use MD_HISTORY_LATEST flag if supplied
    //
    LPWSTR awszFiles[] = { wszHistoryPathPlusFile,     wszHistoryPathPlusSchema,     NULL };
    LPWSTR awszExts[]  = { g_wszRealFileNameExtension, g_wszSchemaFileNameExtension, NULL };
    LPWSTR apInsert[] =  { NULL,                       NULL,                         NULL };
    if(i_dwMDFlags & MD_HISTORY_LATEST)
    {
        DWORD dwMajor = 0;
        DWORD dwMinor = 0;
        for(ULONG i = 0; awszFiles[i] != NULL; i++)
        {
            SIZE_T cch         =  wcslen(awszFiles[i]);
            apInsert[i]        =  awszFiles[i] + cch;
            apInsert[i]        -= wcslen(awszExts[i]);     // i.e. Go to start of: .xml
            apInsert[i]        -= MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW;
            memcpy(
                apInsert[i],
                MD_HISTORY_FILE_SEARCH_EXTENSIONW,
                (MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW) * sizeof(WCHAR));
        }

        hresReturn = GetMostRecentHistoryFile(
            awszFiles[0],   // this is: blah\metabase_??????????_??????????.xml
            &dwMajor,
            &dwMinor);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        for(ULONG i = 0; apInsert[i] != NULL; i++)
        {
            // Move to first set of "?"
            apInsert[i]++;
            _snwprintf(apInsert[i], MD_DEFAULT_HISTORY_MAJOR_NUM_DIGITS, L"%010lu", dwMajor);

            // Move to second set of "?"
            apInsert[i] += MD_DEFAULT_HISTORY_MAJOR_NUM_DIGITS+1;
            _snwprintf(apInsert[i], MD_DEFAULT_HISTORY_MINOR_NUM_DIGITS, L"%010lu", dwMinor);
        }
    }

    if(!strauHistoryPathPlusFile.Copy(wszHistoryPathPlusFile))
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    if(!strauHistoryPathPlusSchema.Copy(wszHistoryPathPlusSchema))
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    hresReturn = Restore(
        NULL,
        &strauHistoryPathPlusFile,
        &strauHistoryPathPlusSchema,
        NULL);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

exit:
    delete [] wszHistoryPathPlusFile;
    delete [] wszHistoryPathPlusSchema;
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumHistoryW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR io_wszMDHistoryLocation,
            /* [out] */ DWORD *o_pdwMDMajorVersion,
            /* [out] */ DWORD *o_pdwMDMinorVersion,
            /* [out] */ PFILETIME o_pftMDHistoryTime,
            /* [in] */ DWORD i_dwMDEnumIndex)
{
    STRAU strauPattern;
    int iLenHistoryLocation;
    HRESULT hresReturn = ERROR_SUCCESS;

    //
    // Copies of out params
    //
    DWORD dwMDMajorVersion;
    DWORD dwMDMinorVersion;
    FILETIME ftMDHistoryTime;

    //
    // Validate parameters
    //
    if(io_wszMDHistoryLocation == NULL || o_pdwMDMajorVersion == NULL ||
        o_pdwMDMinorVersion == NULL || o_pftMDHistoryTime == NULL) {
        return E_INVALIDARG;
    }

    //
    // Validate string len
    //
    for(iLenHistoryLocation = 0; iLenHistoryLocation < MD_BACKUP_MAX_LEN; iLenHistoryLocation++)
    {
        if(io_wszMDHistoryLocation[iLenHistoryLocation] == L'\0') break;
    }
    if(iLenHistoryLocation == MD_BACKUP_MAX_LEN) {
        return E_INVALIDARG;
    }

    MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

    //
    // Eg. c:\windows\system32\inetsrv\history\
    //
    if(io_wszMDHistoryLocation[0] == L'\0') {
        //
        // TODO: Get more meaningful hr
        //
        if(wcslen(g_wszHistoryFileDir) > MD_BACKUP_MAX_LEN-1) {
            hresReturn = E_INVALIDARG;
            goto exit;
        }

        if(!strauPattern.Copy(g_wszHistoryFileDir)) {
            hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    }
    else {
        if(!strauPattern.Copy(io_wszMDHistoryLocation)) {
            hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        if(io_wszMDHistoryLocation[iLenHistoryLocation-1] != L'\\') {
            if(!strauPattern.Append(L"\\")) {
                hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
        }
    }

    //
    // Eg. c:\windows\system32\inetsrv\history\metabase_??????????_??????????.xml
    //
    if(!strauPattern.Append(g_wszRealFileNameWithoutPathWithoutExtension)) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    if(!strauPattern.Append(MD_HISTORY_FILE_SEARCH_EXTENSIONW)) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    if(!strauPattern.Append(g_wszRealFileNameExtension)) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    hresReturn = EnumFiles(strauPattern.QueryStrW(),
        i_dwMDEnumIndex,
        &dwMDMajorVersion,
        &dwMDMinorVersion,
        &ftMDHistoryTime);

    if(FAILED(hresReturn)) {
        goto exit;
    }

    //
    // If everything succeeded, set out parameters
    //
    if(io_wszMDHistoryLocation[0] == L'\0') {
        if( wcslen( g_wszHistoryFileDir ) < MD_BACKUP_MAX_LEN )
        {
            wcscpy(io_wszMDHistoryLocation, g_wszHistoryFileDir);
        }
        else
        {
            hresReturn = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
            goto exit;
        }
    }
    *o_pdwMDMajorVersion = dwMDMajorVersion;
    *o_pdwMDMinorVersion = dwMDMinorVersion;
    memcpy(o_pftMDHistoryTime, &ftMDHistoryTime, sizeof(FILETIME));

exit:
    MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetChildPathsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [unique, in, string] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD cchMDBufferSize,
            /* [out, size_is(dwMDBufferSize)] */ WCHAR *pszBuffer,
            /* [out] */ DWORD *pcchMDRequiredBufferSize)
/*++

Routine Description:

    Retrieves all child metaobjects by name and places them in a MULTISZ containing strings terminated by an empty string

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path - Path of parent object, relative to the path of Handle.
           eg. "Root Object/Child/GrandChild"

    cchMDBufferSize - sizeof buffer passed in, in wchars

    pszBuffer - buffer, allocated by caller, that result is placed into

    pcchMDRequiredBufferSize - required size, filled in only if buffer is insufficient

Return Value:

    HRESULT, S_OK on success
--*/
{
    HRESULT                 hresReturn = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER   pboContainer = NULL;
    CMDBaseObject          *pboAffected =  NULL;
    LPSTR                   pszPath = (LPSTR)pszMDPath;
    BOOL                    fLocked = FALSE;
    BUFFER                  buffTemp;
    size_t                  stCurrentSize = 0;
    BOOL                    fRet = TRUE;

    if (g_dwInitialized == 0)
    {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
        goto done;
    }

    fLocked = TRUE;
    g_LockMasterResource.ReadLock();

    hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, TRUE);
    if (FAILED(hresReturn))
    {
        goto done;
    }
    if ( pboAffected == NULL )
    {
        hresReturn = E_FAIL;
        goto done;
    }

    // get the beginning of the child list (NULL)
    pboContainer = pboAffected->NextChildObject(NULL);

    while (pboContainer != NULL )
    {
        CMDBaseObject * pboChild;
        pboChild = pboContainer->pboMetaObject;

        // get the name of the child (the TRUE indicates in UNICODE)
        LPWSTR pszName = (LPWSTR)pboChild->GetName(TRUE);
        if (pszName == NULL)
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            goto done;
        }

        size_t stNameLen = wcslen(pszName);

        // the new size is the current size + length of new string + 1 for terminating NULL
        size_t stNewSize = stCurrentSize + stNameLen + 1;

        fRet = buffTemp.Resize((UINT)(stNewSize * sizeof(WCHAR)), (UINT)(stNewSize * sizeof(WCHAR)));
        if (FALSE == fRet)
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            goto done;
        }

        // setup the destination pointer for the current name
        WCHAR *pDest = (WCHAR*)buffTemp.QueryPtr();
        pDest += stCurrentSize;

        // actually do the copy
        memcpy(pDest, pszName, sizeof(WCHAR) * (stNameLen + 1));

        // get the size setup for the next iteration of the loop
        stCurrentSize = stNewSize;
        // get the next child in the list
        pboContainer = pboAffected->NextChildObject(pboContainer);
    }

    if (0 == stCurrentSize)
    {
        // there were no children, place a NULL into the buffer.
        fRet = buffTemp.Resize(sizeof(WCHAR), 0);
        if (FALSE == fRet)
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            goto done;
        }

        WCHAR *pDest = (WCHAR*)buffTemp.QueryPtr();
        pDest[0] = '\0';

        // and setup the currentsize correctly
        stCurrentSize = 1;
    }

    // require one extra character for the extra terminating NULL
    if (cchMDBufferSize >= (stCurrentSize + 1))
    {
        if (pszBuffer)
        {
            // copy over from the buffer to the outgoing buffer
            memcpy(pszBuffer, buffTemp.QueryPtr(), stCurrentSize * sizeof(WCHAR));

            // add the final terminating null
            *( pszBuffer + stCurrentSize ) = L'\0';

            // everything suceeded
            hresReturn = ERROR_SUCCESS;
        }
        else
        {
            // received a buffer size that was large enough, but no buffer
            hresReturn = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);
        }
    }
    else if (pcchMDRequiredBufferSize)
    {
        // didn't receive a large enough buffer.
        // indicate the required size
        *pcchMDRequiredBufferSize = (DWORD)(stCurrentSize + 1);

        // and there was insufficient buffer
        hresReturn = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        // passed in buffer wasn't large enough, and nowhere to store the needed size
        hresReturn = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

done:
    if (fLocked)
    {
        g_LockMasterResource.ReadUnlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDStopEWR(VOID)
/*++
Routine Description:
    Signal EWR to stop and waits for EWR thread to exit.
    This must be done before ABO terminates, because EWR uses ABO although living in metadata.

Arguments:
    None

Return Value:

    HRESULT
--*/
{
    // Locals
    HRESULT             hr = S_OK;
    CListenerController * pListenerController = NULL;

    if ( g_pListenerController == NULL )
    {
        goto exit;
    }

    g_LockMasterResource.ReadLock();

    pListenerController = g_pListenerController;

    if (pListenerController != NULL )
    {
        pListenerController->AddRef();
    }

    g_LockMasterResource.ReadUnlock();

    if ( pListenerController != NULL )
    {
        hr = pListenerController->Stop( iSTATE_STOP_PERMANENT, NULL );
    }

exit:
    if ( pListenerController != NULL )
    {
        pListenerController->Release();
        pListenerController = NULL;
    }

    return hr;
}


HRESULT CMDCOM::Restore(
    LPSTR  i_pszMDBackupLocation,
    STRAU* i_pstrauFile,
    STRAU* i_pstrauSchema,
    LPSTR  i_pszPasswd)
/*++

Synopsis:
    Private method used by Restore and RestoreHistory

Arguments: [i_pszMDBackupLocation] - can be NULL
           [i_pstrauFile] -
           [i_pstrauSchema] -
           [i_pszPasswd] - can be NULL (always NULL in case of RestoreHistory)

Return Value:

--*/
{
    MD_ASSERT(i_pstrauFile);
    MD_ASSERT(i_pstrauSchema);

    HRESULT hresReturn        = S_OK;
    DWORD   dwInitializedSave = 0;

    //
    // Send notifications before we grab locks in case users
    // try to access metabase. It would be nice to check the
    // file name before doing this but that requires ReadSaveSemaphore.
    //
    // Send Shutdown Notification since we don't have a Restore
    // Notification and it's close enough.
    //

    SendShutdownNotifications();

    //
    // Give applications some time to close their interfaces,
    // but don't wait too long, user is waiting.
    // Wait until references are closed, unless they take too long.
    // IISADMIN and factory both have refences we do not wait for.
    //
    // We don't actually need to wait during restore, since
    // interfaces are preserved, but waiting will allow clients
    // to cleanup properly.
    //

    for (int i = 0;
         (InterlockedIncrement((long *)&m_dwRefCount) > 3) &&
             (i < MD_SHUTDOWN_WAIT_SECONDS);
         i++) {
        InterlockedDecrement((long *)&m_dwRefCount);
        Sleep(1000);
    }

    InterlockedDecrement((long *)&m_dwRefCount);

    MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

    if (SUCCEEDED(hresReturn)) {
        //
        // Got a valid name
        // See if the file exists
        //
        MD_ASSERT(i_pstrauFile->QueryStr(FALSE) != NULL);
        MD_ASSERT(i_pstrauSchema->QueryStr(FALSE) != NULL);
        HANDLE hFile = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA wfdFile;
        STR   strCopyOfMetabaseFileName (*g_strRealFileName);

        hFile = FindFirstFile(i_pstrauFile->QueryStrA(),
                              &wfdFile);
        if (hFile == INVALID_HANDLE_VALUE) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        }
        else {
            FindClose(hFile);
            //
            // File actually exists,
            // Go ahead and restore.
            //
            g_LockMasterResource.WriteLock();

            //
            // Prevent saves during termination.
            //
            BOOL bPrevSaveDisallowed = g_bSaveDisallowed;
            g_bSaveDisallowed = TRUE;
            dwInitializedSave = 0;
            if( g_dwInitialized != 0 )
            {
                dwInitializedSave = g_dwInitialized;

                while (g_dwInitialized > 0) {
                    TerminateWorker1(TRUE);
                }
            }

            g_bSaveDisallowed = bPrevSaveDisallowed;

            while (SUCCEEDED(hresReturn) && (g_dwInitialized < dwInitializedSave))
            {
                hresReturn = InitWorker(TRUE,
                                        i_pszPasswd,
                                        i_pstrauFile->QueryStr(FALSE),
                                        i_pstrauSchema->QueryStr(FALSE));

                if(HRESULT_FACILITY(hresReturn) == FACILITY_CONFIGURATION)
                {
                    //
                    // Some facility_configuration errors are converted to md_error
                    // in InitWorker.  For the remainder, this has to suffice.
                    //
                    DBGERROR((DBG_CONTEXT,
                        "[CMDCOM::Restore] InitWorker returned hr=0x%x\n", hresReturn));
                    hresReturn = MD_ERROR_READ_METABASE_FILE;
                }
            }

            if( SUCCEEDED(hresReturn) && i_pszMDBackupLocation)
            {
                RestoreCertificates ((LPCWSTR)i_pszMDBackupLocation,
                                      i_pstrauFile->QueryStr(FALSE),
                                      strCopyOfMetabaseFileName.QueryStr());
            }

            //
            // Need to flush the newly restored data out
            //
            g_dwSystemChangeNumber++;
            g_dwSchemaChangeNumber++;

            g_LockMasterResource.WriteUnlock();

            //
            // At this point all old handles are invalidated
            // and all no new handles have been opened.
            // So tell clients to invalidate any open handles now.
            //

            if (SUCCEEDED(hresReturn)) {
                SendEventNotifications(MD_EVENT_MID_RESTORE);
            }
        }

    }
    MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    //
    // Try to load metadata from metabase.bin file on failure
    //
    if( FAILED( hresReturn ) )
    {
        HRESULT hrTemp = S_OK;
        while (SUCCEEDED(hrTemp) && (g_dwInitialized < dwInitializedSave))
        {
            hrTemp = InitWorker(FALSE, NULL, NULL, NULL);
            //
            // Some facility_configuration errors are converted to md_error
            // in InitWorker.  For the remainder, this has to suffice.
            //
            if(HRESULT_FACILITY(hresReturn) == FACILITY_CONFIGURATION)
            {
                DBGERROR((DBG_CONTEXT,
                    "[CMDCOM::Restore] InitWorker returned hr=0x%x\n", hresReturn));
                hresReturn = MD_ERROR_READ_METABASE_FILE;
            }
        }
    }
    else
    {
        //
        // Need to flush newly restored data to Metabase.bin file
        //
        hresReturn = ComMDSaveData( METADATA_MASTER_ROOT_HANDLE );
    }

    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
    }
    return hresReturn;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COPaper::NotifySinks

  Summary:  Internal utility method of this COM object used to fire event
            notification calls to all listening connection sinks in the
            client.

  Modifies: ...

  Returns:  HRESULT
              Standard COM result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT
CMDCOM::NotifySinks(
    METADATA_HANDLE     hHandle,
    PMD_CHANGE_OBJECT   pcoChangeList,
    DWORD               dwNumEntries,
    BOOL                bUnicode,
    DWORD               dwNotificationType,
    DWORD               dwEvent)
{
    HRESULT             hr = S_OK;
    HRESULT             hrT = S_OK;
    COConnectionPoint   *pCoConnectionPoint = NULL;
    CONNECTDATA         *pConnData = NULL;
    ULONG               cConnData = 0;
    ULONG               i;
    IMDCOMSINKA         *pIMDCOMSINKA = NULL;
    IMDCOMSINKW         *pIMDCOMSINKW = NULL;

    DBG_ASSERT( ( dwNotificationType == MD_SINK_MAIN ) ||
                ( dwNotificationType == MD_SINK_SHUTDOWN ) ||
                ( ( dwNotificationType == MD_SINK_EVENT ) && bUnicode ) );

    FlushSomeData();

    if ( bUnicode )
    {
        pCoConnectionPoint = (COConnectionPoint*)m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W];
    }
    else
    {
        pCoConnectionPoint = (COConnectionPoint*)m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A];
    }

    if ( pCoConnectionPoint == NULL )
    {
        goto exit;
    }

    pCoConnectionPoint->AddRef();

    hr = pCoConnectionPoint->InternalEnumSinks( &pConnData, &cConnData );
    if ( FAILED( hr ) || ( cConnData == 0 ) )
    {
        goto exit;
    }

    if (bUnicode)
    {
        // Loop thru the connection point's connections
        // dispatch the event notification to that sink.
        for ( i = 0; i<cConnData; i++ )
        {
            DBG_ASSERT( pConnData[i].pUnk != NULL );
            hrT = pConnData[i].pUnk->QueryInterface( IID_IMDCOMSINK_W,
                                                     (VOID**)&pIMDCOMSINKW );

            if ( FAILED( hrT ) )
            {
                continue;
            }

            DBG_ASSERT( pIMDCOMSINKW != NULL );

            switch ( dwNotificationType )
            {
            case MD_SINK_MAIN:
                pIMDCOMSINKW->ComMDSinkNotify( hHandle,
                                               dwNumEntries,
                                               (PMD_CHANGE_OBJECT_W)pcoChangeList );
                break;

            case MD_SINK_SHUTDOWN:
                //
                // Shutdown Notifications
                //
                pIMDCOMSINKW->ComMDShutdownNotify();
                break;

            case MD_SINK_EVENT:
                pIMDCOMSINKW->ComMDEventNotify( dwEvent );
                break;
            }

            pIMDCOMSINKW->Release();
            pIMDCOMSINKW = NULL;
        }

    }
    else
    {
        // Loop thru the connection point's connections
        // dispatch the event notification to that sink.
        for ( i = 0; i<cConnData; i++ )
        {
            DBG_ASSERT( pConnData[i].pUnk != NULL );
            hrT = pConnData[i].pUnk->QueryInterface( IID_IMDCOMSINK_A,
                                                     (VOID**)&pIMDCOMSINKA );

            if ( FAILED( hrT ) )
            {
                continue;
            }

            DBG_ASSERT( pIMDCOMSINKA != NULL );

            switch ( dwNotificationType )
            {
            case MD_SINK_MAIN:
                pIMDCOMSINKA->ComMDSinkNotify( hHandle,
                                               dwNumEntries,
                                               (PMD_CHANGE_OBJECT_A)pcoChangeList );
                break;

            case MD_SINK_SHUTDOWN:
                //
                // Shutdown Notifications
                //
                pIMDCOMSINKA->ComMDShutdownNotify();
                break;
            }

            pIMDCOMSINKA->Release();
            pIMDCOMSINKA = NULL;
        }
    }

exit:
    DBG_ASSERT( pIMDCOMSINKA == NULL );
    DBG_ASSERT( pIMDCOMSINKW == NULL );

    if ( pConnData != NULL )
    {
        for ( i = 0; i<cConnData; i++ )
        {
            if ( pConnData[i].pUnk != NULL )
            {
                pConnData[i].pUnk->Release();
                pConnData[i].pUnk = NULL;
            }
        }

        delete [] pConnData;
        pConnData = NULL;
    }

    if ( pCoConnectionPoint != NULL )
    {
        pCoConnectionPoint->Release();
        pCoConnectionPoint = NULL;
    }

    return hr;
}

HRESULT
CMDCOM::ConvertNotificationsToDBCS(DWORD dwNumChangeEntries,
                                   BUFFER **ppbufStorageArray)
{
    HRESULT hresReturn = S_OK;
    //
    // ppbufStorageArray is an array of buffer pointers,
    // where each buffer contains a UNICODE path string
    // which needs to be converted to a Local System path string
    //

    STRAU strauPath;
    STRAU strauPathOptional;
    LPSTR pszDBCSPath;
    LPSTR pszDBCSPathOptional = NULL;
    LPSTR pmultiszTarget;
    DWORD dwStrLen1,dwStrLen2 = 0;

    for (DWORD i = 0; i < dwNumChangeEntries; i++) {
        MD_ASSERT(ppbufStorageArray[i] != NULL);

        pmultiszTarget = (LPSTR) ppbufStorageArray[i]->QueryPtr();
        if (!strauPath.Copy((LPWSTR)pmultiszTarget))
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {

            if ((PWORD)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR)))
            {
                if (!strauPathOptional.Copy((LPWSTR)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR))))
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    pszDBCSPathOptional = strauPathOptional.QueryStrA();
                    if (pszDBCSPathOptional == NULL)
                    {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else
                    {
                        dwStrLen2 = strauPathOptional.QueryCBA() + 1 ;
                    }
                }
            }

            if (hresReturn == S_OK)
            {
                pszDBCSPath = strauPath.QueryStrA();
                if (pszDBCSPath == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    dwStrLen1 = strauPath.QueryCBA() + 1 ;

                    MD_ASSERT(ppbufStorageArray[i]->QuerySize() >= (dwStrLen1 + dwStrLen2 + sizeof(char)));

                    MD_COPY(pmultiszTarget, pszDBCSPath, dwStrLen1 );
                    if ( ( dwStrLen2 >0  ) && ( pszDBCSPathOptional != NULL ) )
                    {
                        MD_COPY(pmultiszTarget + dwStrLen1 , pszDBCSPathOptional, dwStrLen2 );
                    }
                    *(pmultiszTarget + dwStrLen1 + dwStrLen2) = '\0';
                }
            }
        }
    }
    return hresReturn;
}

VOID
CMDCOM::SendShutdownNotifications()
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_SHUTDOWN);
    NotifySinks(0,
                NULL,
                0,
                FALSE,
                MD_SINK_SHUTDOWN);
}

VOID
CMDCOM::SendEventNotifications(DWORD dwEvent)
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_EVENT,
                dwEvent);
}

VOID
CMDCOM::SendNotifications(METADATA_HANDLE hHandle,
                          DWORD dwTotalNumChangeEntries,
                          PMD_CHANGE_OBJECT_W pcoBuffer,
                          BUFFER **ppbufStorageArray
                          )
{

    DWORD dwNumChangeEntries;
    DWORD dwRemainingNumChangeEntries = dwTotalNumChangeEntries;

    while (dwRemainingNumChangeEntries != 0) {
        dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
        NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                    dwNumChangeEntries,
                    TRUE,
                    MD_SINK_MAIN);
        dwRemainingNumChangeEntries -= dwNumChangeEntries;
    }

    if (SUCCEEDED(ConvertNotificationsToDBCS(dwTotalNumChangeEntries,
                                             ppbufStorageArray))) {
        dwRemainingNumChangeEntries = dwTotalNumChangeEntries;
        while (dwRemainingNumChangeEntries != 0) {
            dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
            NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                        dwNumChangeEntries,
                        FALSE,
                        MD_SINK_MAIN);
            dwRemainingNumChangeEntries -= dwNumChangeEntries;
        }
    }
}

VOID
CMDCOM::DeleteNotifications(DWORD dwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W pcoBuffer,
                            BUFFER **ppbufStorageArray
                            )
{
    if (dwNumChangeEntries != 0 )
    {
        if( ppbufStorageArray != NULL )
        {
            for( DWORD i = 0; i < dwNumChangeEntries; i++ )
            {
                if (ppbufStorageArray[i] != NULL)
                {
                    delete ppbufStorageArray[i];
                    ppbufStorageArray[i] = NULL;
                }
            }

            delete [] ppbufStorageArray;
        }

        delete pcoBuffer;
    }
}


HRESULT
CMDCOM::CreateNotifications(CMDHandle *phoHandle,
                            DWORD *pdwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W *ppcoBuffer,
                            BUFFER ***pppbufStorageArray
                            )
{
    HRESULT hRes = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    PCHANGE_ENTRY pceChange;
    DWORD i;
    BUFFER **ppbufStorageArray = NULL;
    DWORD dwStringLen, dwStringOldNameLen;
    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer = NULL;

    dwNumChangeEntries = phoHandle->GetNumChangeEntries();
    if (dwNumChangeEntries != 0) {
        ppbufStorageArray = new BUFFER *[dwNumChangeEntries];

        if (ppbufStorageArray == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            for (i = 0; i < dwNumChangeEntries; i++) {
                ppbufStorageArray[i] = new BUFFER();
                if (ppbufStorageArray[i] == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            if (dwReturn == ERROR_SUCCESS) {
                //
                // Create UNICODE callbacks
                //
                pcoBuffer = new MD_CHANGE_OBJECT_W[dwNumChangeEntries];
                if (pcoBuffer == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    for (i = 0;
                        (dwReturn == ERROR_SUCCESS) && (i < dwNumChangeEntries);
                         i++) {
                        MD_REQUIRE((pceChange = phoHandle->EnumChangeEntries(i)) != NULL);
                        dwStringLen = 0;
                        dwReturn = GetObjectPath(pceChange->pboChanged,
                                                 ppbufStorageArray[i],
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 TRUE);
                        if (dwReturn == ERROR_SUCCESS) {
                            dwStringOldNameLen = 0;
                            if ( pceChange->pStrOrigName !=NULL) {
                                dwStringOldNameLen = pceChange->pStrOrigName->QueryCCH ();
                            }

                            // we adding 5, because: 1 for path_delimiter first line 1 for term-zero for first line
                            // 1 for path_delimiter second line 1 for term-zero for second line
                            // and last 1 for multisz term-zero
                            if (!ppbufStorageArray[i]->Resize((dwStringLen + dwStringOldNameLen + 5 ) * sizeof(WCHAR))) {
                                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                            }
                            else {
                                pcoBuffer[i].dwMDChangeType = pceChange->dwChangeType;
                                pcoBuffer[i].pszMDPath = (LPWSTR)(ppbufStorageArray[i]->QueryPtr());
                                pcoBuffer[i].pszMDPath[dwStringLen] = MD_PATH_DELIMETERW;
                                pcoBuffer[i].pszMDPath[dwStringLen + 1] = (WCHAR)L'\0';
                                pcoBuffer[i].pszMDPath[dwStringLen + 2] = (WCHAR)L'\0';
                                if ( dwStringOldNameLen )
                                {
                                    memcpy (&(pcoBuffer[i].pszMDPath[dwStringLen + 2]),
                                            pceChange->pStrOrigName->QueryStrW(),
                                            dwStringOldNameLen * sizeof(WCHAR) );
                                    pcoBuffer[i].pszMDPath[dwStringLen + 2 + dwStringOldNameLen] = MD_PATH_DELIMETERW;
                                    pcoBuffer[i].pszMDPath[dwStringLen + 3 + dwStringOldNameLen] = (WCHAR)L'\0';
                                }
                                pcoBuffer[i].dwMDNumDataIDs = pceChange->dwNumDataIDs;
                                if (pceChange->dwNumDataIDs != 0) {
                                    MD_ASSERT(pceChange->pbufDataIDs != NULL);
                                    pcoBuffer[i].pdwMDDataIDs = (DWORD *)(pceChange->pbufDataIDs->QueryPtr());
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (dwReturn != ERROR_SUCCESS) {
        //
        // Free Buffers
        //
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    else {
        //
        // Pass back info
        // DeleteNotifications will be called later
        //
        *pdwNumChangeEntries = dwNumChangeEntries;
        *pppbufStorageArray = ppbufStorageArray;
        *ppcoBuffer = pcoBuffer;
    }

    if (dwReturn != ERROR_SUCCESS) {
        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    return hRes;
}

VOID CMDCOM::InitializeFlusher (VOID)
{
    if (!fFlusherInitialized)
    {
        fFlusherInitialized = TRUE;

        EnterCriticalSection( &csFlushLock );
        dwFlushCnt = 0;
        dwFlushPeriodExtensions = 0;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
        LeaveCriticalSection( &csFlushLock );

    }

}

// The algorithm for flushing changes of metabase to hard disk is the following:
// when change to metabase is made, and SlushSomeData is called from NotifySinks
// counter which counts the number of changes in metabase is incremented  and first time
// the change happens work item is schedulled for scheduller to flush a metabase after 60 seconds
// if during 60 seconds more than INETA_MB_FLUSH_TRESHOLD changes will happen , then metabase will not
// flush changes to disk, but will extend flushing period for another 60 seconds. If during another 60 secs
// number of changes will be higer than INETA_MB_FLUSH_TRESHOLD agian period will be extended
// but no more times than INETA_MB_FLUSH_PERIODS_EXTENSION
// if in some period number of changes in metabase will be less than INETA_MB_FLUSH_TRESHOLD then
// peirod will not be extended and metabase will be saved to disk


VOID WINAPI CMDCOM::MetabaseLazyFlush(
    VOID * pv
    )
/*++

    Description:

        Scheduler callback for flushing the metabase

--*/
{
    BOOL fExtendPeriod =FALSE;
    CMDCOM *pMasterObject = (CMDCOM *)pv;

    MD_ASSERT(pMasterObject != NULL);

    EnterCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized)
    {
        RemoveWorkItem( pMasterObject->dwMBFlushCookie );
        pMasterObject->dwMBFlushCookie = 0;

        if ( pMasterObject->dwFlushCnt > INETA_MB_FLUSH_TRESHOLD)
        {
            if ( pMasterObject->dwFlushPeriodExtensions < INETA_MB_FLUSH_PERIODS_EXTENSION)
            {
                fExtendPeriod = TRUE;
                pMasterObject->dwFlushPeriodExtensions ++;
            }
        }

        pMasterObject->dwFlushCnt = 0;
        if (!fExtendPeriod)
        {
            pMasterObject->dwFlushPeriodExtensions = 0;
        }
        else
        {
            pMasterObject->dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                               pv, //context,
                                                               pMasterObject->msMBFlushTime);
        }
    }

    LeaveCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized && !fExtendPeriod)
    {
        MB mb(pMasterObject);
        mb.Save();
    }

}

VOID CMDCOM::FlushSomeData (VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized )
    {
        dwFlushCnt++;
        if ( !dwMBFlushCookie )
        {
            dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                this, //context,
                                                msMBFlushTime,
                                                FALSE);
        }
    }
    LeaveCriticalSection( &csFlushLock );
}


VOID CMDCOM::TerminateFlusher(VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized )
    {
        fFlusherInitialized = FALSE;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
    }
    LeaveCriticalSection( &csFlushLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\connect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    IIS MetaBase connection point code.

Author:

    Michael W. Thomas            02-Oct-96

Revision History:

--*/
/*+==========================================================================
  File:      CONNECT.CPP

  Summary:   Implementation file for the connection points (and their
             connections) offered by the connectable objects in the
             STOSERVE server sample. COM objects are implemented for
             Connection Point Enumerators, Connection Points, and
             Connection Enumerators.

             For a comprehensive tutorial code tour of this module's
             contents and offerings see the accompanying STOSERVE.TXT
             file. For more specific technical details on the internal
             workings see the comments dispersed throughout the module's
             source code.

  Classes:   COEnumConnectionPoints, COConnectionPoint, and
             COEnumConnections.

  Functions: none.

  Origin:    6-10-96: atrent - Editor inheritance from CONSERVE OLE
             Tutorial Code Sample. Very little change was required.

----------------------------------------------------------------------------
  This file is part of the Microsoft OLE Tutorial Code Samples.

  Copyright (C) Microsoft Corporation, 1996.  All rights reserved.

  This source code is intended only as a supplement to Microsoft
  Development Tools and/or on-line documentation.  See these other
  materials for detailed information regarding Microsoft code samples.

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
==========================================================================+*/

#include "precomp.hxx"


/*---------------------------------------------------------------------------
  COEnumConnectionPoints's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Constructor.

  Args:     IUnknown* pHostObj
              Pointer to the host object whose connection points are
              being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnPts, and m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::COEnumConnectionPoints(
    IUnknown            * pHostObj)
{
    // Zero the COM object's reference count.
    m_cRefs = 0;

    // Assign the Host Object pointer.
    m_pHostObj = pHostObj;

    // Initialize the Connection Point enumerator variables.
    m_iEnumIndex = 0;
    m_cConnPts = 0;
    m_paConnPts = NULL;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::~COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Destructor.

  Args:     void

  Modifies: m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::~COEnumConnectionPoints(void)
{
    if (NULL != m_paConnPts)
    {
        UINT i;

        // Release all the connection point interface pointers.
        for (i=0; i<m_cConnPts; i++)
            if (NULL != m_paConnPts[i])
                m_paConnPts[i]->Release();

        // Delete the array of interface pointers.
        delete [] m_paConnPts;
    }
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Init

  Summary:  COEnumConnectionPoints Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnPts,
              Number of Connections Points.
            IConnectionPoint** paConnPts,
              Pointer to array of connection point interface pointers.
            ULONG iEnumIndex
              The initial Enumerator index value.

  Modifies: m_cConnPts, m_paConnPts, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnectionPoints::Init(
    ULONG               cConnPts,
    IConnectionPoint    ** paConnPts,
    ULONG               iEnumIndex)
{
    HRESULT             hr = NOERROR;
    UINT                i;

    // Remember the number of Connection points.
    m_cConnPts = cConnPts;

    // Remember the initial enumerator index.
    m_iEnumIndex = iEnumIndex;

    // Create a copy of the array of connection points and keep it inside
    // this enumerator COM object.
    m_paConnPts = new IConnectionPoint* [(UINT) cConnPts];

    // Fill the array copy with the IConnectionPoint interface pointers from
    // the array passed. AddRef for each new Interface pointer copy made.
    if (NULL != m_paConnPts)
    {
        for (i=0; i<cConnPts; i++)
        {
            m_paConnPts[i] = paConnPts[i];
            m_paConnPts[i]->AddRef();
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::QueryInterface

  Summary:  QueryInterface of the COEnumConnectionPoints non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::QueryInterface(
    REFIID              riid,
    PPVOID              ppv)
{
    HRESULT             hr = E_NOINTERFACE;

    *ppv = NULL;

    // The IEnumConnectionPoints interface is implemented directly in
    // this COM object rather than being a nested interface implementation.
    if (IID_IUnknown == riid || IID_IEnumConnectionPoints == riid)
    *ppv = (LPVOID)this;

    if (NULL != *ppv)
    {
        // We've handed out a pointer to the interface so obey the COM rules
        // and AddRef the reference count.
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = NOERROR;
    }

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::AddRef

  Summary:  AddRef of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::AddRef(void)
{
    ULONG               cRefs;

    cRefs = ++m_cRefs;

    // Also AddRef the host object to ensure it stays around as long as
    // this enumerator.
    m_pHostObj->AddRef();

    return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Release

  Summary:  Release of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::Release(void)
{
    ULONG cRefs;

    // Pass this release along to the Host object being enumerated.
    m_pHostObj->Release();

    cRefs = --m_cRefs;

    if (0 == cRefs)
    {
        // We artificially bump the main ref count to prevent reentrancy via
        // the main object destructor.
        m_cRefs++;
        delete this;
    }

    return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Next

  Summary:  The Next member method of this IEnumConnectionPoints interface
            implementation. Called by outside clients of a
            COEnumConnectionPoints object to request that a number of next
            connection point interface pointers be deposited into an array
            supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            IConnectionPoint** paConnPts,
              Pointer to a caller's output array that will receive the
              enumerated IConnectionPoint interface pointers.
            ULONG* cEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Next(
    ULONG               cReq,
    IConnectionPoint    ** paConnPts,
    ULONG               * pcEnumerated)
{
    HRESULT             hr = NOERROR;
    ULONG               cRet = 0;

    // Make sure the argument values passed are valid.
    if (NULL != m_paConnPts)
    {
        if (NULL != paConnPts)
        {
            if (NULL != *paConnPts && m_iEnumIndex < m_cConnPts)
            {
                if (NULL != pcEnumerated)
                    *pcEnumerated = 0L;
                else
                    if (1L != cReq)
                        hr = E_POINTER;
            }
            else
                hr = S_FALSE;
        }
        else
            hr = E_POINTER;
    }
    else
        hr = S_FALSE;

    if (SUCCEEDED(hr))
    {
        // Starting at the current Enumerator index, loop to assign the
        // requested number of output connection point interface pointers.
        for (; m_iEnumIndex < m_cConnPts && cReq > 0;
               paConnPts++, cRet++, cReq--)
        {
            // Assign from the inside Enumerator array to the specified receiving
            // array.
            *paConnPts = m_paConnPts[m_iEnumIndex++];
            // After assigning a copy of an IConnectionPoint pointer, AddRef it.
            if (NULL != *paConnPts)
                (*paConnPts)->AddRef();
        }

        // Assign the output number of connection points enumerated.
        if (NULL != pcEnumerated)
        *pcEnumerated = cRet;
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Skip

  Summary:  The Skip member method of this IEnumConnectionPoints interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection point items.

  Args:     ULONG cSkip
              Number of Connection Point items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Skip(
    ULONG               cSkip)
{
    HRESULT             hr = NOERROR;

    // If there really is a connection point array and the requested
    // amount of skip does not exceed the number of connection points,
    // then bump the index by the requested skip amount.
    if (NULL != m_paConnPts && (m_iEnumIndex + cSkip) < m_cConnPts)
        m_iEnumIndex += cSkip;
    else
        hr = S_FALSE;

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Reset

  Summary:  The Reset member method of the IEnumConnectionPoints interface
            implementation. Resets the Enumeration index to the first
            connection point item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Reset(
    void)
{
    // Zero the main Enumerator index.
    m_iEnumIndex = 0;

    return NOERROR;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Clone

  Summary:  The Clone member method of this IEnumConnectionPoints
            interface implementation. Creates a new clone of this entire
            Connection Point enumerator COM object.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnectionPoints interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Clone(
    IEnumConnectionPoints   ** ppIEnum)
{
    HRESULT                 hr;
    COEnumConnectionPoints  * pCOEnum;

    // NULL the output variable first.
    *ppIEnum = NULL;

    // Create the Clone Enumerator COM object.
    pCOEnum = new COEnumConnectionPoints(m_pHostObj);
    if (NULL != pCOEnum)
    {
        // Initialize it with same values as in this existing enumerator.
        hr = pCOEnum->Init(m_cConnPts, m_paConnPts, m_iEnumIndex);
        if (SUCCEEDED(hr))
        {
            // QueryInterface to return the requested interface pointer.
            // An AddRef will be conveniently done by the QI.
            hr = pCOEnum->QueryInterface(
                                         IID_IEnumConnectionPoints,
                                         (PPVOID)ppIEnum);
        }
        else
        {
            delete pCOEnum;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


/*---------------------------------------------------------------------------
  COConnectionPoint's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  GetConnectionInterface, GetConnectionPointContainer, Advise, Unadvise,
  and EnumConnections.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::COConnectionPoint

  Summary:  COConnectionPoint Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown of the connectable object offering this
              connection point.

  Modifies: ...

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::COConnectionPoint(
    IUnknown            * pHostObj)
{
    // Zero the COM object's reference count.
    m_cRefs = 0;

    // Remember an IUnknown pointer to the connectable object that offers
    // this connection point. Since this connection point object's lifetime
    // is geared to that of the connectable object there is no need to
    // AddRef the following copied pointer to the connectable object.
    m_pHostObj = pHostObj;

    // Initialize the Connection Point variables.
    m_dwNextCookie = COOKIE_START_VALUE;
    m_uiMaxIndex = 0;
    m_cConnections = 0;
    m_paConnections = NULL;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::~COConnectionPoint

  Summary:  COConnectionPoint Destructor.

  Args:     void

  Modifies: m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::~COConnectionPoint(void)
{
    UINT                i;
    IUnknown            * pUnk;

    if (NULL != m_paConnections)
    {
        // Release all the connection sink interface pointers.
        for (i=0; i<m_uiMaxIndex; i++)
        {
            pUnk = m_paConnections[i].pUnk;
            if (NULL != pUnk)
                pUnk->Release();
        }

        // Delete the array of interface pointers.
        delete [] m_paConnections;
    }
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Init

  Summary:  COConnectionPoint Initialization method.  Create any
            necessary arrays, structures, and subordinate objects.

  Args:     REFIID riid
              Reference to the IID of the Sink interface associated with
              this connection point.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::Init(
    REFIID              riid)
{
    HRESULT             hr = NOERROR;
    CONNECTDATA         * paConns;

    // Keep a copy of the reference to the IID of the sink interface
    // associated with this connection point. Needed for later
    // use by the GetConnectionInterface method.
    m_iidSink = riid;

    // Build the initial dynamic array for connections.
    paConns = new CONNECTDATA[ALLOC_CONNECTIONS];
    if (NULL != paConns)
    {
        // Zero the array.
        memset(paConns, 0, ALLOC_CONNECTIONS * sizeof(CONNECTDATA));

        // Rig this connection point object so that it will use the
        // new internal array of connections.
        m_uiMaxIndex = ALLOC_CONNECTIONS;
        m_paConnections = paConns;
    }
    else
        hr = E_OUTOFMEMORY;

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::QueryInterface

  Summary:  QueryInterface of the COConnectionPoint non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::QueryInterface(
    REFIID              riid,
    PPVOID              ppv)
{
    HRESULT             hr = E_NOINTERFACE;

    *ppv = NULL;

    // The IConnectionPoint interface is implemented directly in this
    // COM object rather than being a nested interface implementation.
    if (IID_IUnknown == riid || IID_IConnectionPoint == riid)
        *ppv = (LPVOID)this;

    if (NULL != *ppv)
    {
        // We've handed out a pointer to the interface so obey the COM rules
        // and AddRef the reference count.
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = NOERROR;
    }

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::AddRef

  Summary:  AddRef of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::AddRef(void)
{
      ULONG cRefs;
      cRefs = InterlockedIncrement((long *)&m_cRefs);
      return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Release

  Summary:  Release of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::Release(void)
{
    ULONG               cRefs;

    cRefs = InterlockedDecrement((long *)&m_cRefs);

    if (0 == cRefs)
    {
        // We artificially bump the main ref count to prevent reentrancy via
        // the main object destructor. We relinquish thread ownership of this
        // object prior to deleting it--a good practice.
        InterlockedIncrement((long *)&m_cRefs);
        delete this;
    }

    return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetSlot

  Summary:  An internal private utility member method to obtain a free
            slot in the dynamic connections array. GetSlot will expand the
            dynamic array for more entries if needed. To guarantee thread
            safety, this private method should always be called within the
            protection of a bracketed OwnThis, UnOwnThis pair.

  Args:     UINT* puiFreeSlot
              Address of an output variable to receive the free slot index.

  Modifies: m_uiMaxIndex, m_paConnections.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::GetSlot(
    UINT                * puiFreeSlot)
{
    HRESULT             hr = NOERROR;
    BOOL                bOpen = FALSE;
    UINT                i;
    CONNECTDATA         * paConns;

    // Zero the output variable.
    *puiFreeSlot = 0;

    // Loop to find an empty slot.
    for (i=0; i<m_uiMaxIndex; i++)
    {
        if (m_paConnections[i].dwCookie == 0)
        {
            // We found an open empty slot.
            *puiFreeSlot = i;
            bOpen = TRUE;
            break;
        }
    }

    if (!bOpen)
    {
        // We didn't find an existing open slot in the array--it's full.
        // Expand the array by ALLOC_CONNECTIONS entries and assign the
        // appropriate output index.
        paConns = new CONNECTDATA[m_uiMaxIndex + ALLOC_CONNECTIONS];
        if (NULL != paConns)
        {
            // Copy the content of the old full array to the new larger array.
            for (i=0; i<m_uiMaxIndex; i++)
            {
                paConns[i].pUnk = m_paConnections[i].pUnk;
                paConns[i].dwCookie = m_paConnections[i].dwCookie;
            }

            // Zero (ie mark as empty) the expanded portion of the new array.
            for (i=m_uiMaxIndex; i<m_uiMaxIndex+ALLOC_CONNECTIONS; i++)
            {
                paConns[i].pUnk = NULL;
                paConns[i].dwCookie = 0;
            }

            // New larger array is ready--delete the old array.
            delete [] m_paConnections;

            // Rig the connection point to use the new larger array.
            m_paConnections = paConns;

            // Assign the output free slot as first entry in new expanded area.
            *puiFreeSlot = m_uiMaxIndex;

            // Calculate the new max index.
            m_uiMaxIndex += ALLOC_CONNECTIONS;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::FindSlot

  Summary:  An internal private utility member method to find an existing
            slot (identified by the specified dwCookie value) in the
            dynamic connections array.

  Args:     DWORD dwCookie,
              The connection key (cookie) to find.
            UINT* puiSlot)
              Address of an output variable to receive the slot index.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::FindSlot(
    DWORD               dwCookie,
    UINT                * puiSlot)
{
    HRESULT             hr = CONNECT_E_NOCONNECTION;
    UINT                i;

    // Loop to find the Cookie.
    for (i=0; i<m_uiMaxIndex; i++)
    {
        if (dwCookie == m_paConnections[i].dwCookie)
        {
            // If a cookie match is found, assign the output slot index.
            *puiSlot = i;
            hr = NOERROR;
            break;
        }
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionInterface

  Summary:  The GetConnectionInterface member method of this
            IConnectionPoint interface implementation. Called to get the
            IID of the Sink interface associated with this connection
            point.

  Args:     IID* piidSink
              Pointer to the IID of the associated sink interface.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionInterface(
    IID                 * piidSink)
{
    HRESULT             hr = NOERROR;

    if (NULL != piidSink)
        *piidSink = m_iidSink;
    else
        hr = E_POINTER;

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionPointContainer

  Summary:  The GetConnectionPointContainer member method of this
            IConnectionPoint interface implementation. Called to get the
            connection point container that contains this connection
            point.

  Args:     IConnectionPointContainer** ppConnPtCon
              Address of the pointer variable that will recieve the
              IConnectionPointContainer interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionPointContainer(
    IConnectionPointContainer   ** ppConnPtCon)
{
    HRESULT                     hr;

    // Use QueryInterface to get the interface pointer and to perform the
    // needed AddRef on the returned pointer.
    hr = m_pHostObj->QueryInterface(
                                     IID_IConnectionPointContainer,
                                     (PPVOID) ppConnPtCon);

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Advise

  Summary:  The Advise member method of this IConnectionPoint interface
            implementation. Called by clients to establish a connection of
            their sink to this connection point. Uses the CThreaded
            OwnThis mechanism to provide mutually exclusive access by
            multiple threads.

  Args:     IUnknown* pUnkSink
              IUnknown interface pointer of the Sink object in the client.
            DWORD* pdwCookie
              Pointer to a DWORD in the client that will receive a unique
              key used by the client to refer to the connection established
              by this Advise call.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::Advise(
    IUnknown            * pUnkSink,
    DWORD               * pdwCookie)
{
    HRESULT             hr = NOERROR;
    UINT                uiFreeSlot = 0;
    IUnknown            * pISink = NULL;

    g_rSinkResource->Lock(TSRES_LOCK_WRITE);
    // Zero the output connection key.
    *pdwCookie = 0;

    // Get the specific associated client Sink interface that this
    // connection point expects to use for notifications.
    hr = pUnkSink->QueryInterface(m_iidSink, (PPVOID)&pISink);
    if (SUCCEEDED(hr))
    {
        // Store the specific sink interface in this connection point's
        // array of live connections. First find a free slot (expand the
        // array if needed).
        hr = GetSlot(&uiFreeSlot);
        if (SUCCEEDED(hr))
        {
            // Assign the new slot with the connection entry.
            m_paConnections[uiFreeSlot].pUnk = pISink;
            m_paConnections[uiFreeSlot].dwCookie = m_dwNextCookie;

            // Assign the output Cookie value.
            *pdwCookie = m_dwNextCookie;

            // Increment the Cookie counter.
            m_dwNextCookie++;

            // Increment the number of live connections.
            m_cConnections++;
        }
    }
    else
        hr = CONNECT_E_CANNOTCONNECT;

    g_rSinkResource->Unlock();

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Unadvise

  Summary:  The Unadvise member method of this IConnectionPoint interface
            implementation. Called by clients to disconnect a connection
            of their sink to this connection point. The connection is
            identified by the dwCookie argument (obtained by a previous
            Advise call). Uses the CThreaded OwnThis mechanism to provide
            mutually exclusive access by multiple threads.

  Args:     DWORD dwCookie
              Connection key that was obtained by a previous Advise call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::Unadvise(
    DWORD               dwCookie)
{
    HRESULT             hr = NOERROR;
    UINT                uiSlot;

    if (0 != dwCookie)
    {
        g_rSinkResource->Lock(TSRES_LOCK_WRITE);
        hr = FindSlot(dwCookie, &uiSlot);
        if (SUCCEEDED(hr))
        {
            // Release the sink interface.
            RELEASE_INTERFACE(m_paConnections[uiSlot].pUnk);

            // Mark the array entry as empty.
            m_paConnections[uiSlot].dwCookie = 0;

            // Decrement the number of live connections.
            m_cConnections--;
        }

        g_rSinkResource->Unlock();
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::EnumConnections

  Summary:  The EnumConnections member method of this IConnectionPoint
            interface implementation. Called to obtain an IEnumConnections
            enumerator interface that can be used to enumerate the
            connections of this connection point. Uses the CThreaded
            OwnThis mechanism to ensure mutually exclusive access by
            multiple threads.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the enumerator IEnumConnections interface pointer.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::EnumConnections(
    IEnumConnections    ** ppIEnum)
{
    HRESULT             hr = OLE_E_NOCONNECTION;
    CONNECTDATA         * paConns;
    COEnumConnections   * pCOEnum;
    UINT                i,j;

    g_rSinkResource->Lock(TSRES_LOCK_READ);
    // Zero the output enumerator interface pointer.
    *ppIEnum = NULL;

    if (0 != m_cConnections)
    {
        // Create an array of CONNECTDATA structures.
        paConns = new CONNECTDATA[(UINT)m_cConnections];
        if (NULL != paConns)
        {
            for (i=0, j=0; i<m_uiMaxIndex && j<m_cConnections; i++)
            {
                // Copy non-empty entries only.
                if (0 != m_paConnections[i].dwCookie)
                {
                    // Assign the occupied entry.
                    paConns[j].pUnk = (IUnknown*)m_paConnections[i].pUnk;
                    paConns[j].dwCookie = m_paConnections[i].dwCookie;
                    j++;
                }
            }

            // Create a new COM object for enumerating connections. Pass
            // 'this' as a pHostObj pointer used later to ensure the host
            // connection point object stays alive as long as the enumerator
            // that enumerates connections to that connection point.
            pCOEnum = new COEnumConnections(this);
            if (NULL != pCOEnum)
            {
                // Use the previously constructed (paConns) array of connections
                // to init the new COEnumConnections COM object. The Init will
                // build yet another internal copy of this array. Set the
                // initial enumerator index to 0.
                hr = pCOEnum->Init(m_cConnections, paConns, 0);

                // QueryInterface to return the requested interface pointer.
                // An AddRef will be conveniently done by the QI.
                if (SUCCEEDED(hr))
                {
                    hr = pCOEnum->QueryInterface(
                                                  IID_IEnumConnections,
                                                  (PPVOID)ppIEnum);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            // We're done with the locally constructed array copy--delete it.
            delete [] paConns;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    g_rSinkResource->Unlock();

    return hr;
}

STDMETHODIMP
COConnectionPoint::InternalEnumSinks(
    CONNECTDATA         **prgConnections,
    ULONG               *pcConnections)
{
    // Locals
    HRESULT             hr = S_OK;
    BOOL                fUnlock = FALSE;
    CONNECTDATA         *pConns = NULL;
    ULONG               cConns = 0;
    ULONG               i;
    ULONG               j;

    // Check args
    if ( ( prgConnections == NULL ) || ( pcConnections == NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *prgConnections = NULL;
    *pcConnections = 0;

    g_rSinkResource->Lock(TSRES_LOCK_READ);
    fUnlock = TRUE;

    cConns = m_cConnections;

    // Any listeners?
    if ( cConns == 0 )
    {
        goto exit;
    }

    // Create an array of CONNECTDATA structures.
    pConns = new CONNECTDATA[cConns];
    if ( pConns == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Set to 0.
    memset( pConns, 0, sizeof(CONNECTDATA)*cConns );

    // Copy
    for ( i = 0, j = 0; ( i<m_uiMaxIndex ) && ( j<cConns ); i++ )
    {
        // Copy non-empty entries only.
        if ( m_paConnections[i].dwCookie == 0 )
        {
            continue;
        }

        // Assign the occupied entry.
        pConns[j].pUnk = m_paConnections[i].pUnk;
        pConns[j].pUnk->AddRef();
        pConns[j].dwCookie = m_paConnections[i].dwCookie;
        j++;
    }

    // Return
    *prgConnections = pConns;
    *pcConnections = cConns;

    // Don't delete
    pConns = NULL;
    cConns = 0;

exit:
    if ( fUnlock )
    {
        g_rSinkResource->Unlock();
    }

    if ( pConns != NULL )
    {
        for ( j = 0; j<cConns; j++ )
        {
            if ( pConns[j].pUnk != NULL )
            {
                pConns[j].pUnk->Release();
                pConns[j].pUnk = NULL;
            }
        }

        delete [] pConns;
        pConns = NULL;
    }

    return hr;
}

/*---------------------------------------------------------------------------
  COEnumConnections's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::COEnumConnections

  Summary:  COEnumConnections Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown interface of the host Connection Point
              COM object whose connections are being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnections,
            and m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::COEnumConnections(
  IUnknown* pHostObj)
{
  // Zero the COM object's reference count.
  m_cRefs = 0;

  // Assign the Host Object pointer.
  m_pHostObj = pHostObj;

  // Initialize the Connection Point enumerator variables.
  m_iEnumIndex = 0;
  m_cConnections = 0;
  m_paConnections = NULL;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::~COEnumConnections

  Summary:  COEnumConnections Destructor.

  Args:     void

  Modifies: m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::~COEnumConnections(void)
{
  if (NULL != m_paConnections)
  {
    UINT i;

    // Release all the connected sink interface pointers.
    for (i=0; i<m_cConnections; i++)
      m_paConnections[i].pUnk->Release();

    // Delete the array of connections.
    delete [] m_paConnections;
  }

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Init

  Summary:  COEnumConnections Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnections
              Number of Connections.
            CONNECTDATA* paConnections,
              Pointer to array of connections.
            ULONG iEnumIndex
              The Enumerator index initial value.

  Modifies: m_cConnections, m_paConnections, m_pHostObj, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnections::Init(
          ULONG cConnections,
          CONNECTDATA* paConnections,
          ULONG iEnumIndex)
{
  HRESULT hr = NOERROR;
  UINT i;

  // Remember the number of live Connections.
  m_cConnections = cConnections;

  // Remember the initial enumerator index.
  m_iEnumIndex = iEnumIndex;

  // Create a copy of the array of connections and keep it inside
  // this enumerator COM object.
  m_paConnections = new CONNECTDATA [(UINT) cConnections];

  // Fill the array copy with the connection data from the connections
  // array passed. AddRef for each new sink Interface pointer copy made.
  if (NULL != m_paConnections)
  {
    for (i=0; i<cConnections; i++)
    {
      m_paConnections[i] = paConnections[i];
      m_paConnections[i].pUnk->AddRef();
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::QueryInterface

  Summary:  QueryInterface of the COEnumConnections non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  HRESULT hr = E_NOINTERFACE;

  *ppv = NULL;

  // The IEnumConnections interface is implemented directly in
  // this COM object rather than being a nested interface implementation.
  if (IID_IUnknown == riid || IID_IEnumConnections == riid)
    *ppv = (LPVOID)this;

  if (NULL != *ppv)
  {
    // We've handed out a pointer to the interface so obey the COM rules
    // and AddRef the reference count.
    ((LPUNKNOWN)*ppv)->AddRef();
    hr = NOERROR;
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::AddRef

  Summary:  AddRef of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::AddRef(void)
{
  ULONG cRefs;

  cRefs = InterlockedIncrement((long *)&m_cRefs);

  // Also AddRef the host object to ensure it stays around as long as
  // this enumerator.
  m_pHostObj->AddRef();

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Release

  Summary:  Release of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::Release(void)
{
  ULONG cRefs;

  // Pass this release along to the Host object being enumerated.
  m_pHostObj->Release();

  cRefs = InterlockedDecrement((long *)&m_cRefs);

  if (0 == cRefs)
  {
    // We artificially bump the main ref count to prevent reentrancy via
    // the main object destructor.
    InterlockedIncrement((long *)&m_cRefs);
    delete this;
  }

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Next

  Summary:  The Next member method of this IEnumConnections interface
            implementation. Called by outside clients of a
            COEnumConnections object to request a number of next
            connections be returned in an array supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            CONNECTDATA* paConnections,
              Pointer to a caller's output array that will receive the
              enumerated connection data structures.
            ULONG* pcEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Next(
               ULONG cReq,
               CONNECTDATA* paConnections,
               ULONG* pcEnumerated)
{
  HRESULT hr = NOERROR;
  ULONG cRet = 0;

  // Make sure the argument values passed are valid.
  if (NULL != m_paConnections)
  {
    if (NULL != paConnections)
    {
      if (m_iEnumIndex < m_cConnections)
      {
        if (NULL != pcEnumerated)
          *pcEnumerated = 0L;
        else
          if (1L != cReq)
            hr = E_POINTER;
      }
      else
        hr = S_FALSE;
    }
    else
      hr = E_POINTER;
  }
  else
    hr = S_FALSE;

  if (SUCCEEDED(hr))
  {
    // Starting at the current Enumerator index, loop to assign the
    // requested number of output connection data structures.
    for (; m_iEnumIndex < m_cConnections && cReq > 0;
           paConnections++, m_iEnumIndex++, cRet++, cReq--)
    {
      // Because we are assigning a copy of a connection's data, AddRef
      // its sink interface pointer.
      if (NULL != m_paConnections[m_iEnumIndex].pUnk)
        m_paConnections[m_iEnumIndex].pUnk->AddRef();

      // Assign a connection's data from the inside Enumerator array to
      // the specified output receiving array.
      *paConnections = m_paConnections[m_iEnumIndex];
    }

    // Assign the output number of connections enumerated.
    if (NULL != pcEnumerated)
      *pcEnumerated = cRet;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Skip

  Summary:  The Skip member method of this IEnumConnections interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection items.

  Args:     ULONG cSkip
              Number of Connection items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Skip(
               ULONG cSkip)
{
  HRESULT hr = NOERROR;

  // If there really is a connection array and the requested
  // amount of skip does not exceed the number of connections,
  // then bump the index by the requested skip amount.
  if (NULL != m_paConnections && (m_iEnumIndex + cSkip) < m_cConnections)
    m_iEnumIndex += cSkip;
  else
    hr = S_FALSE;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Reset

  Summary:  The Reset member method of the IEnumConnections interface
            implementation. Resets the Enumeration index to the first
            connection item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Reset(
               void)
{
  // Zero the main Enumerator index.
  m_iEnumIndex = 0;

  return NOERROR;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Clone

  Summary:  The Clone member method of this IEnumConnections interface
            implementation. Creates a new clone of this entire Connection
            enumerator COM object and returns a pointer to its
            IEnumConnections interface.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnections interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Clone(
               IEnumConnections** ppIEnum)
{
  HRESULT hr;
  COEnumConnections* pCOEnum;

  // NULL the output variable first.
  *ppIEnum = NULL;

  // Create the Clone Enumerator COM object.
  pCOEnum = new COEnumConnections(m_pHostObj);
  if (NULL != pCOEnum)
  {
    // Initialize it with same values as in this existing enumerator.
    hr = pCOEnum->Init(m_cConnections, m_paConnections, m_iEnumIndex);
    if (SUCCEEDED(hr))
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
        hr = pCOEnum->QueryInterface(
                        IID_IEnumConnections,
                        (PPVOID)ppIEnum);
    }
    else
    {
        delete pCOEnum;
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\globals.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    IIS MetaBase global variables

Author:

    Michael W. Thomas            31-May-96

Revision History:

--*/
#include "precomp.hxx"

//
// Access to global data structures is synchronized by
// acquiring g_LockMasterResource with read or write
// permission.
//

CMDCOMSrvFactory    *g_pFactory = NULL;

ULONG                g_dwRefCount = 0;

CMDBaseObject       *g_pboMasterRoot;

CReaderWriterLock3  g_LockMasterResource;

TS_RESOURCE         *g_rSinkResource;

CMDHandle           *g_phHandleHead;

METADATA_HANDLE      g_mhHandleIdentifier;

DWORD                g_dwSystemChangeNumber = 0;
DWORD                g_dwSchemaChangeNumber = 1;
DWORD                g_dwLastSchemaChangeNumber = 1;

DWORD                g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;

DWORD                g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;

HANDLE               g_phEventHandles[EVENT_ARRAY_LENGTH];

HANDLE               g_hReadSaveSemaphore;

DWORD                g_dwInitialized = 0;

HRESULT              g_hresInitWarning = ERROR_SUCCESS;

CMDBaseData        **g_ppbdDataHashTable;

DWORD                g_dwWriteNumber;

DWORD                g_dwLastSaveChangeNumber;

BOOL                 g_bSaveDisallowed;

DWORD                g_dwEnableEditWhileRunning = 0;

ULONG				 g_ulHistoryMajorVersionNumber;

DWORD				 g_dwEnableHistory;

DWORD                g_dwMaxHistoryFiles;

DWORD                g_dwMaxErrorFiles;

FILETIME             g_XMLSchemaFileTimeStamp;
FILETIME             g_BINSchemaFileTimeStamp;

//
// The following globals are used by edit while running to determine if the
// file change notification received was due to a programmatic save
// (SaveAllData), or due to a user edit. They are all protected by the
// g_csEditWhileRunning critical section:
//

CRITICAL_SECTION     g_csEditWhileRunning;
FILETIME             g_EWRProcessedMetabaseTimeStamp;
FILETIME             g_MostRecentMetabaseFileLastWriteTimeStamp;
ULONG                g_ulMostRecentMetabaseVersion;
BOOL                 g_bSavingMetabaseFileToDisk;

//
// Data Buffer
// Access to these is synchronized via
// g_csDataBufferCritSec
//

PBUFFER_CONTAINER    g_pbcDataFreeBufHead;

PBUFFER_CONTAINER    g_pbcDataUsedBufHead;

PVOID               *g_ppvDataBufferBlock;

PBUFFER_CONTAINER    g_pbcDataContainerBlock;

HANDLE               g_hDataBufferSemaphore;

BOOL                 g_fDataBufferCritSecInitialized;
CRITICAL_SECTION     g_csDataBufferCritSec;

//
// Data File
//

STR                  *g_strRealFileName;
STR                  *g_strSchemaFileName;
STR                  *g_strTempFileName;
STR                  *g_strBackupFileName;

STR                  *g_pstrBackupFilePath;

PSID                 g_psidSystem;
PSID                 g_psidAdmin;
PACL                 g_paclDiscretionary;
PSECURITY_DESCRIPTOR g_psdStorage;


//
// GlobalISTHelper class
//

CWriterGlobalHelper* g_pGlobalISTHelper;

//
// Unicode versions of strings & their lengths.
// Initialized in  : InitializeUnicodeGlobalDataFileValues
// Set in          : SetUnicodeGlobalDataFileValues
// UnInitialized in: UnInitializeUnicodeGlobalDataFileValues
//

LPWSTR		       g_wszTempFileName;
LPWSTR		       g_wszRealFileName;
LPWSTR		       g_wszBackupFileName;
LPWSTR		       g_wszSchemaFileName;
LPWSTR		       g_wszRealFileNameWithoutPath;
LPWSTR		       g_wszMetabaseDir;
LPWSTR		       g_wszRealFileNameWithoutPathWithoutExtension;
LPWSTR		       g_wszRealFileNameExtension;
LPWSTR             g_wszSchemaFileNameWithoutPath;
LPWSTR             g_wszSchemaFileNameWithoutPathWithoutExtension;
LPWSTR             g_wszSchemaFileNameExtension;
LPWSTR		       g_wszHistoryFileDir;
LPWSTR		       g_wszHistoryFileSearchString;
LPWSTR             g_wszErrorFileSearchString;
LPWSTR             g_wszSchemaExtensionFile;

ULONG		       g_cchTempFileName;
ULONG		       g_cchRealFileName;
ULONG		       g_cchBackupFileName;
ULONG		       g_cchSchemaFileName;
ULONG		       g_cchRealFileNameWithoutPath;
ULONG		       g_cchMetabaseDir;
ULONG		       g_cchRealFileNameWithoutPathWithoutExtension;
ULONG		       g_cchRealFileNameExtension;
ULONG              g_cchSchemaFileNameWithoutPath;
ULONG              g_cchSchemaFileNameWithoutPathWithoutExtension;
ULONG              g_cchSchemaFileNameExtension;
ULONG		       g_cchHistoryFileDir;
ULONG		       g_cchHistoryFileSearchString;
ULONG              g_cchErrorFileSearchString;
ULONG              g_cchSchemaExtensionFile;

//
// This is the array that holds the handle to the metabase schema and data
// files. These files are locked when edit while running is disabled and
// this array holds these handles. It is protected by the read/save semaphore.
//

HANDLE g_ahMetabaseFile[cMetabaseFileTypes];

//
// ListenerController is the object that controls edit while running
//

CListenerController* g_pListenerController = NULL;

//
// Global event logging object
//
ICatalogErrorLogger2*          g_pEventLog = NULL;

//
// Debugging stuff
//

DECLARE_DEBUG_PRINTS_OBJECT();

DWORD           g_dwProcessAttached = 0;



DWORD g_dwCMDBaseObjectNextUniqueDataSetNumber = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\gbuf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gbuf.cxx

Abstract:

    IIS MetaBase subroutines to support global buffers

Author:

    Michael W. Thomas            12-July-96

Revision History:

--*/

#include "precomp.hxx"

HRESULT
InitBufferPoolGlobalsToNull()
/*++
Routine Description:

    Initializes the pool of buffers globals to NULL.

Arguments:
    None

Return Value:
    HHRESULT - S_OK

Notes:
--*/
{
    HRESULT             hr = S_OK;

    g_ppvDataBufferBlock = NULL;
    g_pbcDataContainerBlock = NULL;
    g_pbcDataFreeBufHead = NULL;
    g_pbcDataUsedBufHead = NULL;
    g_fDataBufferCritSecInitialized = FALSE;
    g_hDataBufferSemaphore = NULL;

    return hr;
}


HRESULT
InitBufferPool()
/*++

Routine Description:

    Initializes the pool of buffers.

Arguments:

Return Value:

    HRESULT -   S_OK
                E_OUTOFMEMORY
                Errors by CreateSemaphore, InitializeCriticalSectionAndSpinCount
Notes:

--*/
{
    HRESULT             hr = S_OK;
    DWORD               dwError = ERROR_SUCCESS;
    DWORD               i;

    InitBufferPoolGlobalsToNull();

    g_ppvDataBufferBlock = (PVOID *) new PVOID[NUM_DATA_BUFFERS][DATA_BUFFER_LEN];
    if ( g_ppvDataBufferBlock  == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    g_pbcDataContainerBlock = (PBUFFER_CONTAINER) new BUFFER_CONTAINER[NUM_DATA_BUFFERS];
    if (g_pbcDataContainerBlock == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    g_hDataBufferSemaphore = IIS_CREATE_SEMAPHORE( "g_hDataBufferSemaphore",
                                                   &g_hDataBufferSemaphore,
                                                   NUM_DATA_BUFFERS,
                                                   NUM_DATA_BUFFERS );
    if ( g_hDataBufferSemaphore == NULL )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    g_fDataBufferCritSecInitialized = INITIALIZE_CRITICAL_SECTION( &g_csDataBufferCritSec );
    if ( !g_fDataBufferCritSecInitialized )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    for ( i = 0; i < NUM_DATA_BUFFERS; i++ )
    {
        g_pbcDataContainerBlock[i].ppvBuffer = g_ppvDataBufferBlock + (i * DATA_BUFFER_LEN);
        g_pbcDataContainerBlock[i].NextPtr = g_pbcDataFreeBufHead;
        g_pbcDataFreeBufHead = g_pbcDataContainerBlock + i;
    }


exit:
    if ( FAILED(hr) )
    {
        DeleteBufferPool();
    }

    return hr;
}

VOID
DeleteBufferPool()
/*++

Routine Description:

    Deletes the pool of buffers.

Arguments:

Return Value:

Notes:

--*/
{
    if ( g_ppvDataBufferBlock != NULL )
    {
        delete[] g_ppvDataBufferBlock;
    }

    if ( g_pbcDataContainerBlock != NULL )
    {
        delete[] g_pbcDataContainerBlock;
    }

    if ( g_fDataBufferCritSecInitialized )
    {
        DeleteCriticalSection(&g_csDataBufferCritSec);
    }

    if ( g_hDataBufferSemaphore != NULL )
    {
        CloseHandle( g_hDataBufferSemaphore );
    }

    InitBufferPoolGlobalsToNull();
}

PVOID *
GetDataBuffer()
/*++

Routine Description:

    Gets a buffer.

Arguments:

Return Value:

    PVOID * - The buffer.

Notes:

--*/
{
    DWORD dwError;
    PVOID *ppvReturn = NULL;
    PBUFFER_CONTAINER pbcTemp;
    DWORD i;
    //
    // Use a dual synchonization scheme.
    // The semaphore is used to guarantee
    // a buffer is available.
    // The critical section is used to
    // contol access to global data.
    //
    dwError = WaitForSingleObject(g_hDataBufferSemaphore,
                                 INFINITE);
    if (dwError != WAIT_FAILED) {
        EnterCriticalSection(&g_csDataBufferCritSec);
        MD_ASSERT(g_pbcDataFreeBufHead != NULL);
        ppvReturn = g_pbcDataFreeBufHead->ppvBuffer;
        pbcTemp = g_pbcDataFreeBufHead->NextPtr;
        g_pbcDataFreeBufHead->NextPtr = g_pbcDataUsedBufHead;
        g_pbcDataUsedBufHead = g_pbcDataFreeBufHead;
        g_pbcDataFreeBufHead = pbcTemp;
        LeaveCriticalSection(&g_csDataBufferCritSec);
        for (i = 0; i < DATA_BUFFER_LEN; i++) {
            ppvReturn[i] = NULL;
        }
    }
    return (ppvReturn);
}

VOID
FreeDataBuffer(
         PVOID *ppvBuffer)
{
/*++

Routine Description:

    Gets a buffer.

Arguments:

    ppvBuffer - The buffer.

Return Value:

Notes:

--*/
    PBUFFER_CONTAINER pbcTemp;
    EnterCriticalSection(&g_csDataBufferCritSec);
    MD_ASSERT(g_pbcDataUsedBufHead != NULL);
    //
    // Just grab any container. It's more efficient to set ppvBuffer
    // than to find the right container.
    // Of course, this eliminates error checking. The caller is
    // responsible to make sure that it only passes in correct addresses.
    //
    pbcTemp = g_pbcDataUsedBufHead->NextPtr;
    g_pbcDataUsedBufHead->NextPtr = g_pbcDataFreeBufHead;
    g_pbcDataFreeBufHead = g_pbcDataUsedBufHead;
    g_pbcDataUsedBufHead = pbcTemp;
    g_pbcDataFreeBufHead->ppvBuffer = ppvBuffer;
    LeaveCriticalSection(&g_csDataBufferCritSec);
    MD_REQUIRE(ReleaseSemaphore(g_hDataBufferSemaphore,
                               1,
                               NULL));
}

BOOL
InsertItemIntoDataBuffer(
         PVOID pvItem,
         PVOID *ppvMainDataBuf,
         DWORD &dwNumBufferEntries)
{
/*++

Routine Description:

    Appends an item to the buffer at the specified location. This
    must be an append. Random insertion is not supported.
    This is actually a 2 tiered buffer scheme, where the first buffer
    is used an array of buffers.
    Items are pointers.

Arguments:

    Item             - The pointer to add to the buffer.

    MainDataBuf      - The buffer.

    NumBufferEntries - The number of entries currently in the buffer.

Return Value:

    BOOL       - TRUE if the item was added successfully.

Notes:

--*/
    BOOL bReturn = TRUE;
    DWORD dwMainBufIndex = dwNumBufferEntries / (DATA_BUFFER_LEN - 1);
    DWORD dwSubBufIndex = dwNumBufferEntries % (DATA_BUFFER_LEN - 1);
    PVOID *ppvCurrentDataBuf = ppvMainDataBuf;
    int i;

    MD_ASSERT(ppvMainDataBuf != NULL);
    for (i = 0; i < ((int)dwMainBufIndex - 1); i++) {

        //
        // Go to the buffer before the one we want,
        // in case we need to get the final one.
        //

        MD_ASSERT(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] != NULL);
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN -1]);
    }

    if ((dwMainBufIndex != 0) && (dwSubBufIndex == 0)) {
        MD_ASSERT(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] == NULL);
        ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] = GetDataBuffer();
    }

    MD_ASSERT((dwMainBufIndex == 0) || (i == (int)dwMainBufIndex - 1));
    if (dwMainBufIndex != 0) {
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1]);
    }

    MD_ASSERT(ppvCurrentDataBuf[dwSubBufIndex] == 0);
    ppvCurrentDataBuf[dwSubBufIndex] = pvItem;
    dwNumBufferEntries++;

    return(bReturn);
}

PVOID
GetItemFromDataBuffer(
         PVOID *ppvMainDataBuf,
         DWORD dwItemNum)
/*++

Routine Description:

    Gets the specified item from the buffer.

Arguments:

    MainDataBuf   - The buffer.

    ItemNum       - The number of the item to get.

Return Value:

    PVOID         - The Item from that location.
                    NULL if no item exists at that location.

Notes:

--*/
{
    DWORD dwMainBufIndex = dwItemNum / (DATA_BUFFER_LEN - 1);
    DWORD dwSubBufIndex = dwItemNum % (DATA_BUFFER_LEN - 1);
    PVOID pvReturn;
    PVOID *ppvCurrentDataBuf = ppvMainDataBuf;
    int i;

    MD_ASSERT(ppvMainDataBuf != NULL);
    for (i = 0; i < (int)dwMainBufIndex; i++) {
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN -1]);
    }

    if (ppvCurrentDataBuf == NULL) {
        pvReturn = NULL;
    }
    else {
        pvReturn = ppvCurrentDataBuf[dwSubBufIndex];
    }
    return(pvReturn);
}

VOID
FreeMainDataBuffer(
         PVOID *ppvMainDataBuf)
/*++

Routine Description:

    Frees a main data buffer. Deletes all sub buffers.

Arguments:

    MainDataBuf   - The main data buffer.

Return Value:

Notes:

--*/
{
    MD_ASSERT(ppvMainDataBuf != NULL);
    PVOID *ppvCurrentDataBuf;
    PVOID *ppvNextDataBuf;

    for ( ppvCurrentDataBuf = ppvMainDataBuf;
          ppvCurrentDataBuf != NULL;
          ppvCurrentDataBuf = ppvNextDataBuf ) {
        ppvNextDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1]);
        FreeDataBuffer(ppvCurrentDataBuf);
    }
}

PVOID *
GetMainDataBuffer()
/*++

Routine Description:

    Gets a main data buffer. Deletes all sub buffers.

Arguments:

Return Value:

    PVOID * - The main data buffer.

Notes:

--*/
{
    return(GetDataBuffer());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\handle.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metasub.cxx

Abstract:

    IIS MetaBase handle routines

Author:

    Michael W. Thomas            04-Oct-96

Revision History:

Notes:

--*/

#include "precomp.hxx"

DWORD
CMDHandle::SetChangeData(CMDBaseObject *pboChanged,
         DWORD          dwChangeType,
         DWORD          dwDataID,
         LPWSTR         pszOldName)
{
    PCHANGE_ENTRY pceIndex;
    DWORD i;
    DWORD dwReturn = ERROR_SUCCESS;
    for (pceIndex = m_pceChangeList; pceIndex != NULL; pceIndex = pceIndex->NextPtr) {
        if (pceIndex->pboChanged == pboChanged) {
            break;
        }
    }
    if (pceIndex == NULL) {
        pceIndex = new(CHANGE_ENTRY);
        if (pceIndex == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pceIndex->dwNumDataIDs = 0;
            pceIndex->pbufDataIDs = NULL;
            pceIndex->dwChangeType = 0;
            pceIndex->pboChanged = pboChanged;
            pceIndex->NextPtr = m_pceChangeList;
            pceIndex->pStrOrigName = NULL;
            m_pceChangeList = pceIndex;
        }
    }
    if (dwReturn == ERROR_SUCCESS) {
        MD_ASSERT(pceIndex != NULL);
        pceIndex->dwChangeType |= dwChangeType;
        if ((dwChangeType == MD_CHANGE_TYPE_SET_DATA) ||
            (dwChangeType == MD_CHANGE_TYPE_DELETE_DATA) ||
            (dwChangeType == MD_CHANGE_TYPE_RENAME_OBJECT && pszOldName != NULL )) {
            if (pceIndex->pbufDataIDs == NULL) {
                pceIndex->pbufDataIDs = new BUFFER();
                if (pceIndex->pbufDataIDs == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            if (dwReturn == ERROR_SUCCESS && pceIndex->pStrOrigName == NULL && pszOldName !=NULL) {
                pceIndex->pStrOrigName = new STRAU();
                if (pceIndex->pStrOrigName == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    // sucess
                    // we are taking the old name of metabase key only once.
                    // so if subsequent renames will happen we will return the oldest one
                    if ( !pceIndex->pStrOrigName->Copy (pszOldName) )
                    {
                        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
            if (dwReturn == ERROR_SUCCESS) {
                for (i = 0; i < pceIndex->dwNumDataIDs; i++) {
                    if (((DWORD *)(pceIndex->pbufDataIDs->QueryPtr()))[i] == dwDataID) {
                        break;
                    }
                }
                if (i == pceIndex->dwNumDataIDs) {
                    if (!pceIndex->pbufDataIDs->Resize((pceIndex->dwNumDataIDs + 1) * sizeof(DWORD))) {
                        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else {
                        ((DWORD *)(pceIndex->pbufDataIDs->QueryPtr()))[pceIndex->dwNumDataIDs] = dwDataID;
                        pceIndex->dwNumDataIDs++;
                    }
                }
            }
        }
    }
    return dwReturn;
}

CMDHandle::~CMDHandle()
{
    RemoveNotifications();
}


PCHANGE_ENTRY
CMDHandle::EnumChangeEntries(DWORD dwIndex)
{
    PCHANGE_ENTRY pceIndex;
    DWORD i;
    for (i = 0, pceIndex = m_pceChangeList;
         pceIndex != NULL && i < dwIndex;
         i++, pceIndex = pceIndex->NextPtr) {
    }
    return pceIndex;
}

DWORD
CMDHandle::GetNumChangeEntries()
{
    DWORD dwCount = 0;
    PCHANGE_ENTRY pceIndex;

    for (pceIndex = m_pceChangeList;
        pceIndex !=NULL;
        pceIndex = pceIndex->NextPtr) {
        dwCount++;
    }

    return dwCount;
}

VOID
CMDHandle::RemoveNotifications()
{
    PCHANGE_ENTRY pceIndex, pceNext;
    for (pceIndex = m_pceChangeList; pceIndex != NULL; pceIndex = pceNext) {
        pceNext = pceIndex->NextPtr;
        delete(pceIndex->pbufDataIDs);
        delete(pceIndex->pStrOrigName);
        if ((pceIndex->dwChangeType & MD_CHANGE_TYPE_DELETE_OBJECT) != 0) {
            delete(pceIndex->pboChanged);
        }
        delete(pceIndex);
    }
    m_pceChangeList = NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\listener.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    Listner.cpp

Abstract:

    Implementation of the class that does subscribes and process file change notifications.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

#define MB_TIMEOUT_LISTENER (30 * 1000)

#include <initguid.h>
DEFINE_GUID(CLSID_MSAdminBase_W, 0xa9e69610, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
DEFINE_GUID(IID_IMSAdminBase_W, 0x70b51430, 0xb6ca, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);

HRESULT GetGlobalHelper(BOOL                    i_bFailIfBinFileAbsent,
                        CWriterGlobalHelper**    ppCWriterGlobalHelper);


/***************************************************************************++

  Notes - The listener controller creates the CFileListener and can call the
  following methods on it: (i.e. the ListenerControler thread can call the
  following methods on it)
  Init
  Subscribe
  Unsubscribe
  ProcessChanges

  The listener object implements the ISimpleTableFileChange interface and
  this interface is handed out on a subscribe call - which means that the
  catalog can call back on the methods of this interface.

  Hence there are two threads acceessing this object, and they touch
  different methods. The methods that implement ISimpleTableFileChange
  interface, read member variables, but these member variables are
  initialized once in Init and released in the destructor, and never
  modified in between.

--***************************************************************************/

/***************************************************************************++

Routine Description:

    Constructor for the CFileListener class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CFileListener::CFileListener()
{
    m_cRef                                            = 0;
    m_pISTDisp                                        = NULL;
    m_pISTFileAdvise                                  = NULL;
    m_dwNotificationCookie                            = 0;
    m_wszHistoryFileDir                               = NULL;
    m_cchHistoryFileDir                               = 0;
    m_wszRealFileName                                 = NULL;
    m_cchRealFileName                                 = 0;
    m_wszRealFileNameWithoutPath                      = NULL;
    m_cchRealFileNameWithoutPath                      = 0;
    m_wszRealFileNameWithoutPathWithoutExtension      = NULL;
    m_cchRealFileNameWithoutPathWithoutExtension      = 0;
    m_wszRealFileNameExtension                        = NULL;
    m_cchRealFileNameExtension                        = 0;
    m_wszSchemaFileName                               = NULL;
    m_cchSchemaFileName                               = 0;
    m_wszSchemaFileNameWithoutPath                    = NULL;
    m_cchSchemaFileNameWithoutPath                    = 0;
    m_wszSchemaFileNameWithoutPathWithoutExtension    = NULL;
    m_cchSchemaFileNameWithoutPathWithoutExtension    = 0;
    m_wszSchemaFileNameExtension                      = NULL;
    m_cchSchemaFileNameExtension                      = 0;
    m_wszErrorFileSearchString                        = NULL;
    m_cchErrorFileSearchString                        = 0;
    m_wszMetabaseDir                                  = NULL;
    m_cchMetabaseDir                                  = 0;
    m_wszHistoryFileSearchString                      = NULL;
    m_cchHistoryFileSearchString                      = 0;
    m_wszEditWhileRunningTempDataFile                 = NULL;
    m_cchEditWhileRunningTempDataFile                 = 0;
    m_wszEditWhileRunningTempSchemaFile               = NULL;
    m_cchEditWhileRunningTempSchemaFile               = 0;
    m_wszEditWhileRunningTempDataFileWithAppliedEdits = NULL;
    m_cchEditWhileRunningTempDataFileWithAppliedEdits = 0;
    m_bIsTempSchemaFile                               = FALSE;
    m_pCListenerController                            = NULL;
    m_pAdminBase                                      = NULL;

} // CFileListener::CFileListener


/***************************************************************************++

Routine Description:

    Initializes member vaiables.

Arguments:

    Event handle array.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::Init(CListenerController* i_pListenerController)
{
    HRESULT    hr      = S_OK;
    BOOL       bLocked = FALSE;

    if(NULL == m_pISTDisp)
    {
        hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&m_pISTDisp, WSZ_PRODUCT_IIS );

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::Init] Unable to get the dispenser. DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",
                      hr));

            goto exit;
        }
    }

    if(NULL == m_pISTFileAdvise)
    {
        hr = m_pISTDisp->QueryInterface(IID_ISimpleTableFileAdvise, (void**)&m_pISTFileAdvise);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Keep a reference to the listener controller - it has the handles.
    //

    m_pCListenerController = i_pListenerController;

    m_pCListenerController->AddRef();

    //
    // We make a copy of the following global variables, it eliminates the
    // need for taking the g_LockMasterResource lock everytime we want read
    // these variables.
    //

    g_LockMasterResource.ReadLock();
    bLocked = TRUE;

    // Note that g_wszRealFileNameExtension & g_wszSchemaFileNameExtension may
    // be NULL.

    if((NULL == g_wszHistoryFileDir)                           ||
       (NULL == g_wszRealFileName)                             ||
       (NULL == g_wszRealFileNameWithoutPath)                  ||
       (NULL == g_wszRealFileNameWithoutPathWithoutExtension)  ||
       (NULL == g_wszSchemaFileName)                           ||
       (NULL == g_wszSchemaFileNameWithoutPath)                ||
       (NULL == g_wszSchemaFileNameWithoutPathWithoutExtension)||
       (NULL == g_wszErrorFileSearchString)                    ||
       (NULL == g_wszHistoryFileSearchString)
      )
    {
        hr = E_INVALIDARG;
        goto exit;

    }

    m_wszHistoryFileDir = new WCHAR[g_cchHistoryFileDir+1];
    if(NULL == m_wszHistoryFileDir)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszHistoryFileDir, g_wszHistoryFileDir);
    m_cchHistoryFileDir = g_cchHistoryFileDir;

    m_wszRealFileName = new WCHAR[g_cchRealFileName+1];
    if(NULL == m_wszRealFileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszRealFileName, g_wszRealFileName);
    m_cchRealFileName = g_cchRealFileName;

    m_wszRealFileNameWithoutPath = new WCHAR[g_cchRealFileNameWithoutPath+1];
    if(NULL == m_wszRealFileNameWithoutPath)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszRealFileNameWithoutPath, g_wszRealFileNameWithoutPath);
    m_cchRealFileNameWithoutPath = g_cchRealFileNameWithoutPath;

    m_wszRealFileNameWithoutPathWithoutExtension = new WCHAR[g_cchRealFileNameWithoutPathWithoutExtension+1];
    if(NULL == m_wszRealFileNameWithoutPathWithoutExtension)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszRealFileNameWithoutPathWithoutExtension, g_wszRealFileNameWithoutPathWithoutExtension);
    m_cchRealFileNameWithoutPathWithoutExtension = g_cchRealFileNameWithoutPathWithoutExtension;

    if(NULL != g_wszRealFileNameExtension)
    {
        m_wszRealFileNameExtension = new WCHAR[g_cchRealFileNameExtension+1];
        if(NULL == m_wszRealFileNameExtension)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        wcscpy(m_wszRealFileNameExtension, g_wszRealFileNameExtension);
        m_cchRealFileNameExtension = g_cchRealFileNameExtension;
    }

    m_wszSchemaFileName = new WCHAR[g_cchSchemaFileName+1];
    if(NULL == m_wszSchemaFileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszSchemaFileName, g_wszSchemaFileName);
    m_cchSchemaFileName = g_cchSchemaFileName;

    m_wszSchemaFileNameWithoutPath = new WCHAR[g_cchSchemaFileNameWithoutPath+1];
    if(NULL == m_wszSchemaFileNameWithoutPath)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszSchemaFileNameWithoutPath, g_wszSchemaFileNameWithoutPath);
    m_cchSchemaFileNameWithoutPath = g_cchSchemaFileNameWithoutPath;

    m_wszSchemaFileNameWithoutPathWithoutExtension = new WCHAR[g_cchSchemaFileNameWithoutPathWithoutExtension+1];
    if(NULL == m_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszSchemaFileNameWithoutPathWithoutExtension, g_wszSchemaFileNameWithoutPathWithoutExtension);
    m_cchSchemaFileNameWithoutPathWithoutExtension = g_cchSchemaFileNameWithoutPathWithoutExtension;

    if(NULL != g_wszSchemaFileNameExtension)
    {
        m_wszSchemaFileNameExtension = new WCHAR[g_cchSchemaFileNameExtension+1];
        if(NULL == m_wszSchemaFileNameExtension)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        wcscpy(m_wszSchemaFileNameExtension, g_wszSchemaFileNameExtension);
        m_cchSchemaFileNameExtension = g_cchSchemaFileNameExtension;
    }

    m_wszErrorFileSearchString = new WCHAR[g_cchErrorFileSearchString+1];
    if(NULL == m_wszErrorFileSearchString)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszErrorFileSearchString, g_wszErrorFileSearchString);
    m_cchErrorFileSearchString = g_cchErrorFileSearchString;

    m_wszMetabaseDir = new WCHAR[g_cchMetabaseDir+1];
    if(NULL == m_wszMetabaseDir)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszMetabaseDir, g_wszMetabaseDir);
    m_cchMetabaseDir = g_cchMetabaseDir;

    m_wszHistoryFileSearchString = new WCHAR[g_cchHistoryFileSearchString+1];
    if(NULL == m_wszHistoryFileSearchString)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszHistoryFileSearchString, g_wszHistoryFileSearchString);
    m_cchHistoryFileSearchString = g_cchHistoryFileSearchString;

    if(bLocked)
    {
        g_LockMasterResource.ReadUnlock();
        bLocked = FALSE;
    }

    m_cchEditWhileRunningTempDataFile = m_cchMetabaseDir + (sizeof(MD_EDIT_WHILE_RUNNING_TEMP_DATA_FILE_NAMEW)/sizeof(WCHAR));
    m_wszEditWhileRunningTempDataFile = new WCHAR[m_cchEditWhileRunningTempDataFile+1];
    if(NULL == m_wszEditWhileRunningTempDataFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszEditWhileRunningTempDataFile, m_wszMetabaseDir);
    wcscat(m_wszEditWhileRunningTempDataFile, MD_EDIT_WHILE_RUNNING_TEMP_DATA_FILE_NAMEW);

    m_cchEditWhileRunningTempSchemaFile = m_cchMetabaseDir + (sizeof(MD_EDIT_WHILE_RUNNING_TEMP_SCHEMA_FILE_NAMEW)/sizeof(WCHAR));
    m_wszEditWhileRunningTempSchemaFile = new WCHAR[m_cchEditWhileRunningTempSchemaFile+1];
    if(NULL == m_wszEditWhileRunningTempSchemaFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszEditWhileRunningTempSchemaFile, m_wszMetabaseDir);
    wcscat(m_wszEditWhileRunningTempSchemaFile, MD_EDIT_WHILE_RUNNING_TEMP_SCHEMA_FILE_NAMEW);

    m_cchEditWhileRunningTempDataFileWithAppliedEdits = m_cchHistoryFileDir + (sizeof(MD_DEFAULT_DATA_FILE_NAMEW)/sizeof(WCHAR) + (sizeof(MD_TEMP_DATA_FILE_EXTW)/sizeof(WCHAR)));
    m_wszEditWhileRunningTempDataFileWithAppliedEdits = new WCHAR[m_cchEditWhileRunningTempDataFileWithAppliedEdits+1];
    if(NULL == m_wszEditWhileRunningTempDataFileWithAppliedEdits)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszEditWhileRunningTempDataFileWithAppliedEdits, m_wszHistoryFileDir);
    wcscat(m_wszEditWhileRunningTempDataFileWithAppliedEdits, MD_DEFAULT_DATA_FILE_NAMEW);
    wcscat(m_wszEditWhileRunningTempDataFileWithAppliedEdits, MD_TEMP_DATA_FILE_EXTW);

    hr = CoCreateInstance(CLSID_MSAdminBase,                  // CLSID
                          NULL,                               // controlling unknown
                          CLSCTX_SERVER,                      // desired context
                          IID_IMSAdminBase,                   // IID
                          (VOID**) (&m_pAdminBase ) );          // returned interface

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::Init] Unable to create the admin base object. hr = 0x%x\n",
                  hr));

        goto exit;
    }

exit:

    if(bLocked)
    {
        g_LockMasterResource.ReadUnlock();
        bLocked = FALSE;
    }

    return hr;

} // CFileListener::Init


/***************************************************************************++

Routine Description:

    Destructor for the CFileListener class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CFileListener::~CFileListener()
{
    if(NULL != m_pISTFileAdvise)
    {
        m_pISTFileAdvise->Release();
        m_pISTFileAdvise = NULL;
    }

    if(NULL != m_pISTDisp)
    {
        m_pISTDisp->Release();
        m_pISTDisp = NULL;
    }

    if(NULL != m_wszHistoryFileDir)
    {
        delete [] m_wszHistoryFileDir;
        m_wszHistoryFileDir = NULL;
    }
    m_cchHistoryFileDir             = 0;

    if(NULL != m_wszRealFileName)
    {
        delete [] m_wszRealFileName;
        m_wszRealFileName = NULL;
    }
    m_cchRealFileName    = 0;

    if(NULL != m_wszRealFileNameWithoutPath)
    {
        delete [] m_wszRealFileNameWithoutPath;
        m_wszRealFileNameWithoutPath = NULL;
    }
    m_cchRealFileNameWithoutPath    = 0;

    if(NULL != m_wszRealFileNameWithoutPathWithoutExtension)
    {
        delete [] m_wszRealFileNameWithoutPathWithoutExtension;
        m_wszRealFileNameWithoutPathWithoutExtension = NULL;
    }
    m_cchRealFileNameWithoutPathWithoutExtension    = 0;

    if(NULL != m_wszRealFileNameExtension)
    {
        delete [] m_wszRealFileNameExtension;
        m_wszRealFileNameExtension = NULL;
    }
    m_cchRealFileNameExtension    = 0;

    if(NULL != m_wszSchemaFileName)
    {
        delete [] m_wszSchemaFileName;
        m_wszSchemaFileName = NULL;
    }
    m_cchSchemaFileNameWithoutPath    = 0;

    if(NULL != m_wszSchemaFileNameWithoutPath)
    {
        delete [] m_wszSchemaFileNameWithoutPath;
        m_wszSchemaFileNameWithoutPath = NULL;
    }
    m_cchSchemaFileNameWithoutPath    = 0;

    if(NULL != m_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        delete [] m_wszSchemaFileNameWithoutPathWithoutExtension;
        m_wszSchemaFileNameWithoutPathWithoutExtension = NULL;
    }
    m_cchSchemaFileNameWithoutPathWithoutExtension    = 0;

    if(NULL != m_wszSchemaFileNameExtension)
    {
        delete [] m_wszSchemaFileNameExtension;
        m_wszSchemaFileNameExtension = NULL;
    }
    m_cchSchemaFileNameExtension    = 0;

    if(NULL != m_wszErrorFileSearchString)
    {
        delete [] m_wszErrorFileSearchString;
        m_wszErrorFileSearchString = NULL;
    }
    m_cchErrorFileSearchString = 0;

    if(NULL != m_wszMetabaseDir)
    {
        delete [] m_wszMetabaseDir;
        m_wszMetabaseDir = NULL;
    }
    m_cchMetabaseDir = 0;

    if(NULL != m_wszHistoryFileSearchString)
    {
        delete [] m_wszHistoryFileSearchString;
        m_wszHistoryFileSearchString = NULL;
    }
    m_cchHistoryFileSearchString = 0;

    if(NULL != m_wszEditWhileRunningTempDataFile)
    {
        delete [] m_wszEditWhileRunningTempDataFile;
        m_wszEditWhileRunningTempDataFile = NULL;
    }
    m_cchEditWhileRunningTempDataFile = 0;

    if(NULL != m_wszEditWhileRunningTempSchemaFile)
    {
        delete [] m_wszEditWhileRunningTempSchemaFile;
        m_wszEditWhileRunningTempSchemaFile = NULL;
    }
    m_cchEditWhileRunningTempSchemaFile = 0;

    if(NULL != m_wszEditWhileRunningTempDataFileWithAppliedEdits)
    {
        delete [] m_wszEditWhileRunningTempDataFileWithAppliedEdits;
        m_wszEditWhileRunningTempDataFileWithAppliedEdits = NULL;
    }
    m_cchEditWhileRunningTempDataFileWithAppliedEdits = 0;

    if(NULL != m_pCListenerController)
    {
        m_pCListenerController->Release();
        m_pCListenerController = NULL;
    }

    if(NULL != m_pAdminBase)
    {
        m_pAdminBase->Release();
        m_pAdminBase = NULL;
    }

}


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::QueryInterface

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP CFileListener::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_ISimpleTableFileChange)
    {
        *ppv = (ISimpleTableFileChange*) this;
    }
    else if(riid == IID_IUnknown)
    {
        *ppv = (ISimpleTableFileChange*) this;
    }

    if (NULL != *ppv)
    {
        ((ISimpleTableFileChange*)this)->AddRef ();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }

} // CFileListener::QueryInterface


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::AddRef

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CFileListener::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);

} // CFileListener::AddRef


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::Release

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CFileListener::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;

} // CFileListener::Release


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileCreate
    It adds the notifications to the received queue.

Arguments:

    [in]    FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileCreate(LPCWSTR i_wszFileName)
{
    return AddReceivedNotification(i_wszFileName, eFILE_CREATE);

} // CFileListener::OnFileCreate


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileModify
    It adds the notifications to the received queue.

Arguments:

    [in]    FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileModify(LPCWSTR i_wszFileName)
{
    return AddReceivedNotification(i_wszFileName, eFILE_MODIFY);

} // CFileListener::OnFileModify


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileDelete
    It adds the notifications to the received queue.

Arguments:

    [in]    FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileDelete(LPCWSTR)
{
    //
    // Ignore delete notofications.
    //

    return S_OK;

} // CFileListener::OnFileDelete


/***************************************************************************++

Routine Description:

    Read home directory of all sites and subscribe for file change
    notifications on them. Adds notification cookies to the requested queue.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::Subscribe()
{
    HRESULT hr = S_OK;

    //
    // Subscribe to the directory where metabase.xml resides.
    //

    if(0 == m_dwNotificationCookie)
    {

        DWORD      dwCookie     = 0;

        //
        // Subscribe for Notification
        //

        hr = m_pISTFileAdvise->SimpleTableFileAdvise((ISimpleTableFileChange *)this,
                                                     m_wszMetabaseDir,
                                                     m_wszRealFileNameWithoutPath,
                                                     0,  // No need to recursively search this directory.
                                                     &dwCookie);

        if (FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::Subscribe] Unable to subscribe to file changes. hr = 0x%x.\n",
                      hr));

            return hr;
        }

        //
        // Save notification cookie
        //

        m_dwNotificationCookie = dwCookie;

    }
    else
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[Subscribe] Already subscribed. %d\n",m_dwNotificationCookie));
    }


    //
    // If m_dwNotificationCookie is non-zero the is means that we've already
    // subscribed.
    //

    return hr;

} // CFileListener::Subscribe


/***************************************************************************++

Routine Description:

    Unsubscribe for file change notifications on obsolete directories or
    all directories if the service is being stopped. Purges entries from the
    requested queue.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::UnSubscribe()
{

    HRESULT hr = S_OK;

    if(m_dwNotificationCookie != 0)
    {
        //
        // Unsubscribe only if you have subscribed before.
        //

        hr = m_pISTFileAdvise->SimpleTableFileUnadvise(m_dwNotificationCookie);

        m_dwNotificationCookie = 0;

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[UnSubscribe] Unsubscribing for file change notifications failed hr=0x%x.\n",
                      hr));
        }


    }
    else
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[UnSubscribe] Nothing to unsubscribe for.\n"));
    }

    EnterCriticalSection(&g_csEditWhileRunning);
    //
    // Reset the g_EWRProcessedMetabaseTimeStamp when the EWR thread is
    // unsubscribing, so that the next SaveAllData will rename - else we
    // may land up in a condition where we never rename in  SaveAllData
    // especially if we have missed notifications.
    //
    memset((LPVOID)&g_EWRProcessedMetabaseTimeStamp, 0, sizeof(FILETIME));
    LeaveCriticalSection(&g_csEditWhileRunning);

    return hr;

} // CFileListener::UnSubscribe


/***************************************************************************++

Routine Description:

    This method checks to see if the received notification is relevant and if
    so, sets the event to trigger processing.

Arguments:

    [in] Notified file name .
    [in] Notified status.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::AddReceivedNotification(LPCWSTR i_wszFile, DWORD)
{
    HRESULT hr        = S_OK;

    if(0 == _wcsicmp(i_wszFile, m_wszRealFileName))
    {
        WIN32_FILE_ATTRIBUTE_DATA faData;

        if(GetFileAttributesExW(i_wszFile, GetFileExInfoStandard, &faData) &&
           faData.nFileSizeHigh == 0                                       &&
           faData.nFileSizeLow  == 3 /*3 bytes for the UTF-8 signature*/)
        {
            //
            //Only set the event if the file is larger than the UTF-8 signature.  When we see 0 bytes we cannot rely on the fact
            //that the file is really 0 bytes, because sometimes GetFileAttributes retuns 0 size even if the file has data in it.
            //Hence text editors that CreateFile(CREATE_ALWAYS) and generate a notification when the file is first opened (and truncated to 0 bytes)
            //will be processed. If there is no data in the file, they may see an error.
            //Sometimes, however, we get the notification AFTER the text editor has had a change to write some bytes.  No problem.  In this
            //case also we'll log a warning.  Rough testing indicates that 98% of the time, we notification in time
            //to prevent the bogus event log entries.
            //
        }
        else if(!SetEvent((m_pCListenerController->Event())[iEVENT_PROCESSNOTIFICATIONS]))
        {
           hr = HRESULT_FROM_WIN32(GetLastError());
        }

        DBGINFOW((DBG_CONTEXT,
                 L"[CFileListener::AddReceivedNotification] Low:%d, High:%d\n",
                 faData.nFileSizeLow,
                 faData.nFileSizeHigh));


    }

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::AddReceivedNotification] Error while saving file change notification. hr = 0x%x.\n",
                  hr));
    }

    return hr;

} // CFileListener::AddReceivedNotification


/***************************************************************************++

Routine Description:

    This processes the changes.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CFileListener::ProcessChanges()
{
    HRESULT                   hr                          = S_OK;
    ULONG                     ulMajorVersion              = 0;
    LPWSTR                    wszHistoryFile              = NULL;
    WCHAR                     wszMinorVersionNumber[MD_CCH_MAX_ULONG+1];
    int                       res                         = 0;
    LPWSTR                    pwsz                        = NULL;
    HANDLE                    hFind                       = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW          FileData;
    ULONG                     ulStartMinorVersion         = 0;
    ULONG                     ulMaxMinorVersion           = 0;
    ULONG                     ulMinorVersion              = 0;
    BOOL                      bGetTableFailed             = FALSE;

    if(ProgrammaticMetabaseSaveNotification())
    {
        goto exit;
    }

    //
    // Get the version number
    // GetVersionNumber already has the retry logic in it.
    //

    hr = GetVersionNumber(m_wszEditWhileRunningTempDataFile,
                          &ulMajorVersion,
                          &bGetTableFailed);

    if(FAILED(hr))
    {

        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_READ_XML_FILE,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr);

        goto exit;

    }

    //
    // Construct the history file search string, to search for the largest minor version.
    //

    hr = ConstructHistoryFileNameWithoutMinorVersion(&wszHistoryFile,
                                                     &ulStartMinorVersion,
                                                     m_wszHistoryFileSearchString,
                                                     m_cchHistoryFileSearchString,
                                                     m_wszRealFileNameExtension,
                                                     m_cchRealFileNameExtension,
                                                     ulMajorVersion);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBGINFOW((DBG_CONTEXT,
              L"[CFileListener::ProcessChanges] Searching for history files of type: %s.\n",
              wszHistoryFile));

    //
    // Search for all history files with the matching version number, pick the
    // one with the largest minor version and compute the history file name
    // with the largest minor.
    //

    hFind = FindFirstFileW(wszHistoryFile, &FileData);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_NO_MATCHING_HISTORY_FILE,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr,
                    wszHistoryFile);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] No history files found of type %s. FindFirstFileW failed with hr=0x%x.\n",
                  wszHistoryFile,
                  hr));
        bGetTableFailed = TRUE; // Set this so that we force a flush to disk
        goto exit;
    }

    ulMaxMinorVersion = 0;
    do
    {
        hr = ParseVersionNumber(FileData.cFileName,
                                m_cchRealFileNameWithoutPathWithoutExtension,
                                &ulMinorVersion,
                                NULL);

        if(FAILED(hr))
        {
            goto exit;
        }

        if(ulMinorVersion >= ulMaxMinorVersion)
        {
            ulMaxMinorVersion                   = ulMinorVersion;
            wszHistoryFile[ulStartMinorVersion] = 0;

            res = _snwprintf(wszMinorVersionNumber,
                             MD_CCH_MAX_ULONG+1,
                             L"%010lu",
                             ulMinorVersion);
            if(res < 0)
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[ProcessChanges] _snwprintf returned a negative value. This should never happen.\n"));
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto exit;
            }

            memcpy(&(wszHistoryFile[ulStartMinorVersion]),
                   wszMinorVersionNumber,
                   MD_CCH_MAX_ULONG*sizeof(WCHAR));
        }

    }while (FindNextFileW(hFind, &FileData));

    DBGINFOW((DBG_CONTEXT,
              L"[CFileListener::ProcessChanges] History file found %s.\n",
              wszHistoryFile));

    //
    // Process changes
    //

    pwsz = wcsstr(wszHistoryFile, MD_LONG_STRING_PREFIXW);
    if((NULL != pwsz) &&
       (wszHistoryFile == pwsz)
      )
    {
        pwsz = pwsz + MD_CCH_LONG_STRING_PREFIXW;
    }
    else
    {
        pwsz = wszHistoryFile;
    }

    hr = ProcessChangesFromFile(pwsz,
                                ulMajorVersion,
                                ulMaxMinorVersion,
                                &bGetTableFailed);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    if(FAILED(hr))
    {
        CopyErrorFile(bGetTableFailed, hr);

    }

    DeleteTempFiles();

    if(NULL != wszHistoryFile)
    {
        delete [] wszHistoryFile;
        wszHistoryFile = NULL;
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Diff the real file with the given file and process changes

Arguments:

    [in] History file to diff with
    [in] Next minor version of the history file that will have updated changes

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::ProcessChangesFromFile(LPWSTR i_wszHistoryFile,
                                              ULONG  i_ulMajorVersion,
                                              ULONG  i_ulMaxMinorVersion,
                                              BOOL*  o_bGetTableFailed)
{
    ISimpleTableWrite2*       pISTDiff                = NULL;
    CWriterGlobalHelper*      pISTHelper              = NULL;
    IErrorInfo*               pIErrorInfo             = NULL;
    ISimpleTableRead2*        pISTTest                = NULL;
    HRESULT                   hr                      = S_OK;
    HRESULT                   hrSav                   = S_OK;
    STQueryCell               QueryCell[3];
    ULONG                     cCell                   = sizeof(QueryCell)/sizeof(STQueryCell);
    ULONG                     iRow                    = 0;
    DWORD                     dwPreviousLocationID    = (DWORD)-1;
    METADATA_HANDLE           hMBPath                 = NULL;
    LPWSTR                    wszChildKey             = NULL;
    LPVOID                    a_pv[cMBPropertyDiff_NumberOfColumns];
    ULONG                     a_Size[cMBPropertyDiff_NumberOfColumns];
    ULONG                     a_iCol[]                = {iMBPropertyDiff_Name,
                                                         iMBPropertyDiff_Type,
                                                         iMBPropertyDiff_Attributes,
                                                         iMBPropertyDiff_Value,
                                                         iMBPropertyDiff_Group,
                                                         iMBPropertyDiff_Location,
                                                         iMBPropertyDiff_ID,
                                                         iMBPropertyDiff_UserType,
                                                         iMBPropertyDiff_LocationID,
                                                         iMBPropertyDiff_Directive,
                                                         };
    ULONG                     cCol                    = sizeof(a_iCol)/sizeof(ULONG);
    METADATA_RECORD           MBRecord;

    *o_bGetTableFailed = FALSE;

    //
    // Fetch the diff-ed table.
    //

    hr = GetGlobalHelperAndCopySchemaFile(&pISTHelper);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] GetGlobalHelper failed with hr = 0x%x. Hence unable to get meta tables and hence unable to process changes.\n",
                  hr));

        goto exit;
    }

    QueryCell[0].pData     = (LPVOID)pISTHelper->m_wszBinFileForMeta;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_SCHEMAFILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = 0;

    QueryCell[1].pData     = (LPVOID)i_wszHistoryFile;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iST_CELL_FILE;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = 0;

    QueryCell[2].pData     = (LPVOID)m_wszEditWhileRunningTempDataFile;
    QueryCell[2].eOperator = eST_OP_EQUAL;
    QueryCell[2].iCell     = iST_CELL_FILE;
    QueryCell[2].dbType    = DBTYPE_WSTR;
    QueryCell[2].cbSize    = 0;

    hr = m_pISTDisp->GetTable(wszDATABASE_METABASE,
                              wszTABLE_MBPropertyDiff,
                              (LPVOID)QueryCell,
                              (LPVOID)&cCell,
                              eST_QUERYFORMAT_CELLS,
                              fST_LOS_READWRITE,
                              (LPVOID *)&pISTDiff);

    if(FAILED(hr))
    {
        //
        // Log an error saying could not compute the diffs.
        //

        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_COMPUTING_TEXT_EDITS,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Unable to get the %s table. hr = 0x%x\n",
                  wszTABLE_MBPropertyDiff, hr));

        *o_bGetTableFailed = TRUE;

        goto exit;
    }
    else
    {
        //
        // If the interceptor has encoutered any errors that it can tolerate,
        // it would have set extended error information in addition to logging
        // warnings. In this case, we will continue to process the user edits,
        // but, we will copy the metabase.xml to an errors file at the end.
        // This is so that the user can get an opportunity to look at the
        // edits that caused the warnings.
        //

        hr = GetErrorInfo(0,
                          &pIErrorInfo);

        if(S_OK == hr)
        {
            // If the interceptor has SetErrorInfo, then QI for
            // ISimpleTableRead2 should succeed.

            hr = pIErrorInfo->QueryInterface(IID_ISimpleTableRead2,
                                             (LPVOID *)&pISTTest);

            if(SUCCEEDED(hr))
            {
                // By setting o_bGetTableFailed to true, we will ensure that
                // the errors file is copied.
                *o_bGetTableFailed = TRUE;
            }
        } // Only other hr is S_FALSE, which means no errors to report.
    }


    //
    // Traverse the diffed table and apply changes
    //

    if(NULL == m_pAdminBase)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        LogEvent(m_pCListenerController->EventLog(),
                 MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE,
                 EVENTLOG_ERROR_TYPE,
                 ID_CAT_CAT,
                 hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Admin base object not initialized. hr = 0x%x\n",
                  hr));

        goto exit;
    }


    for(iRow=0;;iRow++)
    {
        BOOL                bLocationWithProperty   = TRUE;
        BOOL                bSecure                 = FALSE;
        BOOL                bChangeApplied          = FALSE;
        BOOL                bInsertedNewLocation    = FALSE;

        MBRecord.dwMDDataTag = 0;

        hr = pISTDiff->GetColumnValues(iRow,
                                       cCol,
                                       a_iCol,
                                       a_Size,
                                       a_pv);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;

            if(0== iRow)
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::ProcessChanges] No changes occured.\n"));

                goto exit;
            }
            else
            {
                break;
            }
        }
        else if(FAILED(hr))
        {

            LogEvent(m_pCListenerController->EventLog(),
                        MD_ERROR_READING_TEXT_EDITS,
                        EVENTLOG_ERROR_TYPE,
                        ID_CAT_CAT,
                        hr);

            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::ProcessChanges] Unable to read from %s table. GetColumnValues on %d row failed with hr = 0x%x\n",
                      wszTABLE_MBPropertyDiff, iRow, hr));

            goto exit;
        }

        //
        // Apply the changes to the metabase.
        //

        if((*(DWORD*)a_pv[iMBProperty_ID] == MD_LOCATION) && (*(LPWSTR)a_pv[iMBProperty_Name] == L'#'))
        {
            bLocationWithProperty = FALSE;
        }

        if(((DWORD)(*(DWORD*)a_pv[iMBPropertyDiff_Attributes]) & ((DWORD)METADATA_SECURE)) != 0)
        {
            bSecure = TRUE;
        }

        if(dwPreviousLocationID != *(DWORD*)a_pv[iMBPropertyDiff_LocationID])
        {
            //
            // Detected a new location. Open the metabase key at that location.
            //

            dwPreviousLocationID = *(DWORD*)a_pv[iMBPropertyDiff_LocationID];

            if(NULL != hMBPath)
            {
                m_pAdminBase->CloseKey(hMBPath);
                hMBPath = NULL;
            }

            switch(*(DWORD*)a_pv[iMBPropertyDiff_Directive])
            {
            case eMBPropertyDiff_Insert:

                    // For inserts open the current node. If the node is
                    // missing, add it - perhaps it is the 1st property
                    // in the node.

                    hr = OpenKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
                                 m_pAdminBase,
                                 TRUE,
                                 &hMBPath,
                                 &bInsertedNewLocation);
                    break;

                case eMBPropertyDiff_Update:

                    // For update open the current node. If the node is
                    // missing, do not add it - perhaps it was deleted

                    hr = OpenKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
                                 m_pAdminBase,
                                 FALSE,
                                 &hMBPath,
                                 NULL);
                    break;

                case eMBPropertyDiff_Delete:

                    // For update open the current node. If the node is
                    // missing, do not add it - perhaps it was deleted

                    hr = OpenKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
                                 m_pAdminBase,
                                 FALSE,
                                 &hMBPath,
                                 NULL);

                    if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
                    {
                        // If the parent is already deleted, we assume child has
                        // already been deleted and continue.

                        bChangeApplied = TRUE;

                        hr = SaveChange(iRow,
                                        pISTDiff);

                        if(SUCCEEDED(hr))
                        {
                            continue;
                        }
                    }
                    break;

                case eMBPropertyDiff_DeleteNode:

                    // For delete node - open the parent node.

                    hr = OpenParentKeyAndGetChildKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
                                                     m_pAdminBase,
                                                     &hMBPath,
                                                     &wszChildKey);

                    if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
                    {
                        // If the parent is already deleted, we assume child has
                        // already been deleted and continue.

                        bChangeApplied = TRUE;

                        hr = SaveChange(iRow,
                                        pISTDiff);

                        if(SUCCEEDED(hr))
                        {
                            continue;
                        }
                    }
                    else if(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
                    {
                        // This error code is returned when someone is trying to delete
                        // root node - so force savealldata by setting o_bGetTableFailed
                        // to true
                        *o_bGetTableFailed = TRUE;
                    }
                    break;

                default:
                     hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    break;
            }

            if(FAILED(hr))
            {

                LogEvent(m_pCListenerController->EventLog(),
                            MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE,
                            EVENTLOG_ERROR_TYPE,
                            ID_CAT_CAT,
                            hr,
                            (LPWSTR)a_pv[iMBPropertyDiff_Location]);
                goto exit;
            }

        } // End if new location

        MD_ASSERT(NULL != a_pv[iMBPropertyDiff_ID]);
        MD_ASSERT(NULL != a_pv[iMBPropertyDiff_Attributes]);
        MD_ASSERT(NULL != a_pv[iMBPropertyDiff_UserType]);
        MD_ASSERT(NULL != a_pv[iMBPropertyDiff_Type]);

        MBRecord.dwMDIdentifier    = *(DWORD*)a_pv[iMBPropertyDiff_ID];
        MBRecord.dwMDAttributes    = *(DWORD*)a_pv[iMBPropertyDiff_Attributes];
        MBRecord.dwMDUserType      = *(DWORD*)a_pv[iMBPropertyDiff_UserType];
        MBRecord.dwMDDataType      = *(DWORD*)a_pv[iMBPropertyDiff_Type];
        MBRecord.dwMDDataLen       = a_Size[iMBPropertyDiff_Value];
        MBRecord.pbMDData          = (unsigned char*)a_pv[iMBPropertyDiff_Value];

        bChangeApplied = FALSE;

        switch(*(DWORD*)a_pv[iMBPropertyDiff_Directive])
        {
             case eMBPropertyDiff_Insert:
             case eMBPropertyDiff_Update:
                 if(bSecure)
                 {
                    LogEvent(g_pEventLog,
                             MD_WARNING_SECURE_PROPERTY_EDITS_NOT_ALLOWED,
                             EVENTLOG_WARNING_TYPE,
                             ID_CAT_CAT,
                             (DWORD)HRESULT_FROM_WIN32(ERROR_INVALID_DATA),
                             (LPWSTR)(a_pv[iMBPropertyDiff_Location]),
                             (LPWSTR)(a_pv[iMBPropertyDiff_Name]));

                 }
                 else if(bLocationWithProperty && (MBRecord.dwMDIdentifier != MD_GLOBAL_SESSIONKEY))
                 {
                     hr = m_pAdminBase->SetData(hMBPath,
                                              NULL,
                                              &MBRecord);

                     bChangeApplied = TRUE;

                     DBGINFOW((DBG_CONTEXT,
                               L"[CFileListener::ProcessChanges] Set %s:%d.\n",
                              (LPWSTR)a_pv[iMBPropertyDiff_Location], MBRecord.dwMDIdentifier));

                 }
                 else if(!bLocationWithProperty)
                 {
                     bChangeApplied = TRUE;
                 }

                 break;
             case eMBPropertyDiff_Delete:
                 if(bSecure)
                 {
                    LogEvent(g_pEventLog,
                             MD_WARNING_SECURE_PROPERTY_EDITS_NOT_ALLOWED,
                             EVENTLOG_WARNING_TYPE,
                             ID_CAT_CAT,
                             (DWORD)HRESULT_FROM_WIN32(ERROR_INVALID_DATA),
                             (LPWSTR)(a_pv[iMBPropertyDiff_Location]),
                             (LPWSTR)(a_pv[iMBPropertyDiff_Name]));

                 }
                 else if(bLocationWithProperty)
                 {
                     hr = m_pAdminBase->DeleteData(hMBPath,
                                                 NULL,
                                                 MBRecord.dwMDIdentifier,
                                                 MBRecord.dwMDDataType);

                     if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
                     {
                        hr = S_OK; // Reset hr and assume already deleted.
                     }

                     bChangeApplied = TRUE;

                     DBGINFOW((DBG_CONTEXT,
                               L"[CFileListener::ProcessChanges] Deleted %s:%d.\n",
                              (LPWSTR)a_pv[iMBPropertyDiff_Location], MBRecord.dwMDIdentifier));

                 }
                 break;
             case eMBPropertyDiff_DeleteNode:
                 hr = m_pAdminBase->DeleteKey(hMBPath,
                                            wszChildKey);

                 if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
                 {
                    hr = S_OK; // Reset hr and assume already deleted.
                 }

                 bChangeApplied = TRUE;

                 DBGINFOW((DBG_CONTEXT,
                           L"[CFileListener::ProcessChanges] Deleted key %s.\n",
                          (LPWSTR)a_pv[iMBPropertyDiff_Location]));

                 break;
             default:
                 hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                 break;

        }
        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::ProcessChanges] Above action failed with hr= 0x%x.\n",
                      hr));

            LogEvent(m_pCListenerController->EventLog(),
                        MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE,
                        EVENTLOG_ERROR_TYPE,
                        ID_CAT_CAT,
                        hr,
                        (LPWSTR)a_pv[iMBPropertyDiff_Location]);

            if((bInsertedNewLocation) &&
               (eMBPropertyDiff_Insert == *(DWORD*)a_pv[iMBPropertyDiff_Directive]))            {

                //
                // This means that the first property could not be added, but the node has been
                // added - hence save a change that indicates a node with no property was added.
                //

                hrSav = SaveChangeAsNodeWithNoPropertyAdded(a_pv,
                                                            pISTDiff);

                if(FAILED(hrSav))
                {
                    goto exit;
                }
            }

            goto exit;
        }
        else if(bChangeApplied)
        {
            //
            // Keep track of the succeeded row, by adding to the write cache.
            //

            hr = SaveChange(iRow,
                            pISTDiff);

            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

exit:
    if(NULL != hMBPath)
    {
        m_pAdminBase->CloseKey(hMBPath);
        hMBPath = NULL;
    }

    //
    // We should always attempt to create a history file with successfully
    // applied changes - even if we were not able to apply all changes and
    // there were errors half way through. This is because we want to track
    // the changes that made it to memory. This way if the user re-edits
    // the file, the diff will happen correctly. For Eg: If a user inserts
    // a node A and edits some properties on another node B. Lets say that
    // node A insert is applied and node B edits cause an error. If we do
    // not create a history file with node A edits, then if the user re-edits
    // the file and deletes node A, we will not capture that in the diff.
    //

    //
    // Compute the next minor version.
    //

    if(0xFFFFFFFF == i_ulMaxMinorVersion)
    {
        LogEvent(m_pCListenerController->EventLog(),
                    MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND,
                    EVENTLOG_WARNING_TYPE,
                    ID_CAT_CAT,
                    hr);

    }
    else
    {
        i_ulMaxMinorVersion++;
    }

    hrSav = ApplyChangeToHistoryFile(pISTHelper,
                                     pISTDiff,
                                     i_wszHistoryFile,
                                     i_ulMajorVersion,
                                     i_ulMaxMinorVersion);

    if(FAILED(hrSav))
    {
        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hrSav);

        if(SUCCEEDED(hr))
        {
            hr = hrSav;
        }
    }

    if(NULL != pISTDiff)
    {
        pISTDiff->Release();
        pISTDiff = NULL;
    }

    if(NULL != pISTHelper)
    {
        delete pISTHelper;
        pISTHelper = NULL;
    }

    if(NULL != pISTTest)
    {
        pISTTest->Release();
        pISTTest = NULL;
    }

    if(NULL != pIErrorInfo)
    {
        pIErrorInfo->Release();
        pIErrorInfo = NULL;
    }

    return hr;

}  // CFileListener::ProcessChangesFromFile


/***************************************************************************++

Routine Description:

    Opens the parent key and returns the pointer to the child key.

Arguments:

    [in]  Location.
    [in]  Adminbase pointer.
    [out] Metadata handle to opened key.
    [out] Pointer in the location string to the child key.

Return Value:

    HRESULT_FROM_WIN32(ERROR_INVALID_DATA) If the parent key is not found (eg
                                           when the location string is mal-
                                           formed, or the parent is the
                                           root location.
    HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) If the parent key is found but
                                             missing in the metabase ie if we
                                             cannot open the parent key.
    Base Object error codes for IMSAdminBase::OpenKey

--***************************************************************************/
HRESULT CFileListener::OpenParentKeyAndGetChildKey(LPWSTR           i_wszLocation,
                                                   IMSAdminBase*    i_pAdminBase,
                                                   METADATA_HANDLE* o_pHandle,
                                                   WCHAR**          o_wszChildKey)
{
    HRESULT hr           = S_OK;
    LPWSTR  wszParentKey = NULL;
    LPWSTR  wszEnd       = NULL;

    *o_wszChildKey = NULL;

    wszParentKey = new WCHAR[wcslen(i_wszLocation)+1];
    if(NULL == wszParentKey)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(wszParentKey, i_wszLocation);
    wszEnd = wcsrchr(wszParentKey, g_wchFwdSlash);

    if(NULL == wszEnd)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::OpenParentKeyAndGetChildKey] Unable to find parent key: %s\n",
                  i_wszLocation));
        goto exit;
    }
    else if(wszParentKey != wszEnd)
    {
        *wszEnd = NULL;
    }
    else if(*(++wszEnd) == L'\0')
    {
        //
        // Someone is trying to delete the root location.
        //

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::OpenParentKeyAndGetChildKey] Unable to delete/modify the root key: %s\n",
                  i_wszLocation));

        goto exit;

    }
    else
    {
        //
        // Someone is trying to delete the subkey of the root.
        //

        *wszEnd=0;
    }

    *o_wszChildKey = wcsrchr(i_wszLocation, g_wchFwdSlash);

    //
    // At this point wszChildKey cannot be NULL because it has been validated above,
    //
    //

    (*o_wszChildKey)++;

    hr = i_pAdminBase->OpenKey(NULL,
                               wszParentKey,
                               METADATA_PERMISSION_WRITE,
                               MB_TIMEOUT_LISTENER,
                               o_pHandle);

    if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Unable to open %s key. IMSAdminBase::OpenKey failed with hr = 0x%x. Assuming %s is deleted.\n",
                  wszParentKey, hr, i_wszLocation));

        goto exit;
    }
    else if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Unable to open %s key. IMSAdminBase::OpenKey failed with hr = 0x%x. Hence unable to delete %s.\n",
                  wszParentKey, hr, i_wszLocation));

        goto exit;
    }

exit:

    if(NULL != wszParentKey)
    {
        delete [] wszParentKey;
        wszParentKey = NULL;
    }

    return hr;

} // CFileListener::OpenParentKeyAndGetChildKey


/***************************************************************************++

Routine Description:

    Opens the parent key and returns the pointer to the child key.

Arguments:

    [in]  Location.
    [in]  Adminbase pointer.
    [out] Metadata handle to opened key.
    [out] Pointer in the location string to the child key.
    [out] Bool indicating key was created.

Return Value:

    E_OUTOFMEMORY
    Base Object error codes for IMSAdminBase::OpenKey

--***************************************************************************/
HRESULT CFileListener::OpenKey(LPWSTR           i_wszLocation,
                               IMSAdminBase*    i_pAdminBase,
                               BOOL             i_bAddIfMissing,
                               METADATA_HANDLE* o_pHandle,
                               BOOL*            o_bInsertedKey)
{
    HRESULT hr           = S_OK;
    LPWSTR  wszChildKey  = NULL;

    if(NULL != o_bInsertedKey)
    {
        *o_bInsertedKey = FALSE;
    }

    hr = i_pAdminBase->OpenKey(NULL,
                               i_wszLocation,
                               METADATA_PERMISSION_WRITE,
                               MB_TIMEOUT_LISTENER,
                               o_pHandle);

    if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
    {
        if(i_bAddIfMissing)
        {
             //
             // Perhaps a location was inserted and this was the first property
             // in the location. Add the key and reopen it for write.
             //

            hr = OpenParentKeyAndGetChildKey(i_wszLocation,
                                             i_pAdminBase,
                                             o_pHandle,
                                             &wszChildKey);

            if(FAILED(hr))
            {
                if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
                {
                    LogEvent(m_pCListenerController->EventLog(),
                                MD_ERROR_METABASE_PATH_NOT_FOUND,
                                EVENTLOG_ERROR_TYPE,
                                ID_CAT_CAT,
                                hr,
                                i_wszLocation);

                }

                return hr;
            }

            hr = i_pAdminBase->AddKey(*o_pHandle,
                                      wszChildKey);

            i_pAdminBase->CloseKey(*o_pHandle);
            *o_pHandle = NULL;

            if(FAILED(hr))
            {

                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::OpenKey] Unable to add %s key. IMSAdminBase::AddKey failed with hr = 0x%x.\n",
                          i_wszLocation, hr));

                return hr;
            }

            if(NULL != o_bInsertedKey)
            {
                *o_bInsertedKey = TRUE;
            }

            hr = i_pAdminBase->OpenKey(NULL,
                                       i_wszLocation,
                                       METADATA_PERMISSION_WRITE,
                                       MB_TIMEOUT_LISTENER,
                                       o_pHandle);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::OpenKey] Unable to open %s key, after successfully adding it. IMSAdminBase::OpenKey failed with hr = 0x%x.\n",
                          i_wszLocation, hr));

                return hr;
            }

            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::OpenKey] Successfully added and reopened %s key.\n",
                      i_wszLocation));
        }
        else
        {
            LogEvent(m_pCListenerController->EventLog(),
                        MD_ERROR_METABASE_PATH_NOT_FOUND,
                        EVENTLOG_ERROR_TYPE,
                        ID_CAT_CAT,
                        hr,
                        i_wszLocation);
        }

    }
    else if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
          L"[CFileListener::OpenKey] Unable to open %s key. IMSAdminBase::OpenKey failed with unexpected hr = 0x%x.\n",
          i_wszLocation, hr));
    }

    return hr;

} // CFileListener::OpenKey


/***************************************************************************++

Routine Description:

    Copies the read row into the write cache. This routine is called when
    a change has successfully been applied to the metabase. By copying the
    read row in the write cache, we are keeping track of all successful
    changes.

Arguments:

    [in] Read row index.
    [in] Write cache IST

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::SaveChange(ULONG                    i_iRow,
                                  ISimpleTableWrite2*    i_pISTDiff)
{
    ULONG   iWriteRow = 0;
    HRESULT hr        = S_OK;

    hr = i_pISTDiff->AddRowForUpdate(i_iRow,
                                     &iWriteRow);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::SaveChanges] Unable to track successful changes. AddRowForUpdate failed with hr= 0x%x.\n",
                  hr));

        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_SAVING_APPLIED_TEXT_EDITS,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr);

    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Adds a row in the write cache. It is called when a node is inserted in
    the metabase, but the properties could not be applied.

Arguments:

    [in] Location.
    [in] Write cache IST

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::SaveChangeAsNodeWithNoPropertyAdded(LPVOID*                i_apvDiff,
                                                           ISimpleTableWrite2*    i_pISTDiff)
{
    ULONG   iWriteRow = 0;
    HRESULT hr        = S_OK;

    MD_ASSERT(NULL != i_pISTDiff);

    hr = i_pISTDiff->AddRowForInsert(&iWriteRow);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::SaveChanges] Unable to track successful changes. AddRowForUpdate failed with hr= 0x%x.\n",
                  hr));

        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_SAVING_APPLIED_TEXT_EDITS,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr);

    }
    else
    {
        static LPCWSTR wszLocationNoProperty = L"#LocationWithNoProperties";
        static DWORD   dwIDLocation          = MD_LOCATION;
        static DWORD   dwType                = STRING_METADATA;
        static DWORD   dwAttributes          = METADATA_NO_ATTRIBUTES;
        static DWORD   dwDirective           = eMBPropertyDiff_Insert;
        static DWORD   dwUserType            = IIS_MD_UT_SERVER;
        static DWORD   dwGroup               = eMBProperty_IIsConfigObject;

        LPVOID  a_pv[cMBPropertyDiff_NumberOfColumns];
        ULONG   a_iCol[] = {iMBPropertyDiff_Name,
                            iMBPropertyDiff_Type,
                            iMBPropertyDiff_Attributes,
                            iMBPropertyDiff_Value,
                            iMBPropertyDiff_Location,
                            iMBPropertyDiff_ID,
                            iMBPropertyDiff_UserType,
                            iMBPropertyDiff_LocationID,
                            iMBPropertyDiff_Directive,
                            iMBPropertyDiff_Group
        };
        ULONG  cCol = sizeof(a_iCol)/sizeof(ULONG);
        ULONG  a_cb[cMBPropertyDiff_NumberOfColumns];

        a_cb[iMBPropertyDiff_Value] = 0;

        a_pv[iMBPropertyDiff_Name]        = (LPVOID)wszLocationNoProperty;
        a_pv[iMBPropertyDiff_Type]        = (LPVOID)&dwType;
        a_pv[iMBPropertyDiff_Attributes]  = (LPVOID)&dwAttributes;
        a_pv[iMBPropertyDiff_Value]       = NULL;
        a_pv[iMBPropertyDiff_Location]    = i_apvDiff[iMBPropertyDiff_Location];
        a_pv[iMBPropertyDiff_ID]          = (LPVOID)&dwIDLocation;
        a_pv[iMBPropertyDiff_UserType]    = (LPVOID)&dwUserType;
        a_pv[iMBPropertyDiff_LocationID]  = i_apvDiff[iMBPropertyDiff_LocationID];
        a_pv[iMBPropertyDiff_Directive]   = (LPVOID)&dwDirective;
        a_pv[iMBPropertyDiff_Group]       = (LPVOID)&dwGroup;

        hr = i_pISTDiff->SetWriteColumnValues(iWriteRow,
                                              cCol,
                                              a_iCol,
                                              a_cb,
                                              a_pv);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::SaveChanges] Unable to track successful changes. AddRowForUpdate failed with hr= 0x%x.\n",
                      hr));

            LogEvent(m_pCListenerController->EventLog(),
                        MD_ERROR_SAVING_APPLIED_TEXT_EDITS,
                        EVENTLOG_ERROR_TYPE,
                        ID_CAT_CAT,
                        hr);

        }

    }

    return hr;

} // CFileListener::SaveChangeAsNodeWithNoPropertyAdded


/***************************************************************************++

Routine Description:

    Copies the changed file to the history directory with errors appended to
    it.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::CopyErrorFile(BOOL            i_bGetTableFailed, HRESULT i_hrThatCausedTheCopyErrorFile)
{
    HANDLE              hFind               = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FileData;
    ULONG               ulMaxErrorVersion    = 0;
    ULONG               ulErrorVersion       = 0;
    WCHAR               wszErrorVersionNumber[MD_CCH_MAX_ULONG+1];
    HRESULT             hr                  = S_OK;
    int                 res                 = 0;
    LPWSTR              pEnd                = NULL;
    ULONG               ulBeginUnderscore   = 0;
    ULONG               ulBeginVersion      = 0;
    METABASE_FILE_DATA  aOldVersionsFixed[MD_MAX_HISTORY_FILES_ALLOC_SIZE];
    METABASE_FILE_DATA* aOldVersions        = (METABASE_FILE_DATA*)&(aOldVersionsFixed[0]);
    BOOL                bReAlloced          = FALSE;
    ULONG               cVersions           = MD_MAX_HISTORY_FILES_ALLOC_SIZE;
    ULONG               iVersion            = 0;
    ULONG               cMaxErrorFiles      = 0;

    //
    // Restore the search string in case it has been overwritten
    //

    ulBeginUnderscore = m_cchErrorFileSearchString           -
                        m_cchRealFileNameExtension           -
                        MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW;

    ulBeginVersion = ulBeginUnderscore +
                     MD_CCH_UNDERSCOREW;

    pEnd = m_wszErrorFileSearchString + ulBeginUnderscore;
    memcpy(pEnd, MD_ERROR_FILE_SEARCH_EXTENSIONW, MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));

    //
    // Search for all existing error files and compute version number for the
    // new error file
    //

    hFind = FindFirstFileW(m_wszErrorFileSearchString, &FileData);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::CopyErrorFile] No error files found. hr=0x%x.\n",
                  hr));
    }
    else
    {
        do
        {
            ULONG   ulBeginUnderscoreFileData = m_cchRealFileNameWithoutPathWithoutExtension +
                                                MD_CCH_ERROR_FILE_NAME_EXTENSIONW;

            res = swscanf(&(FileData.cFileName[ulBeginUnderscoreFileData]),
                          L"_%lu",
                          &ulErrorVersion);

            if((0   == res) ||
               (EOF == res)
              )
            {
                // Simply continue;
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::CopyErrorFile] Could not fetch error version number from %s - swscanf failed.\n",
                          FileData.cFileName));

                continue;
            }

            if(ulErrorVersion >= ulMaxErrorVersion)
            {
                ulMaxErrorVersion = ulErrorVersion;
            }

            //
            // Save the error version number.
            //

            if(iVersion >= cVersions)
            {
                hr = ReAllocateFileData(iVersion,
                                        &aOldVersions,
                                        &cVersions,
                                        &bReAlloced);

                if(FAILED(hr))
                {
                    goto exit;
                }
            }

            aOldVersions[iVersion].ulVersionMinor   = 0;
            aOldVersions[iVersion].ulVersionMajor   = ulErrorVersion;
            aOldVersions[iVersion].ftLastWriteTime  = FileData.ftLastWriteTime;

            iVersion++;

        }while (FindNextFileW(hFind, &FileData));

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }

        if(0xFFFFFFFF == ulMaxErrorVersion)
        {
            ulMaxErrorVersion = 0;
        }
        else
        {
            ulMaxErrorVersion++;
        }
    }

    //
    // Compute the name for the new error file
    //

    res = _snwprintf(wszErrorVersionNumber,
                     MD_CCH_MAX_ULONG+1,
                     L"%010lu",
                     ulMaxErrorVersion);

    if(res < 0)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CopyErrorFile] _snwprintf returned a negative value. This should never happen.\n"));

    }
    else
    {
        pEnd = m_wszErrorFileSearchString + ulBeginVersion;
        memcpy(pEnd, wszErrorVersionNumber, MD_CCH_MAX_ULONG*sizeof(WCHAR));

        //
        // Copy the error file and set security on it.
        //

        if(!CopyFileW(m_wszEditWhileRunningTempDataFile,
                      m_wszErrorFileSearchString,
                      FALSE))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::CopyErrorFile] CopyFile failed with. hr=0x%x.\n",
                      hr));

            LogEvent(m_pCListenerController->EventLog(),
                        MD_ERROR_COPY_ERROR_FILE,
                        EVENTLOG_ERROR_TYPE,
                        ID_CAT_CAT,
                        hr,
                        m_wszErrorFileSearchString);

        }
        else
        {
            SetSecurityOnFile(m_wszEditWhileRunningTempDataFile,
                              m_wszErrorFileSearchString);

            LogEvent(m_pCListenerController->EventLog(),
                        MD_ERROR_PROCESSING_TEXT_EDITS,
                        EVENTLOG_ERROR_TYPE,
                        ID_CAT_CAT,
                        i_hrThatCausedTheCopyErrorFile,
                        m_wszErrorFileSearchString);

        }
    }

    //
    // Cleanup obsolete error files.
    //

    g_LockMasterResource.ReadLock();

    cMaxErrorFiles = g_dwMaxErrorFiles;

    g_LockMasterResource.ReadUnlock();

    if ( (iVersion+1) > cMaxErrorFiles ) // + 1 because we need to include the error file that was just created in the count.
    {
        ULONG cDeleted     = 0;
        ULONG cNeedDeleted = (iVersion+1)-cMaxErrorFiles;

        //
        // Delete old error files based on timestamp rather than version number.
        // That way you are keeping the most recent ones.
        // Exceeded max error files -
        // Delete old error files i.e. the first dwMaxHistoryFiles - cFile
        //

        qsort((void*)aOldVersions, iVersion, sizeof(METABASE_FILE_DATA), MyCompareFileData);

        for (ULONG i=0; cDeleted<cNeedDeleted && i<iVersion ; i++ )
        {
            if(aOldVersions[i].ulVersionMajor == ulMaxErrorVersion)
            {
                //
                // Do not cleanup the file you just created.
                //

                continue;
            }
            else
            {
                //
                // Delete error file
                //

                res = _snwprintf(wszErrorVersionNumber,
                                 MD_CCH_MAX_ULONG+1,
                                 L"%010lu",
                                 aOldVersions[i].ulVersionMajor);

                if(res < 0)
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[CopyErrorFile] _snwprintf returned a negative value. This should never happen.\n"));

                }
                else
                {
                    pEnd = m_wszErrorFileSearchString + ulBeginVersion;
                    memcpy(pEnd, wszErrorVersionNumber, MD_CCH_MAX_ULONG*sizeof(WCHAR));

                    if(!DeleteFileW(m_wszErrorFileSearchString))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());

                        DBGINFOW((DBG_CONTEXT,
                                  L"[CopyErrorFile] Unable to cleanup error file: %s. DeleteFileW failed with hr = 0x%x.\n",
                                  m_wszErrorFileSearchString, hr));
                        hr = S_OK;

                    }
                    else
                    {
                        cDeleted++;
                    }
                }
           }
        } // End loop for all error files, delete the oldest (see rules in comment)
    } // End if the number of error files exceeds the max error file count.

exit:

    //
    // If GetTable fails, then force savedata so that an invalid XML
    // file overwritten with the correct in memory representation.
    // That way if the service is shuts down, we are not left with
    // an invalid file
    //

    if(i_bGetTableFailed)
    {
        if(NULL == m_pAdminBase)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::CopyErrorFile] Unable to create the admin base object. hr = 0x%x\n",
                      hr));
        }
        else
        {
            g_LockMasterResource.WriteLock();

            g_dwSystemChangeNumber++; // Increment the system change number to force a flush to  disk.

            g_LockMasterResource.WriteUnlock();

            hr = m_pAdminBase->SaveData();

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::CopyErrorFile] IMSAdminBase::SaveData failed with hr = 0x%x\n",
                          hr));
            }

        }
    }

    if((aOldVersionsFixed != aOldVersions) && (NULL != aOldVersions))
    {
        delete [] aOldVersions;
        aOldVersions = NULL;
        cVersions = 0;
    }

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }


    return hr;

}

/***************************************************************************++

Routine Description:

    Create a new history file with an inceremented minor version and apply
    to it all the succesful changes that made it into memory/

Arguments:

    [in] IST helper.
    [in] Diff table that has all the successful updates in the write cache.
    [in] changed file.
    [in] history file against which the changed file was compared
    [in] new minor version, with which you need to create the history file.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::ApplyChangeToHistoryFile(CWriterGlobalHelper*       pISTHelper,
                                        ISimpleTableWrite2*        pISTDiff,
                                        LPWSTR                     wszHistoryFile,
                                        ULONG                      i_ulMajorVersion,
                                        ULONG                      i_ulMinorVersion)
{
    STQueryCell           QueryCellHistory[2];
    ULONG                 cCellHistory           = sizeof(QueryCellHistory)/sizeof(STQueryCell);
    HRESULT               hr                     = S_OK;
    ISimpleTableRead2*    pISTHistory            = NULL;
    ULONG                 iWriteRowDiff          = 0;
    ULONG                 iReadRowHistory        = 0;
    LPWSTR                wszNewHistoryFile      = NULL;
    LPWSTR                wszNewSchemaFile       = NULL;
    CWriter*              pCWriter               = NULL;
    BOOL                  bNoChanges             = FALSE;

    //
    // If the diff table is missing the assume no changes. This can happen when
    // there is a parsing error and get table on it fails.
    //

    if(NULL == pISTDiff)
    {
        goto exit;
    }

    //
    // Create the temp bakup file
    //

    hr = ConstructHistoryFileName(&wszNewHistoryFile,
                                  m_wszHistoryFileDir,
                                  m_cchHistoryFileDir,
                                  m_wszRealFileNameWithoutPathWithoutExtension,
                                  m_cchRealFileNameWithoutPathWithoutExtension,
                                  m_wszRealFileNameExtension,
                                  m_cchRealFileNameExtension,
                                  i_ulMajorVersion,
                                  i_ulMinorVersion);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = ConstructHistoryFileName(&wszNewSchemaFile,
                                  m_wszHistoryFileDir,
                                  m_cchHistoryFileDir,
                                  m_wszSchemaFileNameWithoutPathWithoutExtension,
                                  m_cchSchemaFileNameWithoutPathWithoutExtension,
                                  m_wszSchemaFileNameExtension,
                                  m_cchSchemaFileNameExtension,
                                  i_ulMajorVersion,
                                  i_ulMinorVersion);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBGINFOW((DBG_CONTEXT,
              L"[CFileListener::ApplyChangeToHistoryFile] Attempting to create a new version of the hisory file %s, %s that contains all the successful updates to the metabase.\n",
              wszNewHistoryFile, wszNewSchemaFile));

    DBGINFOW((DBG_CONTEXT,
              L"[SaveSchema] Initializing writer with write file: %s bin file: %s.\n",
              wszNewHistoryFile,
              pISTHelper->m_wszBinFileForMeta));

    pCWriter = new CWriter();
    if(NULL == pCWriter)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pCWriter->Initialize(m_wszEditWhileRunningTempDataFileWithAppliedEdits,
                              pISTHelper,
                              NULL);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the hisory file %s. CWriter::Initialize failed with hr = 0x%x.\n",
                  wszNewHistoryFile, hr));
        goto exit;
    }

    //
    // Get the backed up table
    //

    QueryCellHistory[0].pData     = (LPVOID)pISTHelper->m_wszBinFileForMeta;
    QueryCellHistory[0].eOperator = eST_OP_EQUAL;
    QueryCellHistory[0].iCell     = iST_CELL_SCHEMAFILE;
    QueryCellHistory[0].dbType    = DBTYPE_WSTR;
    QueryCellHistory[0].cbSize    = 0;

    QueryCellHistory[1].pData     = (LPVOID)wszHistoryFile;
    QueryCellHistory[1].eOperator = eST_OP_EQUAL;
    QueryCellHistory[1].iCell     = iST_CELL_FILE;
    QueryCellHistory[1].dbType    = DBTYPE_WSTR;
    QueryCellHistory[1].cbSize    = (lstrlenW(wszHistoryFile)+1)*sizeof(WCHAR);

    hr = m_pISTDisp->GetTable(wszDATABASE_METABASE,
                              wszTABLE_MBProperty,
                              (LPVOID)QueryCellHistory,
                              (LPVOID)&cCellHistory,
                              eST_QUERYFORMAT_CELLS,
                              0,
                              (LPVOID *)&pISTHistory);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the history file %s. GetTable on table %s from file %s failed with hr = 0x%x.\n",
                  wszNewHistoryFile, wszTABLE_MBProperty, wszHistoryFile, hr));

        goto exit;
    }

    hr = pCWriter->BeginWrite(eWriter_Metabase);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the hisory file %s. CWriter::BeginWrite failed with hr = 0x%x.\n",
                  wszNewHistoryFile, hr));
        goto exit;
    }

    for(iWriteRowDiff=0,iReadRowHistory=0; ;)
    {
        LPVOID a_pvDiff[cMBPropertyDiff_NumberOfColumns];
        ULONG  a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
        ULONG  cColDiff = cMBPropertyDiff_NumberOfColumns;
        LPVOID a_pvHistory[cMBProperty_NumberOfColumns];
        ULONG  a_cbSizeHistory[cMBProperty_NumberOfColumns];
        ULONG  cColHistory = cMBProperty_NumberOfColumns;

        //
        // Get a property from the diff table.
        //

        hr = pISTDiff->GetWriteColumnValues(iWriteRowDiff,
                                            cColDiff,
                                            NULL,
                                            NULL,
                                            a_cbSizeDiff,
                                            a_pvDiff);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            if(iWriteRowDiff > 0)
            {
                //
                // Write the remaining records from the History table.
                //

                hr = MergeRemainingLocations(pCWriter,
                                             pISTHistory,
                                             TRUE,             // indicates wszTABLE_MBProperty,
                                             &iReadRowHistory);

            }
            else
            {
                //
                // There are no differences. Delete the temp file and exit.
                //
                bNoChanges = TRUE;
            }
            goto exit;
        }

        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // Get a property from the history table.
        //

        hr = pISTHistory->GetColumnValues(iReadRowHistory,
                                          cColHistory,
                                          NULL,
                                          a_cbSizeHistory,
                                          a_pvHistory);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;

            //
            // WriteRemaining records from diff table.
            //

            ISimpleTableRead2* pISTDiffRead = NULL;

            hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2,
                                          (LPVOID*)&pISTDiffRead);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = MergeRemainingLocations(pCWriter,
                                         pISTDiffRead,
                                         FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                         &iWriteRowDiff);

            pISTDiffRead->Release();

            goto exit;
        }

        if(FAILED(hr))
        {
            goto exit;
        }

        if(_wcsicmp((LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]),(LPWSTR)(a_pvHistory[iMBProperty_Location])) < 0)
        {
            //
            // Found a location in the diff table that is not present in the
            // history table - Assume inserts and write all properties of this
            // location from the diff table.
            //

            ISimpleTableRead2* pISTDiffRead = NULL;

            hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2,
                                          (LPVOID*)&pISTDiffRead);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = MergeLocation(pCWriter,
                               pISTDiffRead,
                               FALSE,           // indicates wszTABLE_MBPropertyDiff,
                               &iWriteRowDiff,
                               *(DWORD*)(a_pvDiff[iMBPropertyDiff_LocationID]),
                               (LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]));

            pISTDiffRead->Release();

        }
        else if(_wcsicmp((LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]),(LPWSTR)(a_pvHistory[iMBProperty_Location])) > 0)
        {
            //
            // Found a location in the history table that is not present in the
            // diff table - Assume no change and write all properties of this
            // location from the history table.
            //

            hr = MergeLocation(pCWriter,
                               pISTHistory,
                               TRUE,          // indicates wszTABLE_MBProperty,
                               &iReadRowHistory,
                               *(DWORD*)(a_pvHistory[iMBProperty_LocationID]),
                               (LPWSTR)(a_pvHistory[iMBProperty_Location]));

        }
        else
        {
            //
            // Merge properties of this location from History and diff table.
            //

            if(eMBPropertyDiff_DeleteNode == *(DWORD*)a_pvDiff[iMBPropertyDiff_Directive])
            {
                //
                // No need to merge if the location has been deleted.
                // Move the History pointer to the next location.
                //

                ULONG  LocationIDHistory = *(DWORD*)a_pvHistory[iMBProperty_LocationID]; // save the location ID
                LPWSTR wszDelHistoryLocationStart = (LPWSTR)a_pvHistory[iMBProperty_Location];
                LPWSTR wszDelDiffLocationStart = (LPWSTR)a_pvDiff[iMBPropertyDiff_Location];

                iWriteRowDiff++;

                do
                {
                    iReadRowHistory++;

                    hr = pISTHistory->GetColumnValues(iReadRowHistory,
                                                      cColHistory,
                                                      NULL,
                                                      a_cbSizeHistory,
                                                      a_pvHistory);

                    if(E_ST_NOMOREROWS == hr)
                    {
                        //
                        // WriteRemaining records from diff table.
                        //

                        ISimpleTableRead2* pISTDiffRead = NULL;

                        hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2,
                                                      (LPVOID*)&pISTDiffRead);

                        if(FAILED(hr))
                        {
                            goto exit;
                        }

                        hr = MergeRemainingLocations(pCWriter,
                                                     pISTDiffRead,
                                                     FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                                     &iWriteRowDiff);

                        pISTDiffRead->Release();

                        goto exit;

                    }
                    else if(FAILED(hr))
                    {
                        goto exit;
                    }

                    if(LocationIDHistory != *(DWORD*)(a_pvHistory[iMBProperty_LocationID]))
                    {
                        //
                        // Reached a new location in the history table. Check if this is a sub-
                        // location of the deleted location. If so, ignore all
                        // such sub locations.
                        //

                        LPWSTR wszStart = wcsstr((LPWSTR)a_pvHistory[iMBProperty_Location], wszDelHistoryLocationStart);

                        if(wszStart == (LPWSTR)a_pvHistory[iMBProperty_Location])
                        {
                            LocationIDHistory = *(DWORD*)(a_pvHistory[iMBProperty_LocationID]);
                        }

                        //
                        // Move to the next location in the diff table. If it is a subset of the
                        // parent location that was deleted, then assume it is a delete. Note
                        // that if it is an update, we will ignore and treat it as a delete.
                        //

                        hr = pISTDiff->GetWriteColumnValues(iWriteRowDiff,
                                                            cColDiff,
                                                            NULL,
                                                            NULL,
                                                            a_cbSizeDiff,
                                                            a_pvDiff);

                        if(E_ST_NOMOREROWS == hr)
                        {
                            hr = S_OK;
                        }
                        else if(FAILED(hr))
                        {
                            goto exit;
                        }
                        else
                        {
                            wszStart = wcsstr((LPWSTR)a_pvDiff[iMBPropertyDiff_Location], wszDelDiffLocationStart);

                            if(wszStart == (LPWSTR)a_pvDiff[iMBPropertyDiff_Location])
                            {
                                iWriteRowDiff++;
                            }
                        }
                    }

                }while(LocationIDHistory ==
                       *(DWORD*)(a_pvHistory[iMBProperty_LocationID])
                      );

                continue;
            }
            else
            {
                hr = MergeLocation(pCWriter,
                                   pISTHistory,
                                   &iReadRowHistory,
                                   *(DWORD*)(a_pvHistory[iMBProperty_LocationID]),
                                   pISTDiff,
                                   &iWriteRowDiff,
                                   *(DWORD*)(a_pvDiff[iMBPropertyDiff_LocationID]),
                                   (LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]));
            }
        }

        if(FAILED(hr))
        {
            goto exit;
        }

    }

exit:

    //
    // Release the history file before the move.
    //

    if(NULL != pISTHistory)
    {
        pISTHistory->Release();
        pISTHistory = NULL;
    }

    if(NULL != pCWriter)
    {
        if(FAILED(hr) || bNoChanges)
        {
            //
            // Delete the file.
            //

            HRESULT hrSav = S_OK;

            hrSav = pCWriter->EndWrite(eWriter_Abort);

            if(FAILED(hrSav))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::ApplyChangeToHistoryFile] Unable to abort write history data file %s. CWriter::EndWriter failed with hr = 0x%x.\n",
                          wszNewHistoryFile, hrSav));
            }

        }
        else
        {
            hr = pCWriter->EndWrite(eWriter_Metabase);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the history data file %s. CWriter::EndWrite failed with hr = 0x%x.\n",
                          wszNewHistoryFile, hr));

            }

        }

        delete pCWriter;
        pCWriter = NULL;

        //
        // Rename the updated minor version and
        // Copy the schema file that corresponds to the bin file.
        //

        if(SUCCEEDED(hr) && (!bNoChanges))
        {
            if(MoveFileExW(m_wszEditWhileRunningTempDataFileWithAppliedEdits,
                           wszNewHistoryFile,
                           MOVEFILE_REPLACE_EXISTING)
              )
            {
                LPWSTR pwszSchemaFile = m_wszEditWhileRunningTempSchemaFile;

                if(!m_bIsTempSchemaFile)
                {
                    pwszSchemaFile = m_wszSchemaFileName;
                }


                if(!CopyFileW(pwszSchemaFile,
                              wszNewSchemaFile,
                              FALSE))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    DBGINFOW((DBG_CONTEXT,
                              L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the history schema file %s. CopyFile failed with hr = 0x%x.\n",
                              wszNewSchemaFile, hr));
                    // TODO: Log an error - It is non fatal if you cannot copy the schema file.
                    hr = S_OK;
                }
                else
                {
                    SetSecurityOnFile(pwszSchemaFile,
                                      wszNewSchemaFile);

                }
            }
            else
            {
                hr = GetLastError();
                hr = HRESULT_FROM_WIN32(hr);

                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::ApplyChangeToHistoryFile] Unable to create a new history file with the changes. MoveFile from %s to %s failed with hr = 0x%x. \n",
                          m_wszEditWhileRunningTempDataFileWithAppliedEdits,
                          wszNewHistoryFile,
                          hr));

            }
        }

    }

    if(NULL != wszNewHistoryFile)
    {
        delete [] wszNewHistoryFile;
        wszNewHistoryFile = NULL;
    }

    if(NULL != wszNewSchemaFile)
    {
        delete [] wszNewSchemaFile;
        wszNewSchemaFile = NULL;
    }

    return hr;

} // CFileListener::ApplyChangeToHistoryFile


/***************************************************************************++

Routine Description:

    This function merges the remaining locations from either the write cache
    of the diff table or the read cache of the mbproperty table from the
    history file. It is called only when there are locations left in one or
    or the other, not both. i.e when common locations do not exist.

Arguments:

    [in] Writer object
    [in] IST to read locations from - note it can either be a read or write
         cache
    [in] Bool - used to identify read/write cache. If true, it indicates
         MBProperty, else it indicates MBPropertyDiff
    [in] row index to start merging from.


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeRemainingLocations(CWriter*                pCWriter,
                                       ISimpleTableRead2*      pISTRead,
                                       BOOL                    bMBPropertyTable,
                                       ULONG*                  piRow)
{
    HRESULT                hr             = S_OK;
    ISimpleTableWrite2*    pISTWrite      = NULL;
    ULONG                  cCol           = 0;
    ULONG*                 a_cbSize       = NULL;
    LPVOID*                a_pv           = NULL;
    ULONG                  a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
    LPVOID                 a_pvDiff[cMBPropertyDiff_NumberOfColumns];
    ULONG                  a_cbSizeHistory[cMBProperty_NumberOfColumns];
    LPVOID                 a_pvHistory[cMBProperty_NumberOfColumns];
    ULONG                  iColLocationID = 0;
    ULONG                  iColLocation   = 0;

    if(!bMBPropertyTable)
    {
        hr = pISTRead->QueryInterface(IID_ISimpleTableWrite2,
                                      (LPVOID*)&pISTWrite);

        if(FAILED(hr))
        {
            return hr;
        }

        cCol           = cMBPropertyDiff_NumberOfColumns;
        a_cbSize       = a_cbSizeDiff;
        a_pv           = a_pvDiff;
        iColLocationID = iMBPropertyDiff_LocationID;
        iColLocation   = iMBPropertyDiff_Location;

    }
    else
    {
        cCol           = cMBProperty_NumberOfColumns;
        a_cbSize       = a_cbSizeHistory;
        a_pv           = a_pvHistory;
        iColLocationID = iMBProperty_LocationID;
        iColLocation   = iMBProperty_Location;

    }


    for(ULONG iRow=*piRow;;)
    {
        if(NULL != pISTWrite)
        {
            hr = pISTWrite->GetWriteColumnValues(iRow,
                                                 cCol,
                                                 NULL,
                                                 NULL,
                                                 a_cbSize,
                                                 a_pv);
        }
        else
        {
            hr = pISTRead->GetColumnValues(iRow,
                                           cCol,
                                           NULL,
                                           a_cbSize,
                                           a_pv);
        }

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            goto exit;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }

        hr = MergeLocation(pCWriter,
                           pISTRead,
                           bMBPropertyTable,
                           &iRow,
                           *(DWORD*)a_pv[iColLocationID],
                           (LPWSTR)a_pv[iColLocation]);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:

    if(SUCCEEDED(hr))
    {
        *piRow = iRow;
    }

    if(NULL != pISTWrite)
    {
        pISTWrite->Release();
        pISTWrite = NULL;
    }

    return hr;

} // CFileListener::MergeRemainingLocations


/***************************************************************************++

Routine Description:

    This function merges a location from the write cache of the diff table
    with the read cache of the mbproperty table. It basically applies all
    the changes that were applied to the metabase (stored in the write cache
    of the diff table) with the read cache of the mbproperty table from the
    history file.

Arguments:

    [in] Writer object
    [in] read cache of the mbproperty table from history file
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         read cache
    [in] write cache of the diff table
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         write cache
    [in] location being merged.

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeLocation(CWriter*                pCWriter,
                             ISimpleTableRead2*      pISTHistory,
                             ULONG*                  piReadRowHistory,
                             ULONG                   LocationIDHistory,
                             ISimpleTableWrite2*     pISTDiff,
                             ULONG*                  piWriteRowDiff,
                             ULONG                   LocationIDDiff,
                             LPCWSTR                 wszLocation)
{

    HRESULT                     hr                  = S_OK;
    ISimpleTableWrite2*         pISTMerged          = NULL;
    ULONG                       iReadRowHistory, iWriteRowDiff;
    IAdvancedTableDispenser*    pISTAdvanced        = NULL;
    CLocationWriter*            pCLocationWriter    = NULL;

     DBGINFOW((DBG_CONTEXT,
               L"[CFileListener::MergeLocation] %s.\n", wszLocation));

    //
    // Merge History and the diff table. Merge the well known properties first,
    // then the custom properties.
    //

    hr = pCWriter->GetLocationWriter(&pCLocationWriter,
                                     wszLocation);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] %s. failed because CWriter::GetLocationWriter failed with hr = 0x%x.\n",
                  wszLocation, hr));

        goto exit;
    }

    iReadRowHistory = *piReadRowHistory;
    iWriteRowDiff = *piWriteRowDiff;

    hr = MergeProperties(pCLocationWriter,
                         pISTHistory,
                         &iReadRowHistory,
                         LocationIDHistory,
                         pISTDiff,
                         &iWriteRowDiff,
                         LocationIDDiff);

    if(FAILED(hr))
    {
        goto exit;
    }

    *piReadRowHistory = iReadRowHistory;
    *piWriteRowDiff = iWriteRowDiff;

    hr = pCLocationWriter->WriteLocation(TRUE);    // Need to sort - Custom property may have been converted to a well-known property and vice versa.

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] %s. failed because CWriter::WriteLocation failed with hr = 0x%x.\n",
                  wszLocation, hr));

        goto exit;
    }

exit:

    if(NULL != pISTMerged)
    {
        pISTMerged->Release();
        pISTMerged = NULL;
    }

    if(NULL != pISTAdvanced)
    {
        pISTAdvanced->Release();
        pISTAdvanced = NULL;
    }

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return hr;

} // CFileListener::MergeLocation


/***************************************************************************++

Routine Description:

    This function merges properties in a given location from the write cache
    of the diff table with the read cache of the mbproperty table. It basically
    applies all  the changes that were applied to the metabase (stored in the
    write cache of the diff table) with the read cache of the mbproperty
    table from the history file.

Arguments:

    [in] Bool to indicate merging custom or well-known properties
    [in] Location writer object
    [in] read cache of the mbproperty table from history file
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         read cache
    [in] write cache of the diff table
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         write cache

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeProperties(CLocationWriter*        pCLocationWriter,
                               ISimpleTableRead2*      pISTHistory,
                               ULONG*                  piReadRowHistory,
                               ULONG                   LocationIDHistory,
                               ISimpleTableWrite2*     pISTDiff,
                               ULONG*                  piWriteRowDiff,
                               ULONG                   LocationIDDiff)
{
    HRESULT             hr               = S_OK;
    ISimpleTableRead2*    pISTDiffRead   = NULL;
    ULONG               iReadRowHistory  = 0;
    ULONG               iWriteRowDiff    = 0;

    ULONG               cColHistory      = cMBProperty_NumberOfColumns;
    ULONG               a_cbSizeHistory[cMBProperty_NumberOfColumns];
    LPVOID              a_pvHistory[cMBProperty_NumberOfColumns];

    ULONG               cColDiff         = cMBPropertyDiff_NumberOfColumns;
    ULONG               a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
    LPVOID              a_pvDiff[cMBPropertyDiff_NumberOfColumns];

    BOOL                bGetNextReadRowFromHistory = TRUE;
    BOOL                bGetNextWriteRowFromDiff   = TRUE;

    for(iReadRowHistory=(*piReadRowHistory), iWriteRowDiff=(*piWriteRowDiff);;)
    {
        if(bGetNextReadRowFromHistory)
        {
            //
            // Move to the next property in the History table.
            //

            hr = pISTHistory->GetColumnValues(iReadRowHistory,
                                             cColHistory,
                                             NULL,
                                             a_cbSizeHistory,
                                             a_pvHistory);

            if( (E_ST_NOMOREROWS == hr) ||
                (LocationIDHistory != *(DWORD*)a_pvHistory[iMBProperty_LocationID])
              )
            {
                //
                //    Merge the remaining properties from the diff table.
                //

                hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2,
                                              (LPVOID*)&pISTDiffRead);

                if(FAILED(hr))
                {
                    goto exit;
                }

                hr = MergeRemainingProperties(pCLocationWriter,
                                              pISTDiffRead,
                                              FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                              &iWriteRowDiff,
                                              LocationIDDiff);

                pISTDiffRead->Release();
                pISTDiffRead = NULL;

                goto exit;
            }
            else if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeProperties] GetColumnValues on row %d from table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                          iReadRowHistory, wszTABLE_MBProperty, hr,
                          (LPWSTR)a_pvHistory[iMBProperty_Location],
                          *(DWORD*)a_pvHistory[iMBProperty_ID]));
                goto exit;
            }

        }

        if(bGetNextWriteRowFromDiff)
        {
            //
            // Move to the next property in the diff table.
            //

            hr = pISTDiff->GetWriteColumnValues(iWriteRowDiff,
                                                cColDiff,
                                                NULL,
                                                NULL,
                                                a_cbSizeDiff,
                                                a_pvDiff);

            if( (E_ST_NOMOREROWS == hr) ||
                (LocationIDDiff != *(DWORD*)a_pvDiff[iMBProperty_LocationID])
              )
            {
                //
                //    Merge the remaining properties from the History table.
                //

                hr = MergeRemainingProperties(pCLocationWriter,
                                              pISTHistory,
                                              TRUE,               // indicates wszTABLE_MBProperty,
                                              &iReadRowHistory,
                                              LocationIDHistory);
                goto exit;
            }
            else if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeProperties] GetColumnValues on row %d from table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                          iWriteRowDiff, wszTABLE_MBPropertyDiff, hr,
                          (LPWSTR)a_pvDiff[iMBPropertyDiff_Location],
                          *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));
                goto exit;
            }

        }

        //
        // After moving in both tables, reset the flags
        //

        bGetNextReadRowFromHistory = FALSE;
        bGetNextWriteRowFromDiff = FALSE;

        if(_wcsicmp((LPWSTR)a_pvDiff[iMBPropertyDiff_Name], (LPWSTR)a_pvHistory[iMBProperty_Name]) < 0)
        {
            //
            // Found a name in the diff table that is not present in the History
            // table. Should be an insert and not update/delete. Increment the
            // diff pointer.
            //

            switch(*(DWORD*)a_pvDiff[iMBPropertyDiff_Directive])
            {
                case eMBPropertyDiff_Insert:
                    hr = pCLocationWriter->AddProperty(FALSE,          // indicates wszTABLE_MBPropertyDiff
                                                       a_pvDiff,
                                                       a_cbSizeDiff);

                    if(FAILED(hr))
                    {
                        DBGINFOW((DBG_CONTEXT,
                                  L"[CFileListener::MergeProperties] CLocationWriter::AddProperty from a location in table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                                  wszTABLE_MBPropertyDiff, hr,
                                  (LPWSTR)a_pvDiff[iMBPropertyDiff_Location],
                                  *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));

                        goto exit;
                    }

                    iWriteRowDiff++;
                    bGetNextWriteRowFromDiff = TRUE;

                    break;

                case eMBPropertyDiff_Update:
                case eMBPropertyDiff_Delete:
                case eMBPropertyDiff_DeleteNode:
                default:
                    DBGINFOW((DBG_CONTEXT,
                              L"[CFileListener::MergeProperties] Unexpected directive:%d. Location = %s, Property ID: %d.\n",
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_Directive],
                              (LPWSTR)a_pvDiff[iMBPropertyDiff_Location],
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));

                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    goto exit;

            }
        }
        else if(_wcsicmp((LPWSTR)a_pvDiff[iMBPropertyDiff_Name], (LPWSTR)a_pvHistory[iMBProperty_Name]) > 0)
        {
            //
            // Add the History row to the merged table.
            // Increment the History pointer.
            //
            hr = pCLocationWriter->AddProperty(TRUE,            // indicates wszTABLE_MBProperty
                                               a_pvHistory,
                                               a_cbSizeHistory);


            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeProperties] CLocationWriter::AddProperty from a location in table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                          wszTABLE_MBProperty, hr,
                          (LPWSTR)a_pvHistory[iMBProperty_Location],
                          *(DWORD*)a_pvHistory[iMBProperty_ID]));
                goto exit;
            }

            iReadRowHistory++;
            bGetNextReadRowFromHistory = TRUE;

        }
        else
        {
            //
            // Read from Diff table.
            // Increment the History and the diff pointer.
            //

            switch(*(DWORD*)a_pvDiff[iMBPropertyDiff_Directive])
            {
                case eMBPropertyDiff_Insert:
                case eMBPropertyDiff_Update:

                    hr = pCLocationWriter->AddProperty(FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                                       a_pvDiff,
                                                       a_cbSizeDiff);

                    if(FAILED(hr))
                    {
                        DBGINFOW((DBG_CONTEXT,
                                  L"[CFileListener::MergeProperties] CLocationWriter::AddProperty from a location in table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                                  wszTABLE_MBPropertyDiff, hr,
                                  (LPWSTR)a_pvDiff[iMBPropertyDiff_Location],
                                  *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));
                        goto exit;
                    }

                    iWriteRowDiff++;
                    bGetNextWriteRowFromDiff = TRUE;
                    iReadRowHistory++;
                    bGetNextReadRowFromHistory = TRUE;

                    break;

                case eMBPropertyDiff_Delete:
                    iWriteRowDiff++;
                    bGetNextWriteRowFromDiff = TRUE;
                    iReadRowHistory++;
                    bGetNextReadRowFromHistory = TRUE;
                    break;

                case eMBPropertyDiff_DeleteNode:
                default:
                    DBGINFOW((DBG_CONTEXT,
                              L"[CFileListener::MergeProperties] Unexpected directive:%d. Location = %s, Property ID: %d.\n",
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_Directive],
                              (LPWSTR)a_pvDiff[iMBPropertyDiff_Location],
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    goto exit;

            }
        }

    }

exit:

    if(SUCCEEDED(hr))
    {
        *piReadRowHistory = iReadRowHistory;
        *piWriteRowDiff = iWriteRowDiff;
    }

    return hr;

} // CFileListener::MergeProperties


/***************************************************************************++

Routine Description:

    This function merges a location either from the write cache of the diff
    table or the read cache of the mbproperty table from the history file,
    not both. It is called when there are no more common locations left to
    be merged, and one of the caches has remianing locations,

Arguments:

    [in] writer object
    [in] IST to read locations from - note it can either be a read or write
         cache
    [in] Bool - used to identify read/write cache. If true it indicates
         MBProperty else it indicates MBPropertyDiff
    [in] row index to start merging from.
    [in] location id of the location being merged, with respect to the above
         cache
    [in] location name

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeLocation(CWriter*                pCWriter,
                             ISimpleTableRead2*      pISTRead,
                             BOOL                    bMBPropertyTable,
                             ULONG*                  piRow,
                             ULONG                   LocationID,
                             LPCWSTR                 wszLocation)
{

    HRESULT                     hr               = S_OK;
    ULONG                       iRow             = *piRow;
    ISimpleTableWrite2*         pISTMerged       = NULL;
    IAdvancedTableDispenser*    pISTAdvanced     = NULL;
    CLocationWriter*            pCLocationWriter = NULL;
    LPWSTR                      wszTable         = NULL;

    if(bMBPropertyTable)
    {
        wszTable = wszTABLE_MBProperty;
    }
    else
    {
        wszTable = wszTABLE_MBPropertyDiff;
    }

     DBGINFOW((DBG_CONTEXT,
               L"[CFileListener::MergeLocation] Copy %s from %s.\n",
               wszLocation, wszTable));

    //
    // Merge the diff table with the History table, location by location.
    //

    hr = pCWriter->GetLocationWriter(&pCLocationWriter,
                                     wszLocation);

    if(FAILED(hr))
    {

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] %s from %s. Unable to merge, GetLocationWriter failed with hr = 0x%x.\n",
                  wszLocation, wszTable, hr));

        goto exit;
    }

    hr = MergeRemainingProperties(pCLocationWriter,
                                  pISTRead,
                                  bMBPropertyTable,
                                  &iRow,
                                  LocationID);

    if(FAILED(hr))
    {
        goto exit;
    }

    *piRow = iRow;

    hr = pCLocationWriter->WriteLocation(TRUE);    // Need to sort - a custom property may have got converted to a non custom and vice versa.
    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] Copy %s from %s failed CLocationWriter::WriteLocation failed with hr = 0x%x.\n",
                  wszLocation, wszTable, hr));
        goto exit;
    }

exit:

    if(NULL != pISTMerged)
    {
        pISTMerged->Release();
        pISTMerged = NULL;
    }

    if(NULL != pISTAdvanced)
    {
        pISTAdvanced->Release();
        pISTAdvanced = NULL;
    }

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return hr;

} // CFileListener::MergeLocation


/***************************************************************************++

Routine Description:

    This function merges remaining properties from a location either from
    the write cache of the diff table or the read cache of the mbproperty,
    table from the history file, not both. It is called when there are no
    more common locations left to be merged, and one of the caches has
    remaining locations with properties.

Arguments:

    [in] location writer
    [in] IST to read locations from - note it can either be a read or write
         cache
    [in] bool - used to identify read/write cache. if true it is in
         MBProperty, else MBPropertyDiff
    [in] row index to start merging from.
    [in] location id of the location being merged, with respect to the above
         cache

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeRemainingProperties(CLocationWriter*    pCLocationWriter,
                                        ISimpleTableRead2*  pISTRead,
                                        BOOL                bMBPropertyTable,
                                        ULONG*              piRow,
                                        ULONG                LocationID)
{
    HRESULT             hr             = S_OK;
    ISimpleTableWrite2*    pISTWrite      = NULL;
    ULONG               cCol           = 0;
    ULONG*              a_cbSize       = NULL;
    LPVOID*             a_pv           = NULL;
    ULONG               iColLocation   = 0;
    ULONG               iColLocationID = 0;
    ULONG               iColGroup      = 0;
    ULONG               iColID         = 0;
    ULONG               iColValue      = 0;
    LPWSTR              wszTable       = NULL;

    ULONG               a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
    ULONG               a_cbSizeHistory[cMBProperty_NumberOfColumns];
    LPVOID              a_pvDiff[cMBPropertyDiff_NumberOfColumns];
    LPVOID              a_pvHistory[cMBProperty_NumberOfColumns];

    //
    // If the table being merged if the "Diff" table then we need to read from
    // its write cache because all the successful updates will have been moved
    // into the write cache.

    //
    // If the table being merged is the "History" table the we need to read from
    // the read cache.
    //

    if(!bMBPropertyTable)
    {
        hr = pISTRead->QueryInterface(IID_ISimpleTableWrite2,
                                      (LPVOID*)&pISTWrite);

        if(FAILED(hr))
        {
            return hr;
        }

        cCol           = cMBPropertyDiff_NumberOfColumns;
        a_cbSize       = a_cbSizeDiff;
        a_pv           = a_pvDiff;
        iColLocation   = iMBPropertyDiff_Location;
        iColLocationID = iMBPropertyDiff_LocationID;
        iColGroup      = iMBPropertyDiff_Group;
        iColID         = iMBPropertyDiff_ID;
        iColValue      = iMBPropertyDiff_Value;
        wszTable       = wszTABLE_MBPropertyDiff;
    }
    else
    {
        cCol           = cMBProperty_NumberOfColumns;
        a_cbSize       = a_cbSizeHistory;
        a_pv           = a_pvHistory;
        iColLocation   = iMBProperty_Location;
        iColLocationID = iMBProperty_LocationID;
        iColGroup      = iMBProperty_Group;
        iColID         = iMBProperty_ID;
        iColValue      = iMBProperty_Value;
        wszTable       = wszTABLE_MBProperty;
    }

    for(ULONG iRow=*piRow;;iRow++)
    {
        if(NULL == pISTWrite)
        {
            hr = pISTRead->GetColumnValues(iRow,
                                           cCol,
                                           NULL,
                                           a_cbSize,
                                           a_pv);


        }
        else
        {
            hr = pISTWrite->GetWriteColumnValues(iRow,
                                                 cCol,
                                                 NULL,
                                                 NULL,
                                                 a_cbSize,
                                                 a_pv);
        }

        if(E_ST_NOMOREROWS == hr)
        {
            *piRow = iRow;
            hr = S_OK;
            goto exit;
        }
        else if (FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::MergeRemainingProperties] GetColumnValues/GetWriteColumnValues on row %d from table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                      iRow, wszTable, hr,
                      (LPWSTR)a_pv[iColLocation],
                      *(DWORD*)a_pv[iColID]));
            return hr;
        }
        else if(*(DWORD*)a_pv[iColLocationID] != LocationID)
        {
            *piRow = iRow;
            hr = S_OK;
            goto exit;
        }
        else if(NULL != pISTWrite)
        {
            //
            // If we are merging properties from the diff table, then make sure
            // that the directive is correct.
            //
            switch(*(DWORD*)a_pv[iMBPropertyDiff_Directive])
            {
            case eMBPropertyDiff_Insert:
                break;
            case eMBPropertyDiff_Update:
            case eMBPropertyDiff_Delete:
            case eMBPropertyDiff_DeleteNode:
            default:
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeRemainingProperties] Incorrect directive.\n"));

                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto exit;
            }
        }

        hr = pCLocationWriter->AddProperty(bMBPropertyTable,
                                           a_pv,
                                           a_cbSize);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                       L"[CFileListener::MergeRemainingProperties] CLocationWriter::AddProperty failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                       hr, (LPWSTR)a_pv[iColLocation], *(DWORD*)a_pv[iColID]));

            goto exit;
        }

    }

exit:

    if(NULL != pISTWrite)
    {
        pISTWrite->Release();
        pISTWrite = NULL;
    }

    return hr;

} // CFileListener::MergeRemainingProperties


/***************************************************************************++

Routine Description:

    Utility function to fetch the version number of the file.

Arguments:

    [out] Version number

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::GetVersionNumber(LPWSTR    i_wszDataFile,
                                ULONG*    o_pulVersionNumber,
                                BOOL*     o_bGetTableFailed)
{
    HRESULT                    hr                = S_OK;
    ISimpleTableDispenser2* pISTDisp          = NULL;
    ISimpleTableRead2*      pISTProperty      = NULL;
    STQueryCell             QueryCell[2];
    ULONG                   cCell             = sizeof(QueryCell)/sizeof(STQueryCell);
    LPWSTR                  wszGlobalLocation = MD_GLOBAL_LOCATIONW;
    LPWSTR                  wszMajorVersion   = MD_EDIT_WHILE_RUNNING_MAJOR_VERSION_NUMBERW;
    ULONG                   cbMajorVersion    = 0;
    ULONG*                  pulVersionNumber  = NULL;
    ULONG                   cRetry            = 0;

    //
    // Get only the root location - that where the timestamps are stored.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetVersionNumber] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // No need to specify the schema file because we are getting a shipped
    // property from a global location.
    //

    QueryCell[0].pData     = (LPVOID)i_wszDataFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_wszDataFile)+1)*sizeof(WCHAR);

    QueryCell[1].pData     = (LPVOID)wszGlobalLocation;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iMBProperty_Location;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = (lstrlenW(wszGlobalLocation)+1)*sizeof(WCHAR);

    do
    {
        if(cRetry++ > 0)
        {
            //
            // If retrying because of sharing violation or path/file not found
            //, then sleep. Path or file not found can happen when the metabase
            // file is being renamed at the end of save all data.
            //
            Sleep(2000);
        }

        hr = pISTDisp->GetTable(wszDATABASE_METABASE,
                                wszTABLE_MBProperty,
                                (LPVOID)QueryCell,
                                (LPVOID)&cCell,
                                eST_QUERYFORMAT_CELLS,
                                0,
                                (LPVOID *)&pISTProperty);

    } while(( (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr) ||
              (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)    ||
              (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)    ||
              (E_ST_INVALIDTABLE == hr)
            ) &&
            (cRetry < 10)
           );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetVersionNumber] GetTable on %s from %s failed with hr = 0x%x.\n",
                  wszTABLE_MBProperty,
                  i_wszDataFile,
                  hr));

        if((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr) &&
           (NULL != o_bGetTableFailed)
          )
        {
            *o_bGetTableFailed = TRUE;
        }

        goto exit;
    }


    //
    // Get the version number.
    //

    hr = GetGlobalValue(pISTProperty,
                        wszMajorVersion,
                        &cbMajorVersion,
                        (LPVOID*)&pulVersionNumber);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetVersionNumber] Unable to read %s. GetGlobalValue failed with hr = 0x%x.\n",
                  wszMajorVersion,
                  hr));
        if(NULL != o_bGetTableFailed)
        {
            *o_bGetTableFailed = TRUE;
        }
        goto exit;

    }

    *o_pulVersionNumber = *(ULONG*)pulVersionNumber;

exit:

    if(NULL != pISTProperty)
    {
        pISTProperty->Release();
        pISTProperty = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Utility function to determine if the notification received is because of
    a programmatic save or a user edit. Note that if two SaveAllData's happen
    in quick succession, this algorithm will break and it will treat it as
    as user edit and proceed with the diff. But at least for cases when
    this doesn't happen, the diff can be avoided.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
BOOL CFileListener::ProgrammaticMetabaseSaveNotification()
{
    HRESULT           hr                                    = S_OK;
    BOOL              bProgrammaticMetabaseSaveNotification = FALSE;
    WIN32_FIND_DATAW  CurrentMetabaseAttr;
    FILETIME*         pCurrentMetabaseFileLastWriteTimeStamp= NULL;
    FILETIME          MostRecentMetabaseFileLastWriteTimeStamp;
    ULONG             ulMostRecentMetabaseVersionNumber       = 0;
    ULONG             ulCurrentMetabaseVersion              = 0;
    BOOL              bSavingMetabaseFileToDisk             = FALSE;
    DWORD             dwRes                                 = 0;
    ULONG             cRetry                                = 0;

    //
    // Determine if it was a notification because of a programatic save or a
    // save due to a user edit. Note that if two SaveAllData's happen in
    // quick succession, this algorithm will break and it will treat it as
    // as user edit and proceed with the diff. But at least for cases when
    // this doesn't happen, the diff can be avoided.
    //

    EnterCriticalSection(&g_csEditWhileRunning);

    bSavingMetabaseFileToDisk = g_bSavingMetabaseFileToDisk;

    if(bSavingMetabaseFileToDisk)
    {
        //
        // This means that a programmatic save was happening.
        // Save the metabase attributes as seen by the programmatic save.
        //

        MostRecentMetabaseFileLastWriteTimeStamp = g_MostRecentMetabaseFileLastWriteTimeStamp;
        ulMostRecentMetabaseVersionNumber        = g_ulMostRecentMetabaseVersion;
    }

    DBGINFO((DBG_CONTEXT,
             "[ProgrammaticMetabaseSaveNotification] PREVIOUS SAVE TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n",
             g_MostRecentMetabaseFileLastWriteTimeStamp.dwLowDateTime,
             g_MostRecentMetabaseFileLastWriteTimeStamp.dwHighDateTime));

    LeaveCriticalSection(&g_csEditWhileRunning);

    if(bSavingMetabaseFileToDisk)
    {
        //
        // This means that a programmatic save was happening.
        // Fetch the current metabase attributes
        //

        hr = GetMetabaseAttributes(&CurrentMetabaseAttr,
                                   &ulCurrentMetabaseVersion);

        if(SUCCEEDED(hr))
        {
            DBGINFO((DBG_CONTEXT,
                     "[ProgrammaticMetabaseSaveNotification] CURRENT TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n",
                     CurrentMetabaseAttr.ftLastWriteTime.dwLowDateTime,
                     CurrentMetabaseAttr.ftLastWriteTime.dwHighDateTime));

            bProgrammaticMetabaseSaveNotification = CompareMetabaseAttributes(&MostRecentMetabaseFileLastWriteTimeStamp,
                                                                              ulMostRecentMetabaseVersionNumber,
                                                                              &(CurrentMetabaseAttr.ftLastWriteTime),
                                                                              ulCurrentMetabaseVersion);


        }

        //
        // If GetMetabaseAttributes fails, assume that it is not a programmatic
        // save and proceed with the diff.
        //

        if(bProgrammaticMetabaseSaveNotification)
        {
            goto exit;
        }

    }

    //
    // If you reach here it means that it was not a programmatic save or a
    // programmatic save happened but the current metabase attributes did
    // not match that of the programmatic save (may be due to a competing
    // user edit or due to two programmatic saves in quick succession).
    // We assume that it is a user edit and we will proceed to copy
    // the metabase to a temporary file in order to process the edit. It
    // is necessary to make a copy of the file, because the file can be
    // overwritten in the window between the version number fetch and the
    // diff. If we always work with the copy we will not have the problem.
    // Note that once we make the copy we will re-get the version number
    // from the copied file and then proceed with the diff.
    //

    do
    {
        if(cRetry++ > 0)
        {
            //
            // If retrying because of sharing violation or path/file not found
            // then sleep. Path or file not found can happen when the metabase
            // file is being renamed at the end of save all data.
            //
            Sleep(2000);
        }

        if(!CopyFileW(m_wszRealFileName,
                      m_wszEditWhileRunningTempDataFile,
                      FALSE))
        {
            dwRes = GetLastError();
            hr = HRESULT_FROM_WIN32(dwRes);
        }
        else
        {
            hr = S_OK;
        }

    } while(( (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr) ||
              (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)    ||
              (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
            ) &&
            (cRetry < 10)
           );

    if(FAILED(hr))
    {

        DBGINFOW((DBG_CONTEXT,
              L"[CFileListener::ProgrammaticMetabaseSaveNotification] CopyFile from %s to %s failed with hr = 0x%x. Hence unable to process edits.\n",
              m_wszRealFileName,
              m_wszEditWhileRunningTempDataFile,
              hr));

        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_COPYING_EDITED_FILE,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr);

        CopyErrorFile(FALSE, hr);

        //
        // Set this to true so that this user edit is not processed, because
        // file copy to a temp file failed.
        //

        bProgrammaticMetabaseSaveNotification = TRUE;

        goto exit;
    }

    //
    // Reset the attributes on the temp file if necessary
    //

    ResetFileAttributesIfNeeded((LPTSTR)m_wszEditWhileRunningTempDataFile,
                                TRUE);

    //
    // Set the security on the file
    //

    SetSecurityOnFile(m_wszRealFileName,
                      m_wszEditWhileRunningTempDataFile);

    //
    // Save the last write time stamp on the file being processed.
    //
    // Note that the reason why we save this is to narrow the following window:
    // Someone has saved a file (text edit) and the notification hasn't made it
    // to the EWR thread. Meanwhile SaveAllData happens and clobbers the saved
    // file.
    // Hence, we save the timestamp of the processed EWR file in
    // g_EWRProcessedMetabaseTimeStamp. In SaveAllData we compare the timestamp
    // of (a) the metabase file with (b) g_EWRProcessedMetabaseTimeStamp and
    // (c) g_MostRecentMetabaseFileLastWriteTimeStamp (which stores the timestamp
    // of the metabase file at the last successful SaveAllData). If (a) doesn't
    // match (b) or (c), then we do not rename.
    //
    // Note that we read and save the timestamp after the copy to the edit
    // while running temp data file, so we may be storing a timestamp that is
    // more recent. But it doesn't matter, because when the subsequent
    // notification comes through, we will update the timestamp.
    //

    hr = GetMetabaseAttributes(&CurrentMetabaseAttr,
                               &ulCurrentMetabaseVersion);

    if(SUCCEEDED(hr))
    {
        pCurrentMetabaseFileLastWriteTimeStamp = &(CurrentMetabaseAttr.ftLastWriteTime);

    }
    else
    {
        pCurrentMetabaseFileLastWriteTimeStamp = NULL;
    }

    EnterCriticalSection(&g_csEditWhileRunning);
    if(NULL != pCurrentMetabaseFileLastWriteTimeStamp)
    {
        g_EWRProcessedMetabaseTimeStamp = *pCurrentMetabaseFileLastWriteTimeStamp;
    }
    else
    {
        //
        // Unable to get the last write timestamp on the file.
        // Reset g_EWRProcessedMetabaseTimeStamp so that the next SaveAllData will
        // rename - else we may land up in a condition where we never rename.
        //
        memset((LPVOID)&g_EWRProcessedMetabaseTimeStamp, 0, sizeof(FILETIME));
    }
    LeaveCriticalSection(&g_csEditWhileRunning);

    DBGINFO((DBG_CONTEXT,
             "[ProgrammaticMetabaseSaveNotification] CURRENT EWR PROCESSED TIMESTAMPS:\nMetabaseEWRProcessedLastWrite low: %d\nMetabaseEWRProcessedLastWrite high: %d\n",
             CurrentMetabaseAttr.ftLastWriteTime.dwLowDateTime,
             CurrentMetabaseAttr.ftLastWriteTime.dwHighDateTime));

exit:

    if(bSavingMetabaseFileToDisk)
    {
        //
        // Reset the switch - This indicates that you are done with
        // processing the notification that initially arrived because
        // of a programmatic save. Note that it does not matter if
        // you did not treat it as a programmatic save.
        //

        EnterCriticalSection(&g_csEditWhileRunning);
        g_bSavingMetabaseFileToDisk              = FALSE;
        LeaveCriticalSection(&g_csEditWhileRunning);

    }

    return bProgrammaticMetabaseSaveNotification;

} // CFileListener::ProgrammaticMetabaseSaveNotification


/***************************************************************************++

Routine Description:

    Utility function to that fetches the current file attributes of the
    metabase file and the version number in it. Note that this function
    does not lock the file, so it is not guranteed that both out params
    are indeed from the same file. (ie the metabase file can be overwritten
    in between the file attribute fetch and the version number fetch).

Arguments:

    [out] Metabase file attributes.
    [out] Metabase version number.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::GetMetabaseAttributes(WIN32_FIND_DATAW* pCurrentMetabaseAttr,
                                             ULONG*            pulCurrentMetabaseVersion)
{

    HRESULT   hr       = S_OK;
    ULONG     cRetry   = 0;

    do
    {
        if(cRetry++ > 0)
        {
            //
            // If retrying because of sharing violation or path/file not found
            //, then sleep. Path or file not found can happen when the metabase
            // file is being renamed at the end of save all data.
            //
            Sleep(2000);
        }

        if(!GetFileAttributesExW(m_wszRealFileName,
                                 GetFileExInfoStandard,
                                 pCurrentMetabaseAttr)
          )
        {
            DWORD dwRes = GetLastError();
            hr = HRESULT_FROM_WIN32(dwRes);
        }
        else
        {
            hr = S_OK;
        }

    } while(( (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr) ||
              (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)    ||
              (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
            ) &&
            (cRetry < 10)
           );


    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
          L"[CFileListener::GetMetabaseAttributes] GetFileAttributesEx of %s failed with hr = 0x%x. Hence unable to determine if this is a programmatic save notification. Will assume that it is not.\n",
          m_wszRealFileName,
          hr));
        return hr;
    }

    //
    // GetVersionNumber already has the retry logic in it.
    //

    hr = GetVersionNumber(m_wszRealFileName,
                          pulCurrentMetabaseVersion,
                          NULL);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
          L"[CFileListener::GetMetabaseAttributes] GetVersionNumber of %s failed with hr = 0x%x. Hence unable to determine if this is a programmatic save notification. Will assume that it is not.\n",
          m_wszRealFileName,
          hr));
        return hr;
    }


    return hr;

} // CFileListener::GetMetabaseAttributes


/***************************************************************************++

Routine Description:

    Utility function to that compares the metabase file times and the metabase
    version number

Arguments:

    [in] Previous file create time stamp.
    [in] Previous last write create time stamp.
    [in] Previous metabase version
    [in] Current file create time stamp.
    [in] Current last write create time stamp.
    [in] Current metabase version

Return Value:

    BOOL

--***************************************************************************/
BOOL CFileListener::CompareMetabaseAttributes(FILETIME* pMostRecentMetabaseFileLastWriteTimeStamp,
                                              ULONG     ulMostRecentMetabaseVersion,
                                              FILETIME* pCurrentMetabaseFileLastWriteTimeStamp,
                                              ULONG     ulCurrentMetabaseVersion)
{
    if( (ulMostRecentMetabaseVersion == ulCurrentMetabaseVersion)          &&
        (0 == CompareFileTime(pMostRecentMetabaseFileLastWriteTimeStamp,
                              pCurrentMetabaseFileLastWriteTimeStamp)
        )
      )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

} // CFileListener::CompareMetabaseAttributes

/***************************************************************************++

Routine Description:

    This function gets the global helper object that has a  pointer to the bin
    file containing meta information. It is necessary that we copy the schema
    file because this can change while edits are being processed. (by a
    competing savealldata).

Arguments:

    [out] Global helper object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::GetGlobalHelperAndCopySchemaFile(CWriterGlobalHelper**      o_pISTHelper)
{
    HRESULT hr = S_OK;

    //
    // We want to take a read lock here because we want to prevent any schema
    // compilations. When the server is running, schema compilations take
    // place when SaveAllData is called and if there is a schema change since
    // the previous save. We will make a copy of the schema file before we
    // release the lock, so that we have a snapshot of the schema that is used
    // to process edit while running changes.
    //

    g_LockMasterResource.WriteLock();

    hr = ::GetGlobalHelper(TRUE,          // Means the call will fail if bin file is absent.
                           o_pISTHelper);

    if(FAILED(hr))
    {
        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_READING_SCHEMA_BIN,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::GetGlobalHelperAndCopySchemaFile] GetGlobalHelper failed with hr = 0x%x. Hence unable to get meta tables and hence unable to process changes.\n",
                  hr));

        goto exit;
    }

    if(!CopyFileW(m_wszSchemaFileName,
                  m_wszEditWhileRunningTempSchemaFile,
                  FALSE))
    {
        DWORD dwRes = GetLastError();
        hr = HRESULT_FROM_WIN32(dwRes);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::GetGlobalHelperAndCopySchemaFile] Copying schema file failed with hr = 0x%x. The schema file that is being stored with this version of edits may not be current.\n",
                  hr));

        m_bIsTempSchemaFile = FALSE;
        hr = S_OK;
    }
    else
    {
        m_bIsTempSchemaFile = TRUE;
        SetSecurityOnFile(m_wszSchemaFileName,
                          m_wszEditWhileRunningTempSchemaFile);
    }

exit:

    g_LockMasterResource.WriteUnlock();

    return hr;


} // CFileListener::GetGlobalHelperAndCopySchemaFile


/***************************************************************************++

Routine Description:

    This function deletes the temporary files created for processing in:
    ProgrammaticMetabaseSaveNotification
    GetGlobalHelperAndCopySchemaFile

Arguments:

    None

Return Value:

    void

--***************************************************************************/
void CFileListener::DeleteTempFiles()

{
    DeleteFileW(m_wszEditWhileRunningTempDataFile);

    if(m_bIsTempSchemaFile)
    {
        DeleteFileW(m_wszEditWhileRunningTempSchemaFile);
    }

    return;

} // CFileListener::DeleteTempFiles
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\metabase.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metabase.cxx

Abstract:

    IIS MetaBase exported routines.
    Routine comments are in metadata.h.

Author:

    Michael W. Thomas            31-May-96

Revision History:

--*/

#include "precomp.hxx"

#include <initguid.h>

DEFINE_GUID(CLSID_MDCOM,
0xba4e57f0, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x00, 0xaa, 0x00, 0xa7, 0x0d, 0x51);
DEFINE_GUID(CLSID_MDCOMEXE,
0xba4e57f1, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x00, 0xaa, 0x00, 0xa7, 0x0d, 0x51);
DEFINE_GUID(IID_IMDCOM,
0xc1aa48c0, 0xfacc, 0x11cf, 0x9d, 0x1a, 0x00, 0xaa, 0x00, 0xa7, 0x0d, 0x51);
DEFINE_GUID(IID_IMDCOM2,
0x08dbe811, 0x20e5, 0x4e09, 0xb0, 0xc8, 0xcf, 0x87, 0x19, 0x0c, 0xe6, 0x0e);
DEFINE_GUID(IID_IMDCOM3,
0xa53fd4aa, 0x6f0d, 0x4fe3, 0x9f, 0x81, 0x2b, 0x56, 0x19, 0x7b, 0x47, 0xdb);
DEFINE_GUID(IID_IMDCOMSINK_A,
0x5229ea36, 0x1bdf, 0x11d0, 0x9d, 0x1c, 0x00, 0xaa, 0x00, 0xa7, 0x0d, 0x51);
DEFINE_GUID(IID_IMDCOMSINK_W,
0x6906ee20, 0xb69f, 0x11d0, 0xb9, 0xb9, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x50);

extern "C"
{

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

HRESULT
AssureRunningAsAdministrator(VOID);

BOOL
WINAPI
DllMain(
    HINSTANCE           ,
    DWORD               dwReason,
    LPVOID
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    BOOL                bReturn = TRUE;
    HRESULT             hr = S_OK;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        if (InterlockedIncrement((long *)&g_dwProcessAttached) > 1)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Metadata.dll failed to load.\n"
                        "Most likely cause is IISADMIN service is already running.\n"
                        "Do a \"net stop iisadmin\" and stop all instances of inetinfo.exe.\n" ));
            bReturn = FALSE;
        }
        else
        {
            CREATE_DEBUG_PRINT_OBJECT("Metadata");
            LOAD_DEBUG_FLAGS_FROM_REG_STR( "System\\CurrentControlSet\\Services\\iisadmin\\Parameters", 0 );

            g_pboMasterRoot = NULL;
            g_phHandleHead = NULL;
            g_ppbdDataHashTable = NULL;
            for (int i = 0; i < EVENT_ARRAY_LENGTH; i++)
            {
                g_phEventHandles[i] = NULL;
            }
            g_hReadSaveSemaphore = NULL;
            g_bSaveDisallowed = FALSE;
            g_rSinkResource = new TS_RESOURCE();
            if (g_rSinkResource == NULL)
            {
                bReturn = FALSE;
            }
            if (bReturn)
            {
                hr = AssureRunningAsAdministrator();
                if ( SUCCEEDED(hr) )
                {
                    g_pFactory = new CMDCOMSrvFactory();
                    if (g_pFactory == NULL)
                    {
                        bReturn = FALSE;
                    }
                }
            }
            if (bReturn)
            {
                bReturn = InitializeMetabaseSecurity();
            }
        }

        break;

    case DLL_PROCESS_DETACH:
        if (InterlockedDecrement((long *)&g_dwProcessAttached) == 0)
        {
            g_LockMasterResource.WriteLock();

            // TerminateWorker1 was not called, or did not succeed, so call it in a loop until it reaches 0
            // stops EWR, saves the metabase (if there are any unsaved changes) and calls TerminateWorker.
            // However if TerminateWorker1 fails it won't decrement g_dwInitialized and we will be caught in an endless loop,
            // so exit the loop on failure from TerminateWorker1
            while ( ( g_dwInitialized > 0 ) && SUCCEEDED(hr) )
            {
                hr = TerminateWorker1(TRUE);
            }

            // In all cases g_dwInitialized must be 0 now.
            g_dwInitialized = 0;

            // In all cases call TerminateWorker too
            TerminateWorker();

            g_LockMasterResource.WriteUnlock();

            delete g_rSinkResource;
            g_rSinkResource = NULL;
            delete g_pFactory;
            g_pFactory = NULL;
            TerminateMetabaseSecurity();
            DELETE_DEBUG_PRINT_OBJECT();
        }
        break;

    default:
        break;
    }

    return bReturn;
}

HRESULT
AssureRunningAsAdministrator(VOID)
/*++

Routine Description:

    Verifies that process that loaded the dll is the process of IISADMIN service.
    Since there is no easy way to get the pid of the service if it is launched
    under a debugger, just checks that the owner of the process is Builtin\Administrators or LocalSystem.

Arguments:

    None

Returns:

    HRESULT. S_OK success, E_ACCESSDENIED if not running in IISADMIN, E_* on failure.

--*/
{
    // Locals
    HRESULT                 hr = S_OK;
    BOOL                    fRet;
    DWORD                   dwError;
    PSID                    psidOwner = NULL;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;

    // Get the security info of the process
    dwError = GetSecurityInfo( GetCurrentProcess(),
                               SE_KERNEL_OBJECT,
                               OWNER_SECURITY_INFORMATION,
                               &psidOwner,
                               NULL,
                               NULL,
                               NULL,
                               &pSecurityDescriptor );
    if ( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );

        DBGPRINTF(( DBG_CONTEXT,
                    "GetSecurityInfo() failed in AssureRunningAsAdministrator hr=0x%08x.\n",
                    hr ));
        goto exit;
    }
    if ( psidOwner == NULL )
    {
        hr = E_FAIL;

        DBGPRINTF(( DBG_CONTEXT,
                    "GetSecurityInfo() returned NULL sid.\n" ));
        goto exit;
    }

    // Check whether we are running as administrators
    fRet = IsWellKnownSid( psidOwner,
                           WinBuiltinAdministratorsSid );
    if ( !fRet )
    {
        // Check whether we are running as local system
        fRet = IsWellKnownSid( psidOwner,
                               WinLocalSystemSid );
    }
    if ( !fRet )
    {
        hr = E_ACCESSDENIED;

        DBGPRINTF(( DBG_CONTEXT,
                    "Not running as Administrators/LocalSystem in AssureRunningInIISADMIN.\n",
                    hr ));
        goto exit;
    }

exit:
    // Cleanup
    if ( pSecurityDescriptor != NULL )
    {
        LocalFree( pSecurityDescriptor );
        pSecurityDescriptor = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\importer.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Importer.cpp

Abstract:

    IIS MetaBase subroutines to support Import

Author:

    Mohit Srivastava            04-April-01

Revision History:

Notes:

--*/

#include "precomp.hxx"

const WCHAR CImporter::sm_wszInheritedPropertiesLocationPrefix[] = L"inherited:";
const ULONG CImporter::sm_cchInheritedPropertiesLocationPrefix =
	sizeof(sm_wszInheritedPropertiesLocationPrefix)/sizeof(WCHAR) - 1;

//
// public
//

CImporter::CImporter(
    LPCWSTR  i_wszFileName,
    LPCSTR   i_pszPassword)
{
    m_bInitCalled  = false;

    m_wszFileName  = i_wszFileName;
    m_pszPassword  = i_pszPassword;
}

CImporter::~CImporter()
{
}

HRESULT CImporter::Init()
{
    MD_ASSERT(m_bInitCalled == false);
    m_bInitCalled = true;
    return InitIST();
}

HRESULT CImporter::ShowPathsInFile(
    LPCWSTR pszKeyType,
    DWORD   dwMDBufferSize,
    LPWSTR  pszBuffer,
    DWORD*  pdwMDRequiredBufferSize)
{
    HRESULT hr = S_OK;

    //
    // All of the stuff is read into pISTProperty.
    // Now loop through and populate in-memory cache.
    // Properties are sorted by location.
    //
    ULONG          acbMBPropertyRow[cMBProperty_NumberOfColumns];
    tMBPropertyRow MBPropertyRow;
    DWORD          dwPreviousLocationID = (DWORD)-1;
    DWORD          bufLoc = 0;
    DWORD          dSize = 0;

    for(ULONG i=0; ;i++)
    {
        hr = m_spISTProperty->GetColumnValues(
            i,
            cMBProperty_NumberOfColumns,
            0,
            acbMBPropertyRow,
            (LPVOID*)&MBPropertyRow);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFO((DBG_CONTEXT,
                      "[ReadSomeDataFromXML] GetColumnValues failed with hr = 0x%x. Table:%ws. Read row index:%d.\n",           \
                      hr, wszTABLE_MBProperty, i));
            return hr;
        }

        bool bNewLocation = false;
        if(dwPreviousLocationID != *MBPropertyRow.pLocationID)
        {
            dwPreviousLocationID = *MBPropertyRow.pLocationID;
            bNewLocation         = true;
        }

        if(*MBPropertyRow.pID == MD_KEY_TYPE ||
           *MBPropertyRow.pID == MD_SERVER_COMMENT)
        {
            if (!wcscmp((LPCWSTR)MBPropertyRow.pValue, pszKeyType))
            {
                // MBPropertyRow.pLocation
                dSize = (DWORD)wcslen(MBPropertyRow.pLocation);
                if (bufLoc + dSize < dwMDBufferSize - 1)
                {
                    wcscpy(&(pszBuffer[bufLoc]), MBPropertyRow.pLocation);
                    pszBuffer[bufLoc + dSize] = 0;
                }
                bufLoc += dSize+1;
            }
        }
    }

    if (bufLoc < dwMDBufferSize)
    {
        pszBuffer[bufLoc] = 0;
    }
    else
    {
        pszBuffer[dwMDBufferSize-1] = 0;
        pszBuffer[dwMDBufferSize-2] = 0;
    }

    *pdwMDRequiredBufferSize = bufLoc;
    return hr;
}

HRESULT CImporter::DoIt(
    LPWSTR           i_wszSourcePath,
    LPCWSTR          i_wszKeyType,
    DWORD            i_dwMDFlags,
    CMDBaseObject**  o_ppboNew)
/*++

Synopsis:

Arguments: [i_wszSourcePath] -
           [i_wszKeyType] -
           [i_dwMDFlags] -
           [o_ppboNew] -

Return Value:

--*/
{
    MD_ASSERT(m_bInitCalled);
    MD_ASSERT(i_wszKeyType);
    MD_ASSERT(o_ppboNew);
    MD_ASSERT(*o_ppboNew == NULL);

    HRESULT              hr              = S_OK;
    BOOL                 bSawSourcePath  = false;
    LPWSTR               pLocation       = NULL;

    //
    // This is a pointer to some node in *o_ppboNew
    // It is the current node we are reading to.
    //
    CMDBaseObject*       pboRead  = NULL;

    //
    // Used for decryption
    //
    IIS_CRYPTO_STORAGE*  pStorage = NULL;


    g_LockMasterResource.ReadLock();
    hr = InitSessionKey(m_spISTProperty, &pStorage, (LPSTR)m_pszPassword);
    g_LockMasterResource.ReadUnlock();
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Create the parent base object
    //
    *o_ppboNew = new CMDBaseObject(L"Thenamedoesntmatter", NULL);
    if (*o_ppboNew == NULL || !((*o_ppboNew)->IsValid()) )
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        delete *o_ppboNew;
        goto exit;
    }

    //
    // All of the stuff is read into pISTProperty.
    // Now loop through and populate in-memory cache.
    // Properties are sorted by location.
    //
    ULONG          acbMBPropertyRow[cMBProperty_NumberOfColumns];
    tMBPropertyRow MBPropertyRow;
    BOOL           bSkipLocation        = FALSE;
    DWORD          dwPreviousLocationID = (DWORD)-1;
    Relation       eRelation            = eREL_NONE;
    for(ULONG i=0; ;i++)
    {
        BOOL    bLocationWithProperty = TRUE;
        BOOL    bNewLocation          = FALSE;

        hr = m_spISTProperty->GetColumnValues(
            i,
            cMBProperty_NumberOfColumns,
            0,
            acbMBPropertyRow,
            (LPVOID*)&MBPropertyRow);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReadSomeDataFromXML] GetColumnValues failed with hr = 0x%x. Table:%s. Read row index:%d.\n",           \
                      hr, wszTABLE_MBProperty, i));

            goto exit;
        }

        if(0 == wcscmp(MD_GLOBAL_LOCATIONW, MBPropertyRow.pLocation))
        {
            //
            // Ignore globals.
            //
            continue;
        }

        if((*MBPropertyRow.pID == MD_LOCATION) && (*MBPropertyRow.pName == MD_CH_LOC_NO_PROPERTYW))
        {
            bLocationWithProperty = FALSE;
        }
        if(dwPreviousLocationID != *MBPropertyRow.pLocationID)
        {
            bNewLocation         = TRUE;
            bSkipLocation        = FALSE;
            dwPreviousLocationID = *MBPropertyRow.pLocationID;
            pboRead              = *o_ppboNew;
            pLocation            = MBPropertyRow.pLocation;

            if(*MBPropertyRow.pGroup == eMBProperty_IIsInheritedProperties)
            {
                if(_wcsnicmp(
                    pLocation,
                    sm_wszInheritedPropertiesLocationPrefix,
                    sm_cchInheritedPropertiesLocationPrefix) == 0)
                {
                    pLocation += sm_cchInheritedPropertiesLocationPrefix;
                }
            }
        }
        if(bSkipLocation)
        {
            continue;
        }
#if DBG
        if(bLocationWithProperty == false)
        {
            MD_ASSERT(bNewLocation);
        }
#endif

        if(bNewLocation)
        {
            //
            // See if we're at a (grand*)child or self
            //
            eRelation = GetRelation(i_wszSourcePath, pLocation);

            switch(eRelation)
            {
            case eREL_SELF:
                if(*MBPropertyRow.pGroup != eMBProperty_IIsInheritedProperties)
                {
                    bSawSourcePath = true;
                }
                break;
            case eREL_PARENT:
                if(!(i_dwMDFlags & MD_IMPORT_INHERITED))
                {
                    bSkipLocation = TRUE;
                    continue;
                }
                break;
            case eREL_CHILD:
                if(i_dwMDFlags & MD_IMPORT_NODE_ONLY)
                {
                    bSkipLocation = TRUE;
                    continue;
                }
                break;
            default: // eRelation == eREL_NONE
                bSkipLocation = TRUE;
                continue;
            }

            if(*MBPropertyRow.pGroup == eMBProperty_IIsInheritedProperties)
            {
                if(!(i_dwMDFlags & MD_IMPORT_INHERITED))
                {
                    bSkipLocation = TRUE;
                    continue;
                }
            }
        }

        //
        // Some checks to see whether we skip just the current property, but not
        // necessarily the entire location.
        //
        if(*MBPropertyRow.pGroup == eMBProperty_IIsInheritedProperties)
        {
            if( !(fMBProperty_INHERIT & *MBPropertyRow.pAttributes) )
            {
                continue;
            }
        }
        else
        {
            //
            // Check for keytype match
            //
            if( eRelation                     == eREL_SELF   &&
                *MBPropertyRow.pID            == MD_KEY_TYPE &&
                MBPropertyRow.pValue          != NULL &&
                i_wszKeyType[0]               != L'\0' )
            {
                if(_wcsicmp((LPWSTR)MBPropertyRow.pValue, i_wszKeyType) != 0)
                {
                    hr = RETURNCODETOHRESULT(ERROR_NO_MATCH);
                    goto exit;
                }
            }
        }

        if(eRelation == eREL_PARENT)
        {
            if( !(fMBProperty_INHERIT & *MBPropertyRow.pAttributes) )
            {
                continue;
            }
        }

        if(bNewLocation && (eRelation != eREL_PARENT))
        {
            //
            // Create node in the metabase if it is not there yet.
            // pboRead is pointer to this node.
            //
            hr = ReadMetaObject(i_wszSourcePath,
                                *o_ppboNew,
                                pLocation,
                                &pboRead);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

        if(bLocationWithProperty)
        {
            MD_ASSERT(pboRead != NULL);
            hr = ReadDataObject(pboRead,
                                (LPVOID*)&MBPropertyRow,
                                acbMBPropertyRow,
                                pStorage,
                                TRUE);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

    }

    if(!bSawSourcePath)
    {
        hr = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        goto exit;
    }

exit:

    //
    // Cleanup
    //
    if(FAILED(hr) && NULL != *o_ppboNew)
    {
        delete (*o_ppboNew);
        *o_ppboNew = NULL;
    }

    delete pStorage;
    pStorage = NULL;

    return hr;
}

HRESULT CImporter::InitIST()
/*++

Synopsis:

Return Value:

--*/
{
    HRESULT     hr = S_OK;
    STQueryCell QueryCell[1];

    //
    // Get the property table.
    //
    QueryCell[0].pData     = (LPVOID)m_wszFileName;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(m_wszFileName)+1)*sizeof(WCHAR);

    ULONG cCell            = sizeof(QueryCell)/sizeof(STQueryCell);

    //
    // No need to initilize dispenser (InitializeSimpleTableDispenser()),
    // because we now specify USE_CRT=1 in sources, which means that
    // globals will be initialized.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&m_spISTDisp, WSZ_PRODUCT_IIS );
    if(FAILED(hr))
    {
        DBGERROR((
            DBG_CONTEXT,
            "[%s] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",__FUNCTION__,hr));
        return hr;
    }

    hr = m_spISTDisp->GetTable(
        wszDATABASE_METABASE,
        wszTABLE_MBProperty,
        (LPVOID)QueryCell,
        (LPVOID)&cCell,
        eST_QUERYFORMAT_CELLS,
        fST_LOS_DETAILED_ERROR_TABLE | fST_LOS_NO_LOGGING,
        (LPVOID *)&m_spISTProperty);

    //
    // Log warnings/errors in getting the mb property table
    // Do this BEFORE checking the return code of GetTable.
    //
    CComPtr<IErrorInfo> spErrorInfo;
    HRESULT hrErrorTable = GetErrorInfo(0, &spErrorInfo);
    if(hrErrorTable == S_OK) // GetErrorInfo returns S_FALSE when there is no error object
    {
        //
        // Get the ICatalogErrorLogger interface to log the errors.
        //
        CComPtr<IAdvancedTableDispenser> spISTDispAdvanced;
        hrErrorTable = m_spISTDisp->QueryInterface(
            IID_IAdvancedTableDispenser,
            (LPVOID*)&spISTDispAdvanced);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((
                DBG_CONTEXT,
                "[%s] Could not QI for Adv Dispenser, hr=0x%x\n", __FUNCTION__, hrErrorTable));
            return hr;
        }

        hrErrorTable = spISTDispAdvanced->GetCatalogErrorLogger(&m_spILogger);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((
                DBG_CONTEXT,
                "[%s] Could not get ICatalogErrorLogger2, hr=0x%x\n", __FUNCTION__, hrErrorTable));
            return hr;
        }

        //
        // Get the ISimpleTableRead2 interface to read the errors.
        //
        hrErrorTable =
            spErrorInfo->QueryInterface(IID_ISimpleTableRead2, (LPVOID*)&m_spISTError);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((DBG_CONTEXT, "[%s] Could not get ISTRead2 from IErrorInfo\n, __FUNCTION__"));
            return hr;
        }

        for(ULONG iRow=0; ; iRow++)
        {
            tDETAILEDERRORSRow ErrorInfo;
            hrErrorTable = m_spISTError->GetColumnValues(
                iRow,
                cDETAILEDERRORS_NumberOfColumns,
                0,
                0,
                (LPVOID*)&ErrorInfo);
            if(hrErrorTable == E_ST_NOMOREROWS)
            {
                break;
            }
            if(FAILED(hrErrorTable))
            {
                DBGWARN((DBG_CONTEXT, "[%s] Could not read an error row.\n", __FUNCTION__));
                return hr;
            }

            hrErrorTable =
                m_spILogger->ReportError(
                    BaseVersion_DETAILEDERRORS,
                    ExtendedVersion_DETAILEDERRORS,
                    cDETAILEDERRORS_NumberOfColumns,
                    0,
                    (LPVOID*)&ErrorInfo);
            if(FAILED(hrErrorTable))
            {
                DBGWARN((DBG_CONTEXT, "[%s] Could not log error.\n", __FUNCTION__));
                return hr;
            }
            hr = MD_ERROR_READ_METABASE_FILE;
        } // for(ULONG iRow=0; ; iRow++)
    } // if(hrErrorTable == S_OK)

    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "[%s] GetTable failed with hr = 0x%x.\n",__FUNCTION__,hr));
        return hr;
    }

    return hr;
}

//
// private
//

CImporter::Relation CImporter::GetRelation(
    LPCWSTR i_wszSourcePath,
    LPCWSTR i_wszCheck)
/*++

Synopsis:

Arguments: [i_wszSourcePath] -
           [i_wszCheck] -

Return Value:

--*/
{
    Relation eRelation     = eREL_NONE;
    BOOL     bIsSourcePath = false;
    BOOL     bIsChild      = IsChild(i_wszSourcePath, i_wszCheck, &bIsSourcePath);
    if(bIsChild)
    {
        eRelation = (bIsSourcePath) ? eREL_SELF : eREL_CHILD;
    }
    else
    {
        BOOL bIsParent = IsChild(i_wszCheck, i_wszSourcePath, &bIsSourcePath);
        if(bIsParent)
        {
            MD_ASSERT(bIsSourcePath == false);
            eRelation = eREL_PARENT;
        }
        else
        {
            eRelation = eREL_NONE;
        }
    }

    return eRelation;
}

BOOL
CImporter::IsChild(
    LPCWSTR i_wszParent,
    LPCWSTR i_wszCheck,
    BOOL    *o_pbSamePerson)
/*++

Synopsis:

Arguments: [i_wszParent] -    Ex. /LM/w3svc/1/root
           [i_wszCheck] -     Ex. /LM/w3svc/1
           [o_pbSamePerson] - true if i_wszParent and i_wszCheck is same person

Return Value:
    true if i_wszCheck is child or same person

--*/
{
    MD_ASSERT(i_wszParent != NULL);
    MD_ASSERT(i_wszCheck  != NULL);
    MD_ASSERT(o_pbSamePerson != NULL);

    LPCWSTR pParent;
    LPCWSTR pCheck;

    pParent = i_wszParent;
    pCheck  = i_wszCheck;

    SKIP_DELIMETER(pParent, MD_PATH_DELIMETERW);
    SKIP_DELIMETER(pCheck,  MD_PATH_DELIMETERW);

    if(*pParent == L'\0')
    {
        switch(*pCheck)
        {
        case L'\0':
            *o_pbSamePerson = TRUE;
            break;
        default:
            *o_pbSamePerson = FALSE;
        }
        return TRUE;
    }

    while(*pParent != L'\0')
    {
        if(_wcsnicmp(pParent, pCheck, 1) == 0)
        {
            pParent++;
            pCheck++;
        }
        else if(*pParent == MD_PATH_DELIMETERW && pParent[1] == L'\0' && *pCheck == L'\0')
        {
            *o_pbSamePerson = TRUE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    switch(*pCheck)
    {
    case L'\0':
        *o_pbSamePerson = TRUE;
        return TRUE;
    case MD_PATH_DELIMETERW:
        *o_pbSamePerson = (pCheck[1] == L'\0') ? TRUE : FALSE;
        return TRUE;
    default:
        return FALSE;
    }
}

HRESULT CImporter::ReadMetaObject(
    IN LPCWSTR i_wszAbsParentPath,
    IN CMDBaseObject *i_pboParent,
    IN LPCWSTR i_wszAbsChildPath,
    OUT CMDBaseObject **o_ppboChild)
/*++

Synopsis:
    Returns a pbo for the child.  If it does not already exist, it is
    created.

Arguments: [i_wszAbsParentPath] -
           [i_pboParent] - pbo corresponding to i_wszAbsParentPath
           [i_wszAbsChildPath] -
           [o_ppboChild] - pbo corresponding to i_wszAbsChildPath

Return Value:

--*/
{
    MD_ASSERT(i_pboParent != NULL);
    MD_ASSERT(i_wszAbsParentPath != NULL);
    MD_ASSERT(i_wszAbsChildPath != NULL);
    MD_ASSERT(o_ppboChild != NULL);

    HRESULT hr = ERROR_SUCCESS;
    HRESULT hrWarn = ERROR_SUCCESS;

    int iLenParent = (int)wcslen(i_wszAbsParentPath);
    int iLenChild  = (int)wcslen(i_wszAbsChildPath);

    LPWSTR wszParent = NULL;
    LPWSTR wszChild  = NULL;

    wszParent = new wchar_t[iLenParent+1];
    if(wszParent == NULL)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    wszChild = new wchar_t[iLenChild+1];
    if(wszChild == NULL)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    int idxParent = 0;
    int idxChild = 0;

    BOOL bRetParent = FALSE;
    BOOL bRetChild  = FALSE;

    CMDBaseObject *pboNew = NULL;
    CMDBaseObject *pboLastParent = i_pboParent;

    while(1) {
        bRetParent = EnumMDPath(i_wszAbsParentPath, wszParent, &idxParent);
        bRetChild =  EnumMDPath(i_wszAbsChildPath,  wszChild,  &idxChild);

        if(bRetParent == FALSE) {
            break;
        }
    }

    while(bRetChild == TRUE) {
        //
        // This is okay, since function that uses this takes an LPSTR
        // and a bool saying whether or not the string is unicode.
        //
        LPSTR pszTemp = (LPSTR)wszChild;

        pboNew = pboLastParent->GetChildObject(pszTemp, &hrWarn, TRUE);
        if(pboNew == NULL) {
            //
            // Create it
            //
            pboNew = new CMDBaseObject(wszChild, NULL);
            if (pboNew == NULL) {
                hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            else if (!pboNew->IsValid()) {
                hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
                goto exit;
            }
            hr = pboLastParent->InsertChildObject(pboNew);
            if(FAILED(hr)) {
                delete pboNew;
                goto exit;
            }
        }
        pboLastParent = pboNew;

        bRetChild = EnumMDPath(i_wszAbsChildPath,  wszChild,  &idxChild);
    }

    //
    // Set out params
    //
    *o_ppboChild = pboLastParent;

exit:
    delete [] wszParent;
    delete [] wszChild;

    return hr;
}

BOOL CImporter::EnumMDPath(
    LPCWSTR i_wszFullPath,
    LPWSTR  io_wszPath,
    int*    io_iStartIndex)
/*++

Synopsis:
    Starting at io_iStartIndex, this function will find the next token.
    Eg. i_wszFullPath   =  /LM/w3svc/1
        *io_iStartIndex =  3
        io_wszPath      => w3svc
        *io_iStartIndex =  9

Arguments: [i_wszFullPath] -  Ex. /LM/w3svc/1
           [io_wszPath] -     Should be at least same size as i_wszFullPath
           [io_iStartIndex] - 0-based index to start looking from

Return Value:
    true if io_wszPath is set.

--*/
{
    MD_ASSERT(i_wszFullPath != NULL);
    MD_ASSERT(io_wszPath    != NULL);

    int idxEnd =   *io_iStartIndex;
    int idxStart = *io_iStartIndex;

    if(i_wszFullPath[idxStart] == MD_PATH_DELIMETERW)
    {
        idxStart++;
        idxEnd++;
    }

    //
    // If there is no more to enum, just exit and don't set out params
    //
    if(i_wszFullPath[idxStart] == L'\0')
    {
        return FALSE;
    }

    for(; ; idxEnd++)
    {
        if(i_wszFullPath[idxEnd] == MD_PATH_DELIMETERW)
        {
            break;
        }
        if(i_wszFullPath[idxEnd] == L'\0')
        {
            break;
        }
    }

    //
    // Set out params
    //
    *io_iStartIndex = idxEnd;
    memcpy(io_wszPath, &i_wszFullPath[idxStart], sizeof(wchar_t) * (idxEnd-idxStart));
    io_wszPath[idxEnd-idxStart] = L'\0';

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\ptrmap.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

    Module Name:

      ptrmap.cxx

    Abstract:

      A helper class for mapping ID to 32 or 64 bit ptr

    Author:
      Kestutis Patiejunas (kestutip)        08-Dec-1998


    Revision History:

      Notes:

--*/

#include "precomp.hxx"

#ifdef _X86_
/*++
Routine Description:

    Constructor

    Arguments: ignored

    Return Value: NA

--*/
CIdToPointerMapper::CIdToPointerMapper(
    DWORD               ,
    DWORD               )
{
}


CIdToPointerMapper::~CIdToPointerMapper()
{
}


VOID
CIdToPointerMapper::VerifyOutstandinMappings()
{
}

/*++
Routine Description:

    Finds a mapping in mapping table between DWORD ID and pointer associated

    Arguments:
    DWORD ID - and ID to which mapping should be deleted.

    Return Value:

    PVOID - the pointer associated with the given ID.
    NULL indicates  a failure.

--*/
PVOID
CIdToPointerMapper::FindMapping(
    DWORD               id)
{
    return (PVOID)id;
}


/*++
Routine Description:

  Deletes a mapping from mapping table between dword ID and PTR

    Arguments: ignored

    Return Value:

    BOOL TRUE is succeded
--*/
BOOL
CIdToPointerMapper::DeleteMapping(
    DWORD               )
{
    return TRUE;
}


/*++
Routine Description:

  Takes a PVOID pointer and returns a DWORD ID associated,which should be used
  in mapping it back to ptr

    Arguments:
    PVOID ptr - a pointer of 32/64 bits which should be mapped into dword

    Return Value:
    DWORD - an ID associated with a given pointer . Starts from 1.
    Zero indicates  a failure to craete mapping.

--*/
DWORD
CIdToPointerMapper::AddMapping(
    PVOID               ptr)
{
    return (DWORD)ptr;
}

#else // ifdef _X86_
/*++
Routine Description:

  Constructor

    Arguments:
    nStartMaps - initial nubmer of possible mappings in table
    nIncreaseMaps - number of increase for table when there is not enought space

      Return Value:
      sucess is tored in m_fInitialized

--*/
CIdToPointerMapper::CIdToPointerMapper(DWORD nStartMaps,DWORD nIncreaseMaps):
                    m_nStartMaps(nStartMaps),
                    m_nIncreaseMaps(nIncreaseMaps)
{
    if (!m_nStartMaps)
    {
        m_nStartMaps = DEFAULT_START_NUMBER_OF_MAPS;
    }
    if (!nIncreaseMaps)
    {
        m_nIncreaseMaps = DEFAULT_INCREASE_NUMBER_OF_MAPS;
    }


    // initial empty list head index
    m_EmptyPlace = 0;
    m_nMappings = 0;
    m_Map = NULL;

    // allocate a mem for mapping
    m_pBufferObj = new BUFFER (m_nStartMaps * sizeof(MapperElement));
    if( m_pBufferObj )
    {
        m_Map = (MapperElement *) m_pBufferObj->QueryPtr();
    }

    if (m_Map)
    {
        // initialized mappaing space so the every element point to next one
        for (DWORD i=0; i< m_nStartMaps; i++)
        {
            m_Map[i].fInUse = FALSE;
            m_Map[i].dwIndex = i+1;
        }

        // just the last has special value
        m_Map[m_nStartMaps-1].dwIndex = MAPPING_NO_EMPTY_PLACE_IDX;

        m_fInitialized = TRUE;
    }
    else
    {
        m_fInitialized =FALSE;
    }
}


CIdToPointerMapper::~CIdToPointerMapper()
{
    VerifyOutstandinMappings ();
    if (m_fInitialized)
    {
        delete m_pBufferObj;
    }
}


VOID CIdToPointerMapper::VerifyOutstandinMappings ()
{
    MD_ASSERT (m_nMappings==0);
}




/*++
Routine Description:

  Finds a mapping in mapping table between DWORD ID and pointer associated

    Arguments:
    DWORD ID - and ID to which mapping should be deleted.

      Return Value:

        DWORD - an ID associated with a given pointer . Starts from 1.
        Zero indicates  a failure to craete mapping.

--*/

PVOID   CIdToPointerMapper::FindMapping (DWORD id)
{
    PVOID retVal = NULL;

    if (m_fInitialized)
    {
        id--;

        MD_ASSERT (id < m_nStartMaps);
        if (id < m_nStartMaps &&
            m_Map[id].fInUse)
        {
            retVal = m_Map[id].pData;
        }
    }

    return retVal;
}


/*++
Routine Description:

  Deletes a mapping from mapping table between dword ID and PTR

    Arguments:
    DWORD ID - and ID to which mapping should be deleted.

      Return Value:

        BOOL TRUE is succeded
--*/

BOOL  CIdToPointerMapper::DeleteMapping (DWORD id)
{
    BOOL retVal = FALSE;

    if (m_fInitialized)
    {
        id--;

        MD_ASSERT (id < m_nStartMaps);
        if (id < m_nStartMaps)
        {
            MD_ASSERT (m_Map[id].fInUse);

            // get the ptr from element with index [id]
            if (m_Map[id].fInUse)
            {
                // add elemen to empty elements list
                m_Map[id].fInUse = FALSE;
                m_Map[id].dwIndex = m_EmptyPlace;
                m_EmptyPlace = id;
                MD_ASSERT(m_nMappings);
                m_nMappings--;
                retVal = TRUE;
            }
        }
    }

    return retVal;
}


/*++
Routine Description:

  Takes a PVOID pointer and returns a DWORD ID associated,which should be used
  in mapping it back to ptr

    Arguments:
    PVOID ptr - a pointer of 32/64 bits which should be mapped into dword

      Return Value:

        DWORD - an ID associated with a given pointer . Starts from 1.
        Zero indicates  a failure to craete mapping.

--*/
DWORD   CIdToPointerMapper::AddMapping (PVOID ptr)
{
    DWORD retVal=0;
    DWORD newSize, i, dwPlace;

    if (m_fInitialized)
    {
        if (m_EmptyPlace == MAPPING_NO_EMPTY_PLACE_IDX)
        {
            // case when there is not enough mem , so then try to realloc
            newSize = m_nStartMaps + m_nIncreaseMaps;

            if (!m_pBufferObj->Resize(newSize * sizeof(MapperElement)))
            {
                return 0;
            }

            m_Map = (MapperElement *) m_pBufferObj->QueryPtr();

            // realloc succeded initialize the remainder as free list
            for (i=m_nStartMaps; i<newSize; i++)
            {
                m_Map[i].fInUse = FALSE;
                m_Map[i].dwIndex = i+1;
            }
            m_Map[newSize-1].dwIndex = MAPPING_NO_EMPTY_PLACE_IDX;
            m_EmptyPlace = m_nStartMaps;
            m_nStartMaps = newSize;
        }


        // case when there was at least one empty element in free list

        MD_ASSERT(!m_Map[m_EmptyPlace].fInUse);
        dwPlace = m_EmptyPlace;
        m_EmptyPlace = m_Map[m_EmptyPlace].dwIndex;

        // add a pointer into array and return associated ID
        // note, that we return dwPlace+1 ,a s we don't use ID zero
        m_Map[dwPlace].pData = ptr;
        m_Map[dwPlace].fInUse = TRUE;
        retVal = dwPlace + 1;
        m_nMappings++;
    }
    return retVal;
}

#endif // ifdef _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\listenercontroller.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ListenerController.cpp

Abstract:

    Implementation of the class that starts and stops the Listener.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/
#include "precomp.hxx"

// Fwd declaration
extern CListenerController* g_pListenerController;
DWORD WINAPI StartListenerThread(LPVOID  lpParam);

/***************************************************************************++

Routine Description:

    Constructor for the ListenerController class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CListenerController::CListenerController()
{
    m_pEventLog                          = NULL;
    memset(m_aHandle, 0, sizeof(m_aHandle));
    m_hListenerThread                    = NULL;
    m_bDoneWaitingForListenerToTerminate = FALSE;
    m_cRef                               = 0;
    m_eState                             = iSTATE_STOP_TEMPORARY;

    for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++)
    {
        m_aHandle[i] = INVALID_HANDLE_VALUE;
    }
}

/***************************************************************************++

Routine Description:

    Implementation of IUnknown::QueryInterface

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP CListenerController::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if(riid == IID_IUnknown)
    {
        *ppv = (IUnknown*) this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown*)this)->AddRef ();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }

} // CListenerController::QueryInterface


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::AddRef

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CListenerController::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);

} // CListenerController::AddRef


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::Release

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CListenerController::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;

} // CListenerController::Release

/***************************************************************************++

Routine Description:

    Initialize events, locks, and the state of the controller.
    Stop listening event is used to signal to the listener thread to stop
    listening to file change notifications.
    Process notifications event is used in the listener thread to trigger
    processing the file changes.
    The state vaiable is to to keep the state of the listener thread -
    if it has been started or stopped. It is initialized to stop temporary.
    Stop permanent state is set when you do not want to make any more
    transitions to the start state, like when the service is shutting down.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CListenerController::Init()
{
    HRESULT                  hr           = S_OK;
    ISimpleTableDispenser2*  pISTDisp     = NULL;
    IAdvancedTableDispenser* pISTAdvanced = NULL;

    for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++)
    {
        m_aHandle[i] = INVALID_HANDLE_VALUE;
    }

    m_aHandle[iEVENT_MANAGELISTENING] = CreateEvent(NULL,   // no security attributes
                                                  FALSE,  // auto-reset event object
                                                  FALSE,  // initial state is nonsignaled
                                                  NULL);  // unnamed object

    if (m_aHandle[iEVENT_MANAGELISTENING] == INVALID_HANDLE_VALUE)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto exit;
    }


    m_aHandle[iEVENT_PROCESSNOTIFICATIONS] = CreateEvent(NULL,   // no security attributes
                                                         FALSE,  // auto-reset event object
                                                         FALSE,  // initial state is nonsignaled
                                                         NULL);  // unnamed object

    if (m_aHandle[iEVENT_PROCESSNOTIFICATIONS] == INVALID_HANDLE_VALUE)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto exit;
    }

    m_eState = iSTATE_STOP_TEMPORARY;

    hr = m_LockStartStop.Initialize();

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = pISTDisp->QueryInterface(IID_IAdvancedTableDispenser,
                                  (LPVOID*)&pISTAdvanced);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = pISTAdvanced->GetCatalogErrorLogger(&m_pEventLog);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != pISTAdvanced)
    {
        pISTAdvanced->Release();
        pISTAdvanced = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Destructor for the CListenerController class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CListenerController::~CListenerController()
{
    for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++)
    {
        if((m_aHandle[i] != INVALID_HANDLE_VALUE) &&
           (m_aHandle[i] != 0)
          )
        {
            CloseHandle(m_aHandle[i]);
            m_aHandle[i] = INVALID_HANDLE_VALUE;
        }
    }

    m_LockStartStop.Terminate();

    if(m_pEventLog)
    {
        m_pEventLog->Release();
        m_pEventLog = NULL;
    }

    if(!m_bDoneWaitingForListenerToTerminate)
    {
        //
        // Do not close the handle to the listener thread in the destructor.
        // It is handed out to the caller when they stop permanent so that
        // the caller can wait for the thread to terminate. After the wait
        // the caller should close the handle.  The reason why we canot wait
        // within the stop function is because while calling start/stop the
        // caller takes the g_LockMasterResource lock, and you do not want to
        // wait while the lock is taken, because the listener thread also
        // takes the same g_LockMasterResource lock under certain conditions,
        // and this can lead to a deadlock.
        //

        m_hListenerThread = NULL;
    }
    else if(NULL != m_hListenerThread)
    {
        CloseHandle(m_hListenerThread);
        m_hListenerThread = NULL;
    }

}


/***************************************************************************++

Routine Description:

    Start the state listener.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CListenerController::Start()
{

    HRESULT      hr                                = S_OK;
    DWORD        dwThreadID;
    DWORD        dwRes                             = 0;

    CLock   StartStopLock(&m_LockStartStop);

    if(m_eState == iSTATE_STOP_TEMPORARY)
    {
        //
        // Start only if the previous state is stop temporary.
        //

        if(NULL == m_hListenerThread)
        {
            AddRef();

            DBGINFOW((DBG_CONTEXT,
                      L"[Start] Creating edit while running thread.\n",
                      hr));

            m_hListenerThread = CreateThread( NULL,
                                              0,
                                              StartListenerThread,
                                              (LPVOID)this,
                                              0,
                                              &dwThreadID );

            if (m_hListenerThread == NULL)
            {
                dwRes = GetLastError();
                hr = HRESULT_FROM_WIN32(dwRes);

                DBGINFOW((DBG_CONTEXT,
                          L"[Start] Could not create edit while running thread. CreateThread falied with hr=0x%x\n",
                          hr));

                Release();
                //
                // Note: If the thread is created successfully, it will do the release
                //
                return hr;
            }

            //
            // Keep the thread handle around to detect the demise of the
            // thread when the service stops.
            //

        }

        m_eState = iSTATE_START;

        DBGINFOW((DBG_CONTEXT,
                  L"[Start] Setting start event.\n"));

        if(!SetEvent(m_aHandle[iEVENT_MANAGELISTENING]))
        {
            dwRes = GetLastError();
            hr = HRESULT_FROM_WIN32(dwRes);

            DBGINFOW((DBG_CONTEXT,
                      L"[Start] Setting start event failed with hr=0x%x. Resetting state to iSTATE_STOP_TEMPORARY.\n",
                      hr));

            m_eState = iSTATE_STOP_TEMPORARY;
        }

    }

    return hr;

} // CListenerController::Start


/***************************************************************************++

Routine Description:

    Stop the listener.

Arguments:

    Stop type - permanent, means you cannot go back to start state.
              - temporary means you can restart.
    Handle    - When a valid handle pointer is specified and the stop type is
                permanent it means that the caller wants to wait for the
                listener thread to die outside the stop function and we
                hand the thread handle out to the caller and we do not
                wait for the thread to die or close the handle. The reason
                why the caller would want to wait outside the stop function
                is because the caller may have obtained a lock before calling
                stop and may want to wait outside the scope of the function.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CListenerController::Stop(eSTATE   i_eState,
                                  HANDLE*  o_hListenerThread)
{
    HRESULT      hr                                = S_OK;
    DWORD        dwRes                             = 0;
    HANDLE       hListenerThread                   = INVALID_HANDLE_VALUE;

    DBG_ASSERT((i_eState == iSTATE_STOP_TEMPORARY) ||
               (i_eState == iSTATE_STOP_PERMANENT));

    CLock   StartStopLock(&m_LockStartStop);

    eSTATE  eStateWAS = m_eState;
    hListenerThread = m_hListenerThread;

    if((m_eState == iSTATE_START)                     ||
       ((m_eState == iSTATE_STOP_TEMPORARY)  &&
        (i_eState == iSTATE_STOP_PERMANENT)
       )
      )
    {
        //
        // Set an event that will stop listening
        //

        m_eState = i_eState;

        DBGINFOW((DBG_CONTEXT,
                  L"[Stop] Setting stop event.\n"));

        if(!SetEvent(m_aHandle[iEVENT_MANAGELISTENING]))
        {
            //
            // If set event fails then do not reset the state. One of the
            // following can happen:
            // A. Stop event is called which will attempt to stop again.
            // B. Start event is called and it will not start because it is
            //    is alredy in the start state.
            //

            dwRes = GetLastError();
            hr = HRESULT_FROM_WIN32(dwRes);

            DBGINFOW((DBG_CONTEXT,
                      L"[Stop] Setting stop event failed with hr=0x%x. Resetting state to %d.\n",
                      hr,
                      (DWORD)eStateWAS));

            m_eState = eStateWAS;

            return hr;
        }
    }

    StartStopLock.UnLock();

    if((i_eState   == iSTATE_STOP_PERMANENT)     &&
       (NULL       != hListenerThread)         &&
       ((eStateWAS == iSTATE_START)          ||
        (eStateWAS == iSTATE_STOP_TEMPORARY)
       )
      )
    {
        if(NULL != o_hListenerThread)
        {
            *o_hListenerThread = hListenerThread;
            StartStopLock.Lock();
            m_bDoneWaitingForListenerToTerminate = FALSE;
            m_hListenerThread = NULL;
            StartStopLock.UnLock();
        }
        else
        {

            dwRes = WaitForSingleObject(hListenerThread,
                                        INFINITE);

            if((dwRes == WAIT_ABANDONED) ||
               (dwRes == WAIT_TIMEOUT)
              )
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[Stop] Wait for Edit while running thread to terminate failed. dwRes=0x%x. Ignoring this event.\n",
                          dwRes));
                // TODO: Log an error
            }

            StartStopLock.Lock();
            m_bDoneWaitingForListenerToTerminate = TRUE;
            CloseHandle(m_hListenerThread);
            m_hListenerThread = NULL;
            StartStopLock.UnLock();

        }
    }

    return S_OK;

} // CListenerController::Stop


/***************************************************************************++

Routine Description:

    Helper function that returns a pointer to the handle array.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HANDLE * CListenerController::Event()
{
    return (HANDLE *)m_aHandle;
}



/***************************************************************************++

Routine Description:

    Helper function that returns a pointer to the eventlog object.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
ICatalogErrorLogger2 * CListenerController::EventLog()
{
    return (ICatalogErrorLogger2*)m_pEventLog;
}


/***************************************************************************++

Routine Description:

    Function that starts the listener thread. We ensure that there is only one
    listener thread at any given time by taking a lock.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
DWORD WINAPI StartListenerThread(LPVOID  lpParam)
{
    CListenerController*    pListenerController = (CListenerController*)lpParam;

    CoInitializeEx (NULL, COINIT_MULTITHREADED);

    DBG_ASSERT(NULL != pListenerController);

    pListenerController->Listen();

    //
    // CListenerController::Start addrefs the CListenerController and calls CreateThread.
    // If create thread fails, it releases it. Else the thread is supposed to release it.
    //

    pListenerController->Release();

    CoUninitialize();

    return 0;
}


/***************************************************************************++

Routine Description:

    Function that waits for the start/stop event and creates or deletes the
    listener.

Arguments:

    None.

Return Value:

    void

--***************************************************************************/
void CListenerController::Listen()
{
    CFileListener*  pListener  = NULL;
    HRESULT         hr         = S_OK;

    //
    // First create and initialize the listener object.
    //

    for ( ; ; )
    {
        DWORD dwRes = WaitForMultipleObjects(cmaxLISTENERCONTROLLER_EVENTS,
                                             m_aHandle,
                                             FALSE,
                                             INFINITE);

        if((WAIT_FAILED == dwRes) ||
           ((iEVENT_MANAGELISTENING      != (dwRes - WAIT_OBJECT_0)) &&
            (iEVENT_PROCESSNOTIFICATIONS != (dwRes - WAIT_OBJECT_0))
           )
          )
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[Listen] Unexpected event received. dwRes=0x%x. Ignoring this event.\n",
                      HRESULT_FROM_WIN32(GetLastError())));

            continue;
        }

        if(NULL == pListener)
        {
            //
            // If the listener has never been created, then create it. If the
            // creation fails then set the state to stop temporary. Note that
            // the listener has to be created on the heap because it is handed
            // off to the file notification object which then makes async calls
            // on it and it releases it when done.
            //

            DBGINFOW((DBG_CONTEXT, L"[Listen] Creating listener object.\n"));

            hr = CreateListener(&pListener);


            if(FAILED(hr))
            {
                LogEvent(EventLog(),
                          MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS,
                          EVENTLOG_ERROR_TYPE,
                          ID_CAT_CAT,
                          hr);

                DBGINFOW((DBG_CONTEXT, L"[Listen] Unable to create listener object. hr = 0x%x\n",hr));

                CLock    StartStopLock(&m_LockStartStop);

                switch(m_eState)
                {
                    case iSTATE_STOP_TEMPORARY:
                        break;

                    case iSTATE_STOP_PERMANENT:
                        //
                        // This means that a stop permanent event was received before a start event could successfully complete.
                        // We will simply exit.
                        //
                        goto exit;
                        break;

                    case iSTATE_START:
                    default:
                        m_eState = iSTATE_STOP_TEMPORARY;
                        break;

                }

                continue;
            }
        }

        DBG_ASSERT(NULL != pListener);

        CLock    StartStopLock(&m_LockStartStop);

        if(iEVENT_MANAGELISTENING == (dwRes - WAIT_OBJECT_0))
        {
            switch(m_eState)
            {
                case iSTATE_STOP_TEMPORARY:

                    DBGINFOW((DBG_CONTEXT, L"[Listen] Unsubscribing temporarily..\n"));
                    pListener->UnSubscribe();
                    break;

                case iSTATE_STOP_PERMANENT:

                    DBGINFOW((DBG_CONTEXT, L"[Listen] Unsubscribing permanently..\n"));
                    pListener->UnSubscribe();
                    goto exit;

                case iSTATE_START:

                    DBGINFOW((DBG_CONTEXT, L"[Listen] Subscibing..\n"));
                    hr = pListener->Subscribe();
                    if(FAILED(hr))
                    {
                       LogEvent(EventLog(),
                                MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS,
                                EVENTLOG_ERROR_TYPE,
                                ID_CAT_CAT,
                                hr);

                        m_eState = iSTATE_STOP_TEMPORARY;
                    }
                    break;

                default:
                    DBG_ASSERT( ( m_eState == iSTATE_STOP_TEMPORARY ) ||
                                ( m_eState == iSTATE_STOP_PERMANENT ) ||
                                ( m_eState == iSTATE_START ) );
                    DBGINFOW((DBG_CONTEXT, L"[Listen] Unknown initial state - ignoring event..\n"));
                    break;
            }
            continue;
        }
        else if(m_eState != iSTATE_START)
        {
            //
            // This means that the process notifications event was set, but
            // the state is not started, so ignore the notification.
            //
            DBGINFOW((DBG_CONTEXT, L"[Listen] Process notifications received when not started. Ignoring event.\n",hr));
            continue;
        }

        StartStopLock.UnLock();

        DBGINFOW((DBG_CONTEXT, L"[Listen] Processing changes..\n"));
        pListener->ProcessChanges();
        DBGINFOW((DBG_CONTEXT, L"[Listen] Done Processing changes..\n"));

    } // end while

exit:

    if(NULL != pListener)
    {
        pListener->Release();
        pListener = NULL;
    }

    return;

} // CListenerController::Listen


/***************************************************************************++

Routine Description:

    Function creates the listener object and starts listening

Arguments:

    None.

Return Value:

    void

--***************************************************************************/
HRESULT CListenerController::CreateListener(CFileListener** o_pListener)
{
    HRESULT        hr        = S_OK;
    CFileListener* pListener = NULL;

    *o_pListener = NULL;

    //
    // Listener is always created on the heap because it is handed off to the
    // File advise object that makes aync calls.
    //

    pListener = new CFileListener();
    if(NULL == pListener)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    pListener->AddRef();

    hr = pListener->Init(this);
    if (FAILED(hr))
    {
        goto exit;
    }

    pListener->AddRef();
    *o_pListener = pListener;

exit:

    if(NULL != pListener)
    {
        pListener->Release();
        pListener = NULL;
    }

    return hr;

} // CListenerController::CreateListener


/***************************************************************************++

Routine Description:

    Returns the ListenerControler object.
    This object is a singleton, global object and hence it is necessary to
    take the g_LockMasterResource lock when calling this function, and any place
    where this object is used. Note that while we use new to create the object
    it is destroyed by calling release, because the object is ref-counted.
    It is ref-counted, because the listener object also holds a reference to
    it.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT InitializeListenerController()
{

    HRESULT hr = S_OK;

    if(NULL == g_pListenerController)
    {
        g_pListenerController = new CListenerController();

        if(NULL == g_pListenerController)
        {
            return E_OUTOFMEMORY;
        }

        g_pListenerController->AddRef();

        hr = g_pListenerController->Init();

        if(FAILED(hr))
        {
            g_pListenerController->Release();
            g_pListenerController = NULL;
            return hr;
        }

    }

    return hr;
}

/***************************************************************************++

Routine Description:

    Releases the global listener controller object.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT UnInitializeListenerController()
{

    HRESULT hr = S_OK;

    if(NULL != g_pListenerController)
    {
        g_pListenerController->Release();
        g_pListenerController = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\readschema.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ReadSchema.cpp

Abstract:

    Implementation of the helper functions that are used to read
    schema information from the config stuctures into the metabase.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/
#include "precomp.hxx"

DWORD GetMetabaseFlags(DWORD i_CatalogFlag)
{
    return i_CatalogFlag & 0x00000003;  // First two bits represent metabase flag property.
}


/***************************************************************************++

Routine Description:

    Reads the schema fromthe catalog into the schema tree.

Arguments:

    [in]  Storage pointer.
    [in]  Filetime pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadSchema(IIS_CRYPTO_STORAGE*      i_pStorage,
                   FILETIME*                i_pFileTime)
{
    HRESULT             hr                      = S_OK;
    CMDBaseObject*      pboReadSchema           = NULL;

    if(FAILED(hr))
    {
        goto exit;
    }


    hr = ReadMetaObject(pboReadSchema,
                        (LPWSTR)g_wszSlashSchema,
                        i_pFileTime,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = ReadSchemaProperties(pboReadSchema,
                              i_pStorage);

    if(FAILED(hr))
    {
        goto exit;

    }

    hr = ReadProperties(i_pStorage,
                        i_pFileTime);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = ReadClasses(i_pStorage,
                     i_pFileTime);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    return hr;

} // ReadSchema


/***************************************************************************++

Routine Description:

    Reads the properties in the root of the schema.

Arguments:

    [in]  Pointer to the metabase object.
    [in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadSchemaProperties(CMDBaseObject*           i_pboRead,
                             IIS_CRYPTO_STORAGE*      i_pStorage)
{
    HRESULT hr = S_OK;

    hr = ReadAdminACL(i_pboRead,
                      i_pStorage);

    if(FAILED(hr))
    {
        return hr;
    }

    hr = ReadLargestMetaID(i_pboRead,
                           i_pStorage);

    if(FAILED(hr))
    {
        return hr;
    }

    return hr;

} // ReadSchemaProperties


/***************************************************************************++

Routine Description:

    Construct the Admin ACL property

Arguments:

    [in]  Pointer to the metabase object.
    [in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadAdminACL(CMDBaseObject*       i_pboRead,
                     IIS_CRYPTO_STORAGE*  )
{
    BOOL                 b                    = FALSE;
    DWORD                dwLength             = 0;

    PSECURITY_DESCRIPTOR pSD                  = NULL;
    PSECURITY_DESCRIPTOR outpSD               = NULL;
    DWORD                cboutpSD             = 0;
    PACL                 pACLNew              = NULL;
    DWORD                cbACL                = 0;
    PSID                 pAdminsSID           = NULL;
    PSID                 pEveryoneSID         = NULL;
    BOOL                 bWellKnownSID        = FALSE;
    HRESULT              hr                   = S_OK;
    DWORD                dwRes                = 0;
    DWORD                dwMetaIDAdminACL     = MD_ADMIN_ACL;
    DWORD                dwAttributesAdminACL = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE;
    DWORD                dwUserTypeAdminACL   = IIS_MD_UT_SERVER;
    DWORD                dwDataTypeAdminACL   = BINARY_METADATA;

    LPVOID      a_pv[cMBProperty_NumberOfColumns];
    ULONG       a_Size[cMBProperty_NumberOfColumns];

    //
    // Initialize a new security descriptor
    //

    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
                                            SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!pSD)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    InitializeSecurityDescriptor(pSD,
                                 SECURITY_DESCRIPTOR_REVISION);
    //
    // Get Local Admins Sid
    //

    dwRes = GetPrincipalSID (L"Administrators",
                             &pAdminsSID,
                             &bWellKnownSID);

    if(ERROR_SUCCESS != dwRes)
    {
        hr = HRESULT_FROM_WIN32(dwRes);
        goto exit;
    }

    //
    // Get everyone Sid
    //

    GetPrincipalSID (L"Everyone", &pEveryoneSID, &bWellKnownSID);

    //
    // Initialize a new ACL, which only contains 2 aaace
    //

    cbACL = sizeof(ACL) +
            (sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
           (sizeof(ACCESS_ALLOWED_ACE) +
           GetLengthSid(pEveryoneSID) - sizeof(DWORD));

    pACLNew = (PACL) LocalAlloc(LPTR,
                                cbACL);

    if (!pACLNew)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    InitializeAcl(pACLNew,
                  cbACL,
                  ACL_REVISION);

    AddAccessAllowedAce(pACLNew,
                        ACL_REVISION,
                        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                        pAdminsSID);

    AddAccessAllowedAce(pACLNew,
                        ACL_REVISION,
                        FILE_GENERIC_READ,
                        pEveryoneSID);

    //
    // Add the ACL to the security descriptor
    //

    b = SetSecurityDescriptorDacl(pSD,
                                  TRUE,
                                  pACLNew,
                                  FALSE);

    if(!b)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto exit;
    }

    b = SetSecurityDescriptorOwner(pSD,
                                   pAdminsSID,
                                   TRUE);

    if(!b)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto exit;
    }

    b = SetSecurityDescriptorGroup(pSD,
                                   pAdminsSID,
                                   TRUE);

    if(!b)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto exit;
    }

    //
    // Security descriptor blob must be self relative
    //

    b = MakeSelfRelativeSD(pSD,
                           outpSD,
                           &cboutpSD);

    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR,
                                               cboutpSD);

    if (!outpSD)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    b = MakeSelfRelativeSD(pSD,
                           outpSD,
                           &cboutpSD);

    if(!b)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto exit;
    }

    //
    // below this modify pSD to outpSD
    //

    //
    // Apply the new security descriptor to the file
    //

    dwLength = GetSecurityDescriptorLength(outpSD);

    //
    // Apply the new security descriptor to the file
    //
    //
    // Read all the property names. If the property is a flag, then read
    // all the flag names as well.
    //

    a_pv[iMBProperty_Name]        = NULL;
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchema;
    a_pv[iMBProperty_ID]          = &dwMetaIDAdminACL;
    a_pv[iMBProperty_Attributes]  = &dwAttributesAdminACL;
    a_pv[iMBProperty_UserType]    = &dwUserTypeAdminACL;
    a_pv[iMBProperty_Type]        = &dwDataTypeAdminACL;
    a_pv[iMBProperty_Value]       = (LPBYTE)outpSD;

    a_Size[iMBProperty_Value]     = dwLength;

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        NULL,           // We should not be passing crypto object here, if we do it will attempt to decrypt it because the attribute is sucure.
                        TRUE);


exit :

    //
    //Cleanup:
    // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
    //

    if (outpSD)
        GlobalFree(outpSD);

    if (pAdminsSID)
        FreeSid(pAdminsSID);
    if (pEveryoneSID)
        FreeSid(pEveryoneSID);
    if (pSD)
        LocalFree((HLOCAL) pSD);
    if (pACLNew)
        LocalFree((HLOCAL) pACLNew);

    return (hr);
}


/***************************************************************************++

Routine Description:

    Helper function to read construct the Admin ACL.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/
DWORD GetPrincipalSID (LPWSTR Principal,
                       PSID *Sid,
                       BOOL *pbWellKnownSID)
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority = NULL;
    BYTE Count = 0;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    if ( wcscmp(Principal,L"Administrators") == 0 )
    {
        //
        // Administrators group
        //

        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;

    }
    else if ( wcscmp(Principal,L"System") == 0)
    {
        //
        // SYSTEM
        //

        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;

    }
    else if ( wcscmp(Principal,L"Interactive") == 0)
    {
        //
        // INTERACTIVE
        //

        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;

    }
    else if ( wcscmp(Principal,L"Everyone") == 0)
    {
        //
        // Everyone
        //

        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;

    }
    else
    {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID)
    {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                    dwRID[0],
                                    dwRID[1],
                                    dwRID[2],
                                    dwRID[3],
                                    dwRID[4],
                                    dwRID[5],
                                    dwRID[6],
                                    dwRID[7],
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        WCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountNameW(NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if(NULL == *Sid)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (!LookupAccountNameW(NULL,
                                     Principal,
                                     *Sid,
                                     &sidSize,
                                     refDomain,
                                     &refDomainSize,
                                     &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Reads the largest metabase id available so far from the schema.

Arguments:

    [in]  Pointer to the metabase object.
    [in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadLargestMetaID(CMDBaseObject*             i_pboRead,
                          IIS_CRYPTO_STORAGE*        i_pStorage)
{
    HRESULT             hr                  = S_OK;
    DWORD*              pdwLargestID        = NULL;
    DWORD               dwLargestIDDefault  = IIS_MD_ADSI_METAID_BEGIN;

    DWORD               dwMetaIDMetaID      = MD_SCHEMA_METAID;
    DWORD               dwAttributesMetaID  = METADATA_NO_ATTRIBUTES;
    DWORD               dwUserTypeMetaID    = IIS_MD_UT_SERVER;
    DWORD               dwDataTypeMetaID    = DWORD_METADATA;
    ULONG               iCol                = iTABLEMETA_ExtendedVersion;  // Largest ID is stored in this column
    ULONG               iRow                = 0;
    LPWSTR              wszTable            = wszTABLE_IIsConfigObject;

    LPVOID              a_pv[cMBProperty_NumberOfColumns];
    ULONG               a_Size[cMBProperty_NumberOfColumns];

    hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetRowIndexByIdentity(NULL,
                                                                                     (LPVOID*)&wszTable,
                                                                                     &iRow);

    if(SUCCEEDED(hr))
    {
        hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetColumnValues(iRow,
                                                                                   1,
                                                                                   &iCol,
                                                                                   NULL,
                                                                                   (LPVOID*)&pdwLargestID);
    }

    if(FAILED(hr))
    {

        DBGINFOW((DBG_CONTEXT,
                  L"[SetLargestMetaID] Unable to read largest meta id from the meta tables. GetColumnValues failed with hr = 0x%x. Will default it to %d.\n",
                  hr,
                  dwLargestIDDefault));

        hr = S_OK;

        pdwLargestID = &dwLargestIDDefault;
    }

    a_pv[iMBProperty_Name]        = NULL;
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchema;
    a_pv[iMBProperty_ID]          = &dwMetaIDMetaID;
    a_pv[iMBProperty_Attributes]  = &dwAttributesMetaID;
    a_pv[iMBProperty_UserType]    = &dwUserTypeMetaID;
    a_pv[iMBProperty_Type]        = &dwDataTypeMetaID;
    a_pv[iMBProperty_Value]       = (LPBYTE)pdwLargestID;

    a_Size[iMBProperty_Value]     = sizeof(DWORD);

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);


    return hr;

}


/***************************************************************************++

Routine Description:

    Reads the properties into the schema tree.

Arguments:

    [in]  Pointer to the metabase object.
    [in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadProperties(IIS_CRYPTO_STORAGE*      i_pStorage,
                       FILETIME*                i_pFileTime)
{
    HRESULT             hr                  = S_OK;
    CMDBaseObject*      pboReadProperties   = NULL;
    CMDBaseObject*      pboReadNames        = NULL;
    CMDBaseObject*      pboReadTypes        = NULL;
    CMDBaseObject*      pboReadDefaults     = NULL;
    ULONG               i                   = 0;
    ULONG               iColIndex           = 0;
    LPVOID              a_Identity[]        = {(LPVOID)g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject,
                                               (LPVOID)&iColIndex
    };
    LPWSTR              wszTable            = NULL;
    LPVOID              a_pv[cCOLUMNMETA_NumberOfColumns];
    ULONG               a_Size[cCOLUMNMETA_NumberOfColumns];
    ULONG               a_iCol[] = {iCOLUMNMETA_Table,
                                    iCOLUMNMETA_Index,
                                    iCOLUMNMETA_InternalName,
                                    iCOLUMNMETA_Type,
                                    iCOLUMNMETA_MetaFlags,
                                    iCOLUMNMETA_SchemaGeneratorFlags,
                                    iCOLUMNMETA_DefaultValue,
                                    iCOLUMNMETA_StartingNumber,
                                    iCOLUMNMETA_EndingNumber,
                                    iCOLUMNMETA_ID,
                                    iCOLUMNMETA_UserType,
                                    iCOLUMNMETA_Attributes
                                    };
    ULONG               cCol = sizeof(a_iCol)/sizeof(ULONG);

    //
    // Initialize all the meta objects.
    //

    hr = ReadMetaObject(pboReadProperties,
                        (LPWSTR)g_wszSlashSchemaSlashProperties,
                        i_pFileTime,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = ReadMetaObject(pboReadNames,
                        (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashNames,
                        i_pFileTime,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = ReadMetaObject(pboReadTypes,
                        (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashTypes,
                        i_pFileTime,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = ReadMetaObject(pboReadDefaults,
                        (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashDefaults,
                        i_pFileTime,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Get the row index of the first column and then iterate thru the table until
    // e_st_nomorerows or the table difffers
    //

    hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
                                                                     a_Identity,
                                                                     &i);

    if(FAILED(hr))
    {
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
        }
        goto exit;
    }

    //
    // For each property in this table, construct the name, type and default
    // in the metabase tree
    //

    for(;;i++)
    {
        hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(i,
                                                                   cCol,
                                                                   a_iCol,
                                                                   a_Size,
                                                                   a_pv);


        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }

        if(NULL == wszTable)
        {
            wszTable = (LPWSTR)a_pv[iCOLUMNMETA_Table];
        }

        if(wszTable != (LPWSTR)a_pv[iCOLUMNMETA_Table])
        {
            //
            // reached another table break
            //
            break;
        }

        MD_ASSERT(NULL != (DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]);

        if(fCOLUMNMETA_HIDDEN == (fCOLUMNMETA_HIDDEN & (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags])))
        {
            //
            // Do not read hidden properties. All these properties have the
            // "HIDDEN" schemagenerator flag set on them.
            //
            continue;
        }

        hr = ReadPropertyNames(pboReadNames,
                               a_pv,
                               a_Size,
                               i_pStorage);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = ReadPropertyTypes(pboReadTypes,
                               a_pv,
                               a_Size,
                               i_pStorage);

        if(FAILED(hr))
        {
            goto exit;
        }

        if((*(DWORD*)a_pv[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_FLAG)
        {
            hr = ReadAllFlags(i_pStorage,
                              pboReadTypes,
                              pboReadNames,
                              pboReadDefaults,
                              *(DWORD*)a_pv[iCOLUMNMETA_Index],
                              *(DWORD*)a_pv[iCOLUMNMETA_ID],
                              GetMetabaseFlags(*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]),
                              *(DWORD*)a_pv[iCOLUMNMETA_Attributes],
                              *(DWORD*)a_pv[iCOLUMNMETA_UserType],
                              (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]) & fCOLUMNMETA_MULTISTRING);

            if(FAILED(hr))
            {
                goto exit;
            }
        }

        hr = ReadPropertyDefaults(pboReadDefaults,
                                  a_pv,
                                  a_Size,
                                  i_pStorage);

        if(FAILED(hr))
        {
            goto exit;
        }

    }


exit:

    return hr;

} // ReadProperties


/***************************************************************************++

Routine Description:

    Reads names of properties into the schema.

Arguments:

    [in]  Pointer to the metabase object.
    [in]  Array that hold catalog schema information about the property.
    [in]  Array that holds count of bytes for the above.
    [in]  Storage pointer.


Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadPropertyNames(CMDBaseObject*            i_pboRead,
                          LPVOID*                   i_apv,
                          ULONG*                    i_aSize,
                          IIS_CRYPTO_STORAGE*       i_pStorage)
{
    HRESULT     hr           = S_OK;
    LPVOID      a_pv[cMBProperty_NumberOfColumns];
    ULONG       a_Size[cMBProperty_NumberOfColumns];
    DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
    DWORD       dwType       = STRING_METADATA;
    DWORD       dwUserType   = IIS_MD_UT_SERVER;

    //
    // Read all the property names. If the property is a flag, then read
    // all the flag names as well.
    //

    a_pv[iMBProperty_Name]        = i_apv[iCOLUMNMETA_InternalName];
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashNames;
    a_pv[iMBProperty_ID]          = i_apv[iCOLUMNMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = i_apv[iCOLUMNMETA_InternalName];

    a_Size[iMBProperty_Value]     = i_aSize[iCOLUMNMETA_InternalName];

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);


    return hr;

} // ReadPropertyNames


/***************************************************************************++

Routine Description:

    Reads names of flags into the schema.

Arguments:

    [in]  Pointer to the metabase object.
    [in]  Array that hold catalog schema information about the flags.
    [in]  Array that holds count of bytes for the above.
    [in]  Storage pointer.


Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadFlagNames(CMDBaseObject*            i_pboRead,
                      LPVOID*                   i_apv,
                      ULONG*                    i_aSize,
                      IIS_CRYPTO_STORAGE*       i_pStorage)
{
    HRESULT     hr           = S_OK;
    LPVOID      a_pv[cMBProperty_NumberOfColumns];
    ULONG       a_Size[cMBProperty_NumberOfColumns];
    DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
    DWORD       dwType       = STRING_METADATA;
    DWORD       dwUserType   = IIS_MD_UT_SERVER;

    //
    // Read all the property names. If the property is a flag, then read
    // all the flag names as well.
    //

    a_pv[iMBProperty_Name]        = i_apv[iTAGMETA_InternalName];
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashNames;
    a_pv[iMBProperty_ID]          = i_apv[iTAGMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = i_apv[iTAGMETA_InternalName];

    a_Size[iMBProperty_Value]     = i_aSize[iTAGMETA_InternalName];

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    return hr;

} // ReadFlagNames


/***************************************************************************++

Routine Description:

    Reads type information about the properties into the schema.

Arguments:

    [in]  Pointer to the metabase object.
    [in]  Array that hold catalog schema information about the property.
    [in]  Array that holds count of bytes for the above.
    [in]  Storage pointer.


Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadPropertyTypes(CMDBaseObject*            i_pboRead,
                          LPVOID*                   i_apv,
                          ULONG*                    ,
                          IIS_CRYPTO_STORAGE*       i_pStorage)
{
    HRESULT     hr           = S_OK;
    LPVOID      a_pv[cMBProperty_NumberOfColumns];
    ULONG       a_Size[cMBProperty_NumberOfColumns];
    DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
    DWORD       dwType       = BINARY_METADATA;
    DWORD       dwUserType   = IIS_MD_UT_SERVER;
    PropValue   propVal;
    DWORD       dwMetaFlagsEx = *(DWORD*)(i_apv[iCOLUMNMETA_SchemaGeneratorFlags]);

    memset(&propVal, 0, sizeof(PropValue));

    //
    // Read all the property type. If the property is a flag, then read
    // all the type for the flag names as well.
    //

    propVal.dwMetaID          = *(DWORD*)(i_apv[iCOLUMNMETA_ID]);
    propVal.dwPropID          = *(DWORD*)(i_apv[iCOLUMNMETA_ID]);                       // Note: This is different from the meta id if it is a flag.
    propVal.dwSynID           = SynIDFromMetaFlagsEx(dwMetaFlagsEx);
    propVal.dwMetaType        = GetMetabaseType(*(DWORD*)(i_apv[iCOLUMNMETA_Type]),
                                                *(DWORD*)(i_apv[iCOLUMNMETA_MetaFlags]));

    if(DWORD_METADATA == propVal.dwMetaType)
    {
        propVal.dwMinRange        = *(DWORD*)(i_apv[iCOLUMNMETA_StartingNumber]);
        propVal.dwMaxRange        = *(DWORD*)(i_apv[iCOLUMNMETA_EndingNumber]);
    }
    else
    {
        //
        // Ensure that non-DWORDs have no starting/ending numbers
        //

        propVal.dwMinRange        = 0;
        propVal.dwMaxRange        = 0;
    }

    propVal.dwFlags           = GetMetabaseFlags(*(DWORD*)i_apv[iCOLUMNMETA_SchemaGeneratorFlags]);
    propVal.dwMask            = 0;                                                      // This gets filled in for flag values only.
    propVal.dwMetaFlags       = *(DWORD*)(i_apv[iCOLUMNMETA_Attributes]);
    propVal.dwUserGroup       = *(DWORD*)(i_apv[iCOLUMNMETA_UserType]);
    propVal.fMultiValued      = ((*(DWORD*)i_apv[iCOLUMNMETA_MetaFlags])&fCOLUMNMETA_MULTISTRING)?1:0;  // Ensure that this gets set in the schema as multivalued
    propVal.dwDefault         = 0;
    propVal.szDefault         = NULL;

    a_pv[iMBProperty_Name]        = i_apv[iCOLUMNMETA_InternalName];
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashTypes;
    a_pv[iMBProperty_ID]          = i_apv[iCOLUMNMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = (LPVOID)&propVal;

    a_Size[iMBProperty_Value]     = sizeof(PropValue);

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    return hr;

} // ReadPropertyTypes


/***************************************************************************++

Routine Description:

    Reads all flag properties into the schema.

Arguments:

    [in]  Storage pointer.
    [in]  Pointer to the metabase object that holds the types tree.
    [in]  Pointer to the metabase object that holds the names tree.
    [in]  Pointer to the metabase object that holds the default value tree.
    [in]  Column index of the parent flag property.
    [in]  Meta Id of the parent flag property.
    [in]  Flags of the parent flag property.
    [in]  Attribute of the parent flag property.
    [in]  Usertype of the parent flag property.
    [in]  Multivalued attribute of the parent flag property.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadAllFlags(IIS_CRYPTO_STORAGE*        i_pStorage,
                     CMDBaseObject*             i_pboReadType,
                     CMDBaseObject*             i_pboReadName,
                     CMDBaseObject*             i_pboReadDefault,
                     DWORD                      i_dwColumnIndex,
                     DWORD                      i_dwMetaID,
                     DWORD                      i_dwFlags,
                     DWORD                      i_dwAttributes,
                     DWORD                      i_dwUserType,
                     DWORD                      i_dwMultivalued)
{
    ULONG       i                = 0;
    ULONG       iStartRow        = 0;
    HRESULT     hr               = S_OK;
    LPVOID      a_pvSearch[cTAGMETA_NumberOfColumns];
    ULONG       aColSearch[]     = {iTAGMETA_Table,
                                    iTAGMETA_ColumnIndex
                                    };
    ULONG       cColSearch       = sizeof(aColSearch)/sizeof(ULONG);
    LPWSTR      wszTable         = NULL;


    a_pvSearch[iTAGMETA_Table] = g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject;
    a_pvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&i_dwColumnIndex;

    hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(iStartRow,
                                                                                     cColSearch,
                                                                                     aColSearch,
                                                                                     NULL,
                                                                                     a_pvSearch,
                                                                                     &iStartRow);

    if(E_ST_NOMOREROWS == hr)
    {
        hr = S_OK;
        goto exit;
    }
    else if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllFlags] Unable to read flags. GetRowIndexBySearch failed with hr = 0x%x.\n",
                  hr));
        goto exit;
    }


    for(i=iStartRow;;i++)
    {

        LPVOID  a_pv[cTAGMETA_NumberOfColumns];
        ULONG   a_Size[cTAGMETA_NumberOfColumns];
        ULONG   a_iCol[] = {iTAGMETA_Table,
                            iTAGMETA_ColumnIndex,
                            iTAGMETA_InternalName,
                            iTAGMETA_Value,
                            iTAGMETA_ID
                            };
        ULONG   cCol = sizeof(a_iCol)/sizeof(ULONG);

        hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetColumnValues(i,
                                                                                     cCol,
                                                                                     a_iCol,
                                                                                     a_Size,
                                                                                     a_pv);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }

        if(NULL == wszTable)
        {
            // Save the table name from the read cache so that you can do a pointer compare below.
            wszTable = (LPWSTR)a_pv[iTAGMETA_Table];
        }

        if((wszTable != a_pv[iTAGMETA_Table]) ||
            (i_dwColumnIndex != *(DWORD*)a_pv[iTAGMETA_ColumnIndex])
          )
        {
            //
            // Done with all tags of this column, in this table hence exit.
            //

            goto exit;

        }

        hr = ReadFlagTypes(i_pboReadType,
                           i_pStorage,
                           i_dwMetaID,
                           i_dwFlags,
                           i_dwAttributes,
                           i_dwUserType,
                           i_dwMultivalued,
                           a_pv,
                           a_Size);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = ReadFlagNames(i_pboReadName,
                           a_pv,
                           a_Size,
                           i_pStorage);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = ReadFlagDefaults(i_pboReadDefault,
                              a_pv,
                              a_Size,
                              i_pStorage);

        if(FAILED(hr))
        {
            goto exit;
        }

    }

exit:

    return hr;

} // ReadAllFlagTypes

#define     IIS_SYNTAX_ID_BOOL_BITMASK  7

/***************************************************************************++

Routine Description:

    Reads all flag type information into the schema.

Arguments:

    [in]  Pointer to the metabase object that holds the types tree.
    [in]  Storage pointer.
    [in]  Meta Id of the parent flag property.
    [in]  Flags of the parent flag property.
    [in]  Attribute of the parent flag property.
    [in]  Usertype of the parent flag property.
    [in]  Multivalued attribute of the parent flag property.
    [in]  Array that hold catalog schema information about the flag.
    [in]  Array that holds count of bytes for the above.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadFlagTypes(CMDBaseObject*            i_pboRead,
                      IIS_CRYPTO_STORAGE*       i_pStorage,
                      DWORD                     i_dwMetaID,
                      DWORD                     i_dwFlags,
                      DWORD                     i_dwAttributes,
                      DWORD                     i_dwUserType,
                      DWORD                     i_dwMultivalued,
                      LPVOID*                   i_apv,
                      ULONG*                    )
{
    HRESULT     hr           = S_OK;
    LPVOID      a_pv[cMBProperty_NumberOfColumns];
    ULONG       a_Size[cMBProperty_NumberOfColumns];
    DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
    DWORD       dwType       = BINARY_METADATA;
    DWORD       dwUserType   = IIS_MD_UT_SERVER;
    PropValue   propVal;
    DWORD       dwFlagSynID  = IIS_SYNTAX_ID_BOOL_BITMASK;
    DWORD       dwFlagType   = DWORD_METADATA;

    memset(&propVal, 0, sizeof(PropValue));

    //
    // Read all the property type. If the property is a flag, then read
    // all the type for the flag names as well.
    //

    propVal.dwMetaID          = i_dwMetaID;
    propVal.dwPropID          = *(DWORD*)(i_apv[iTAGMETA_ID]);                  // This is different from the meta id if it is a flag.
    propVal.dwSynID           = dwFlagSynID;
    propVal.dwMetaType        = dwFlagType;

    propVal.dwMaxRange        = 0;
    propVal.dwMinRange        = 0;

    propVal.dwFlags           = i_dwFlags;                                      // Set to parent prop flags
    propVal.dwMask            = *(DWORD*)(i_apv[iTAGMETA_Value]);               // Set to parent prop flags
    propVal.dwMetaFlags       = i_dwAttributes;                                 // Set to parent prop flags
    propVal.dwUserGroup       = i_dwUserType;                                   // Set to parent prop flags
    propVal.fMultiValued      = i_dwMultivalued;                                // Set to parent prop flags
    propVal.dwDefault         = 0;
    propVal.szDefault         = NULL;

    a_pv[iMBProperty_Name]        = NULL;
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashTypes;
    a_pv[iMBProperty_ID]          = i_apv[iTAGMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = (LPVOID)&propVal;

    a_Size[iMBProperty_Value]     = sizeof(PropValue);

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    return hr;

} // ReadFlagTypes


/***************************************************************************++

Routine Description:

    Reads property defaults into the schema.

Arguments:

    [in]  Pointer to the metabase object that holds property defaults.
    [in]  Array that hold catalog schema information about the property.
    [in]  Array that holds count of bytes for the above.
    [in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadPropertyDefaults(CMDBaseObject*         i_pboRead,
                             LPVOID*                i_apv,
                             ULONG*                 i_aSize,
                             IIS_CRYPTO_STORAGE*    i_pStorage)
{
    HRESULT     hr           = S_OK;
    LPVOID      a_pv[cMBProperty_NumberOfColumns];
    ULONG       a_Size[cMBProperty_NumberOfColumns];
    DWORD       dwType       = GetMetabaseType(*(DWORD*)i_apv[iCOLUMNMETA_Type],
                                               *(DWORD*)i_apv[iCOLUMNMETA_MetaFlags]);
    LPVOID      pvValue      = NULL;
    ULONG       cbSize       = NULL;
    DWORD       dwZero       = 0;
    DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;

    //
    // Read all the property names. If the property is a flag, then read
    // all the flag names as well.
    //

    a_pv[iMBProperty_Name]        = i_apv[iCOLUMNMETA_InternalName];
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashDefaults;
    a_pv[iMBProperty_ID]          = i_apv[iCOLUMNMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;                  //  NO_ATTRIBUTES since it will attempt to decrypt.
    a_pv[iMBProperty_UserType]    = i_apv[iCOLUMNMETA_UserType];
    a_pv[iMBProperty_Type]        = &dwType;

    if((dwType == DWORD_METADATA) && (NULL == i_apv[iCOLUMNMETA_DefaultValue]))
    {
        pvValue = &dwZero;
        cbSize = sizeof(DWORD);
    }
    else if(((dwType == MULTISZ_METADATA) || (dwType == STRING_METADATA) || (dwType == EXPANDSZ_METADATA)) &&
            ((NULL == i_apv[iCOLUMNMETA_DefaultValue]) || (0 == *(BYTE*)(i_apv[iCOLUMNMETA_DefaultValue])))
           )
    {
        if(dwType == MULTISZ_METADATA)
        {
            pvValue = g_wszEmptyMultisz;                   // Two nulls.
            cbSize = g_cchEmptyMultisz * sizeof(WCHAR);
        }
        else if((dwType == STRING_METADATA) || (dwType == EXPANDSZ_METADATA))
        {
            pvValue = g_wszEmptyWsz;
            cbSize = g_cchEmptyWsz * sizeof(WCHAR);       // One null.
        }
    }
    else
    {
        pvValue    = i_apv[iCOLUMNMETA_DefaultValue];
        cbSize     = i_aSize[iCOLUMNMETA_DefaultValue];
    }

    a_pv[iMBProperty_Value]       = pvValue;
    a_Size[iMBProperty_Value]     = cbSize;

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadPropertyDefaults] Could not read property %s:%d.\npv=%d.\ncb=%d.\n",
                  i_apv[iCOLUMNMETA_InternalName],
                  *(DWORD*)i_apv[iCOLUMNMETA_ID],
                  pvValue,
                  cbSize));

        if(NULL != pvValue)
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReadPropertyDefaults]*pv=%d.\n",
                      *(WORD*)pvValue));

        }
    }

    return hr;

} // ReadPropertyDefaults


/***************************************************************************++

Routine Description:

    Reads all flag defaults into the schema.

Arguments:

    [in]  Pointer to the metabase object that holds the defaults.
    [in]  Array that hold catalog schema information about the flag.
    [in]  Array that holds count of bytes for the above.
    [in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadFlagDefaults(CMDBaseObject*         i_pboRead,
                         LPVOID*                i_apv,
                         ULONG*                 ,
                         IIS_CRYPTO_STORAGE*    i_pStorage)
{
    HRESULT     hr           = S_OK;
    LPVOID      a_pv[cMBProperty_NumberOfColumns];
    ULONG       a_Size[cMBProperty_NumberOfColumns];
    DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
    DWORD       dwType       = DWORD_METADATA;
    DWORD       dwUserType   = IIS_MD_UT_SERVER;

    //
    // TODO: Is this a correct assumption? I noticed that default values for
    // flags was being set to 0 or -1. This doesnt make any sense. How can a
    // flag have a default value other than its own value? This is not
    //captured in our new schema, so just putting it as 0.
    //

    DWORD       dwFlagDefaults = 0;

    //
    // Read all the property names. If the property is a flag, then read
    // all the flag names as well.
    //

    a_pv[iMBProperty_Name]        = i_apv[iTAGMETA_InternalName];
    a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashDefaults;
    a_pv[iMBProperty_ID]          = i_apv[iTAGMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = &dwFlagDefaults;

    a_Size[iMBProperty_Value]     = sizeof(DWORD);

    hr = ReadDataObject(i_pboRead,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    return hr;

} // ReadFlagDefaults


/***************************************************************************++

Routine Description:

    Reads all classes into the schema.

Arguments:

    [in]  Storage pointer.
    [in]  Filetime pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadClasses(IIS_CRYPTO_STORAGE*     i_pStorage,
                    FILETIME*               i_pFileTime)
{
    HRESULT             hr              = S_OK;
    CMDBaseObject*      pboReadClasses  = NULL;
    ULONG               i               = 0;
    LPVOID              a_pv[cTABLEMETA_NumberOfColumns];
    ULONG               a_Size[cTABLEMETA_NumberOfColumns];
    ULONG               a_iCol[]        = {iTABLEMETA_InternalName,
                                           iTABLEMETA_MetaFlags,
                                           iTABLEMETA_SchemaGeneratorFlags,
                                           iTABLEMETA_ContainerClassList
    };
    ULONG               cCol = sizeof(a_iCol)/sizeof(ULONG);

    hr = ReadMetaObject(pboReadClasses,
                        (LPWSTR)g_wszSlashSchemaSlashClasses,
                        i_pFileTime,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    for(i=0;;i++)
    {
        hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetColumnValues(i,
                                                                                   cCol,
                                                                                   a_iCol,
                                                                                   a_Size,
                                                                                   a_pv);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }

        MD_ASSERT(NULL != (DWORD*)a_pv[iTABLEMETA_MetaFlags]);

        if(fTABLEMETA_HIDDEN == (fTABLEMETA_HIDDEN & (*(DWORD*)a_pv[iTABLEMETA_MetaFlags])))
        {
            //
            // Do not read hidden classes. All these classes have the "HIDDEN" MetaFlag set on them.
            // Eg: IIsConfigObject,MetabaseBaseClass, MBProperty, MBPropertyDiff, IIsInheritedProperties
            //
            continue;
        }

        hr = ReadClass(a_pv,
                       a_Size,
                       i_pStorage,
                       i_pFileTime);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReadClasses] Could not read information for class: %s.\nReadClass failed with hr=0x%x.\n",
                      a_pv[iTABLEMETA_InternalName],
                      hr));
        }

    }

exit:

    return hr;

} // ReadClasses


/***************************************************************************++

Routine Description:

    Reads a class into the schema.

Arguments:

    [in]  Array that hold catalog schema information about the class.
    [in]  Array that holds count of bytes for the above.
    [in]  Storage pointer.
    [in]  Filetime pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadClass(LPVOID*                   i_apv,
                  ULONG*                    ,
                  IIS_CRYPTO_STORAGE*       i_pStorage,
                  FILETIME*                 i_pFileTime)
{
    HRESULT             hr              = S_OK;
    CMDBaseObject*      pboReadClass    = NULL;
    WCHAR               wszClassPathFixed[MAX_PATH];
    ULONG               cchClassPath    = 0;
    WCHAR*              wszClassPath    = wszClassPathFixed;
    WCHAR*              wszEnd          = NULL;
    ULONG               cchClassName    = (ULONG)wcslen((LPWSTR)i_apv[iTABLEMETA_InternalName]);
    DWORD               dwID            = 0;
    DWORD               dwType          = DWORD_METADATA;
    DWORD               dwUserType      = IIS_MD_UT_SERVER;
    DWORD               dwAttributes    = METADATA_NO_ATTRIBUTES;
    DWORD               dwValue         = 0;
    LPVOID              a_pv[cMBProperty_NumberOfColumns];
    ULONG               a_Size[cMBProperty_NumberOfColumns];
    LPWSTR              wszManditory    = NULL;
    LPWSTR              wszOptional     = NULL;

    //
    // Construct the ClassPath and read the meta object.
    //

    cchClassPath = g_cchSlashSchemaSlashClasses +
                   g_cchSlash                  +
                   cchClassName;

    if((cchClassPath + 1) > MAX_PATH)
    {
        wszClassPath = new WCHAR[cchClassPath + 1];
        if(NULL == wszClassPath)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    wszEnd = wszClassPath;
    memcpy(wszEnd, g_wszSlashSchemaSlashClasses, g_cchSlashSchemaSlashClasses*sizeof(WCHAR));
    wszEnd = wszEnd + g_cchSlashSchemaSlashClasses;
    memcpy(wszEnd, g_wszSlash, g_cchSlash*sizeof(WCHAR));
    wszEnd = wszEnd + g_cchSlash;
    memcpy(wszEnd, i_apv[iTABLEMETA_InternalName], cchClassName*sizeof(WCHAR));
    wszEnd = wszEnd + cchClassName;
    *wszEnd = L'\0';

    hr = ReadMetaObject(pboReadClass,
                        wszClassPath,
                        i_pFileTime,
                        TRUE);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadClasses] ReadMetaObject for class: %s failed with hr=0x%x.\n",
                  wszClassPath,
                  hr));
        goto exit;
    }

    //
    // Initialize a_pv to write data objects
    //

    a_pv[iMBProperty_Name]              = NULL;
    a_pv[iMBProperty_ID]                = &dwID;
    a_pv[iMBProperty_Location]          = wszClassPath;
    a_pv[iMBProperty_Attributes]        = &dwAttributes;
    a_pv[iMBProperty_UserType]          = &dwUserType;
    a_pv[iMBProperty_Type]              = &dwType;

    //
    // Read the data object that corresponds to container class property
    //

    dwID                        = MD_SCHEMA_CLASS_CONTAINER;
    dwType                      = DWORD_METADATA;
    dwValue                     = ((*(DWORD*)(i_apv[iTABLEMETA_SchemaGeneratorFlags])) & fTABLEMETA_CONTAINERCLASS)?1:0; // Need to set true or false.
    a_pv[iMBProperty_Value]     = &dwValue;
    a_Size[iMBProperty_Value]   = sizeof(DWORD);

    hr = ReadDataObject(pboReadClass,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadClasses] ReadDataObject for class: %s, property: Container failed with hr=0x%x.\n",
                  wszClassPath,
                  hr));
        goto exit;
    }

    //
    // Read the data object that corresponds to container class list property
    //

    dwID                        = MD_SCHEMA_CLASS_CONTAINMENT;
    dwType                      = STRING_METADATA;

    if(NULL == i_apv[iTABLEMETA_ContainerClassList])
    {
        a_pv[iMBProperty_Value]     = g_wszEmptyWsz;
        a_Size[iMBProperty_Value]   = (g_cchEmptyWsz)*sizeof(WCHAR);
    }
    else
    {
        a_pv[iMBProperty_Value]     = i_apv[iTABLEMETA_ContainerClassList];
        a_Size[iMBProperty_Value]   = (ULONG)(wcslen((LPWSTR)i_apv[iTABLEMETA_ContainerClassList])+1)*sizeof(WCHAR);
    }

    hr = ReadDataObject(pboReadClass,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Read properties for this class.
    //

    hr = GetProperties((LPCWSTR)i_apv[iTABLEMETA_InternalName],
                       &wszOptional,
                       &wszManditory);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Read data object that corresponds to optional property list
    //

    dwID                        = MD_SCHEMA_CLASS_OPT_PROPERTIES;
    dwType                      = STRING_METADATA;

    if(NULL == wszOptional)
    {
        a_pv[iMBProperty_Value]     = g_wszEmptyWsz;
        a_Size[iMBProperty_Value]   = (g_cchEmptyWsz)*sizeof(WCHAR);
    }
    else
    {
        a_pv[iMBProperty_Value]     = wszOptional;
        a_Size[iMBProperty_Value]   = (ULONG)(wcslen(wszOptional)+1)*sizeof(WCHAR);
    }

//  DBGINFOW((DBG_CONTEXT,
//            L"[ReadClasses] Class: %s has Optional Properties: %s.\n",
//            wszClassPath,
//            a_pv[iMBProperty_Value]));

    hr = ReadDataObject(pboReadClass,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Read data object that corresponds to maditory property list
    //

    dwID                        = MD_SCHEMA_CLASS_MAND_PROPERTIES;
    dwType                      = STRING_METADATA;

    if(NULL == wszManditory)
    {
        a_pv[iMBProperty_Value]     = g_wszEmptyWsz;
        a_Size[iMBProperty_Value]   = (g_cchEmptyWsz)*sizeof(WCHAR);
    }
    else
    {
        a_pv[iMBProperty_Value]     = wszManditory;
        a_Size[iMBProperty_Value]   = (ULONG)(wcslen(wszManditory)+1)*sizeof(WCHAR);
    }


//  DBGINFOW((DBG_CONTEXT,
//            L"[ReadClasses] Class: %s has Manditory Properties: %s.\n",
//            wszClassPath,
//            a_pv[iMBProperty_Value]));

    hr = ReadDataObject(pboReadClass,
                        a_pv,
                        a_Size,
                        i_pStorage,
                        TRUE);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(wszClassPathFixed != wszClassPath)
    {
        delete [] wszClassPath;
        wszClassPath = NULL;
    }

    if(NULL != wszManditory)
    {
        delete [] wszManditory;
        wszManditory = NULL;
    }

    if(NULL != wszOptional)
    {
        delete [] wszOptional;
        wszOptional = NULL;
    }

    return hr;

} // ReadClasses


/***************************************************************************++

Routine Description:

    Given a class it constructs the optional and manditory property lists

Arguments:

    [in]  Class name.
    [out] Optional properties.
    [out] Manditory properties.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetProperties(LPCWSTR                   i_wszTable,
                      LPWSTR*                   o_pwszOptional,
                      LPWSTR*                   o_pwszManditory)
{

    HRESULT             hr              = S_OK;
    LPVOID              a_pv[cCOLUMNMETA_NumberOfColumns];
    ULONG               a_iCol[]        = { iCOLUMNMETA_Table,
                                            iCOLUMNMETA_InternalName,
                                            iCOLUMNMETA_Index,
                                            iCOLUMNMETA_MetaFlags,
                                            iCOLUMNMETA_SchemaGeneratorFlags,
                                            iCOLUMNMETA_ID
                                          };
    ULONG               cCol            = sizeof(a_iCol)/sizeof(ULONG);
    WCHAR*              wszEndOpt       = NULL;
    WCHAR*              wszEndMand      = NULL;
    ULONG               cchOptional     = 0;
    ULONG               cchManditory    = 0;
    ULONG               iColIndex       = 0;
    LPVOID              a_Identity[]    = {(LPVOID)i_wszTable,
                                           (LPVOID)&iColIndex
    };
    LPWSTR              wszTable        = NULL;
    ULONG               iStartRow       = 0;
    ULONG               i               = 0;

    MD_ASSERT(NULL != o_pwszOptional);
    MD_ASSERT(NULL != o_pwszManditory);

    *o_pwszOptional = NULL;
    *o_pwszManditory   = NULL;

    //
    // Get the row index of the first column and then iterate thru the table until
    // e_st_nomorerows or the table difffers
    //

    hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
                                                                     a_Identity,
                                                                     &iStartRow);

    if(FAILED(hr))
    {
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
        }
        goto exit;
    }

    //
    // Count the optional and maditory property lengths.
    //

    for(i=iStartRow;;i++)
    {
        ULONG*  pcCh = NULL;

        hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(i,
                                                                   cCol,
                                                                   a_iCol,
                                                                   NULL,
                                                                   a_pv);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[GetProperties] GetColumnValues (count) failed with hr = 0x%x. Index: %d\n",
                      hr, i));
            goto exit;
        }

        if(NULL == wszTable)
        {
            // Save the table name from the read cache so that you can do a pointer compare below.
            wszTable = (LPWSTR)a_pv[iCOLUMNMETA_Table];
        }

        if(wszTable != a_pv[iCOLUMNMETA_Table])
        {
            //
            // reached another table break
            //
            break;
        }

        if(MD_LOCATION == *(DWORD*)a_pv[iCOLUMNMETA_ID])
        {
            //
            // Do NOT read in the location property.
            //

            continue;
        }

        MD_ASSERT(NULL != (DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]);

        if(fCOLUMNMETA_HIDDEN == (fCOLUMNMETA_HIDDEN & (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags])))
        {
            //
            // Do not read hidden properties. All these properties have the
            // "HIDDEN" schemagenerator flag set on them.
            //
            continue;
        }

        if((*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]) & fCOLUMNMETA_MANDATORY)
        {
            cchManditory = cchManditory + (ULONG)wcslen((LPWSTR)a_pv[iCOLUMNMETA_InternalName]) + 1 ; // For comma
            pcCh = &cchManditory;
        }
        else
        {
            cchOptional = cchOptional + (ULONG)wcslen((LPWSTR)a_pv[iCOLUMNMETA_InternalName]) + 1; // For comma
            pcCh = &cchOptional;
        }

        if((*(DWORD*)a_pv[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_FLAG)
        {
            hr = AddFlagValuesToPropertyList((LPWSTR)i_wszTable,
                                             *(DWORD*)a_pv[iCOLUMNMETA_Index],
                                             pcCh,
                                             NULL);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[GetProperties] AddFlagValuesToPropertyList for %s:%s failed with hr = 0x%x.\n",
                          i_wszTable,
                          a_pv[iCOLUMNMETA_InternalName],
                          hr
                          ));
                goto exit;
            }

        }

    }

    if(cchManditory > 0)
    {
        *o_pwszManditory = new WCHAR[cchManditory+1];
        if(NULL == *o_pwszManditory)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        **o_pwszManditory = 0;
        wszEndMand = *o_pwszManditory;
    }

    if(cchOptional > 0)
    {
        *o_pwszOptional = new WCHAR[cchOptional+1];
        if(NULL == *o_pwszOptional)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        **o_pwszOptional= 0;
        wszEndOpt = *o_pwszOptional;
    }

    //
    // Count the optional and maditory property lengths.
    //

    wszTable = NULL;

    for(i=iStartRow; ;i++)
    {
        ULONG   cchName = 0;
        LPWSTR* pwszPropertyList = NULL;

        hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(i,
                                                                   cCol,
                                                                   a_iCol,
                                                                   NULL,
                                                                   a_pv);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[GetProperties] GetColumnValues (copy) failed with hr = 0x%x. Index: %d\n",
                      hr, i));
            goto exit;
        }

        if(NULL == wszTable)
        {
            // Save the table name from the read cache so that you can do a pointer compare below.
            wszTable = (LPWSTR)a_pv[iCOLUMNMETA_Table];
        }

        if(wszTable != a_pv[iCOLUMNMETA_Table])
        {
            //
            // reached another table break
            //
            break;
        }

        if(MD_LOCATION == *(DWORD*)a_pv[iCOLUMNMETA_ID])
        {
            //
            // Do NOT read in the location property.
            //

            continue;
        }

        MD_ASSERT(NULL != (DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]);

        if(fCOLUMNMETA_HIDDEN == (fCOLUMNMETA_HIDDEN & (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags])))
        {
            //
            // Do not read hidden properties. All these properties have the
            // "HIDDEN" schemagenerator flag set on them.
            //
            continue;
        }

        cchName = (ULONG)wcslen((LPWSTR)a_pv[iCOLUMNMETA_InternalName]);


        if((*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]) & fCOLUMNMETA_MANDATORY)
        {
            MD_ASSERT(wszEndMand != NULL);
            memcpy(wszEndMand, a_pv[iCOLUMNMETA_InternalName],  cchName*sizeof(WCHAR));
            wszEndMand = wszEndMand + cchName;
            memcpy(wszEndMand, g_wszComma,  g_cchComma*sizeof(WCHAR));
            wszEndMand = wszEndMand + g_cchComma;
            pwszPropertyList = &wszEndMand;
        }
        else
        {
            MD_ASSERT(wszEndOpt != NULL);
            memcpy(wszEndOpt, a_pv[iCOLUMNMETA_InternalName], cchName*sizeof(WCHAR));
            wszEndOpt = wszEndOpt + cchName;
            memcpy(wszEndOpt, g_wszComma,  g_cchComma*sizeof(WCHAR));
            wszEndOpt = wszEndOpt + g_cchComma;
            pwszPropertyList = &wszEndOpt;
        }

        if((*(DWORD*)a_pv[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_FLAG)
        {
            hr = AddFlagValuesToPropertyList((LPWSTR)i_wszTable,
                                             *(DWORD*)a_pv[iCOLUMNMETA_Index],
                                             NULL,
                                             pwszPropertyList);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[GetProperties] AddFlagValuesToPropertyList for %s:%s failed with hr = 0x%x.\n",
                          i_wszTable,
                          a_pv[iCOLUMNMETA_InternalName],
                          hr
                          ));
                goto exit;
            }
        }

    }

    if(cchManditory > 0)
    {
        wszEndMand--;
        *wszEndMand = L'\0';
    }

    if(cchOptional > 0)
    {
        wszEndOpt--;
        *wszEndOpt = L'\0';
    }

exit:

    return hr;

} // GetProperties


/***************************************************************************++

Routine Description:

    Adds the flag values to the (optional or manditory) property lists

Arguments:

    [in]  Class name.
    [in]  index
    [out] Count of chars.
    [in out] Property list with all flag values added to it.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT AddFlagValuesToPropertyList(LPWSTR                  i_wszTable,
                                    ULONG                   i_dwIndex,
                                    ULONG*                  io_pcCh,
                                    LPWSTR*                 io_pwszPropertyList)
{

    ULONG               a_iCol[]        = { iTAGMETA_InternalName,
                                            iTAGMETA_ColumnIndex,
                                            iTAGMETA_Table
                                          };
    ULONG               cCol            = sizeof(a_iCol)/sizeof(ULONG);
    LPVOID              a_pv[cTAGMETA_NumberOfColumns];

    ULONG               aColSearchTag[] = {iTAGMETA_Table,
                                           iTAGMETA_ColumnIndex
                                            };
    ULONG               cColSearchTag   = sizeof(aColSearchTag)/sizeof(ULONG);
    ULONG               iStartRow       = 0;
    LPWSTR              wszEnd          = NULL;
    HRESULT             hr              = S_OK;
    LPWSTR              wszTable        = NULL;

    if(NULL != io_pwszPropertyList && NULL != *io_pwszPropertyList)
    {
        wszEnd = *io_pwszPropertyList;
    }

    a_pv[iTAGMETA_Table]       = i_wszTable;
    a_pv[iTAGMETA_ColumnIndex] = (LPVOID)&i_dwIndex;

    hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(iStartRow,
                                                                                     cColSearchTag,
                                                                                     aColSearchTag,
                                                                                     NULL,
                                                                                     a_pv,
                                                                                     (ULONG*)&iStartRow);
    if(E_ST_NOMOREROWS == hr)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[AddFlagValuesToPropertyList] No flags found for  %s:%d.\n",
                  i_wszTable,
                  i_dwIndex));
        hr = S_OK;
        goto exit;
    }
    else if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[AddFlagValuesToPropertyList] GetRowIndexBySearch for %s failed with hr = 0x%x.\n",
                  wszTABLE_TAGMETA,
                  hr));

        goto exit;
    }

    for(ULONG iRow=iStartRow;;iRow++)
    {
        ULONG cchName = 0;

        hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetColumnValues(iRow,
                                                                                     cCol,
                                                                                     a_iCol,
                                                                                     NULL,
                                                                                     a_pv);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[AddFlagValuesToPropertyList] GetColumnValues for %s index %i failed with hr = 0x%x.\n",
                      wszTABLE_TAGMETA,
                      iRow,
                      hr));
            goto exit;
        }

        if(NULL == wszTable)
        {
            wszTable = (LPWSTR)a_pv[iTAGMETA_Table];
        }

        if((wszTable != (LPWSTR)a_pv[iTAGMETA_Table])           ||
           (i_dwIndex != *(DWORD*)a_pv[iTAGMETA_ColumnIndex])
          )
        {
            //
            // Reached another table, done with the tags of this table
            //

            break;
        }

        cchName = (ULONG)wcslen((LPWSTR)a_pv[iTAGMETA_InternalName]);

        if(NULL != io_pcCh)
        {
            *io_pcCh = *io_pcCh + cchName + 1; // for comma
        }

        if(NULL != wszEnd)
        {
            memcpy(wszEnd, a_pv[iTAGMETA_InternalName], cchName*sizeof(WCHAR));
            wszEnd = wszEnd + cchName;
            memcpy(wszEnd, g_wszComma,  g_cchComma*sizeof(WCHAR));
            wszEnd = wszEnd + g_cchComma;
        }
    }


    if(NULL != io_pwszPropertyList)
    {
        *io_pwszPropertyList = wszEnd;
    }

exit:

    return hr;

} // AddFlagValuesToPropertyList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\metasub.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metasub.cxx

Abstract:

    IIS MetaBase subroutines to support exported routines

Author:

    Michael W. Thomas            31-May-96

Revision History:

Notes:

    Most routines in this file assume that g_LockMasterResource is already taken
    for read or write as appropriate.
--*/
#include "precomp.hxx"

#if DBG
BOOL g_fShowMetaLocks = FALSE;
#endif DBG


#define _WIDEN(x) L ## x

//
// TODO: Since XML table also uses this cant we reduce to one definition?
//

static WCHAR * kByteToWchar[256] =
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

HRESULT
ReadAllDataFromXML(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   LPSTR pszSchemaLocation,
                   BOOL bHaveReadSaveSemaphore
                   );

HRESULT
ReadAllDataFromBin(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   BOOL bHaveReadSaveSemaphore
                   );

HRESULT
ReadMetaObject(IN CMDBaseObject*&     cboRead,
               IN LPWSTR              wszPath,
               IN FILETIME*           pFileTime,
               IN BOOL                bUnicode);

HRESULT
SaveMasterRoot(IN CWriter*         pCWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob);

HRESULT
SaveEntireTree(IN  IIS_CRYPTO_STORAGE*     pCryptoStorage,
               IN  PIIS_CRYPTO_BLOB        pSessionKeyBlob,
               IN  METADATA_HANDLE         hHandle,
               IN  LPWSTR                  pwszSchemaLocation,
               IN  LPWSTR                  pwszSchemaFileName,
               IN  PSECURITY_ATTRIBUTES    psaStorage,
               IN  HANDLE                  hTempFileHandle);

void
DetermineIfMetabaseCanBeRenamed(LPWSTR      pwszBackupLocation,
                                LPWSTR      pwszRealFileName,
                                BOOL        bTerminating,
                                BOOL*       pbRenameMetabase);

HRESULT
SaveMetabaseFile(IN  LPWSTR pwszSchemaFileName,
                 IN  DWORD  ulHistoryMajorVersionNumber,
                 IN  DWORD  dwEnableHistory,
                 IN  DWORD  dwMaxHistoryFiles,
                 IN  DWORD  dwTempLastSaveChangeNumber,
                 IN  BOOL   bRenameMetabase,
                 IN  LPWSTR pwszTempFileName,
                 IN  LPWSTR pwszRealFileName,
                 IN  LPWSTR pwszBackupFileName,
                 IN  LPWSTR pwszBackupLocation,
                 OUT BOOL*  pbDeleteTemp);

HRESULT
SaveTree(IN CWriter*             pCWriter,
         IN CMDBaseObject*       pboRoot,
         IN BUFFER*              pbufParentPath,
         IN IIS_CRYPTO_STORAGE*  pCryptoStorage,
         IN PIIS_CRYPTO_BLOB     pSessionKeyBlob,
         IN BOOL                 bRecurse = TRUE,
         IN BOOL                 bSaveSchema = TRUE,
                 IN BOOL                 bLocalMachine = FALSE);

HRESULT
SaveDataObject(CMDBaseData*        pbdSave,
               CLocationWriter*    pCLocationWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob);

BOOL
DiscontinuousLocation(LPWSTR wszPreviousLocation,
                      LPWSTR wszCurrentLocation);
VOID
SaveGlobalsFromLM(CMDBaseData*  pbdSave);

HRESULT
InitializeGlobalsFromXML(ISimpleTableRead2*    pISTProperty,
                         LPWSTR                wszDataFileName,
                         LPWSTR                wszSchemaFileName,
                         IIS_CRYPTO_STORAGE**  ppStorage,
                         LPTSTR                pszPasswd,
                         BOOL                  bCalledFromRestore,
                         FILETIME              *pftLastWriteTimeDataFile);

HRESULT
InitializeIIS6GlobalsToDefaults(ULONG  dwPrevSchemaChangeNumber,
                                ULONG  dwSchemaChangeNumber,
                                LPSTR  pszBackupLocation);

HRESULT
SaveGlobalsToXML(CWriter* pCWriter,
                 PIIS_CRYPTO_BLOB    pSessionKeyBlob,
                 bool                bSessionKeyOnly=false);


HRESULT
GetComputerValue(ISimpleTableRead2* pISTProperty,
                 LPCWSTR            wszName,
                 ULONG*             pcbSize,
                 LPVOID*            ppVoid);

HRESULT
GetValue(ISimpleTableRead2*    pISTProperty,
         LPCWSTR               wszPath,
         DWORD                 dwGroup,
         LPCWSTR               wszName,
         ULONG*                pcbSize,
         LPVOID*               ppVoid);

HRESULT
GetUnicodeNameW(IN  LPWSTR  wszFileName,
                OUT LPWSTR* pwszFileName);

HRESULT
GetUnicodeNameA(IN  LPSTR   szFileName,
                OUT LPWSTR* pwszFileName);


HRESULT
InitEditWhileRunning(ISimpleTableRead2*   pISTProperty);

HRESULT
InitChangeNumber(ISimpleTableRead2*   pISTProperty);

void
ValidateMaxHistoryFiles();

HRESULT
CreateHistoryFile(LPWSTR               i_wszFileName,
                  LPWSTR               i_wszHistroyFileDir,
                  ULONG                i_cchHistoryFileDir,
                  LPWSTR               i_wszFileNameWithoutPathWithoutExtension,
                  ULONG                i_cchFileNameWithoutPathWithoutExtension,
                  LPWSTR               i_wszFileNameExtension,
                  ULONG                i_cchFileNameExtension,
                  ULONG                i_ulHistoryMajorVersionNumber);

HRESULT
CreateHistoryFiles(LPWSTR   wszDataFileName,
                   LPWSTR   wszSchemaFileName,
                   ULONG    ulHistoryMajorVersionNumber,
                   DWORD    dwMaxHistoryFiles);
HRESULT
CleanupObsoleteHistoryFiles(DWORD i_dwMaxHistoryFiles,
                            ULONG i_ulHistoryMajorVersionNumber);

HRESULT
DeleteHistoryFile(LPWSTR  i_wszHistroyFileDir,
                  ULONG   i_cchHistoryFileDir,
                  LPWSTR  i_wszFileNameWithoutPathWithoutExtension,
                  ULONG   i_cchFileNameWithoutPathWithoutExtension,
                  LPWSTR  i_wszFileNameExtension,
                  ULONG   i_cchFileNameExtension,
                  ULONG   i_ulMajorVersion,
                  ULONG   i_ulMinorVersion);

HRESULT
SaveSchemaIfNeeded(LPCWSTR              i_wszTempFile,
                   PSECURITY_ATTRIBUTES i_pSecurityAtrributes);

HRESULT
ReadSchema(IIS_CRYPTO_STORAGE*      i_pStorage,
           FILETIME*                pFileTime);

BOOL
SchemaTreeInTable(ISimpleTableRead2*    i_pISTProperty);

HRESULT
CompileIfNeeded(LPWSTR  i_wszDataFileName,
                LPWSTR  i_wszSchemaFileName,
                BOOL*   o_pbSchemaFileNotFound);


HRESULT
InitializeGlobalISTHelper(BOOL  i_bFailIfBinFileAbsent);

void
ReleaseGlobalISTHelper();

HRESULT
MatchTimeStamp(LPWSTR i_wszDataFileName,
               LPWSTR i_wszSchemaXMLFileName,
               LPWSTR i_wszSchemaBINFileName,
               BOOL*  o_bMatchTimeStamp);

HRESULT
ComputeNewHistoryVersionNumber();

BOOL
WstrToUl(
    LPCWSTR     i_wszSrc,
    WCHAR       i_wcTerminator,
    ULONG*      o_pul);

HRESULT
UpdateTimeStamp(LPWSTR i_wszSchemaXMLFileName,
                LPWSTR i_wszSchemaBinFileName);

HRESULT
GetTimeStamp(LPWSTR    i_wszFile,
             LPWSTR    i_wszPropertyName,
             FILETIME* o_FileTime);

HRESULT
SetSecurityOnFile(LPWSTR i_wszFileSrc,
                  LPWSTR i_wszFileDest);

HRESULT
LockMetabaseFile(LPWSTR             pwszMetabaseFile,
                 eMetabaseFile      eMetabaseFileType,
                 BOOL               bHaveReadSaveSemaphore);


HRESULT
UnlockMetabaseFile(eMetabaseFile      eMetabaseFileType,
                   BOOL               bHaveReadSaveSemaphore);

//
// Used by qsort in SaveTree and SaveMasterRoot. In pointers will never
// be null because they are address of array elements.
//

int _cdecl MyComparePBaseObjectContainer(const void *a,
                                         const void *b)
{
    MD_ASSERT(NULL != a);
    MD_ASSERT(NULL != b);

    PBASEOBJECT_CONTAINER pa = *((PBASEOBJECT_CONTAINER*)a);
    PBASEOBJECT_CONTAINER pb = *((PBASEOBJECT_CONTAINER*)b);

    MD_ASSERT(NULL != pa->pboMetaObject);
    MD_ASSERT(NULL != pb->pboMetaObject);

    int res = CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (LPCWSTR)(pa->pboMetaObject->GetName(TRUE)), -1, (LPCWSTR)(pb->pboMetaObject->GetName(TRUE)), -1);

    return (res - 2);

// #define CSTR_LESS_THAN            1           // string 1 less than string 2
// #define CSTR_EQUAL                2           // string 1 equal to string 2
// #define CSTR_GREATER_THAN         3           // string 1 greater than string 2

}


//
// Added By Mohit
//
HRESULT
SaveInheritedOnly(IN CWriter*             i_pCWriter,
                  IN CMDBaseObject*       i_pboRoot,
                  IN BUFFER*              i_pbufParentPath,
                  IN IIS_CRYPTO_STORAGE*  i_pCryptoStorage,
                  IN PIIS_CRYPTO_BLOB     i_pSessionKeyBlob);


#ifdef UNICODE
#define GetUnicodeName  GetUnicodeNameW
#else
#define GetUnicodeName  GetUnicodeNameA
#endif // !UNICODE

HRESULT GetObjectFromPath(
         OUT CMDBaseObject *&rpboReturn,
         IN METADATA_HANDLE hHandle,
         IN DWORD dwPermissionNeeded,
         IN OUT LPTSTR &strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds an object from a path. This function just calls GetHandleObject
    and calls the GetObjectFromPathWithHandle function.

Arguments:

    Return - The object found.

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    PermissionNeeded - The read/write permissions needed. Compared with the
             permissions associated with Handle.

    Path   - The path of the object requested, relative to Handle. If the path
             is not found, this is updated to point to the portion of the path
             not found.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND

Notes:

--*/
{
    CMDHandle *hHandleObject = GetHandleObject(hHandle);

    if (hHandleObject == NULL) {
        return E_HANDLE;
    }

    return GetObjectFromPathWithHandle(rpboReturn,
                                       hHandle,
                                       hHandleObject,
                                       dwPermissionNeeded,
                                       strPath,
                                       bUnicode);

}

HRESULT GetObjectFromPathWithHandle(
         OUT CMDBaseObject *&rpboReturn,
         IN METADATA_HANDLE ,
         IN CMDHandle       *HandleObject,
         IN DWORD dwPermissionNeeded,
         IN OUT LPTSTR &strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds an object from a path. Updates Path to point past the last
    object found if the whole path is not found. If the entire path
    is not found, the last object found is returned.

Arguments:

    Return - The object found.

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    PermissionNeeded - The read/write permissions needed. Compared with the
             permissions associated with Handle.

    Path   - The path of the object requested, relative to Handle. If the path
             is not found, this is updated to point to the portion of the path
             not found.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *pboCurrent, *pboPrevious = NULL;
    LPTSTR strCurPath = strPath;

    rpboReturn = NULL;

    if ((((dwPermissionNeeded & METADATA_PERMISSION_WRITE) != 0) && (!HandleObject->IsWriteAllowed())) ||
        (((dwPermissionNeeded & METADATA_PERMISSION_READ) != 0) && (!HandleObject->IsReadAllowed()))) {
        hresReturn = E_ACCESSDENIED;
    }
    else {
        pboCurrent = HandleObject->GetObject();
        MD_ASSERT(pboCurrent != NULL);
        strCurPath = strPath;

        if (strCurPath != NULL) {
            SkipPathDelimeter(strCurPath, bUnicode);
            while ((pboCurrent != NULL) &&
                (!IsStringTerminator(strCurPath, bUnicode))) {
                pboPrevious = pboCurrent;
                //
                // GetChildObject increments strCurPath on success
                // and returns NULL if child not found
                //
                pboCurrent = pboCurrent->GetChildObject(strCurPath, &hresReturn, bUnicode);
                if (FAILED(hresReturn)) {
                    break;
                }
                if (pboCurrent != NULL) {
                    SkipPathDelimeter(strCurPath, bUnicode);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if ((strCurPath == NULL) ||
                IsStringTerminator(strCurPath, bUnicode)) {  // Found the whole path
                rpboReturn = pboCurrent;
                hresReturn = ERROR_SUCCESS;
            }
            else {           //return last object found and an error code
                rpboReturn = pboPrevious;
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
                strPath = strCurPath;
            }
        }
    }

    return (hresReturn);
}

HRESULT AddObjectToDataBase(
         IN METADATA_HANDLE hHandle,
         IN CMDHandle       *hHandleObject,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Creates and adds one or more objects to the metabase. Finds the deepest object
    pointed to by Handle/Path and creates any subobject specified by path.

Arguments:

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_NOT_ENOUGH_MEMORY
             ERROR_INVALID_NAME

Notes:

--*/
{
    HRESULT hresReturn=ERROR_SUCCESS;
    CMDBaseObject *pboParent;
    CMDHandle     *phCMDHandleObject;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    HRESULT hresExtractRetCode = ERROR_SUCCESS;

    hresReturn = GetObjectFromPathWithHandle(pboParent,
                                             hHandle,
                                             hHandleObject,
                                             METADATA_PERMISSION_WRITE,
                                             strTempPath,
                                             bUnicode);

    //
    // This should return ERROR_PATH_NOT_FOUND and the parent object,
    // with strPath set to the remainder of the path,
    // which should be the child name, without a preceding delimeter.
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND) &&
        pboParent) {
        MD_ASSERT(pboParent != NULL);
        for (hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
            SUCCEEDED(hresExtractRetCode);
            hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode)) {
            CMDBaseObject *pboNew;
            if (bUnicode) {
                pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
            }
            else {
                pboNew = new CMDBaseObject((LPSTR)strName, NULL);
            }
            if (pboNew == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
            else if (!pboNew->IsValid()) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
                break;
            }
            else {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete (pboNew);
                    break;
                }
                else {
                    pboParent = pboNew;

                    phCMDHandleObject = GetHandleObject( hHandle );
                    if( !phCMDHandleObject )
                    {
                        return MD_ERROR_DATA_NOT_FOUND;
                    }

                    phCMDHandleObject->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
                }
            }
        }
    }
    else if (SUCCEEDED(hresReturn)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
    }
    if (hresExtractRetCode == RETURNCODETOHRESULT(ERROR_INVALID_NAME)) {
        hresReturn = hresExtractRetCode;
    }
    return(hresReturn);
}

HRESULT RemoveObjectFromDataBase(
         IN METADATA_HANDLE hHandle,
         IN CMDHandle *hHandleObject,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a metaobject and all subobjects from the database.

Arguments:

    Handle - The Meta Data handle. A handle returned by MDOpenMetaObject with write permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND
             ERROR_INVALID_PARAMETER

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboDelete;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    //
    // Make sure that a valid path was specified
    //
    SkipPathDelimeter(strTempPath, bUnicode);
    hresReturn = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
    if (FAILED(hresReturn)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        strTempPath = strPath;
        hresReturn = GetObjectFromPathWithHandle(pboDelete,
                                       hHandle,
                                       hHandleObject,
                                       METADATA_PERMISSION_WRITE,
                                       strTempPath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = (pboDelete->GetParent())->RemoveChildObject(pboDelete);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(GetHandleObject(hHandle) != NULL);
                if (GetHandleObject(hHandle)->SetChangeData(pboDelete, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboDelete);
                }
            }
        }
    }
    return(hresReturn);
}

CMDHandle *GetHandleObject(
         IN METADATA_HANDLE hHandle)
/*++

Routine Description:

    Gets the handle object associated with Handle.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

Return Value:

    CMDHandle * - The handle object, or NULL if not found.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    for (hoCurrent = g_phHandleHead;
        (hoCurrent != NULL) && (hoCurrent->GetHandleIdentifier() != hHandle);
        hoCurrent = hoCurrent->GetNextPtr()) {
    }
    return (hoCurrent);
}

BOOL
PermissionsAvailable(
         IN CMDBaseObject *pboTest,
         IN DWORD dwRequestedPermissions,
         IN DWORD dwReadThreshHold
         )
/*++

Routine Description:

    Checks if the requested handle permissions are available for a meta object.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

    RequestedPermissions - The permissions requested.

    ReadThreshHold - The number of reads allows on a write request. Normally 0.

Return Value:

    BOOL   - TRUE if the permissions are available.

Notes:

--*/
{
    BOOL bResults = TRUE;
    CMDBaseObject *pboCurrent;
    MD_ASSERT(pboTest != NULL);
    if (dwRequestedPermissions & METADATA_PERMISSION_WRITE) {
        if ((pboTest->GetReadPathCounter() != 0) ||
            (pboTest->GetWritePathCounter() != 0)) {
            bResults = FALSE;
        }
        if ((pboTest->GetReadCounter() > dwReadThreshHold) || (pboTest->GetWriteCounter() != 0)) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest->GetParent();bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if ((pboCurrent->GetReadCounter() != 0) || (pboCurrent->GetWriteCounter() != 0)) {
                bResults = FALSE;
            }
        }
    }
    else if (dwRequestedPermissions & METADATA_PERMISSION_READ) {
        if (pboTest->GetWritePathCounter() != 0) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest;bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if (pboCurrent->GetWriteCounter() != 0) {
                bResults = FALSE;
            }
        }
    }
    else {
        MD_ASSERT(FALSE);
    }
    return (bResults);
}

VOID RemovePermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRemovePermissions
         )
/*++

Routine Description:

    Removes the handle permissions from a meta object.

Arguments:

    Affected - The object to remove permissions from.

    RemovePermissions - The permissions to remove.

Return Value:

Notes:

--*/
{
    MD_ASSERT(pboAffected != NULL);
    CMDBaseObject *pboCurrent;
    if ((dwRemovePermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->DecrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementWritePathCounter();
        }
    }
    if ((dwRemovePermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->DecrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementReadPathCounter();
        }
    }

#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRemovePermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms releasted (%d) on ");
        cchSz = (unsigned long)strlen(szBuf);

        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);

        cchBuf = (cchBuf + cchSz + 2 > (unsigned long)sizeof(szBuf)) ? (unsigned long)sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';

        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

VOID
AddPermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRequestedPermissions
         )
/*++

Routine Description:

    Adds handle permissions to a meta object.

Arguments:

    Affected - The object to remove permissions from.

    ReqyestedPermissions - The permissions to add.

Return Value:

Notes:

--*/
{
    CMDBaseObject *pboCurrent;
    if (((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) &&
        ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0)) {
        pboAffected->IncrementWriteCounter();
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
            pboCurrent->IncrementReadPathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->IncrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementReadPathCounter();
        }
    }

#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRequestedPermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms obtained (%d) on ");
        cchSz = (unsigned long)strlen(szBuf);

        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);

        cchBuf = (cchBuf + cchSz + 2 > (unsigned long)sizeof(szBuf)) ? (unsigned long)sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';

        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

HRESULT
AddHandle(
         IN CMDBaseObject *pboAssociated,
         IN DWORD dwRequestedPermissions,
         IN METADATA_HANDLE &rmhNew,
         IN BOOLEAN bSchemaKey
         )
/*++

Routine Description:

    Creates a handle object and adds it to the handle list.

Arguments:

    Handle - The object the handle is associated with.

    RequestedPermissions - The permissions for the handle.

    New - The handle id.

Return Value:
    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoNew = new CMDHandle(pboAssociated,
                                     dwRequestedPermissions,
                                     g_dwSystemChangeNumber,
                                     g_mhHandleIdentifier++,
                                     bSchemaKey);
    if (hoNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        rmhNew = hoNew->GetHandleIdentifier();
        hoNew->SetNextPtr(g_phHandleHead);
        g_phHandleHead = hoNew;
        AddPermissions(pboAssociated, dwRequestedPermissions);
    }
    return(hresReturn);
}

CMDHandle *
RemoveHandleObject(
         IN METADATA_HANDLE mhHandle
         )
/*++

Routine Description:

    Removes a handle object from the handle list.

Arguments:

    Handle - The handle to be removed.

Return Value:

    CMDHandle * - The Handle object removed.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    CMDHandle *hoReturn;

    if (g_phHandleHead->GetHandleIdentifier() == mhHandle) {
        hoReturn = g_phHandleHead;
        g_phHandleHead = g_phHandleHead->GetNextPtr();
    }
    else {
        for (hoCurrent = g_phHandleHead;(hoCurrent->GetNextPtr() != NULL) &&
            (hoCurrent->GetNextPtr()->GetHandleIdentifier() != mhHandle);
            hoCurrent = hoCurrent->GetNextPtr()) {
        }
        hoReturn = hoCurrent->GetNextPtr();
        if (hoCurrent->GetNextPtr() != NULL) {
            MD_ASSERT (hoCurrent->GetNextPtr()->GetHandleIdentifier() == mhHandle);
            hoCurrent->SetNextPtr(hoCurrent->GetNextPtr()->GetNextPtr());
        }
    }
    return (hoReturn);
}

HRESULT
SaveDataObject(HANDLE hFileHandle,
               CMDBaseData *pbdSave,
               PBYTE pbLineBuf,
               DWORD dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage
               )
/*++

Routine Description:

    Save a data object.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Save       - The data object to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwTemp;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {

        *pbLineBuf = MD_ID_DATA;

        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            pbLineBuf,
                            pbrNextPtr,
                            1,
                            FALSE);

        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetIdentifier();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetAttributes();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetUserType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetDataType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }

        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) {
                    PIIS_CRYPTO_BLOB blob;

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData( &blob,
                                                              pbdSave->GetData(TRUE),
                                                              pbdSave->GetDataLen(TRUE),
                                                              0);

                    if (SUCCEEDED(hresReturn)) {
                        hresReturn = WriteLine(hFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE)blob,
                                            pbrNextPtr,
                                            IISCryptoGetBlobLength(blob),
                                            TRUE);

                        ::IISCryptoFreeBlob(blob);
                    }
                } else {
                    hresReturn = WriteLine(hFileHandle,
                                        dwWriteBufSize,
                                        pbWriteBuf,
                                        (PBYTE)pbdSave->GetData(TRUE),
                                        pbrNextPtr,
                                        pbdSave->GetDataLen(TRUE),
                                        TRUE);
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
SaveMasterRoot(HANDLE hFileHandle,
               PBYTE pbLineBuf,
               DWORD  dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage
               )
/*++

Routine Description:

    Save the master root object, including its data objects.

Arguments:

    FileHandle - File handle for use by WriteLine.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    PFILETIME pftTime;

    pftTime = g_pboMasterRoot->GetLastChangeTime();

    *pbLineBuf = MD_ID_ROOT_OBJECT;

    hresReturn = WriteLine(hFileHandle,
                        dwWriteBufSize,
                        pbWriteBuf,
                        pbLineBuf,
                        pbrNextPtr,
                        1,
                        FALSE);

    if (SUCCEEDED(hresReturn)) {
        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            (PBYTE)pftTime,
                            pbrNextPtr,
                            sizeof(FILETIME),
                            TRUE);
    }

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
        hresReturn = SaveDataObject(hFileHandle,
                                 dataAssociatedData,
                                 pbLineBuf,
                                 dwWriteBufSize,
                                 pbWriteBuf,
                                 pbrNextPtr,
                                 pCryptoStorage
                                 );
    }

    return(hresReturn);
}

HRESULT
SaveTree(
         IN HANDLE hFileHandle,
         IN CMDBaseObject *pboRoot,
         IN PBYTE pbLineBuf,
         IN BUFFER *pbufParentPath,
         IN DWORD  dwWriteBufSize,
         IN PBYTE pbWriteBuf,
         IN OUT PBYTE &pbrNextPtr,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage
         )
/*++

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Root       - The root of the tree to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *objChildObject;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;

    dwParentPathLen = (DWORD)wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = (DWORD)wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
            strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
            strParentPath[dwNewParentPathLen - 1] = (WCHAR)L'\0';
            pftTime = pboRoot->GetLastChangeTime();

            *pbLineBuf = MD_ID_OBJECT;

            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                pbLineBuf,
                                pbrNextPtr,
                                1,
                                FALSE);

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE)pftTime,
                                    pbrNextPtr,
                                    sizeof(FILETIME),
                                    FALSE);
            }

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE) strParentPath,
                                    pbrNextPtr,
                                    (dwNewParentPathLen) * sizeof(WCHAR),
                                    TRUE);
            }

            if (SUCCEEDED(hresReturn)) {

                for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                    (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                    dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
                    hresReturn = SaveDataObject(hFileHandle,
                                             dataAssociatedData,
                                             pbLineBuf,
                                             dwWriteBufSize,
                                             pbWriteBuf,
                                             pbrNextPtr,
                                             pCryptoStorage
                                             );
                }

                for(dwEnumObjectIndex=0,objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++);
                    (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                    objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++)) {
                    hresReturn = SaveTree(hFileHandle,
                                       objChildObject,
                                       pbLineBuf,
                                       pbufParentPath,
                                       dwWriteBufSize,
                                       pbWriteBuf,
                                       pbrNextPtr,
                                       pCryptoStorage
                                       );
                }
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)L'\0';
        }
    }

    return(hresReturn);
}

HRESULT
ReadMetaObject(
         IN CMDBaseObject *&cboRead,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *,
         IN BOOL bUnicode)
/*++

Routine Description:

    Read a meta object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Read       - Place to return the created object.

    ObjectLine - The object info.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboParent;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    FILETIME ftTime;
    PFILETIME pftParentTime;
    FILETIME ftParentTime;
    PBYTE pbLine = (PBYTE)pbufLine->QueryPtr();
    LPTSTR strObjectName;

    if ((dwLineLen <= BASEMETAOBJECTLENGTH) || (*(pbLine + dwLineLen - 1) != '\0')) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        ftTime = *(UNALIGNED FILETIME *)(pbLine + 1);
        //
        // GetObjectFromPath checks permissions on the handle
        // This only gets called from init so just tell it read.
        //
        strObjectName = (LPTSTR)(pbLine + BASEMETAOBJECTLENGTH);

        if (bUnicode != FALSE) {

            PCUWSTR strObjectNameUnaligned;
            PCWSTR strObjectNameAligned;

            //
            // Generate an aligned copy of the string
            //

            strObjectNameUnaligned = (PCUWSTR)strObjectName;

            #pragma warning(push, 3)
            WSTR_ALIGNED_STACK_COPY(&strObjectNameAligned,
                                    strObjectNameUnaligned);
            #pragma warning(pop)

            strObjectName = (LPTSTR)strObjectNameAligned;
        }
        hresReturn = GetObjectFromPath(pboParent,
                                    METADATA_MASTER_ROOT_HANDLE,
                                    METADATA_PERMISSION_READ,
                                    strObjectName,
                                    bUnicode);

        //
        // This should return ERROR_PATH_NOT_FOUND and the parent object,
        // with strObjectLine set to the remainder of the path,
        // which should be the child name, without a preceding delimeter.
        //

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            MD_ASSERT(pboParent != NULL);
            if (bUnicode) {
                hresReturn = ExtractNameFromPath((LPWSTR *)&strObjectName, (LPWSTR)strName);
            }
            else {
                hresReturn = ExtractNameFromPath((LPSTR)strObjectName, (LPSTR)strName);
            }
            if (SUCCEEDED(hresReturn)) {
                CMDBaseObject *pboNew;
                if (bUnicode) {
                    pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
                }
                else {
                    pboNew = new CMDBaseObject((LPSTR)strName, NULL);
                }
                if (pboNew == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else if (!pboNew->IsValid()) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    delete (pboNew);
                }
                else {
                    //
                    // InsertChildObject sets the last change time to current time.
                    // This isn't really a change, so save and restore time.
                    //
                    pftParentTime = pboParent->GetLastChangeTime();
                    ftParentTime = *pftParentTime;
                    hresReturn = pboParent->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        pboParent->SetLastChangeTime(&ftParentTime);
                        pboNew->SetLastChangeTime(&ftTime);
                        cboRead = pboNew;
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }
        }
        else if (SUCCEEDED(hresReturn)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
        }
    }
    return (hresReturn);
}

HRESULT
ReadDataObject(
         IN CMDBaseObject *cboAssociated,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode
         )
/*++

Routine Description:

    Read a data object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Associated - The associated meta object.

    DataLine   - The data info.

    BinaryBuf  - Buffer to use in UUDecode.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS
                 ERROR_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    PFILETIME pftTime;
    FILETIME ftTime;
    PBYTE pbDataLine = (PBYTE)pbufLine->QueryPtr();
    PBYTE pbDataValue;
    STACK_BUFFER( bufAlignedValue, 256 );
    DWORD dwDataLength;
    PIIS_CRYPTO_BLOB blob = NULL;

    if (dwLineLen < DATAOBJECTBASESIZE) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        MD_ASSERT(pbufLine->QuerySize() >= DATAOBJECTBASESIZE);
        mdrData.dwMDIdentifier = *(UNALIGNED DWORD *)(pbDataLine + 1);
        mdrData.dwMDAttributes = *(UNALIGNED DWORD *)(pbDataLine + 1 + sizeof(DWORD));
        mdrData.dwMDUserType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (2 * sizeof(DWORD)));
        mdrData.dwMDDataType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (3 * sizeof(DWORD)));

        pbDataValue = pbDataLine + DATAOBJECTBASESIZE;
        dwDataLength = dwLineLen - DATAOBJECTBASESIZE;

        if (IsSecureMetadata(mdrData.dwMDIdentifier, mdrData.dwMDAttributes) &&
            pCryptoStorage != NULL) {

            //
            // This is a secure data object, we we'll need to decrypt it
            // before proceeding. Note that we must clone the blob before
            // we can actually use it, as the blob data in the line buffer
            // is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
            // the only IISCrypto function that can handle unaligned data.)
            //

            hresReturn = ::IISCryptoCloneBlobFromRawData(
                             &blob,
                             pbDataValue,
                             dwDataLength
                             );

            if (SUCCEEDED(hresReturn)) {
                DWORD dummyRegType;

                MD_ASSERT(::IISCryptoIsValidBlob(blob));
                hresReturn = pCryptoStorage->DecryptData(
                                   (PVOID *)&pbDataValue,
                                   &dwDataLength,
                                   &dummyRegType,
                                   blob
                                   );
            }

        } else {

            //
            // The metadata was not secure, so decryption was not required.
            // Nonetheless, it must be copied to an aligned buffer...
            //

            if( !bufAlignedValue.Resize( dwDataLength ) )
            {
                hresReturn = HRESULT_FROM_WIN32( GetLastError() );
            }
            else
            {
                memcpy( bufAlignedValue.QueryPtr(), pbDataValue, dwDataLength );
                pbDataValue = ( PBYTE )bufAlignedValue.QueryPtr();
            }
         }

        if (SUCCEEDED(hresReturn)) {
            mdrData.pbMDData = pbDataValue;

            switch (mdrData.dwMDDataType) {
                case DWORD_METADATA: {
                    if (dwDataLength != sizeof(DWORD)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if ((LONG)dwDataLength < 1 ||
                        (!bUnicode && (pbDataValue[dwDataLength-1] != '\0')) ||
                        (bUnicode && *(((LPWSTR)pbDataValue) + ((dwDataLength / sizeof(WCHAR)) -1)) != (WCHAR)L'\0')) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case BINARY_METADATA:
                {
                    mdrData.dwMDDataLen = dwDataLength;
                    break;
                }
                case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        if (dwDataLength < (2 * sizeof(WCHAR)) ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-1)) != (WCHAR)L'\0' ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-2)) != (WCHAR)L'\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    else {
                        if (dwDataLength < 2 ||
                            pbDataValue[dwDataLength-1] != '\0' ||
                            pbDataValue[dwDataLength-2] != '\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        mdrData.dwMDDataLen = dwDataLength;
                    }
                    break;
                }
                default: {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // SetDataObject sets the last change time to current time.
        // This isn't really a change, so save and restore time.
        //
        pftTime = cboAssociated->GetLastChangeTime();
        ftTime = *pftTime;
        hresReturn = cboAssociated->SetDataObject(&mdrData, bUnicode);
        cboAssociated->SetLastChangeTime(&ftTime);
    }

    if (blob != NULL) {
        ::IISCryptoFreeBlob(blob);
    }

    return(hresReturn);
}

HRESULT
FlushWriteBuf(HANDLE hWriteFileHandle,
              PBYTE pbWriteBuf,
              PBYTE &pbrNextPtr)
/*++

Routine Description:

    Flush the write buffer to the file.

Arguments:

    FileHandle - File handle to write to.

    WriteBuf   - Buffer to write to file.

    NextPtr    - Pointer past end of buffer.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesWritten;
    if (pbrNextPtr > pbWriteBuf) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       (DWORD)DIFF((BYTE *)pbrNextPtr - (BYTE *)pbWriteBuf),
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

BOOL
CopyLineWithEscapes(PBYTE &pbrFileBuf,
                    DWORD &dwrFileBufLen,
                    PBYTE &pbrLineBuf,
                    DWORD &dwrLineBufLen,
                    BOOL  &brMidEscape)
    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbrFileBuf, dwrFileBufLen, brMidEscape
    // FAILURE: pbrLineBuf, dwrLineBufLen, brMidEscape
    // On FAILURE, it fills to the end of the buffer
    //
{
    BOOL bReturn = TRUE;
    PBYTE pbFileBufEnd = pbrFileBuf + dwrFileBufLen;
    PBYTE pbLineBufEnd = pbrLineBuf + dwrLineBufLen;
    PBYTE pbFileBufIndex = pbrFileBuf;
    PBYTE pbLineBufIndex = pbrLineBuf;

    brMidEscape = FALSE;

    while ((pbLineBufIndex < pbLineBufEnd) && (pbFileBufIndex < (pbFileBufEnd - 1))) {
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
        }
        *pbFileBufIndex++ = *pbLineBufIndex++;
    }
    if ((pbLineBufIndex != pbLineBufEnd) && (pbFileBufIndex < pbFileBufEnd)) {
        MD_ASSERT(pbFileBufIndex == (pbFileBufEnd - 1));
        //
        // file last byte in buffer
        //
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
            brMidEscape = TRUE;
        }
        else {
            *pbFileBufIndex++ = *pbLineBufIndex++;
        }
    }
    if (pbLineBufIndex != pbLineBufEnd) {
        bReturn = FALSE;
        pbrLineBuf = pbLineBufIndex;
        dwrLineBufLen = (DWORD)DIFF(pbLineBufEnd - pbLineBufIndex);
    }
    else {
        pbrFileBuf = pbFileBufIndex;
        dwrFileBufLen = (DWORD)DIFF(pbFileBufEnd - pbFileBufIndex);
    }

    return bReturn;
}


HRESULT
WriteLine(HANDLE hWriteFileHandle,
          DWORD  dwWriteBufSize,
          PBYTE  pbWriteBuf,
          PBYTE  pbLineBuf,
          PBYTE  &pbNextPtr,
          DWORD  dwLineLen,
          BOOL   bTerminate)
/*++

Routine Description:

    Write a line. Performs buffered writes to a file. Does not append \n.
    The string does not need to be terminated with \0.

Arguments:

    FileHandle - File to write to.

    WriteBufSize - Buffer size.

    WriteBuf   - Buffer to store data in.

    LineBuf    - The line buffer with data to write.

    NextPtr    - Pointer to the next unused character in WriteBuf.

    Len        - The number of characters to write.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    PBYTE pbWriteBufEnd = pbWriteBuf + dwWriteBufSize;
    DWORD dwBufferBytesLeft = (DWORD)DIFF(pbWriteBufEnd - pbNextPtr);
    DWORD dwBytesWritten;
    BOOL  bMidEscape;

    MD_ASSERT(pbLineBuf != NULL);
    MD_ASSERT(pbWriteBuf != NULL);
    MD_ASSERT((pbNextPtr >= pbWriteBuf) && (pbNextPtr <= pbWriteBufEnd));

    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbNextPtr, dwBufferBytesLeft
    // FAILURE: pbLineBuf, dwLineLen, bMidEscape
    // On FAILURE, it fills to the end of the buffer
    //

    while ((dwReturn == ERROR_SUCCESS) &&
        (!CopyLineWithEscapes(pbNextPtr, dwBufferBytesLeft, pbLineBuf, dwLineLen, bMidEscape))) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       dwWriteBufSize,
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
        dwBufferBytesLeft = dwWriteBufSize;
        pbNextPtr = pbWriteBuf;
        if (bMidEscape) {
            *pbNextPtr++ = *pbLineBuf++;
            dwBufferBytesLeft--;
            dwLineLen--;
        }
    }
    if (bTerminate && (dwReturn == ERROR_SUCCESS)) {
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_ESCAPE_BYTE;
        dwBufferBytesLeft--;
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_TERMINATE_BYTE;
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

PBYTE
FindEndOfData(PBYTE pbNextPtr,
              PBYTE pbEndReadData,
              BOOL bEscapePending)
{
    PBYTE pbIndex = pbNextPtr;
    BOOL bEndFound = FALSE;

    if ((pbEndReadData > pbIndex) && bEscapePending) {
        if (*pbIndex == MD_TERMINATE_BYTE) {
            bEndFound = TRUE;
        }
        pbIndex++;
    }
    while ((pbEndReadData -1 > pbIndex) && !bEndFound) {
        if (*pbIndex == MD_ESCAPE_BYTE) {
            pbIndex++;
            if (*pbIndex == MD_TERMINATE_BYTE) {
                bEndFound = TRUE;
            }
        }
        pbIndex++;
    }
    if (!bEndFound) {
        MD_ASSERT(pbIndex == pbEndReadData - 1);
        pbIndex++;
    }
    return pbIndex;
}

DWORD
GetLineFromBuffer(PBYTE &pbrNextPtr,
                  PBYTE &pbrEndReadData,
                  BUFFER *pbufLine,
                  DWORD &dwrLineLen,
                  BOOL &brEscapePending)
    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //
{
    DWORD dwReturn = ERROR_HANDLE_EOF;
    PBYTE pbLineIndex;
    PBYTE pbEndReadLine;
    PBYTE pbReadDataIndex = pbrNextPtr;

    DBGINFO((DBG_CONTEXT,
             "Entering GeLineFromBuffer, pbrNextPtr = %p, pbrEndReadData = %p\n",
             pbrNextPtr,
             pbrEndReadData));

    if (pbrNextPtr != pbrEndReadData) {
        //
        // first find out how many bytes we need to read
        //
        pbEndReadLine = FindEndOfData(pbrNextPtr, pbrEndReadData, brEscapePending);
        MD_ASSERT(pbEndReadLine > pbrNextPtr);

        //
        // Actual number of bytes needed may be less than the size of the data
        // but never more, so just resize for the max we might need
        //
        if (!pbufLine->Resize(dwrLineLen + (ULONG)DIFF(pbEndReadLine - pbrNextPtr))) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pbLineIndex = (PBYTE)pbufLine->QueryPtr() + dwrLineLen;
            if (brEscapePending) {
                brEscapePending = FALSE;
                if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                    dwReturn = ERROR_SUCCESS;
                    pbReadDataIndex++;
                }
            }
            while ((dwReturn != ERROR_SUCCESS) && (pbReadDataIndex < pbEndReadLine)) {
                if (*pbReadDataIndex != MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    pbReadDataIndex++;
                    if (pbReadDataIndex == pbEndReadLine) {
                        brEscapePending = TRUE;
                    }
                    else {
                        if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                            *pbLineIndex++ = *pbReadDataIndex++;
                        }
                        else {
                            MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                            pbReadDataIndex++;
                            dwReturn = ERROR_SUCCESS;
                        }
                    }
                }
            }
            dwrLineLen = (DWORD)DIFF(pbLineIndex - (PBYTE)pbufLine->QueryPtr());
            pbrNextPtr = pbReadDataIndex;
        }
    }

    DBGINFO((DBG_CONTEXT,
             "Leaving GeLineFromBuffer, pbrNextPter = %p, pbrEndReadData = %p\n",
             pbrNextPtr,
             pbrEndReadData));

    return dwReturn;
}

HRESULT
GetNextLine(
         IN HANDLE hReadFileHandle,
         IN OUT PBYTE &pbrEndReadData,
         IN BUFFER *pbufRead,
         IN OUT BUFFER *pbufLine,
         IN OUT DWORD &dwrLineLen,
         IN OUT PBYTE &pbrNextPtr)
/*++

Routine Description:

    Get the next line. Performs buffered reads from a file. Only pbrCurPtr may be modified between calls.
    Other variables must be set up before the first call and not changed.

Arguments:

    ReadFileHandle - File to write to.

    EndReadDataPtr - Points past the end of the data in ReadBuf.

    Read       - Buffer for file data.

    Line       - A line buffer which the returned line is stored in.

    LineLen    - The length of the data in line

    NextPtr    - On entry, pointer to the next unread character in ReadBuf.
                 On exit, pointer to the new next unread character in ReadBuf.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_INVALID_DATA
                 Return codes from file system

Notes:
    On EOF, returns ERROR_SUCCESS, dwrLineLen = 0.

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwLineLen = 0;
    BOOL bEscapePending = FALSE;
    DWORD dwGetLineReturn = ERROR_HANDLE_EOF;
    BOOL bEOF = FALSE;

    DBGINFO((DBG_CONTEXT,
             "Entering GetNextLine, pbrNextPtr = %p, pbrEndReadData = %p\n",
             pbrNextPtr,
             pbrEndReadData));

    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //

    while ((dwReturn == ERROR_SUCCESS) && (dwGetLineReturn == ERROR_HANDLE_EOF) && (!bEOF)) {

        DBGINFO((DBG_CONTEXT,
                 "GetNextLine calling GetLineFromBuffer, pbrNextPtr = %p, pbrEndReadData = %p\n",
                 pbrNextPtr,
                 pbrEndReadData));

        dwGetLineReturn = GetLineFromBuffer(pbrNextPtr,
                                            pbrEndReadData,
                                            pbufLine,
                                            dwLineLen,
                                            bEscapePending);

        if (dwGetLineReturn == ERROR_HANDLE_EOF) {
            DBGINFO((DBG_CONTEXT,
                     "GetNextLine calling ReadFile\n"));

            if (!ReadFile(hReadFileHandle,
                          (LPVOID) pbufRead->QueryPtr(),
                          pbufRead->QuerySize(),
                          &dwBytesRead,
                          NULL)) {
                dwReturn = GetLastError();
            }
            else {
                pbrEndReadData = (BYTE *)pbufRead->QueryPtr() + dwBytesRead;
                pbrNextPtr = (PBYTE)pbufRead->QueryPtr();

                DBGINFO((DBG_CONTEXT,
                         "GetNextLine after call to ReadFile, pbrNextPter = %p, pbrEndReadData = %p\n",
                         pbrNextPtr,
                         pbrEndReadData));

                if (dwBytesRead == 0) {
                    bEOF = TRUE;
                }
            }
        }
    }
    if (bEOF) {
        MD_ASSERT(dwGetLineReturn == ERROR_HANDLE_EOF);
        dwLineLen = 0;
    }
    else if (dwGetLineReturn != ERROR_SUCCESS) {
        dwReturn = dwGetLineReturn;
    }

    dwrLineLen = dwLineLen;
    return RETURNCODETOHRESULT(dwReturn);
}

DWORD
GetLineID(
         IN OUT LPTSTR &strCurPtr)
/*++

Routine Description:

    Determines the ID of a line from the metadata file.

Arguments:

    CurPtr     - The line to ID. Updated on successful ID to point past
                 the id string.

Return Value:

    DWORD      - MD_ID_OBJECT
                 MD_ID_DATA
                 MD_ID_REFERENCE
                 MD_ID_ROOT_OBJECT
                 MD_ID_NONE

Notes:

--*/
{
    DWORD dwLineID;
    if (MD_STRNICMP(strCurPtr, MD_OBJECT_ID_STRING, ((sizeof(MD_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_DATA_ID_STRING, ((sizeof(MD_DATA_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_DATA;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_DATA_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_REFERENCE_ID_STRING, ((sizeof(MD_REFERENCE_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_REFERENCE;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_REFERENCE_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_ROOT_OBJECT_ID_STRING, ((sizeof(MD_ROOT_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_ROOT_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_ROOT_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_CHANGE_NUMBER_ID_STRING, ((sizeof(MD_CHANGE_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_CHANGE_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_CHANGE_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MAJOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MAJOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MINOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MINOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else {
        dwLineID = MD_ID_NONE;
    }
    return(dwLineID);
}

HRESULT
GetWarning(
         IN HRESULT hresWarningCode)
/*++

Routine Description:

    Converts error to warnings.

Arguments:

    WarnignCode - The error code to convert.

Return Value:

    DWORD      - MD_WARNING_PATH_NOT_FOUND
                 MD_WARNING_DUP_NAME
                 MD_WARNING_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn;
    switch (hresWarningCode) {
        case (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)):
            hresReturn = MD_WARNING_PATH_NOT_FOUND;
            break;
        case (RETURNCODETOHRESULT(ERROR_DUP_NAME)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        case (RETURNCODETOHRESULT(ERROR_INVALID_DATA)):
            hresReturn = MD_WARNING_INVALID_DATA;
            break;
        case (RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        default:
            hresReturn = hresWarningCode;
    }
    return (hresReturn);
}

BOOL CheckDigits(LPTSTR pszString)
{
    LPTSTR  pszTemp;
    BOOL    bDigitFound = FALSE;
    BOOL    bReturn = FALSE;
    DWORD   dwNumber=0;

    if (!pszString)
    {
        goto exit;
    }

    for (pszTemp = pszString; MD_ISDIGIT(*pszTemp)&&(dwNumber<=MD_BACKUP_MAX_VERSION); pszTemp++)
    {
        dwNumber*=10;
        dwNumber+=*pszTemp-_T('0');
        bDigitFound = TRUE;
    }

    if (bDigitFound && (dwNumber<=MD_BACKUP_MAX_VERSION) && (*pszTemp == _T('\0')))
    {
        bReturn = TRUE;
    }

exit:
    return bReturn;
}

HRESULT
InitStorageHelper(
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {
        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //

        storage = new IIS_CRYPTO_STORAGE();

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             TRUE,          // fUseMachineKeyset
                             hProv
                             );
                if (FAILED(hresReturn))
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[InitStorageHelper] IIS_CRYPTO_STORAGE::Initialize faile with hr = 0x%x.\n",hresReturn));
                }
            }
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[InitStorageHelper] GetCryptoProvider failed with hr = 0x%x. (Crypto problem)\n",hresReturn));
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob(alignedBlob);
    }
    else
    {
        // something failed...
        DBGINFOW((DBG_CONTEXT,
                  L"[InitStorageHelper] IISCryptoCloneBlobFromRawData failed with hr = 0x%x. (Crypto problem).\n",hresReturn));
    }

    *NewStorage = storage;
    return hresReturn;

}   // InitStorageHelper


HRESULT
InitStorageHelper2(
    LPSTR pszPasswd,
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.






--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE2 *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    if( ( ( PIIS_CRYPTO_BLOB )RawBlob )->BlobSignature != SALT_BLOB_SIGNATURE )
    {
        return InitStorageHelper( RawBlob, RawBlobLength, NewStorage );
    }

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData2(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {
        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //
        storage = new IIS_CRYPTO_STORAGE2;

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider2( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             pszPasswd,
                             hProv
                             );
                if (FAILED(hresReturn))
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[InitStorageHelper2] IIS_CRYPTO_STORAGE::Initialize failed with hr = 0x%x.\n",hresReturn));
                }
            }
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[InitStorageHelper] GetCryptoProvider failed with hr = 0x%x. (Crypto problem)\n",hresReturn));
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob2(alignedBlob);
    }
    else
    {
        // something failed...
        DBGINFOW((DBG_CONTEXT,
                  L"[InitStorageHelper] IISCryptoCloneBlobFromRawData failed with hr = 0x%x. (Crypto problem).\n",hresReturn));
    }

    *NewStorage = ( IIS_CRYPTO_STORAGE * )storage;
    return hresReturn;

}   // InitStorageHelper2


HRESULT
ReadAllData(LPSTR pszPasswd,
            LPSTR pszBackupLocation,
            LPSTR pszSchemaLocation,
            BOOL bHaveReadSaveSemaphore
            )
/*++

Routine Description:

    Deletgates to correct Reads all meta data from metabase.bin
    or metabase.xml

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system
                 Return codes from config

Notes:

--*/
{

    HRESULT hr = ERROR_SUCCESS;

    hr = ReadAllDataFromXML(pszPasswd,
                            pszBackupLocation,
                            pszSchemaLocation,
                            bHaveReadSaveSemaphore
                            );

    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {

    //
    // Metabase.xml file was not found. Hence try to load from the
    // metabase.bin file.
    //

        hr = ReadAllDataFromBin(pszPasswd,
                                pszBackupLocation,
                                bHaveReadSaveSemaphore
                                );
    }

    return hr;

}


HRESULT
ReadAllDataFromXML(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   LPSTR pszSchemaLocation,
                   BOOL bHaveReadSaveSemaphore
                   )
/*++

Routine Description:

    Reads all meta data from the XML file.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system
                 Return codes from the catalog

Notes:

--*/
{
    HRESULT                     hr                             = ERROR_SUCCESS;
    HRESULT                     hresWarningCode                = ERROR_SUCCESS;

    ISimpleTableDispenser2*     pISTDisp                       = NULL;
    ISimpleTableRead2*          pISTProperty                   = NULL;
    STQueryCell                 QueryCell[2];
    ULONG                       cCell                          = sizeof(QueryCell)/sizeof(STQueryCell);
    ULONG                       i                              = 0;
    LPWSTR                      wszDataFileName                = NULL;
    LPWSTR                      wszSchemaFileName              = NULL;
    LPTSTR                      strReadFileName;
    LPTSTR                      strSchemaFileName;

    CMDBaseObject*              pboRead                        = NULL;
    IIS_CRYPTO_STORAGE*         pStorage                       = NULL;
    DWORD                       dwPreviousLocationID           = (DWORD)-1;
    LPWSTR                      wszPreviousContinuousLocation  = L"/"; // Initialize to the root location
    BOOL                        bLocationDiscontinuous         = FALSE;
    DWORD                       dwTempLastSaveChangeNumber     = 0;
    DWORD                       dwTempLastSaveMetabaseVersion  = 0;
    FILETIME                    fileTime;
    BOOL                        bSchemaFileNotFound            = FALSE;
    BOOL                        bReadSchemaFromSchemaBin       = TRUE;
    BOOL                        bMRLock                        = false;

    if( !pszPasswd && !pszBackupLocation )
    {
        strReadFileName = g_strRealFileName->QueryStr();
    }
    else
    {
        //
        // Restore
        //
        strReadFileName = pszBackupLocation;
    }

    if(!pszPasswd && !pszSchemaLocation )
    {
        strSchemaFileName = g_strSchemaFileName->QueryStr();
    }
    else
    {
        //
        // Restore
        //
        strSchemaFileName = pszSchemaLocation;
    }

    //
    // Get full unicode file name for data file i.e. metabase.xml
    //

    hr = GetUnicodeName(strReadFileName, &wszDataFileName);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] GetUnicodeName failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // Get full file name for schema file i.e. mbschema.xml
    //

    hr = GetUnicodeName(strSchemaFileName, &wszSchemaFileName);

    DBGINFOW((DBG_CONTEXT,
              L"[ReadAllDataFromXML]\nDataFileName:%s\nSchemaFileName:%s\n",
              wszDataFileName,
              wszSchemaFileName));

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] GetUnicodeName failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    if (!bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    //
    // Lock the metabase
    //

    g_LockMasterResource.WriteLock();
    bMRLock = true;

    //
    // TODO:
    // g_dwMajorVersionNumber = dwTemp;
    // g_dwMinorVersionNumber = dwTemp;
    // g_dwSystemChangeNumber = dwTemp;
    //

    //
    // Set the global values to their defaults, so that even if they aren't
    // present in the XML file, they are correctly initialized.
    // Also initializes the dispenser and the bin file path.
    //

    hr = InitializeIIS6GlobalsToDefaults(1,1,pszBackupLocation);

    //
    // Compile the schema bin file if needed and initialize g_pGlobalISTHelper
    //

    hr = CompileIfNeeded(wszDataFileName, wszSchemaFileName, &bSchemaFileNotFound);

    if(FAILED(hr))
    {
        goto exit;
    }


    if(bSchemaFileNotFound)
    {
        //
        // If schema file is not found, set the schema change numbers to differ
        // so that a compilation is forced. If schema file is not found and the
        // schema tree is in the xml, we will read the schema tree from the xml
        // hence we will need to force a compile during savealldata to merge
        // the xml schema and the shippped schema..
        //

        g_dwLastSchemaChangeNumber = 0;

    }

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Get the property table.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    QueryCell[0].pData     = (LPVOID)g_pGlobalISTHelper->m_wszBinFileForMeta;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_SCHEMAFILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = 0;

    QueryCell[1].pData     = (LPVOID)wszDataFileName;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iST_CELL_FILE;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = (lstrlenW(wszDataFileName)+1)*sizeof(WCHAR);


    hr = pISTDisp->GetTable(wszDATABASE_METABASE,
                            wszTABLE_MBProperty,
                            (LPVOID)QueryCell,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID *)&pISTProperty);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] GetTable failed with hr = 0x%x.\n",hr));



        goto exit;
    }

    hr = InitializeGlobalsFromXML(pISTProperty,
                                  wszDataFileName,
                                  wszSchemaFileName,
                                  &pStorage,
                                  pszPasswd,
                                  pszBackupLocation ? TRUE : FALSE,
                                  &fileTime);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Need to determine where to read the schema from.
    // In upgrade scenarios from IIS5.0/5.1 to 6.0 ReadAllDataFromBin is called
    // which reads the schema tree from the metabase.bin file.
    // In upgrade scenarios from IIS6.0 Beta1 builds (where schema is stored in
    // the metabase.xml file) to IIS6.0 Beta2 builds (where schema is stored in
    // mbschema.XML files) a compile is done, but schema is still read from the
    // metabase.XML file.
    // Setup needs to force a save in these scenarios so that the schema that is
    // read (from either metabase.bin or metabase.xml) can be merged with the
    // shipped schema to generate a unified mbschema.bin and mbschema.xml file.
    //

    if(bSchemaFileNotFound && SchemaTreeInTable(pISTProperty))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] Should not be reading from schema bin.\n"));

        bReadSchemaFromSchemaBin = FALSE;
    }

    if(bReadSchemaFromSchemaBin)
    {
        //
        // Read the schema tree from the .bin
        //

        hr = ReadSchema(pStorage,
                        &fileTime);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // All of the stuff is read into pISTProperty.
    // Now loop through and populate in-memory cache
    //

    for(i=0; ;i++)
    {
        LPVOID  a_pv[cMBProperty_NumberOfColumns];
        ULONG   a_Size[cMBProperty_NumberOfColumns];
        ULONG   a_iCol[] = {iMBProperty_Name,
                            iMBProperty_Location,
                            iMBProperty_ID,
                            iMBProperty_Attributes,
                            iMBProperty_UserType,
                            iMBProperty_Type,
                            iMBProperty_Value,
                            iMBProperty_LocationID};
        ULONG   cCol = sizeof(a_iCol)/sizeof(ULONG);
        BOOL    bLocationWithProperty   = TRUE;
        BOOL    bNewLocation            = FALSE;
        BOOL    bIsRoot                 = FALSE;

        hr = pISTProperty->GetColumnValues(i,
                                           cCol,
                                           a_iCol,
                                           a_Size,
                                           a_pv);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReadAllDataFromXML] GetColumnValues failed with hr = 0x%x. Table:%s. Read row index:%d.\n",           \
                      hr, wszTABLE_MBProperty, i));

            goto exit;
        }
        else if((0 == wcscmp(MD_GLOBAL_LOCATIONW, (LPWSTR)a_pv[iMBProperty_Location])) ||
                (bReadSchemaFromSchemaBin && (0 == _wcsnicmp((LPWSTR)a_pv[iMBProperty_Location], g_wszSlashSchema, g_cchSlashSchema)))
               )
        {
            //
            // Ignore globals.
            //

            //
            // Ignore the schema tree if it has been read from bin,
            //

            continue;
        }

        if((*(DWORD*)a_pv[iMBProperty_ID] == MD_LOCATION) && (*(LPWSTR)a_pv[iMBProperty_Name] == MD_CH_LOC_NO_PROPERTYW))
        {
            bLocationWithProperty = FALSE;
        }

        if(dwPreviousLocationID != *(DWORD*)a_pv[iMBProperty_LocationID])
        {
            bNewLocation = TRUE;
            dwPreviousLocationID = *(DWORD*)a_pv[iMBProperty_LocationID];

            bLocationDiscontinuous = DiscontinuousLocation(wszPreviousContinuousLocation,
                                                           (LPWSTR)a_pv[iMBProperty_Location]);

            if(!bLocationDiscontinuous)
            {
                wszPreviousContinuousLocation  = (LPWSTR)a_pv[iMBProperty_Location];
            }
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[ReadAllDataFromXML] Encountered discontinuous location:%s. Ignoring this and all locations below it.\n",           \
                          (LPWSTR)a_pv[iMBProperty_Location]));

                LogEvent(g_pEventLog,
                         MD_WARNING_IGNORING_DISCONTINUOUS_NODE,
                         EVENTLOG_WARNING_TYPE,
                         ID_CAT_CAT,
                         ERROR_INVALID_DATA,
                         (LPWSTR)a_pv[iMBProperty_Location]);
            }
        }

        if(bLocationDiscontinuous)
        {
            //
            // Properties are sorted by location. If you have a discontinous location, the ignore it.
            //

            continue;
        }

        //
        // TODO: Need to assert when bLocationWithProperty == FALSE, then bNewLocation must == TRUE
        //

        if(0 == wcscmp((LPWSTR)a_pv[iMBProperty_Location], L"/"))
        {
            bIsRoot = TRUE;
        }

        if(bNewLocation && (!bIsRoot))  // No need to read meta object for root - g_pboMasterRoot already present.
        {
            hr = ReadMetaObject(pboRead,
                                (LPWSTR)a_pv[iMBProperty_Location],
                                &fileTime,
                                TRUE);

            if(FAILED(hr))
            {
                if (hr == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY))
                {
                    //
                    // Serious error, we're done.
                    //

                    goto exit;
                }
                else
                {
                    //
                    // Just give a warning and go to the next object
                    //

                    hresWarningCode = hr;
                    continue;
                }
            }
        }

        if(bLocationWithProperty)
        {
            if(!bIsRoot)
            {
                hr = ReadDataObject(pboRead,
                                    a_pv,
                                    a_Size,
                                    pStorage,
                                    TRUE);
            }
            else
            {
                hr = ReadDataObject(g_pboMasterRoot,
                                    a_pv,
                                    a_Size,
                                    pStorage,
                                    TRUE);

            }

            if(FAILED(hr))
            {
                if (hr == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY))
                {
                    //
                    // Serious error, we're done.
                    //

                    goto exit;
                }
                else
                {
                    //
                    // Just give a warning and go to the next object
                    //

                    hresWarningCode = hr;
                    continue;
                }
            }
        }

    }

exit:

    //
    // Must have MasterResource when accessing SystemChangeNumber
    // so save it away here. Only update LastSaveChangeNumber on success.
    //

    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;

    //
    // Save the version number as well.
    //
    dwTempLastSaveMetabaseVersion = g_ulHistoryMajorVersionNumber;


    if(bMRLock)
    {
        g_LockMasterResource.WriteUnlock();
        bMRLock = false;
    }

    //
    // If the file is not found we either read from the bin file
    // (if it is present like in an upgrade scenario, or we fail.
    //

    if ((SUCCEEDED(hr)) && (hresWarningCode != ERROR_SUCCESS))
    {
        hr = GetWarning(hresWarningCode);
    }

    if (SUCCEEDED(hr))
    {
        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    if(SUCCEEDED(hr) && (NULL == pszBackupLocation))
    {
        //
        // Initialize last write timestamp. Do not initialize for the restore scenario.
        //

        WIN32_FILE_ATTRIBUTE_DATA  CurrentMetabaseTempFileAttr;
        FILETIME*                  pCurrentMetabaseLastWriteTimeStamp = NULL;

        if(!GetFileAttributesExW(wszDataFileName,
                                 GetFileExInfoStandard,
                                 &CurrentMetabaseTempFileAttr)
          )
        {
            //
            // Could not fetch the current file attributes for the temporary metabase file.
            // The file timestamp will remain initialized to zero - this will force a sav.
            //

#if DBG
            DWORD   dwRes = GetLastError();
            HRESULT hrSav = RETURNCODETOHRESULT(dwRes);

            DBGINFOW((DBG_CONTEXT,
                     L"[ReadAllDataFromXML] Could not fetch the current file attributes for the temporary metabase file. GetFileAttributesEx on %s failed with hr = 0x%x.\n",
                     wszDataFileName,
                     hrSav));
#endif
        }
        else
        {
            pCurrentMetabaseLastWriteTimeStamp = &CurrentMetabaseTempFileAttr.ftLastWriteTime;
        }

        EnterCriticalSection(&g_csEditWhileRunning);
        if(NULL != pCurrentMetabaseLastWriteTimeStamp)
        {
            g_MostRecentMetabaseFileLastWriteTimeStamp = CurrentMetabaseTempFileAttr.ftLastWriteTime;
        }
        else
        {
            memset((LPVOID)&g_MostRecentMetabaseFileLastWriteTimeStamp, 0, sizeof(FILETIME));
        }
        g_ulMostRecentMetabaseVersion              = dwTempLastSaveMetabaseVersion;
        LeaveCriticalSection(&g_csEditWhileRunning);

    }


    if((SUCCEEDED(hr))                &&
       (NULL == pszBackupLocation)
      )
    {
        //
        // Note the global handle array is initialized in
        // InitializeIIS6GlobalsToDefaults
        //

        if(!g_dwEnableEditWhileRunning)
        {
            // Write lock the file only if EWR is disabled and it is a
            // ReadAllData that is called from service startup and not
            // from Restore.
            //

            hr = LockMetabaseFile(wszDataFileName,
                                  eMetabaseDataFile,
                                  TRUE);

            DBGINFOW((DBG_CONTEXT,
                      L"[ReadAllDataFromXML] Locking metabase file %s returned 0x%x.\n",
                      wszDataFileName,
                      hr));

            if(SUCCEEDED(hr))
            {
                hr = LockMetabaseFile(wszSchemaFileName,
                                      eMetabaseSchemaFile,
                                      TRUE);

                DBGINFOW((DBG_CONTEXT,
                          L"[ReadAllDataFromXML] Locking metabase file %s returned 0x%x.\n",
                          wszSchemaFileName,
                          hr));

            }
        }

    }

    //
    // Cleanup
    //

    if (!bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if(NULL != pISTProperty)
    {
        pISTProperty->Release();
        pISTProperty = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    if(NULL != wszDataFileName)
    {
        delete [] wszDataFileName;
        wszDataFileName = NULL;
    }

    if(NULL != wszSchemaFileName)
    {
        delete [] wszSchemaFileName;
        wszSchemaFileName = NULL;
    }

    return hr;
}


HRESULT
ReadAllDataFromBin(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   BOOL bHaveReadSaveSemaphore
                   )
/*++

Routine Description:

    Reads all meta data from the original bin file.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarningCode = ERROR_SUCCESS;
    PBYTE  pbEndReadData;
    PBYTE  pbNextPtr;
    DWORD  dwLineLen;
    LPTSTR strReadFileName;
    HANDLE hReadFileHandle = INVALID_HANDLE_VALUE;
    BYTE   bLineId = MD_ID_NONE;
    DWORD  dwTemp;
    DWORD  dwError;
    CMDBaseObject *pboRead;
    FILETIME ftTime;
    IIS_CRYPTO_STORAGE *pStorage = NULL;
    BOOL bUnicode = TRUE;
    DWORD dwTempLastSaveChangeNumber = 0;
    STR*  strRealBinFileName = NULL;
    LPWSTR wszFileName = NULL;

    BUFFER *pbufRead = new BUFFER(0);
    if( !pbufRead )
    {
        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    BUFFER *pbufLine = new BUFFER(0);
    if( !pbufLine )
    {
        delete pbufRead;
        pbufRead = NULL;

        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    if( !pszPasswd )
    {
        TCHAR*  szBin = NULL;
        TCHAR*  szEnd = NULL;
        TCHAR   chDot = (TCHAR)'.';
        TCHAR*   szBinExtn = (TCHAR*)"bin";

        szBin = new TCHAR[_tcslen(g_strRealFileName->QueryStr())+1];
        if(NULL == szBin)
        {
            delete(pbufRead);
            delete(pbufLine);
            return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
        }
        else
        {
            _tcscpy(szBin, (g_strRealFileName->QueryStr()));
            szEnd = _tcsrchr(szBin, chDot);
            *(++szEnd) = (TCHAR)'\0';
            _tcscat(szBin, szBinExtn);
            strRealBinFileName = new STR(szBin);
            delete [] szBin;

            if(NULL == strRealBinFileName)
            {
                delete(pbufRead);
                delete(pbufLine);
                return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
            }
            else
                strReadFileName = strRealBinFileName->QueryStr();
        }
    }
    else
    {
        strReadFileName = pszBackupLocation;
    }

    hresReturn = GetUnicodeName(strReadFileName, &wszFileName);

    if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromBin] GetUnicodeName failed with hr = 0x%x.\n",hresReturn));
        delete(pbufRead);
        delete(pbufLine);
        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    hresReturn = InitializeIIS6GlobalsToDefaults(0,1,pszBackupLocation);

    if(FAILED(hresReturn))
    {
        delete(pbufRead);
        delete(pbufLine);
        delete [] wszFileName;
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromBin] InitializeIIS6GlobalsToDefaults failed with hr = 0x%x.\n",hresReturn));
        return hresReturn;
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    //
    // Open the file.
    //
    hReadFileHandle = CreateFile(strReadFileName,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 0);

    if ((hReadFileHandle == INVALID_HANDLE_VALUE) || (hReadFileHandle == NULL)) {
        dwError = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwError);
    }
    else {
        //
        // Allocate Buffers
        //
        if (!pbufLine->Resize(MAX_RECORD_BUFFER) ||
            !pbufRead->Resize(READWRITE_BUFFER_LENGTH)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            pbEndReadData = (PBYTE)pbufRead->QueryPtr();
            //
            // GetNextLine makes sure that the next line is in the buffer and sets strCurPtr to point to it
            // The line is NULL terminated, no new line. The variables passed in must not be modified outside
            // of GetNextLine.
            //
            dwLineLen = 0;
            pbNextPtr = pbEndReadData;
            hresReturn = GetNextLine(hReadFileHandle,
                                  pbEndReadData,
                                  pbufRead,
                                  pbufLine,
                                  dwLineLen,
                                  pbNextPtr);
            if (SUCCEEDED(hresReturn)) {
                //
                // See if it's our file
                //
                if (dwLineLen == sizeof(MD_SIGNATURE_STRINGA) &&
                    (MD_CMP(MD_SIGNATURE_STRINGA, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = FALSE;
                }
                else if  (dwLineLen == sizeof(MD_SIGNATURE_STRINGW) &&
                    (MD_CMP(MD_SIGNATURE_STRINGW, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = TRUE;
                }
                else {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }

                if (SUCCEEDED(hresReturn)) {
                    //
                    // The first GetNextLine filled the buffer
                    // so we may not need to do any file system stuff
                    // with g_LockMasterResource locked.
                    //
                    g_LockMasterResource.WriteLock();

                    while ((SUCCEEDED(hresReturn)) &&
                           (SUCCEEDED(hresReturn = GetNextLine(hReadFileHandle,
                                                   pbEndReadData,
                                                   pbufRead,
                                                   pbufLine,
                                                   dwLineLen,
                                                   pbNextPtr))) &&
                           (dwLineLen > 0) &&
                           (((bLineId = *(BYTE *)(pbufLine->QueryPtr())) == MD_ID_NONE) ||
                               (bLineId == MD_ID_MAJOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_MINOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_CHANGE_NUMBER) ||
                               (bLineId == MD_ID_SESSION_KEY))) {

                        if (bLineId != MD_ID_NONE) {
                            if (bLineId != MD_ID_SESSION_KEY &&
                                dwLineLen != (1 + sizeof(DWORD))) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                            }
                            else {
                                dwTemp = *(UNALIGNED DWORD *)FIRSTDATAPTR(pbufLine);
                                switch (bLineId) {
                                case MD_ID_MAJOR_VERSION_NUMBER:
                                    g_dwMajorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_MINOR_VERSION_NUMBER:
                                    g_dwMinorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_CHANGE_NUMBER:
                                    g_dwSystemChangeNumber = dwTemp;
                                    break;
                                case MD_ID_SESSION_KEY:
                                    {
                                        BOOL    fSecuredRead = TRUE;
                                        HKEY    hkRegistryKey = NULL;
                                        DWORD   dwRegReturn, dwValue,dwType,dwSize = sizeof(DWORD);

                                            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                                                     SETUP_REG_KEY,
                                                                     &hkRegistryKey);
                                            if (dwRegReturn == ERROR_SUCCESS)
                                            {
                                                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                                                MD_UNSECUREDREAD_VALUE,
                                                                NULL,
                                                                &dwType,
                                                                (BYTE *)&dwValue,
                                                                &dwSize);
                                                if ( dwRegReturn == ERROR_SUCCESS &&
                                                     dwType == REG_DWORD &&
                                                     dwValue == 1)
                                                {
                                                    hresReturn = NO_ERROR;
                                                    pStorage = NULL;
                                                    fSecuredRead = FALSE;

                                                    DBGPRINTF(( DBG_CONTEXT,
                                                                "Temporary disabling  decryption for metabase read\n"));


                                                    // special indicator for IIS setup that we passed this point
                                                    dwValue = 2;
                                                    dwRegReturn = RegSetValueEx(hkRegistryKey,
                                                                    MD_UNSECUREDREAD_VALUE,
                                                                    0,
                                                                    REG_DWORD,
                                                                    (PBYTE)&dwValue,
                                                                    sizeof(dwValue));
                                                    if (dwRegReturn == ERROR_SUCCESS)
                                                    {
                                                        DBGPRINTF(( DBG_CONTEXT,"Reanabling decryption after W9z upgrade\n"));
                                                    }

                                                }
                                                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
                                            }

                                        if (fSecuredRead)
                                        {
                                            if (IISCryptoIsClearTextSignature((IIS_CRYPTO_BLOB UNALIGNED *) FIRSTDATAPTR(pbufLine)))
                                            {
                                                    // call special function focibly tell that this machine has no
                                                    // encryption enabled even if it happens to be so
                                                    // that's a special handling for French case with US locale
                                                    IISCryptoInitializeOverride (FALSE);
                                            }

                                            if( !pszPasswd )
                                            {
                                                hresReturn = InitStorageHelper(
                                                               FIRSTDATAPTR(pbufLine),
                                                               dwLineLen-1,
                                                               &pStorage
                                                               );
                                             }
                                             else
                                             {
                                                hresReturn = InitStorageHelper2(
                                                               pszPasswd,
                                                               FIRSTDATAPTR(pbufLine),
                                                               dwLineLen-1,
                                                               &pStorage
                                                               );
                                             }
                                        }
                                    }
                                    break;
                                default:
                                    MD_ASSERT(FALSE);
                                }
                            }
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {

                        //
                        // This must be the global master object
                        //
                        if ((dwLineLen != 1 + sizeof(FILETIME)) || (bLineId != MD_ID_ROOT_OBJECT)) {
                            //
                            // This file is hosed
                            //
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                        else {
                            //
                            // Got the MasterRoot Object.
                            //

                            ftTime = *(UNALIGNED FILETIME *)FIRSTDATAPTR(pbufLine);
                            g_pboMasterRoot->SetLastChangeTime(&ftTime);
                            //
                            // Read in MasterRoot Data.
                            //
                            for (hresReturn = GetNextLine(hReadFileHandle,
                                                  pbEndReadData,
                                                  pbufRead,
                                                  pbufLine,
                                                  dwLineLen,
                                                  pbNextPtr);
                                ((SUCCEEDED(hresReturn)) && (dwLineLen != 0)
                                && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr)) {
                                if (bLineId == MD_ID_DATA) {

                                    hresReturn = ReadDataObject( g_pboMasterRoot,
                                                                 pbufLine,
                                                                 dwLineLen,
                                                                 pStorage,
                                                                 bUnicode
                                                                 );
                                }
                            }
                        }
                    }
                    //
                    // All of the required stuff is read in, and the next line is either
                    // NULL or the first normal object.
                    // Loop through all normal objects.
                    //
                    if (SUCCEEDED(hresReturn)) {
                        while ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                            MD_ASSERT(bLineId == MD_ID_OBJECT);
                            for (hresReturn = ReadMetaObject(pboRead,
                                                           pbufLine,
                                                           dwLineLen,
                                                           pStorage,
                                                           bUnicode);
                                (FAILED(hresReturn));
                                hresReturn = ReadMetaObject(pboRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pStorage,
                                                          bUnicode)) {
                                //
                                // This for loop normally shouldn't be executed.
                                // The purpose of the loop is to ignore problems if
                                // the object is bad.
                                //
                                if (hresReturn == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                    //
                                    // Serious error, we're done.
                                    //
                                    break;
                                }
                                else {
                                    //
                                    // Just give a warning and go to the next object
                                    // Ignore everything until we get to the next object
                                    //
                                    hresWarningCode = hresReturn;

                                    for (hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr);
                                        ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                        && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                        hresReturn = GetNextLine(hReadFileHandle,
                                                              pbEndReadData,
                                                              pbufRead,
                                                              pbufLine,
                                                              dwLineLen,
                                                              pbNextPtr)) {

                                    }
                                    if (dwLineLen == 0) {
                                        //
                                        // EOF, we're done
                                        //
                                        break;
                                    }
                                }
                            }
                            if ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                                //
                                // Got an object.
                                // Read in data.
                                //
                                for (hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr);
                                    ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                    //
                                    // GetLineID increments strCurPtr if a match is found
                                    //
                                    && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                    hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr)) {
                                    if (bLineId == MD_ID_DATA) {
                                        hresReturn = ReadDataObject( pboRead,
                                                                     pbufLine,
                                                                     dwLineLen,
                                                                     pStorage,
                                                                     bUnicode
                                                                     );

                                        //
                                        // dwReturn gets blown away by the for loop.
                                        // Most errors we can just ignore anyway, but
                                        // save a warning.
                                        //
                                        if (FAILED(hresReturn)) {
                                            if (hresReturn != RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                                hresWarningCode = hresReturn;
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;
                    g_LockMasterResource.WriteUnlock();
                }
            }
            if (!CloseHandle(hReadFileHandle)) {
                dwError = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwError);
            }
            hReadFileHandle = INVALID_HANDLE_VALUE;
        }
    }
    //
    // File not found is ok
    // Start with MasterRoot only
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {
        hresReturn = ERROR_SUCCESS;
    }

    if ((SUCCEEDED(hresReturn)) && (hresWarningCode != ERROR_SUCCESS)) {
        hresReturn = GetWarning(hresWarningCode);
    }

    if (SUCCEEDED(hresReturn)) {
        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    //
    // Cleanup
    //
    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }
    delete(pbufRead);
    delete(pbufLine);
    delete(pStorage);
    if(NULL != wszFileName)
    {
        delete [] wszFileName;
    }

    if ((hReadFileHandle != INVALID_HANDLE_VALUE) && (hReadFileHandle != NULL))
    {
        CloseHandle(hReadFileHandle);
        hReadFileHandle = INVALID_HANDLE_VALUE;
    }

    return hresReturn;
}

VOID
InitializeGlobalsToNull()
{
    DWORD                   i;

    g_pboMasterRoot = NULL;
    g_phHandleHead = NULL;

    for ( i = 0; i < EVENT_ARRAY_LENGTH; i++ )
    {
        g_phEventHandles[i] = NULL;
    }

    g_mhHandleIdentifier = METADATA_MASTER_ROOT_HANDLE;
    g_ppbdDataHashTable = NULL;
    g_dwSystemChangeNumber = 0;
    g_strRealFileName = NULL;
    g_strTempFileName = NULL;
    g_strBackupFileName = NULL;
    g_pstrBackupFilePath = NULL;
    g_strSchemaFileName = NULL;

    memset( &g_XMLSchemaFileTimeStamp, 0, sizeof(FILETIME) );
    memset( &g_BINSchemaFileTimeStamp, 0, sizeof(FILETIME) );

    EnterCriticalSection( &g_csEditWhileRunning );
    memset( &g_MostRecentMetabaseFileLastWriteTimeStamp, 0, sizeof(FILETIME) );
    memset( &g_EWRProcessedMetabaseTimeStamp, 0, sizeof(FILETIME) );
    g_bSavingMetabaseFileToDisk = FALSE;
    g_ulMostRecentMetabaseVersion = 0;
    LeaveCriticalSection( &g_csEditWhileRunning );

    InitializeUnicodeGlobalDataFileValues();

    g_pGlobalISTHelper = NULL;
    g_pListenerController = NULL;
    g_pEventLog = NULL;

    g_psidSystem = NULL;
    g_psidAdmin = NULL;
    g_paclDiscretionary = NULL;
    g_psdStorage = NULL;
}



HRESULT
InitWorker(
    IN BOOL             bHaveReadSaveSemaphore,
    IN LPSTR            pszPasswd,
    IN LPSTR            pszBackupLocation,
    IN LPSTR            pszSchemaLocation)
{
    HRESULT                 hr = S_OK;
    ISimpleTableDispenser2  * pISTDisp   = NULL;
    IAdvancedTableDispenser * pISTAdvanced = NULL;
    DWORD                   i;
    DWORD                   dwOld;
    DWORD                   dwNew;
    bool                    fReadLocked = true; // This has to be bool, otherwise compiler gives a warning

    DBGPRINTF(( DBG_CONTEXT,
                "Enter InitWorker g_dwInitialized = %d\n",
                g_dwInitialized ));

    // TryWriteLock gives us 2 very important benefits:
    // 1. If we can lock exclusive we can skip the smarts bellow.
    // 2. If the caller already has acquired write lock we must recursively write lock.
    if ( !g_LockMasterResource.TryWriteLock() )
    {
        g_LockMasterResource.ReadLock();

        DBGPRINTF(( DBG_CONTEXT,
                    "InitWorker ReadLock\n" ));

        dwOld = g_dwInitialized;

        // If we are not about to add the 1st reference
        while ( dwOld != 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "InitWorker Old = %d\n",
                        dwOld ));

            dwNew = (DWORD)InterlockedCompareExchange( (LONG*)&g_dwInitialized,
                                                       dwOld+1,
                                                       dwOld );
            DBGPRINTF(( DBG_CONTEXT,
                        "InitWorker Old = %d New = %d\n",
                        dwOld,
                        dwNew ));

            if ( dwOld == dwNew )
            {
                // We added a reference that was not the 1st one.
                // We are done
                hr = g_hresInitWarning;

                DBGPRINTF(( DBG_CONTEXT,
                            "InitWorker Done hr = 0x%08x g_dwInitialized = %d\n",
                            hr,
                            g_dwInitialized ));
                goto exit;
            }

            // Somebody else was faster than us. Retry.
            dwOld = dwNew;
        }

        // We are about to add the 1st reference.
        // It must happend under a write lock.
        // Note that other reader/writers might do something with g_dwInitialized meanwhile
        g_LockMasterResource.ConvertSharedToExclusive();
    }

    DBGPRINTF(( DBG_CONTEXT,
                "InitWorker WriteLock\n" ));

    // Either through success of TryWriteLock() or via ConvertSharedToExclusive()
    // we have a write lock
    fReadLocked = false;

    dwNew = (DWORD)InterlockedIncrement( (LONG*)&g_dwInitialized );
    if ( dwNew != 1 )
    {
        // We added a reference that was not the 1st one.
        // We are done
        hr = g_hresInitWarning;

        DBGPRINTF(( DBG_CONTEXT,
                    "InitWorker Done hr = 0x%08x g_dwInitialized = %d\n",
                    hr,
                    g_dwInitialized ));

        goto exit;
    }

    InitializeGlobalsToNull();

    g_pboMasterRoot = new CMDBaseObject(MD_MASTER_ROOT_NAME);
    if ( ( g_pboMasterRoot == NULL ) || ( !g_pboMasterRoot->IsValid() ) )
    {
        IIS_PRINTF(( buff, "Unable to allocate CMDBaseObject\n" ));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    g_pboMasterRoot->SetParent(NULL);

    g_phHandleHead = new CMDHandle( g_pboMasterRoot,
                                    METADATA_PERMISSION_READ,
                                    g_dwSystemChangeNumber,
                                    g_mhHandleIdentifier++,
                                    FALSE );
    if (g_phHandleHead == NULL)
    {
        IIS_PRINTF(( buff, "Unable to allocate CMDHandle\n" ));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    g_phHandleHead->SetNextPtr(NULL);

    g_phEventHandles[EVENT_READ_INDEX] = IIS_CREATE_EVENT( "g_phEventHandles[EVENT_READ_INDEX]",
                                                           &g_phEventHandles[EVENT_READ_INDEX],
                                                           TRUE,
                                                           FALSE );
    if ( g_phEventHandles[EVENT_READ_INDEX] == NULL )
    {
        hr = GetLastHResult();
        IIS_PRINTF(( buff, "CreateEvent Failed with %x\n",hr ));
        goto cleanup;
    }

    g_phEventHandles[EVENT_WRITE_INDEX] = IIS_CREATE_EVENT( "g_phEventHandles[EVENT_WRITE_INDEX]",
                                                            &g_phEventHandles[EVENT_WRITE_INDEX],
                                                            TRUE,
                                                            FALSE );
    if( g_phEventHandles[EVENT_WRITE_INDEX] == NULL )
    {
        hr = GetLastHResult();
        IIS_PRINTF(( buff, "CreateEvent Failed with %x\n", hr ));
        goto cleanup;
    }

    g_ppbdDataHashTable = new CMDBaseData *[DATA_HASH_TABLE_LEN];
    if ( g_ppbdDataHashTable == NULL)
    {
        IIS_PRINTF(( buff, "Unable to allocate CMDBaseData\n" ));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    for ( i=0; i < DATA_HASH_TABLE_LEN; i++ )
    {
        g_ppbdDataHashTable[i] = NULL;
    }

    hr = InitBufferPool();
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    // Code Work:
    // There is a conceiveable deadlock if ReadAllData is called with g_LockMasterResource Locked,
    // due to the semaphore used to control file access. Would like to release g_LockMasterResource,
    // but that could cause duplicate inits.
    hr = SetStorageSecurityDescriptor();
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    // Initialize logging object first
    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    hr = pISTDisp->QueryInterface( IID_IAdvancedTableDispenser,
                                   (LPVOID*)&pISTAdvanced );

    pISTDisp->Release();
    pISTDisp = NULL;
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    hr = pISTAdvanced->GetCatalogErrorLogger( &g_pEventLog );

    pISTAdvanced->Release();
    pISTAdvanced = NULL;
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    hr = SetDataFile();
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    hr = ReadAllData( pszPasswd, pszBackupLocation, pszSchemaLocation, bHaveReadSaveSemaphore );
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    // Check if the Major/Minor version needs to get updated...
    // if there is a specified version in the registry (set by iis setup during upgrade)
    // then use that new version, if it's not a dword, then use the default for g_dwMajorVersionNumber.
    CheckForNewMetabaseVersion();
    if ( !CheckVersionNumber() )
    {
        IIS_PRINTF(( buff, "MD: Invalid version number\n" ));
        hr = MD_ERROR_INVALID_VERSION;
        goto cleanup;
    }

    // Initialize the listener controller and depending on whether Edit
    // While running is enabled or disabled, start or stop it.
    hr = InitializeListenerController();
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

    if( g_dwEnableEditWhileRunning )
    {
        hr = g_pListenerController->Start();
    }
    else
    {
        hr = g_pListenerController->Stop( iSTATE_STOP_TEMPORARY,
                                          NULL);
    }
    if ( FAILED( hr ) )
    {
        goto cleanup;
    }

cleanup:
    // Cleanup
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "InitWorker Failed hr = 0x%08x!!!\n",
                    hr ));
        InterlockedDecrement( (LONG*)&g_dwInitialized );
        TerminateWorker();
    }

    // Save the return code.
    // Secondary init's repeat warnings.
    // If error, the next init will overwrite this.
    // So don't worry about setting this to errors.
    g_hresInitWarning = hr;

exit:
    g_LockMasterResource.ReadOrWriteUnlock( fReadLocked );

    DBGPRINTF(( DBG_CONTEXT,
                "InitWorker %sUnlock\n",
                fReadLocked ? "Read" : "Write" ));

    DBGPRINTF(( DBG_CONTEXT,
                "End InitWorker hr = 0x%08x g_dwInitialized = %d\n",
                hr,
                g_dwInitialized ));

    return hr;
}

HRESULT
TerminateWorker1(
    IN BOOL             bHaveReadSaveSemaphore)
{
    HRESULT             hr = S_OK;
    IIS_CRYPTO_STORAGE  CryptoStorage;
    PIIS_CRYPTO_BLOB    pSessionKeyBlob = NULL;
    HANDLE              hEditWhileRunningThread = NULL;
    DWORD               dwOld;
    DWORD               dwNew;
    bool                fReadLocked = true; // This has to be bool, otherwise compiler gives a warning

    DBGPRINTF(( DBG_CONTEXT,
                "Enter TerminateWorker1 g_dwInitialized = %d\n",
                g_dwInitialized ));
    // TryWriteLock gives us 2 very important benefits:
    // 1. If we can lock exclusive we can skip the smarts bellow.
    // 2. If the caller already has acquired write lock we must recursively write lock.
    if ( !g_LockMasterResource.TryWriteLock() )
    {
        g_LockMasterResource.ReadLock();
        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 ReadLock\n" ));

        dwOld = g_dwInitialized;

        // If we are not about to release the last reference
        while ( dwOld != 1 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "TerminateWorker1 Old = %d\n",
                        dwOld ));

            if ( dwOld == 0 )
            {
                hr = MD_ERROR_NOT_INITIALIZED;
                DBGPRINTF(( DBG_CONTEXT,
                            "TerminateWorker1 Not Initialized hr = 0x%08x!!!\n",
                            hr ));
                goto exit;
            }

            dwNew = (DWORD)InterlockedCompareExchange( (LONG*)&g_dwInitialized,
                                                       dwOld-1,
                                                       dwOld );
            DBGPRINTF(( DBG_CONTEXT,
                        "TerminateWorker1 Old = %d New = %d\n",
                        dwOld,
                        dwNew ));

            if ( dwOld == dwNew )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "TerminateWorker1 Done hr = 0x%08x g_dwInitialized = %d\n",
                            hr,
                            g_dwInitialized ));
                // We released a reference that was not the last one.
                // We are done
                goto exit;
            }

            // Somebody else was faster than us. Retry.
            dwOld = dwNew;
        }

        // We are about to release the last reference.
        // It must happend under a write lock.
        // Note that other readers/writers might do something with g_dwInitialized meanwhile
        g_LockMasterResource.ConvertSharedToExclusive();
    }

    // Either through success of TryWriteLock() or via ConvertSharedToExclusive()
    // we have a write lock
    fReadLocked = false;

    DBGPRINTF(( DBG_CONTEXT,
                "TerminateWorker1 WriteLock\n" ));

    if ( g_dwInitialized == 0 )
    {
        hr = MD_ERROR_NOT_INITIALIZED;
        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 Not Initialized hr = 0x%08x!!!\n",
                    hr ));
        goto exit;
    }

    if ( g_dwInitialized == 1 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 Stopping EWR\n" ));

        if ( g_pListenerController != NULL )
        {
            hr = g_pListenerController->Stop( iSTATE_STOP_PERMANENT,
                                              &hEditWhileRunningThread );
        }
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 Getting key\n" ));
        hr = InitStorageAndSessionKey( &CryptoStorage,
                                       &pSessionKeyBlob );
        if ( FAILED( hr ) )
        {
            // pretty serious.
            DBGPRINTF(( DBG_CONTEXT, "TerminateWorker1.InitStorageAndSessionKey:Failed - error 0x%0x\n", hr ));

            goto exit;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 Saving data\n" ));
        hr = SaveAllData( FALSE,
                          &CryptoStorage,
                          pSessionKeyBlob,
                          NULL,
                          NULL,
                          METADATA_MASTER_ROOT_HANDLE,
                          bHaveReadSaveSemaphore,
                          TRUE );
        if ( FAILED( hr ) )
        {
            goto exit;
        }
    }

    dwNew = (DWORD)InterlockedDecrement( (LONG*)&g_dwInitialized );
    if ( dwNew == 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 Last Terminate\n" ));
        TerminateWorker();
    }

exit:
    DBGPRINTF(( DBG_CONTEXT,
                "TerminateWorker1 %sUnlock\n",
                fReadLocked ? "Read" : "Write" ));

    g_LockMasterResource.ReadOrWriteUnlock( fReadLocked );
    if ( pSessionKeyBlob != NULL )
    {
        ::IISCryptoFreeBlob( pSessionKeyBlob );
        pSessionKeyBlob = NULL;
    }
    // Wait for the Edit while running thread to die before terminating
    // Note that we wait after the lock is released.
    if ( hEditWhileRunningThread != NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 Waiting for EWR\n" ));
        WaitForSingleObject( hEditWhileRunningThread, INFINITE );
        CloseHandle( hEditWhileRunningThread );
        hEditWhileRunningThread = NULL;
        DBGPRINTF(( DBG_CONTEXT,
                    "TerminateWorker1 EWR stopped\n" ));
    }
    DBGPRINTF(( DBG_CONTEXT,
                "End TerminateWorker1 hr = 0x%08x g_dwInitialized = %d\n",
                hr,
                g_dwInitialized ));
    return hr;
}

VOID
TerminateWorker()
/*++

Routine Description:

    Worker routine for termination.

Arguments:


Return Value:

    VOID

Notes:
--*/
{
    CMDHandle           *CurHandle;
    CMDHandle           *NextHandle;
    DWORD               i;

    for ( CurHandle = g_phHandleHead; CurHandle != NULL ; CurHandle = NextHandle )
    {
        NextHandle = CurHandle->GetNextPtr();
        delete CurHandle;
    }

    for ( i = 0; i < EVENT_ARRAY_LENGTH; i++ )
    {
        if ( g_phEventHandles[i] != NULL )
        {
            CloseHandle( g_phEventHandles[i] );
        }
    }

    if ( g_pboMasterRoot != NULL )
    {
        // Perf fix.
        g_pboMasterRoot->CascadingDataCleanup();
        delete g_pboMasterRoot;
    }

    // All data objects should be deleted by
    // deleting the handles and masterroot
    // but it's possible a client failed
    // to release a data by reference so
    // destroy all remaining data objects
    DeleteAllRemainingDataObjects();
    ReleaseStorageSecurityDescriptor();

    if ( g_ppbdDataHashTable != NULL )
    {
        delete [] g_ppbdDataHashTable;
    }

    if ( g_strRealFileName != NULL )
    {
        delete g_strRealFileName;
    }

    if ( g_strRealFileName != NULL )
    {
        delete g_strTempFileName;
    }

    if ( g_strRealFileName != NULL )
    {
        delete g_strBackupFileName;
    }

    if ( g_strRealFileName != NULL )
    {
        delete g_pstrBackupFilePath;
    }

    if ( g_strRealFileName != NULL )
    {
        delete g_strSchemaFileName;
    }

    UnInitializeUnicodeGlobalDataFileValues();

    if ( g_pGlobalISTHelper != NULL )
    {
        delete g_pGlobalISTHelper;
    }

    if ( g_pEventLog != NULL )
    {
        g_pEventLog->Release();
    }

    UnInitializeListenerController();
    DeleteBufferPool();

    InitializeGlobalsToNull();
}


HRESULT
SetStorageSecurityDescriptor()
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL status;
    DWORD dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PLATFORM_TYPE platformType;

    //
    // Verify that globals were initialized correctly.
    //


    MD_ASSERT(g_psidSystem == NULL);
    MD_ASSERT(g_psidAdmin == NULL);
    MD_ASSERT(g_paclDiscretionary == NULL);
    MD_ASSERT(g_psdStorage == NULL);

    //
    // Of course, we only need to do this under NT...
    //

    platformType = IISGetPlatformType();

    if( (platformType == PtNtWorkstation) || (platformType == PtNtServer ) ) {


        g_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (g_psdStorage == NULL) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     g_psdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }
        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidSystem)
                       - sizeof(DWORD);

        g_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if( g_paclDiscretionary == NULL ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = InitializeAcl(
                     g_paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     g_psdStorage,
                     TRUE,
                     g_paclDiscretionary,
                     FALSE
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }
    }

fatal:

    if (FAILED(hresReturn)) {
        ReleaseStorageSecurityDescriptor();

    }

    return hresReturn;

}

VOID
ReleaseStorageSecurityDescriptor()
{
    if( g_paclDiscretionary != NULL ) {
        LocalFree( g_paclDiscretionary );
        g_paclDiscretionary = NULL;
    }

    if( g_psidAdmin != NULL ) {
        FreeSid( g_psidAdmin );
        g_psidAdmin = NULL;

    }

    if( g_psidSystem != NULL ) {
        FreeSid( g_psidSystem );
        g_psidSystem = NULL;
    }

    if( g_psdStorage != NULL ) {
        LocalFree( g_psdStorage );
        g_psdStorage = NULL;
    }
}

HRESULT
ExtractNameFromPath(
         IN OUT LPSTR &strPath,
         OUT LPSTR strNameBuffer,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    LPSTR pszIndex;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (bUnicode) {
        LPWSTR wstrPath = (LPWSTR)strPath;
        hresReturn = ExtractNameFromPath(&wstrPath, (LPWSTR)strNameBuffer);
        strPath = (LPSTR) wstrPath;
    }
    else {
        if (strPath != NULL) {
            for (pszIndex = strPath;
                 ((pszIndex - strPath) < METADATA_MAX_NAME_LEN) && (*pszIndex != (TCHAR)'\0') &&
                    (*pszIndex != MD_PATH_DELIMETER) && (*pszIndex != MD_ALT_PATH_DELIMETER);
                 pszIndex = CharNextExA(CP_ACP,
                                        pszIndex,
                                        0)) {
            }
            DWORD dwStrBytes = (DWORD)DIFF(pszIndex - strPath);
            if ((dwStrBytes) >= METADATA_MAX_NAME_LEN) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
            }
            else {
                MD_COPY(strNameBuffer, strPath, dwStrBytes);
                strNameBuffer[dwStrBytes] = (TCHAR)'\0';
                strPath = pszIndex;
                if (*strNameBuffer != (TCHAR)'\0') {
                    //
                    // if a non-null name
                    //
                    SKIP_PATH_DELIMETERA(strPath);
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
ExtractNameFromPath(
         IN OUT LPWSTR *pstrPath,
         OUT LPWSTR strNameBuffer)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    int i;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (*pstrPath != NULL) {
        for (i = 0;
            (i < METADATA_MAX_NAME_LEN) && ((*pstrPath)[i] != (WCHAR)L'\0') &&
                ((*pstrPath)[i] != (WCHAR)MD_PATH_DELIMETER) && ((*pstrPath)[i] != (WCHAR)MD_ALT_PATH_DELIMETER);
            i++) {
            strNameBuffer[i] = (*pstrPath)[i];
        }
        if (i == METADATA_MAX_NAME_LEN) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
        }
        else {
            strNameBuffer[i] = (WCHAR)L'\0';
            *pstrPath += i;
            if (*strNameBuffer != (WCHAR)L'\0') {
                //
                // if a non-null name
                //
                SKIP_PATH_DELIMETERW(*pstrPath);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }
    return (hresReturn);
}

BOOL DataMatch(IN CMDBaseData *pbdExisting,
               IN PMETADATA_RECORD pmdrData,
               OUT PBOOL pbError,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Determines if a set of data maches an existing object.

Arguments:

    Existing   - The existing data object.

    Identifier - The Identifier of the data.

    Attributes - The flags for the data.
                      METADATA_INHERIT

    UserType   - The User Type for the data. User Defined.

    DataType   - The Type of the data.
                      DWORD_METADATA
                      STRING_METADATA
                      BINARY_METADATA

    DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.
                 Binary data must not exceed METADATA_MAX_BINARY_LEN bytes.
                 String data must not exceed METADATA_MAX_STRING_LEN characters,
                 include the trailing '\0'.

    Data       - Pointer to the data.


Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    BOOL bReturn = TRUE;
    BOOL bError = FALSE;

    if ((pmdrData->dwMDIdentifier != pbdExisting->GetIdentifier()) ||
        (pmdrData->dwMDAttributes != pbdExisting->GetAttributes()) ||
        (pmdrData->dwMDUserType != pbdExisting->GetUserType()) ||
        (pmdrData->dwMDDataType != pbdExisting->GetDataType())) {
        bReturn = FALSE;
    }
    else {
        if (pbdExisting->GetData(bUnicode) == NULL) {
            bError = TRUE;
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    if (*(DWORD *)(pmdrData->pbMDData) != *(DWORD *)(pbdExisting->GetData())) {
                        bReturn = FALSE;
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszStringData = (LPWSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = L"";
                        }
                        if (wcscmp(pszStringData, (LPWSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    else {
                        LPSTR pszStringData = (LPSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = "";
                        }
                        if (MD_STRCMP(pszStringData, (LPSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                case BINARY_METADATA:
                case MULTISZ_METADATA:
                {
                    if (pmdrData->dwMDDataLen != pbdExisting->GetDataLen(bUnicode)) {
                        bReturn = FALSE;
                    }
                    else {
                        if (MD_CMP(pmdrData->pbMDData, pbdExisting->GetData(bUnicode), pmdrData->dwMDDataLen) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                default: {
                    bReturn = FALSE;
                }
            }
        }
    }
    *pbError = bError;
    return (bReturn);
}

VOID
DeleteDataObject(
         IN CMDBaseData *pbdDelete)
/*++

Routine Description:

    Decrements the reference count of an object and deletes it if the reference count becomes 0.

Arguments:

    Delete      - The data object to delete.

Return Value:

Notes:

--*/
{
    DWORD dwHash = DATA_HASH(pbdDelete->GetIdentifier());
    CMDBaseData *pdataIndex;

    MD_ASSERT(pbdDelete != NULL);
    if (pbdDelete->DecrementReferenceCount() == 0) {
        if (g_ppbdDataHashTable[dwHash] == pbdDelete) {
            g_ppbdDataHashTable[dwHash] = pbdDelete->GetNextPtr();
        }
        else {
            for (pdataIndex=g_ppbdDataHashTable[dwHash];
                pdataIndex->GetNextPtr() != pbdDelete;
                pdataIndex = pdataIndex->GetNextPtr()) {
            }
            pdataIndex->SetNextPtr(pbdDelete->GetNextPtr());
        }
        switch (pbdDelete->GetDataType()) {
        case DWORD_METADATA: {
            delete ((CMDDWData *) pbdDelete);
            break;
        }
        case STRING_METADATA: {
            delete ((CMDSTRData *) pbdDelete);
            break;
        }
        case BINARY_METADATA: {
            delete ((CMDBINData *) pbdDelete);
            break;
        }
        case EXPANDSZ_METADATA: {
            delete ((CMDEXSZData *) pbdDelete);
            break;
        }
        case MULTISZ_METADATA: {
            delete ((CMDMLSZData *) pbdDelete);
            break;
        }
        default: {
            MD_ASSERT(FALSE);
            delete (pbdDelete);
        }
        }
    }
}

VOID
DeleteAllRemainingDataObjects()
{
    DWORD i;
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdSave;

    if ( g_ppbdDataHashTable == NULL )
    {
        return;
    }

    for (i = 0; i < DATA_HASH_TABLE_LEN; i++) {
        for (pbdIndex=g_ppbdDataHashTable[i];
            pbdIndex != NULL;
            pbdIndex = pbdSave) {
            pbdSave = pbdIndex->GetNextPtr();
            switch (pbdIndex->GetDataType()) {
            case DWORD_METADATA: {
                delete ((CMDDWData *) pbdIndex);
                break;
            }
            case STRING_METADATA: {
                delete ((CMDSTRData *) pbdIndex);
                break;
            }
            case BINARY_METADATA: {
                delete ((CMDBINData *) pbdIndex);
                break;
            }
            case EXPANDSZ_METADATA: {
                delete ((CMDEXSZData *) pbdIndex);
                break;
            }
            case MULTISZ_METADATA: {
                delete ((CMDMLSZData *) pbdIndex);
                break;
            }
            default: {
                MD_ASSERT(FALSE);
                delete (pbdIndex);
            }
            }
        }
    }
}


BOOL
ValidateData(IN PMETADATA_RECORD pmdrData,
             IN BOOL bUnicode)
/*++

Routine Description:

    Checks data values for new metadata.

Arguments:

    Data       - The data structure. All fields must be set.

        Attributes - The flags for the data.
                 METADATA_INHERIT - If set on input, inherited data will be returned.
                                    If not set on input, inherited data will not be returned.

                 METADATA_PARTIAL_PATH - If set on input, this routine will return ERROR_SUCCESS
                                    and the inherited data even if the entire path is not present.
                                    Only valid if METADATA_INHERIT is also set.

        DataType   - The Type of the data.
                 DWORD_METADATA
                 STRING_METADATA
                 BINARY_METADATA

Return Value:

    BOOL       - TRUE if the data values are valid.

Notes:
--*/
{
    BOOL                bReturn = TRUE;
    LPCWSTR             pwszData = NULL;
    LPCSTR              pszData = NULL;
    DWORD               dwDataLen = 0;
    DWORD               cch = 0;
    ULONG               i = 0;

    // Must not have NULL DWORD data
    if ( ( pmdrData->dwMDDataType == DWORD_METADATA ) &&
         ( pmdrData->pbMDData == NULL ) )
    {
        bReturn = FALSE;
        goto exit;
    }

    // Must not have NULL string (in all forms) or binary data
    // with size >0
    if ( ( ( pmdrData->dwMDDataType == BINARY_METADATA ) ||
           ( pmdrData->dwMDDataType == MULTISZ_METADATA ) ||
           ( pmdrData->dwMDDataType == EXPANDSZ_METADATA ) ||
           ( pmdrData->dwMDDataType == STRING_METADATA ) ) &&
         ( pmdrData->pbMDData == NULL ) &&
         ( pmdrData->dwMDDataLen > 0 ) )
    {
        bReturn = FALSE;
        goto exit;
    }

    // Must not have types outside the open interval (ALL_METADATA, INVALID_END_METADATA)
    if ( ( pmdrData->dwMDDataType <= ALL_METADATA ) ||
         ( pmdrData->dwMDDataType >= INVALID_END_METADATA ) )
    {
        bReturn = FALSE;
        goto exit;
    }

    // Must not have unknown flags
    if ( ( pmdrData->dwMDAttributes &
           ~( METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE | METADATA_VOLATILE | METADATA_INSERT_PATH | METADATA_LOCAL_MACHINE_ONLY ) ) !=0 )
    {
        bReturn = FALSE;
        goto exit;
    }

    // Must not have METADATA_INSERT_PATH together with METADATA_REFERENCE
    if ( ( ( pmdrData->dwMDAttributes & METADATA_REFERENCE ) != 0 ) &&
         ( ( pmdrData->dwMDAttributes & METADATA_INSERT_PATH ) != 0 ) )
    {
        bReturn = FALSE;
        goto exit;
    }


    // Must not have METADATA_INSERT_PATH with DWORD or binary data
    if ( ( ( pmdrData->dwMDDataType == DWORD_METADATA ) ||
           ( pmdrData->dwMDDataType == BINARY_METADATA ) ) &&
         ( ( pmdrData->dwMDAttributes & METADATA_INSERT_PATH ) != 0 ) )

    {
        bReturn = FALSE;
        goto exit;
    }

    // Check multi strings
    if ( pmdrData->dwMDDataType == MULTISZ_METADATA )
    {
        dwDataLen = pmdrData->dwMDDataLen;
        // If the data size is 0 it is Ok
        if ( dwDataLen == 0 )
        {
            goto exit;
        }

        if (bUnicode)
        {
            // The data size must be n*sizeof(WCHAR)
            if ( dwDataLen % sizeof(WCHAR) )
            {
                bReturn = FALSE;
                goto exit;
            }

            pwszData = (LPWSTR) pmdrData->pbMDData;
            cch = dwDataLen / sizeof(WCHAR);

            // The character count must be at least 2 (because the multi strings are double 0 terminated)
            // and the multi string must be double 0 terminated at the end
            if ( ( cch == 1 ) ||
                 ( pwszData[cch-1] != L'\0' ) ||
                 ( pwszData[cch-2] != L'\0' ) )
            {
                bReturn = FALSE;
                goto exit;
            }

            // If this is an empty multi string it is Ok
            if ( cch == 2 )
            {
                goto exit;
            }

            // Check for double 0 termination in the string excluding at the end, which is invalid
            for ( i=0; i<cch-2; i++ )
            {
                if ( ( pwszData[i] == L'\0') &&
                     ( pwszData[i+1] == L'\0') )
                {
                    // Encountered an embedded NULL string
                    bReturn = FALSE;
                    goto exit;
                }
            }
        }
        else
        {
            pszData = (LPSTR) pmdrData->pbMDData;
            cch = dwDataLen;

            // The character count must be at least 2 (because the multi strings are double 0 terminated)
            // and the multi string must be double 0 terminated at the end
            if ( ( cch == 1 ) ||
                 ( pszData[cch-1] != '\0' ) ||
                 ( pszData[cch-2] != '\0' ) )
            {
                bReturn = FALSE;
                goto exit;
            }

            // If this is an empty multi string it is Ok
            if ( cch == 2 )
            {
                goto exit;
            }

            // Check for double 0 termination in the string excluding at the end, which is invalid
            for ( i=0; i<cch-2; i++)
            {
                if ( ( pszData[i] == (CHAR)'\0' ) &&
                     ( pszData[i+1] == (CHAR)'\0' ) )
                {
                    // Encountered an embedded NULL string
                    bReturn = FALSE;
                    goto exit;
                }
            }
        }

        goto exit;
    }

    // Check strings and expand string, which must be at least well formed string
    if ( ( pmdrData->dwMDDataType == STRING_METADATA ) ||
         ( pmdrData->dwMDDataType == EXPANDSZ_METADATA ) )
    {
        dwDataLen = pmdrData->dwMDDataLen;
        // If the data size is 0 it is Ok
        if ( dwDataLen == 0 )
        {
            goto exit;
        }

        if (bUnicode)
        {
            // The data size must be n*sizeof(WCHAR)
            if ( dwDataLen % sizeof(WCHAR) )
            {
                bReturn = FALSE;
                goto exit;
            }

            pwszData = (LPWSTR) pmdrData->pbMDData;
            cch = dwDataLen / sizeof(WCHAR);

            // The string must be 0 terminated
            if ( pwszData[cch-1] != L'\0' )
            {
                bReturn = FALSE;
                goto exit;
            }

            // If this is an empty string it is Ok
            if ( cch == 1 )
            {
                goto exit;
            }

            // Check for 0 termination in the string before the end, which is invalid
            if ( wcslen( pwszData ) != cch-1 )
            {
                // Encountered an embedded NULL
                bReturn = FALSE;
                goto exit;
            }
        }
        else
        {
            pszData = (LPSTR) pmdrData->pbMDData;
            cch = dwDataLen;

            // The string must be 0 terminated
            if ( pszData[cch-1] != '\0' )
            {
                bReturn = FALSE;
                goto exit;
            }

            // If this is an empty string it is Ok
            if ( cch == 1 )
            {
                goto exit;
            }

            // Check for 0 termination in the string before the end, which is invalid
            if ( strlen( pszData ) != cch-1 )
            {
                // Encountered an embedded NULL
                bReturn = FALSE;
                goto exit;
            }
        }

        goto exit;
    }

exit:
    return ( bReturn );
}

CMDBaseData *
MakeDataObject(IN PMETADATA_RECORD pmdrData,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Looks for a data object matching the parameters.
    If found, increments the reference count. If not found, it
    creates it.

Arguments:

    Data - The data for the new object.

        Identifier - The Identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
//    CMDBaseData *pbdIndex;
    CMDBaseData *pbdReturn = NULL;
    CMDBaseData *pbdNew = NULL;
    DWORD dwHash = DATA_HASH(pmdrData->dwMDIdentifier);
//    BOOL bDataMatchError = FALSE;

//    for (pbdIndex = g_ppbdDataHashTable[dwHash];
//        (pbdIndex != NULL) &&
//        !DataMatch(pbdIndex, pmdrData, &bDataMatchError, bUnicode) &&
//        !bDataMatchError;
//        pbdIndex = pbdIndex->GetNextPtr()) {
//    }
//    if (!bDataMatchError) {
//        if (pbdIndex != NULL) {
//            pbdReturn = pbdIndex;
//            pbdReturn->IncrementReferenceCount();
//        }
//        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    pbdNew = new CMDDWData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, *(DWORD *)(pmdrData->pbMDData));
                    break;
                }
                case STRING_METADATA: {
                    pbdNew = new CMDSTRData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case BINARY_METADATA: {
                    pbdNew = new CMDBINData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, pmdrData->dwMDDataLen, pmdrData->pbMDData);
                    break;
                }
                case EXPANDSZ_METADATA: {
                    pbdNew = new CMDEXSZData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case MULTISZ_METADATA: {
                    pbdNew = new CMDMLSZData(pmdrData->dwMDIdentifier,
                                             pmdrData->dwMDAttributes,
                                             pmdrData->dwMDUserType,
                                             pmdrData->dwMDDataLen,
                                             (LPSTR)pmdrData->pbMDData,
                                             bUnicode);
                    break;
                }
                default: {
                    pbdNew = NULL;
                }
            }
            if (pbdNew != NULL) {
                if (!(pbdNew->IsValid())) {
                    delete (pbdNew);
                }
                else {
                    pbdNew->SetNextPtr(g_ppbdDataHashTable[dwHash]);
                    g_ppbdDataHashTable[dwHash] = pbdNew;
                    pbdReturn = pbdNew;
                }
            }
//        }
//    }
    return (pbdReturn);
}

HRESULT
GetHighestVersion(IN OUT STRAU *pstrauBackupLocation,
                  OUT DWORD *pdwVersion)
{
    long lHighestVersion = -1;
    long lVersion;
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathBytes = g_pstrBackupFilePath->QueryCB() + 1;
    DWORD dwNameBytes = pstrauBackupLocation->QueryCBA() - dwPathBytes;
    if (!pstrauBackupLocation->Append("*")) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        if (pstrauBackupLocation->QueryStrA() == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            hFile = FindFirstFile(pstrauBackupLocation->QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }
            else {
                //
                // Process the first file
                //

                //
                // dwNameBytes could be wrong for this assert in MBCS,
                // so call MBCS strlen. Subtract 1 char for appended '*'
                //

                MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                      wfdFile.cFileName,
                                      MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                if (CheckDigits(wfdFile.cFileName + (dwNameBytes))) {
                    //
                    // One of our files
                    //
                    lVersion = atol(wfdFile.cFileName + dwNameBytes);
                    if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                         (lVersion > lHighestVersion)) {
                        lHighestVersion = lVersion;
                    }
                }
                //
                // Process the remaining files
                //
                while (FindNextFile(hFile, &wfdFile)) {
                    MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                          wfdFile.cFileName,
                                          MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                    if (CheckDigits(wfdFile.cFileName + dwNameBytes)) {
                        //
                        // One of our files
                        //
                        lVersion = atol(wfdFile.cFileName + dwNameBytes);
                        if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                             (lVersion > lHighestVersion)) {
                            lHighestVersion = lVersion;
                        }
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                if (lHighestVersion == -1) {

                    //
                    // May not be an error, but need to indicate that
                    // no backups were found.
                    //

                    hresReturn = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
                }
                else if (lHighestVersion <= MD_BACKUP_MAX_VERSION) {
                        *pdwVersion = lHighestVersion;
                }
                else {
                        hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                }
            }
        }
        pstrauBackupLocation->SetLen(pstrauBackupLocation->QueryCCH() - 1);

    }

    return hresReturn;
}

BOOL
ValidateBackupLocation(LPSTR pszBackupLocation,
                       BOOL bUnicode)
{

    //
    // The main purpose of this routine is to make sure the user
    // is not putting in any file system controls, like .., /, etc.

    //
    // Secondarily, try to eliminate any characters that cannot be
    // used in database names
    //

    BOOL bReturn = TRUE;
    DWORD  dwStringLen;

    MD_ASSERT(pszBackupLocation != NULL);

    char *pszLocSave = setlocale(LC_CTYPE, NULL);    // Save cur locale

    if( pszLocSave )
    {
        pszLocSave = _strdup( pszLocSave );
    }

    if( !pszLocSave )
    {
        return FALSE;
    }

    setlocale(LC_CTYPE, "");                        // Set sys locale

    //
    // strcspn doesn't have an error return, but will return
    // the index of the terminating NULL if the chars are not found
    //

    if (bUnicode) {
        dwStringLen = (DWORD)wcslen((LPWSTR)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (wcscspn((LPWSTR)pszBackupLocation, MD_BACKUP_INVALID_CHARS_W) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPWSTR pszIndex;
            for (pszIndex = (LPWSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)L'\0') &&
                     (iswprint(*pszIndex));
                 pszIndex++) {
            }
            if (*pszIndex != (WCHAR)L'\0') {
                bReturn = FALSE;

            }
        }
    }
    else {
        dwStringLen = (DWORD)_mbslen((PBYTE)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (_mbscspn((PBYTE)pszBackupLocation, (PBYTE)MD_BACKUP_INVALID_CHARS_A) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPSTR pszIndex;
            for (pszIndex = (LPSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)L'\0') &&
                     (_ismbcprint(*pszIndex));
                     pszIndex = CharNextExA(CP_ACP,
                                            pszIndex,
                                            0)) {
            }
            if (*pszIndex != '\0') {
                bReturn = FALSE;

            }
        }
    }

    setlocale(LC_CTYPE, pszLocSave);
    free( pszLocSave );

    return bReturn;
}

DWORD
GetBackupNameLen(LPSTR pszBackupName)

//
// Get Number of Bytes in name prior to suffix
//

{
    LPSTR pszSubString = NULL;
    LPSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = (LPSTR)MD_STRCHR(pszBackupName, '.')) != NULL);
    while (pszNextSubString != NULL) {

        //
        // In case the suffix happens to be part of the name
        //

        pszSubString = pszNextSubString;
        pszNextSubString = (LPSTR)MD_STRCHR(pszSubString+1, '.');
    }

    if (pszSubString
        && (pszSubString[1] != '\0')
        && (pszSubString[2] != '\0')
        && !IsDBCSLeadByte(pszSubString[1])
        && (toupper(pszSubString[1]) == 'M')
        && (toupper(pszSubString[2]) == 'D')) {
        return (DWORD)DIFF(pszSubString - pszBackupName);
    }
    else {
        return 0;
    }

}

DWORD
GetBackupNameLen(LPWSTR pszBackupName)

//
// Get Number of WCHARs in name prior to version Number
//

{
    LPWSTR pszSubString = NULL;
    LPWSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = wcschr(pszBackupName, L'.')) != NULL);
    while (pszNextSubString != NULL) {
        pszSubString = pszNextSubString;
        pszNextSubString = wcschr(pszSubString+1, L'.');
    }
    if (pszSubString
        && (pszSubString[1] != L'\0')
        && (pszSubString[2] != L'\0')
        && (towupper(pszSubString[1]) == L'M')
        && (towupper(pszSubString[2]) == L'D')) {
        return (DWORD)DIFF(pszSubString - pszBackupName);
    }
    else {
        return 0;
    }

}

HRESULT CreateBackupFileName(IN LPSTR pszMDBackupLocation,
                             IN DWORD dwMDVersion,
                             IN BOOL  bUnicode,
                             IN OUT STRAU *pstrauBackupLocation,
                             IN OUT STRAU *pstrauSchemaLocation)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszBackupLocation = pszMDBackupLocation;

    if (((dwMDVersion > MD_BACKUP_MAX_VERSION) &&
           (dwMDVersion != MD_BACKUP_NEXT_VERSION) &&
           (dwMDVersion != MD_BACKUP_HIGHEST_VERSION)) ||
        ((pszBackupLocation != NULL) &&
            !ValidateBackupLocation(pszBackupLocation, bUnicode))) {
        hresReturn = E_INVALIDARG;
    }
    else {

        if ((pszBackupLocation == NULL) ||
            (bUnicode && ((*(LPWSTR)pszBackupLocation) == (WCHAR)L'\0')) ||
            (!bUnicode && ((*(LPSTR)pszBackupLocation) == (CHAR)'\0'))) {
            pszBackupLocation = MD_DEFAULT_BACKUP_LOCATION;
            bUnicode = FALSE;
        }

        if (!pstrauBackupLocation->Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pstrauBackupLocation->Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (!pstrauBackupLocation->Append((LPWSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            else {
                if (!pstrauBackupLocation->Append((LPSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if ( !pstrauSchemaLocation->Copy( (LPWSTR)pstrauBackupLocation->QueryStr(TRUE) ) |
                 !pstrauBackupLocation->Append( MD_BACKUP_SUFFIX )                    |
                 !pstrauSchemaLocation->Append( MD_SCHEMA_SUFFIX )) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                DWORD dwVersion = dwMDVersion;
                if (dwVersion == MD_BACKUP_NEXT_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                    if (SUCCEEDED(hresReturn)) {
                        if (dwVersion < MD_BACKUP_MAX_VERSION) {
                            dwVersion++;
                        }
                        else {
                            hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                        }
                    }
                    else if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {

                        //
                        // Database doesn't exist, so new version is 0
                        //

                        dwVersion = 0;
                        hresReturn = ERROR_SUCCESS;
                    }
                }
                else if (dwVersion == MD_BACKUP_HIGHEST_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                }
                if (SUCCEEDED(hresReturn)) {
                    CHAR pszBuffer[MD_MAX_DWORD_STRING];
                    _ultoa((int)dwVersion, pszBuffer, 10);
                    if (!pstrauBackupLocation->Append(pszBuffer) |
                        !pstrauSchemaLocation->Append(pszBuffer)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Make sure the ANSI buffer is valid
            //
            if ( (pstrauBackupLocation->QueryStrA() == NULL) |
                 (pstrauSchemaLocation->QueryStrA() == NULL) ) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    return hresReturn;
}

HRESULT SetBackupPath(LPSTR pszBackupPath)
{
    DWORD dwReturn = ERROR_DIRECTORY;
    DWORD dwDirectoryAttributes;

    dwDirectoryAttributes = GetFileAttributes(pszBackupPath);

    if (dwDirectoryAttributes == 0xffffffff) {
        //
        // Can't get attributes
        // Path probably doesn't exist
        //
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else if (!(CreateDirectory(pszBackupPath,
                                  NULL))) {
            dwReturn = GetLastError();
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }
    else if ((dwDirectoryAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        //
        // If a directory
        //
        dwReturn = ERROR_SUCCESS;
    }
    if (dwReturn == ERROR_SUCCESS) {
        //
        // Got it! Now set global variable
        //
        MD_ASSERT(g_pstrBackupFilePath == NULL);
        g_pstrBackupFilePath = new STR(pszBackupPath);
        if (g_pstrBackupFilePath == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (!(g_pstrBackupFilePath->IsValid())) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            delete g_pstrBackupFilePath;
            g_pstrBackupFilePath = NULL;
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetGlobalDataFileValues(LPTSTR pszFileName)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HANDLE hFileHandle;
    BOOL bMainFileFound = FALSE;

    ResetFileAttributesIfNeeded(pszFileName,
                                FALSE);

    hFileHandle = CreateFile(pszFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0);
    if (hFileHandle == INVALID_HANDLE_VALUE) {
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
        }
        else {
            hFileHandle = CreateFile(pszFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_NEW,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
            if (hFileHandle == INVALID_HANDLE_VALUE) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else {
                CloseHandle(hFileHandle);
                DeleteFile(pszFileName);
            }
        }
    }
    else {
        CloseHandle(hFileHandle);
        bMainFileFound = TRUE;
    }
    if (SUCCEEDED(hresReturn)) {
        g_strRealFileName = new STR(pszFileName);
        g_strSchemaFileName = new STR(pszFileName);
        g_strTempFileName = new STR(pszFileName);
        g_strBackupFileName = new STR(pszFileName);
        if( (NULL == g_strRealFileName)   ||
            (NULL == g_strSchemaFileName) ||
            (NULL == g_strTempFileName)   ||
            (NULL == g_strBackupFileName)
          )
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {
            if (g_strSchemaFileName->IsValid()) {
                LPSTR szRealFileNameBegin = g_strRealFileName->QueryStr();
                LPSTR szEnd = strrchr(szRealFileNameBegin, '\\');
                if(NULL == szEnd) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
                }
                else {
                    szEnd++;
                    g_strSchemaFileName->SetLen((DWORD)(szEnd-szRealFileNameBegin));
                }
            }
            if(SUCCEEDED(hresReturn)) {

                if(g_strSchemaFileName->IsValid()) {
                    g_strSchemaFileName->Append(MD_SCHEMA_FILE_NAME);
                }
                if (g_strTempFileName->IsValid()) {
                    g_strTempFileName->Append(MD_TEMP_DATA_FILE_EXT);
                }
                if (g_strBackupFileName->IsValid()) {
                    g_strBackupFileName->Append(MD_BACKUP_DATA_FILE_EXT);
                }
                if (!g_strSchemaFileName->IsValid() || !g_strTempFileName->IsValid() || !g_strBackupFileName->IsValid())
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            if(SUCCEEDED(hresReturn)) {

                ResetFileAttributesIfNeeded( g_strTempFileName->QueryStrA(),
                                             FALSE );

                hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         0);
                if (hFileHandle == INVALID_HANDLE_VALUE) {
                    if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                        hresReturn = RETURNCODETOHRESULT(GetLastError());
                    }
                    else {
                        hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 0,
                                                 NULL,
                                                 CREATE_NEW,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 0);
                        if (hFileHandle == INVALID_HANDLE_VALUE) {
                            hresReturn = RETURNCODETOHRESULT(GetLastError());
                        }
                        else {
                            CloseHandle(hFileHandle);
                            DeleteFile(g_strTempFileName->QueryStr());
                        }
                    }
                }
                else {
                    CloseHandle(hFileHandle);
                    DeleteFile( g_strTempFileName->QueryStrA() );
                }

                if (SUCCEEDED(hresReturn)) {
                    hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                    if (hFileHandle == INVALID_HANDLE_VALUE) {
                        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                            hresReturn = RETURNCODETOHRESULT(GetLastError());
                        }
                        else {
                            hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                                     GENERIC_READ | GENERIC_WRITE,
                                                     0,
                                                     NULL,
                                                     CREATE_NEW,
                                                     FILE_ATTRIBUTE_NORMAL,
                                                     0);
                            if (hFileHandle == INVALID_HANDLE_VALUE) {
                                hresReturn = RETURNCODETOHRESULT(GetLastError());
                            }
                            else {
                                CloseHandle(hFileHandle);
                                DeleteFile(g_strBackupFileName->QueryStr());

                                if ( !bMainFileFound )
                                {
                                    // We should fail the loading the metabase if there is no metabase.xml,
                                    // with one very important exclusion: during the setup.
                                    if ( CheckForSetup() != S_OK )
                                    {
                                        hresReturn = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                                    }
                                }
                            }
                        }
                    }
                    else {
                        CloseHandle(hFileHandle);
                        if (!bMainFileFound) {
                            if (!MoveFile(g_strBackupFileName->QueryStr(), pszFileName)) {
                                hresReturn = RETURNCODETOHRESULT(GetLastError());
                            }
                            else
                            {
                                ResetFileAttributesIfNeeded( pszFileName,
                                                             FALSE );
                            }
                        }
                    }
                }
            }
        }

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = SetUnicodeGlobalDataFileValues();
        }

        if (FAILED(hresReturn))
        {
            if( g_strRealFileName )
            {
                delete(g_strRealFileName);
                g_strRealFileName = NULL;
            }
            if(g_strSchemaFileName)
            {
                delete(g_strSchemaFileName);
                g_strSchemaFileName = NULL;
            }
            if( g_strTempFileName )
            {
                delete(g_strTempFileName);
                g_strRealFileName = NULL;
            }

            if( g_strBackupFileName )
            {
                delete(g_strBackupFileName);
                g_strRealFileName = NULL;
            }
        }
    }
    return hresReturn;
}


HRESULT
SetUnicodeGlobalDataFileValues()
//
//  Create unicode versions of the realfilename, tempfilename, backupfilename
//  metabasedir, historyfiledir, schemaextensions file for use by catalog
//
{
    HRESULT hr      = S_OK;
    LPWSTR  pwsz    = NULL;

    // Temp File name

    hr = GetUnicodeName(g_strTempFileName->QueryStr(),
                        &g_wszTempFileName);

    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchTempFileName = (ULONG)wcslen(g_wszTempFileName);

    // Real File name

    hr = GetUnicodeName(g_strRealFileName->QueryStr(),
                        &g_wszRealFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchRealFileName = (ULONG)wcslen(g_wszRealFileName);

    // Backup File name

    hr = GetUnicodeName(g_strBackupFileName->QueryStr(),
                        &g_wszBackupFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchBackupFileName = (ULONG)wcslen(g_wszBackupFileName);

    // Schema File name

    hr = GetUnicodeName(g_strSchemaFileName->QueryStr(),
                        &g_wszSchemaFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchSchemaFileName = (ULONG)wcslen(g_wszSchemaFileName);

    // Position pwsz where real file name begins ie past last backslash.

    pwsz = wcsrchr(g_wszRealFileName, L'\\');
    if(NULL == pwsz)
    {
        hr = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        goto exit;
    }
    pwsz++;

    // Real File name without path

    g_cchRealFileNameWithoutPath = (ULONG)wcslen(pwsz);
    g_wszRealFileNameWithoutPath = new WCHAR[g_cchRealFileNameWithoutPath+1];
    if(NULL == g_wszRealFileNameWithoutPath)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    wcscpy(g_wszRealFileNameWithoutPath, pwsz);

    // Create metabase directory, end with backslash

    g_cchMetabaseDir = (ULONG)(pwsz-g_wszRealFileName);
    g_wszMetabaseDir = new WCHAR[g_cchMetabaseDir+1];
    if(NULL == g_wszMetabaseDir)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    memcpy(g_wszMetabaseDir, g_wszRealFileName, g_cchMetabaseDir*sizeof(WCHAR));
    g_wszMetabaseDir[g_cchMetabaseDir] = L'\0';

    // Real File name without path & without extension

    pwsz = wcsrchr(g_wszRealFileNameWithoutPath, MD_CH_EXTN_SEPERATORW);

    g_cchRealFileNameWithoutPathWithoutExtension = g_cchRealFileNameWithoutPath;
    g_wszRealFileNameWithoutPathWithoutExtension = new WCHAR[g_cchRealFileNameWithoutPathWithoutExtension +1];
    if(NULL == g_wszRealFileNameWithoutPathWithoutExtension)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    else if(NULL != pwsz)
    {
        g_cchRealFileNameWithoutPathWithoutExtension = (ULONG)(pwsz - g_wszRealFileNameWithoutPath);
        memcpy(g_wszRealFileNameWithoutPathWithoutExtension, g_wszRealFileNameWithoutPath, g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszRealFileNameWithoutPathWithoutExtension[g_cchRealFileNameWithoutPathWithoutExtension] = L'\0';

        // Real File name extension

        g_cchRealFileNameExtension = (ULONG)wcslen(pwsz);
        g_wszRealFileNameExtension = new WCHAR[g_cchRealFileNameExtension+1];
        if(NULL == g_wszRealFileNameExtension)
        {
            hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        memcpy(g_wszRealFileNameExtension, pwsz, g_cchRealFileNameExtension*sizeof(WCHAR));
        g_wszRealFileNameExtension[g_cchRealFileNameExtension] = L'\0';
    }
    else
    {
        memcpy(g_wszRealFileNameWithoutPathWithoutExtension,g_wszRealFileNameWithoutPath,g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszRealFileNameWithoutPathWithoutExtension[g_cchRealFileNameExtension] = L'\0';
    }

    // Position pwsz where schema file name begins ie past last backslash.

    pwsz = wcsrchr(g_wszSchemaFileName, L'\\');
    if(NULL == pwsz)
    {
        hr = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        goto exit;
    }
    pwsz++;

    // Schema File name without path

    g_cchSchemaFileNameWithoutPath = (ULONG)wcslen(pwsz);
    g_wszSchemaFileNameWithoutPath = new WCHAR[g_cchSchemaFileNameWithoutPath+1];
    if(NULL == g_wszSchemaFileNameWithoutPath)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    wcscpy(g_wszSchemaFileNameWithoutPath, pwsz);

    // Schema File name without path & without extension

    pwsz = wcsrchr(g_wszSchemaFileNameWithoutPath, MD_CH_EXTN_SEPERATORW);

    g_cchSchemaFileNameWithoutPathWithoutExtension = g_cchSchemaFileNameWithoutPath;
    g_wszSchemaFileNameWithoutPathWithoutExtension = new WCHAR[g_cchSchemaFileNameWithoutPathWithoutExtension +1];
    if(NULL == g_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    else if(NULL != pwsz)
    {
        g_cchSchemaFileNameWithoutPathWithoutExtension = (ULONG)(pwsz - g_wszSchemaFileNameWithoutPath);
        memcpy(g_wszSchemaFileNameWithoutPathWithoutExtension, g_wszSchemaFileNameWithoutPath, g_cchSchemaFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszSchemaFileNameWithoutPathWithoutExtension[g_cchSchemaFileNameWithoutPathWithoutExtension] = L'\0';

        // Schema File name extension

        g_cchSchemaFileNameExtension = (ULONG)wcslen(pwsz);
        g_wszSchemaFileNameExtension = new WCHAR[g_cchSchemaFileNameExtension+1];
        if(NULL == g_wszSchemaFileNameExtension)
        {
            hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        memcpy(g_wszSchemaFileNameExtension, pwsz, g_cchSchemaFileNameExtension*sizeof(WCHAR));
        g_wszSchemaFileNameExtension[g_cchSchemaFileNameExtension] = L'\0';
    }
    else
    {
        memcpy(g_wszSchemaFileNameWithoutPathWithoutExtension,g_wszSchemaFileNameWithoutPath,g_cchSchemaFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszSchemaFileNameWithoutPathWithoutExtension[g_cchSchemaFileNameExtension] = L'\0';
    }

    // Create history file dir, end with backslash

    g_cchHistoryFileDir = g_cchMetabaseDir + MD_CCH_HISTORY_FILE_SUBDIRW;
    g_wszHistoryFileDir = new WCHAR[g_cchHistoryFileDir+1];
    if(NULL == g_wszHistoryFileDir)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    pwsz    = g_wszHistoryFileDir;
    memcpy(pwsz, g_wszMetabaseDir, g_cchMetabaseDir*sizeof(WCHAR));
    pwsz    = pwsz + g_cchMetabaseDir;
    memcpy(pwsz, MD_HISTORY_FILE_SUBDIRW, MD_CCH_HISTORY_FILE_SUBDIRW*sizeof(WCHAR));
    pwsz    = pwsz + MD_CCH_HISTORY_FILE_SUBDIRW; // This contains the backslash
    *pwsz   = L'\0';

    // Create history file seach string Eg: D:\WINNT\System32\inetsrv\History\Metabase_??????????_??????????.XML

    g_cchHistoryFileSearchString = g_cchHistoryFileDir                           +
                                   g_cchRealFileNameWithoutPathWithoutExtension  +
                                   MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW         +
                                   g_cchRealFileNameExtension;

    if((g_cchHistoryFileSearchString + 1) > MAX_PATH)
    {
        g_cchHistoryFileSearchString += MD_CCH_LONG_STRING_PREFIXW;
    }

    g_wszHistoryFileSearchString = new WCHAR[g_cchHistoryFileSearchString + 1];
    if(NULL == g_wszHistoryFileSearchString)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    pwsz = g_wszHistoryFileSearchString;
    if((g_cchHistoryFileSearchString + 1) > MAX_PATH)
    {
        memcpy(pwsz, MD_LONG_STRING_PREFIXW, MD_CCH_LONG_STRING_PREFIXW*sizeof(WCHAR));
        pwsz = pwsz + (MD_CCH_LONG_STRING_PREFIXW);
    }
    memcpy(pwsz, g_wszHistoryFileDir, g_cchHistoryFileDir*sizeof(WCHAR));
    pwsz = pwsz + g_cchHistoryFileDir;
    memcpy(pwsz, g_wszRealFileNameWithoutPathWithoutExtension, g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
    pwsz = pwsz + g_cchRealFileNameWithoutPathWithoutExtension;
    memcpy(pwsz, MD_HISTORY_FILE_SEARCH_EXTENSIONW, MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW;
    if(NULL != g_wszRealFileNameExtension)
    {
        memcpy(pwsz, g_wszRealFileNameExtension, g_cchRealFileNameExtension*sizeof(WCHAR));
        pwsz = pwsz + g_cchRealFileNameExtension;
    }
    *pwsz = L'\0';

    // Create error file search string Eg: D:\WINNT\System32\inetsrv\History\MetabaseError_??????????.XML

    g_cchErrorFileSearchString = g_cchHistoryFileDir                          +
                                 g_cchRealFileNameWithoutPathWithoutExtension +
                                 MD_CCH_ERROR_FILE_NAME_EXTENSIONW            +
                                 MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW          +
                                 g_cchRealFileNameExtension;

    if((g_cchErrorFileSearchString + 1) > MAX_PATH)
    {
        g_cchErrorFileSearchString += MD_CCH_LONG_STRING_PREFIXW;
    }

    g_wszErrorFileSearchString = new WCHAR[g_cchErrorFileSearchString+1];
    if(NULL == g_wszErrorFileSearchString)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    pwsz = g_wszErrorFileSearchString;
    if((g_cchErrorFileSearchString + 1) > MAX_PATH)
    {
        memcpy(pwsz,MD_LONG_STRING_PREFIXW, MD_CCH_LONG_STRING_PREFIXW*sizeof(WCHAR));
        pwsz = pwsz + MD_CCH_LONG_STRING_PREFIXW;
    }
    memcpy(pwsz, g_wszHistoryFileDir, g_cchHistoryFileDir*sizeof(WCHAR));
    pwsz = pwsz + g_cchHistoryFileDir;
    memcpy(pwsz, g_wszRealFileNameWithoutPathWithoutExtension, g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
    pwsz = pwsz + g_cchRealFileNameWithoutPathWithoutExtension;
    memcpy(pwsz, MD_ERROR_FILE_NAME_EXTENSIONW, MD_CCH_ERROR_FILE_NAME_EXTENSIONW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_ERROR_FILE_NAME_EXTENSIONW;
    memcpy(pwsz, MD_ERROR_FILE_SEARCH_EXTENSIONW, MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW;
    if(NULL != g_wszRealFileNameExtension)
    {
        memcpy(pwsz, g_wszRealFileNameExtension, g_cchRealFileNameExtension*sizeof(WCHAR));
        pwsz = pwsz + g_cchRealFileNameExtension;
    }
    *pwsz = L'\0';

    // Create schema extensions file. Eg: D:\WINNT\System32\inetsrv\MBSchExt.XML

    g_cchSchemaExtensionFile = g_cchMetabaseDir                  +
                               MD_CCH_SCHEMA_EXTENSION_FILE_NAMEW;

    g_wszSchemaExtensionFile = new WCHAR[g_cchSchemaExtensionFile+1];
    if(NULL == g_wszSchemaExtensionFile)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    pwsz = g_wszSchemaExtensionFile;
    memcpy(pwsz, g_wszMetabaseDir, g_cchMetabaseDir*sizeof(WCHAR));
    pwsz = pwsz + g_cchMetabaseDir;
    memcpy(pwsz, MD_SCHEMA_EXTENSION_FILE_NAMEW, MD_CCH_SCHEMA_EXTENSION_FILE_NAMEW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_SCHEMA_EXTENSION_FILE_NAMEW;
    *pwsz = L'\0';

    DBGINFOW((DBG_CONTEXT,
              L"[SetUnicodeGlobalDataFileValues]\nTempFileName%s:%d\nRealFileName:%s::%d\nBackupFileName:%s::%d\nSchemaFileName:%s::%d\nRealFileNameWithoutPath:%s::%d\nRealFileNameWithoutPathWithoutExtension:%s::%d\nMetabaseDir:%s::%d\nSchemaFileNameWithoutPath:%s::%d\nSchemaFileNameWithoutPathWithoutExtension:%s::%d\nHistoryFileDir:%s::%d\nHistoryFileSearchString:%s::%d\nErrorFileSearchString:%s::%d\nSchemaExtensionFile:%s::%d\n",
              g_wszTempFileName,
              g_cchTempFileName,
              g_wszRealFileName,
              g_cchRealFileName,
              g_wszBackupFileName,
              g_cchBackupFileName,
              g_wszSchemaFileName,
              g_cchSchemaFileName,
              g_wszRealFileNameWithoutPath,
              g_cchRealFileNameWithoutPath,
              g_wszRealFileNameWithoutPathWithoutExtension,
              g_cchRealFileNameWithoutPathWithoutExtension,
              g_wszMetabaseDir,
              g_cchMetabaseDir,
              g_wszSchemaFileNameWithoutPath,
              g_cchSchemaFileNameWithoutPath,
              g_wszSchemaFileNameWithoutPathWithoutExtension,
              g_cchSchemaFileNameWithoutPathWithoutExtension,
              g_wszHistoryFileDir,
              g_cchHistoryFileDir,
              g_wszHistoryFileSearchString,
              g_cchHistoryFileSearchString,
              g_wszErrorFileSearchString,
              g_cchErrorFileSearchString,
              g_wszSchemaExtensionFile,
              g_cchSchemaExtensionFile));

    if(NULL != g_wszRealFileNameExtension)
    {
        DBGINFOW((DBG_CONTEXT,
              L"[SetUnicodeGlobalDataFileValues]\nRealFileNameExtension:%s::%d\n",
              g_wszRealFileNameExtension,
              g_cchRealFileNameExtension));
    }

    if(NULL != g_wszSchemaFileNameExtension)
    {
        DBGINFOW((DBG_CONTEXT,
              L"[SetUnicodeGlobalDataFileValues]\nSchemaFileNameExtension:%s::%d\n",
              g_wszSchemaFileNameExtension,
              g_cchSchemaFileNameExtension));
    }

exit:

    if(FAILED(hr))
    {
        UnInitializeUnicodeGlobalDataFileValues();
    }
    else
    {
        hr = RETURNCODETOHRESULT(ERROR_SUCCESS);
    }

    return hr;

}

void
InitializeUnicodeGlobalDataFileValues()
{
    g_wszTempFileName                               = NULL;
    g_cchTempFileName                               = 0;

    g_wszRealFileName                               = NULL;
    g_cchRealFileName                               = 0;

    g_wszBackupFileName                             = NULL;
    g_cchBackupFileName                             = 0;

    g_wszSchemaFileName                             = NULL;
    g_cchSchemaFileName                             = 0;

    g_wszRealFileNameWithoutPath                    = NULL;
    g_cchRealFileNameWithoutPath                    = 0;

    g_wszMetabaseDir                                = NULL;
    g_cchMetabaseDir                                = 0;

    g_wszRealFileNameWithoutPathWithoutExtension    = NULL;
    g_cchRealFileNameWithoutPathWithoutExtension    = 0;

    g_wszRealFileNameExtension                      = NULL;
    g_cchRealFileNameExtension                      = 0;

    g_wszSchemaFileNameWithoutPath                  = NULL;
    g_cchSchemaFileNameWithoutPath                  = 0;

    g_wszSchemaFileNameWithoutPathWithoutExtension  = NULL;
    g_cchSchemaFileNameWithoutPathWithoutExtension  = 0;

    g_wszSchemaFileNameExtension                    = NULL;
    g_cchSchemaFileNameExtension                    = 0;

    g_wszHistoryFileDir                             = NULL;
    g_cchHistoryFileDir                             = 0;

    g_wszHistoryFileSearchString                    = NULL;
    g_cchHistoryFileSearchString                    = 0;

    g_wszErrorFileSearchString                      = NULL;
    g_cchErrorFileSearchString                      = 0;

    g_wszSchemaExtensionFile                        = NULL;
    g_cchSchemaExtensionFile                        = 0;

}

void
UnInitializeUnicodeGlobalDataFileValues()
{
    if(NULL != g_wszTempFileName)
    {
        delete [] g_wszTempFileName;
        g_wszTempFileName = NULL;
        g_cchTempFileName = 0;
    }

    if(NULL != g_wszRealFileName)
    {
        delete [] g_wszRealFileName;
        g_wszRealFileName = NULL;
        g_cchRealFileName = 0;

    }

    if(NULL != g_wszBackupFileName)
    {
        delete [] g_wszBackupFileName;
        g_wszBackupFileName = NULL;
        g_cchBackupFileName = 0;

    }

    if(NULL != g_wszSchemaFileName)
    {
        delete [] g_wszSchemaFileName;
        g_wszSchemaFileName = NULL;
        g_cchSchemaFileName = 0;

    }

    if(NULL != g_wszRealFileNameWithoutPath)
    {
        delete [] g_wszRealFileNameWithoutPath;
        g_wszRealFileNameWithoutPath = NULL;
        g_cchRealFileNameWithoutPath = 0;

    }

    if(NULL != g_wszMetabaseDir)
    {
        delete [] g_wszMetabaseDir;
        g_wszMetabaseDir = NULL;
        g_cchMetabaseDir = 0;

    }

    if(NULL != g_wszRealFileNameWithoutPathWithoutExtension)
    {
        delete [] g_wszRealFileNameWithoutPathWithoutExtension;
        g_wszRealFileNameWithoutPathWithoutExtension = NULL;
        g_cchRealFileNameWithoutPathWithoutExtension = 0;

    }

    if(NULL != g_wszRealFileNameExtension)
    {
        delete [] g_wszRealFileNameExtension;
        g_wszRealFileNameExtension = NULL;
        g_cchRealFileNameExtension = 0;

    }

    if(NULL != g_wszSchemaFileNameWithoutPath)
    {
        delete [] g_wszSchemaFileNameWithoutPath;
        g_wszSchemaFileNameWithoutPath = NULL;
        g_cchSchemaFileNameWithoutPath = 0;
    }

    if(NULL != g_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        delete [] g_wszSchemaFileNameWithoutPathWithoutExtension;
        g_wszSchemaFileNameWithoutPathWithoutExtension = NULL;
        g_cchSchemaFileNameWithoutPathWithoutExtension = 0;

    }

    if(NULL != g_wszSchemaFileNameExtension)
    {
        delete [] g_wszSchemaFileNameExtension;
        g_wszSchemaFileNameExtension = NULL;
        g_cchSchemaFileNameExtension = 0;

    }

    if(NULL != g_wszHistoryFileDir)
    {
        delete [] g_wszHistoryFileDir;
        g_wszHistoryFileDir = NULL;
        g_cchHistoryFileDir = 0;

    }

    if(NULL != g_wszHistoryFileSearchString)
    {
        delete [] g_wszHistoryFileSearchString;
        g_wszHistoryFileSearchString = NULL;
        g_cchHistoryFileSearchString = 0;
    }
    if(NULL != g_wszErrorFileSearchString)
    {
        delete [] g_wszErrorFileSearchString;
        g_wszErrorFileSearchString = NULL;
        g_cchErrorFileSearchString = 0;
    }

    if(NULL != g_wszSchemaExtensionFile)
    {
        delete [] g_wszSchemaExtensionFile;
        g_wszSchemaExtensionFile = NULL;
        g_cchSchemaExtensionFile = 0;
    }

    return;
}

HRESULT
SetDataFile()
{
    HRESULT             hr = S_OK;
    CHAR                szTemp[MAX_PATH+1]; // MAX_PATH+1 so we always have a zero terminated string
    CHAR                *pszLastSlash;
    DWORD               cch;
    STRAU               strMetabase;
    STRAU               strBackup;

    // Zero out
    memset( szTemp, 0 , sizeof(szTemp) );

    // Get the full path name of the dll
    cch = GetModuleFileNameA( GetModuleHandleA( MD_DEFAULT_DLL_FILE_NAME ), szTemp, MAX_PATH );
    // Failed?
    if ( cch == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    // If the buffer is not big enough
    if ( szTemp[MAX_PATH-1] != '\0' )
    {
        hr = E_FAIL;
        goto exit;
    }

    // Find the last slash
    pszLastSlash = strrchr( szTemp, '\\' );
    if ( pszLastSlash == NULL )
    {
        hr = E_FAIL;
        goto exit;
    }
    if ( _stricmp( pszLastSlash+1, MD_DEFAULT_DLL_FILE_NAME ) != 0 )
    {
        hr = E_FAIL;
        goto exit;
    }

    // Terminate after the slash
    pszLastSlash[1] = '\0';

    if ( !strMetabase.Copy( szTemp ) )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ( !strMetabase.Append( MD_DEFAULT_DATA_FILE_NAME ) )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ( !strBackup.Copy( szTemp ) )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ( !strBackup.Append( MD_DEFAULT_BACKUP_PATH_NAME ) )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = SetGlobalDataFileValues( strMetabase.QueryStrA() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    hr = SetBackupPath( strBackup.QueryStrA() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

exit:
    return hr;
}

DWORD GetObjectPath(CMDBaseObject *pboObject,
                    BUFFER *pbufPath,
                    DWORD &rdwStringLen,
                    CMDBaseObject *pboTopObject,
                    IN BOOL bUnicode)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwOldStringLen;

    MD_ASSERT(pboObject != NULL);
    if (pboObject != pboTopObject) {
        dwReturn = GetObjectPath(pboObject->GetParent(),
                                 pbufPath,
                                 rdwStringLen,
                                 pboTopObject,
                                 bUnicode);
        dwOldStringLen = rdwStringLen;
        if (pboObject->GetName(bUnicode) == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            if (bUnicode) {
                rdwStringLen += (1 + (DWORD)wcslen((LPWSTR)pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(WCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPWSTR lpzStringEnd = (LPWSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERW;
                    wcscpy(lpzStringEnd+1, (LPWSTR)(pboObject->GetName(bUnicode)));
                }
            }
            else {
                rdwStringLen += (1 + (DWORD)MD_STRBYTES(pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(TCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPTSTR lpzStringEnd = (LPTSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERA;
                    MD_STRCPY(lpzStringEnd+1, pboObject->GetName(bUnicode));
                }
            }
        }
    }
    return dwReturn;
}


HRESULT
MakeInsertPathData(STRAU *pstrauNewData,
                   LPTSTR pszPath,
                   LPTSTR pszOldData,
                   DWORD *pdwDataLen,
                   BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (bUnicode) {
        LPWSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = (LPWSTR)pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = wcsstr(pszDataIndex, MD_INSERT_PATH_STRINGW)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGW) / sizeof(WCHAR)) - 1))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, (DWORD)DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append((LPWSTR)pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(WCHAR);
    }
    else {
        LPTSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = MD_STRSTR(pszDataIndex, MD_INSERT_PATH_STRINGA)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGA) - 1)))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, (DWORD)DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append(pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(CHAR);
    }
    return hresReturn;
}

HRESULT
InsertPathIntoData(BUFFER *pbufNewData,
                   STRAU *pstrData,
                   PBYTE *ppbNewData,
                   DWORD *pdwNewDataLen,
                   CMDBaseData *pbdRetrieve,
                   METADATA_HANDLE hHandle,
                   CMDBaseObject *pboDataMetaObject,
                   IN BOOL bUnicode)
{
    //
    // Need to insert path
    //
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathLen = 0;
    BUFFER bufPath;
    CMDHandle * pCMDHandle = GetHandleObject(hHandle);
    if( !pCMDHandle )
    {
        return MD_ERROR_DATA_NOT_FOUND;
    }

    CMDBaseObject *pboHandleMetaObject = pCMDHandle->GetObject();

    MD_ASSERT((pbdRetrieve->GetDataType() != DWORD_METADATA) &&
        (pbdRetrieve->GetDataType() != BINARY_METADATA));

    if (pboHandleMetaObject->GetObjectLevel() > pboDataMetaObject->GetObjectLevel()) {
        hresReturn = MD_WARNING_PATH_NOT_INSERTED;
    }
    else {
        DWORD dwReturn;
        if ( (dwReturn = GetObjectPath(pboDataMetaObject,
                                       &bufPath,
                                       dwPathLen,
                                       pboHandleMetaObject,
                                       bUnicode)) != ERROR_SUCCESS) {
            hresReturn = RETURNCODETOHRESULT(dwReturn);
        }
        else if (!bufPath.Resize((dwPathLen + 2) * ((bUnicode) ? sizeof(WCHAR) : sizeof(CHAR)))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            LPTSTR pszPath;
            DWORD dwDataLen;
            pszPath = (LPTSTR)(bufPath.QueryPtr());
            if (bUnicode) {
                ((LPWSTR)pszPath)[dwPathLen] = MD_PATH_DELIMETERW;
                ((LPWSTR)pszPath)[dwPathLen + 1] = (WCHAR)L'\0';
            }
            else {
                pszPath[dwPathLen] = MD_PATH_DELIMETERA;
                pszPath[dwPathLen + 1] = (TCHAR)'\0';
            }
            //
            // If there was an error in GetData, it would have been
            // caught already.
            //
            MD_ASSERT(pbdRetrieve->GetData(bUnicode) != NULL);
            switch (pbdRetrieve->GetDataType()) {
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                {
                    hresReturn = MakeInsertPathData(pstrData,
                                             (LPTSTR)bufPath.QueryPtr(),
                                             (LPTSTR)pbdRetrieve->GetData(bUnicode),
                                             &dwDataLen,
                                             bUnicode);
                    if (SUCCEEDED(hresReturn)) {
                        //
                        // QueryStr should not fail in this instance
                        // since it was created with the same unicode flag
                        //
                        MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                        *ppbNewData = (PBYTE) pstrData->QueryStr(bUnicode);
                        *pdwNewDataLen = dwDataLen;
                    }
                }
                break;
            case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPWSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (WCHAR)L'\0');
                             pszDataIndex += (wcslen(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                            (LPSTR)bufPath.QueryPtr(),
                                                            (LPSTR)pszDataIndex,
                                                            &dwStringBytes,
                                                            bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen,
                                            pstrData->QueryStr(bUnicode),
                                            dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(WCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(((LPWSTR)(*ppbNewData)) + ((dwDataLen / sizeof(WCHAR)) - 1)) = (WCHAR)L'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                    else {
                        LPSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPTSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (CHAR)'\0');
                             pszDataIndex += (MD_STRBYTES(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                     (LPTSTR)bufPath.QueryPtr(),
                                                     pszDataIndex,
                                                     &dwStringBytes);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStrA() != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen, pstrData->QueryStrA(), dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(TCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(*ppbNewData + (dwDataLen-1)) = (CHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                }
                break;
            default:
                MD_ASSERT(FALSE);
            }
        }
    }
    return hresReturn;
}

HRESULT
MakeTreeCopyWithPath(CMDBaseObject *pboSource,
                     CMDBaseObject *&rpboNew,
                     LPSTR pszPath,
                     IN BOOL bUnicode)
{
    WCHAR pszName[METADATA_MAX_NAME_LEN];
    LPSTR pszTempPath = pszPath;
    CMDBaseObject *pboNew = NULL;
    CMDBaseObject *pboParent = NULL;
    CMDBaseObject *pboTree = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresExtractReturn = S_OK;

    while ((SUCCEEDED(hresReturn)) &&
        (SUCCEEDED(hresExtractReturn = ExtractNameFromPath(pszTempPath, (LPSTR)pszName, bUnicode)))) {

        if (bUnicode) {
            pboNew = new CMDBaseObject((LPWSTR)pszName);
        }
        else {
            pboNew = new CMDBaseObject((LPSTR)pszName);
        }
        if (pboNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pboNew->IsValid()) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            delete (pboNew);
        }
        else {
            if (pboParent != NULL) {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete pboNew;
                    pboNew = pboParent;
                }
            }
            pboParent = pboNew;
        }
    }

    if ((SUCCEEDED(hresReturn)) && (hresExtractReturn != (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)))) {
        hresReturn = hresExtractReturn;
    }

    if (SUCCEEDED(hresReturn)) {

        //
        // Don't really want the leaf object, as MakeTreeCopy will create it.
        //

        LPWSTR pszTreeName = NULL;

        if (pboNew != NULL) {
            pszTreeName = (LPWSTR)pboNew->GetName(TRUE);
            pboParent = pboNew->GetParent();
            if (pszTreeName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            hresReturn = MakeTreeCopy(pboSource, pboTree, (LPSTR)pszTreeName, TRUE);

            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(pboTree != NULL);

                if (pboParent != NULL) {
                    MD_REQUIRE(SUCCEEDED(pboParent->RemoveChildObject(pboNew)));
                    hresReturn = pboParent->InsertChildObject(pboTree);
                    if (FAILED(hresReturn)) {
                        delete(pboTree);
                        pboTree = NULL;
                    }
                }
            }
        }
        delete(pboNew);
        pboNew = NULL;
    }

    if (FAILED(hresReturn)) {
        if (pboParent != NULL) {
            CMDBaseObject *pboTemp;
            MD_ASSERT(pboNew != NULL);
            for (pboTemp = pboParent; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
            }
            //
            // destructor recurses through child objects
            //
            delete pboTemp;
        }
    }
    else {
        MD_ASSERT(pboTree != NULL);
        CMDBaseObject *pboTemp;
        for (pboTemp = pboTree; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
        }
        rpboNew = pboTemp;
    }

    return hresReturn;
}

HRESULT
MakeTreeCopy(CMDBaseObject *pboSource,
             CMDBaseObject *&rpboNew,
             LPSTR pszName,
             IN BOOL bUnicode)
{
    CMDBaseObject *pboTemp = NULL;
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pszName == NULL) {
        if ((pboSource->GetName(TRUE)) != NULL) {
            pboTemp = new CMDBaseObject((LPWSTR)(pboSource->GetName(TRUE)), NULL);
        }
    }
    else {
        if (bUnicode) {
            pboTemp = new CMDBaseObject((LPWSTR)pszName, NULL);
        }
        else {
            pboTemp = new CMDBaseObject((LPSTR)pszName, NULL);
        }
    }
    if (pboTemp == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else if (!pboTemp->IsValid()) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        delete (pboTemp);
    }
    else {
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        if ( ppvMainDataBuf == NULL )
        {
            hresReturn = E_FAIL;
        }
        else
        {
            dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE, FALSE);
            for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                hresReturn = pboTemp->SetDataObject(pbdCurrent);
            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            hresReturn = MakeTreeCopy(pboOldChild, pboNewChild, NULL, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT (pboNewChild != NULL);
                hresReturn = pboTemp->InsertChildObject(pboNewChild);
            }
            i++;
            pboOldChild = pboSource->EnumChildObject(i);
        }
    }
    if (SUCCEEDED(hresReturn)) {
        rpboNew = pboTemp;
    }
    else {
        rpboNew = NULL;
        delete(pboTemp);
    }
    return (hresReturn);
}

void
AddNewChangeData(CMDHandle *phoDestHandle,
                 CMDBaseObject *pboNew)
{
    DWORD i;
    CMDBaseObject *pboChild;
    CMDBaseData *pbdCurrent;

    MD_ASSERT(pboNew != NULL);

    phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
    if ((pbdCurrent = pboNew->EnumDataObject(0, 0, ALL_METADATA, ALL_METADATA)) != NULL) {
        phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
    }
    i = 0;
    pboChild = pboNew->EnumChildObject(i);
    while (pboChild != NULL) {
        AddNewChangeData(phoDestHandle, pboChild);
        i++;
        pboChild = pboNew->EnumChildObject(i);
    }
}

HRESULT
CopyTree(CMDHandle *phoDestParentHandle,
         CMDBaseObject *pboDest,
         CMDBaseObject *pboSource,
         BOOL &rbChanged)

{
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    LPSTR pszTempName;
    HRESULT hresReturn = ERROR_SUCCESS;

    MD_ASSERT(pboDest != NULL);
    MD_ASSERT(pboSource != NULL);
    ppvMainDataBuf = GetMainDataBuffer();
    MD_ASSERT (ppvMainDataBuf != NULL);
    if ( ppvMainDataBuf == NULL )
    {
        hresReturn = E_FAIL;
    }
    else
    {
        dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE, FALSE);
        for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
            pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
            MD_ASSERT(pbdCurrent != NULL);
            PREFIX_ASSUME(pbdCurrent != NULL, "pbdCurrent is guaranteed not to NULL here");
            hresReturn = pboDest->SetDataObject(pbdCurrent);
            if (SUCCEEDED(hresReturn)) {
                rbChanged = TRUE;
                phoDestParentHandle->SetChangeData(pboDest, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
            }
        }
        if (SUCCEEDED(hresReturn)) {
            i = 0;
            pboOldChild = pboSource->EnumChildObject(i);
            while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
                pszTempName = (pboOldChild->GetName(TRUE));
                if (pszTempName == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    pboNewChild = pboDest->GetChildObject(pszTempName, &hresReturn, TRUE);
                    if (SUCCEEDED(hresReturn)) {
                        if (pboNewChild != NULL) {
                            hresReturn = CopyTree(phoDestParentHandle, pboNewChild, pboOldChild, rbChanged);
                        }
                        else {
                            hresReturn = MakeTreeCopy(pboOldChild, pboNewChild);
                            if (SUCCEEDED(hresReturn)) {
                                MD_ASSERT (pboNewChild != NULL);
                                hresReturn = pboDest->InsertChildObject(pboNewChild);
                                if (SUCCEEDED(hresReturn)) {
                                    rbChanged = TRUE;
                                    AddNewChangeData(phoDestParentHandle, pboNewChild);
                                }
                                else {
                                    delete(pboNewChild);
                                }
                            }
                        }
                        i++;
                        pboOldChild = pboSource->EnumChildObject(i);
                    }
                }
            }
        }
        FreeMainDataBuffer(ppvMainDataBuf);
    }
    return (hresReturn);
}

HRESULT
CheckForSetup()
/*++

Routine Description:

    Checks whether the IIS setup is currently running.

Arguments:


Return Value:

    HRESULT     - S_OK:     Yes, we are in setup
                - S_FALSE:  No, we are not in setup
                - E_*:      Failure

Notes:

--*/
{
    HRESULT             hr = S_OK;
    HKEY                hkeySetup = NULL;
    DWORD               dwErr;
    DWORD               dwValue = 0;
    DWORD               dwType = REG_NONE;
    DWORD               dwSize = sizeof(DWORD);

    // Open HKLM\SOFTWARE\Microsoft\InetStp
    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                        SETUP_REG_KEY,
                        &hkeySetup );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Get CurrentInstallState
    dwErr = RegQueryValueEx( hkeySetup,
                             MD_CURRENT_INSTALL_STATE,
                             NULL,
                             &dwType,
                             (BYTE*)&dwValue,
                             &dwSize );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // If it isn't a DWORD
    if ( ( dwType != REG_DWORD ) ||
         ( dwSize != sizeof(DWORD) ) )
    {
        // The value is bad
        hr = E_FAIL;
        goto exit;
    }

    // If during setup
    if ( ( dwValue & MD_INSTALL_STATE_INSTALLING ) == MD_INSTALL_STATE_INSTALLING )
    {
        // Yes, we are in setup
        hr = S_OK;
    }
    else
    {
        // No, we are not in setup
        hr = S_FALSE;
    }

exit:
    if ( hkeySetup != NULL )
    {
        RegCloseKey( hkeySetup );
        hkeySetup = NULL;
    }

    // Done
    return hr;
}

void CheckForNewMetabaseVersion()
{
    BOOL    bValueWasWrongType = FALSE;
    BOOL    bSomethingChanged = FALSE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn,dwValue,dwType,dwSize = sizeof(DWORD);

    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SETUP_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS)
    {
        // Check for update to major version

        // get the Type of data only first
        // since a string won't fit in &dwValue
        dwValue = 0;
        dwSize = sizeof(DWORD);
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        MD_SETMAJORVERSION_VALUE,
                        NULL,
                        &dwType,
                        NULL,
                        &dwSize);
        if ( dwRegReturn == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                dwSize = sizeof(DWORD);
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                MD_SETMAJORVERSION_VALUE,
                                NULL,
                                &dwType,
                                (BYTE *)&dwValue,
                                &dwSize);
                if ( dwRegReturn == ERROR_SUCCESS)
                {
                    // default the value with the version that this binary was compiled with
                    if (dwType == REG_DWORD)
                    {
                        if (g_dwMajorVersionNumber != dwValue && dwValue >= 1)
                        {
                            g_dwMajorVersionNumber = dwValue;
                            bSomethingChanged = TRUE;
                        }
                    }
                    else
                    {
                        bValueWasWrongType = TRUE;
                    }
                }
            }
            else
            {
                bValueWasWrongType = TRUE;
            }
        }

        if (FALSE == bValueWasWrongType)
        {
            // Check for update to minor version

            // get the Type of data only first
            // since a string won't fit in &dwValue
            dwValue = 0;
            dwSize = sizeof(DWORD);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                            MD_SETMINORVERSION_VALUE,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);
            if ( dwRegReturn == ERROR_SUCCESS)
            {
                if (dwType == REG_DWORD)
                {
                    dwSize = sizeof(DWORD);
                    dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                    MD_SETMINORVERSION_VALUE,
                                    NULL,
                                    &dwType,
                                    (BYTE *)&dwValue,
                                    &dwSize);
                    if ( dwRegReturn == ERROR_SUCCESS)
                    {
                        if (dwType == REG_DWORD)
                        {
                            if (g_dwMinorVersionNumber != dwValue)
                            {
                                g_dwMinorVersionNumber = dwValue;
                                bSomethingChanged = TRUE;
                            }
                        }
                        else
                        {
                            bValueWasWrongType = TRUE;
                        }
                    }
                }
                else
                {
                    bValueWasWrongType = TRUE;
                }
            }
        }
        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
    }

    if (TRUE == bValueWasWrongType)
    {
        // default the value with the version that this binary was compiled with

        if (g_dwMajorVersionNumber != MD_MAJOR_VERSION_NUMBER)
        {
            g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }

        if (g_dwMinorVersionNumber != MD_MINOR_VERSION_NUMBER)
        {
            g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }
    }


    if (TRUE == bSomethingChanged)
    {
        // make sure that we tell the metabase that there was a change made..
        g_dwSystemChangeNumber++;
        IIS_PRINTF((buff,"MD:New Metabase Version:%d.%d\n",g_dwMajorVersionNumber,g_dwMinorVersionNumber));
    }
    return;
}

BOOL
CheckVersionNumber()
{
    BOOL bReturn = FALSE;

    if (g_dwMajorVersionNumber >= 1) {
        // 1 = IIS4
        //     we need to be able to open IIS4 in IIS5 during setup upgrade
        // 2 = IIS5
        bReturn = TRUE;
    }

    // g_dwMinorVersionNumber -- maybe use this for Major service pack releases or something in which
    //                           Metabase has been changed and we need to know the difference?

    return bReturn;
}

HRESULT
InitStorageAndSessionKey(
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider( &hProv );

    if( SUCCEEDED(hresReturn) )
    {
        hresReturn = pCryptoStorage->Initialize(
                         TRUE,                          // fUseMachineKeyset
                         hProv
                         );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->Initialize Failed - error 0x%0x\n", hresReturn));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: GetCryptoProvider Failed - error 0x%0x\n", hresReturn));
    }

    if( SUCCEEDED(hresReturn) )
    {
        hresReturn = pCryptoStorage->GetSessionKeyBlob( ppSessionKeyBlob );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->GetSessionKeyBlob Failed - error 0x%0x\n", hresReturn));
        }
    }

    return hresReturn;

}   // InitStorageAndSessionKey


HRESULT
InitStorageAndSessionKey2(
    IN LPSTR pszPasswd,
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider2( &hProv );
    if( SUCCEEDED(hresReturn) )
    {
        hresReturn = ((IIS_CRYPTO_STORAGE2*)pCryptoStorage)->Initialize(
                         hProv
                         );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->Initialize Failed - error 0x%0x\n", hresReturn));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: GetCryptoProvider2 Failed - error 0x%0x\n", hresReturn));
    }

    if( SUCCEEDED(hresReturn) )
    {
        hresReturn = ((IIS_CRYPTO_STORAGE2*)pCryptoStorage)->GetSessionKeyBlob( pszPasswd, ppSessionKeyBlob );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->GetSessionKeyBlob Failed - error 0x%0x\n", hresReturn));
        }
    }

    return hresReturn;

}   // InitStorageAndSessionKey2


VOID
SkipPathDelimeter(IN OUT LPSTR &rpszPath,
                    IN BOOL bUnicode)
{
    if (bUnicode) {
        LPWSTR pszPath = (LPWSTR)rpszPath;
        SKIP_PATH_DELIMETERW(pszPath);
        rpszPath = (LPSTR)pszPath;
    }
    else {
        SKIP_PATH_DELIMETERA(rpszPath);
    }
}

BOOL
IsStringTerminator(IN LPTSTR pszString,
                   IN BOOL bUnicode)
{
    if (bUnicode) {
        if (*(LPWSTR)pszString == (WCHAR)L'\0') {
            return TRUE;
        }
    }
    else {
        if (*(LPSTR)pszString == (CHAR)'\0') {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
GetLastHResult() {
    DWORD tmp = GetLastError();
    return RETURNCODETOHRESULT(tmp);
}


HRESULT STDMETHODCALLTYPE  BackupCertificates (LPCWSTR  backupName,PCHAR lpszToPath,PCHAR lpszFromPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    CHAR                *p1,*p2;
    LPSTR               searchMask = "*.mp";
    LPSTR               backupNameSeparator = ".";
    CHAR                strSourcePath[MAX_PATH];
    CHAR                strSearchPattern[MAX_PATH];
    CHAR                strDestPath[MAX_PATH];
    DWORD               dwLenOfBackupName, n1;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FileInfo;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSrcFileName, strDestFileName;

    dwLenOfBackupName = (DWORD)(wcslen (backupName) * sizeof (WCHAR));
    p1 = strrchr (lpszFromPath,'\\');
    p2 = strrchr (lpszToPath,'\\');
    if (p1 &&p2)
    {
        n1 = min (MAX_PATH-1, (DWORD)DIFF(p1 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;
        strcpy (strSearchPattern,strSourcePath);

        n1 = min (MAX_PATH-1, (DWORD)DIFF(p2 - lpszToPath)+1);
        strncpy (strDestPath,lpszToPath,n1);
        strDestPath[n1] = 0;

        if (strlen (strSourcePath) +  strlen(searchMask) < MAX_PATH)
        {
            strcat (strSearchPattern,searchMask);
            hFindFile = FindFirstFile( strSearchPattern, &FileInfo);

            if (hFindFile == INVALID_HANDLE_VALUE)
            {
                // no certificate file found
                return ERROR_SUCCESS;
            }

            while (fFoundFile)
            {
                if ( strlen (FileInfo.cFileName) + strlen (strDestPath) + dwLenOfBackupName + 1 < MAX_PATH)
                {

                    fValid = strSrcFileName.Copy (strSourcePath);
                    fValid = fValid && strSrcFileName.Append (FileInfo.cFileName);

                    fValid = fValid && strDestFileName.Copy (strDestPath);
                    fValid = fValid && strDestFileName.Append ((LPWSTR)backupName);
                    fValid = fValid && strDestFileName.Append (backupNameSeparator);
                    fValid = fValid && strDestFileName.Append (FileInfo.cFileName);

                    if (fValid)
                    {
                        if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                        {
                            IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));
                        }
                    }
                    else
                    {
                        IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));
                    }

                }

                fFoundFile = FindNextFile(hFindFile,&FileInfo);
            }
            fFoundFile = FindClose (hFindFile);
            MD_ASSERT (fFoundFile);
        }
        else
        {
            IIS_PRINTF((buff,"CertificateBackup: strSourcePath filename was too long\n"));
        }
    }
    else
    {
        IIS_PRINTF((buff,"CertificateBackup: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE  RestoreCertificates (LPCWSTR  backupName,PCHAR lpszFromPath,PCHAR lpszToPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    DWORD               n1;
    CHAR                strDestinationPath[MAX_PATH];
    CHAR                strSourcePath[MAX_PATH];
    CHAR                *p1,*p2;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSearchPatttern, strDestFileName, strSrcFileName;
    WIN32_FIND_DATAW    FileInfo;
    LPWSTR              pszSearchPattern = NULL;


    p1 = strrchr (lpszToPath,'\\');
    p2 = strrchr (lpszFromPath,'\\');


    if (p1 &&p2)
    {

        n1 = min (MAX_PATH-1, (DWORD)DIFF(p1 - lpszToPath)+1);
        strncpy (strDestinationPath,lpszToPath,n1);
        strDestinationPath[n1] = 0;

        n1 = min (MAX_PATH-1, (DWORD)DIFF(p2 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;


        strSearchPatttern.Copy (strSourcePath);
        strSearchPatttern.Append ((LPWSTR)backupName);
        strSearchPatttern.Append ((LPWSTR)L".*.mp");

        pszSearchPattern = strSearchPatttern.QueryStrW();
        if( !( pszSearchPattern ) )
        {
            return ERROR_SUCCESS;
        }

        hFindFile = FindFirstFileW( pszSearchPattern, &FileInfo);

        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            // no certificate file found
            return ERROR_SUCCESS;
        }

        while (fFoundFile)
        {
            fValid = strDestFileName.Copy (strDestinationPath);
            fValid = fValid && strDestFileName.Append ((LPWSTR)(FileInfo.cFileName + wcslen (backupName) +1));

            fValid = fValid && strSrcFileName.Copy (strSourcePath);
            fValid = fValid && strSrcFileName.Append ((LPWSTR)FileInfo.cFileName);

            if (fValid)
            {
                if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                {
                    IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));
                }
            }
            else
            {
                IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));
            }

            fFoundFile = FindNextFileW(hFindFile,&FileInfo);
        }
        fFoundFile = FindClose (hFindFile);
        MD_ASSERT (fFoundFile);
    }
    else
    {
        IIS_PRINTF((buff,"CertificateRestore: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));
    }

    return hresReturn;

}



HRESULT
ReadMetaObject(IN CMDBaseObject*&     cboRead,
               IN LPWSTR              wszPath,
               IN FILETIME*           pFileTime,
               IN BOOL                bUnicode)
/*++

Routine Description:

    Read a meta object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:


    Read       - Place to return the created object.
    Path       - Object path



Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS

Notes:

--*/
{
    HRESULT        hresReturn;
    CMDBaseObject* pboParent;
    WCHAR          strName[METADATA_MAX_NAME_LEN];
    FILETIME       ftTime;
    PFILETIME      pftParentTime;
    FILETIME       ftParentTime;
    LPTSTR         strObjectName;

    //
    // This should never be called for the root object.
    // If it is return without doing anything.
    //

    if(0 == wcscmp(wszPath, L"/"))
        return S_OK;

    //
    // TODO: What to do about file time?
    //

    ftTime = *(UNALIGNED FILETIME *)(pFileTime);

    strObjectName = (LPTSTR)wszPath;    //
                                        // It is OK to cast because we are always passing unicode
                                        // and bUnicode is always set to TRUE when this function
                                        // is called.
                                        //

    hresReturn = GetObjectFromPath(pboParent,
                                   METADATA_MASTER_ROOT_HANDLE,
                                   METADATA_PERMISSION_READ,
                                   strObjectName,
                                   bUnicode);

    //
    // This should return ERROR_PATH_NOT_FOUND and the parent object,
    // with strObjectLine set to the remainder of the path,
    // which should be the child name, without a preceding delimeter.
    //

    if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
        MD_ASSERT(pboParent != NULL);
        if (bUnicode) {
            hresReturn = ExtractNameFromPath((LPWSTR *)&strObjectName, (LPWSTR)strName);
        }
        else {
            hresReturn = ExtractNameFromPath((LPSTR)strObjectName, (LPSTR)strName);
        }
        if (SUCCEEDED(hresReturn)) {
            CMDBaseObject *pboNew;
            if (bUnicode) {
                pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
            }
            else {
                pboNew = new CMDBaseObject((LPSTR)strName, NULL);
            }
            if (pboNew == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else if (!pboNew->IsValid()) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
            }
            else {
                //
                // InsertChildObject sets the last change time to current time.
                // This isn't really a change, so save and restore time.
                //
                pftParentTime = pboParent->GetLastChangeTime();
                ftParentTime = *pftParentTime;
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (SUCCEEDED(hresReturn)) {
                    pboParent->SetLastChangeTime(&ftParentTime);
                    pboNew->SetLastChangeTime(&ftTime);
                    cboRead = pboNew;
                }
                else {
                    delete (pboNew);
                }
            }
        }
    }
    else if (SUCCEEDED(hresReturn)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
    }

    return (hresReturn);
}


HRESULT
ReadDataObject(
         IN CMDBaseObject*      cboAssociated,
         LPVOID*                a_pv,
         ULONG*                 a_Size,
         IN IIS_CRYPTO_STORAGE* pCryptoStorage,
         IN BOOL                bUnicode)

/*++

Routine Description:

    Read a data object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Associated - The associated meta object.

    Buffer     - DataBuffer from config containing data.

    Size buffer - Size buffer for data.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS
                 ERROR_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    PFILETIME pftTime;
    FILETIME ftTime;
    PBYTE pbDataValue;
    STACK_BUFFER( bufAlignedValue, 256 );
    DWORD dwDataLength;
    PIIS_CRYPTO_BLOB blob = NULL;

    // Assert that these pointers are always valid.
    MD_ASSERT(a_pv[iMBProperty_ID] != NULL);
    MD_ASSERT(a_pv[iMBProperty_Attributes] != NULL);
    MD_ASSERT(a_pv[iMBProperty_UserType] != NULL);
    MD_ASSERT(a_pv[iMBProperty_Type] != NULL);


    mdrData.dwMDIdentifier = *(DWORD *)(a_pv[iMBProperty_ID]);
    mdrData.dwMDAttributes = *(DWORD *)(a_pv[iMBProperty_Attributes]);
    mdrData.dwMDUserType   = *(DWORD *)(a_pv[iMBProperty_UserType]);
    mdrData.dwMDDataType = *(DWORD *)(a_pv[iMBProperty_Type]);

    // Assert that catalog returns a valid type.
    MD_ASSERT(mdrData.dwMDDataType < INVALID_END_METADATA );

    pbDataValue = (PBYTE)a_pv[iMBProperty_Value];
    dwDataLength = a_Size[iMBProperty_Value];

    if (IsSecureMetadata(mdrData.dwMDIdentifier, mdrData.dwMDAttributes) &&
        pCryptoStorage != NULL) {

        //
        // This is a secure data object, we we'll need to decrypt it
        // before proceeding. Note that we must clone the blob before
        // we can actually use it, as the blob data in the line buffer
        // is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
        // the only IISCrypto function that can handle unaligned data.)
        //

        if(0 != dwDataLength)
        {
            // ::IISCryptoCloneBlobFromRawData cannot handle 0 length
            // Hence this work around.

            hresReturn = ::IISCryptoCloneBlobFromRawData(
                             &blob,
                             pbDataValue,
                             dwDataLength
                             );

            if (SUCCEEDED(hresReturn)) {
                DWORD dummyRegType;

                MD_ASSERT(::IISCryptoIsValidBlob(blob));
                hresReturn = pCryptoStorage->DecryptData(
                                       (PVOID *)&pbDataValue,
                                       &dwDataLength,
                                       &dummyRegType,
                                       blob
                                       );

            }
        }
        else
        {
            hresReturn = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        if(FAILED(hresReturn))
        {
            LogEvent(g_pEventLog,
                     MD_WARNING_UNABLE_TO_DECRYPT,
                     EVENTLOG_WARNING_TYPE,
                     ID_CAT_CAT,
                     hresReturn,
                     (LPWSTR)(a_pv[iMBProperty_Location]),
                     (LPWSTR)(a_pv[iMBProperty_Name]));

        }


    } else {

        //
        // The metadata was not secure, so decryption was not required.
        // Nonetheless, it must be copied to an aligned buffer...
        //

        if( !bufAlignedValue.Resize( dwDataLength ) )
        {
            hresReturn = HRESULT_FROM_WIN32( GetLastError() );
        }
        else
        {
            memcpy( bufAlignedValue.QueryPtr(), pbDataValue, dwDataLength );
            pbDataValue = ( PBYTE )bufAlignedValue.QueryPtr();
        }
    }

    if (SUCCEEDED(hresReturn)) {
        mdrData.pbMDData = pbDataValue;

        switch (mdrData.dwMDDataType) {
            case DWORD_METADATA: {
                if (dwDataLength != sizeof(DWORD)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);

                    DBGINFOW((DBG_CONTEXT,
                              L"Error: Invalid dword length. Length %d. Property id: %d. location: %s. hr = 0x%x.\n",
                               dwDataLength,
                               mdrData.dwMDIdentifier,
                               (LPWSTR)a_pv[iMBProperty_Location],
                               hresReturn));
                }
                break;
            }
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
            {
                if ((LONG)dwDataLength < 1 ||
                    (!bUnicode && (pbDataValue[dwDataLength-1] != '\0')) ||
                    (bUnicode && *(((LPWSTR)pbDataValue) + ((dwDataLength / sizeof(WCHAR)) -1)) != (WCHAR)L'\0')) {

                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);

                    DBGINFOW((DBG_CONTEXT,
                              L"Error: Invalid string. Length %d. Property id: %d. location: %s. hr = 0x%x.\n",
                               dwDataLength,
                               mdrData.dwMDIdentifier,
                               (LPWSTR)a_pv[iMBProperty_Location],
                               hresReturn));

                }
                break;
            }
            case BINARY_METADATA:
            {
                mdrData.dwMDDataLen = dwDataLength;
                break;
            }
            case MULTISZ_METADATA:
            {
                if (bUnicode) {
                    if (dwDataLength < (2 * sizeof(WCHAR)) ||
                        *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-1)) != (WCHAR)L'\0' ||
                        *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-2)) != (WCHAR)L'\0') {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);

                        DBGINFOW((DBG_CONTEXT,
                                  L"[ReadDataObject] Error: Invalid multisz. Length %d. Property id: %d. location: %s. hr = 0x%x.\n",
                                  dwDataLength,
                                  mdrData.dwMDIdentifier,
                                  (LPWSTR)a_pv[iMBProperty_Location],
                                  hresReturn));

                    }
                }
                else {
                    if (dwDataLength < 2 ||
                        pbDataValue[dwDataLength-1] != '\0' ||
                        pbDataValue[dwDataLength-2] != '\0') {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    mdrData.dwMDDataLen = dwDataLength;
                }
                break;
            }
            default: {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // SetDataObject sets the last change time to current time.
        // This isn't really a change, so save and restore time.
        //
        pftTime = cboAssociated->GetLastChangeTime();
        ftTime = *pftTime;
        hresReturn = cboAssociated->SetDataObject(&mdrData, bUnicode);
        cboAssociated->SetLastChangeTime(&ftTime);
    }

    if (blob != NULL) {
        ::IISCryptoFreeBlob(blob);
    }

    return(hresReturn);
}


HRESULT
SaveAllData(
         IN BOOL bSetSaveDisallowed,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
         IN LPWSTR pwszBackupLocation,
         IN LPWSTR pwszSchemaLocation,
         IN METADATA_HANDLE hHandle,
         IN BOOL bHaveReadSaveSemaphore,
         IN BOOL bTerminating
         )
/*
++

Routine Description:

    Saves all meta data.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT               hresReturn                             = ERROR_SUCCESS;
    HRESULT               hresReturnSav                          = ERROR_SUCCESS;
    HANDLE                hTempFileHandle                        = INVALID_HANDLE_VALUE;
    BOOL                  bDeleteTemp                            = TRUE;
    DWORD                 dwTempLastSaveChangeNumber             = 0;
    BOOL                  bSaveNeeded                            = FALSE;
    DWORD                 ulHistoryMajorVersionNumber            = 0;
    DWORD                 dwEnableHistory                        = 0;
    DWORD                 dwMaxHistoryFiles                      = 0;
    LPWSTR                pwszRealFileName                       = NULL;
    LPWSTR                pwszSchemaFileName                     = NULL;
    LPWSTR                pwszTempFileName                       = g_wszTempFileName;
    LPWSTR                pwszBackupFileName                     = g_wszBackupFileName;
    SECURITY_ATTRIBUTES   saStorage;
    BOOL                  bRenameMetabase                        = TRUE;
    FILETIME              MostRecentMetabaseFileLastWriteTimeStamp = g_MostRecentMetabaseFileLastWriteTimeStamp;
    ULONG                 ulMostRecentMetabaseVersion            = 0;
    BOOL                  bMRLock                                = false;
    bool                  bMRReadLock                            = false;
    DWORD                 dwError;

    //
    // Figure out the schema and data file names. Note that pwszBackupLocation
    // and pwszSchemaLocation are passed in during backup restore only.
    //

    if( !pwszBackupLocation )
    {
        pwszRealFileName = g_wszRealFileName;
    }
    else
    {
        pwszRealFileName = pwszBackupLocation;
    }

    if( !pwszSchemaLocation )
    {
        pwszSchemaFileName = g_wszSchemaFileName;
    }
    else
    {
        pwszSchemaFileName = pwszSchemaLocation;
    }

    //
    // If ReadSaveSemaphore hasnt been already taken, then take it.
    //

    if (!bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    if(g_bSaveDisallowed)
    {
        goto exit;
    }

    g_bSaveDisallowed = bSetSaveDisallowed;

    //
    // Write to a temp file first in case there are errors.
    // Create the temp file
    //

    if (g_psdStorage != NULL)
    {
        saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
        saStorage.lpSecurityDescriptor = g_psdStorage;
        saStorage.bInheritHandle = FALSE;
    }

    hTempFileHandle = CreateFileW(pwszTempFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  0,
                                  &saStorage,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                  0);

    if (hTempFileHandle == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwError);
        goto exit;
    }

    //
    // Lock the in-memory metabase (master resource) to prevent writes.
    //

    bMRReadLock = g_LockMasterResource.ReadOrWriteLock();
    bMRLock = true;

    if ((pwszBackupLocation) ||
        (g_dwLastSaveChangeNumber != g_dwSystemChangeNumber))
    {
        //
        // Only Save if changes have been made since the last save.
        //

        bSaveNeeded = TRUE;

        hresReturn = SaveEntireTree(pCryptoStorage,
                                    pSessionKeyBlob,
                                    hHandle,
                                    pwszSchemaLocation,
                                    pwszSchemaFileName,
                                    &saStorage,
                                    hTempFileHandle);

        //
        // Must have MasterResource when accessing SystemChangeNumber
        // so save it away here. Only update LastSaveChangeNumber on success.
        //

        dwTempLastSaveChangeNumber  = g_dwSystemChangeNumber;
        ulHistoryMajorVersionNumber = g_ulHistoryMajorVersionNumber;
        dwEnableHistory             = g_dwEnableHistory;
        ValidateMaxHistoryFiles();
        dwMaxHistoryFiles           = g_dwMaxHistoryFiles;

        DetermineIfMetabaseCanBeRenamed(pwszBackupLocation,
                                        pwszRealFileName,
                                        bTerminating,
                                        &bRenameMetabase);

    }

    if(NULL != g_pListenerController)
    {
        if(g_dwEnableEditWhileRunning)
        {
            hresReturnSav = g_pListenerController->Start();
        }
        else
        {
            hresReturnSav = g_pListenerController->Stop(iSTATE_STOP_TEMPORARY,
                                                        NULL);
        }

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = hresReturnSav;
        }
    }

    //
    // Unlock the in-memory metabase once it has been saved to the temp file.
    // Unlock the metabase file once the temp file has been created.
    //

    if(bMRLock)
    {
        g_LockMasterResource.ReadOrWriteUnlock(bMRReadLock);
        bMRLock = false;
    }

    if (!CloseHandle(hTempFileHandle))
    {
        if(SUCCEEDED(hresReturn))
        {
            dwError = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwError);
        }
    }

    if(FAILED(hresReturn) || (!bSaveNeeded))
    {
        goto exit;
    }

    if(bRenameMetabase)
    {
        //
        // Update the  g_MostRecentMetabaseSaveTimeStamp value
        // to the current time stamp, just before the move and rename.
        // Note that if the rename is not happening, then we needn't
        // update the values because a notification will not be sent.
        // Also, update the g_MostRecentMetabaseFileLastWriteTimeStamp
        // even if EWR is not enabled, because if EWR is disabled and
        // while the server is running, you enable it, then you will
        // want the last saved time stamp to determine the rename.
        //

        WIN32_FILE_ATTRIBUTE_DATA  CurrentMetabaseTempFileAttr;
        BOOL                       bFetchedCurrentMetabaseAttr = TRUE;

        if(!GetFileAttributesExW(pwszTempFileName,
                                 GetFileExInfoStandard,
                                 &CurrentMetabaseTempFileAttr)
          )
        {
            //
            // Could not fetch the current file attributes for the temporary metabase file.
            //

            DWORD dwRes = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwRes);

            DBGINFOW((DBG_CONTEXT,
                     L"[SaveAllData] Could not fetch the current file attributes for the temporary metabase file. GetFileAttributesEx on %s failed with hr = 0x%x.\n",
                     pwszTempFileName,
                     hresReturn));
            bFetchedCurrentMetabaseAttr = FALSE;
        }

        EnterCriticalSection(&g_csEditWhileRunning);
        MostRecentMetabaseFileLastWriteTimeStamp   = g_MostRecentMetabaseFileLastWriteTimeStamp;
        ulMostRecentMetabaseVersion                = g_ulMostRecentMetabaseVersion;
        g_ulMostRecentMetabaseVersion              = ulHistoryMajorVersionNumber;
        g_bSavingMetabaseFileToDisk                = TRUE;
        if(bFetchedCurrentMetabaseAttr)
        {
            g_MostRecentMetabaseFileLastWriteTimeStamp = CurrentMetabaseTempFileAttr.ftLastWriteTime;
        }
        else
        {
            // Unable to fetch the time stamp - hence reset g_MostRecentMetabaseFileLastWriteTimeStamp
            // to zeroes. This will force the next SaveAllData to rename - else we may land up in a
            // condition where we never rename, because the comparisons will always fail (because
            // the timestamp on the file would have changed and the
            // g_MostRecentMetabaseFileLastWriteTimeStamp will have a stale value)
            //
            memset((LPVOID)&g_MostRecentMetabaseFileLastWriteTimeStamp, 0, sizeof(FILETIME));

        }
        LeaveCriticalSection(&g_csEditWhileRunning);
    }

    hresReturn = SaveMetabaseFile(pwszSchemaFileName,
                                  ulHistoryMajorVersionNumber,
                                  dwEnableHistory,
                                  dwMaxHistoryFiles,
                                  dwTempLastSaveChangeNumber,
                                  bRenameMetabase,
                                  pwszTempFileName,
                                  pwszRealFileName,
                                  pwszBackupFileName,
                                  pwszBackupLocation,
                                  &bDeleteTemp);

    if (FAILED(hresReturn))
    {
        if(bRenameMetabase)
        {
            //
            // The previous time stamp would have been updated to
            // the current tempfile timestamp just before the move
            // is attempted. If the move of the temp file to the
            // real file fails, then we must reset this time stamp.
            //

            EnterCriticalSection(&g_csEditWhileRunning);
            g_MostRecentMetabaseFileLastWriteTimeStamp   = MostRecentMetabaseFileLastWriteTimeStamp;
            g_ulMostRecentMetabaseVersion                = ulMostRecentMetabaseVersion;
            LeaveCriticalSection(&g_csEditWhileRunning);
        }
        goto exit;
    }
    else
    {

        //
        // Update Change Number
        // Must have ReadSaveSemaphore when accessing this.
        // Note that we are updating the change number only if
        // we have renamed the metabase. If we have not renamed the
        // metabase, then we not not update the last save change number.
        // This will force another save attempt when the next SaveAllData
        // is called, therby ensuring that at some point the metabase
        // file will get updated.
        //

        if(bRenameMetabase)
        {
            g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
        }
    }

exit:

    if(bMRLock)
    {
        g_LockMasterResource.ReadOrWriteUnlock(bMRReadLock);
        bMRLock = false;
    }

    if(bTerminating)
    {
        //
        // Unlock the metabase if terminating - irrespective of failure.
        //

        hresReturnSav = S_OK;

        hresReturnSav = UnlockMetabaseFile(eMetabaseDataFile,
                                           TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Unlocking metabase file %s returned 0x%x.\n",
                  pwszRealFileName,
                  hresReturnSav));

        if(SUCCEEDED(hresReturnSav))
        {

            hresReturnSav = UnlockMetabaseFile(eMetabaseSchemaFile,
                                               TRUE);

            DBGINFOW((DBG_CONTEXT,
                      L"[SaveAllData] Unlocking metabase file %s returned 0x%x.\n",
                      pwszSchemaFileName,
                      hresReturnSav));
        }

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = hresReturnSav;
        }

    }

    if (bDeleteTemp && (hTempFileHandle != INVALID_HANDLE_VALUE))
    {
        DeleteFileW(pwszTempFileName);
        hTempFileHandle = INVALID_HANDLE_VALUE;
    }

    if (!bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if ( FAILED( hresReturn ))
    {
        LogEvent(g_pEventLog,
                 MD_ERROR_UNABLE_TOSAVE_METABASE,
                 EVENTLOG_ERROR_TYPE,
                 ID_CAT_CAT,
                 hresReturn);

        DBGPRINTF(( DBG_CONTEXT, "Failed to flush metabase - error 0x%08lx\n", hresReturn));
    }

    return hresReturn;

} // SaveAllData


HRESULT
SaveEntireTree(IN  IIS_CRYPTO_STORAGE*     pCryptoStorage,
               IN  PIIS_CRYPTO_BLOB        pSessionKeyBlob,
               IN  METADATA_HANDLE         hHandle,
               IN  LPWSTR                  pwszSchemaLocation,
               IN  LPWSTR                  pwszSchemaFileName,
               IN  PSECURITY_ATTRIBUTES    psaStorage,
               IN  HANDLE                  hTempFileHandle)
/*
++

Routine Description:

    Saves the metabase tree to disk.

Arguments:
    [in] Crypto object for encryption/decryption.
    [in] Session key blob.
    [in] Handle to in-memory metabase.
    [in] Schema location (used only for backup/restore)
    [in] Schema file name.
    [in] Security Attributes to set on the file.
    [in] File handle of the temp file.

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT                hresReturn              = S_OK;
    HRESULT                hresReturnSav           = S_OK;
    BUFFER*                pbufParentPath          = NULL;
    PBASEOBJECT_CONTAINER  objChildObjectContainer = NULL;
    CWriter*               pCWriter                = NULL;
    ULONG                  cChildObjects           = 0;
    ULONG                  iChildObjects           = 0;
    PBASEOBJECT_CONTAINER  arrFixedChildObjects[MD_MAX_CHILD_OBJECTS];
    PBASEOBJECT_CONTAINER* arrChildObject          = arrFixedChildObjects;

    if (hHandle != METADATA_MASTER_ROOT_HANDLE)
    {
        CMDHandle *phoHandle;
        phoHandle = GetHandleObject(hHandle);

        if ((phoHandle == NULL) ||
            (phoHandle->GetObject() != g_pboMasterRoot))
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
        }
        else if ((!phoHandle->IsReadAllowed()) &&
                 (!phoHandle->IsWriteAllowed()))
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
        }
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    pbufParentPath = new BUFFER(4);
    if( pbufParentPath == NULL )
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    *(LPWSTR)pbufParentPath->QueryPtr() = MD_PATH_DELIMETERW;
    ((LPWSTR)pbufParentPath->QueryPtr())[1] = (WCHAR)L'\0';

    //
    // TODO: Need to add the following:
    //       MD_ID_MAJOR_VERSION_NUMBER
    //       MD_ID_MINOR_VERSION_NUMBER
    //

    if( pwszSchemaLocation )
    {
        //
        // Bump up g_dwSchemaChangeNumber to force save MBSchema.XML
        // This (pszSchemaLocation being non-null) is in
        // the case of Restore.
        //
        g_dwSchemaChangeNumber++;

    }

    //
    // Unlock the schema file before compile
    //

    if(NULL == pwszSchemaLocation)
    {
        hresReturn = UnlockMetabaseFile(eMetabaseSchemaFile,
                                        TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Unlocking metabase file %s returned 0x%x.\n",
                  pwszSchemaFileName,
                  hresReturn));

        if(FAILED(hresReturn))
        {
            goto exit;
        }
    }

    hresReturn = SaveSchemaIfNeeded(pwszSchemaFileName,
                                    psaStorage);

    //
    // Lock the metabase file even if compile has failed or even if EWR is
    // enabled - we do not allow users to edit the schema file.
    //

    if(NULL == pwszSchemaLocation)
    {
        hresReturnSav = LockMetabaseFile(pwszSchemaFileName,
                                         eMetabaseSchemaFile,
                                         TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Locking metabase file %s returned 0x%x.\n",
                  pwszSchemaFileName,
                  hresReturnSav));

        if(FAILED(hresReturnSav) && SUCCEEDED(hresReturn))
        {
            hresReturn = hresReturnSav;
        }
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    // Assert g_pGlobalISTHelper is valid.
    MD_ASSERT( g_pGlobalISTHelper != NULL);

    DBGINFOW((DBG_CONTEXT,
              L"[SaveAllData] Initializing writer with write file: %s bin file: %s.\n",
              g_wszTempFileName,
              g_pGlobalISTHelper->m_wszBinFileForMeta));

    pCWriter = new CWriter();

    if(NULL == pCWriter)
    {
        hresReturn = E_OUTOFMEMORY;
        goto exit;
    }

    hresReturn = pCWriter->Initialize(g_wszTempFileName,
                                      g_pGlobalISTHelper,
                                      hTempFileHandle);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    hresReturn = pCWriter->BeginWrite(eWriter_Metabase);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Save the global location first
    //

    hresReturn = SaveGlobalsToXML(pCWriter,
                                  pSessionKeyBlob);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Save the master root.
    //

    hresReturn = SaveMasterRoot(pCWriter,
                                pCryptoStorage,
                                pSessionKeyBlob);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Enumerate all the subnodes and write all the sub-nodes, in a sorted manner.
    //

    //
    // First pass, count the number of child objects
    //

    for(objChildObjectContainer=g_pboMasterRoot->NextChildObject(NULL);
        (SUCCEEDED(hresReturn)) && (objChildObjectContainer!=NULL);
        objChildObjectContainer=g_pboMasterRoot->NextChildObject(objChildObjectContainer)) {
            cChildObjects++;
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Allocate memory if greater than whats allocated on the stack.
    //

    if(cChildObjects > MD_MAX_CHILD_OBJECTS)
    {
        arrChildObject = new PBASEOBJECT_CONTAINER[cChildObjects];
        if(NULL == arrChildObject)
        {
            hresReturn = E_OUTOFMEMORY;
            goto exit;
        }
    }

    //
    // Make another pass and populate the array
    //

    for(objChildObjectContainer=g_pboMasterRoot->NextChildObject(NULL),iChildObjects=0;
        (SUCCEEDED(hresReturn)) && (objChildObjectContainer!=NULL);
        objChildObjectContainer=g_pboMasterRoot->NextChildObject(objChildObjectContainer),iChildObjects++) {
        arrChildObject[iChildObjects] = objChildObjectContainer;
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Sort the array
    //

    qsort((void*)arrChildObject, cChildObjects, sizeof(PBASEOBJECT_CONTAINER), MyComparePBaseObjectContainer);

    //
    // Enumerate the sorted array of child objects and call SaveTree on each of them
    //

    for(iChildObjects=0;
        (SUCCEEDED(hresReturn)) && (iChildObjects<cChildObjects);
        iChildObjects++) {

        BOOL bLocalMachine = FALSE;

        if(0 == _wcsnicmp((LPWSTR)((arrChildObject[iChildObjects])->pboMetaObject->GetName(TRUE)), g_wszSchema, g_cchSchema))
        {
            //
            // No need to save the schema tree in data file.
            //

            #ifndef _SAVE_SCHEMA_TREE_IN_DATA_FILE_
            continue;
            #endif  _SAVE_SCHEMA_TREE_IN_DATA_FILE_

        }
        else if(0 == _wcsnicmp((LPWSTR)((arrChildObject[iChildObjects])->pboMetaObject->GetName(TRUE)), g_wszLM, g_cchLM))
        {
            bLocalMachine = TRUE;
        }

        hresReturn = SaveTree(pCWriter,
                              (arrChildObject[iChildObjects])->pboMetaObject,
                              pbufParentPath,
                              pCryptoStorage,
                              pSessionKeyBlob,
                              TRUE,
                              TRUE,
                              bLocalMachine);

    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    hresReturn = pCWriter->EndWrite(eWriter_Metabase);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

exit:

    if(NULL != pCWriter)
    {
        delete pCWriter;
        pCWriter = NULL;
    }

    if ( pbufParentPath != NULL )
    {
        pbufParentPath->FreeMemory();
        delete(pbufParentPath);
    }

    if((NULL != arrChildObject) && (arrChildObject != arrFixedChildObjects) )
    {
        delete [] arrChildObject;
        arrChildObject = NULL;
    }

    return hresReturn;

} // SaveEntireTree


HRESULT
SaveMetabaseFile(IN  LPWSTR pwszSchemaFileName,
                 IN  ULONG  ulHistoryMajorVersionNumber,
                 IN  DWORD  dwEnableHistory,
                 IN  DWORD  dwMaxHistoryFiles,
                 IN  DWORD  ,
                 IN  BOOL   bRenameMetabase,
                 IN  LPWSTR pwszTempFileName,
                 IN  LPWSTR pwszRealFileName,
                 IN  LPWSTR pwszBackupFileName,
                 IN  LPWSTR pwszBackupLocation,
                 OUT BOOL*  pbDeleteTemp)
/*
++

Routine Description:

    Creates the history file and moves the temp file to the
    real xml file.

Arguments:
    [in] Schema file name.
    [in] History major version number.
    [in] Enable history.
    [in] Max history files.
    [in] Last save change number.
    [in] Bool to indicate rename temp file to xml file or not.
    [in] Temp file name.
    [in] Real file name.
    [in] Schema file name.
    [in] Backup file name.
    [in] Backup location.
    [out] Bool to indicate delete temp or not.

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = S_OK;
    DWORD   dwTemp     = 0;
    BOOL    bUnlocked  = FALSE;

    //
    // Save the temp file in the history directory.
    // If we are unable to create a history, then we
    // will not be able to diff if someone makes changes.
    // Hence we will have to error at the time of diffing.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[SaveAllData] HistoryMajorVersionNumber: %d.\n", g_ulHistoryMajorVersionNumber));

    DBGINFOW((DBG_CONTEXT,
              L"[SaveAllData] HistoryMajorVersionNumber: %d.\n", ulHistoryMajorVersionNumber));

    //
    // We want to create history files only if we are saving to the actual
    // metabase.xml (and not to a backup file)
    //
    if(dwEnableHistory && NULL == pwszBackupLocation)
    {
        CreateHistoryFiles(g_wszTempFileName,
                           pwszSchemaFileName,
                           ulHistoryMajorVersionNumber,
                           dwMaxHistoryFiles);
    }

    //
    // New data file created successfully
    // Backup real file and copy temp
    // to real
    //
    if(g_dwEnableEditWhileRunning && (!bRenameMetabase))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Edit while running is enabled and a user has edited the file and the edit hasn't been processed. Meanwhile SaveAllData has been called. Hence SaveAllData is not renaming the file, so that the user edits are not overwrittem.\n"));
        goto exit;

    }

    //
    // Unlock the metabase file just before the rename and if is not called from
    // backup.
    //

    if(NULL == pwszBackupLocation)
    {
        hresReturn = UnlockMetabaseFile(eMetabaseDataFile,
                                        TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveMetabaseFile] Unlocking metabase file %s returned 0x%x.\n",
                  pwszRealFileName,
                  hresReturn));

        if(FAILED(hresReturn))
        {
            goto exit;
        }

        bUnlocked = TRUE;
    }


    //
    // Rename the temp file to the real file
    //

    if (!MoveFileW(pwszTempFileName, pwszRealFileName))
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            dwTemp = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwTemp);
            goto exit;
        }

        //
        // Real File exists, so back it up
        //

        //
        // Bug #260590  If someone had attrib-ed the real file to
        // be read-only then we could land up in a state where the
        // backup file is read-only. Hence attrib the real file to
        // be read-write and then move it to the backup file.
        //

        ResetFileAttributesIfNeeded((LPTSTR)pwszRealFileName,
                                     TRUE);

        if (!MoveFileW(pwszRealFileName, pwszBackupFileName))
        {
            //
            // backup failed, check for old backup file
            //
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
                goto exit;
            }
            else if (!DeleteFileW(pwszBackupFileName))
            {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
                goto exit;
            }
            else if (!MoveFileW(pwszRealFileName, pwszBackupFileName))
            {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
                goto exit;
            }
        }

        //
        // Real file is backed up
        // so move in new file
        //

        if (!MoveFileW(pwszTempFileName, pwszRealFileName))
        {
            dwTemp = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwTemp);
            //
            // Moved real to backup but
            // failed to move temp to real
            // so restore from backup
            //
            if (!MoveFileW(pwszBackupFileName, pwszRealFileName))
            {
                //
                // Unable to write new file
                // or restore original file so don't delete backup
                //
                goto exit;
            }
        }

        DeleteFileW(pwszBackupFileName);
    }

exit:

    //
    // Lock the metabase file if edit while running is disabled and if it is
    // not called from backup and if it was unlocked above.
    //

    if((NULL == pwszBackupLocation) && (!g_dwEnableEditWhileRunning) && (bUnlocked))
    {
        HRESULT hresReturnSav = S_OK;

        hresReturnSav = LockMetabaseFile(pwszRealFileName,
                                         eMetabaseDataFile,
                                         TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveMetabaseFile] Locking metabase file %s returned 0x%x.\n",
                  pwszRealFileName,
                  hresReturn));

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = hresReturnSav;
        }

    }

    if (FAILED(hresReturn))
    {
        //
        // temp file was created ok but a problem
        // occurred while moving it to real
        // so don't delete it
        //
        *pbDeleteTemp = FALSE;

    }

    return hresReturn;
}


void
DetermineIfMetabaseCanBeRenamed(LPWSTR      pwszBackupLocation,
                                LPWSTR      pwszRealFileName,
                                BOOL        bTerminating,
                                BOOL*       pbRenameMetabase)
/*
++

Routine Description:

    Helper function to determine if the metabase can be renamed.
    It compares the current filetime with that of the last save
    and if not equal it tries to match it with the last processed
    edit while running timestamp.

Arguments:
    [in] Real file name.
    [in] Metabase file.
    [in] Bool to indicate terminating or not.
    [out] Bool to indicate rename or not.

Return Value:

    HRESULT

Notes:

--*/
{
    //
    // This function assumes that the g_masterResourceLock has been taken
    //

    HRESULT                     hr = S_OK;
    WIN32_FILE_ATTRIBUTE_DATA   CurrentAttr;
    static FILETIME             ZeroedTimeStamp;
    FILETIME                    MostRecentMetabaseFileLastWriteTimeStamp;
    FILETIME                    EWRProcessedMetabaseTimeStamp;

    memset((LPVOID)&ZeroedTimeStamp, 0, sizeof(FILETIME));

    EnterCriticalSection(&g_csEditWhileRunning);
    MostRecentMetabaseFileLastWriteTimeStamp = g_MostRecentMetabaseFileLastWriteTimeStamp;
    EWRProcessedMetabaseTimeStamp            = g_EWRProcessedMetabaseTimeStamp;
    LeaveCriticalSection(&g_csEditWhileRunning);

    if(!g_dwEnableEditWhileRunning)
    {
        *pbRenameMetabase = TRUE;
        return;
    }
    else if(NULL != pwszBackupLocation)
    {
        // Always rename for backup
        *pbRenameMetabase = TRUE;
        return;
    }
    else if(0 == memcmp(&MostRecentMetabaseFileLastWriteTimeStamp, &ZeroedTimeStamp, sizeof(FILETIME)))
    {
        //
        // This means that we were unable to initialize g_MostRecentMetabaseFileLastWriteTimeStamp
        // (this can happen when the metabase file is missing on startup, or, when we are unable to
        //  fetch the last write timestamp)
        //
        *pbRenameMetabase                = TRUE;
        return;
    }
    else
    {
        *pbRenameMetabase = FALSE;

        if(!GetFileAttributesExW(pwszRealFileName,
                                 GetFileExInfoStandard,
                                 &CurrentAttr)
          )
        {
            //
            // Could not fetch the current file attributes for the metabase file.
            // Assume that it cannot be renamed.
            //

            DWORD dwRes = GetLastError();
            hr = RETURNCODETOHRESULT(dwRes);

            DBGINFOW((DBG_CONTEXT,
                     L"[DetermineIfMetabaseCanBeRenamed] Coud not fetch file attributes of the metabase file. GetFileAttributesEx on %s failed with hr = 0x%x.\n",
                     pwszRealFileName,
                     hr));

            if( (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
                (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
              )
            {
                //
                // Perhaps someone deleted the file - ok to rename.
                //
                *pbRenameMetabase = TRUE;
            }
            else
            {
                //
                // Do not rename for this SaveAllData
                // Reset g_MostRecentMetabaseFileLastWriteTimeStamp so that the next SaveAllData will
                // rename - else we may land up in a condition where we never rename.
                //
                EnterCriticalSection(&g_csEditWhileRunning);
                memset((LPVOID)&g_MostRecentMetabaseFileLastWriteTimeStamp, 0, sizeof(FILETIME));
                LeaveCriticalSection(&g_csEditWhileRunning);
            }

            return;
        }

        DBGINFO((DBG_CONTEXT,
                 "[DetermineIfMetabaseCanBeRenamed] CURRENT TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n",
                 CurrentAttr.ftLastWriteTime.dwLowDateTime,
                 CurrentAttr.ftLastWriteTime.dwHighDateTime));

        DBGINFO((DBG_CONTEXT,
                 "[DetermineIfMetabaseCanBeRenamed] LAST SAVE TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n",
                 MostRecentMetabaseFileLastWriteTimeStamp.dwLowDateTime,
                 MostRecentMetabaseFileLastWriteTimeStamp.dwHighDateTime));

        DBGINFO((DBG_CONTEXT,
         "[DetermineIfMetabaseCanBeRenamed] LAST EWR PROCESSED TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n",
         EWRProcessedMetabaseTimeStamp.dwLowDateTime,
         EWRProcessedMetabaseTimeStamp.dwHighDateTime));


        if(0 == CompareFileTime(&(CurrentAttr.ftLastWriteTime), &MostRecentMetabaseFileLastWriteTimeStamp))
        {
            *pbRenameMetabase                = TRUE;
            return;
        }
        else if(0 == CompareFileTime(&(CurrentAttr.ftLastWriteTime), &EWRProcessedMetabaseTimeStamp))
        {
            *pbRenameMetabase                = TRUE;
            return;
        }
        else if(0 == memcmp(&EWRProcessedMetabaseTimeStamp, &ZeroedTimeStamp, sizeof(FILETIME)))
        {
            //
            // This means that we were unable to initialize g_EWRProcessedMetabaseTimeStamp
            // (this can happen when the EWR thread fails to get the file attribute or when it
            // shutsdown.
            //
            *pbRenameMetabase                = TRUE;
            return;
        }
        else if(bTerminating)
        {
            //
            // We always want to rename while terminating so that the metabase file reflects what was in memory.
            //

            DBGINFO((DBG_CONTEXT,
                     "[DetermineIfMetabaseCanBeRenamed] Metabase timestamp did not match last saved or last EWR processed timestamp. Renaming anyway.\n"));

            *pbRenameMetabase                = TRUE;
            return;
        }
        else
        {
            //
            // This means that the metabase timestamp was different from the last metabase save
            // and the last edit while running processed timestamp. We will not do the rename
            // this time around, but however we will reset the g_EWRProcessedMetabaseTimeStamp
            // so that the next time around, we will be forced to rename. This is because we do not always
            // want to always rely on filetimestamp comparison (which is known to return cached values).
            //
            EnterCriticalSection(&g_csEditWhileRunning);
            memset((LPVOID)&g_EWRProcessedMetabaseTimeStamp, 0, sizeof(FILETIME));
            LeaveCriticalSection(&g_csEditWhileRunning);

        }
    }


    return;

} // DetermineIfMetabaseCanBeRenamed


HRESULT
SaveMasterRoot(CWriter*            pCWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob
)
/*++

Routine Description:

    Save the master root object, including its data objects.

Arguments:

     CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT          hresReturn           = ERROR_SUCCESS;
    CMDBaseData*     dataAssociatedData   = NULL;
    DWORD            dwEnumObjectIndex;
    PFILETIME        pftTime;
    LPWSTR           wszKeyType           = NULL;
    CLocationWriter* pCLocationWriter     = NULL;
    LPWSTR           wszRootLocation      = L"/";
    DWORD            dwAttributes         = 0;
    DWORD            dwUserType           = 0;
    DWORD            dwDataType           = 0;
    ULONG            cbData               = 0;

    //
    // TODO: What to do about change time at node level?
    //

    pftTime = g_pboMasterRoot->GetLastChangeTime();

    //
    // Fetch the Location writer.
    //

    hresReturn = pCWriter->GetLocationWriter(&pCLocationWriter,
                                             wszRootLocation);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Figure out the KeyType of this node.
    //

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

            if(MD_KEY_TYPE == dataAssociatedData->GetIdentifier())
            {
                wszKeyType = (LPWSTR)dataAssociatedData->GetData(TRUE);
                dwAttributes = dataAssociatedData->GetAttributes();
                dwUserType =  dataAssociatedData->GetUserType();
                dwDataType =  dataAssociatedData->GetDataType();
                cbData = dataAssociatedData->GetDataLen(TRUE);
                break;
            }
    }

    //
    // Initialize the keytype at this node
    //

    hresReturn = pCLocationWriter->InitializeKeyType(MD_KEY_TYPE,
                                                     dwAttributes,
                                                     dwUserType,
                                                     dwDataType,
                                                     (PBYTE)wszKeyType,
                                                     cbData);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Save all the properties at this node
    //

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

        hresReturn = SaveDataObject(dataAssociatedData,
                                    pCLocationWriter,
                                    pCryptoStorage,
                                    pSessionKeyBlob);
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Write the node.
    //

    hresReturn = pCLocationWriter->WriteLocation(TRUE);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

exit:

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return(hresReturn);
}

void SaveGlobalsFromLM(CMDBaseData*  pbSave)
{
    if(pbSave->GetDataType() == DWORD_METADATA)
    {
        switch(pbSave->GetIdentifier())
        {
        case MD_ROOT_ENABLE_HISTORY:
            g_dwEnableHistory  = *(DWORD*)pbSave->GetData(TRUE);
            break;

        case MD_ROOT_MAX_HISTORY_FILES:
            g_dwMaxHistoryFiles = *(DWORD*)pbSave->GetData(TRUE);
            break;

        case MD_ROOT_ENABLE_EDIT_WHILE_RUNNING:
            g_dwEnableEditWhileRunning = *(DWORD*)pbSave->GetData(TRUE);
            break;

        case MD_MAX_ERROR_FILES:
            g_dwMaxErrorFiles = *(DWORD*)pbSave->GetData(TRUE);
            break;

        }
    }

    return;
}


HRESULT
SaveTree(IN CWriter*             pCWriter,
         IN CMDBaseObject*       pboRoot,
         IN BUFFER*              pbufParentPath,
         IN IIS_CRYPTO_STORAGE*  pCryptoStorage,
         IN PIIS_CRYPTO_BLOB     pSessionKeyBlob,
         IN BOOL                 bRecurse,   /* default = TRUE */
         IN BOOL                 bSaveSchema, /* default = TRUE */
         IN BOOL                 bLocalMachine /* default = FALSE */)
/*++

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    Root          - The root of the tree to save.

    CryptoStorage - Used to encrypt secure data.

    bRecurse      - Save Children as well.

    bSaveSchema   - If we end up at /schema node, call SaveTree on /schema.

    bLocalMachine - True if it is the /LM node.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER objChildObjectContainer = NULL;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;
    CLocationWriter*  pCLocationWriter = NULL;
    LPWSTR wszKeyType = NULL;
    DWORD dwAttributes = 0;
    DWORD dwUserType = 0;
    DWORD dwDataType = 0;
    DWORD cbData = 0;
    PBASEOBJECT_CONTAINER  arrFixedChildObjects[MD_MAX_CHILD_OBJECTS];
    PBASEOBJECT_CONTAINER* arrChildObject = arrFixedChildObjects;


    dwParentPathLen = (DWORD)wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = (DWORD)wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            if(pboRoot != g_pboMasterRoot) {
                wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
                strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
                strParentPath[dwNewParentPathLen - 1] = (WCHAR)L'\0';
            }
            pftTime = pboRoot->GetLastChangeTime();

            // TODO: MD_ID_OBJECT
            //       pftFileTIme?

            //
            // Fetch the Location writer.
            //

            hresReturn = pCWriter->GetLocationWriter(&pCLocationWriter,
                                                     strParentPath);

            //
            // Figure out the KeyType of this node.
            //

            for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

                    if(MD_KEY_TYPE == dataAssociatedData->GetIdentifier())
                    {
                        wszKeyType = (LPWSTR)dataAssociatedData->GetData(TRUE);
                        dwAttributes = dataAssociatedData->GetAttributes();
                        dwUserType =  dataAssociatedData->GetUserType();
                        dwDataType =  dataAssociatedData->GetDataType();
                        cbData = dataAssociatedData->GetDataLen(TRUE);
                        break;
                    }
            }

            //
            // Initialize the writer with the keytype
            //

            if(SUCCEEDED(hresReturn))
            {
                hresReturn = pCLocationWriter->InitializeKeyType(MD_KEY_TYPE,
                                                                 dwAttributes,
                                                                 dwUserType,
                                                                 dwDataType,
                                                                 (PBYTE)wszKeyType,
                                                                 cbData);
            }

            //
            // Save all the properties at this node
            //

            for ( dwEnumObjectIndex = 0, dataAssociatedData = pboRoot->EnumDataObject( dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA );
                  SUCCEEDED( hresReturn ) && ( dataAssociatedData != NULL );
                  dataAssociatedData = pboRoot->EnumDataObject( dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA ) )
            {
                hresReturn = SaveDataObject( dataAssociatedData,
                                             pCLocationWriter,
                                             pCryptoStorage,
                                             pSessionKeyBlob );
                if ( bLocalMachine )
                {
                    SaveGlobalsFromLM( dataAssociatedData );
                }
            }

            if ( bLocalMachine )
            {
                if ( g_dwEnableEditWhileRunning && !g_dwEnableHistory )
                {
                    DBGINFOW(( DBG_CONTEXT,
                               L"[SaveTree] Warning! Edit while running is enabled, while Enable history is disabled. Forcibly enabling history.\n" ));
                    g_dwEnableHistory = TRUE;
                }
            }

            //
            // Write out the node
            //

            if(SUCCEEDED(hresReturn))
            {
                hresReturn = pCLocationWriter->WriteLocation(TRUE);
            }

            //
            // If recurse, the enumerate and write all the sub-nodes, in a sorted manner.
            //

            if((SUCCEEDED(hresReturn)) && (bRecurse)) {

                //
                // First pass, count the number of child objects
                //

                ULONG cChildObjects = 0;
                ULONG iChildObjects = 0;

                for(objChildObjectContainer=pboRoot->NextChildObject(NULL);
                    (SUCCEEDED(hresReturn)) && (objChildObjectContainer!=NULL);
                    objChildObjectContainer=pboRoot->NextChildObject(objChildObjectContainer)) {
                        cChildObjects++;
                }

                //
                // Allocate memory if greater than whats allocated on the stack.
                //

                if(SUCCEEDED(hresReturn) && (cChildObjects > MD_MAX_CHILD_OBJECTS))
                {
                    arrChildObject = new PBASEOBJECT_CONTAINER[cChildObjects];
                    if(NULL == arrChildObject)
                    {
                        hresReturn = E_OUTOFMEMORY;
                    }
                }

                //
                // Make another pass and populate the array
                //

                for(objChildObjectContainer=pboRoot->NextChildObject(NULL),iChildObjects=0;
                    (SUCCEEDED(hresReturn)) && (objChildObjectContainer!=NULL);
                    objChildObjectContainer=pboRoot->NextChildObject(objChildObjectContainer),iChildObjects++) {
                    arrChildObject[iChildObjects] = objChildObjectContainer;
                }

                //
                // Sort the array
                //

                if(SUCCEEDED(hresReturn))
                {
                    qsort((void*)arrChildObject, cChildObjects, sizeof(PBASEOBJECT_CONTAINER), MyComparePBaseObjectContainer);
                }

                //
                // Enumerate the sorted array of child objects and call SaveTree on each of them
                //

                for(iChildObjects=0;
                    (SUCCEEDED(hresReturn)) && (iChildObjects<cChildObjects);
                    iChildObjects++) {

                    if(bSaveSchema ||
                       !(pboRoot == g_pboMasterRoot &&
                         _wcsicmp((LPWSTR)((arrChildObject[iChildObjects])->pboMetaObject->GetName(TRUE)), g_wszSchema) == 0
                        )
                      )
                    {
                        hresReturn = SaveTree(pCWriter,
                                              (arrChildObject[iChildObjects])->pboMetaObject,
                                              pbufParentPath,
                                              pCryptoStorage,
                                              pSessionKeyBlob,
                                              bRecurse,
                                              true);
                    }

                }

            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)L'\0';
        }
    }

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    if((NULL != arrChildObject) && (arrChildObject != arrFixedChildObjects) )
    {
        delete [] arrChildObject;
        arrChildObject = NULL;
    }
    return(hresReturn);
}


HRESULT
SaveDataObject(CMDBaseData*        pbdSave,
               CLocationWriter*    pCLocationWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    )
/*++

Routine Description:

    Save a data object.

Arguments:

    Save       - The data object to save.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {

        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {

                PIIS_CRYPTO_BLOB blob = NULL;
                PBYTE            pbData = NULL;
                DWORD            cbData = 0;

                pbData = (PBYTE)pbdSave->GetData(TRUE);
                cbData = pbdSave->GetDataLen(TRUE);

                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) {

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData(&blob,
                                                          pbData,
                                                          cbData,
                                                          0);
                    if (SUCCEEDED(hresReturn)) {
                        pbData = (PBYTE)blob;
                        cbData = IISCryptoGetBlobLength(blob);
                    }
                    else
                    {
                        DBGINFOW((DBG_CONTEXT,
                                  L"[SaveDataObject] Unable to encrypt data. Failed with hr = 0x%x. Property id: %d Location %s.\n",
                                  hresReturn,
                                  pbdSave->GetIdentifier(),
                                  pCLocationWriter->m_wszLocation));
                    }

                }

                if (SUCCEEDED(hresReturn)) {
                    hresReturn = pCLocationWriter->AddProperty(pbdSave->GetIdentifier(),
                                                               pbdSave->GetAttributes(),
                                                               pbdSave->GetUserType(),
                                                               pbdSave->GetDataType(),
                                                               (PBYTE)pbData,
                                                               cbData);

                    if(NULL != blob) {
                        ::IISCryptoFreeBlob(blob);
                    }
                }

            }
        }
    }
    return (hresReturn);
}


BOOL
DiscontinuousLocation(LPWSTR wszPreviousLocation,
                      LPWSTR wszCurrentLocation)
{
    LPWSTR wszEndCurrent      = NULL;
    BOOL   bNeedRestore       = FALSE;
    ULONG  cchCurrentLocation = 0;
    BOOL   bReturn;
    ULONG  cchCompare         = 0;

    if(NULL == wszPreviousLocation || 0 == *wszPreviousLocation ||
       NULL == wszCurrentLocation  || 0 == *wszCurrentLocation)
    {
        bReturn = TRUE;
    }
    else
    {
        cchCurrentLocation = (ULONG)wcslen(wszCurrentLocation);

        if((wszCurrentLocation[cchCurrentLocation-1] == L'/') &&
           (1 != cchCurrentLocation)
          )
        {
            //
            // If the location ends in a "/" and is not the root location,
            // then null it out for the purpose of comparison.
            //

            wszCurrentLocation[cchCurrentLocation-1] = 0;
            bNeedRestore = TRUE;
        }

        wszEndCurrent = wcsrchr(wszCurrentLocation, L'/');

        if(wszEndCurrent == wszCurrentLocation)
        {
            //
            // This is the root location
            //
            cchCompare = 1;
        }
        else
        {
            cchCompare = (ULONG)(wszEndCurrent-wszCurrentLocation);
        }

        if(0 == _wcsnicmp(wszPreviousLocation, wszCurrentLocation, cchCompare))
        {
            bReturn = FALSE;
        }
        else
        {
            bReturn = TRUE;
        }

        if(bNeedRestore)
        {
            wszCurrentLocation[cchCurrentLocation-1] = L'/';
        }

    }

    return bReturn;
}


HRESULT
InitSessionKey(ISimpleTableRead2*   pISTProperty,
               IIS_CRYPTO_STORAGE** ppStorage,
               LPSTR                pszPasswd)
{
    HRESULT hresReturn = 0;
    BOOL    fSecuredRead = TRUE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn, dwValue,dwType,dwSize = sizeof(DWORD);

    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SETUP_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        MD_UNSECUREDREAD_VALUE,
                        NULL,
                        &dwType,
                        (BYTE *)&dwValue,
                        &dwSize);
        if ( dwRegReturn == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwValue == 1)
        {
            hresReturn = NO_ERROR;
            *ppStorage = NULL;
            fSecuredRead = FALSE;

            DBGPRINTF(( DBG_CONTEXT,
                        "Temporary disabling  decryption for metabase read\n"));


            // special indicator for IIS setup that we passed this point
            dwValue = 2;
            dwRegReturn = RegSetValueEx(hkRegistryKey,
                            MD_UNSECUREDREAD_VALUE,
                            0,
                            REG_DWORD,
                            (PBYTE)&dwValue,
                            sizeof(dwValue));
            if (dwRegReturn == ERROR_SUCCESS)
            {
                DBGPRINTF(( DBG_CONTEXT,"Reanabling decryption after W9z upgrade\n"));
            }

        }
        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
    }

    if (fSecuredRead)
    {
        ULONG   cbSessionKey = 0;
        BYTE*   pbSessionKey = NULL;

        hresReturn = GetGlobalValue(pISTProperty,
                                    MD_SESSION_KEYW,
                                    &cbSessionKey,
                                    (LPVOID*)&pbSessionKey);

        if(FAILED(hresReturn))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[InitSessionKey] Error: Session key could not be fetched. GetGlobalValue failed with hr = 0x%x.\n",
                      hresReturn));
            return MD_ERROR_NO_SESSION_KEY;
        }

        if (IISCryptoIsClearTextSignature((IIS_CRYPTO_BLOB UNALIGNED *) pbSessionKey))
        {
                // call special function focibly tell that this machine has no
                // encryption enabled even if it happens to be so
                // that's a special handling for French case with US locale
                IISCryptoInitializeOverride (FALSE);
        }

        if( !pszPasswd )
        {
            hresReturn = InitStorageHelper(pbSessionKey,
                                           cbSessionKey, // dwLineLen-1
                                           ppStorage);
        }
        else
        {
            hresReturn = InitStorageHelper2(pszPasswd,
                                            pbSessionKey,
                                            cbSessionKey, // dwLineLen-1
                                            ppStorage);
        }

        if(FAILED(hresReturn))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[InitSessionKey] InitStorageHelper? failed with hr = 0x%x.\n",hresReturn));
        }

    }

    return hresReturn;

}


HRESULT
GetUnicodeNameW(IN  LPWSTR  wszFileName,
                OUT LPWSTR* pwszFileName)
{
    *pwszFileName = new WCHAR[wcslen(wszFileName)+1];
    if(NULL == *pwszFileName)
        return E_OUTOFMEMORY;

    wcscpy(*pwszFileName, wszFileName);

    return S_OK;

}

HRESULT
GetUnicodeNameA(IN  LPSTR   szFileName,
                OUT LPWSTR* pwszFileName)
{

    ULONG cchOut = 0;

    cchOut = MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                 0,
                                 szFileName,
                                 (int)((strlen(szFileName) + 1)*sizeof(char)),
                                 NULL,
                                 0);

    if(!cchOut)
        return HRESULT_FROM_WIN32(GetLastError());

    *pwszFileName = new WCHAR[cchOut+1];
    if(NULL == *pwszFileName)
        return E_OUTOFMEMORY;

    cchOut = MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                 0,
                                 szFileName,
                                 (int)((strlen(szFileName) + 1)*sizeof(char)),
                                 *pwszFileName,
                                 cchOut);

    if(!cchOut)
    {
        delete *pwszFileName;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;

}


HRESULT
InitEditWhileRunning(ISimpleTableRead2*   pISTProperty)
{
    HRESULT hresReturn       = S_OK;

    DWORD   dwDisable        = 0;
    DWORD*  pdwEnable        = &dwDisable;
    ULONG*  pulVersionMajor  = NULL;
    ULONG*  pulMaxErrorFiles = NULL;

    hresReturn = GetComputerValue(pISTProperty,
                                  MD_ENABLE_EDIT_WHILE_RUNNINGW,
                                  NULL,
                                  (LPVOID*)&pdwEnable);

    if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEditWhileRunning] Could not determine if edit while running was enabled. Defaulting to %d. GetComputerValue failed with hr = 0x%x.\n",
                  g_dwEnableEditWhileRunning, hresReturn));

    }
    else
    {
        g_dwEnableEditWhileRunning = *pdwEnable;
    }


    //
    // Init Edit while running version number irrespective of whether edit
    // while running is enabled, because they are used to create history files.
    //

    hresReturn = GetGlobalValue(pISTProperty,
                                MD_EDIT_WHILE_RUNNING_MAJOR_VERSION_NUMBERW,
                                NULL,
                                (LPVOID*)&pulVersionMajor);

    if(E_ST_NOMOREROWS == hresReturn)
    {
        //
        // Currently, if we are unable to fetch the major version number, we
        // initialize it to 0. The next time metabase.xml gets saved (in
        // SaveAllData, we will search through history dir and compute the
        // next available version number and assign it to
        // g_ulHistoryMajorVersionNumber.
        //

        DBGINFOW((DBG_CONTEXT,
                  L"[InitEditWhileRunning] Could not fetch history major version number. Defaulting to 0x%x. GetGlobalValue failed with hr = 0x%x.\n",
                  g_ulHistoryMajorVersionNumber, hresReturn));

        hresReturn = S_OK;
    }
    else if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEditWhileRunning] Could not fetch history major version number. Defaulting to 0x%x. GetGlobalValue failed with hr = 0x%x.\n",
                  g_ulHistoryMajorVersionNumber, hresReturn));

        hresReturn = S_OK;
    }
    else
    {
        g_ulHistoryMajorVersionNumber = (*(ULONG*)pulVersionMajor);

        DBGINFOW((DBG_CONTEXT,
                   L"[InitEditWhileRunning] Read history major version number as 0x%x.\n",
                   g_ulHistoryMajorVersionNumber));
    }

    //
    // Get the MaxErrorFiles property.
    //

    hresReturn = GetComputerValue(pISTProperty,
                                  MD_MAX_ERROR_FILESW,
                                  NULL,
                                  (LPVOID*)&pulMaxErrorFiles);

    if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEditWhileRunning] Could not determine if edit while running was enabled. Defaulting to %d. GetComputerValue failed with hr = 0x%x.\n",
                  g_dwEnableEditWhileRunning, hresReturn));

    }
    else
    {
        g_dwMaxErrorFiles = *pulMaxErrorFiles;
    }

    return hresReturn;
}


HRESULT InitEnableHistory(ISimpleTableRead2*   pISTProperty,
                          LPWSTR               wszDataFileName,
                          LPWSTR               wszSchemaFileName,
                          BOOL                 bCalledFromRestore)
{

    HRESULT hresReturn        = S_OK;
    DWORD   dwEnableHistory   = FALSE;
    DWORD*  pdwEnableHistory  = &dwEnableHistory;
    DWORD   dwMaxHistoryFiles  = 0;
    DWORD*  pdwMaxHistoryFiles = &dwMaxHistoryFiles;

    hresReturn = GetComputerValue(pISTProperty,
                                  MD_ENABLE_HISTORYW,
                                  NULL,
                                  (LPVOID*)&pdwEnableHistory);

    if(E_ST_NOMOREROWS == hresReturn)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch enable history. Defaulting to %d. GetComputerValue failed with hr = 0x%x.\n",
                    g_dwEnableHistory, hresReturn));

        hresReturn = S_OK;
    }
    else if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch enable history. GetGlobalValue failed with hr = 0x%x.\n",
                  hresReturn));

        return hresReturn;
    }
    else
    {
        g_dwEnableHistory = *pdwEnableHistory;
    }

    if((g_dwEnableEditWhileRunning) && (0 == g_dwEnableHistory))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Warning! Edit while running is enabled, while Enable history is disabled. Forcibly enabling history.\n"));

        g_dwEnableHistory = 1;
    }

    hresReturn = GetComputerValue(pISTProperty,
                                  MD_MAX_HISTORY_FILESW,
                                  NULL,
                                  (LPVOID*)&pdwMaxHistoryFiles);

    if(E_ST_NOMOREROWS == hresReturn)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch max history files. Defaulting to %d. GetComputerValue failed with hr = 0x%x.\n",
                  g_dwMaxHistoryFiles, hresReturn));

        hresReturn = S_OK;
    }
    else if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch max history files. GetComputerValue with hr = 0x%x.\n",
                  hresReturn));

        return hresReturn;
    }
    else
    {
        g_dwMaxHistoryFiles = *pdwMaxHistoryFiles;
    }

    ValidateMaxHistoryFiles();

    if(g_dwEnableHistory && !bCalledFromRestore)
    {
        hresReturn = CreateHistoryFiles(wszDataFileName,
                                        wszSchemaFileName,
                                        g_ulHistoryMajorVersionNumber,
                                        g_dwMaxHistoryFiles);
    }

    return hresReturn;
}


void
ValidateMaxHistoryFiles()
{

    if((0 == g_dwMaxHistoryFiles) && (g_dwEnableEditWhileRunning))
    {
        g_dwMaxHistoryFiles = MD_COUNT_MAX_HISTORY_FILES;

        DBGINFOW((DBG_CONTEXT,
                  L"[ValidateMaxHistoryFiles] Warning! Edit while running is enable, while max history files is zero. Defaulting to %d.\n",
                  g_dwMaxHistoryFiles, HRESULT_FROM_WIN32(ERROR_INVALID_DATA)));

        LogEvent(g_pEventLog,
                 MD_ERROR_DAFAULTING_MAX_HISTORY_FILES,
                 EVENTLOG_ERROR_TYPE,
                 ID_CAT_CAT,
                 S_OK);


    }
    else if((0 == g_dwMaxHistoryFiles) && (g_dwEnableHistory))
    {
        g_dwMaxHistoryFiles = MD_COUNT_MAX_HISTORY_FILES;

        DBGINFOW((DBG_CONTEXT,
                  L"[ValidateMaxHistoryFiles] Warning! History is enabled, while max history files is zero. Defaulting to %d.\n",
                  g_dwMaxHistoryFiles, HRESULT_FROM_WIN32(ERROR_INVALID_DATA)));

        LogEvent(g_pEventLog,
                 MD_ERROR_DAFAULTING_MAX_HISTORY_FILES,
                 EVENTLOG_ERROR_TYPE,
                 ID_CAT_CAT,
                 (DWORD)HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }

    return;
}


HRESULT
InitChangeNumber(ISimpleTableRead2*   pISTProperty)
{
    HRESULT hresReturn        = S_OK;
    DWORD*  pdwChangeNumber    = NULL;

    hresReturn = GetGlobalValue(pISTProperty,
                                MD_CHANGE_NUMBERW,
                                NULL,
                                (LPVOID*)&pdwChangeNumber);

    if(FAILED(hresReturn))
    {
        //
        // If unable to read change number, initialize to 0.
        //
        g_dwSystemChangeNumber = 0;

        DBGINFOW((DBG_CONTEXT,
                  L"[InitChangeNumber] Could not fetch change number. Defaulting to %d. GetGlobalValue failed with hr = 0x%x.\n",
                    g_dwSystemChangeNumber, hresReturn));

    }
    else
    {
        g_dwSystemChangeNumber = *pdwChangeNumber;
    }

    return S_OK;
}


HRESULT
CreateHistoryFiles(LPWSTR   i_wszDataFileName,
                   LPWSTR   i_wszSchemaFileName,
                   ULONG    i_ulHistoryMajorVersionNumber,
                   DWORD    i_dwMaxHistoryFiles)

{
    HRESULT              hr                         = S_OK;

    //
    // Create the history directory, if it is not present.
    //

    if(-1 == GetFileAttributesW(g_wszHistoryFileDir))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        if((hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))||
           (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
          )
        {
            SECURITY_ATTRIBUTES  saStorage;
            PSECURITY_ATTRIBUTES psaStorage  = NULL;

            //
            // Initialize the security attributes & create the file
            //

            if (g_psdStorage != NULL) {
                saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
                saStorage.lpSecurityDescriptor = g_psdStorage;
                saStorage.bInheritHandle = FALSE;
                psaStorage = &saStorage;
            }

            if(!CreateDirectoryW(g_wszHistoryFileDir, psaStorage))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                DBGINFOW((DBG_CONTEXT,
                          L"[CreateHistoryFile] Unable to create history directory. CreateDirectoryW failed with hr = 0x%x. \n",
                          hr));

                return hr;
            }
            else
            {
                hr = S_OK;
            }
        }
        else
        {
            return hr;
        }
    }

    //
    // Create the data file before the schema file. Under stress data files
    // can grow and if the creation of data files fail, then you do not want
    // to create the schema file.
    //

    //
    // Create the data history file first
    //

    hr = CreateHistoryFile(i_wszDataFileName,
                           g_wszHistoryFileDir,
                           g_cchHistoryFileDir,
                           g_wszRealFileNameWithoutPathWithoutExtension,
                           g_cchRealFileNameWithoutPathWithoutExtension,
                           g_wszRealFileNameExtension,
                           g_cchRealFileNameExtension,
                           i_ulHistoryMajorVersionNumber);

    if(SUCCEEDED(hr))
    {
        //
        // Create the schema history file next
        //

        hr = CreateHistoryFile(i_wszSchemaFileName,
                               g_wszHistoryFileDir,
                               g_cchHistoryFileDir,
                               g_wszSchemaFileNameWithoutPathWithoutExtension,
                               g_cchSchemaFileNameWithoutPathWithoutExtension,
                               g_wszSchemaFileNameExtension,
                               g_cchSchemaFileNameExtension,
                               i_ulHistoryMajorVersionNumber);
    }


    //
    // Cleanup the obsolete history files.
    //

    hr = CleanupObsoleteHistoryFiles(i_dwMaxHistoryFiles,
                                     i_ulHistoryMajorVersionNumber);

    return hr;
}


HRESULT
CreateHistoryFile(LPWSTR               i_wszFileName,
                  LPWSTR               i_wszHistroyFileDir,
                  ULONG                i_cchHistoryFileDir,
                  LPWSTR               i_wszFileNameWithoutPathWithoutExtension,
                  ULONG                i_cchFileNameWithoutPathWithoutExtension,
                  LPWSTR               i_wszFileNameExtension,
                  ULONG                i_cchFileNameExtension,
                  DWORD                i_ulHistoryMajorVersionNumber)
{
    WCHAR*              wszHistoryFileName      = NULL;
    HRESULT             hr                      = S_OK;
    DWORD               dwMinorVersion          = 0;

    //
    // Construct the history data file name
    //

    hr = ConstructHistoryFileName(&wszHistoryFileName,
                                  i_wszHistroyFileDir,
                                  i_cchHistoryFileDir,
                                  i_wszFileNameWithoutPathWithoutExtension,
                                  i_cchFileNameWithoutPathWithoutExtension,
                                  i_wszFileNameExtension,
                                  i_cchFileNameExtension,
                                  i_ulHistoryMajorVersionNumber,
                                  dwMinorVersion);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CreateHistoryFile] Unable to construct history file name. ConstructHistoryFileName failed with hr = 0x%x\n.",
                  hr));
        goto exit;
    }

    //
    // Create the history file.
    //

    DBGINFOW((DBG_CONTEXT,
                  L"[CreateHistoryFile] Copying history file from %s to %s.\n",
                  i_wszFileName,
                  wszHistoryFileName));

    //
    // Compare the names of the source and dest. Do not copy if they are the same.
    // This can happen when restoring from history directory, and ReadAllData=>
    // InitEnableHistory=>CreateHistoryFiles is called.
    //

    if(0 == _wcsicmp(i_wszFileName, wszHistoryFileName))
    {
        goto exit;
    }

    if(!CopyFileW(i_wszFileName,
                      wszHistoryFileName,
                      FALSE)                  // Overwrite if it exists.
          )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[CreateHistoryFile] Unable to create history file. CopyFileW from %s to %s failed with hr = 0x%x\n.",
                  i_wszFileName,
                  wszHistoryFileName,
                  hr));

        goto exit;

    }
    else
    {
        SetSecurityOnFile(i_wszFileName,
                          wszHistoryFileName);
    }

exit:

    if(NULL != wszHistoryFileName)
    {
        delete [] wszHistoryFileName;
        wszHistoryFileName = NULL;
    }

    return hr;
}

int _cdecl MyCompareFileData(const void *a,
                             const void *b)
{
    return CompareFileTime(&(((METABASE_FILE_DATA*)a)->ftLastWriteTime), &(((METABASE_FILE_DATA*)b)->ftLastWriteTime));
}


HRESULT ConstructHistoryFileName(LPWSTR*  o_wszHistoryFile,
                                 LPWSTR   i_wszHistroyFileDir,
                                 ULONG    i_cchHistoryFileDir,
                                 LPWSTR   i_wszFileNameWithoutPathWithoutExtension,
                                 ULONG    i_cchFileNameWithoutPathWithoutExtension,
                                 LPWSTR   i_wszFileNameExtension,
                                 ULONG    i_cchFileNameExtension,
                                 ULONG    i_ulMajorVersion,
                                 ULONG    i_ulMinorVersion)
{
    ULONG   cch            = 0;
    LPWSTR  pEnd           = NULL;
    int     res            = 0;
    HRESULT hr             = S_OK;
    WCHAR   wszVersion[MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW+1];

    *o_wszHistoryFile = NULL;

    res = _snwprintf(wszVersion,
                     MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW+1,
                     L"_%010lu_%010lu",
                     i_ulMajorVersion,
                     i_ulMinorVersion);
    if(res < 0)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ConstructHistoryFileName] _snwprintf returned a negative value. This should never happen.\n"));
        MD_ASSERT(0);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;

    }

    cch = i_cchHistoryFileDir +
          1 + // For backslash if it doesn't end in one
          i_cchFileNameWithoutPathWithoutExtension +
          MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW +
          i_cchFileNameExtension;

    *o_wszHistoryFile= new WCHAR[cch+1];
    if(NULL == *o_wszHistoryFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pEnd = *o_wszHistoryFile;
    memcpy(pEnd, i_wszHistroyFileDir, i_cchHistoryFileDir*sizeof(WCHAR));
    pEnd = pEnd + i_cchHistoryFileDir;
    if(i_wszHistroyFileDir[i_cchHistoryFileDir-1] != L'\\')
    {
        *pEnd = L'\\';
        pEnd++;
    }
    memcpy(pEnd, i_wszFileNameWithoutPathWithoutExtension, i_cchFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
    pEnd = pEnd + i_cchFileNameWithoutPathWithoutExtension;
    memcpy(pEnd, wszVersion, MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));
    pEnd = pEnd + MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW;
    if(0 != i_cchFileNameExtension)
    {
        memcpy(pEnd, i_wszFileNameExtension, i_cchFileNameExtension*sizeof(WCHAR));
        pEnd = pEnd + i_cchFileNameExtension;
    }
    *(pEnd) = L'\0';

exit:
    return hr;

}

HRESULT ConstructHistoryFileNameWithoutMinorVersion(LPWSTR*  o_wszHistoryFileNameWithoutMinorVersion,
                                                    ULONG*   o_iStartMinorVersion,
                                                    LPWSTR   i_wszHistroyFileSearchString,
                                                    ULONG    i_cchHistoryFileSearchString,
                                                    LPWSTR   ,
                                                    ULONG    i_cchFileNameExtension,
                                                    ULONG    i_ulMajorVersion)
/*
++

Routine Description:

    Constructs the history file search string, given the following:
    History file search string
      (This would look like:
           D:\Winnt\system32\inetsrv\History\Metabase_??????????_??????????.XML
           or if the path is long (greater that MAX_PATH):
           \\?\D:\Winnt\system32\inetsrv\History\Metabase_??????????_??????????.XML
      )
    Major history version number

    The resulting string would look something like:
    D:\Winnt\system32\inetsrv\History\Metabase_0000000001_??????????.XML
    or if the path is long (greater that MAX_PATH):
    \\?\D:\Winnt\system32\inetsrv\History\Metabase_0000000001_??????????.XML


Arguments:

    Return - The full path of the history file search string.
    Return - The start index of where the minor version would begin.

    History file search string
    History file search string count of characters
    History file extension, if any (Eg: ".XML")
    History file extension character count
    Major history version number

Return Value:

    HRESULT  - S_OK
               HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
               E_OUTOFMEMORY

Notes:

--*/
{
    LPWSTR      pEnd     = NULL;
    int         res      = 0;
    HRESULT     hr       = S_OK;
    WCHAR       wszVersionNumber[MD_CCH_MAX_ULONG+1];

    res = _snwprintf(wszVersionNumber,
                     MD_CCH_MAX_ULONG,
                     L"%010lu",
                     i_ulMajorVersion);
    wszVersionNumber[MD_CCH_MAX_ULONG]=L'\0';

    if(res < 0)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ConstructHistoryFileNameWithoutMinorVersion] _snwprintf returned a negative value. This should never happen.\n"));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;

    }

    *o_wszHistoryFileNameWithoutMinorVersion = new WCHAR[i_cchHistoryFileSearchString+1];
    if(NULL == *o_wszHistoryFileNameWithoutMinorVersion)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    pEnd = *o_wszHistoryFileNameWithoutMinorVersion;
    memcpy(pEnd, i_wszHistroyFileSearchString, i_cchHistoryFileSearchString*sizeof(WCHAR));
    pEnd = pEnd + i_cchHistoryFileSearchString;
    *pEnd = 0;

    pEnd = ((*o_wszHistoryFileNameWithoutMinorVersion) + i_cchHistoryFileSearchString) -
           i_cchFileNameExtension                -
           MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW  +
           MD_CCH_UNDERSCOREW;

    memcpy(pEnd, wszVersionNumber, MD_CCH_MAX_ULONG*sizeof(WCHAR));


    if(NULL != o_iStartMinorVersion)
    {
        *o_iStartMinorVersion = i_cchHistoryFileSearchString          -
                                i_cchFileNameExtension                -
                                MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW +
                                MD_CCH_UNDERSCOREW                    +
                                MD_CCH_MAX_ULONG                      +
                                MD_CCH_UNDERSCOREW;
    }

exit:

    return hr;

} // ConstructHistoryFileNameWithoutMinorVersion


HRESULT ReAllocateFileData(ULONG                i_iFileData,
                           METABASE_FILE_DATA** io_aFileData,
                           ULONG*               io_pcFileData,
                           BOOL*                io_pbReAlloced)
{
    METABASE_FILE_DATA* aTemp = NULL;
    HRESULT             hr    = S_OK;

    aTemp = new METABASE_FILE_DATA[*io_pcFileData + MD_MAX_HISTORY_FILES_ALLOC_SIZE];
    if(NULL == aTemp)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }
    *io_pcFileData = *io_pcFileData + MD_MAX_HISTORY_FILES_ALLOC_SIZE;

    memset(aTemp, 0, (*io_pcFileData)*sizeof(METABASE_FILE_DATA));

    if((NULL != *io_aFileData))
    {
        memcpy(aTemp, *io_aFileData, i_iFileData*sizeof(METABASE_FILE_DATA));

        if(*io_pbReAlloced)
        {
            delete [] *io_aFileData;
            *io_aFileData = NULL;
        }
    }

    *io_pbReAlloced = TRUE;
        *io_aFileData = aTemp;

    return hr;
}

HRESULT CleanupObsoleteHistoryFiles(DWORD i_dwMaxHistoryFiles,
                                    ULONG i_ulHistoryMajorVersionNumber)
{
    HANDLE              hFind         = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FileData;
    FILETIME            ftLastWriteTime;
    HRESULT             hr            = S_OK;
    ULONG               iVersion      = 0;
    METABASE_FILE_DATA  aOldVersionsFixed[MD_MAX_HISTORY_FILES_ALLOC_SIZE];
    METABASE_FILE_DATA* aOldVersions  = (METABASE_FILE_DATA*)&(aOldVersionsFixed[0]);
    BOOL                bReAlloced    = FALSE;
    ULONG               cVersions     = MD_MAX_HISTORY_FILES_ALLOC_SIZE;
    ULONG               ulVersionMajor;
    ULONG               ulVersionMinor;

    //
    // We also cleanup the stale (non-zero) backedup minor versions, that
    // correspond to the major version we just created.This can happen if
    // someone is restoring to an old version, & restarting IIS.
    //
    // Delete old history files based on timestamp rather than version number.
    // Because if you start by restoring an old version, you dont
    // want to delete it. Save as soon as you load the old version so
    // that it is re-backed up.
    //
    // We search for all the data history files only, then we sort them
    // in ascending order, then we delete the old ones along with their
    // schema files.
    //

    //
    // Search for all the data history files.
    //

    hFind = FindFirstFileW(g_wszHistoryFileSearchString, &FileData);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[CleanupObsoleteHistoryFiles] Unable find any old history files. FindFirstFileW on %s failed with hr = 0x%x.\n",
                   g_wszHistoryFileSearchString, hr));

        goto exit;
    }

    do
    {
        //
        // Extract the version number from the file name.
        //

        hr = ParseVersionNumber(FileData.cFileName,
                                g_cchRealFileNameWithoutPathWithoutExtension,
                                &ulVersionMinor,
                                &ulVersionMajor);

        if(FAILED(hr))
        {
            //
            // Assume invalid file and continue
            //

            DBGINFOW((DBG_CONTEXT,
                      L"[CleanupObsoleteHistoryFiles] Unable to parse version number from file name %s. This file will not be cleaned up.\n",
                       FileData.cFileName));
            hr = S_OK;
            continue;
        }

        //
        // Save the last write timestamp.
        //

        ftLastWriteTime = FileData.ftLastWriteTime;

        //
        // Save the version number.
        //

        if(iVersion >= cVersions)
        {
            hr = ReAllocateFileData(iVersion,
                                    &aOldVersions,
                                    &cVersions,
                                    &bReAlloced);

            if(FAILED(hr))
            {
                goto exit;
            }
        }

        aOldVersions[iVersion].ulVersionMinor   = ulVersionMinor;
        aOldVersions[iVersion].ulVersionMajor   = ulVersionMajor;
        aOldVersions[iVersion].ftLastWriteTime  = ftLastWriteTime;

        iVersion++;

    }while (FindNextFileW(hFind, &FileData));

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    //
    // Check to see if there are any history files with the same major version and a
    // non-zero minor version, if so delete the non-zero minor versions. This
    // can happen when someone restores from an old history file. Make sure
    // this cleanup happens first so that we are in a state where timestamps
    // of all non-zero minor versions are greater that the zero minor versions.
    //

    for (ULONG i=0; i< iVersion; i++ )
    {
        if((aOldVersions[i].ulVersionMajor == i_ulHistoryMajorVersionNumber) &&
           (aOldVersions[i].ulVersionMinor != 0)
          )
        {
            //
            // Delete data history file first. We create a data file with a
            // non-zero minor number when a text edit takes place and we
            // have successfully applied the text edit to memory.
            //

            hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                   g_cchHistoryFileDir,
                                   g_wszRealFileNameWithoutPathWithoutExtension,
                                   g_cchRealFileNameWithoutPathWithoutExtension,
                                   g_wszRealFileNameExtension,
                                   g_cchRealFileNameExtension,
                                   aOldVersions[i].ulVersionMajor,
                                   aOldVersions[i].ulVersionMinor);


            if(SUCCEEDED(hr))
            {
                //
                // Delete schema file next
                //
                hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                       g_cchHistoryFileDir,
                                       g_wszSchemaFileNameWithoutPathWithoutExtension,
                                       g_cchSchemaFileNameWithoutPathWithoutExtension,
                                       g_wszSchemaFileNameExtension,
                                       g_cchSchemaFileNameExtension,
                                       aOldVersions[i].ulVersionMajor,
                                       aOldVersions[i].ulVersionMinor);
            }
        }
    }

    if ( iVersion > i_dwMaxHistoryFiles )
    {
        ULONG cDeleted     = 0;
        ULONG cNeedDeleted = iVersion-i_dwMaxHistoryFiles;

        //
        // Exceeded max history files -
        // Delete old history files i.e. the first dwMaxHistoryFiles - cFile
        //

        qsort((void*)aOldVersions, iVersion, sizeof(METABASE_FILE_DATA), MyCompareFileData);

        for (ULONG i=0; cDeleted<cNeedDeleted && i<iVersion ; i++ )
        {
            if(aOldVersions[i].ulVersionMajor == i_ulHistoryMajorVersionNumber)
            {
                //
                // Do not cleanup the file you just created.
                //

                continue;
            }
            else
            {
                //
                // Delete data history file first
                //

                hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                       g_cchHistoryFileDir,
                                       g_wszRealFileNameWithoutPathWithoutExtension,
                                       g_cchRealFileNameWithoutPathWithoutExtension,
                                       g_wszRealFileNameExtension,
                                       g_cchRealFileNameExtension,
                                       aOldVersions[i].ulVersionMajor,
                                       aOldVersions[i].ulVersionMinor);

                if(SUCCEEDED(hr))
                {
                    //
                    // Delete schema file next
                    //

                    cDeleted++;

                    hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                           g_cchHistoryFileDir,
                                           g_wszSchemaFileNameWithoutPathWithoutExtension,
                                           g_cchSchemaFileNameWithoutPathWithoutExtension,
                                           g_wszSchemaFileNameExtension,
                                           g_cchSchemaFileNameExtension,
                                           aOldVersions[i].ulVersionMajor,
                                           aOldVersions[i].ulVersionMinor);
                }
            }
        } // End loop for all history files, delete the oldest (see rules in comment)
    } // End if the number of histor files exceeds the max history file count.


exit:

    if((aOldVersionsFixed != aOldVersions) && (NULL != aOldVersions))
    {
        delete [] aOldVersions;
        aOldVersions = NULL;
        cVersions = 0;
    }

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    return hr;

} // CleanupObsoleteHistoryFiles


HRESULT ParseVersionNumber(LPWSTR  i_wszFileName,
                           ULONG   i_cchFileNameUntilFirstUnderscore,
                           ULONG*  o_ulVersionMinor,
                           ULONG*  o_ulVersionMajor)
/*
++

Routine Description:

    Parses the major and minor history version numbers from the file name.
    The file name can be the full path to the hisory file or the file name
    only.
    Eg:
    D:\Winnt\system32\inetsrv\History\Metabase_0000000001_0000000001.XML
    Metabase_0000000001_0000000001.XML

Arguments:

    History file name (full path to file name or just file name). The file
    name cannot contain wild chars ?????????? for version numbers.

    Count of chars in the history file name upto the fist underscore.

    Return - Major history version number
    Return - Minor history version number

Return Value:

    HRESULT  - S_OK
               HRESULT_FROM_WIN32(ERROR_INVALID_NAME)

Notes:

--*/
{
    HRESULT hr               = S_OK;
    ULONG   ulVersionMinor   = 0;
    ULONG   ulVersionMajor   = 0;

    //
    // Look for the first underscore
    //

    if(i_wszFileName[i_cchFileNameUntilFirstUnderscore]  != MD_CH_UNDERSCOREW)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        goto exit;
    }

    LPWSTR pCur = &(i_wszFileName[i_cchFileNameUntilFirstUnderscore]);

    for(ULONG i = 0; i < 2; i++)
    {
        pCur = wcschr(pCur, L'_');
        if(pCur == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
            goto exit;
        }
        pCur++;
        if( !WstrToUl(
                pCur,
                (i == 0) ? L'_'            : L'.',
                (i == 0) ? &ulVersionMajor : &ulVersionMinor) )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
            goto exit;
        }
    }

    if(NULL !=  o_ulVersionMinor)
    {
        *o_ulVersionMinor = ulVersionMinor;
    }

    if(NULL !=  o_ulVersionMajor)
    {
        *o_ulVersionMajor = ulVersionMajor;
    }

exit:

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ParseVersionNumber] Invalid file name %s.\n",
                  i_wszFileName));
    }

    return hr;

}

HRESULT
ParseVersionNumber(IN     LPWSTR i_wszFileName,
                   IN OUT DWORD* io_pdwMinor,
                   IN OUT DWORD* io_pdwMajor)
/*++

Synopsis:
    Overloaded version of ParseVersionNumber that will figure out
    i_cchFileNameUntilFirstUnderscore,

Arguments: [i_wszFileName] - filename formatted as blah_major_minor.xml
           [io_pdwMinor] -
           [io_pdwMajor] -

Return Value:

--*/
{
    MD_ASSERT(i_wszFileName);
    MD_ASSERT(io_pdwMinor);
    MD_ASSERT(io_pdwMajor);

    ULONG  iNrUnderscoresSeen = 0;
    LPWSTR pEnd               = i_wszFileName + wcslen(i_wszFileName);

    for(; pEnd >= i_wszFileName; pEnd--)
    {
        if(*pEnd == L'_')
        {
            iNrUnderscoresSeen++;
        }
        if(iNrUnderscoresSeen == 2)
        {
            break;
        }
    }

    if(iNrUnderscoresSeen != 2)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }

    return ParseVersionNumber(
        i_wszFileName,
        (ULONG)(pEnd - i_wszFileName),
        io_pdwMinor,
        io_pdwMajor);
}


HRESULT DeleteHistoryFile(LPWSTR  i_wszHistroyFileDir,
                          ULONG   i_cchHistoryFileDir,
                          LPWSTR  i_wszFileNameWithoutPathWithoutExtension,
                          ULONG   i_cchFileNameWithoutPathWithoutExtension,
                          LPWSTR  i_wszFileNameExtension,
                          ULONG   i_cchFileNameExtension,
                          ULONG   i_ulVersionMajor,
                          ULONG   i_ulVersionMinor)
{
    LPWSTR  wszDeleteFileName = NULL;
    HRESULT hr               = S_OK;

    hr = ConstructHistoryFileName(&wszDeleteFileName,
                                  i_wszHistroyFileDir,
                                  i_cchHistoryFileDir,
                                  i_wszFileNameWithoutPathWithoutExtension,
                                  i_cchFileNameWithoutPathWithoutExtension,
                                  i_wszFileNameExtension,
                                  i_cchFileNameExtension,
                                  i_ulVersionMajor,
                                  i_ulVersionMinor);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[DeleteHistoryFile] Unable to cleanup history files. ConstructHistoryFileName failed with hr = 0x%x.\n",
                  hr));
        return hr;
    }

    if(!DeleteFileW(wszDeleteFileName))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[DeleteHistoryFile] Unable to cleanup history file: %s. DeleteFileW failed with hr = 0x%x.\n",
                  wszDeleteFileName, hr));

    }

    delete [] wszDeleteFileName;
    wszDeleteFileName = NULL;

    return hr;
}


HRESULT
GetGlobalValue(ISimpleTableRead2*    pISTProperty,
               LPCWSTR               wszName,
               ULONG*                pcbSize,
               LPVOID*               ppVoid)
{

    LPWSTR  wszPath = L".";
    DWORD   dwGroup = eMBProperty_IIS_Global;

    return GetValue(pISTProperty,
                    wszPath,
                    dwGroup,
                    wszName,
                    pcbSize,
                    ppVoid);
}


HRESULT
GetComputerValue(ISimpleTableRead2*    pISTProperty,
                 LPCWSTR               wszName,
                 ULONG*                pcbSize,
                 LPVOID*               ppVoid)
{
    LPWSTR  wszPath = L"/LM";
    DWORD   dwGroup = eMBProperty_IIsComputer;

    return GetValue(pISTProperty,
                    wszPath,
                    dwGroup,
                    wszName,
                    pcbSize,
                    ppVoid);
}

HRESULT
GetValue(ISimpleTableRead2*    pISTProperty,
         LPCWSTR               wszPath,
         DWORD                 dwGroup,
         LPCWSTR               wszName,
         ULONG*                pcbSize,
         LPVOID*               ppVoid)
{

    HRESULT hr          = S_OK;
    ULONG   iRow        = 0;
    ULONG   iColumn     = iMBProperty_Value;
    LPVOID  aIdentity[] = {(LPVOID)(LPWSTR)wszName,
                           (LPVOID)(LPWSTR)wszPath,
                           &dwGroup};

    *ppVoid = NULL;

    hr = pISTProperty->GetRowIndexByIdentity(NULL,
                                             aIdentity,
                                             &iRow);

    if(E_ST_NOMOREROWS == hr)
    {
        //
        // Perhaps key type was not present and hence it may be custom
        //

        dwGroup = eMBProperty_Custom;

        hr = pISTProperty->GetRowIndexByIdentity(NULL,
                                                 aIdentity,
                                                 &iRow);
        if(E_ST_NOMOREROWS == hr)
        {
            dwGroup = eMBProperty_IIsConfigObject;

            hr = pISTProperty->GetRowIndexByIdentity(NULL,
                                                     aIdentity,
                                                     &iRow);

        }
    }

    if(FAILED(hr))
    {
        return hr;
    }

    hr = pISTProperty->GetColumnValues(iRow,
                                       1,
                                       &iColumn,
                                       pcbSize,
                                       (LPVOID*)ppVoid);

    return hr;

}

HRESULT
InitializeIIS6GlobalsToDefaults(ULONG dwPrevSchemaChangeNumber,
                                ULONG dwSchemaChangeNumber,
                                LPSTR pszBackupLocation)
{
    ISimpleTableDispenser2*     pISTDisp           = NULL;
    IMetabaseSchemaCompiler*    pCompiler          = NULL;
    HRESULT                     hr                 = S_OK;

    //
    // This is used to initialize the following global properties to their
    // defaults. Note that these are global properties that were introduced
    // in IIS60. Hence this function needs to be called from ReadAllDataFromBin
    // else these properties will not be initialized during an upgrade scenario
    // ie. from IIS50/51 to IIS60 when you read from a bin file, in the absence
    // of the XML file. It ned to be called from ReadAllDataFromXML as well so
    // that they can be initialized correctly.
    //

    g_dwEnableEditWhileRunning              = 0;
    g_ulHistoryMajorVersionNumber           = 0;
    g_dwEnableHistory                       = TRUE;
    g_dwMaxHistoryFiles                     = MD_COUNT_MAX_HISTORY_FILES;
    g_dwMaxErrorFiles                       = MD_COUNT_MAX_ERROR_FILES;
    g_dwSchemaChangeNumber                  = dwSchemaChangeNumber;
    g_dwLastSchemaChangeNumber              = dwPrevSchemaChangeNumber;

    if(NULL == pszBackupLocation)
    {
        //
        // Initialize the global array containing file handles. The
        // initialization is done here (one time only) because this if
        // condition will evaluate one time only during service startup.
        // Other times when this function is invoked is during restore
        // - you can tell when restore is calling by checking
        // pszBackupLocation which will be non null.
        //

        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] Initializing global file handle array.\n"));

        for(ULONG i=0; i<cMetabaseFileTypes; i++)
        {
            g_ahMetabaseFile[i] = INVALID_HANDLE_VALUE;
        }

    }

    //
    // No need to initilize dispenser (InitializeSimpleTableDispenser()),
    // because we now specify USE_CRT=1 in sources, which means that
    // globals will be initialized.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // Always set the Bin path to point to the metabase directory.
    // Even if ReadAllData* gets called with a different filename during restore,
    // SetBinPath should always be set to the metabase directory
    //

    hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
                                  (LPVOID*)&pCompiler);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    hr = pCompiler->SetBinPath(g_wszMetabaseDir);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] SetBinPath failed with hr = 0x%x.\n",hr));
        goto exit;
    }

exit:

    if(NULL != pCompiler)
    {
        pCompiler->Release();
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
    }

    return hr;

}

HRESULT
InitializeGlobalsFromXML(ISimpleTableRead2*     pISTProperty,
                         LPWSTR                 wszDataFileName,
                         LPWSTR                 wszSchemaFileName,
                         IIS_CRYPTO_STORAGE**   ppStorage,
                         LPTSTR                 pszPasswd,
                         BOOL                   bCalledFromRestore,
                         FILETIME               *pftLastWriteTimeDataFile)
{
    HRESULT                     hr           = S_OK;
    WIN32_FILE_ATTRIBUTE_DATA   MBFileAttr;

    //
    // Currently, we are setting the Master root last change time to the
    // timestamp on the metabase.xml file.
    // TODO: Should this information be persisted as an attribute in
    // the metabase.xml file, and should we read from it?
    //

    if(!GetFileAttributesExW(wszDataFileName,
                             GetFileExInfoStandard,
                             &MBFileAttr))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeGlobalsFromXML] GetFileAttributesExW failed with hr = 0x%x.\n",
                  hr));

        return hr;
    }
    else
    {
        if ( pftLastWriteTimeDataFile )
        {
            *pftLastWriteTimeDataFile = MBFileAttr.ftLastWriteTime;
        }

        //
        // TODO: Is it sufficient if we only set the root filetime?
        // IVANPASH: Fixing BUG 751131, it looks like setting only the root,
        // could be sufficient if ReadSchema was not explicitely setting the LastChangeTime on every node.
        // Now I return the ftLastWriteTime to the caller in pftLastWriteTimeDataFile.
        //
        g_pboMasterRoot->SetLastChangeTime( &MBFileAttr.ftLastWriteTime );
    }

    //
    // Initialize session key before you read stuff in.
    //

    hr = InitSessionKey(pISTProperty,
                        ppStorage,
                        pszPasswd);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Initialize enable edit while running before you read stuff in.
    //

    InitEditWhileRunning(pISTProperty);

    //
    // Initialize change number before you read stuff in.
    // TODO: Should we migrate the change number when we migrate from .bin to .xml?
    //

    InitChangeNumber(pISTProperty);

    //
    // Initialize enable history - Should be called after InitEditWhileRunning
    //

    InitEnableHistory(pISTProperty,
                      wszDataFileName,
                      wszSchemaFileName,
                      bCalledFromRestore);

    return hr; // Return failure code only if you want to exit.

}


HRESULT
SaveGlobalsToXML(CWriter*            pCWriter,
                 PIIS_CRYPTO_BLOB    pSessionKeyBlob,
                 bool                bSessionKeyOnly)
{

    HRESULT             hr                  = S_OK;
    CLocationWriter*    pCLocationWriter    = NULL;
    LPWSTR              wszGlobalLocation   = L".";
    LPWSTR              wszKeyType          = L"IIS_Global";
    DWORD               dwIdentifier;
    DWORD               dwDataType;
    DWORD               dwAttributes;
    DWORD                dwNumber;
    DWORD               dwUserType          = IIS_MD_UT_SERVER;

    hr = pCWriter->GetLocationWriter(&pCLocationWriter,
                                     wszGlobalLocation);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] GetLocationWriter failed with hr = 0x%x.\n",
                  hr));
        goto exit;
    }

    hr = pCLocationWriter->InitializeKeyType(MD_KEY_TYPE,
                                             METADATA_NO_ATTRIBUTES,
                                             IIS_MD_UT_SERVER,
                                             STRING_METADATA,
                                             (PBYTE)wszKeyType,
                                             (DWORD)((wcslen(wszKeyType)+1)*sizeof(WCHAR))
                                             );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] InitializeKeyType failed with hr = 0x%x.\n",
                  hr));
        goto exit;
    }

    if(!bSessionKeyOnly)
    {
        //
        // Change Number
        //

        dwIdentifier = MD_GLOBAL_CHANGE_NUMBER;
        dwDataType = DWORD_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&g_dwSystemChangeNumber,
                                           sizeof(DWORD));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }

        //
        // HistoryMajorVersionNumber
        //

        ComputeNewHistoryVersionNumber();


        dwIdentifier = MD_GLOBAL_EDIT_WHILE_RUNNING_MAJOR_VERSION_NUMBER;
        dwDataType   = DWORD_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;
        dwNumber     = g_ulHistoryMajorVersionNumber;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&dwNumber,
                                           sizeof(DWORD));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }
    }

    //
    // Add SessionKey
    //

    dwIdentifier = MD_GLOBAL_SESSIONKEY;
    dwDataType = BINARY_METADATA;
    dwAttributes = METADATA_NO_ATTRIBUTES;

    hr = pCLocationWriter->AddProperty(dwIdentifier,
                                       dwAttributes,
                                       dwUserType,
                                       dwDataType,
                                       (PBYTE)pSessionKeyBlob,
                                       IISCryptoGetBlobLength(pSessionKeyBlob));

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                  dwIdentifier, hr));
        goto exit;
    }

    if(!bSessionKeyOnly)
    {

        //
        // Add XML Schema timestamp
        //

        dwIdentifier = MD_GLOBAL_XMLSCHEMATIMESTAMP;
        dwDataType   = BINARY_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&g_XMLSchemaFileTimeStamp,
                                           sizeof(FILETIME));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }

        //
        // Add XML Schema timestamp
        //

        dwIdentifier = MD_GLOBAL_BINSCHEMATIMESTAMP;
        dwDataType   = BINARY_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&g_BINSchemaFileTimeStamp,
                                           sizeof(FILETIME));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }
    }

    hr = pCLocationWriter->WriteLocation(TRUE);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] WriteLocation failed with hr = 0x%x.\n",
                  hr));
        goto exit;
    }

exit:

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return hr;
}

//
// Added by Mohit (10/00)
//

//********** Utilities **********//

HRESULT
RemoveLastPartOfPath(
        IN OUT LPWSTR io_wszPath,
        IN     int    i_iLen)
/*++

Routine Description:

    Removes last part of absolute path.
    Ex: "/LM/w3svc/" -> "/LM/"
        "/LM/w3svc"  -> "/LM/"
        "/LM"        -> "/"
        "/"          -> "/"

Arguments:

    wszPath       - The absolute path (null terminated).

    iLen          - The length of the string in chars
                    (not including null termination)

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_INVALID_NAME

Notes:

--*/
{
    MD_ASSERT(io_wszPath != NULL);

    bool bCharSeen = false;
    HRESULT hr = RETURNCODETOHRESULT(ERROR_INVALID_NAME);

    for(int i = i_iLen-1; i>=0; i--)
    {
        if(io_wszPath[i] == MD_PATH_DELIMETERW)
        {
            hr = RETURNCODETOHRESULT(ERROR_SUCCESS);
            if(bCharSeen)
                break;
        }
        else
        {
            bCharSeen = true;
        }
        io_wszPath[i] = L'\0';
    }

    if(io_wszPath[0] == L'\0' && i_iLen > 0)
    {
        io_wszPath[0] = MD_PATH_DELIMETERW;
        io_wszPath[1] = L'\0';
    }

    return hr;
}

HRESULT
GetMostRecentHistoryFile(
    LPCWSTR i_wszPattern,
    DWORD*  io_pdwMajor,
    DWORD*  io_pdwMinor)
{
    MD_ASSERT(i_wszPattern != NULL);
    MD_ASSERT(io_pdwMajor  != NULL);
    MD_ASSERT(io_pdwMinor  != NULL);

    HRESULT          hr        = S_OK;
    HANDLE           hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW fdCur;
    WIN32_FIND_DATAW fdMostRecent;

    DWORD            dwMajor = 0;
    DWORD            dwMinor = 0;
    DWORD            dwError;

    bool             bMatch  = false;

    hFindFile = FindFirstFileW(i_wszPattern, &fdCur);
    if(hFindFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        hr = RETURNCODETOHRESULT(dwError);
        // printf("[%s: Line %d] hr=0x%x\n", __FILE__, __LINE__, hr);
        goto exit;
    }

    do
    {
        if( !bMatch ||
            (bMatch && CompareFileTime(&fdCur.ftLastWriteTime, &fdMostRecent.ftLastWriteTime) > 0) )
        {
            hr = ParseVersionNumber(
                fdCur.cFileName,
                &dwMinor,
                &dwMajor);
            if(SUCCEEDED(hr))
            {
                bMatch = true;
                memcpy(&fdMostRecent, &fdCur, sizeof(WIN32_FIND_DATA));
            }
            hr = S_OK;
        }
    }
    while(FindNextFileW(hFindFile, &fdCur));

    if(!bMatch)
    {
        hr = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
        goto exit;
    }

    hr = ParseVersionNumber(
        fdMostRecent.cFileName,
        &dwMinor,
        &dwMajor);
    if(FAILED(hr))
    {
        goto exit;
    }

    *io_pdwMajor = dwMajor;
    *io_pdwMinor = dwMinor;

exit:
    if(hFindFile != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindFile);
    }

    return hr;
}

//******** Meat *********//

HRESULT
SaveInheritedOnly(IN CWriter*             i_pCWriter,
                  IN CMDBaseObject*       i_pboRoot,
                  IN BUFFER*              i_pbufParentPath,
                  IN IIS_CRYPTO_STORAGE*  i_pCryptoStorage,
                  IN PIIS_CRYPTO_BLOB     i_pSessionKeyBlob)
/*++

Routine Description:

    Save a node, either with or w/o inherited properties.

Arguments:

    Root       - The root of the tree to save.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    MD_ASSERT(i_pbufParentPath->QueryPtr() != NULL);

    HRESULT hresReturn = S_OK;

    DWORD     cchParentPath             = (DWORD)wcslen((LPCWSTR)i_pbufParentPath->QueryPtr());
    DWORD     cchName                   = 0;
    DWORD     cchNewParentPath          = 0;   // consists of parent and name
    LPWSTR    wszNewParentPath          = NULL;
    LPWSTR    pCur                      = NULL;
    FILETIME* pftTime                   = NULL;
    CLocationWriter* pCLocationWriter   = NULL;
    CMDBaseData*     dataAssociatedData = NULL;
    DWORD            dwEnumObjectIndex  = 0;

    //
    // Construct the location (i.e. inherited:/LM/w3svc/1)
    //
    if(i_pboRoot->GetName(TRUE) == NULL)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        DBGERROR((DBG_CONTEXT, "Out of memory\n"));
        goto exit;
    }
    cchName          = (DWORD)wcslen((LPWSTR)i_pboRoot->GetName(TRUE));

    cchNewParentPath =
        CImporter::sm_cchInheritedPropertiesLocationPrefix +
        cchParentPath +
        cchName       +
        2;                  // terminating slash + null terminator
    wszNewParentPath = new WCHAR[cchNewParentPath];
    if(wszNewParentPath == NULL)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        DBGERROR((DBG_CONTEXT, "Out of memory\n"));
        goto exit;
    }

    pCur = wszNewParentPath;
    memcpy(
        pCur,
        CImporter::sm_wszInheritedPropertiesLocationPrefix,
        sizeof(WCHAR) * CImporter::sm_cchInheritedPropertiesLocationPrefix);
    pCur += CImporter::sm_cchInheritedPropertiesLocationPrefix;

    memcpy(pCur, i_pbufParentPath->QueryPtr(), sizeof(WCHAR) * cchParentPath);
    pCur += cchParentPath;

    if(i_pboRoot != g_pboMasterRoot)
    {
        memcpy(pCur, i_pboRoot->GetName(TRUE), sizeof(WCHAR) * cchName);
        pCur  += cchName;
        *pCur =  MD_PATH_DELIMETERW;
        pCur  += 1;
        *pCur = L'\0';
    }
    pftTime = i_pboRoot->GetLastChangeTime();

    //
    // Fetch the location writer
    //
    hresReturn = i_pCWriter->GetLocationWriter(&pCLocationWriter, wszNewParentPath);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "GetLocationWriter failed [0x%x]\n", hresReturn));
        goto exit;
    }

    hresReturn = pCLocationWriter->InitializeKeyTypeAsInherited();
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "InitializeKeyTypeAsInherited failed [0x%x]\n", hresReturn));
        goto exit;
    }

    for(dwEnumObjectIndex=0; ; dwEnumObjectIndex++)
    {
        DWORD dwTemp           = dwEnumObjectIndex;
        CMDBaseObject* pboTemp = NULL;

        dataAssociatedData = i_pboRoot->EnumInheritableDataObject(
            /*ref*/ dwTemp,
            ALL_METADATA,
            ALL_METADATA,
            &pboTemp);

        //
        // No more data
        //
        if(dataAssociatedData == NULL)
        {
            break;
        }

        //
        // Only save property if it's inherited
        //
        if(pboTemp != i_pboRoot)
        {
            hresReturn = SaveDataObject(
                dataAssociatedData,
                pCLocationWriter,
                i_pCryptoStorage,
                i_pSessionKeyBlob);
            if(FAILED(hresReturn))
            {
                DBGERROR((DBG_CONTEXT, "SaveDataObject failed [0x%x]\n", hresReturn));
                goto exit;
            }
        }
    }

    hresReturn = pCLocationWriter->WriteLocation(TRUE);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "WriteLocation failed [0x%x]\n", hresReturn));
        goto exit;
    }

exit:
    delete pCLocationWriter;
    pCLocationWriter = NULL;
    delete [] wszNewParentPath;
    wszNewParentPath = NULL;
    return hresReturn;
}

HRESULT
SaveSomeData(
         IN BOOL                i_bSaveInherited,
         IN BOOL                i_bSaveNodeOnly,
         IN BOOL                i_bOverwriteFile,
         IN IIS_CRYPTO_STORAGE* i_pCryptoStorage,
         IN PIIS_CRYPTO_BLOB    i_pSessionKeyBlob,
         IN LPCWSTR             i_wszBackupLocation,
         IN METADATA_HANDLE     i_hHandle,
         IN LPCWSTR             i_wszSourcePath,
         IN BOOL                i_bHaveReadSaveSemaphore
         )
/*++

Routine Description:

    Saves some meta data (used by export).

Arguments:

    i_wszSourcePath - This is absolute (not relative to handle).  We need
        it for SaveTree()

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    MD_ASSERT(i_wszBackupLocation != NULL);
    if(!i_bOverwriteFile)
    {
        return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
    }

    HRESULT         hresReturn         = ERROR_SUCCESS;

    //
    // Stores i_wszSourcePath as unicode (i.e. /LM/w3svc/1)
    // Passed to SaveTree
    //
    BUFFER          bufParentPath;

    //
    // Handle of the source path
    //
    CMDHandle*      phoHandle          = NULL;

    HANDLE          hTempFile          = INVALID_HANDLE_VALUE;
    LPWSTR          wszTempFile        = NULL;

    BOOL            bTempFileOpen      = false;
    BOOL            bMRLock            = false;
    DWORD           dwError;

    if(!i_bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    if(wcschr(i_wszBackupLocation, L'\\') == NULL)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_FILE_INVALID);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    g_LockMasterResource.ReadLock();
    bMRLock = true;

    hresReturn = GetUnicodeName(g_strTempFileName->QueryStr(), &wszTempFile);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // TODO: Investigate if I actually need to check this.
    //
    if(g_bSaveDisallowed)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_SHUTDOWN_IN_PROGRESS);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // Write to a temp file first in case there are errors.
    //
    SECURITY_ATTRIBUTES saStorage;

    if (g_psdStorage != NULL)
    {
        saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
        saStorage.lpSecurityDescriptor = g_psdStorage;
        saStorage.bInheritHandle = FALSE;
    }

    hTempFile = CreateFileW(
        wszTempFile,
        GENERIC_READ | GENERIC_WRITE,
        0,
        &saStorage,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        0);
    if (hTempFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwError);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    bTempFileOpen = true;

    //
    // Validate source handle
    //
    phoHandle = GetHandleObject(i_hHandle);
    if(phoHandle == NULL)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else if(!phoHandle->IsReadAllowed() && !phoHandle->IsWriteAllowed())
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
    }
    else if(phoHandle->IsSchemaHandle())
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
    }
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // Doctor up i_wszSourcePath and put it in pbufParentPath
    //
    int cchSourcePath = (int)wcslen(i_wszSourcePath);
    if( !bufParentPath.Resize( sizeof(WCHAR)*(cchSourcePath+2)) )
    {
        dwError = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwError);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    LPWSTR wszPathNew = (LPWSTR)bufParentPath.QueryPtr();
    if(i_wszSourcePath[0] == L'\0')
    {
        wszPathNew[0] = MD_PATH_DELIMETERW;
        wszPathNew[1] = L'\0';
    }
    else
    {
        for(int i = 0; i < cchSourcePath; i++)
        {
            wszPathNew[i] = (i_wszSourcePath[i] == MD_ALT_PATH_DELIMETERW) ?
                MD_PATH_DELIMETERW : i_wszSourcePath[i];
        }
        wszPathNew[i] = L'\0';

        hresReturn = RemoveLastPartOfPath((LPWSTR)bufParentPath.QueryPtr(), cchSourcePath);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }
    }

    //
    // Walk thru metabase and actually do the writing
    //
    DBGINFOW((DBG_CONTEXT,
        L"[SaveSchema] Initializing writer with write file: %s bin file: %s.\n",
        g_wszTempFileName,
        g_pGlobalISTHelper->m_wszBinFileForMeta));

    {
        //
        // Inside {} because we need to call CWriter's destructor to flush the file.
        //
        CWriter writer;
        hresReturn = writer.Initialize(
            wszTempFile,
            g_pGlobalISTHelper,
            hTempFile);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = writer.BeginWrite(eWriter_Metabase);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = SaveGlobalsToXML(
            &writer,
            i_pSessionKeyBlob,
            true);      // session key only
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = SaveTree(&writer,
            phoHandle->GetObject(),
            &bufParentPath,
            i_pCryptoStorage,
            i_pSessionKeyBlob,
            !i_bSaveNodeOnly,
            false /* do not save schema node */);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        if(i_bSaveInherited)
        {
            hresReturn = SaveInheritedOnly(&writer,
                phoHandle->GetObject(),
                &bufParentPath,
                i_pCryptoStorage,
                i_pSessionKeyBlob);
        }
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = writer.EndWrite(eWriter_Metabase);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }
    }

    g_LockMasterResource.ReadUnlock();
    bMRLock = false;

    if(!CloseHandle(hTempFile))
    {
        dwError = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwError);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    bTempFileOpen = false;

    //
    // Temp file created successfully.  Finally, move temp to real
    // Real may be on another machine, so we need to impersonate.
    //
    hresReturn = CoImpersonateClient();
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    if(!MoveFileExW(wszTempFile, i_wszBackupLocation,
                   MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
    {
        dwError = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwError);
    }
    CoRevertToSelf();
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

exit:
    if(bMRLock)
    {
        g_LockMasterResource.ReadUnlock();
        bMRLock = false;
    }
    if(bTempFileOpen)
    {
        MD_ASSERT(hTempFile != INVALID_HANDLE_VALUE);
        CloseHandle(hTempFile);

        //
        // Only set failure code if we don't already have another failure.
        //
        if(SUCCEEDED(hresReturn))
        {
            dwError = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwError);
        }
    }
    if(hTempFile != INVALID_HANDLE_VALUE)
    {
        DeleteFileW(wszTempFile);
    }
    if(!i_bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }
    bufParentPath.FreeMemory();

    delete [] wszTempFile;
    wszTempFile = NULL;

    return hresReturn;
}

HRESULT
ReadSomeDataFromXML(
             IN LPSTR            i_pszPasswd,
             IN LPWSTR           i_wszFileName,
             IN LPWSTR           i_wszSourcePath,
             IN LPCWSTR          i_wszKeyType,
             IN DWORD            i_dwMDFlags,
             IN BOOL             i_bHaveReadSaveSemaphore,
             OUT CMDBaseObject** o_ppboNew)
/*++

Routine Description:

    Used by import.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system
                 Return codes from config.

Notes:

--*/
{
    MD_ASSERT(i_wszKeyType != NULL);
    MD_ASSERT(o_ppboNew    != NULL);

    HRESULT   hr                   = S_OK;
    bool      bImpersonatingClient = false;
    CImporter Importer(i_wszFileName, i_pszPasswd);

    //
    // TODO: Determine if we need this
    //
    if (!i_bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hr));
        goto exit;
    }
    bImpersonatingClient = true;

    hr = Importer.Init();
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hr));
        goto exit;
    }

    hr = Importer.DoIt(i_wszSourcePath, i_wszKeyType, i_dwMDFlags, o_ppboNew);
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hr));
        goto exit;
    }

exit:
    if (!i_bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if (bImpersonatingClient)
    {
        CoRevertToSelf();
        bImpersonatingClient = false;
    }

    return hr;
}

HRESULT
EnumFiles(IN LPWSTR i_wszPattern,
          IN DWORD i_dwMDEnumIndex,
          OUT DWORD *o_pdwMajor,
          OUT DWORD *o_pdwMinor,
          OUT PFILETIME o_pftMDBackupTime)
/*++

Routine Description:

    Given a pattern, will enum the corresponding files, filling in the
    out params.  Used as a helper routine for EnumHistory.

    TODO: Have EnumBackups use this as well to eliminate duplicate code.

Arguments:

Return Value:

Notes:

    Out parameters may be set even though the function fails.  Caller should
    deal with this.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;

    //
    // TODO: Assert that params are not null.
    //       (This is checked by caller)
    //

    if(i_wszPattern == NULL) {
        hresReturn = E_INVALIDARG;
        return hresReturn;
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // Enumerate files
        //
        HANDLE hFile = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATAW wfdFile;
        DWORD dwEnumIndex = (DWORD) -1;
        hFile = FindFirstFileW(i_wszPattern,
                               &wfdFile);
        if (hFile == INVALID_HANDLE_VALUE) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
        }
        else {
            /*if (CheckDigits(wfdFile.cFileName +
                            GetBackupNameLen(wfdFile.cFileName) +
                            (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                dwEnumIndex++;
            }*/
            hresReturn = ParseVersionNumber(wfdFile.cFileName, o_pdwMinor, o_pdwMajor);
            if (SUCCEEDED(hresReturn))
            {
                dwEnumIndex++;
            }
            else
            {
                hresReturn = S_OK;
            }
            while (SUCCEEDED(hresReturn) && (dwEnumIndex != i_dwMDEnumIndex)) {
                //
                // Process the remaining files
                //
                if (FindNextFileW(hFile, &wfdFile)) {
                    /*if (CheckDigits(wfdFile.cFileName +
                                    GetBackupNameLen(wfdFile.cFileName) +
                                    (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                        //
                        // One of our files
                        //
                        dwEnumIndex++;
                    }*/
                    if (SUCCEEDED(ParseVersionNumber(wfdFile.cFileName, o_pdwMinor, o_pdwMajor))) {
                        dwEnumIndex++;
                    }
                }
                else {
                    hresReturn = GetLastHResult();
                }
            }
            FindClose(hFile);
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Found the file
            //
            int iLen = (int)wcslen(wfdFile.cFileName);
            if(iLen > MD_BACKUP_MAX_LEN-1) {
                hresReturn = E_INVALIDARG;
            }
            else {
                MD_COPY(o_pftMDBackupTime,
                        &(wfdFile.ftLastWriteTime),
                        sizeof(FILETIME));
            }
        }
        else {
            if ((hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) ||
                (hresReturn == RETURNCODETOHRESULT(ERROR_NO_MORE_FILES))) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
        }
    }

    return hresReturn;
}

HRESULT
ReplaceMasterRoot(
    CMDBaseObject* i_pboNew,
    CMDHandle*     i_phoRootHandle)
/*++

Synopsis:
    Replaces g_pboMasterRoot with a copy of i_pboNew.  The exception is that the
    schema node from g_pboMasterRoot is maintained.

    Caller must have g_rMasterResourceLock(TSRES_LOCK_WRITE)

Arguments: [i_pboNew] - The pbo to become the new root.  Does NOT contain schema
                        schema node.
           [i_phoRootHandle] - An open write handle to the existing root.

Return Value:

--*/
{
    MD_ASSERT(i_pboNew        != NULL);
    MD_ASSERT(i_phoRootHandle != NULL);

    HRESULT        hr        = S_OK;
    BOOL           bChanged  = false;

    //
    // For child nodes
    //
    CMDBaseObject* pboChild  = NULL;
    CMDBaseObject* pboSchema = NULL;

    //
    // For data
    //
    PVOID*         ppvMainDataBuf   = NULL;
    CMDBaseData*   pbdCurrent       = NULL;
    DWORD          dwNumDataObjects = 0;
    DWORD          dwCurrentDataID  = 0;

    //
    // Remove all the data from g_pboMastRoot
    //
    ppvMainDataBuf = GetMainDataBuffer();
    MD_ASSERT (ppvMainDataBuf != NULL);
    if ( ppvMainDataBuf == NULL )
    {
        hr = E_FAIL;
        goto exit;
    }

    dwNumDataObjects = g_pboMasterRoot->GetAllDataObjects(
        ppvMainDataBuf,
        0,
        ALL_METADATA,
        ALL_METADATA,
        FALSE,
        FALSE);
    for (ULONG i = 0; i < dwNumDataObjects ; i++)
    {
        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
        MD_ASSERT(pbdCurrent != NULL);
        dwCurrentDataID = pbdCurrent->GetIdentifier();
        MD_REQUIRE(g_pboMasterRoot->RemoveDataObject(pbdCurrent, TRUE) == S_OK);
        i_phoRootHandle->SetChangeData(g_pboMasterRoot, MD_CHANGE_TYPE_DELETE_DATA, dwCurrentDataID);
    }
    if (dwNumDataObjects > 0)
    {
        bChanged = true;
    }
    FreeMainDataBuffer(ppvMainDataBuf);

    //
    // Remove all the child data nodes except schema node.
    //
    ULONG idxFirstNonSchema = 0;
    while((pboChild = g_pboMasterRoot->EnumChildObject(idxFirstNonSchema)) != NULL)
    {
        if(_wcsicmp(WSZSCHEMA_KEY_NAME1, (LPWSTR)pboChild->GetName(true)) == 0)
        {
            MD_ASSERT(idxFirstNonSchema == 0);
            idxFirstNonSchema++;
            pboSchema = pboChild;
        }
        else
        {
            bChanged = true;
            MD_REQUIRE(g_pboMasterRoot->RemoveChildObject(pboChild) == S_OK);
            if(i_phoRootHandle->SetChangeData(pboChild, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != S_OK)
            {
                delete(pboChild);
            }
        }
    }
    MD_ASSERT(idxFirstNonSchema <= 1);

    //
    // Do the copying of data and child nodes
    //
    hr = CopyTree(
        i_phoRootHandle,
        g_pboMasterRoot,
        i_pboNew,
        bChanged);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(bChanged)
    {
        g_dwSystemChangeNumber++;
    }
    return hr;
}

HRESULT
CopyMetaObject(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
        BOOL bUseSourceHandle,
        CMDBaseObject* pboSourceIn,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ BOOL bMDOverwriteFlag,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves Source meta object and it's data and descendants to Dest. The
    copied object is a child of Dest.

Arguments:

    SourceHandle - The handle or the object to be copied. If copyflag is specified, read permission
                   is requried. If not, read/write permission is required.

    SourcePath  - Path of the object to be copied, relative to the path of SourceHandle.
            eg. "Root Object/Child/GrandChild"

    DestHandle - The handle of the new location for the object. Write permission is required.

    DestPath  - The path of the new location for the object, relative to the path of
            DestHandle. The new object will be a child of the object specified by
            DestHandle/DestPath. Must not be a descendant of SourceHandle/SourePath.
            eg. "Root Object/Child2"

    OverwriteFlag - Determines the behavior if the a meta object with the same name as Source is
            already a child of Dest.
            If TRUE, the existing object and all of its data and
            descandants are deleted prior to copying/moving Source.
            If FALSE, the existing object, data, and descendants remain, and Source is merged
            in. In cases of data conflicts, the Source data overwrites the Dest data.

    CopyFlag - Determines whether Source is deleted from its original location.
            If TRUE, a copy is performed. Source is not deleted from its original location.
            If FALSE, a move is performed. Source is deleted from its original location.

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    CMDHandle *phoDestHandle, *phoSourceHandle;
    CMDBaseObject *pboSource = NULL, *pboDest = NULL, *pboIndex = NULL, *pboNew = NULL, *pboDestParent = NULL;
    LPSTR pszTempPath;
    LPSTR pszRemainingDestPath;
    BOOL bChanged = FALSE;
    WCHAR strName[METADATA_MAX_NAME_LEN];

    if(!bUseSourceHandle)
    {
        MD_ASSERT(pboSourceIn != NULL);
    }

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {

        //
        // check if pszDestPath is a valid parameter (non-NULL)
        //

        if (pszDestPath == NULL) {
            hresReturn = E_INVALIDARG;
        }
        else {

            //
            // Must have access to Dest parent to add it.
            // Make sure that a valid path was specified, ie. handle
            // points to ancestor.
            //
            pszTempPath = pszDestPath;
            SkipPathDelimeter(pszTempPath, bUnicode);
            if(bUseSourceHandle)
            {
                hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
            }
            if (FAILED(hresReturn)) {
                hresReturn = E_INVALIDARG;
            }
            if (!bMDCopyFlag) {
                //
                // Must have access to source parent to remove it.
                // Make sure that a valid path was specified, ie. handle
                // points to ancestor.
                //
                pszTempPath = pszSourcePath;
                SkipPathDelimeter(pszTempPath, bUnicode);
                hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
                if (FAILED(hresReturn)) {
                    hresReturn = E_INVALIDARG;
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        g_LockMasterResource.WriteLock();
        if(bUseSourceHandle)
        {
            hresReturn = GetObjectFromPath(pboSource, hMDSourceHandle,
                (bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE,
                (LPSTR)pszSourcePath, bUnicode);
        }
        else
        {
            pboSource = pboSourceIn;
        }
        if (SUCCEEDED(hresReturn)) {
            //
            // GetObjectFromPath updates path, need both original and remainder
            //
            pszRemainingDestPath = pszDestPath;

            phoDestHandle = GetHandleObject(hMDDestHandle);

            if(phoDestHandle != NULL)
            {
                hresReturn = GetObjectFromPathWithHandle(pboDest,
                                                         hMDDestHandle,
                                                         phoDestHandle,
                                                         METADATA_PERMISSION_WRITE,
                                                         (LPSTR)pszRemainingDestPath,
                                                         bUnicode);
            }
            else
            {
                hresReturn = E_HANDLE;
            }

            if ((SUCCEEDED(hresReturn)) ||
                ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL))) {
                //
                // Make sure dest is not descendant of source
                //
                for (pboIndex = pboDest; pboIndex != NULL; pboIndex = pboIndex->GetParent()) {
                    if (pboIndex == pboSource) {
                        hresReturn = E_INVALIDARG;
                        break;
                    }
                }
            }

            //
            // I don't think we need this call, since we have already called
            // GetHandleObject Above.
            //
            // phoDestHandle = GetHandleObject(hMDDestHandle);

            if (SUCCEEDED(hresReturn)) {
                //
                // Object already exists
                //
                if (pboDest == pboSource) {
                    //
                    // Copy to self
                    //
                }
                else {
                    MD_ASSERT (phoDestHandle != NULL);
                    if (bMDOverwriteFlag) {
                        if (pboDest->GetName(bUnicode) == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                        else if(pboDest == g_pboMasterRoot) {
                            hresReturn = ReplaceMasterRoot(pboSource, phoDestHandle);
                        }
                        else {
                            pboDestParent = pboDest->GetParent();
                            hresReturn = MakeTreeCopy(pboSource, pboNew, pboDest->GetName(bUnicode), bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                MD_REQUIRE(SUCCEEDED(pboDestParent->RemoveChildObject(pboDest->GetName(bUnicode), bUnicode)));
                                hresReturn = pboDestParent->InsertChildObject(pboNew);
                                if (SUCCEEDED(hresReturn)) {
                                    g_dwSystemChangeNumber++;

                                    INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle,
                                                                   phoDestHandle,
                                                                   pszDestPath,
                                                                   bUnicode);


                                    if (phoDestHandle->SetChangeData(
                                        pboDest, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                                        delete(pboDest);
                                    }
                                    AddNewChangeData(phoDestHandle, pboNew);
                                }
                                else {
                                    delete (pboNew);
                                    pboDestParent->InsertChildObject(pboDest);
                                }
                            }
                        }
                    }
                    else {
                        //
                        // Object exists at destination and not overwrite.
                        // Add in missing objects and data.
                        //
                        hresReturn = CopyTree(phoDestHandle, pboDest, pboSource, bChanged);
                        if (bChanged) {
                            g_dwSystemChangeNumber++;

                            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle,
                                                           phoDestHandle,
                                                           pszDestPath,
                                                           bUnicode);
                        }
                    }
                }
            }
            else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL)) {

                //
                // Full destination path doesn't exist, so create it
                //

                hresReturn = MakeTreeCopyWithPath(pboSource,
                                               pboNew,
                                               pszRemainingDestPath,
                                               bUnicode);
                if (SUCCEEDED(hresReturn)) {
                    MD_ASSERT(pboDest != NULL);
                    hresReturn = pboDest->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        g_dwSystemChangeNumber++;
                        INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle,
                                                       phoDestHandle,
                                                       pszDestPath,
                                                       bUnicode);
                        AddNewChangeData(phoDestHandle, pboNew);
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }

            if ((SUCCEEDED(hresReturn)) && (!bMDCopyFlag)) {
                MD_REQUIRE(SUCCEEDED(pboSource->GetParent()->RemoveChildObject(pboSource)));
                phoSourceHandle = GetHandleObject(hMDSourceHandle);
                MD_ASSERT (phoSourceHandle != NULL);
                if (phoSourceHandle->SetChangeData(pboSource, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboSource);
                }
            }
        }
        g_LockMasterResource.WriteUnlock();
    }
    return hresReturn;
}

BOOL WstrToUl(
    LPCWSTR     i_wszSrc,
    WCHAR       i_wcTerminator,
    ULONG*      o_pul)
/*++

Synopsis:
    Converts a WstrToUl.
    We need this because neither swscanf nor atoi indicate error cases correctly.

Arguments: [i_wszSrc]       - The str to be converted
           [i_wcTerminator] - At what char we should stop searching
           [o_pul]          - The result, only set on success.

Return Value:
    BOOL - true if succeeded, false otherwise

--*/
{
    MD_ASSERT(o_pul);
    MD_ASSERT(i_wszSrc);

    static const ULONG  ulMax  = 0xFFFFFFFF;
    ULONG               ulCur  = 0;
    _int64              i64Out = 0;

    for(LPCWSTR pCur = i_wszSrc; *pCur != L'\0' && *pCur != i_wcTerminator; pCur++)
    {
        ulCur = *pCur - L'0';
        if(ulCur > 9)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Invalid char encountered\n"));
            return false;
        }

        i64Out = i64Out*10 + ulCur;
        if(i64Out > ulMax)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Number is too big\n"));
            return false;
        }
    }

    MD_ASSERT(i64Out <= ulMax);
    *o_pul = (ULONG)i64Out;
    return true;
}

BOOL SchemaTreeInTable(ISimpleTableRead2*    i_pISTProperty)
{
    HRESULT     hr           = S_OK;
    DWORD       dwGroup      = eMBProperty_Custom;
    LPWSTR      wszName      = L"AdminACL";
    LPWSTR      wszLocation  = L"/Schema";
    LPVOID      a_Identity[] = {(LPVOID)wszName,
                                (LPVOID)wszLocation,
                                (LPVOID)&dwGroup
    };
    ULONG       iRow         = 0;

    //
    // Assumption here is that AdminACL is always present at /Schema
    // If we find it, we assume that the schema tree is in the table.
    //

    hr = i_pISTProperty->GetRowIndexByIdentity(NULL,
                                               a_Identity,
                                               &iRow);

    DBGINFOW((DBG_CONTEXT,
              L"[SchemaTreeInTable] GetRowIndexByIdentity returned hr=0x%x\n",hr));


    if(FAILED(hr))
    {
        dwGroup = eMBProperty_IIsConfigObject;

        hr = i_pISTProperty->GetRowIndexByIdentity(NULL,
                                                   a_Identity,
                                                   &iRow);

        if(FAILED(hr))
        {
            return FALSE;
        }
    }

    return TRUE;
}


HRESULT CompileIfNeeded(LPWSTR  i_wszDataFileName,
                        LPWSTR  i_wszSchemaFileName,
                        BOOL*   o_pbSchemaFileNotFound)
{
    HRESULT                     hr        = S_OK;
    ISimpleTableDispenser2*     pISTDisp  = NULL;
    IMetabaseSchemaCompiler*    pCompiler = NULL;

    //
    // Get a pointer to the compiler to get the bin file name.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CompileIfNeeded] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
                                  (LPVOID*)&pCompiler);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CompileIfNeeded] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    if(-1 != GetFileAttributesW(i_wszSchemaFileName))
    {
        BOOL bMatchTimeStamp = FALSE;

        //
        // Schema file present. Check if it has a corresponding valid bin file.
        //

        *o_pbSchemaFileNotFound = FALSE;

        if(NULL == g_pGlobalISTHelper)
        {
            BOOL bFailIfBinFileAbsent = TRUE;

            hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

            if(SUCCEEDED(hr))
            {
                hr = MatchTimeStamp(i_wszDataFileName,
                                    i_wszSchemaFileName,
                                    g_pGlobalISTHelper->m_wszBinFileForMeta,
                                    &bMatchTimeStamp);

                if(FAILED(hr))
                {
                    goto exit;
                }

                if(bMatchTimeStamp)
                {
                    //
                    // Bin file found and time stamp matched, no need to compile
                    //

                    DBGINFOW((DBG_CONTEXT,
                              L"[CompileIfNeeded] Schema file: %s found. Schema bin file: %s is valid, and its timestamp matches what is stored in data file %s. No compilation reqired.\n",
                              i_wszSchemaFileName,
                              g_pGlobalISTHelper->m_wszBinFileForMeta,
                              i_wszDataFileName));

                    goto exit;
                }
            }
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] Unable to get the the bin file name. (Assuming file is missing or invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
            }
        }
        else
        {
            hr = MatchTimeStamp(i_wszDataFileName,
                                i_wszSchemaFileName,
                                g_pGlobalISTHelper->m_wszBinFileForMeta,
                                &bMatchTimeStamp);

            if(FAILED(hr))
            {
                goto exit;
            }

            if(bMatchTimeStamp)
            {
                //
                // Bin file found and time stamp matched, no need to compile
                //

                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] Schema file: %s found. Schema bin file: %s is valid, and its timestamp matches what is stored in data file %s. No compilation reqired.\n",
                          i_wszSchemaFileName,
                          g_pGlobalISTHelper->m_wszBinFileForMeta,
                          i_wszDataFileName));

                goto exit;
            }
        }

        //
        // If you reach here it means that the schema file was found and either
        // a. the bin file was invalid
        // b. the bin file was missing
        // c. the bin file had a timestamp mistmatch
        // Hence try compiling from the schema file.
        //

        DBGINFOW((DBG_CONTEXT,
                  L"[CompileIfNeeded] Compiling from schema file %s\n", i_wszSchemaFileName));

        hr = CompileIntoBinFromSchemaFile(pCompiler,
                                          i_wszSchemaFileName);

        if(SUCCEEDED(hr))
        {
            goto exit;
        }

    }
    else
    {
        *o_pbSchemaFileNotFound = TRUE;
    }

    //
    // Recreate from shipped schema
    //

    DBGINFOW((DBG_CONTEXT,
              L"[CompileIfNeeded] Schema file not found or compile from it failed. Compiling from shipped schema\n"));


    hr = CompileIntoBin(pCompiler,
                        NULL,
                        i_wszSchemaFileName);

exit:

    if(SUCCEEDED(hr))
    {
        if(NULL == g_pGlobalISTHelper)
        {
            BOOL bFailIfBinFileAbsent = TRUE;

            hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] Unable to get the the bin file name. (Assuming file is invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = UpdateTimeStamp((LPWSTR)i_wszSchemaFileName,
                                 g_pGlobalISTHelper->m_wszBinFileForMeta);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] UpdateTimeStamp failed with hr = 0x%x.\n",hr));
            }

        }

    }

    if(NULL != pCompiler)
    {
        pCompiler->Release();
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Utility function that takes the schema file and copies it as an extension
    file and then invokes compile. This is called in cases where the bin file
    is out of sync with the schema file, and since the schema file is the
    master, you want to regenerate the bin file from the existing schema file.
    This function touches global variable g_wszSchemaExtensions file, and hence
    needs the appropriate lock to be taken before calling.

Arguments:

    [in] compiler
    [in] name of the schema file that needs to be compiled


Return Value:

    HRESULT

--***************************************************************************/
HRESULT CompileIntoBinFromSchemaFile(IMetabaseSchemaCompiler* i_pCompiler,
                                     LPCWSTR                   i_wszSchemaFileName)
{
    HRESULT hr = S_OK;

    MD_ASSERT(NULL != i_pCompiler);
    MD_ASSERT(NULL != i_wszSchemaFileName);

    //
    // Bug #512868  If someone had attrib-ed an existing extenstion file
    // be read-only then we could land up in a state where we will not be
    // able to recreate the extensions file. Hence attrib the extensions
    // file to be read-write if it exists. An extensions file can be
    // around only if a previous compile has failed.
    //
    // Also, in this case reset the attrib on the extensions file after you
    // have created it via copy. Else, if the schema file is read-only you
    // will land up with a read-only extensions file. We cannot reset the
    // schema file before the copy because it may be on a CD-ROM.
    //

    ResetFileAttributesIfNeeded((LPTSTR)g_wszSchemaExtensionFile,
                                TRUE);


    if(CopyFileW(i_wszSchemaFileName,
                 g_wszSchemaExtensionFile,
                 FALSE))
    {

        ResetFileAttributesIfNeeded((LPTSTR)g_wszSchemaExtensionFile,
                                    TRUE);

        hr = CompileIntoBin(i_pCompiler,
                            g_wszSchemaExtensionFile,
                            i_wszSchemaFileName);


        if(SUCCEEDED(hr))
        {
            if(!DeleteFileW(g_wszSchemaExtensionFile))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIntoBinFromSchemaFile] Compile from schema file: %s succeeded, but cannot delete the extsions file: %s into which it was copied. Delete file failed with hr = 0x%x.\n",
                          i_wszSchemaFileName,
                          g_wszSchemaExtensionFile,
                          hr));

                hr = S_OK;
            }

        }
        else
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CompileIntoBinFromSchemaFile] Compile from schema file failed with hr = 0x%x.\n",
                      hr));
        }

    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[CompileIntoBinFromSchemaFile] Unable to copy %s to %s. CopyFile failed with hr = 0x%x.\n",
                  i_wszSchemaFileName,
                  g_wszSchemaExtensionFile,
                  hr));
    }

    return hr;

} // CompileIntoBinFromSchemaFile


/***************************************************************************++

Routine Description:

    Utility function that takes the extension file and compiles it into the
    schema file

Arguments:

    [in] compiler
    [in] Extension file to be compiled
    [in] Name of the output schema file


Return Value:

    HRESULT

--***************************************************************************/
HRESULT CompileIntoBin(IMetabaseSchemaCompiler* i_pCompiler,
                       LPCWSTR                  i_wszSchemaExtensionFileName,
                       LPCWSTR                  i_wszSchemaFileName)
{

    HRESULT hr = S_OK;

    MD_ASSERT(NULL != i_pCompiler);
    MD_ASSERT(NULL != i_wszSchemaFileName);

    //
    // Always release the bin file that you've been using so far before a
    // compile.
    //

    ReleaseGlobalISTHelper();

    //
    // Bug #513962  If someone had attrib-ed an existing schema file
    // be read-only then we could land up in a state where we will not be
    // able to recreate the schema file. Hence attrib the schema
    // file to be read-write if it exists.
    //

    ResetFileAttributesIfNeeded((LPTSTR)i_wszSchemaFileName,
                                TRUE);

    hr = i_pCompiler->Compile(i_wszSchemaExtensionFileName,
                              i_wszSchemaFileName);

    return hr;

} // CompileIntoBin


HRESULT MatchTimeStamp(LPWSTR i_wszDataFileName,
                       LPWSTR i_wszSchemaXMLFileName,
                       LPWSTR i_wszSchemaBINFileName,
                       BOOL*  o_bMatchTimeStamp)
{
    HRESULT                   hr                      = S_OK;
    LPWSTR                    wszSchemaXMLTimeStamp   = MD_XML_SCHEMA_TIMESTAMPW;
    LPWSTR                    wszSchemaBINTimeStamp   = MD_BIN_SCHEMA_TIMESTAMPW;
    FILETIME                  XMLSchemaTimeStamp;
    FILETIME                  BINSchemaTimeStamp;
    WIN32_FILE_ATTRIBUTE_DATA XMLSchema;
    WIN32_FILE_ATTRIBUTE_DATA BINSchema;

    *o_bMatchTimeStamp = FALSE;

    hr = GetTimeStamp(i_wszDataFileName,
                      wszSchemaXMLTimeStamp,
                      &XMLSchemaTimeStamp);

    if(FAILED(hr))
    {
        if(E_ST_INVALIDTABLE == hr)
        {
            return hr;
        }
        else
        {
            return S_OK;
        }
    }

    if(!GetFileAttributesExW(i_wszSchemaXMLFileName,
                             GetFileExInfoStandard,
                             (LPVOID)&XMLSchema))
    {
        return S_OK;
    }

    if(0 != CompareFileTime(&XMLSchemaTimeStamp,
                            &XMLSchema.ftLastWriteTime))
    {
        return S_OK;
    }

    hr = GetTimeStamp(i_wszDataFileName,
                      wszSchemaBINTimeStamp,
                      &BINSchemaTimeStamp);

    if(FAILED(hr))
    {
        if(E_ST_INVALIDTABLE == hr)
        {
            return hr;
        }
        else
        {
            return S_OK;
        }
    }

    if(!GetFileAttributesExW(i_wszSchemaBINFileName,
                             GetFileExInfoStandard,
                             (LPVOID)&BINSchema))
    {
        return S_OK;
    }

    if(0 != CompareFileTime(&BINSchemaTimeStamp,
                            &BINSchema.ftLastWriteTime))
    {
        return S_OK;
    }

    *o_bMatchTimeStamp = TRUE;

    return S_OK;
}

HRESULT UpdateTimeStamp(LPWSTR i_wszSchemaXMLFileName,
                        LPWSTR i_wszSchemaBinFileName)
{
    WIN32_FILE_ATTRIBUTE_DATA XMLSchema;
    WIN32_FILE_ATTRIBUTE_DATA BINSchema;

    if(!GetFileAttributesExW(i_wszSchemaXMLFileName,
                                 GetFileExInfoStandard,
                                 (LPVOID)&XMLSchema))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    memcpy(&g_XMLSchemaFileTimeStamp, &(XMLSchema.ftLastWriteTime), sizeof(FILETIME));

    if(!GetFileAttributesExW(i_wszSchemaBinFileName,
                                 GetFileExInfoStandard,
                                 (LPVOID)&BINSchema))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    memcpy(&g_BINSchemaFileTimeStamp, &(BINSchema.ftLastWriteTime), sizeof(FILETIME));

    return S_OK;

}

HRESULT ComputeNewHistoryVersionNumber()
{
    ULONG               ulCurrentVersionNumber = g_ulHistoryMajorVersionNumber;
    ULONG               ulNextVersionNumber    = 0;
    WIN32_FIND_DATAW    FileData;
    HRESULT             hr                     = S_OK;
    HANDLE              hFind                  = INVALID_HANDLE_VALUE;
    LPWSTR              wszSearchString        = NULL;
    ULONG               i                      = 0;

    //
    // Compute a new version number and make sure that no history files
    // exist with that major version number.
    //

    do
    {
        if(ulCurrentVersionNumber != 0xFFFFFFFF)
        {
            ulNextVersionNumber = ulCurrentVersionNumber + 1;
        }
        else
        {
            ulNextVersionNumber = 0;
        }

        if((hFind != INVALID_HANDLE_VALUE) && (hFind != NULL))
        {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }

        hr = ConstructHistoryFileNameWithoutMinorVersion(&wszSearchString,
                                                         NULL,
                                                         g_wszHistoryFileSearchString,
                                                         g_cchHistoryFileSearchString,
                                                         g_wszRealFileNameExtension,
                                                         g_cchRealFileNameExtension,
                                                         ulNextVersionNumber);

        if(FAILED(hr))
        {
            goto exit;
        }

        hFind = FindFirstFileW(wszSearchString, &FileData);

        if(NULL != wszSearchString)
        {
            delete [] wszSearchString;
            wszSearchString = NULL;
        }

        ulCurrentVersionNumber = ulNextVersionNumber;
    }
    while((hFind != INVALID_HANDLE_VALUE) && (hFind != NULL) && (++i < 0xFFFFFFFF));

    g_ulHistoryMajorVersionNumber = ulNextVersionNumber;

exit:

    if((hFind != INVALID_HANDLE_VALUE) && (hFind != NULL))
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    return hr;

} // ComputeNewHistoryVersionNumber


/***************************************************************************++

Routine Description:

    Utility function to fetch the timestamp of the file. It maps a view of
    the file and looks for the timestamp

Arguments:

    [in] File name
    [out] Count of bytes for version number
    [out] Version number


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
GetTimeStamp(LPWSTR    i_wszFile,
             LPWSTR    i_wszPropertyName,
             FILETIME* o_FileTime)
{
    HRESULT                 hr                = S_OK;
    ISimpleTableDispenser2* pISTDisp          = NULL;
    ISimpleTableRead2*      pISTProperty      = NULL;
    STQueryCell             QueryCell[2];
    ULONG                   cCell             = sizeof(QueryCell)/sizeof(STQueryCell);
    LPWSTR                  wszGlobalLocation = MD_GLOBAL_LOCATIONW;
    ULONG                   cbFileTime        = sizeof(FILETIME);
    DWORD                   cb                = 0;
    FILETIME*               pFileTime         = NULL;

    //
    // Get only the root location - that where the timestamps are stored.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // No need to specify the schema file because we are getting a shipped
    // property from a global location.
    //

    QueryCell[0].pData     = (LPVOID)i_wszFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_wszFile)+1)*sizeof(WCHAR);

    QueryCell[1].pData     = (LPVOID)wszGlobalLocation;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iMBProperty_Location;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = (lstrlenW(wszGlobalLocation)+1)*sizeof(WCHAR);

    hr = pISTDisp->GetTable(wszDATABASE_METABASE,
                            wszTABLE_MBProperty,
                            (LPVOID)QueryCell,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID *)&pISTProperty);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] GetTable on %s failed with hr = 0x%x.\n",
                  wszTABLE_MBProperty,
                  hr));

        goto exit;
    }


    //
    // Get the timestamps.
    //

    hr = GetGlobalValue(pISTProperty,
                        i_wszPropertyName,
                        &cb,
                        (LPVOID*)&pFileTime);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] Unable to read %s. GetGlobalValue failed with hr = 0x%x.\n",
                  i_wszPropertyName,
                  hr));

        goto exit;

    }
    else if(cbFileTime != cb)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] GetGlobalValue returns incorrect count of bytes %d for %s. Expected %d.\n",
                  cb,
                  i_wszPropertyName,
                  cbFileTime));

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

    *o_FileTime = *(FILETIME*)pFileTime;

exit:

    if(NULL != pISTProperty)
    {
        pISTProperty->Release();
        pISTProperty = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    Sets the security on the the given file to system and administrators.

Arguments:

    [in] File name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SetSecurityOnFile(LPWSTR i_wszFileSrc,
                          LPWSTR i_wszFileDest)

{
    DWORD                   dwRes;
    PACL                    pDACL = NULL;
    PSECURITY_DESCRIPTOR    pSD   = NULL;
    HRESULT                 hr    = S_OK;

    //
    // Get the DACL of the original file.
    //

    dwRes = GetNamedSecurityInfoW(i_wszFileSrc,
                                  SE_FILE_OBJECT,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  &pDACL,
                                  NULL,
                                  &pSD);
    if (dwRes != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwRes);
        DBGINFOW((DBG_CONTEXT,
                  L"[SetSecurityOnFile] Unable to set security on %s. GetNamedSecurityInfo on %s failed with hr = 0x%x\n.",
                  i_wszFileDest,
                  i_wszFileSrc,
                  hr));
        hr = S_OK;
    }
    else
    {
        //
        // Set the DACL of the original file to the copy.
        //

        dwRes = SetNamedSecurityInfoW(i_wszFileDest,
                                      SE_FILE_OBJECT,
                                      DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      pDACL,
                                      NULL);
        if (dwRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwRes);
            DBGINFOW((DBG_CONTEXT,
                      L"[SetSecurityOnFile] Unable to set security on %s. SetNamedSecurityInfo failed with hr = 0x%x\n.",
                      i_wszFileDest,
                      hr));
            hr = S_OK;
        }
    }

    //
    // Cleanup the security descriptor.
    //

    if (NULL != pSD)
    {
        LocalFree(pSD);
    }

    return hr;

} // SetSecurityOnFile


void ResetFileAttributesIfNeeded(LPTSTR pszFile,
                                 BOOL   bUnicode)
{
    DWORD dwRealFileAttributes;

    if(bUnicode)
    {
        dwRealFileAttributes = GetFileAttributesW((LPWSTR)pszFile);
    }
    else
    {
        dwRealFileAttributes = GetFileAttributes(pszFile);
    }

    if((-1 != dwRealFileAttributes) &&
       (FILE_ATTRIBUTE_READONLY == (dwRealFileAttributes & FILE_ATTRIBUTE_READONLY)))
    {
        DWORD dwRes = 0;

        if(bUnicode)
        {
            dwRes = SetFileAttributesW((LPWSTR)pszFile,
                                       FILE_ATTRIBUTE_NORMAL);
        }
        else
        {
            dwRes = SetFileAttributes(pszFile,
                                      FILE_ATTRIBUTE_NORMAL);
        }

        if(dwRes)
        {
            LogEvent(g_pEventLog,
                     MD_WARNING_RESETTING_READ_ONLY_ATTRIB,
                     EVENTLOG_WARNING_TYPE,
                     ID_CAT_CAT,
                     S_OK);
        }
        else
        {
            HRESULT hr;
            DWORD dwError;

            dwError = GetLastError();
            hr = RETURNCODETOHRESULT(dwError);
            DBGINFOW((DBG_CONTEXT,
                      L"[ResetFileAttributesIfNeeded] Unable to reset metabase file attributes. SetFileAttributes failed with hr=0x%x", hr));
        }
    }

} // ResetFileAttributesIfNeeded


//
// The following two functions LockMetabaseFiles and UnlockMetabaseFiles are used to
// write lock the metabase files when edit while running is disabled and unlock it
// when edit while running is enabled. This change was necessary for full volume
// restore to work. Backup vendors have been told that they need not change their
// scripts for the whistler release. Eg: When they do a full volume restore,
// they will overwrite metabase.xml and a competing save can overwrite the
// metabase.xml that has just been restored, thus invalidating the restore.
// Vendors have been told that if a file is in use, they must use MoveFileEx with
// the delay until reboot option. Hence by write locking the file, their copy will
// fail and they will be forced to use MoveFileEx with the delay until reboot option
// for the metabase files. Once that happens we're safe because on a reboot we will
// read from their new files.
//
// Note1: We are going to document that full volume restore is not going to work when
// edit while running is enabled. This is because we do not lock the file. Also note
// that when they transition from edit while running enabled/disable state and vice
// versa, they must always force a flush (SaveAllData) for any of these changes,
// because we look at the enabled/disable value only in SaveAllData
//
// Note2: There is a window where the file will not be write locked. For Eg: When
// we rename metabase.xml.tmp to metabase.xml, we have to unlock the metabase.xml,
// rename it to metabase.xml and relock metabase,xml. Similarly when invoking compile,
// we will have to unlock mbschema.xml invoke compile (that will regenerate mbschema.xml)
// and relock mbschema.xml. But these windows are very small.
//
// Note3: The g_ahMetabaseFile is protected by the read/sve semaphore.
//

HRESULT LockMetabaseFile(LPWSTR             pwszMetabaseFile,
                         eMetabaseFile      eMetabaseFileType,
                         BOOL               bHaveReadSaveSemaphore)
{
    HRESULT hr = S_OK;

    if (!bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    MD_ASSERT(INVALID_HANDLE_VALUE == g_ahMetabaseFile[eMetabaseFileType]);

    g_ahMetabaseFile[eMetabaseFileType] = CreateFileW(pwszMetabaseFile,
                                                      GENERIC_READ,
                                                      FILE_SHARE_READ,
                                                      NULL,
                                                      OPEN_EXISTING,
                                                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                      NULL);

    if(INVALID_HANDLE_VALUE == g_ahMetabaseFile[eMetabaseFileType])
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
    }

    if (!bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    return hr;

}


HRESULT UnlockMetabaseFile(eMetabaseFile      eMetabaseFileType,
                           BOOL               bHaveReadSaveSemaphore)
{
    HRESULT hr = S_OK;

    if(INVALID_HANDLE_VALUE != g_ahMetabaseFile[eMetabaseFileType])
    {
        if (!bHaveReadSaveSemaphore)
        {
            MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
        }

        if(!CloseHandle(g_ahMetabaseFile[eMetabaseFileType]))
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
        }

        g_ahMetabaseFile[eMetabaseFileType] = INVALID_HANDLE_VALUE;

        if (!bHaveReadSaveSemaphore)
        {
            MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
        }

    }

    return hr;
}

/*
    This is a wrapper function that logs the appropriate event

  //-----------------Columns as Struct---------------
struct tDETAILEDERRORSRow {
         ULONG *     pErrorID;
         WCHAR *     pDescription;
         WCHAR *     pDate;
         WCHAR *     pTime;
         WCHAR *     pSourceModuleName;
         WCHAR *     pMessageString;
         WCHAR *     pCategoryString;
         WCHAR *     pSource;
         ULONG *     pType;
         ULONG *     pCategory;
         WCHAR *     pUser;
         WCHAR *     pComputer;
 unsigned char *     pData;
         ULONG *     pEvent;
         WCHAR *     pString1;
         WCHAR *     pString2;
         WCHAR *     pString3;
         WCHAR *     pString4;
         WCHAR *     pString5;
         ULONG *     pErrorCode;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorSource;
         ULONG *     pOperationType;
         WCHAR *     pTable;
         WCHAR *     pConfigurationSource;
         ULONG *     pRow;
         ULONG *     pColumn;
         ULONG *     pMajorVersion;
         ULONG *     pMinorVersion;
};


*/
HRESULT LogEvent(ICatalogErrorLogger2*  pLogger,
                 DWORD                  dwError,
                 DWORD                  dwErrorType,
                 DWORD                  dwErrorCategory,
                 DWORD                  dwHr,
                 WCHAR*                 pString1, /* Default = NULL */
                 WCHAR*                 pString2, /* Default = NULL */
                 WCHAR*                 pString3, /* Default = NULL */
                 WCHAR*                 pString4, /* Default = NULL */
                 WCHAR*                 pString5) /* Default = NULL */
{
        static LPCWSTR wszSource = L"IIS Config";
        struct tDETAILEDERRORSRow sErr;
        memset(&sErr, 0, sizeof(struct tDETAILEDERRORSRow ));

        sErr.pSource    = (WCHAR*)wszSource;
        sErr.pType      = &dwErrorType;
        sErr.pCategory  = &dwErrorCategory;
        sErr.pEvent     = &dwError;
        sErr.pErrorCode = &dwHr;
        sErr.pString1   = pString1;
        sErr.pString2   = pString2;
        sErr.pString3   = pString3;
        sErr.pString4   = pString4;
        sErr.pString5   = pString5;

        return pLogger->ReportError(BaseVersion_DETAILEDERRORS,
                                    ExtendedVersion_DETAILEDERRORS,
                                    cDETAILEDERRORS_NumberOfColumns,
                                    NULL,
                                    (LPVOID*)&sErr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\saveschema.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    SaveSchema.cpp

Abstract:

    Implementation of the helper functions that are used to determine
    if a schema compilation is needed, and if needed they invoke the
    appropriate classes to create a schema extensions file
    (MD_SCHEMA_EXTENSION_FILE_NAMEW), that contains the schema extension
    descriptions, and invoke a schema compile to generate the schema bin format.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/
#include "precomp.hxx"


#define cMaxContainedClass 75
#define cMaxProperty       250

int _cdecl MyCompareStrings(const void *a,
                            const void *b)
{
    return _wcsicmp(*(LPWSTR*)a, *(LPWSTR*)b);
}


/***************************************************************************++

Routine Description:

    Helper function used by qsort. Compares to strings, but compares it only
    up until the first comma.


--***************************************************************************/
int _cdecl MyCompareCommaDelimitedStrings(const void *a,
                                          const void *b)
{
    LPWSTR wszStringAStart = ((DELIMITEDSTRING*)a)->pwszStringStart;
    LPWSTR wszStringBStart = ((DELIMITEDSTRING*)b)->pwszStringStart;
    LPWSTR wszStringAEnd   = ((DELIMITEDSTRING*)a)->pwszStringEnd;
    LPWSTR wszStringBEnd   = ((DELIMITEDSTRING*)b)->pwszStringEnd;
    int    iret            = 0;
    SIZE_T cchA            = wszStringAEnd - wszStringAStart;
    SIZE_T cchB            = wszStringBEnd - wszStringBStart;

    //
    // Do not attempt to null terminate the string because you may be
    // hitting a read-only page.
    //

    iret = _wcsnicmp(wszStringAStart, wszStringBStart, __min(cchA, cchB));

    if((0    == iret) &&
       (cchA != cchB)
      )
    {
        iret = cchA < cchB ? -1 : 1;
    }

    return iret;
}


/***************************************************************************++

Routine Description:

    Gets the global helper object that has the pointer to the meta tables.

Arguments:

    [in]  Bool that indicates whether to fail or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT InitializeGlobalISTHelper(BOOL  i_bFailIfBinFileAbsent)
{
    return ::GetGlobalHelper(i_bFailIfBinFileAbsent,
                             &g_pGlobalISTHelper);
}

void ReleaseGlobalISTHelper()
{
    if(NULL != g_pGlobalISTHelper)
    {
        delete g_pGlobalISTHelper;
        g_pGlobalISTHelper = NULL;
    }
}


/***************************************************************************++

Routine Description:

    This function saves the schema only if something has changed in the schema
    since the last save.

Arguments:

    [in]  Schema file name.
    [in]  Security attributes for the file.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveSchemaIfNeeded(LPCWSTR              i_wszSchemaFileName,
                           PSECURITY_ATTRIBUTES i_pSecurityAtrributes)
{
    HRESULT hr = S_OK;

    if(NULL == g_pGlobalISTHelper)
    {
        //
        // g_pGlobalISTHelper will not be initialized if
        // ReadAllDataFromXML is not called. This can happen
        // during an upgrade scneario i.e IIS5.0/5.1 to IIS6.0
        // We attempt to initialize it here. Note that we do
        // not fail if bin file is absent - just go with
        // the shipped schema.
        //

        BOOL bFailIfBinFileAbsent = FALSE;

        hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

    }

    if(g_dwSchemaChangeNumber != g_dwLastSchemaChangeNumber)
    {

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchemaIfNeeded] Calling SaveSchema. Last save schema change number: %d. Current schema change number: %d.\n",
                  g_dwLastSchemaChangeNumber,
                  g_dwSchemaChangeNumber));

        hr = SaveSchema(i_wszSchemaFileName,
                        i_pSecurityAtrributes);


        if(SUCCEEDED(hr))
        {
            g_dwLastSchemaChangeNumber = g_dwSchemaChangeNumber;

            //
            // SaveSchema will reinitialize the GlobalISTHelper if the schema has changed.
            //

            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchemaIfNeeded] Done Saving schema. Updating last save schema change number to: %d. Current schema change number: %d.\n",
                      g_dwLastSchemaChangeNumber,
                      g_dwSchemaChangeNumber));

        }
    }
    else
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchemaIfNeeded] No need saving schema because schema has not changed since last save. Last save schema change number: %d. Current schema change number: %d.\n",
                  g_dwLastSchemaChangeNumber,
                  g_dwSchemaChangeNumber));
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    This function saves the schema and compiles schema information into the
    bin file.

Arguments:

    [in]  Schema file name.
    [in]  Security attributes for the file.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveSchema(LPCWSTR              i_wszSchemaFileName,
                   PSECURITY_ATTRIBUTES i_pSecurityAtrributes)
{
    HRESULT                     hr;
    CMDBaseObject*              pObjSchema         = NULL;
    CMDBaseObject*              pObjProperties     = NULL;
    CWriter*                    pCWriter           = NULL;
    CMBSchemaWriter*            pSchemaWriter      = NULL;
    LPWSTR                      wszSchema          = L"Schema";
    LPWSTR                      wszProperties      = L"Properties";
    ISimpleTableDispenser2*     pISTDisp           = NULL;
    IMetabaseSchemaCompiler*    pCompiler          = NULL;

    //
    // Get a pointer to the compiler to get the bin file name.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
                                  (LPVOID*)&pCompiler);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
        goto exit;
    }


    //
    // Get the Properties object
    //

    pObjSchema = g_pboMasterRoot->GetChildObject((LPSTR&)wszSchema,
                                                 &hr,
                                                 TRUE);

    if(FAILED(hr) || (NULL == pObjSchema))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] Unable to open /Schema. GetChildObject failed with hr = 0x%x.\n",hr));

        goto exit;
    }

    pObjProperties = pObjSchema->GetChildObject((LPSTR&)wszProperties,
                                                &hr,
                                                TRUE);

    if(FAILED(hr) || (NULL == pObjProperties))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] Unable to open /Schema/Properties. GetChildObject failed with hr = 0x%x.\n",hr));

        goto exit;
    }

    //
    // Create the writer object
    //

    DBGINFOW((DBG_CONTEXT,
              L"[SaveSchema] Initializing writer with write file: %s bin file: %s.\n",
              g_wszSchemaExtensionFile,
              g_pGlobalISTHelper->m_wszBinFileForMeta));

    //
    // Assert the g_GlobalISTHelper are valid
    //

    MD_ASSERT(g_pGlobalISTHelper != NULL);

    pCWriter = new CWriter();
    if(NULL == pCWriter)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        //
        // Bug #512868  If someone had attrib-ed an existing extenstion file
        // be read-only then we could land up in a state where we will not be
        // able to recreate the extensions file. Hence attrib the extensions
        // file to be read-write if it exists. An extensions file can be
        // around only if a previous compile has failed.
        //

        ResetFileAttributesIfNeeded((LPTSTR)g_wszSchemaExtensionFile,
                                    TRUE);

        hr = pCWriter->Initialize(g_wszSchemaExtensionFile,
                                  g_pGlobalISTHelper,
                                  NULL);
    }

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] Error while saving schema tree. Cannot initialize writer. Failed with hr = 0x%x.\n", hr));
        goto exit;
    }

    //
    // First create the IIsConfigObject collection
    //

    hr = CreateIISConfigObjectCollection(pObjProperties,
                                         pCWriter,
                                         &pSchemaWriter);


    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Create all other collections
    //

    hr = CreateNonIISConfigObjectCollections(pObjSchema,
                                             pCWriter,
                                             &pSchemaWriter);

    if(FAILED(hr))
    {
        goto exit;
    }

    if(pSchemaWriter)
    {
        //
        // If pSchemaWriter has a valid Value, then some extensions were found - write it.
        //

        hr = pCWriter->BeginWrite(eWriter_Schema,
                                  i_pSecurityAtrributes);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] Error while saving schema tree. CWriter::BeginWrite failed with hr = 0x%x.\n", hr));
            goto exit;
        }

        hr = pSchemaWriter->WriteSchema();

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] Error while saving schema tree. CMBSchemaWriter::WriteSchema. Failed with hr = 0x%x.\n", hr));
            goto exit;

        }

        hr = pCWriter->EndWrite(eWriter_Schema);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] Error while saving schema tree. CWriter::EndWrite Failed with hr = 0x%x.\n", hr));
            goto exit;
        }

        //
        // Trigger compilation
        //

        //
        // Must close the file prior to calling compile schema, else will get a sharing violation.
        //

        delete pCWriter;
        pCWriter = NULL;

        hr = CompileIntoBin(pCompiler,
                            g_wszSchemaExtensionFile,
                            i_wszSchemaFileName);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] CompileSchema from %s failed with hr = 0x%x.\n",
                      g_wszSchemaExtensionFile, hr));
        }
        else
        {
            if(!DeleteFileW(g_wszSchemaExtensionFile))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] Compile from schema extensions file: %s succeeded, but cannot cleanup the extensions file:%s. Delete file failed with hr = 0x%x.\n",
                          g_wszSchemaExtensionFile,
                          g_wszSchemaExtensionFile,
                          hr));

                hr = S_OK;
            }

            goto exit;
        }

    }
    else
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] No extensions found. - Either schema tree was changed, but no extensions added, or all extensions were deleted.\n"));
    }

    //
    // If you reach here it means that:
    // A. Schema changes occured to the in-memory /Schema tree, but either
    //    there were no extensions or all extensions were deleted.
    //    (This is inferred when pSchemaWriter in NULL)
    // or
    // B. Schema compile failed.
    // For A: Compile from shipped schema.
    // For B: Check for an existing schema file. If found make sure that the
    // bin file is valid. If bin file is not valid try compiling from the
    // schema file. If schema file is not found, compile from shipped schema.
    //

    if(pSchemaWriter)
    {
        //
        // This is case B.
        //

        if(-1 != GetFileAttributesW(i_wszSchemaFileName))
        {
            if(NULL == g_pGlobalISTHelper)
            {
                BOOL bFailIfBinFileAbsent = TRUE;

                hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

                if(SUCCEEDED(hr))
                {
                    goto exit;
                }
                else
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[SaveSchema] Unable to get the the bin file name. (Assuming file missing or invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
                }
            }
            else
            {
                //
                // Schema file present and valid - goto exit
                // As long as we have a valid g_pGlobalISTHelper, it holds on
                // to a reference to the bin file and the bin file cannot be
                // invalidated.
                //

                goto exit;
            }

            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] Compiling from schema file %s\n", i_wszSchemaFileName));


            hr = CompileIntoBinFromSchemaFile(pCompiler,
                                              i_wszSchemaFileName);

            if(SUCCEEDED(hr))
            {
                goto exit;
            }
        }
    }

    //
    // If you reach here it is either case A or the last part of case B.
    // Recreate from shipped schema
    //

    DBGINFOW((DBG_CONTEXT,
              L"[SaveSchema] Schema file not found. Compiling from shipped schema\n"));

    hr = CompileIntoBin(pCompiler,
                        NULL,
                        i_wszSchemaFileName);

exit:

    if(SUCCEEDED(hr))
    {
        if(NULL == g_pGlobalISTHelper)
        {
            BOOL bFailIfBinFileAbsent = TRUE;

            hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Unable to get the the bin file name. (Assuming file is invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = UpdateTimeStamp((LPWSTR)i_wszSchemaFileName,
                                 g_pGlobalISTHelper->m_wszBinFileForMeta);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] UpdateTimeStamp failed with hr = 0x%x.\n",hr));
            }

        }

    }

    if(NULL != pSchemaWriter)
    {
        delete pSchemaWriter;
    }

    if(NULL != pCWriter)
    {
        delete pCWriter;
    }

    if(NULL != pCompiler)
    {
        pCompiler->Release();
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    This function creates the non-IIsConfigObject collection *extensions* to
    the schema.

Arguments:

    [in]     Object that contains the schema tree.
    [in]     The writter object.
    [in,out] The schema object - this gets created if it is not already created

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CreateNonIISConfigObjectCollections(CMDBaseObject*      i_pObjSchema,
                                            CWriter*            i_pCWriter,
                                            CMBSchemaWriter**   io_pSchemaWriter)
{
    CMDBaseObject*       pObjClasses        = NULL;
    CMDBaseObject*       pObjClass          = NULL;
    DWORD                dwEnumClassIndex   = 0;
    static LPCWSTR       wszSeparator       = L",";
    LPWSTR               wszClasses         = L"Classes";
    HRESULT              hr                 = S_OK;

    //
    // Open the Classes key
    //

    pObjClasses = i_pObjSchema->GetChildObject((LPSTR&)wszClasses,
                                             &hr,
                                             TRUE);

    if(FAILED(hr) || (NULL == pObjClasses))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] Unable to open /Schema/Classes. GetChildObject failed with hr = 0x%x.\n",hr));

        return hr;
    }


    for(dwEnumClassIndex=0,
        pObjClass=pObjClasses->EnumChildObject(dwEnumClassIndex++);
        (SUCCEEDED(hr)) && (pObjClass!=NULL);
        pObjClass=pObjClasses->EnumChildObject(dwEnumClassIndex++))
    {
        //
        // Save all the properties for this class in temp variables
        //

        LPCWSTR                 wszOptProp             = NULL;
        LPCWSTR                 wszMandProp            = NULL;
        LPCWSTR                 wszContainedClassList  = NULL;
        BOOL                    bContainer             = FALSE;
        BOOL*                   pbContainer            = &bContainer;
        LPCWSTR                 wszClassName           = (LPCWSTR)pObjClass->GetName(TRUE);
        CMBCollectionWriter*    pCollectionWriter      = NULL;
        CMDBaseData*            pObjData               = NULL;
        DWORD                   dwEnumIndex            = 0;

        for(dwEnumIndex=0,
            pObjData=pObjClass->EnumDataObject(dwEnumIndex++,
                                               0,
                                               ALL_METADATA,
                                               ALL_METADATA);
            (SUCCEEDED(hr)) && (pObjData!=NULL);
            pObjData=pObjClass->EnumDataObject(dwEnumIndex++,
                                               0,
                                               ALL_METADATA,
                                               ALL_METADATA))
        {
            DWORD dwID = pObjData->GetIdentifier();

            if(MD_SCHEMA_CLASS_OPT_PROPERTIES == dwID)
            {
                wszOptProp = (LPCWSTR)pObjData->GetData(TRUE);
            }
            else if(MD_SCHEMA_CLASS_MAND_PROPERTIES == dwID)
            {
                wszMandProp = (LPCWSTR)pObjData->GetData(TRUE);
            }
            else if(dwID == MD_SCHEMA_CLASS_CONTAINER)
            {
                pbContainer = (BOOL*)pObjData->GetData(TRUE);
            }
            else if(dwID == MD_SCHEMA_CLASS_CONTAINMENT)
            {
                wszContainedClassList = (LPCWSTR)pObjData->GetData(TRUE);
            }

        }


        //
        // Get collection writer for IIsConfigObject
        //

//      DBGINFOW((DBG_CONTEXT,
//                L"[CreateNonIISConfigObjectCollections] Class %s Mand Prop:%s. Opt Prop: %s\n",
//                wszClassName,
//                wszMandProp,
//                wszOptProp));

        // Assert that pbContainer is non-null.
        MD_ASSERT(pbContainer != NULL);

        if(ClassDiffersFromShippedSchema(wszClassName,
                                         *pbContainer,
                                         (LPWSTR)wszContainedClassList) ||
           ClassPropertiesDifferFromShippedSchema(wszClassName,
                                                  (LPWSTR)wszOptProp,
                                                  (LPWSTR)wszMandProp)
           )
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] Saving collection: %s.\n",wszClassName));

            hr = GetCollectionWriter(i_pCWriter,
                                     io_pSchemaWriter,
                                     &pCollectionWriter,
                                     wszClassName,
                                     *pbContainer,
                                     wszContainedClassList);
            if(FAILED(hr))
            {
                return hr;
            }

            hr = ParseAndAddPropertiesToNonIISConfigObjectCollection(wszOptProp,
                                                                     FALSE,
                                                                     pCollectionWriter);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving classes tree. Could not add optional properties %s for class %s failed with hr = 0x%x.\n",wszOptProp, wszClassName, hr));
                return hr;
            }

            hr = ParseAndAddPropertiesToNonIISConfigObjectCollection(wszMandProp,
                                                                     TRUE,
                                                                     pCollectionWriter);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving classes tree. Could not add manditory properties %s for class %s failed with hr = 0x%x.\n",wszMandProp, wszClassName, hr));
                return hr;
            }
        }

    }

    return hr;

}


/***************************************************************************++

Routine Description:

    It parses the list of properties and adds it to a Non_IIsConfigObject
    collection.

Arguments:

    [in]     List of properties
    [in]     Bool that indicates manditory or optional.
    [in,out] The collection object - this gets created if it is not already created

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
ParseAndAddPropertiesToNonIISConfigObjectCollection(LPCWSTR                 i_wszProperties,
                                                    BOOL                    i_bManditory,
                                                    CMBCollectionWriter*    i_pCollectionWriter)
{
    CMBPropertyWriter   *pProperty        = NULL;
    HRESULT             hr                = S_OK;
    static WCHAR        wchSeparator      = L',';
    WCHAR*              pwszStartProperty = NULL;
    WCHAR*              pwszEndProperty   = NULL;

    if(NULL == i_wszProperties || 0 == *i_wszProperties)
    {
        return S_OK;
    }

    pwszStartProperty = (LPWSTR)i_wszProperties;

    for ( ; ; )
    {
        pwszEndProperty = wcschr(pwszStartProperty, wchSeparator);

        if(0 != *pwszStartProperty)
        {
            hr = i_pCollectionWriter->GetMBPropertyWriter(pwszStartProperty,
                                                          i_bManditory,
                                                          &pProperty);

            if(FAILED(hr))
            {
                return hr;
            }
        }

        if(NULL != pwszEndProperty)
        {
            pwszStartProperty = ++pwszEndProperty;
        }
        else
        {
            break;
        }

    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Looks up the schema and determines if a property is in the shipped
    schema or not.

Arguments:

    [in]     Writer object.
    [in]     property id.

Return Value:

    HRESULT

--***************************************************************************/
BOOL PropertyNotInShippedSchema(CWriter*  i_pCWriter,
                                DWORD     i_dwIdentifier)
{

    HRESULT hr                          = S_OK;
    ULONG   aColSearch[]                = {iCOLUMNMETA_Table,
                                           iCOLUMNMETA_ID
                                        };
    ULONG   cColSearch                  = sizeof(aColSearch)/sizeof(ULONG);
    LPVOID apvSearch[cCOLUMNMETA_NumberOfColumns];
    apvSearch[iCOLUMNMETA_Table]        = (LPVOID)i_pCWriter->m_pCWriterGlobalHelper->m_wszTABLE_IIsConfigObject;
    apvSearch[iCOLUMNMETA_ID]           = (LPVOID)&i_dwIdentifier;
    BOOL    bPropertyNotInShippedSchema = TRUE;
    ULONG   iRow                        = 0;
    ULONG   iStartRow                   = 0;
    ULONG   iCol                        = iCOLUMNMETA_SchemaGeneratorFlags;
    DWORD*  pdwMetaFlagsEx              = NULL;


    hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow,
                                                                                               cColSearch,
                                                                                               aColSearch,
                                                                                               NULL,
                                                                                               apvSearch,
                                                                                               &iRow);

    if(SUCCEEDED(hr))
    {

        hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
                                                                                               1,
                                                                                               &iCol,
                                                                                               NULL,
                                                                                               (LPVOID*)&pdwMetaFlagsEx);

        if(SUCCEEDED(hr) && (((*pdwMetaFlagsEx)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
        {
            bPropertyNotInShippedSchema = FALSE;
        }
    }

    if(E_ST_NOMOREROWS == hr)
    {
        //
        // See if property is a shipped tag.
        //

        bPropertyNotInShippedSchema = TagNotInShippedSchema(i_pCWriter,
                                                            i_dwIdentifier);


    }
    else if(FAILED(hr))
    {
        //
        // Trace a message saying internal catalog error
        //

        DBGINFOW((DBG_CONTEXT,
          L"[PropertyNotInShippedSchema] Internal catalog error. Could not determine if property was not in shipped schema. Assuming it is not. hr = 0x%x.\n", hr));

    }

    return bPropertyNotInShippedSchema;

} // PropertyNotInShippedSchema


/***************************************************************************++

Routine Description:

    Looks up the schema and determines if a tag is in the shipped
    schema or not.

Arguments:

    [in]     Writer object.
    [in]     property id.

Return Value:

    HRESULT

--***************************************************************************/
BOOL TagNotInShippedSchema(CWriter* i_pCWriter,
                           DWORD    i_dwIdentifier)
{

    HRESULT     hr                                  = S_OK;
    ULONG       aColSearch[]                        = {iTAGMETA_Table,
                                                       iTAGMETA_ID
                                                        };
    ULONG       cColSearch                          = sizeof(aColSearch)/sizeof(ULONG);
    LPVOID      apvSearch[cCOLUMNMETA_NumberOfColumns];
    BOOL        bTagNotInShippedSchema              = TRUE;
    ULONG       iStartRow                           = 0;
    ULONG       iColIndex                           = iTAGMETA_ColumnIndex;
    DWORD*      pdwColIndex                         = NULL;

    apvSearch[iTAGMETA_Table]                       = (LPVOID)g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject;
    apvSearch[iTAGMETA_ID]                          = (LPVOID)&i_dwIdentifier;



    hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndID->GetRowIndexBySearch(iStartRow,
                                                                                            cColSearch,
                                                                                            aColSearch,
                                                                                            NULL,
                                                                                            apvSearch,
                                                                                            &iStartRow);

    if(SUCCEEDED(hr))
    {

        hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndID->GetColumnValues(iStartRow,
                                                                                            1,
                                                                                            &iColIndex,
                                                                                            NULL,
                                                                                            (LPVOID*)&pdwColIndex);
        if(SUCCEEDED(hr))
        {
            //
            // Lookup the property to see if it is shipped.
            //

            LPVOID  a_Identity[] = {(LPVOID)g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject,
                                    (LPVOID)pdwColIndex
            };
            ULONG   iRow=0;


            hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
                                                                             a_Identity,
                                                                             &iRow);

            if(SUCCEEDED(hr))
            {
                DWORD* pdwExtended = NULL;
                ULONG  iColPropertyMetaFlagsEx = iCOLUMNMETA_SchemaGeneratorFlags;

                hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(iRow,
                                                                           1,
                                                                           &iColPropertyMetaFlagsEx,
                                                                           NULL,
                                                                           (LPVOID*)&pdwExtended);

                if(SUCCEEDED(hr) && (((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
                {
                    //
                    // Found at least one property that is not in the shipped schema
                    //
                    bTagNotInShippedSchema = FALSE;
                }

                //
                // Else condition means it failed or it was a shipped property
                // if(FAILED(hr) || ( (((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) != 0))
                //

            }

        }

    } // If GetRowIndexBySearch succeeds

    return bTagNotInShippedSchema;

} // TagNotInShippedSchema


/***************************************************************************++

Routine Description:

    Looks up the schema and determines if a class has any extensions or if it
    an extended (ie new) class.

Arguments:

    [in]     Class name
    [in]     Container class or not.
    [in]     Container class list.

Return Value:

    HRESULT

--***************************************************************************/
BOOL ClassDiffersFromShippedSchema(LPCWSTR i_wszClassName,
                                   BOOL    i_bIsContainer,
                                   LPWSTR  i_wszContainedClassList)
{
    HRESULT                     hr                               = S_OK;
    BOOL                        bClassDiffersFromShippedSchema   = TRUE;
    ULONG                       aiCol []                         = {iTABLEMETA_SchemaGeneratorFlags,
                                                                    iTABLEMETA_ContainerClassList
                                                                    };
    ULONG                       cCol                             = sizeof(aiCol)/sizeof(ULONG);
    LPVOID                      apv[cTABLEMETA_NumberOfColumns];
    ULONG                       iRow                             = 0;

    hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetRowIndexByIdentity(NULL,
                                                                                     (LPVOID*)&i_wszClassName,
                                                                                     &iRow);

    if(SUCCEEDED(hr))
    {

        hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetColumnValues(iRow,
                                                                                   cCol,
                                                                                   aiCol,
                                                                                   NULL,
                                                                                   apv);

        if(SUCCEEDED(hr))
        {
            if(((*(DWORD*)apv[iTABLEMETA_SchemaGeneratorFlags]) & (fTABLEMETA_EXTENDED|fTABLEMETA_USERDEFINED)) == 0)
            {
                if(MatchClass(i_bIsContainer,
                              i_wszContainedClassList,
                              apv)
                  )
                {
                    bClassDiffersFromShippedSchema = FALSE;
                }
            }
        }
        else
        {
            //
            // Trace a message saying internal catalog error
            //

            DBGINFOW((DBG_CONTEXT,
              L"[ClassDiffersFromShippedSchema] Internal catalog error. Could not determine if class was not in shipped schema. Assuming it is not. hr = 0x%x.\n", hr));

        }
    }
    else if(E_ST_NOMOREROWS != hr)
    {
        //
        // Trace a message saying internal catalog error
        //

        DBGINFOW((DBG_CONTEXT,
          L"[ClassDiffersFromShippedSchema] Internal catalog error. Could not determine if class was not in shipped schema. Assuming it is not. hr = 0x%x.\n", hr));
    }

    return bClassDiffersFromShippedSchema;

} // ClassDiffersFromShippedSchema


/***************************************************************************++

Routine Description:

    Looks up the schema and matches a class.

Arguments:

    [in]     Container class or not.
    [in]     Container class list.
    [in]     Class attributes.

Return Value:

    HRESULT

--***************************************************************************/
BOOL MatchClass(BOOL      i_bIsContainer,
                LPWSTR    i_wszContainedClassList,
                LPVOID*   i_apv)
{
    BOOL     bMatch = TRUE;
    DWORD    fIsContained = (*(DWORD*)i_apv[iTABLEMETA_SchemaGeneratorFlags]) & fTABLEMETA_CONTAINERCLASS;

    //
    // Compare the container property 1st and only if they equal compare the container class list
    //

    if( i_bIsContainer &&
        (fIsContained != fTABLEMETA_CONTAINERCLASS)
      )
    {
        bMatch = FALSE;
    }
    else if (!i_bIsContainer &&
             (fIsContained == fTABLEMETA_CONTAINERCLASS)
            )
    {
        bMatch = FALSE;
    }
    else
    {
        bMatch = MatchCommaDelimitedStrings(i_wszContainedClassList,
                                            (LPWSTR)i_apv[iTABLEMETA_ContainerClassList]);
    }

    return bMatch;

} // MatchClass


/***************************************************************************++

Routine Description:

    Checks to see if two comma delimited strings match.

Arguments:

    [in]     Comma delimited string.
    [in]     Comma delimited string.

Return Value:

    HRESULT

--***************************************************************************/
BOOL MatchCommaDelimitedStrings(LPWSTR  i_wszString1,
                                LPWSTR  i_wszString2)
{
    BOOL    bMatch = FALSE;

    DELIMITEDSTRING aStringFixed1[cMaxContainedClass];
    DELIMITEDSTRING aStringFixed2[cMaxContainedClass];
    DELIMITEDSTRING*    aString1    = aStringFixed1;
    DELIMITEDSTRING*    aString2    = aStringFixed2;
    ULONG               cString1    = cMaxContainedClass;
    ULONG               cString2    = cMaxContainedClass;
    ULONG               iString1    = 0;
    ULONG               iString2    = 0;
    BOOL                bReAlloced1 = FALSE;
    BOOL                bReAlloced2 = FALSE;
    HRESULT             hr          = S_OK;

    if(NULL == i_wszString1 || 0 == *i_wszString1)
    {
        if(NULL == i_wszString2 || 0 == *i_wszString2)
        {
            bMatch = TRUE;
        }
    }
    else if(NULL == i_wszString2 || 0 == *i_wszString2)
    {
        bMatch = FALSE;         // Means i_wszString1 != NULL and i_wszString2 == NULL
    }
    else if(wcscmp(i_wszString1, i_wszString2) == 0)
    {
        bMatch = TRUE;
    }
    else
    {
        //
        // Construct an array of individual strings
        // and compare the array
        //

        hr = CommaDelimitedStringToArray(i_wszString1,
                                         &aString1,
                                         &iString1,
                                         &cString1,
                                         &bReAlloced1);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = CommaDelimitedStringToArray(i_wszString2,
                                         &aString2,
                                         &iString2,
                                         &cString2,
                                         &bReAlloced2);

        if(FAILED(hr))
        {
            goto exit;
        }

        bMatch = MatchDelimitedStringArray(aString1,
                                           iString1,
                                           aString2,
                                           iString2);

    }

exit:

    if(aString1 != aStringFixed1)
    {
        delete [] aString1;
    }

    if(aString2 != aStringFixed2)
    {
        delete [] aString2;
    }

    return bMatch;

} // MatchCommaDelimitedStrings


/***************************************************************************++

Routine Description:

    Converts a comma delimited string to an array.

Arguments:

    [in]         Comma delimited string.
    [in,out]     Array.
    [in,out]     Current index in the array.
    [in,out]     Max count of the array. (i.e. max it can hold)
    [in,out]     Bool which indecates if the array has been realloced.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CommaDelimitedStringToArray(LPWSTR              i_wszString,
                                    DELIMITEDSTRING**   io_apDelimitedString,
                                    ULONG*              io_piDelimitedString,
                                    ULONG*              io_pcMaxDelimitedString,
                                    BOOL*               io_pbReAlloced)
{
    LPWSTR  wszSubStringStart = NULL;
    LPWSTR  wszSubStringEnd   = NULL;
    HRESULT hr                = S_OK;

    wszSubStringStart = i_wszString;

    while(NULL != wszSubStringStart)
    {
        DELIMITEDSTRING DelimitedString;

        wszSubStringEnd = wcschr(wszSubStringStart, L',');

        DelimitedString.pwszStringStart = wszSubStringStart;

        if(NULL != wszSubStringEnd)
        {
            DelimitedString.pwszStringEnd = wszSubStringEnd;
        }
        else
        {
            // Point to the terminating NULL.

            DelimitedString.pwszStringEnd = wszSubStringStart + wcslen(wszSubStringStart);
        }

        hr = AddDelimitedStringToArray(&DelimitedString,
                                       io_piDelimitedString,
                                       io_pcMaxDelimitedString,
                                       io_pbReAlloced,
                                       io_apDelimitedString);

        if(FAILED(hr))
        {
            return hr;
        }

        if(wszSubStringEnd != NULL)
        {
            wszSubStringStart = ++wszSubStringEnd;
        }
        else
        {
            wszSubStringStart = wszSubStringEnd;
        }
    }


    return S_OK;

}


/***************************************************************************++

Routine Description:

    Adds the string to the array.

Arguments:

    [in]         String to add.
    [in,out]     Current index in the array.
    [in,out]     Max count of the array. (i.e. max it can hold)
    [in,out]     Bool which indecates if the array has been realloced.
    [in,out]     Array.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT AddDelimitedStringToArray(DELIMITEDSTRING*     i_pDelimitedString,
                                  ULONG*               io_piDelimitedString,
                                  ULONG*               io_pcMaxDelimitedString,
                                  BOOL*                io_pbReAlloced,
                                  DELIMITEDSTRING**    io_apDelimitedString)
{
    HRESULT hr = S_OK;

    if(*io_piDelimitedString >= *io_pcMaxDelimitedString)
    {
        hr = ReAllocate(*io_piDelimitedString,
                        *io_pbReAlloced,
                        io_apDelimitedString,
                        io_pcMaxDelimitedString);

        if(FAILED(hr))
        {
            return hr;
        }

        *io_pbReAlloced = TRUE;
    }

    (*io_apDelimitedString)[(*io_piDelimitedString)++] = (*i_pDelimitedString);

    return hr;

}

HRESULT ReAllocate(ULONG              i_iDelimitedString,
                   BOOL               i_bReAlloced,
                   DELIMITEDSTRING**  io_apDelimitedString,
                   ULONG*             io_pcDelimitedString)
{
    DELIMITEDSTRING*    pSav = NULL;

    pSav = new DELIMITEDSTRING[*io_pcDelimitedString + cMaxContainedClass];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    *io_pcDelimitedString = *io_pcDelimitedString + cMaxContainedClass;
    memset(pSav, 0, sizeof(DELIMITEDSTRING)*(*io_pcDelimitedString));

    if(NULL != *io_apDelimitedString)
    {
        memcpy(pSav, *io_apDelimitedString, sizeof(DELIMITEDSTRING)*i_iDelimitedString);
        if(i_bReAlloced)
        {
            delete [] *io_apDelimitedString;
            *io_apDelimitedString = NULL;
        }
    }

    *io_apDelimitedString = pSav;

    return S_OK;
}


/***************************************************************************++

Routine Description:

    Compares two string arrays.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/
BOOL MatchDelimitedStringArray(DELIMITEDSTRING* i_aString1,
                               ULONG            i_cString1,
                               DELIMITEDSTRING* i_aString2,
                               ULONG            i_cString2)
{
    DBG_ASSERT((i_cString1 > 0) && (i_cString2 >0));

    if(i_cString1 != i_cString2)
    {
        return FALSE;
    }

    qsort((void*)i_aString1, i_cString1, sizeof(DELIMITEDSTRING), MyCompareCommaDelimitedStrings);
    qsort((void*)i_aString2, i_cString2, sizeof(DELIMITEDSTRING), MyCompareCommaDelimitedStrings);

    for(ULONG i=0; i<i_cString1; i++)
    {
        if(0 != MyCompareCommaDelimitedStrings(&(i_aString1[i]),
                                               &(i_aString2[i]))
          )
        {
            return FALSE;
        }
    }

    return TRUE;

}


/***************************************************************************++

Routine Description:

    Looks at the optinal and manditory properties of a class and determines
    if ti differs fromt the shipped schema.

Arguments:

    [in]     Class name.
    [in]     Optional properties.
    [in]     Manditory properties.
    [in]     Writer object.

Return Value:

    HRESULT

--***************************************************************************/
BOOL ClassPropertiesDifferFromShippedSchema(LPCWSTR  i_wszClassName,
                                            LPWSTR   i_wszOptProperties,
                                            LPWSTR   i_wszMandProperties)
{

    BOOL                        bClassPropertiesDifferFromShippedSchema  = FALSE;
    ULONG                       i                                        = 0;
    HRESULT                     hr                                       = S_OK;
    DELIMITEDSTRING             aPropertyFixed[cMaxProperty];
    ULONG                       cProperty                                = cMaxProperty;
    ULONG                       iProperty                                = 0;
    DELIMITEDSTRING*            aProperty                                = aPropertyFixed;
    BOOL                        bReAlloced                               = FALSE;

    if( ((NULL == i_wszOptProperties)  || (0 == *i_wszOptProperties)) &&
        ((NULL == i_wszMandProperties) || (0 == *i_wszMandProperties))
      )
    {
        //
        // It is true that you cannot delete all shipped properties from a shipped class,
        // because every shipped class that we know of has at least one location property.
        // But there may be previously added extension that were deleted, so assume something
        // changed, when there are no properties.
        //
        bClassPropertiesDifferFromShippedSchema = TRUE;
        goto exit;
    }


    //
    // Now create an array of
    // mand + opt properties
    //

    if((NULL != i_wszOptProperties) && (0 != *i_wszOptProperties))
    {

        hr = CommaDelimitedStringToArray(i_wszOptProperties,
                                         &aProperty,
                                         &iProperty,
                                         &cProperty,
                                         &bReAlloced);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    if((NULL != i_wszMandProperties) && (0 != *i_wszMandProperties))
    {
        hr = CommaDelimitedStringToArray(i_wszMandProperties,
                                         &aProperty,
                                         &iProperty,
                                         &cProperty,
                                         &bReAlloced);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    for(i=0; i<iProperty; i++ )
    {
        LPWSTR  wszPropertyName             = aProperty[i].pwszStringStart;
        LPWSTR  wszEnd                      = aProperty[i].pwszStringEnd;
        WCHAR   wchEndSav;
        ULONG   aColSearchProperty[]        = {iCOLUMNMETA_Table,
                                               iCOLUMNMETA_InternalName
                                                };
        ULONG   cColSearchProperty          = sizeof(aColSearchProperty)/sizeof(ULONG);
        LPVOID  apvSearchProperty[cCOLUMNMETA_NumberOfColumns];
        ULONG   iStartRowProperty           = 0;
        ULONG   iColPropertyMetaFlagsEx     = iCOLUMNMETA_SchemaGeneratorFlags;
        DWORD*  pdwExtended                 = NULL;

        //
        // Null terminate the property name and initialize it.
        // Hence on gotos until you reset it.
        //

        wchEndSav = *wszEnd;
        *wszEnd = L'\0';

        apvSearchProperty[iCOLUMNMETA_Table]        = (LPVOID)i_wszClassName;
        apvSearchProperty[iCOLUMNMETA_InternalName] = (LPVOID)wszPropertyName;


        //
        // See if the property is found in the class and see if it is shipped
        //

        hr = g_pGlobalISTHelper->m_pISTColumnMetaByTableAndName->GetRowIndexBySearch(iStartRowProperty,
                                                                                     cColSearchProperty,
                                                                                     aColSearchProperty,
                                                                                     NULL,
                                                                                     apvSearchProperty,
                                                                                     &iStartRowProperty);

        if(SUCCEEDED(hr))
        {
            hr = g_pGlobalISTHelper->m_pISTColumnMetaByTableAndName->GetColumnValues(iStartRowProperty,
                                                                                     1,
                                                                                     &iColPropertyMetaFlagsEx,
                                                                                     NULL,
                                                                                     (LPVOID*)&pdwExtended);

            if(FAILED(hr) || ( ((*pdwExtended) & (fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) != 0))
            {
                //
                // Found at least one property that is not in the shipped schema
                //

                bClassPropertiesDifferFromShippedSchema = TRUE;
            }

            //
            // Else condition means it succeeded and it was a shipped property
            // if(SUCCEEDED(hr) && ( ((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
            //

        }
        else
        {
            //
            // May be its a tag value. Check if it is in the tag meta
            //

            ULONG   aColSearchTag[]        = {iTAGMETA_Table,
                                              iTAGMETA_InternalName
                                             };
            ULONG   cColSearchTag          = sizeof(aColSearchTag)/sizeof(ULONG);
            LPVOID  apvSearchTag[cTAGMETA_NumberOfColumns];
            ULONG   iStartRowTag           = 0;
            ULONG   iColIndex              = iTAGMETA_ColumnIndex;
            DWORD*  pdwColumnIndex         = NULL;

            apvSearchTag[iTAGMETA_Table]        = (LPVOID)i_wszClassName;
            apvSearchTag[iTAGMETA_InternalName] = (LPVOID)wszPropertyName;

            hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndName->GetRowIndexBySearch(iStartRowTag,
                                                                                      cColSearchTag,
                                                                                      aColSearchTag,
                                                                                      NULL,
                                                                                      apvSearchTag,
                                                                                      &iStartRowTag);

            if(FAILED(hr))
            {
                bClassPropertiesDifferFromShippedSchema = TRUE;
            }
            else
            {
                //
                // Check if the parent property of this tag is shipped, if it is not,
                // then this becomes a non-shipped tag
                //

                hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndName->GetColumnValues(iStartRowTag,
                                                                                      1,
                                                                                      &iColIndex,
                                                                                      NULL,
                                                                                      (LPVOID*)&pdwColumnIndex);

                if(SUCCEEDED(hr))
                {
                    LPVOID  a_Identity[] = {(LPVOID)i_wszClassName,
                                            (LPVOID)pdwColumnIndex
                    };
                    ULONG   iRow         = 0;

                    hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
                                                                                     a_Identity,
                                                                                     &iRow);

                    if(SUCCEEDED(hr))
                    {
                        hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(iRow,
                                                                                   1,
                                                                                   &iColPropertyMetaFlagsEx,
                                                                                   NULL,
                                                                                   (LPVOID*)&pdwExtended);

                        if(FAILED(hr) || ( ((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) != 0))
                        {
                            //
                            // Found at least one property that is not in the shipped schema
                            //
                            bClassPropertiesDifferFromShippedSchema = TRUE;
                        }

                        //
                        // Else condition means it succeeded and it was a shipped property
                        // if(SUCCEEDED(hr) && ( ((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
                        //

                    }
                }
                else
                {
                    bClassPropertiesDifferFromShippedSchema = TRUE;
                }

            }

        }

        //
        // Restore the property name
        //

        *wszEnd = wchEndSav;

        if(FAILED(hr) || bClassPropertiesDifferFromShippedSchema)
        {
            goto exit;
        }

    }


exit:

    if(FAILED(hr))
    {
        bClassPropertiesDifferFromShippedSchema = TRUE;
    }

    if(aProperty != aPropertyFixed)
    {
        delete [] aProperty;
    }

    return bClassPropertiesDifferFromShippedSchema;

} // ClassPropertiesDifferFromShippedSchema


/***************************************************************************++

Routine Description:

    Creates the IIsConfigObject collection - This collection has complete
    definitions of all properties.

Arguments:

    [in]         Properties object.
    [in,out]     Writer object.
    [in,out]     Schema Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CreateIISConfigObjectCollection(CMDBaseObject*      i_pObjProperties,
                                        CWriter*            i_pCWriter,
                                        CMBSchemaWriter**   io_pSchemaWriter)
{
    HRESULT              hr                 = S_OK;
    CMBCollectionWriter* pCollectionWriter  = NULL;

    hr = SaveNames(i_pObjProperties,
                   i_pCWriter,
                   io_pSchemaWriter,
                   &pCollectionWriter);

    if(FAILED(hr))
    {
        return hr;
    }


    hr = SaveTypes(i_pObjProperties,
                   i_pCWriter,
                   io_pSchemaWriter,
                   &pCollectionWriter);

    if(FAILED(hr))
    {
        return hr;
    }

    hr = SaveDefaults(i_pObjProperties,
                      i_pCWriter,
                      io_pSchemaWriter,
                      &pCollectionWriter);

    if(FAILED(hr))
    {
        return hr;
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Saves the extended roperty name

Arguments:

    [in]         Metabase properties object.
    [in,out]     Writer object.
    [in,out]     Schema Writer object.
    [in,out]     Collection Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveNames(CMDBaseObject*        i_pObjProperties,
                  CWriter*              i_pCWriter,
                  CMBSchemaWriter**     io_pSchemaWriter,
                  CMBCollectionWriter** io_pCollectionWriter)
{
    HRESULT              hr                 = S_OK;
    CMDBaseObject*       pObjNames          = NULL;
    CMDBaseData*         pObjData           = NULL;
    DWORD                dwEnumIndex        = 0;
    LPWSTR               wszNames           = L"Names";

    //
    // Get the names object
    //

    pObjNames = i_pObjProperties->GetChildObject((LPSTR&)wszNames,
                                                &hr,
                                                TRUE);

    if(FAILED(hr) || (NULL == pObjNames))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] Unable to open /Schema/Properties/Names. GetChildObject failed with hr = 0x%x.\n",hr));

        return hr;
    }

    //
    // Populate the Column meta array by enumerating the names key.
    //

    for(dwEnumIndex=0,
        pObjData=pObjNames->EnumDataObject(dwEnumIndex++,
                                           0,
                                           ALL_METADATA,
                                           ALL_METADATA);
        (SUCCEEDED(hr)) && (pObjData!=NULL);
        pObjData=pObjNames->EnumDataObject(dwEnumIndex++,
                                           0,
                                           ALL_METADATA,
                                           ALL_METADATA))
    {
        CMBPropertyWriter   *pProperty = NULL;

        if(pObjData->GetDataType() != STRING_METADATA)
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] Encountered non-string data in the names tree of the schema. Ignoring entry for this ID: %d \n",pObjData->GetIdentifier()));
            continue;
        }

        if(PropertyNotInShippedSchema(i_pCWriter,
                                      pObjData->GetIdentifier())
          )
        {
            if(NULL == *io_pCollectionWriter)
            {
                hr = GetCollectionWriter(i_pCWriter,
                                         io_pSchemaWriter,
                                         io_pCollectionWriter,
                                         wszTABLE_IIsConfigObject,
                                         FALSE,
                                         NULL);
                if(FAILED(hr))
                {
                    return hr;
                }
            }


            hr = (*io_pCollectionWriter)->GetMBPropertyWriter(pObjData->GetIdentifier(),
                                                              &pProperty);


            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving names tree. GetPropertyWriter for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

                return hr;
            }

            pProperty->AddNameToProperty((LPCWSTR)(pObjData->GetData(TRUE)));
        }

    }

    //
    // Must call create index else it will keep adding duplicate property entries.
    //

    return hr;

} // SaveNames


/***************************************************************************++

Routine Description:

    Saves the extended roperty type

Arguments:

    [in]         Metabase properties object.
    [in,out]     Writer object.
    [in,out]     Schema Writer object.
    [in,out]     Collection Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveTypes(CMDBaseObject*        i_pObjProperties,
                  CWriter*              i_pCWriter,
                  CMBSchemaWriter**     io_pSchemaWriter,
                  CMBCollectionWriter** io_pCollectionWriter)
{
    HRESULT              hr                 = S_OK;
    CMDBaseObject*       pObjTypes          = NULL;
    CMDBaseData*         pObjData           = NULL;
    DWORD                dwEnumIndex        = 0;
    LPWSTR               wszTypes           = L"Types";

    //
    // Get the Types object
    //

    pObjTypes = i_pObjProperties->GetChildObject((LPSTR&)wszTypes,
                                                 &hr,
                                                 TRUE);

    if(FAILED(hr) || (NULL == pObjTypes))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] Unable to open /Schema/Properties/Types. GetChildObject failed with hr = 0x%x.\n",hr));

        return hr;
    }

    for(dwEnumIndex=0,
        pObjData=pObjTypes->EnumDataObject(dwEnumIndex++,
                                           0,
                                           ALL_METADATA,
                                           ALL_METADATA);
        (SUCCEEDED(hr)) && (pObjData!=NULL);
        pObjData=pObjTypes->EnumDataObject(dwEnumIndex++,
                                           0,
                                           ALL_METADATA,
                                           ALL_METADATA))
    {
        CMBPropertyWriter   *pProperty = NULL;

        if(pObjData->GetDataType() != BINARY_METADATA  ||
           pObjData->GetDataLen(TRUE) != sizeof(PropValue))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveSchema] Encountered non-binary data in the type tree of the schema.\nIgnoring type entry for this ID: %d.\nType: %d.(Expected %d)\nLength: %d(Expected %d).\n",
                      pObjData->GetIdentifier(),
                      pObjData->GetDataType(),
                      BINARY_METADATA,
                      pObjData->GetDataLen(TRUE),
                      sizeof(PropValue)));
            if(pObjData->GetDataType() == STRING_METADATA )
            {
                DBGINFOW((DBG_CONTEXT,
                          L"Data: %s.\n",
                          pObjData->GetData(TRUE)
                          ));
            }

            continue;
        }

        if(PropertyNotInShippedSchema(i_pCWriter,
                                      pObjData->GetIdentifier())
          )
        {

            if(NULL == *io_pCollectionWriter)
            {
                hr = GetCollectionWriter(i_pCWriter,
                                         io_pSchemaWriter,
                                         io_pCollectionWriter,
                                         wszTABLE_IIsConfigObject,
                                         FALSE,
                                         NULL);
                if(FAILED(hr))
                {
                    return hr;
                }
            }

            hr = (*io_pCollectionWriter)->GetMBPropertyWriter(pObjData->GetIdentifier(),
                                                              &pProperty);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving types tree. GetPropertyWriter for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

                return hr;
            }

            hr = pProperty->AddTypeToProperty((PropValue*)(pObjData->GetData(TRUE)));

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving types tree. AddTypeToProperty for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

                return hr;
            }
        }

    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Saves the extended roperty default

Arguments:

    [in]         Metabase properties object.
    [in,out]     Writer object.
    [in,out]     Schema Writer object.
    [in,out]     Collection Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveDefaults(CMDBaseObject*           i_pObjProperties,
                     CWriter*                 i_pCWriter,
                     CMBSchemaWriter**        io_pSchemaWriter,
                     CMBCollectionWriter**    io_pCollectionWriter)
{
    HRESULT              hr                 = S_OK;
    CMDBaseObject*       pObjDefaults       = NULL;
    CMDBaseData*         pObjData           = NULL;
    DWORD                dwEnumIndex        = 0;
    LPWSTR               wszDefaults        = L"Defaults";

    //
    // Get the Defaults object
    //

    pObjDefaults = i_pObjProperties->GetChildObject((LPSTR&)wszDefaults,
                                                    &hr,
                                                    TRUE);

    if(FAILED(hr) || (NULL == pObjDefaults))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] Unable to open /Schema/Properties/Defaults. GetChildObject failed with hr = 0x%x.\n",hr));

        return hr;
    }

    for(dwEnumIndex=0,
        pObjData=pObjDefaults->EnumDataObject(dwEnumIndex++,
                                              0,
                                              ALL_METADATA,
                                              ALL_METADATA);
        (SUCCEEDED(hr)) && (pObjData!=NULL);
        pObjData=pObjDefaults->EnumDataObject(dwEnumIndex++,
                                              0,
                                              ALL_METADATA,
                                              ALL_METADATA))
    {
        CMBPropertyWriter   *pProperty = NULL;

        if(PropertyNotInShippedSchema(i_pCWriter,
                                      pObjData->GetIdentifier())
          )
        {
            if(NULL == *io_pCollectionWriter)
            {
                hr = GetCollectionWriter(i_pCWriter,
                                         io_pSchemaWriter,
                                         io_pCollectionWriter,
                                         wszTABLE_IIsConfigObject,
                                         FALSE,
                                         NULL);
                if(FAILED(hr))
                {
                    return hr;
                }
            }

            hr = (*io_pCollectionWriter)->GetMBPropertyWriter(pObjData->GetIdentifier(),
                                                              &pProperty);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving defaults tree. GetPropertyWriter for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

                return hr;
            }

            hr = pProperty->AddDefaultToProperty((BYTE*)(pObjData->GetData(TRUE)),
                                                 pObjData->GetDataLen(TRUE));

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving types tree. AddDefaultToProperty for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

                return hr;
            }
        }

    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Saves the extended roperty name

Arguments:

    [in,out]     Writer object.
    [in,out]     Schema Writer object.
    [in,out]     Collection Writer object.
    [in]         Collection name
    [in]         Bool that indicates container
    [in]         Container class list


Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetCollectionWriter(CWriter*               i_pCWriter,
                            CMBSchemaWriter**      io_pSchemaWriter,
                            CMBCollectionWriter**  io_pCollectionWriter,
                            LPCWSTR                i_wszCollectionName,
                            BOOL                   i_bContainer,
                            LPCWSTR                i_wszContainerClassList)
{
    HRESULT hr = S_OK;

    if(NULL != *io_pCollectionWriter)
    {
        return S_OK;
    }

    //
    // Get the schema writer if it has not been created
    //

    if(NULL == *io_pSchemaWriter)
    {
        hr = i_pCWriter->GetMetabaseSchemaWriter(io_pSchemaWriter);

        if(FAILED(hr))
        {
              DBGINFOW((DBG_CONTEXT,
                          L"[SaveSchema] Error while saving schema tree. Unable to get schema writer failed with hr = 0x%x.\n", hr));
            return hr;
        }

    }

    //
    // Get collection writer for the collection
    //

    hr = (*io_pSchemaWriter)->GetCollectionWriter(i_wszCollectionName,
                                                  i_bContainer,
                                                  i_wszContainerClassList,
                                                  io_pCollectionWriter);
    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveSchema] GetCollectionWriter for %s failed with hr = 0x%x.\n",
                  i_wszCollectionName, hr));

        return hr;
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\sink.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS MetaBase connection point container code for sinks

Author:

    Michael W. Thomas            02-Oct-96

Revision History:

--*/
#include "precomp.hxx"


/*---------------------------------------------------------------------------
  CMDCOM's nested implementation of the COM standard
  IConnectionPointContainer interface including Constructor, Destructor,
  QueryInterface, AddRef, Release, FindConnectionPoint, and
  EnumConnectionPoints.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer
              ::CImpIConnectionPointContainer

  Summary:  Constructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     CMDCOM* pBackObj,
              Back pointer to the parent outer object.
            IUnknown* pUnkOuter
              Pointer to the outer Unknown.  For delegation.

  Modifies: m_pBackObj, m_pUnkOuter.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CMDCOM::CImpIConnectionPointContainer::CImpIConnectionPointContainer()
{
  // Init the Back Object Pointer to point to the parent object.
  //m_pBackObj = pBackObj;

  //m_pUnkOuter = pBackObj;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer
              ::~CImpIConnectionPointContainer

  Summary:  Destructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     void

  Modifies: .

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CMDCOM::CImpIConnectionPointContainer::~CImpIConnectionPointContainer(void)
{
  return;
}

VOID CMDCOM::CImpIConnectionPointContainer::Init(CMDCOM *pBackObj)
{
  // Init the Back Object Pointer to point to the parent object.
  m_pBackObj = pBackObj;

  m_pUnkOuter = (IUnknown*)pBackObj;

  return;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::QueryInterface

  Summary:  The QueryInterface IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
              Returned by the delegated outer QueryInterface call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  // Delegate this call to the outer object's QueryInterface.
  return m_pUnkOuter->QueryInterface(riid, ppv);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::AddRef

  Summary:  The AddRef IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer AddRef call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CMDCOM::CImpIConnectionPointContainer::AddRef(void)
{
  // Delegate this call to the outer object's AddRef.
  return m_pUnkOuter->AddRef();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::Release

  Summary:  The Release IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer Release call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CMDCOM::CImpIConnectionPointContainer::Release(void)
{
  // Delegate this call to the outer object's Release.
  return m_pUnkOuter->Release();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::FindConnectionPoint

  Summary:  Given an IID for a connection point sink find and return the
            interface pointer for that connection point sink.

  Args:     REFIID riid
              Reference to an IID
            IConnectionPoint** ppConnPt
              Address of the caller's IConnectionPoint interface pointer
              variable that will receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::FindConnectionPoint(
               REFIID riid,
               IConnectionPoint** ppConnPt)
{
  HRESULT hr = E_NOINTERFACE;
  IConnectionPoint* pIConnPt;
  g_rSinkResource->Lock(TSRES_LOCK_READ);
    // NULL the output variable.
    *ppConnPt = NULL;

    if (riid == IID_IMDCOMSINK_A) {
        pIConnPt = m_pBackObj->m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A];
        if (NULL != pIConnPt)
        {
          // This connectable CMDCOM object currently has only the Paper Sink
          // connection point. If the associated interface is requested,
          // use QI to get the Connection Point interface and perform the
          // needed AddRef.
            hr = pIConnPt->QueryInterface(IID_IConnectionPoint,
                                          (PPVOID)ppConnPt);
        }
    }
    else if (riid == IID_IMDCOMSINK_W) {
        pIConnPt = m_pBackObj->m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W];
        if (NULL != pIConnPt)
        {
          // This connectable CMDCOM object currently has only the Paper Sink
          // connection point. If the associated interface is requested,
          // use QI to get the Connection Point interface and perform the
          // needed AddRef.
            hr = pIConnPt->QueryInterface(IID_IConnectionPoint,
                                          (PPVOID)ppConnPt);
        }
    }

  g_rSinkResource->Unlock();

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::EnumConnectionPoints

  Summary:  Return Enumerator for the connectable object's contained
            connection points.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's Enumerator interface pointer
              variable. An output variable that will receive a pointer to
              the connection point enumerator COM object.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::EnumConnectionPoints(
                       IEnumConnectionPoints** ppIEnum)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* aConnPts[MAX_CONNECTION_POINTS];
  COEnumConnectionPoints* pCOEnum;
  UINT i;

  g_rSinkResource->Lock(TSRES_LOCK_READ);
  // Zero the output interface pointer.
  *ppIEnum = NULL;

  // Make a copy on the stack of the array of connection point
  // interfaces. The copy is used below in the creation of the new
  // Enumerator object.
  for (i=0; i<MAX_CONNECTION_POINTS; i++)
    aConnPts[i] = (IConnectionPoint*)m_pBackObj->m_aConnectionPoints[i];

  // Create a Connection Point enumerator COM object for the connection
  // points offered by this CMDCOM object. Pass 'this' to be used to
  // hook the lifetime of the host object to the life time of this
  // enumerator object.
  pCOEnum = new COEnumConnectionPoints(this);
  if (NULL != pCOEnum)
  {
    // Use the array copy to Init the new Enumerator COM object.
    // Set the initial Enumerator index to 0.
    hr = pCOEnum->Init(MAX_CONNECTION_POINTS, aConnPts, 0);
    if ( SUCCEEDED(hr) )
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
      hr = pCOEnum->QueryInterface(
                      IID_IEnumConnectionPoints,
                      (PPVOID)ppIEnum);
    }
    
    if( FAILED( hr ) )
    {
      delete pCOEnum;
      pCOEnum = NULL;
    }
  }
  else
    hr = E_OUTOFMEMORY;

  g_rSinkResource->Unlock();

  return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\sources.inc ===
#   sources
#   Author: Charles E. Grant (cgrant)
#   Date:   19-February-1997
#
#   This file is used for compiling Proxy web server from code
#    for generic web server
#
#   Describes the macros used for building using NT 'build' command
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

BUFFER_OVERFLOW_CHECKS=1 
MSC_WARNING_LEVEL= /W4 /WX

INCLUDES=$(IISBASEDIR)\inc;

#
# these are the files that are common between IIS 5.1 & IIS 6.0
#

SOURCES=\
        ..\cbin.cxx     \
        ..\gbuf.cxx     \
        ..\handle.cxx   \
        ..\ptrmap.cxx   \
        ..\security.cxx \
        ..\metabase.rc

TARGETLIBS=\
            $(SDK_LIB_PATH)\user32.lib    \
            $(SDK_LIB_PATH)\advapi32.lib  \
            $(SDK_LIB_PATH)\ole32.lib     \
            $(SDK_LIB_PATH)\uuid.lib      \
            $(SDK_LIB_PATH)\kernel32.lib  \
            $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib \
            $(IISBASEDIR)\svcs\lib\$(O)\iiscrypt.lib  \
            $(IISBASEDIR)\svcs\lib\$(O)\icrypt.lib

!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\dll\security.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    security.cxx

Abstract:

    IIS MetaBase security routines.

Author:

    Keith Moore (keithmo)       13-Mar-1997

Revision History:

--*/

#include "precomp.hxx"

//
// Private data.
//

CRITICAL_SECTION p_SecurityLock;
HCRYPTPROV       p_CryptoProvider  = CRYPT_NULL;
HCRYPTPROV       p_CryptoProvider2 = CRYPT_NULL;

//
// Public functions.
//


BOOL
InitializeMetabaseSecurity(
    VOID
    )
/*++

Routine Description:

    Initializes metabase security.

Arguments:

    None.

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/
{

    HRESULT result;

    INITIALIZE_CRITICAL_SECTION( &p_SecurityLock );

    result = ::IISCryptoInitialize();

    if( FAILED(result) ) {
        DBGPRINTF((
            DBG_CONTEXT,
            "InitializeMetabaseSecurity: error %lx\n",
            result
            ));
    }

    return SUCCEEDED(result);

}   // InitializeMetabaseSecurity


VOID
TerminateMetabaseSecurity(
    VOID
    )
/*++

Routine Description:

    Terminates metabase security. Basically, undoes anything done in
    InitializeMetabaseSecurity().

Arguments:

    None.

Return Value:

    None.

--*/
{

    HRESULT result;

    if( p_CryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( p_CryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) );
    }

    if( p_CryptoProvider2 != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( p_CryptoProvider2 );
        DBG_ASSERT( SUCCEEDED(result) );
    }

    result = ::IISCryptoTerminate();
    DBG_ASSERT( SUCCEEDED(result) );

    DeleteCriticalSection( &p_SecurityLock );

}   // TerminateMetabaseSecurity


HRESULT
GetCryptoProvider(
    HCRYPTPROV *Provider
    )
/*++

Routine Description:

    This routine returns a handle to the crypto provider we need to
    use, deferring creation of the handle until it is actually needed.

Arguments:

    Provider - Receives the handle to the provider.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hprov;

    //
    // If the handle is already initialized, then just use it. Otherwise,
    // grab the lock and check it again.
    //

    hprov = p_CryptoProvider;
    if( hprov == CRYPT_NULL ) {

        EnterCriticalSection( &p_SecurityLock );

        hprov = p_CryptoProvider;
        if( hprov == CRYPT_NULL ) {

            result = ::IISCryptoGetStandardContainer(
                           &hprov,
                           CRYPT_MACHINE_KEYSET
                           );

            if( SUCCEEDED(result) ) {
                p_CryptoProvider = hprov;
            }

        }

        LeaveCriticalSection( &p_SecurityLock );

    }

    *Provider = hprov;
    return result;

}   // GetCryptoProvider

HRESULT
GetCryptoProvider2(
    HCRYPTPROV *Provider
    )
/*++

Routine Description:

    This routine returns a handle to the crypto provider we need to
    use, deferring creation of the handle until it is actually needed.

Arguments:

    Provider - Receives the handle to the provider.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT             hr = S_OK;
    HCRYPTPROV          hprov;
    HCRYPTPROV          hprov1 = CRYPT_NULL;

    //
    // If the handle is already initialized, then just use it. Otherwise,
    // grab the lock and check it again.
    //

    hprov = p_CryptoProvider2;
    if ( hprov == CRYPT_NULL )
    {
        EnterCriticalSection( &p_SecurityLock );

        hprov = p_CryptoProvider2;
        if ( hprov == CRYPT_NULL )
        {
            hr = ::IISCryptoGetStandardContainer2( &hprov );
            if ( SUCCEEDED( hr ) )
            {
                p_CryptoProvider2 = hprov;
            }
        }

        LeaveCriticalSection( &p_SecurityLock );
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = GetCryptoProvider( &hprov1 );
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = IISCryptoCacheHashLength( hprov1 );
    }

    if ( SUCCEEDED( hr ) )
    {
        *Provider = hprov;
    }
    else
    {
        *Provider = CRYPT_NULL;
    }

    return hr;
}   // GetCryptoProvider2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\inc\importer.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ImpExpUtils.h

Abstract:

    IIS MetaBase subroutines to support Import

Author:

    Mohit Srivastava            04-April-01

Revision History:

Notes:

--*/

#ifndef _impexputils_h_
#define _impexputils_h_

class CImporter
{
public:
    CImporter(
        LPCWSTR i_wszFileName,
        LPCSTR  i_pszPassword);

    ~CImporter();

    HRESULT Init();

    HRESULT ShowPathsInFile(
        LPCWSTR pszKeyType,
        DWORD   dwMDBufferSize,
        LPWSTR  pszBuffer,
        DWORD*  pdwMDRequiredBufferSize);

    HRESULT DoIt(
        LPWSTR          i_wszSourcePath,
        LPCWSTR         i_wszKeyType,
        DWORD           i_dwMDFlags,
        CMDBaseObject** o_ppboNew);

	static const WCHAR sm_wszInheritedPropertiesLocationPrefix[];
	static const ULONG sm_cchInheritedPropertiesLocationPrefix;

private:
    //
    // This is the relation of the current
    // location being read from the XML file to the source path.
    //
    enum Relation
    {
        eREL_SELF, eREL_CHILD, eREL_PARENT, eREL_NONE
    };

    HRESULT InitIST();

    Relation GetRelation(
        LPCWSTR i_wszSourcePath,
        LPCWSTR i_wszCheck);

    BOOL IsChild(
        LPCWSTR i_wszParent,
        LPCWSTR i_wszCheck,
        BOOL    *o_pbSamePerson);

    HRESULT ReadMetaObject(
        IN LPCWSTR i_wszAbsParentPath,
        IN CMDBaseObject *i_pboParent,
        IN LPCWSTR i_wszAbsChildPath,
        OUT CMDBaseObject **o_ppboChild);

    BOOL EnumMDPath(
        LPCWSTR i_wszFullPath,
        LPWSTR  io_wszPath,
        int*    io_iStartIndex);

    CComPtr<ISimpleTableDispenser2> m_spISTDisp;
    CComPtr<ISimpleTableWrite2>     m_spISTProperty;

    CComPtr<ISimpleTableRead2>      m_spISTError;
    CComPtr<ICatalogErrorLogger2>   m_spILogger;

    LPCWSTR                         m_wszFileName;
    LPCSTR                          m_pszPassword;

    bool                            m_bInitCalled;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\inc\connect.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    connect.h

Abstract:

    defines for event/sink interface for IIS MetaBase.

Author:

    Michael W. Thomas            04-Oct-96

Revision History:

--*/

#if !defined(CONNECT_H)
#define CONNECT_H

#ifdef __cplusplus

// Types that should be in OLE2.H
#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

// Convenient macros.

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

// An enumeration giving symbol names for the connection
// points offered by the DllPaper component in this server.
enum
{
  MD_CONNPOINT_WRITESINK_A = 0,
  MD_CONNPOINT_WRITESINK_W
};

enum
{
  // The maximum number of connection points offered by the DllPaper
  // component in this STOSERVE server.  The number of items in the
  // connection point enumeration above.
  MAX_CONNECTION_POINTS = 2,

  // A constant for the number of connections to add to the allocation
  // of the dynamic connection array.
  ALLOC_CONNECTIONS = 256,

  // The start value for the connection key (cookie) counter.
  COOKIE_START_VALUE = 500
};


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnectionPoints

  Summary:     COM object class for enumerating the Connection Points
               offered by a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnectionPoints
                 Interface for connection point enumeration.

  Aggregation: COEnumConnectionPoints COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnectionPoints : public IEnumConnectionPoints
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnectionPoints(IUnknown* pHostObj);
    ~COEnumConnectionPoints(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnPts,
              IConnectionPoint** paConnPts,
              ULONG iEnumIndex);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnectionPoints methods.
    STDMETHODIMP         Next(ULONG, IConnectionPoint**, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnectionPoints**);

  private:
    // Private data of COEnumConnectionPoints COM objects.

    // Main Object reference count.
    ULONG              m_cRefs;

    // IUnknown pointer to host COM object being enumerated.
    IUnknown*          m_pHostObj;

    // Connection Point index variable.
    ULONG              m_iEnumIndex;

    // Number of Connection Points being enumerated.
    ULONG              m_cConnPts;

    // Allocated array of Connection Point interface pointers.
    IConnectionPoint** m_paConnPts;
};

typedef COEnumConnectionPoints* PCOEnumConnectionPoints;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COConnectionPoint

  Summary:     Connection Point COM object class. Implements a native
               IConnectionPoint interface. The Advise, Unadvise, and
               EnumConnections methods use the CThreaded OwnThis mechanism
               to provide thread-safe mutually exclusive access to this
               connection point object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IConnectionPoint
                 Interface for connection point features.

  Aggregation: COConnectionPoint COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COConnectionPoint : public IConnectionPoint
{
  public:
    // Main Object Constructor & Destructor.
    COConnectionPoint(IUnknown* pHostObj);
    ~COConnectionPoint(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT                 Init(REFIID riid);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP            QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    // IConnectionPoint methods.
    STDMETHODIMP    GetConnectionInterface(IID*);
    STDMETHODIMP    GetConnectionPointContainer(IConnectionPointContainer**);
    STDMETHODIMP    Advise(IUnknown*, DWORD*);
    STDMETHODIMP    Unadvise(DWORD);
    STDMETHODIMP    EnumConnections(IEnumConnections**);

// Helper functions
    STDMETHODIMP    InternalEnumSinks(
        CONNECTDATA         **prgConnections,
        ULONG               *pcConnections);

  private:
    // Private utility methods of COConnectionPoint.
    HRESULT GetSlot(UINT* puiFreeSlot);
    HRESULT FindSlot(DWORD dwCookie, UINT* puiSlot);

    // Private data of COConnectionPoint COM objects.

    // Main Object reference count.
    ULONG          m_cRefs;

    // IUnknown pointer to host COM object offering this connection point.
    IUnknown*      m_pHostObj;

    // The IID of the sink interface associated with this connection point.
    IID            m_iidSink;

    // The current connection cookie (key) counter.
    DWORD          m_dwNextCookie;

    // The current number of live sink connections to this connection point.
    UINT           m_cConnections;

    // The current maximum index into the dynamic connection array.
    UINT           m_uiMaxIndex;

    // The dynamic array of sink connections to this connection point.
    CONNECTDATA*   m_paConnections;
};

typedef COConnectionPoint* PCOConnectionPoint;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnections

  Summary:     COM object class for enumerating the connections of a
               connection point of a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnections
                 Interface for connection enumeration features.

  Aggregation: COEnumConnections COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnections : public IEnumConnections
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnections(IUnknown* pHostObj);
    ~COEnumConnections(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnections,
              CONNECTDATA* paConnections,
              ULONG iEnumIndex);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnections methods.
    STDMETHODIMP         Next(ULONG, CONNECTDATA*, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnections**);

  private:
    // Private data of COEnumConnections COM objects.

    // Main Object reference count.
    ULONG            m_cRefs;

    // IUnknown pointer to host connection point COM object being
    // enumerated.
    IUnknown*        m_pHostObj;

    // Connection index variable.
    ULONG            m_iEnumIndex;

    // Number of Connections being enumerated.
    ULONG            m_cConnections;

    // Allocated array of live Connections only.
    CONNECTDATA*     m_paConnections;
};

typedef COEnumConnections* PCOEnumConnections;

#endif // __cplusplus


#endif // CONNECT_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\inc\cfgarray.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    cfgarray.h

$Header: $

Abstract:

Author:
    marcelv     5/9/2001 12:28:08       Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGARRAY_H__
#define __CFGARRAY_H__

#pragma once

template <class T>
class CCfgArray
{
public:
    CCfgArray () : m_aData(0), m_cElements(0), m_cSize(0) {}
    ~CCfgArray ()
    {
        delete [] m_aData;
        m_aData = 0;
    }

    ULONG Count () const
    {
        return m_cElements;
    }

    ULONG AllocSize () const
    {
        return m_cSize;
    }

    HRESULT SetAllocSize (ULONG i_iNewSize)
    {
        return AllocNewSize (i_NewSize);
    }

    HRESULT Append (const T& i_NewElement)
    {
        return InsertAt (i_NewElement, m_cElements);
    }

    HRESULT Prepend (const T& i_NewElement)
    {
       return InsertAt (i_NewElement, 0);
    }

    HRESULT InsertAt (const T& i_NewElement, ULONG i_idx)
    {
        HRESULT hr = S_OK;
        if (m_cElements==m_cSize)
        {
            hr = AllocNewSize (m_cSize==0?1:2*m_cSize);
            if (FAILED (hr))
            {
                return hr;
            }
        }

        // move the data in the array. Note that you cannot use
        // memmove, because when you have an array of objects that are
        // refcounted, you have to call the copy constructor, else you
        // get very weird behavior (program crash, etc).
        for (ULONG jdx = m_cElements; jdx > i_idx; --jdx)
        {
            m_aData[jdx] = m_aData[jdx-1];
        }

        m_aData[i_idx] = i_NewElement;
        m_cElements++;

        return hr;
    }

    T& operator[] (ULONG idx) const
    {
        return m_aData[idx];
    };

//=================================================================================
// The Iterator class is used to navigate through the elements in the linked list. Call
// List::Begin to get an iterator pointing to the first element in the list, and call
// Next to get the next element in the list. List::End can be used if we are at the end
// of the list
//=================================================================================
	class Iterator
	{
    private:
        void operator =(const Iterator&);

		friend class CCfgArray<T>;
	public:

		//=================================================================================
		// Function: Next
		//
		// Synopsis: get iterator to next element in the list
		//=================================================================================
		void Next () { m_curIdx++;}

		//=================================================================================
		// Function: Value
		//
		// Synopsis: Returns value of element that iterator points to
		//=================================================================================
		T& Value () const
        {
            return m_aData[m_curIdx];
        }

		bool operator== (const Iterator& rhs) const	{return m_curIdx == rhs.m_curIdx;}
		bool operator!= (const Iterator& rhs) const {return m_curIdx != rhs.m_curIdx;}

	private:
        Iterator (const CCfgArray<T> * i_paData, ULONG iStart) : m_aData(*i_paData), m_curIdx (iStart) {} // only list can create these
		ULONG m_curIdx;
        const CCfgArray<T>& m_aData;
	};

    //=================================================================================
	// Function: Begin
	//
	// Synopsis: Returns an iterator to the beginning of the list
	//=================================================================================
	const Iterator Begin () const
	{
		return Iterator (this, 0);
	}

	//=================================================================================
	// Function: End
	//
	// Synopsis: Returns an iterator one past the end of the list (like STL does)
	//=================================================================================
	const Iterator End () const
	{
		return Iterator (this, m_cElements);
	}

    // returns index of place to insert element in sorted array
    ULONG BinarySearch (const T& i_ElemToSearch) const
    {
        ULONG iLow = 0;
        ULONG iHigh = m_cElements;
        while (iLow < iHigh)
        {
            // (low + high) / 2 might overflow
            ULONG iMid = iLow + (iHigh - iLow) / 2;
            if (m_aData[iMid] > i_ElemToSearch)
            {
                iHigh = iMid;
            }
            else
            {
                iLow = iMid + 1;
            }
        }

        return iLow;
    }

private:
    HRESULT AllocNewSize (ULONG i_NewSize)
    {
        T * aNewData = new T [i_NewSize];
        if (aNewData == 0)
        {
            return E_OUTOFMEMORY;
        }

        // copy the data from the old array in the new array.
        // you have to use the copy constructor (and not memcpy), to avoid
        // all kind of weird errors. When you use memcpy, you are not updating
        // possible refcounts that are part of type T, and thus you get possible
        // crashes
        for (ULONG idx=0; idx < m_cSize; ++idx)
        {
            aNewData[idx] = m_aData[idx];
        }

        delete[] m_aData;
        m_aData = aNewData;
        m_cSize = i_NewSize;

        return S_OK;
    }

    // we don't allow copies
    CCfgArray (const CCfgArray<T>& );
    CCfgArray<T>& operator=(const CCfgArray<T>& );

    T *     m_aData;
    ULONG   m_cSize;
    ULONG   m_cElements;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\inc\readschema.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ReadSchema.h

Abstract:

	Header for the helper functions that are used to read
    schema information from the config stuctures into the metabase.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

extern HRESULT
ReadMetaObject(IN CMDBaseObject*&     cboRead,
			   IN LPWSTR		      wszPath,
			   IN FILETIME*           pFileTime,
			   IN BOOL		          bUnicode);

extern HRESULT
ReadDataObject(IN CMDBaseObject*      cboAssociated,
		       IN LPVOID*             a_pv,
		       IN ULONG*              a_Size,
               IN IIS_CRYPTO_STORAGE* pCryptoStorage,
               IN BOOL                bUnicode);

extern HRESULT 
ReadSchema(IIS_CRYPTO_STORAGE*		i_pStorage,
		   FILETIME*				pFileTime);

extern HRESULT 
ReadSchemaProperties(CMDBaseObject*           i_pboRead,
  				     IIS_CRYPTO_STORAGE*	  i_pStorage);

extern HRESULT 
ReadAdminACL(CMDBaseObject*       i_pboRead,
		     IIS_CRYPTO_STORAGE*  i_pStorage);

extern DWORD 
GetPrincipalSID (LPWSTR Principal,
	             PSID*  Sid,
				 BOOL*  pbWellKnownSID);

extern HRESULT 
ReadLargestMetaID(CMDBaseObject*             i_pboRead,
  				  IIS_CRYPTO_STORAGE*		 i_pStorage);

extern HRESULT 
ReadProperties(IIS_CRYPTO_STORAGE*		i_pStorage,
   			   FILETIME*				i_pFileTime);

extern HRESULT 
ReadPropertyNames(CMDBaseObject*			i_pboRead,
				  LPVOID*					i_apv,
				  ULONG*					i_aSize,
	   			  IIS_CRYPTO_STORAGE*		i_pStorage);

extern HRESULT 
ReadFlagNames(CMDBaseObject*			i_pboRead,
			  LPVOID*					i_apv,
			  ULONG*					i_aSize,
	   		  IIS_CRYPTO_STORAGE*		i_pStorage);

extern HRESULT 
ReadPropertyTypes(CMDBaseObject*			i_pboRead,
				  LPVOID*					i_apv,
				  ULONG*					i_aSize,
	   			  IIS_CRYPTO_STORAGE*		i_pStorage);

extern HRESULT 
ReadAllFlags(IIS_CRYPTO_STORAGE*		i_pStorage,
			 CMDBaseObject*				i_pboReadType,
			 CMDBaseObject*				i_pboReadName,
			 CMDBaseObject*				i_pboReadDefault,
			 DWORD						i_dwColumnIndex,
			 DWORD						i_dwMetaID,
			 DWORD						i_dwFlags,
			 DWORD						i_dwAttributes,
			 DWORD						i_dwUserType,
			 DWORD						i_dwMultivalued);

extern HRESULT 
ReadFlagTypes(CMDBaseObject*			i_pboRead,
   			  IIS_CRYPTO_STORAGE*		i_pStorage,
			  DWORD						i_dwMetaID,
			  DWORD						i_dwFlags,
			  DWORD						i_dwAttributes,
			  DWORD						i_dwUserType,
			  DWORD						i_dwMultivalued,
			  LPVOID*					i_apv,
			  ULONG*					i_aSize);

extern HRESULT 
ReadFlagDefaults(CMDBaseObject*			i_pboRead,
			     LPVOID*				i_apv,
			     ULONG*					i_aSize,
	   		     IIS_CRYPTO_STORAGE*	i_pStorage);

extern HRESULT 
ReadPropertyDefaults(CMDBaseObject*			i_pboRead,
				     LPVOID*				i_apv,
				     ULONG*					i_aSize,
	   			     IIS_CRYPTO_STORAGE*	i_pStorage);

extern HRESULT 
ReadClasses(IIS_CRYPTO_STORAGE*		i_pStorage,
 			FILETIME*				i_pFileTime);

extern HRESULT 
ReadClass(LPVOID*					i_apv,
		  ULONG*					i_aSize,
	      IIS_CRYPTO_STORAGE*		i_pStorage,
 		  FILETIME*					i_pFileTime);

extern HRESULT 
GetProperties(LPCWSTR					i_wszTable,
              LPWSTR*					o_pwszOptional,
			  LPWSTR*					o_pManditory);

extern HRESULT 
AddFlagValuesToPropertyList(LPWSTR					i_wszTable,
		                    ULONG					i_dwIndex,
							ULONG*					io_pcCh,
							LPWSTR*					io_pwszPropertyList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\interfac\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME2  = mddefw
INCS            = -I. -I$(SDK_INC_PATH)
HEADER_FILE2    = $(PROJECT_ROOT)\iis\inc\$(O)\$(IDL_FILE_NAME2).h
TARGETS         = $(HEADER_FILE) $(HEADER_FILE2) $(HEADER_FILE3)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

MSC_WARNING_LEVEL= /W4 /WX

#
#  Define output and dependencies
#

$(PROJECT_ROOT)\iis\inc\$(O)\mdmsg.h ..\inc\$(O)\mdmsg.rc ..\inc\$(O)\msg00001.bin: mdmsg.mc
    -mkdir $(PROJECT_ROOT)\iis\inc\$(O)
    -mkdir ..\inc\$(O)
    mc -o -h $(PROJECT_ROOT)\iis\inc\$(O) -r ..\inc\$(O) -v mdmsg.mc


!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

#
#  MIDL Compile stuff
#

$(HEADER_FILE2): .\$(IDL_FILE_NAME2).idl
    midl -no_stamp $(MIDL_OPTIMIZATION_NT5) -h $(HEADER_FILE2) $(INCS) .\$(IDL_FILE_NAME2).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\inc\listener.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    Listner.h

Abstract:

    Class that does subscribes and process file change notifications.

Author:

    Varsha Jayasimha (varshaj)          30-Nov-1999

Revision History:

--*/

#ifndef _LISTNER_H_
#define _LISTNER_H_


enum eUNSUBSCRIBE_ACTION
{
    eACTION_UNSUBSCRIBE_ALL =0,
    eACTION_UNSUBSCRIBE_OBSOLETE,
    cUNSUBSCRIBE_ACTION
};

enum eFILE_NOTIFICATION
{
    eFILE_CREATE = 0,
    eFILE_MODIFY,
    eFILE_DELETE,
    cFILE_NOTIFCATION
};


class CFileListener : 
public ISimpleTableFileChange
{

public:

    CFileListener();

    ~CFileListener();

private:

    DWORD                               m_cRef;

    DWORD                               m_dwNotificationCookie;

    ULONG                               m_cRequestedFileNotification;

    ISimpleTableDispenser2*             m_pISTDisp;

    ISimpleTableFileAdvise*             m_pISTFileAdvise;

    LPWSTR                              m_wszHistoryFileDir;

    DWORD                               m_cchHistoryFileDir;

    LPWSTR                              m_wszRealFileName;

    DWORD                               m_cchRealFileName;

    LPWSTR                              m_wszRealFileNameWithoutPath;

    DWORD                               m_cchRealFileNameWithoutPath;

    LPWSTR                              m_wszRealFileNameWithoutPathWithoutExtension;

    DWORD                               m_cchRealFileNameWithoutPathWithoutExtension;

    LPWSTR                              m_wszRealFileNameExtension;

    DWORD                               m_cchRealFileNameExtension;

    LPWSTR                              m_wszSchemaFileName;

    DWORD                               m_cchSchemaFileName;

    LPWSTR                              m_wszSchemaFileNameWithoutPath;

    DWORD                               m_cchSchemaFileNameWithoutPath;

    LPWSTR                              m_wszSchemaFileNameWithoutPathWithoutExtension;

    DWORD                               m_cchSchemaFileNameWithoutPathWithoutExtension;

    LPWSTR                              m_wszSchemaFileNameExtension;

    DWORD                               m_cchSchemaFileNameExtension;

    LPWSTR                              m_wszErrorFileSearchString;

    DWORD                               m_cchErrorFileSearchString;

    LPWSTR                              m_wszMetabaseDir;

    DWORD                               m_cchMetabaseDir;

    LPWSTR                              m_wszHistoryFileSearchString;

    DWORD                               m_cchHistoryFileSearchString;

    LPWSTR                              m_wszEditWhileRunningTempDataFile;

    DWORD                               m_cchEditWhileRunningTempDataFile;

    LPWSTR                              m_wszEditWhileRunningTempSchemaFile;

    DWORD                               m_cchEditWhileRunningTempSchemaFile;

    LPWSTR                              m_wszEditWhileRunningTempDataFileWithAppliedEdits;

    DWORD                               m_cchEditWhileRunningTempDataFileWithAppliedEdits;

    BOOL                                m_bIsTempSchemaFile;

    CListenerController*                m_pCListenerController;

    IMSAdminBase*                       m_pAdminBase;

public:

    // Initialize

    HRESULT Init(CListenerController* i_pListenerController);

    // IUnknown

    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);

    STDMETHOD_(ULONG,AddRef)        ();

    STDMETHOD_(ULONG,Release)       ();

    // ISimpleTableFileChange

    STDMETHOD (OnFileCreate)        (LPCWSTR i_wszFileName);    // Add notifications to the received queue. 

    STDMETHOD (OnFileModify)        (LPCWSTR i_wszFileName);    // Add notifications to the received queue. 

    STDMETHOD (OnFileDelete)        (LPCWSTR i_wszFileName);    // Add notifications to the received queue. 

    HRESULT Subscribe();                                            // Subscribe for file change notifications on 
                                                                    // the metabase file.
                                                                    

    HRESULT UnSubscribe();                                          // Unsubscribe for file change notifications on
                                                                    // the metabase file.
    HRESULT ProcessChanges();

private:

    HRESULT AddReceivedNotification(LPCWSTR i_wszFile, 
                                    DWORD i_eNotificationStatus);   // Adds to recd array

    HRESULT GetTable(LPCWSTR    i_wszDatabase,
                     LPCWSTR    i_wszTable,
                     LPVOID     i_QueryData,    
                     LPVOID     i_QueryMeta,    
                     ULONG      i_eQueryFormat,
                     DWORD      i_fServiceRequests,
                     LPVOID*    o_ppIST);


    HRESULT ProcessChangesFromFile(LPWSTR i_wszHistoryFile,
                                   ULONG  i_ulMajorVersion,
                                   ULONG  i_ulMaxMinorVersion,
                                   BOOL*  o_bGetTableFailed);

    HRESULT OpenParentKeyAndGetChildKey(LPWSTR           i_wszLocation,
                                        IMSAdminBase*    i_pAdminBase,
                                        METADATA_HANDLE* o_pHandle,
                                        WCHAR**          o_wszChildKey);

    HRESULT OpenKey(LPWSTR           i_wszLocation,
                    IMSAdminBase*    i_pAdminBase,
                    BOOL             i_bAddIfMissing,
                    METADATA_HANDLE* o_pHandle,
                    BOOL*            o_bInsertedKey);

    HRESULT GetVersionNumber(LPWSTR    i_wszDataFile,
                             DWORD*    o_pdwVersionNumber,
                             BOOL*     o_bGetTableFailed);                          // Gets the version number.

    HRESULT GetVersionNumberSubset(LPSTR  szVersion,
                                   int*   piVersion,
                                   LPVOID lpMapAddressBegin,
                                   LPVOID lpMapAddressEnd);

    HRESULT ApplyChangeToHistoryFile(CWriterGlobalHelper*       pISTHelper,
                                     ISimpleTableWrite2*        pISTDiff,
                                     LPWSTR                     wszHistoryFile,
                                     ULONG                      i_dwMajorVersion,
                                     ULONG                      i_dwMinorVersion);  // Apply changes to the history file.

    HRESULT CopyErrorFile(BOOL            i_bGetTableFailed, HRESULT i_hrThatCausedTheCopyErrorFile);

    HRESULT MergeLocation(CWriter*                pCWriter,
                          ISimpleTableRead2*      pISTHistory,
                          ULONG*                  piReadRowHistory,
                          ULONG                   LocationIDHistory,
                          ISimpleTableWrite2*     pISTDiff,
                          ULONG*                  piWriteRowDiff,
                          ULONG                   LocationIDDiff,
                          LPCWSTR                 wszLocation);                 // Merges the location (found in both diff and history)

    HRESULT MergeLocation(CWriter*                pCWriter,
                          ISimpleTableRead2*      pISTRead,
                          BOOL                    bMBPropertyTable,
                          ULONG*                  piRow,
                          ULONG                   LocationID,
                          LPCWSTR                 wszLocation);                 // Merges location from diff or history.

    HRESULT MergeRemainingLocations(CWriter*                pCWriter,
                                    ISimpleTableRead2*      pISTRead,
                                    BOOL                    bMBPropertyTable,
                                    ULONG*                  piRow);             // Merge remaining locations from diff or history.

    HRESULT MergeProperties(CLocationWriter*        pCLocationWriter,
                            ISimpleTableRead2*      pISTHistory,
                            ULONG*                  piReadRowHistory,
                            ULONG                   LocationIDHistory,
                            ISimpleTableWrite2*     pISTDiff,
                            ULONG*                  piWriteRowDiff,
                            ULONG                   LocationIDDiff);            // Merge properties from a given location from diff and history tables.

    HRESULT MergeRemainingProperties(CLocationWriter*    pCLocationWriter,
                                     ISimpleTableRead2*  pISTRead,
                                     BOOL                bMBPropertyTable,
                                     ULONG*              piRow,
                                     ULONG               LocationID);           // Merge properties from a given location in diff or history table.

    HRESULT SaveChange(ULONG                i_iRow,
                       ISimpleTableWrite2*  i_pISTDiff);

    HRESULT SaveChangeAsNodeWithNoPropertyAdded(LPVOID*                i_apvDiff,
                                                ISimpleTableWrite2*    i_pISTDiff);

    HRESULT GetChangeNumber(LPWSTR  wszChangedFile,
                            DWORD*  pdwChangeNumber);

    LPVOID  FindStr(LPSTR  wszStr,
                    LPVOID lpBegin,
                    LPVOID lpEnd);

    int Cmp(char* s1, LPVOID pvEnd, char* s2);

    BOOL ProgrammaticMetabaseSaveNotification();

    HRESULT GetMetabaseAttributes(WIN32_FIND_DATAW* pCurrentMetabaseAttr,
                                  DWORD*            pdwCurrentMetabaseVersion);

    BOOL CompareMetabaseAttributes(FILETIME* pPreviousMetabaseFileLastWriteTimeStamp,
                                   DWORD     dwPreviousMetabaseVersion,
                                   FILETIME* pCurrentMetabaseFileLastWriteTimeStamp,
                                   DWORD     dwCurrentMetabaseVersion);

    HRESULT GetGlobalHelperAndCopySchemaFile(CWriterGlobalHelper** o_pISTHelper);

    void DeleteTempFiles();


}; // CFileListner

#endif _LISTNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\inc\listenercontroller.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ListnerController.h

Abstract:

    Class that starts and stops the Listener

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:

--*/


#ifndef _LISTENERCONTROLLER_H_
#define _LISTENERCONTROLLER_H_

enum eEVENTS{
    iEVENT_MANAGELISTENING = 0,     // Stop should be before processnotifications, because if both happen at the same time, you want stop to win.
    iEVENT_PROCESSNOTIFICATIONS,
    cmaxLISTENERCONTROLLER_EVENTS
};

enum eSTATE{
    iSTATE_STOP_TEMPORARY = 0,
    iSTATE_STOP_PERMANENT,
    iSTATE_START,
    cmaxSTATE
};

// Fwd declaration
class CFileListener;

class CListenerController:
public IUnknown
{

public:

    CListenerController();

    ~CListenerController();

private:

    eSTATE                          m_eState;

    HANDLE                          m_aHandle[cmaxLISTENERCONTROLLER_EVENTS];

    LOCK                            m_LockStartStop;

    DWORD                           m_cRef;

    ICatalogErrorLogger2*            m_pEventLog;

    HANDLE                          m_hListenerThread;

    BOOL                            m_bDoneWaitingForListenerToTerminate;

public:

    // IUnknown

    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);

    STDMETHOD_(ULONG,AddRef)        ();

    STDMETHOD_(ULONG,Release)       ();

    HRESULT CreateListener(CFileListener** o_pListener);

    void Listen();

    HRESULT Start();                // Start the listener.

    HRESULT Stop(eSTATE   i_eState,
                 HANDLE*  o_hListenerThread);   // Stop the listener.

    HRESULT Init();                 // Initializes the events and CriticalSection

    HANDLE* Event();                // Accessor function that returns a ptr to the event handle array

    ICatalogErrorLogger2* EventLog();

};

HRESULT InitializeListenerController();
HRESULT UnInitializeListenerController();

#endif _LISTENERCONTROLLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\rpcref\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for rpcref.dll  --
           This Dll adds a ref count around the RPC runtime call -
           RpcServerListen(). This enables multiple services in
           the inetinfo process to do a RpcServerListen() without
           stomping over each other.

           This Dll will maintain a ref count on calls to RpcServerListen()
           and call RpcMgmtStopServerListening() when the ref count goes to 0.

    FILE HISTORY:
        RajeevR     18-Aug-1997 Created.
*/

#include <windows.h>
#include <stdio.h>

extern "C" {
	#include <rpc.h>
};

#include <dbgutil.h>
	
DWORD				cRefs = 0;
CRITICAL_SECTION	csCritRef;

extern "C"
BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
	    case DLL_PROCESS_ATTACH:

	    	cRefs = 0;
	    	INITIALIZE_CRITICAL_SECTION( &csCritRef );
	    	break;
	    	
	    case DLL_PROCESS_DETACH:

	    	DeleteCriticalSection( &csCritRef );
	    	break;
	    	
    	case DLL_THREAD_ATTACH:
	    case DLL_THREAD_DETACH:
    	default:
        	break ;
    }

    return ( fReturn);

}  // main()

DWORD
InetinfoStartRpcServerListen(
    VOID
    )
/*++

Routine Description:

    This function starts RpcServerListen for this process. The first
    service that is calling this function will actually start the
    RpcServerListen, subsequent calls just bump a ref count

Arguments:

    None.

Return Value:

    None.

--*/
{

    RPC_STATUS Status = RPC_S_OK;

    EnterCriticalSection( &csCritRef );

    if( cRefs++ == 0 ) {
	    Status = RpcServerListen(
    	                1,                              // minimum num threads.
        	            RPC_C_LISTEN_MAX_CALLS_DEFAULT, // max concurrent calls.
            	        TRUE );                         // don't wait
    }

    LeaveCriticalSection( &csCritRef );

    return( Status );
}

DWORD
InetinfoStopRpcServerListen(
    VOID
    )
/*++

Routine Description:

	Bump ref count down. Last caller will do actual cleanup.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    EnterCriticalSection( &csCritRef );

	if( --cRefs == 0 ) {
	    Status = RpcMgmtStopServerListening(0);

    	//
	    // wait for all RPC threads to go away.
    	//

	    if( Status == RPC_S_OK) {
    	    Status = RpcMgmtWaitServerListen();
	    }
    }

    LeaveCriticalSection( &csCritRef );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\metadata\inc\saveschema.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    SaveSchema.h

Abstract:

    Header for the helper functions that are used to determine
    if a schema compilation is needed.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/


typedef struct _DELIMITEDSTRING
{
    LPWSTR pwszStringStart;
    LPWSTR pwszStringEnd;

} DELIMITEDSTRING;


extern HRESULT 
SaveSchemaIfNeeded(LPCWSTR              i_wszTempFile,
                   PSECURITY_ATTRIBUTES i_pSecurityAtrributes);

extern HRESULT 
SaveSchema(LPCWSTR              i_wszTempFile,
           PSECURITY_ATTRIBUTES i_pSecurityAtrributes);

extern HRESULT 
CreateNonIISConfigObjectCollections(CMDBaseObject*     i_pObjSchema,
                                    CWriter*           i_pCWriter,
                                    CMBSchemaWriter**  io_pSchemaWriter);

extern HRESULT 
ParseAndAddPropertiesToNonIISConfigObjectCollection(LPCWSTR                 i_wszProperties,
                                                    BOOL                    i_bManditory,
                                                    CMBCollectionWriter*    i_pCollectionWriter);

extern HRESULT  
CreateIISConfigObjectCollection(CMDBaseObject*     i_pObjProperties,
                                CWriter*           i_pCWriter,
                                CMBSchemaWriter**  io_pSchemaWriter);

extern HRESULT 
SaveNames(CMDBaseObject*        i_pObjProperties,
          CWriter*              i_pCWriter,
          CMBSchemaWriter**     i_pSchemaWriter,
          CMBCollectionWriter** i_pCollectionWriter);

extern HRESULT 
SaveTypes(CMDBaseObject*       i_pObjProperties,
          CWriter*             i_pCWriter,
          CMBSchemaWriter**    i_pSchemaWriter,
          CMBCollectionWriter** i_pCollectionWriter);

extern HRESULT 
SaveDefaults(CMDBaseObject*        i_pObjProperties,
             CWriter*              i_pCWriter,
             CMBSchemaWriter**     i_pSchemaWriter,
             CMBCollectionWriter**  i_pCollectionWriter);

extern BOOL 
PropertyNotInShippedSchema(CWriter*  i_pCWriter,
                           DWORD     i_dwIdentifier);

extern BOOL 
TagNotInShippedSchema(CWriter*  i_pCWriter,
                      DWORD     i_dwIdentifier);

extern HRESULT 
GetCollectionWriter(CWriter*               i_pCWriter,
                    CMBSchemaWriter**      io_pSchemaWriter,
                    CMBCollectionWriter**  io_pCollectionWriter,
                    LPCWSTR                i_wszCollectionName,
                    BOOL                   i_bContainer,
                    LPCWSTR                i_wszContainerClassList);

extern BOOL 
ClassDiffersFromShippedSchema(LPCWSTR i_wszClassName,
                              BOOL    i_bIsContainer,
                              LPWSTR  i_wszContainedClassList);

extern BOOL 
MatchClass(BOOL     i_bIsContainer,
           LPWSTR   i_wszContainedClassList,
           LPVOID*  i_apv);

extern BOOL 
MatchCommaDelimitedStrings(LPWSTR   i_wszString1,
                           LPWSTR   i_wszString2);

extern HRESULT 
CommaDelimitedStringToArray(LPWSTR              i_wszString,
                            DELIMITEDSTRING**   io_apDelimitedString,
                            ULONG*              io_piDelimitedString,
                            ULONG*              io_pcMaxDelimitedString,
                            BOOL*               io_pbReAlloced);

extern HRESULT 
AddDelimitedStringToArray(DELIMITEDSTRING*     i_pDelimitedString,
                          ULONG*               io_piDelimitedString,
                          ULONG*               io_pcMaxDelimitedString,
                          BOOL*                io_pbReAlloced,
                          DELIMITEDSTRING**    io_apDelimitedString);

extern HRESULT 
ReAllocate(ULONG              i_iDelimitedString,
           BOOL               i_bReAlloced,
           DELIMITEDSTRING**  io_apDelimitedString,
           ULONG*             io_pcDelimitedString);

extern BOOL 
MatchDelimitedStringArray(DELIMITEDSTRING* i_aString1,
                          ULONG            i_cString1,
                          DELIMITEDSTRING* i_aString2,
                          ULONG            i_cString2);

extern BOOL 
ClassPropertiesDifferFromShippedSchema(LPCWSTR i_wszClassName,
                                       LPWSTR  i_wszOptProperties,
                                       LPWSTR  i_wszMandProperties);


extern HRESULT 
GetGlobalHelper(BOOL                    i_bFailIfBinFileAbsent, 
                CWriterGlobalHelper**   ppCWriterGlobalHelper);

extern HRESULT 
UpdateTimeStamp(LPWSTR i_wszSchemaXMLFileName,
                LPWSTR i_wszSchemaBinFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\sec\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Contains prototype definitions for various locally defined functions.

Author:

    Madan Appiah (madana)  19-Sep-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_H_
#define _PROTO_H_

#ifdef __cplusplus
extern "C" {
#endif

PVOID
INetpMemoryAllocate(
    DWORD Size
    );

VOID
INetpMemoryFree(
    PVOID Memory
    );

DWORD
INetpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    );

DWORD
INetpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    );

DWORD
NetpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    );

DWORD
INetpAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    );

DWORD
INetpDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );

DWORD
INetpCreateSecurityDescriptor(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

#ifdef __cplusplus
}
#endif


#endif  // _PROTO_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\rdns\rdns.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rdns.cxx

Abstract:

    Reverse DNS service

Author:

    Philippe Choquier (phillich)    5-june-1996

--*/

// only need async if not every HTTP req ends up calling DNS resolution
// if async then potentially 100s of HTTP requests
// so should be sync.

// Bind(addr) @ session start
// Init(BLOB) / CheckAccess( callbakc ) / Terminate()
// callback : yes or no, post empty completion status

#define dllexp __declspec( dllexport )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <time.h>
#include <stdio.h>
#include <malloc.h>
#include <windns.h>

#include <iis64.h>
#include <dbgutil.h>

#include <rdns.hxx>
#include <issched.hxx>

#include <inetsvcs.h>

#define DN_LEN  64

#define RDNS_REG_KEY    "SYSTEM\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define RDNS_REG_MAX_THREAD     "DnsMaxThread"
#define RDNS_REG_CACHE_SIZE     "DnsCacheSizeInK"
#define RDNS_REG_TTL            "DnsTTLInSeconds"
#define RDNS_REG_MAX_THREAD_DEF 0
#define RDNS_REG_CACHE_SIZE_DEF 256
// in seconds
#define RDNS_REG_TTL_DEF    (20*60)


#define RDNS_SCAVENGER_GRANULARITY  (2*60)

#define XBF_EXTEND      64
#define RDNS_HASH_SIZE  1021

#define ENTRYPTR( a, b ) (a+b-1)

#define LOCALHOST_ADDRESS        0x0100007F  // 127.0.0.1

//
// Local classes
//

class RDnsCacheEntry {
public:
    BOOL Init( UINT i );
    void Reset();
    //
    UINT RemoveFromPrio( RDnsCacheEntry* );
    UINT RemoveFromHash( RDnsCacheEntry* );
    void InsertInPrioBefore( RDnsCacheEntry*, UINT );
    void InsertInHashBefore( RDnsCacheEntry*, UINT );
    UINT GetNextHash() { return m_pHashNext; }
    UINT GetNextPrio() { return m_pPrioNext; }
    BOOL MatchAddr(struct sockaddr *, time_t tNow );
    BOOL MatchName(LPSTR pszName, time_t tNow );
    BOOL CopyName(LPSTR pszResult, DWORD dwResMaxLen)
    {
        UINT l = strlen(m_achName) + 1;
        if ( dwResMaxLen >= l  )
        {
            memcpy( pszResult, m_achName, l );
            return TRUE;
        }

        return FALSE;
    }
    BOOL CopyAddr( sockaddr* p )
    {
        memcpy( p, &m_addr, sizeof(m_addr) ); return TRUE;
    }
    DWORD GetHash() { return m_h; }
    void SetFree() { m_fIsFree = TRUE; }
    BOOL Store(struct sockaddr *pAddr, DWORD h, time_t Expire, LPSTR pszName );
    BOOL Expired( time_t tNow ) { return !m_fIsFree && m_Expire <= tNow; }
    BOOL IsIp2Dns() { return m_fIsIp2Dns; }
    VOID SetIsIp2Dns( BOOL f ) { m_fIsIp2Dns = f; }

private:
    struct sockaddr     m_addr;
    CHAR                m_achName[DN_LEN];
    UINT                m_pHashNext;
    UINT                m_pHashPrev;
    UINT                m_pPrioNext;
    UINT                m_pPrioPrev;
    UINT                m_iIndex;
    DWORD               m_h;
    BOOL                m_fIsFree;
    time_t              m_Expire;
    BOOL                m_fIsIp2Dns;
} ;


class RDnsDict {

public:
    BOOL Init()
    {
        m_cAlloc = 0;
        m_cSize = 0;
        INITIALIZE_CRITICAL_SECTION( &m_csLock );
        if ( m_FreeList = Append() )
        {
            ENTRYPTR(m_pV,m_FreeList)->Init( m_FreeList );
        }
        if ( m_PrioList = Append() )
        {
            ENTRYPTR(m_pV,m_PrioList)->Init( m_PrioList );
        }
        return TRUE;
    }

    void Terminate()
    {
        if (m_cAlloc )
        {
            LocalFree( m_pV );
        }

        DeleteCriticalSection( &m_csLock );
    }

    void Lock() { EnterCriticalSection( &m_csLock ); }
    void Unlock() { LeaveCriticalSection( &m_csLock ); }

    // Append an entry

    UINT NewEntry( struct sockaddr *pAddr, DWORD h, time_t Expire, LPSTR pszName );
    UINT NewDns2IpEntry( struct sockaddr *pAddr, DWORD h, time_t Expire, LPSTR pszName );
    DWORD ComputeHash( struct sockaddr* pAddr );
    DWORD ComputeHash( LPSTR pszName );
    BOOL Search( struct sockaddr* pAddr, DWORD h, LPSTR pszResult, DWORD dwResMaxLen );
    BOOL SearchByName( struct sockaddr* pAddr, DWORD h, LPSTR pszName );
    UINT GetFreeEntry();
    UINT Append();
    void FreeEntry( UINT i);
    void Scavenger();

private:
    UINT                m_cAlloc;       // allocated memory
    UINT                m_cSize;        // used memory
    CRITICAL_SECTION    m_csLock;
    RDnsCacheEntry*     m_pV;
    UINT                m_PrioList;
    UINT                m_FreeList;
    UINT                m_pHash[RDNS_HASH_SIZE];
    UINT                m_pDns2IpHash[RDNS_HASH_SIZE];
} ;


//
// Local functions
//

VOID
AddrCheckDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

VOID
AddrCheckDnsCallBack2(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

VOID
AddrCheckDnsCallBack3(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

VOID
ResolveDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

//
// globals
//

DWORD g_cCacheSize = RDNS_REG_CACHE_SIZE_DEF * 1024;
DWORD g_cTTL = RDNS_REG_TTL_DEF;
HANDLE g_hThreadsTerminated = NULL;
HANDLE g_hDnsPort = NULL;
UINT g_cThreads;
UINT g_cMaxThreadLimit = RDNS_REG_MAX_THREAD_DEF;
long g_cAvailableThreads;
RDnsDict g_RDns;
CSidCache * g_pscPen = NULL;
DWORD g_dwScavengerWorkItem = NULL;
BOOL g_fEnableRdns = TRUE;
DNSFUNCDESC g_Dns2Ip = { RDNS_REQUEST_TYPE_DNS2IP, ::AddrCheckDnsCallBack2 };
DNSFUNCDESC g_Ip2Dns = { RDNS_REQUEST_TYPE_IP2DNS, ::AddrCheckDnsCallBack};
DNSFUNCDESC g_ResolveDns = { RDNS_REQUEST_TYPE_IP2DNS, ::ResolveDnsCallBack};
DNSFUNCDESC g_ResolveDns2Ip = { RDNS_REQUEST_TYPE_DNS2IP, ::AddrCheckDnsCallBack3 };
BYTE NULL_IP_ADDR[]="\x00\x00\x00\x00";

//
//
//

BOOL
PenAddToCache(
    PSID pS,
    DWORD dwTTL
    )
/*++

Routine Description:

    Add to Pwd Exp Notification cache

Arguments:

    pS - ptr to SID to add to cache

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    return g_pscPen->AddToCache( pS, dwTTL );
}


BOOL
PenIsInCache(
    PSID pS
    )
/*++

Routine Description:

    Check if SID in Pwd Exp Notification cache

Arguments:

    pS - ptr to SID to check

Return Value:

    TRUE if SID in cache, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    return g_pscPen->IsInCache( pS );
}


BOOL
PenCheckPresentAndResetTtl(
    PSID pS,
    DWORD dwTtl
    )
/*++

Routine Description:

    Check if SID in Pwd Exp Notification cache
    and update TTL

Arguments:

    pS - ptr to SID to check
    dwTtl - new TTL value

Return Value:

    TRUE if SID in cache, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    return g_pscPen->CheckPresentAndResetTtl( pS, dwTtl );
}


//
//
//

BOOL
RDnsCacheEntry::Init(
    UINT i
    )
/*++

Routine Description:

    Initialize a cache entry

Arguments:

    i - index (1-based) of this entry in the dict array

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    m_iIndex = i;
    Reset();

    return TRUE;
}


void
RDnsCacheEntry::Reset(
    VOID
    )
/*++

Routine Description:

    Reset a cache entry

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    m_pHashNext = NULL;     // non-circular list
    m_pHashPrev = NULL;
    m_pPrioNext = m_iIndex; // circular list
    m_pPrioPrev = m_iIndex;

    m_fIsFree = TRUE;
}


BOOL
RDnsCacheEntry::MatchAddr(
    struct sockaddr * pAddr,
    time_t tNow
    )
/*++

Routine Description:

    Check if entry match specified address and not expired

Arguments:

    pAddr - ptr to address
    tNow - current time

Return Value:

    TRUE if match and not expired, FALSE otherwise

--*/
{
    int l;
    LPBYTE p1;
    LPBYTE p2;

    DBG_ASSERT(g_fEnableRdns);
    switch ( pAddr->sa_family )
    {
        case AF_INET:
            l = SIZEOF_IP_ADDRESS;
            p1 = (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr);
            p2 = (LPBYTE)(&((PSOCKADDR_IN)&m_addr)->sin_addr);
            break;
#if 0
        case AF_IPX:
            l = 6;
            p1 = (LPBYTE)(((PSOCKADDR)pAddr)->sa_data);
            p2 = (LPBYTE)(((PSOCKADDR)&m_addr)->sa_data);
            break;
#endif
        default:
            return FALSE;
    }

    return !memcmp( p1, p2, l ) && m_Expire > tNow;
}


BOOL
RDnsCacheEntry::MatchName(
    LPSTR pszName,
    time_t tNow
    )
/*++

Routine Description:

    Check if entry match specified DNS name and not expired

Arguments:

    pszName - ptr to DNS name
    tNow - current time

Return Value:

    TRUE if match and not expired, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);

    return !strcmp( pszName, m_achName ) && m_Expire > tNow;
}


BOOL
RDnsCacheEntry::Store(
    struct sockaddr *pAddr,
    DWORD h,
    time_t Expire,
    LPSTR pszName
    )
/*++

Routine Description:

    Store a address<>name pair with expiration time

Arguments:

    pAddr - ptr to address
    h - hash value of this address
    Expire - expiration time
    pszName - DNS name

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    int l;

    DBG_ASSERT(g_fEnableRdns);
    memcpy( &m_addr, pAddr, sizeof(m_addr) );
    if ( (l=strlen(pszName)+1) <= sizeof(m_achName) )
    {
        memcpy( m_achName, pszName, l );
    }
    else
    {
        return FALSE;
    }

    m_h = h;
    m_fIsFree = FALSE;
    m_Expire = Expire;

    return TRUE;
}


UINT
RDnsCacheEntry::RemoveFromPrio(
    RDnsCacheEntry* pE
    )
/*++

Routine Description:

    Remove from priority list

Arguments:

    pE - ptr to base of array

Return Value:

    next index in the priority list

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    if ( m_pPrioPrev )
    {
        ENTRYPTR(pE,m_pPrioPrev)->m_pPrioNext = m_pPrioNext;
    }
    if ( m_pPrioNext )
    {
        ENTRYPTR(pE,m_pPrioNext)->m_pPrioPrev = m_pPrioPrev;
    }

    return m_pPrioNext;
}


void
RDnsCacheEntry::InsertInPrioBefore(
    RDnsCacheEntry* pE,
    UINT i
    )
/*++

Routine Description:

    Insert in priority list after specified index

Arguments:

    pE - ptr to base of array
    i - index of element to insert before

Return Value:

    Nothing

--*/
{
    m_pPrioPrev = NULL;

    DBG_ASSERT(g_fEnableRdns);
    if ( i )
    {
        UINT iPrev = ENTRYPTR(pE,i)->m_pPrioPrev;
        ENTRYPTR(pE,i)->m_pPrioPrev = m_iIndex;
        if ( iPrev )
        {
            ENTRYPTR(pE,iPrev)->m_pPrioNext = m_iIndex;
            m_pPrioPrev = iPrev;
        }
    }
    m_pPrioNext = i;
}


UINT
RDnsCacheEntry::RemoveFromHash(
    RDnsCacheEntry* pE
    )
/*++

Routine Description:

    Remove from hash list

Arguments:

    pE - ptr to base of array

Return Value:

    next index in the hash list

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    if ( m_pHashPrev )
    {
        ENTRYPTR(pE,m_pHashPrev)->m_pHashNext = m_pHashNext;
    }
    if ( m_pHashNext )
    {
        ENTRYPTR(pE,m_pHashNext)->m_pHashPrev = m_pHashPrev;
    }

    return m_pHashNext;
}


void
RDnsCacheEntry::InsertInHashBefore(
    RDnsCacheEntry* pE,
    UINT i
    )
/*++

Routine Description:

    Insert in hash list after specified index

Arguments:

    pE - ptr to base of array
    i - index of element to insert before

Return Value:

    Nothing

--*/
{
    m_pHashPrev = NULL;

    DBG_ASSERT(g_fEnableRdns);
    if ( i )
    {
        UINT iPrev = ENTRYPTR(pE,i)->m_pHashPrev;
        ENTRYPTR(pE,i)->m_pHashPrev = m_iIndex;
        if ( iPrev )
        {
            ENTRYPTR(pE,iPrev)->m_pHashNext = m_iIndex;
            m_pHashPrev = iPrev;
        }
    }
    m_pHashNext = i;
}


UINT
RDnsDict::NewEntry(
    struct sockaddr *pAddr,
    DWORD h,
    time_t Expire,
    LPSTR pszName
    )
/*++

Routine Description:

    Store a address<>name pair with expiration time

Arguments:

    pAddr - ptr to address
    h - hash value of this address
    Expire - expiration time
    pszName - DNS name

Return Value:

    index (1-based) of new entry, NULL if error

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    Lock();
    UINT i = GetFreeEntry();

    if ( i )
    {
        RDnsCacheEntry *p = ENTRYPTR(m_pV,i);

        if ( !p->Store( pAddr, h, Expire, pszName ) )
        {
            // put back on free list
            p->InsertInPrioBefore( m_pV, m_FreeList );
            i = NULL;
        }
        else
        {
            p->InsertInPrioBefore( m_pV, m_PrioList );
            p->InsertInHashBefore( m_pV, m_pHash[h] );
            m_pHash[h] = i;
        }

        p->SetIsIp2Dns( TRUE );
    }

    Unlock();

    return i;
}


UINT
RDnsDict::NewDns2IpEntry(
    struct sockaddr *pAddr,
    DWORD h,
    time_t Expire,
    LPSTR pszName
    )
/*++

Routine Description:

    Store a address<>name pair with expiration time

Arguments:

    pAddr - ptr to address
    h - hash value of DNS name
    Expire - expiration time
    pszName - DNS name

Return Value:

    index (1-based) of new entry, NULL if error

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    Lock();
    UINT i = GetFreeEntry();

    if ( i )
    {
        RDnsCacheEntry *p = ENTRYPTR(m_pV,i);

        if ( !p->Store( pAddr, h, Expire, pszName ) )
        {
            // put back on free list
            p->InsertInPrioBefore( m_pV, m_FreeList );
            i = NULL;
        }
        else
        {
            p->InsertInPrioBefore( m_pV, m_PrioList );
            p->InsertInHashBefore( m_pV, m_pDns2IpHash[h] );
            m_pDns2IpHash[h] = i;
        }

        p->SetIsIp2Dns( FALSE );
    }

    Unlock();

    return i;
}


DWORD
RDnsDict::ComputeHash(
    struct sockaddr* pAddr
    )
/*++

Routine Description:

    Compute hash code of address

Arguments:

    pAddr - ptr to address

Return Value:

    Hash code <0...RDNS_HASH_SIZE>

--*/
{
    UINT x;
    UINT l;
    DWORD h = 0;
    LPBYTE p;

    DBG_ASSERT(g_fEnableRdns);
    switch ( pAddr->sa_family )
    {
        case AF_INET:
            l = SIZEOF_IP_ADDRESS;
            p = (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr);
            break;

#if 0
        case AF_IPX:
            l = 6;
            p = (LPBYTE)pAddr->sa_data;
            break;
#endif

        default:
            l = 8;
            p = (LPBYTE)pAddr->sa_data;
            break;
    }

    for ( x = 0 ; x < l ; ++x )
    {
        h = ((h<<5)|(h>>27)) ^ p[x];
    }

    return h % RDNS_HASH_SIZE;
}


DWORD
RDnsDict::ComputeHash(
    LPSTR pszName
    )
/*++

Routine Description:

    Compute hash code of name

Arguments:

    pszName - DNS name

Return Value:

    Hash code <0...RDNS_HASH_SIZE>

--*/
{
    UINT x;
    UINT l;
    DWORD h = 0;
    LPBYTE p;

    DBG_ASSERT(g_fEnableRdns);

    l = strlen( pszName );
    p = (LPBYTE)pszName;

    for ( x = 0 ; x < l ; ++x )
    {
        h = ((h<<5)|(h>>27)) ^ p[x];
    }

    return h % RDNS_HASH_SIZE;
}


BOOL
RDnsDict::Search(
    struct sockaddr* pAddr,
    DWORD h,
    LPSTR pszResult,
    DWORD dwResMaxLen
    )
/*++

Routine Description:

    Search for address in cache

Arguments:

    pAddr - ptr to address
    h - hash code for address
    pszResult - ptr to array updated with name if found
    dwResMaxLen - size of pszResult array

Return Value:

    TRUE if found and stored in pszResult, otherwise FALSE

--*/
{
    UINT i = m_pHash[h];
    RDnsCacheEntry *p;
    BOOL fSt = FALSE;
    time_t tNow = time(NULL);

    DBG_ASSERT(g_fEnableRdns);
    Lock();

    while ( i )
    {
        p = ENTRYPTR(m_pV,i);
        if ( p->MatchAddr( pAddr, tNow ) )
        {
            fSt = p->CopyName( pszResult, dwResMaxLen );

            // update position in LRU list
            p->RemoveFromPrio( m_pV );
            p->InsertInPrioBefore( m_pV, m_PrioList );

            break;
        }
        i = p->GetNextHash();
    }

    Unlock();

    return fSt;
}


BOOL
RDnsDict::SearchByName(
    struct sockaddr* pAddr,
    DWORD h,
    LPSTR pszName
    )
/*++

Routine Description:

    Search for name in cache

Arguments:

    pAddr - ptr to address
    h - hash code for address
    pszName - name to search for

Return Value:

    TRUE if found and stored in pAddr, otherwise FALSE

--*/
{
    UINT i = m_pDns2IpHash[h];
    RDnsCacheEntry *p;
    BOOL fSt = FALSE;
    time_t tNow = time(NULL);

    DBG_ASSERT(g_fEnableRdns);
    Lock();

    while ( i )
    {
        p = ENTRYPTR(m_pV,i);
        if ( p->MatchName( pszName, tNow ) )
        {
            fSt = p->CopyAddr( pAddr );

            // update position in LRU list
            p->RemoveFromPrio( m_pV );
            p->InsertInPrioBefore( m_pV, m_PrioList );

            break;
        }
        i = p->GetNextHash();
    }

    Unlock();

    return fSt;
}


UINT
RDnsDict::GetFreeEntry(
    VOID
    )
/*++

Routine Description:

    Get a free entry in cache array

Arguments:

    None

Return Value:

    index ( 1-based ) of free element to use

--*/
{
    UINT i;
    UINT iN;
    RDnsCacheEntry *p;

    DBG_ASSERT(g_fEnableRdns);
    if ( m_PrioList == NULL || m_FreeList == NULL )
    {
        return NULL;
    }

    i = ENTRYPTR(m_pV,m_FreeList)->GetNextPrio();

    if ( i != m_FreeList )
    {
        ENTRYPTR(m_pV,i)->RemoveFromPrio( m_pV );
        ENTRYPTR(m_pV,i)->Reset();
    }
    else
    {
        if ( i = Append() )
        {
            ENTRYPTR(m_pV,i)->Init( i );
        }
        else
        {
            // get from LRU

            i = ENTRYPTR(m_pV,m_PrioList)->GetNextPrio();

            if ( i != m_PrioList )
            {
                // remove from hash list

                p = ENTRYPTR(m_pV,i);
                p->RemoveFromPrio( m_pV );
                iN = p->RemoveFromHash(m_pV);
                // if hash entry pointed to this element, update hash entry
                if ( p->IsIp2Dns() )
                {
                    if ( m_pHash[p->GetHash()] == i )
                    {
                        m_pHash[p->GetHash()] = iN;
                    }
                }
                else
                {
                    if ( m_pDns2IpHash[p->GetHash()] == i )
                    {
                        m_pDns2IpHash[p->GetHash()] = iN;
                    }
                }
                p->Reset();
            }
            else
            {
                return NULL;
            }
        }
    }

    return i;
}


UINT
RDnsDict::Append(
    VOID
    )
/*++

Routine Description:

    Append an entry to the cache array

Arguments:

    None

Return Value:

    index ( 1-based ) of new element

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    if ( m_cSize + 1 > m_cAlloc )
    {
        int cNew = (( m_cSize + 1 + XBF_EXTEND )/XBF_EXTEND)*XBF_EXTEND;
        if ( cNew*sizeof(RDnsCacheEntry) > g_cCacheSize )
        {
            return NULL;
        }
        LPBYTE pN = (LPBYTE)LocalAlloc( LMEM_FIXED, cNew*sizeof(RDnsCacheEntry) );
        if ( pN == NULL )
        {
            return NULL;
        }
        if ( m_cSize )
        {
            memcpy( pN, m_pV, m_cSize*sizeof(RDnsCacheEntry) );
        }
        if ( m_cAlloc )
        {
            LocalFree( m_pV );
        }
        m_pV = (RDnsCacheEntry*)pN;
        m_cAlloc = cNew;
    }
    return ++m_cSize;
}


void
RDnsDict::FreeEntry(
    UINT i
    )
/*++

Routine Description:

    Free an element in the cache array, put it on free list

Arguments:

    index ( 1-based ) of element to be freed

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);

    UINT iN;
    RDnsCacheEntry *p = ENTRYPTR(m_pV,i);

    iN = p->RemoveFromHash(m_pV);
    // if hash entry pointed to this element, update hash entry
    if ( p->IsIp2Dns() )
    {
        if ( m_pHash[p->GetHash()] == i )
        {
            m_pHash[p->GetHash()] = iN;
        }
    }
    else
    {
        if ( m_pDns2IpHash[p->GetHash()] == i )
        {
            m_pDns2IpHash[p->GetHash()] = iN;
        }
    }
    p->SetFree();

    p->RemoveFromPrio( m_pV );
    p->InsertInPrioBefore( m_pV, m_FreeList );
}


void
RDnsDict::Scavenger(
    VOID
    )
/*++

Routine Description:

    Scavenger code to delete expired entries in the cache array

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    Lock();
    RDnsCacheEntry *p = m_pV;
    UINT i;
    time_t tNow = time(NULL);

    for ( i = 0 ; i < m_cSize ; ++i, ++p )
    {
        if ( p->Expired( tNow ) )
        {
            FreeEntry( i + 1 );
        }
    }

    Unlock();
}


VOID
WINAPI
RDnsScavenger(
    LPVOID
    )
/*++

Routine Description:

    Scavenger function for RDns & Pen

Arguments:

    LPVOID - not used

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    g_RDns.Scavenger();
    
    if ( g_pscPen != NULL )
    {
        g_pscPen->Scavenger();
    }
}


BOOL
InitRDns(
    VOID
    )
/*++

Routine Description:

    Init the Reverse DNS API

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
#if DBG
    //
    // check that RDNS_HASH_SIZE is prime
    //

    UINT x = 2;
    UINT x2;
    for ( x = 2 ; (x2=x*x) <= RDNS_HASH_SIZE; ++x )
    {
        if ( (RDNS_HASH_SIZE/x)*x == RDNS_HASH_SIZE )
        {
            ASSERT( FALSE );
        }
    }
#endif

    HKEY hKey;

    // get cache size, max # threads
    if ( RegOpenKey( HKEY_LOCAL_MACHINE, RDNS_REG_KEY, &hKey )
            == ERROR_SUCCESS )
    {
        DWORD dwType;
        DWORD dwValue;

        DWORD dwSize = sizeof(dwValue);
        if ( RegQueryValueEx( hKey,
                              RDNS_REG_MAX_THREAD,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS
             && dwType == REG_DWORD )
        {
            g_cMaxThreadLimit = dwValue;
        }
        else
        {
            g_cMaxThreadLimit = RDNS_REG_MAX_THREAD_DEF;
        }

        dwSize = sizeof(dwValue);
        if ( RegQueryValueEx( hKey,
                              RDNS_REG_CACHE_SIZE,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS
             && dwType == REG_DWORD )
        {
            g_cCacheSize = dwValue * 1024;
        }
        else
        {
            g_cCacheSize = RDNS_REG_CACHE_SIZE_DEF * 1024;
        }

        dwSize = sizeof(dwValue);
        if ( RegQueryValueEx( hKey,
                              RDNS_REG_TTL,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS
             && dwType == REG_DWORD )
        {
            g_cTTL = dwValue;
        }
        else
        {
            g_cTTL = RDNS_REG_TTL_DEF;
        }

        RegCloseKey( hKey );

    }

    if ( g_RDns.Init() == FALSE )
    {
        return FALSE;
    }

    g_pscPen = new CSidCache;
    if ( g_pscPen == NULL )
    {
        return FALSE;
    }
    g_pscPen->Init();

    g_cAvailableThreads = 0;
    g_cThreads = 0;
    g_hDnsPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,
            NULL,
            NULL,
            g_cMaxThreadLimit );

    g_hThreadsTerminated = IIS_CREATE_EVENT(
                               "g_hThreadsTerminated",
                               &g_hThreadsTerminated,
                               TRUE,
                               FALSE
                               );

    if ( g_hDnsPort == NULL || g_hThreadsTerminated == NULL )
    {
        CloseHandle( g_hDnsPort );
        CloseHandle( g_hThreadsTerminated );
        g_hDnsPort = NULL;
        g_hThreadsTerminated = NULL;
        return FALSE;
    }

    g_dwScavengerWorkItem = ScheduleWorkItem( RDnsScavenger,
                                              NULL,
                                              1000 * RDNS_SCAVENGER_GRANULARITY,
                                              TRUE );

    return TRUE;
}


void
TerminateRDns(
    VOID
    )
/*++

Routine Description:

    Terminate the Reverse DNS API

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT x;

    if ( !g_fEnableRdns ) {
        return;
    }

    //
    // post queued to everybody
    // all threads will dec global count of thread, when 0 set event
    // close port

    if ( g_cThreads )
    {
        for ( x = 0 ; x < g_cThreads ; ++x )
        {
            PostQueuedCompletionStatus( g_hDnsPort, NULL, NULL, NULL );
        }
        WaitForSingleObject( g_hThreadsTerminated, 5 * 1000 );
    }

    CloseHandle( g_hDnsPort );
    CloseHandle( g_hThreadsTerminated );
    g_hDnsPort = NULL;
    g_hThreadsTerminated = NULL;

    if ( g_dwScavengerWorkItem != NULL )
    {
        RemoveWorkItem( g_dwScavengerWorkItem );
        g_dwScavengerWorkItem = NULL;
    }

    g_RDns.Terminate();

    if ( g_pscPen != NULL )
    {
        g_pscPen->Terminate();
        delete g_pscPen;
        g_pscPen = NULL;
    }
}


DWORD WINAPI
AsyncThread(
    LPVOID
    )
/*++

Routine Description:

    Thread handling reverse DNS request

Arguments:

    LPVOID - not used

Return Value:

    Thread exit status

--*/
{
    DWORD dwSize;
    ULONG_PTR dwKey;
    PVOID * ppInfo; 
    DNSARG  pArg;
    struct sockaddr *pAddr;
    struct sockaddr EmptyAddr;
    LPSTR pName;
    CHAR achName[DN_LEN];
    DWORD h;
    BOOL fSt;
    struct hostent* pH;


    DBG_ASSERT(g_fEnableRdns);
    
    while ( GetQueuedCompletionStatus( g_hDnsPort,
            &dwSize,
            &dwKey,
            (LPOVERLAPPED*)&ppInfo,
            (DWORD)-1 ) )
    {
        InterlockedDecrement( &g_cAvailableThreads );

        //
        // if pInfo is NULL it is close request
        //
        
        if ( NULL == ppInfo)
        {
            if ( InterlockedDecrement( (PLONG)&g_cThreads ) == 0)
            {
                SetEvent( g_hThreadsTerminated );
            }
            break;
        }

        pAddr = (struct sockaddr *)ppInfo[0];
        pArg  = ppInfo[1];
        
        switch ( ((PDNSFUNCDESC)dwKey)->dwRequestType )
        {
            case RDNS_REQUEST_TYPE_IP2DNS:
                h = g_RDns.ComputeHash( pAddr );
                fSt = FALSE;

                if ( pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)pAddr)->sin_addr),
                                         SIZEOF_IP_ADDRESS,
                                         PF_INET ) )
                {
                    g_RDns.NewEntry( pAddr, h, time(NULL)+g_cTTL, pH->h_name );
                    fSt = TRUE;
                }
                else
                {
                    //
                    // Create entry with empty name as result of negative search
                    //

                    g_RDns.NewEntry( pAddr, h, time(NULL)+g_cTTL, "" );
                }

                (((PDNSFUNCDESC)dwKey)->pFunc)(pArg, fSt, pH ? pH->h_name : NULL );
                break;

            case RDNS_REQUEST_TYPE_DNS2IP:
                pName = (LPSTR)pAddr;
                h = g_RDns.ComputeHash( pName );
                fSt = FALSE;

                if ( pH = gethostbyname( pName ) )
                {
                    memcpy( &((sockaddr_in*)&EmptyAddr)->sin_addr, pH->h_addr, SIZEOF_IP_ADDRESS );
                    EmptyAddr.sa_family = AF_INET;
                    fSt = TRUE;
                }
                else
                {
                    //
                    // Create entry with null addr as result of negative search
                    //

                    memset( &EmptyAddr, '\0', sizeof(EmptyAddr) );
                }

                g_RDns.NewDns2IpEntry( &EmptyAddr, h, time(NULL)+g_cTTL, pName );
                (((PDNSFUNCDESC)dwKey)->pFunc)(pArg, fSt, (LPSTR)&EmptyAddr );
                break;
        }

        InterlockedIncrement( &g_cAvailableThreads );

        pAddr = NULL;
        pArg  = NULL;

        free(ppInfo);
       
    }

    return 0;
}

//AtqPostCompletionStatus(
//        IN PATQ_CONTEXT patqContext,      from QueryClientConn()->QueryAtqContext()
//        IN DWORD        BytesTransferred  will be 0
//        )

BOOL
AsyncHostByAddr(
    PDNSFUNCDESC pFunc,     // will store DNS name, post dummy completion status
                            // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,            // ptr to be passed to FUNC
    struct sockaddr *pHostAddr,

    BOOL *pfSync,           // updated with TRUE if sync call
    LPSTR pName,
    DWORD dwMaxNameLen
    )
/*++

Routine Description:

    Reverse DNS query

Arguments:

    pFunc - ptr to function to be called for asynchronous result
    pArg - argument to be supplied while calling pFunc
    pHostAddr - address to reverse resolve
    pfSync - updated with TRUE if synchronous result ( i.e. pName updated
             with result if function returns TRUE )
    pName - to be updated with DNS name if synchronous result
    dwMaxNameLen - size of supplied pName buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL fRet = TRUE;
    DWORD h;

    DBG_ASSERT(g_fEnableRdns);

    h = g_RDns.ComputeHash( pHostAddr );

    if ( g_RDns.Search( pHostAddr, h, pName, dwMaxNameLen ) )
    {
        *pfSync = TRUE;
        return TRUE;
    }

    if ( pFunc == NULL || g_cMaxThreadLimit == 0 )
    {
        struct hostent* pH;
        if ( pHostAddr->sa_family == AF_INET &&
             (pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)pHostAddr)->sin_addr),
                                  SIZEOF_IP_ADDRESS,
                                  PF_INET )) )
        {
            UINT l = strlen( pH->h_name ) + 1;
            if ( l <= dwMaxNameLen )
            {
                memcpy( pName, pH->h_name, l );
                fRet = TRUE;
            }
            else
            {
                *pName = '\0';
                fRet = FALSE;
            }
        }
        else
        {
            //
            // Create entry with empty name as result of negative search
            //

            *pName = '\0';
            fRet = FALSE;
        }

        g_RDns.NewEntry( pHostAddr,
                         h,
                         time(NULL)+g_cTTL,
                         pName );

        *pfSync = TRUE;
        return fRet;
    }

    *pfSync = FALSE;

    return FireUpNewThread( pFunc, pArg, (LPVOID)pHostAddr );
}


BOOL
AsyncAddrByHost(
    PDNSFUNCDESC pFunc,     // will store DNS name, post dummy completion status
                            // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,            // ptr to be passed to FUNC
    struct sockaddr *pHostAddr,

    BOOL *pfSync,           // updated with TRUE if sync call
    LPSTR pszName
    )
/*++

Routine Description:

    DNS query

Arguments:

    pFunc - ptr to function to be called for asynchronous result
    pArg - argument to be supplied while calling pFunc
    pHostAddr - to be updated with address
    pfSync - updated with TRUE if synchronous result ( i.e. pName updated
             with result if function returns TRUE )
    pName - to be updated with DNS name if synchronous result

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL fRet = TRUE;
    DWORD h;

    DBG_ASSERT(g_fEnableRdns);

    h = g_RDns.ComputeHash( pszName );

    if ( g_RDns.SearchByName( pHostAddr, h, pszName ) )
    {
        *pfSync = TRUE;
        return TRUE;
    }

    if ( pFunc == NULL || g_cMaxThreadLimit == 0 )
    {
        struct hostent* pH;
        if ( pH = gethostbyname( pszName ) )
        {
            memcpy( &((sockaddr_in*)pHostAddr)->sin_addr, pH->h_addr, pH->h_length );
            pHostAddr->sa_family = AF_INET;
            fRet = TRUE;
        }
        else
        {
            //
            // Create entry with empty name as result of negative search
            //

            memset( pHostAddr, '\0', sizeof(struct sockaddr) );
            fRet = FALSE;
        }

        g_RDns.NewDns2IpEntry( pHostAddr,
                               h,
                               time(NULL)+g_cTTL,
                               pszName );

        *pfSync = TRUE;
        return fRet;
    }

    *pfSync = FALSE;

    return FireUpNewThread( pFunc, pArg, (LPVOID)pszName );
}


BOOL
FireUpNewThread(
    PDNSFUNCDESC pFunc,
    DNSARG pArg,
    LPVOID pOvr
    )
{
    //
    //  If no threads are available, kick a new one off up to the limit
    //

    if ( (g_cAvailableThreads == 0) &&
         (g_cThreads < g_cMaxThreadLimit) )
    {

        HANDLE hThread;
        DWORD  dwThreadID;

        InterlockedIncrement( (PLONG)&g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AsyncThread,
                                NULL,
                                0,
                                &dwThreadID );

        if ( hThread )
        {
            CloseHandle( hThread );     // Free system resources
            InterlockedIncrement( &g_cAvailableThreads );
        }
        else
        {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( (PLONG)&g_cThreads ) == 0)
            {
                return FALSE;
            }
        }
    }

    PVOID * ppInfo = (PVOID *) malloc(2*sizeof(PVOID));

    if (NULL != ppInfo)
    {
        ppInfo[0]   = pOvr;
        ppInfo[1]   = pArg;
    }
    
    BOOL fRet = PostQueuedCompletionStatus( g_hDnsPort,
                                            0,
                                            (ULONG_PTR)pFunc,
                                            (LPOVERLAPPED)ppInfo 
                                            );
    if( !fRet )
    {
        free( ppInfo );
    }
    
    return fRet;
}


#if DBG


typedef struct _TEST_RDNS
{
    LPSTR pIA;
    char achName[32];
    struct sockaddr sa;
} TEST_RDNS;

TEST_RDNS TR[]={
    { "157.55.83.72", "PHILLICH3" },
    { "157.55.91.17", "JOHNL0" },
    { "157.55.84.160", "JOHNSONA" },
    { "157.55.87.80", "MICHTH1" },
    { "157.55.86.54", "MICHTH2" },
} ;

LONG cPending = 0;

void CheckAddr( TEST_RDNS*p, LPSTR a)
{
//    char achErr[80];
//    wsprintf( achErr, "Arg=%d, bool=%d, addr=%s\n", a, f, p );
//    OutputDebugString( achErr );

    int l = strlen( p->achName );
    if ( _memicmp( p->achName, a, l ) )
    {
        ASSERT( FALSE );
    }
}

void pFunc( DNSARG a, BOOL f, LPSTR p)
{
    if ( f )
    {
        CheckAddr( (TEST_RDNS*)a, p );
    }
    else
    {
        char achErr[80];
        wsprintf( achErr, "Failed gethostbyaddr=%s\n", ((TEST_RDNS*)a)->pIA );
        OutputDebugString( achErr );
    }
    InterlockedDecrement( &cPending );
}


DNSFUNCDESC g_TestFunc = { RDNS_REQUEST_TYPE_IP2DNS, pFunc };


void TestRDns()
{
    static struct sockaddr sa;
    BOOL fS;
    UINT x;
    UINT y;
    CHAR achName[64];
    UINT a,b,c,d;


    for ( x = y = 0 ; x < 1000 ; ++x )
    {
        TEST_RDNS *p = TR+y;

        sscanf( p->pIA, "%u.%u.%u.%u", &a, &b, &c, &d );
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_net = (u_char)a;
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_host = (u_char)b;
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_lh = (u_char)c;
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_impno = (u_char)d;
        p->sa.sa_family = AF_INET;

        if ( AsyncHostByAddr(
            (PDNSFUNCDESC)&g_TestFunc,
            (DNSARG)p,
            &p->sa,
            &fS,
            achName,
            sizeof(achName)
            ) )
        {
            if ( fS )
            {
                CheckAddr( p, achName );
            }
            else
            {
                InterlockedIncrement( &cPending );
                Sleep( 500 );
            }
        }
        else
        {
            ASSERT( FALSE );
        }
        if ( ++y == sizeof(TR)/sizeof(TEST_RDNS) )
        {
            y = 0;
        }
    }

    for ( ;; )
    {
        if ( cPending == 0 )
        {
            break;
        }
        Sleep( 1000 );
    }

    OutputDebugString( "Done" );
}
#endif


LPVOID
BsearchEx (
    LPVOID      key,
    LPVOID      base,
    size_t      num,
    size_t      width,
    CMPFUNC     compare,
    LPVOID      param
    )
/*++

Routine Description:

    Binary search with additional parameter to be passed
    to compare routine

Arguments:

    key - ptr to key
    base - ptr to base of array
    num - number of elements in array
    width - size of array element
    compare - compare routine, called with ptr to 2 elements and param
    param - additional parameter presented to the compare routine

Return Value:

    ptr to element in array if key found, else NULL

--*/
{
    char *lo = (char *)base;
    char *hi = (char *)base + (num - 1) * width;
    char *mid;
    unsigned int half;
    int result;

    while (lo <= hi)
        if (half = num / 2)
        {
            mid = lo + (num & 1 ? half : (half - 1)) * width;
            if (!(result = (*compare)(key,mid,param)))
                return(mid);
            else if (result < 0)
            {
                hi = mid - width;
                num = num & 1 ? half : half-1;
            }
            else    {
                lo = mid + width;
                num = half;
            }
        }
        else if (num)
            return((*compare)(key,lo,param) ? NULL : lo);
        else
            break;

    return(NULL);
}


BOOL
ADDRESS_CHECK::BindCheckList(
    LPBYTE p,
    DWORD c
    )
/*++

Routine Description:

    Bind a check list ( presented as a BLOB ) to an
    ADDRESS_CHECK object

Arguments:

    p - ptr to BLOB
    c - size of BLOB

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    PADDRESS_CHECK_LIST pList;
    UINT                l;

    if ( p == NULL )
    {
        if ( m_Storage.Init() && m_Storage.Resize( sizeof(ADDRESS_CHECK_LIST)
                + sizeof(ADDRESS_HEADER) * 2
                + sizeof(NAME_HEADER) * 2 ) )
        {
            DWORD i;
            pList = (PADDRESS_CHECK_LIST)m_Storage.GetAlloc();
                        
                        // BugFix: 47982 Whistler
                        //         Prefix bug pList not being valid.
                        //         EBK 5/5/2000         
                        if (pList)
                        {
                                pList->iDenyAddr = i = MAKEREF( sizeof(ADDRESS_CHECK_LIST) );
                                i += sizeof(ADDRESS_HEADER);
                                pList->iGrantAddr = i;
                                i += sizeof(ADDRESS_HEADER);
                                pList->iDenyName = i;
                                i += sizeof(NAME_HEADER);
                                pList->iGrantName = i;
                                i += sizeof(NAME_HEADER);
                                pList->cRefSize = MAKEOFFSET(i);
                                pList->dwFlags = RDNS_FLAG_DODNS2IPCHECK;

                                return TRUE;
                        }
        }

        return FALSE;
    }
    else
    {
        return m_Storage.Init( p, c );
    }
}


BOOL
ADDRESS_CHECK::SetFlag(
    DWORD   dwFlag,
    BOOL    fEnable
    )
/*++

Routine Description:

    Set flag in address check object

Arguments:

    dwFlag - flag to enable/disable
    fEnable - TRUE to enable, else FALSE

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        if ( fEnable )
        {
            pList->dwFlags |= dwFlag;
        }
        else
        {
            pList->dwFlags &= ~dwFlag;
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
ADDRESS_CHECK::GetFlags(
    )
/*++

Routine Description:

    Get flags in address check object

Arguments:

    None

Return Value:

    Flags if object exists, otherwise 0

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;

        return pList->dwFlags;
    }

    return 0;
}


BOOL
ADDRESS_CHECK::LocateAddr(
    BOOL fGrant,
    DWORD iIndex,
    PADDRESS_HEADER* ppHd,
    PADDRESS_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate an address in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    ppHd - updated with ptr to address header
    pHeader - updated with ptr to address list entry
    piIndexInHeader - updated with index in array addressed by
                      pHeader->iFirstAddress

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            // adjust index by 1: 1st entry is mask
            if ( iIndex < (pHd->Entries[iL].cAddresses-1) )
            {
                *pHeader = pHd->Entries+iL;
                *piIndexInHeader = iIndex+1;
                return TRUE;
            }
            iIndex -= (pHd->Entries[iL].cAddresses-1);
        }
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::GetAddr(
    BOOL fGrant,
    DWORD iIndex,
    LPDWORD pdwFamily,
    LPBYTE* pMask,
    LPBYTE* pAddr
    )
/*++

Routine Description:

    Get an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    pdwFamily - updated with address family ( as in sockaddr.sa_type )
    pMask - updated with ptr to mask
    pAddr - updated with ptr to address

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PADDRESS_LIST_ENTRY pHeader;
    PADDRESS_HEADER     pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateAddr( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        UINT cS = GetAddrSize( pHeader->iFamily );
        *pdwFamily = pHeader->iFamily;
        pStore = MAKEPTR(pStore, pHeader->iFirstAddress);
        *pMask = pStore;
        *pAddr = pStore+iIndexInHeader*cS;

        return TRUE;
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::DeleteAddr(
    BOOL fGrant,
    DWORD iIndex
    )
/*++

Routine Description:

    Delete an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PADDRESS_LIST_ENTRY pHeader;
    PADDRESS_HEADER     pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateAddr( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        UINT cS = GetAddrSize( pHeader->iFamily );
        UINT iS = MAKEOFFSET(pHeader->iFirstAddress)+iIndexInHeader*cS;
        LPBYTE pAddr = MAKEPTR(pStore, iS);

        memmove( pAddr,
                 pAddr + cS,
                 m_Storage.GetUsed() - iS - cS );
        m_Storage.AdjustUsed( -(int)cS );
        --pHeader->cAddresses;
        AdjustRefs( pStore, MAKEOFFSET(pHeader->iFirstAddress)+1, -(int)cS );
        --pHd->cAddresses;
        return TRUE;
    }

    return FALSE;
}


int __cdecl
AddrCmp(
    LPVOID pA,
    LPVOID pB,
    LPVOID pP
    )
/*++

Routine Description:

    Compare 2 address entries.
    uses mask as defined by PADDRCMPDESC pP

Arguments:

    pA - ptr to 1st address entry ( as byte array )
    pB - ptr to 2nd address entry ( as byte array )
    pP - ptr yo ADDRCMDDESC

Return Value:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    PADDRCMPDESC    pacd = (PADDRCMPDESC)pP;
    int             l;
    UINT            a;
    UINT            b;


    if ( pacd->cFullBytes || pacd->LastByte )
    {
        if ( (l = memcmp( pA, pB, pacd->cFullBytes )) )
        {
            return l;
        }

        if ( pacd->LastByte )
        {
            a = ((LPBYTE)pA)[pacd->cFullBytes] & pacd->LastByte;
            b = ((LPBYTE)pB)[pacd->cFullBytes] & pacd->LastByte;

            return a < b ? -1 : ( a==b ? 0 : 1 );
        }

        return 0;
    }
    else
    {
        // bit cmp from pMask
        LPBYTE pM = pacd->pMask;
        LPBYTE pMM = pM + pacd->cSizeAddress;
        for ( ; pM < pMM ; ++pM )
        {
            a = *((LPBYTE)pA) & *pM;
            b = *((LPBYTE)pB) & *pM;
            if ( a<b )
            {
                return -1;
            }
            else if ( a > b )
            {
                return 1;
            }
            pA = (LPVOID)(((LPBYTE)pA) + 1);
            pB = (LPVOID)(((LPBYTE)pB) + 1);
        }
        return 0;
    }
}


int __cdecl
NameCmp(
    LPVOID pA,
    LPVOID pB,
    LPVOID pP
    )
/*++

Routine Description:

    Compare 2 name entries.
    Entry is either defined as a ptr to ASCII ( if equal to NAMECMPDESC.pName )
    or as ptr to DWORD offset in LPSTR array based as NAMECMPDESC.pBase

Arguments:

    pA - ptr to 1st name entry
    pB - ptr to 2nd name entry
    pP - ptr yo NAMECMDDESC

Return Value:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    int             l;
    UINT            a;
    UINT            b;
    PNAMECMPDESC    pncd = (PNAMECMPDESC)pP;
    LPVOID          pName = pncd->pName;
    LPBYTE          pBase = pncd->pBase;


    if ( pA != pName )
    {
        pA = MAKEPTR( pBase, *(DWORD*)pA );
    }
    if ( pB != pName )
    {
        pB = MAKEPTR( pBase, *(DWORD*)pB );
    }

    return _stricmp( (const char*)pA, (const char*)pB );
}


BOOL
ADDRESS_CHECK::AddAddr(
    BOOL fGrant,
    DWORD dwFamily,
    LPBYTE pMask,
    LPBYTE pAddr
    )
/*++

Routine Description:

    Add an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    dwFamily - address family, as in sockaddr.sa_type
    pMask - ptr to mask
    pAddr - ptr to address

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;
    UINT                cS = GetAddrSize( dwFamily );
    LPBYTE              pA;
    ADDRCMPDESC         acd;
    LPBYTE              pS;
    PADDRESS_LIST_ENTRY pE;

    MakeAcd( &acd, pMask, cS );

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( pHd->Entries[iL].iFamily == dwFamily )
            {
                pS = MAKEPTR(pStore, pHd->Entries[iL].iFirstAddress );
                int cm;
                if ( !(cm = memcmp( pMask, pS, cS )) )
                {
                    // found matching family, mask
                    // find where to insert
                    DWORD i;
                    for ( i= 1, cm = 1 ; i < pHd->Entries[iL].cAddresses ; ++i )
                    {
                        if ( !(cm = AddrCmp( pAddr, pS+cS*i, &acd )) )
                        {
                            // already exist
                            return FALSE;
                        }
                        else if ( cm < 0 )
                        {
                            // insert @ i
insert_addr:
                            UINT s = m_Storage.GetUsed();
                            if ( m_Storage.Resize( cS ) )
                            {
                                int l;
                                pStore = m_Storage.GetAlloc();
                                pList = (PADDRESS_CHECK_LIST)pStore;
                                pHd = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
                                pS = MAKEPTR(pStore, l=MAKEOFFSET(pHd->Entries[iL].iFirstAddress+i*cS) );
                                memmove( pS+cS, pS, s-l );
                                memcpy( pS, pAddr, cS );
                                AdjustRefs( pStore, pHd->Entries[iL].iFirstAddress+1, cS );
                                ++pHd->Entries[iL].cAddresses;
                                ++pHd->cAddresses;
                                return TRUE;
                            }
                            return FALSE;
                        }
                    }
                    goto insert_addr;
                }
                else if ( cm < 0 )
                {
insert_at_current_pos:
                    // must insert new Entry @ iL
                    int i = m_Storage.GetUsed()+sizeof(ADDRESS_LIST_ENTRY);
                    UINT cWasUsed = m_Storage.GetUsed();
                    if ( m_Storage.Resize( sizeof(ADDRESS_LIST_ENTRY)+cS*2 ) )
                    {
                        // refresh pointers

                        pStore = m_Storage.GetAlloc();
                        pList = (PADDRESS_CHECK_LIST)pStore;
                        pList->cRefSize += sizeof(ADDRESS_LIST_ENTRY);
                        pHd = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
                        pE = pHd->Entries + iL;

                        // SELFREFINDEX where to insert
                        UINT iS = DIFF((LPBYTE)(pHd->Entries+iL)-pStore);

                        // make room for entry
                        memmove( pE+1,
                                 pE,
                                 cWasUsed-iS );
                        AdjustRefs( pStore, DIFF((LPBYTE)pHd->Entries-pStore), sizeof(ADDRESS_LIST_ENTRY) );

                        // fill entry
                        pE->iFamily = dwFamily;
                        pE->cAddresses = 2;
                        pE->iFirstAddress = MAKEREF( i );
                        pE->cFullBytes = acd.cFullBytes;
                        pE->LastByte = acd.LastByte;

                        // copy mask & addr
                        pA = MAKEPTR( pStore, i );
                        memcpy( pA, pMask, cS );
                        memcpy( pA+cS, pAddr, cS );

                        ++pHd->cEntries;
                        ++pHd->cAddresses;
                        return TRUE;
                    }
                    break;
                }
            }
            else if ( pHd->Entries[iL].iFamily > dwFamily )
            {
                goto insert_at_current_pos;
            }
        }
        goto insert_at_current_pos;
    }

    return FALSE;
}

inline
DWORD
ADDRESS_CHECK::GetNbAddr(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        return pHd->cAddresses;
    }

    return 0;
}


VOID
ADDRESS_CHECK::MakeAcd(
    PADDRCMPDESC pacd,
    LPBYTE pMask,
    UINT cLen
    )
/*++

Routine Description:

    Build a ADDRCMPDESC struct based on ptr to mask and address length

Arguments:

    pacd - ptr to ADDRCMPDESC to build
    pMask - ptr to mask
    cLen - address length

Return Value:

    Nothing

--*/
{
    pacd->pMask = pMask;
    pacd->cFullBytes = 0;
    pacd->LastByte = 0;
    pacd->cSizeAddress = cLen;

    while ( pacd->cFullBytes < cLen &&
            pMask[pacd->cFullBytes] == 0xff )
    {
        ++pacd->cFullBytes;
    }

    if ( pacd->cFullBytes < cLen )
    {
        UINT i;

        pacd->LastByte = pMask[pacd->cFullBytes];
        for ( i = pacd->cFullBytes+1 ; i < cLen ; ++i )
        {
            if ( pMask[i] != 0 )
            {
                // non-standard mask
                pacd->cFullBytes = 0;
                pacd->LastByte = 0;
                break;
            }
        }
    }
}


BOOL
ADDRESS_CHECK::IsMatchAddr(
    BOOL fGrant,
    DWORD dwFamily,
    LPBYTE pAddr
    )
/*++

Routine Description:

    Check if address in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    dwFamily - address family, as in sockaddr.sa_type
    pAddr - ptr to address

Return Value:

    TRUE if address is in specified list, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;
    UINT                cS = GetAddrSize( dwFamily );

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries  ; ++iL )
        {
            if ( dwFamily == pHd->Entries[iL].iFamily )
            {
                ADDRCMPDESC acd;
                LPBYTE pA = MAKEPTR( pStore, pHd->Entries[iL].iFirstAddress );
                acd.cSizeAddress = cS;
                acd.pMask = pA;
                acd.cFullBytes = pHd->Entries[iL].cFullBytes;
                acd.LastByte = pHd->Entries[iL].LastByte;
                if ( BsearchEx( pAddr, pA+cS, pHd->Entries[iL].cAddresses - 1, cS, (CMPFUNC)AddrCmp, &acd ) )
                {
                    return TRUE;
                }
            }
            else if ( dwFamily > pHd->Entries[iL].iFamily )
            {
                break;
            }
        }
    }

    return FALSE;
}


VOID
ADDRESS_CHECK::AdjustRefs(
    LPBYTE pStore,
    DWORD dwCut,
    DWORD dwAdj
    )
/*++

Routine Description:

    Adjust references in ADDRESS_CHECK by offset dwAdj for references
    above or equal to dwCut

Arguments:

    pStore - ptr to address check binary object
    dwCut - references above or equal to this parameter are to be adjusted
            by dwAdj
    dwAdj - offset to add to reference above or equal to dwCut

Return Value:

    Nothing

--*/
{
    LPBYTE pL = pStore + ((PADDRESS_CHECK_LIST)pStore)->cRefSize;
    dwCut = MAKEREF( dwCut );
    for ( ; pStore < pL ; pStore += sizeof(DWORD) )
    {
        if ( *((LPDWORD)pStore) >= dwCut )
        {
            *((LPDWORD)pStore) += dwAdj;
        }
    }
}


UINT
ADDRESS_CHECK::GetAddrSize(
    DWORD dwF
    )
/*++

Routine Description:

    Returns address size in byte based on family ( sockaddr.sa_type )

Arguments:

    dwF - address family ( as in sockaddr.sa_type )

Return Value:

    Address length, in byte. 0 for unknown address families

--*/
{
    DWORD dwS;

    switch ( dwF )
    {
        case AF_INET:
            dwS = SIZEOF_IP_ADDRESS;
            break;

        default:
            dwS = 0;
            break;
    }

    return dwS;
}


BOOL
ADDRESS_CHECK::DeleteAllAddr(
    BOOL fGrant
    )
/*++

Routine Description:

    Delete all address entries in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    while ( DeleteAddr( fGrant, 0 ) )
    {
    }

    return TRUE;
}


BOOL
XAR::Resize(
    DWORD dwDelta
    )
/*++

Routine Description:

    Resize storage by dwDelta.
    This can modify storage ptr, so ptr based on value returned by GetAlloc()
    are invalidated by calling this.

Arguments:

    dwDelta - delta to add ( substract if (int)dwDelta < 0 )
              to storage

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( (int)dwDelta > 0 )
    {
        if ( (m_cUsed + dwDelta > m_cAlloc) )
        {
            UINT cNew = ((m_cUsed+dwDelta+XAR_GRAIN)/XAR_GRAIN)*XAR_GRAIN;
            LPBYTE p = (LPBYTE)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT, cNew );
            if ( p )
            {
                memcpy( p, m_pAlloc, m_cUsed );
                if ( m_fDidAlloc )
                {
                    LocalFree( m_pAlloc );
                }
                m_pAlloc = p;
                m_cAlloc = cNew;
                m_fDidAlloc = TRUE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    m_cUsed += dwDelta;

    return TRUE;
}


AC_RESULT
ADDRESS_CHECK::CheckAddress(
    struct sockaddr*    pAddr
    )
/*++

Routine Description:

    Check if address is in grant or deny list

Arguments:

    pAddr - ptr to address

Return Value:

    TRUE if address is granted access, otherwise FALSE

--*/
{
    LPBYTE p;

    if ( !pAddr || !g_fEnableRdns )
    {
        goto ex;
    }

    // if deny list non empty, check not in list
    switch ( pAddr->sa_family )
    {
        case AF_INET:
            p = (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr);
            break;

        case AF_IPX:
            goto ex;
            //p = (LPBYTE)(((PSOCKADDR)pAddr)->sa_data);
            //break;
    }

    if ( GetNbAddr( FALSE ) )
    {
        if ( IsMatchAddr( FALSE, pAddr->sa_family, p ) )
        {
            return AC_IN_DENY_LIST;
        }
        return AC_NOT_IN_DENY_LIST;
    }

    // if grant list non empty, check in list

    if ( GetNbAddr( TRUE ) )
    {
        if ( IsMatchAddr( TRUE, pAddr->sa_family, p ) )
        {
            return AC_IN_GRANT_LIST;
        }
        return AC_NOT_IN_GRANT_LIST;
    }

ex:
    return AC_NO_LIST;
}


VOID
AddrCheckDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->AddrCheckDnsCallBack( fSt, pDns );
}


VOID
AddrCheckDnsCallBack2(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS2 resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->AddrCheckDnsCallBack2( fSt, (struct sockaddr *)pDns );
}


VOID
AddrCheckDnsCallBack3(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS3 resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->AddrCheckDnsCallBack3( fSt, (struct sockaddr *)pDns );
}


VOID
ResolveDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->ResolveDnsCallBack( fSt, pDns );
}


VOID
ADDRESS_CHECK::AddrCheckDnsCallBack(
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fDnsResolved = TRUE;

    if ( fSt )
    {
        strncpy( m_pszDnsName, pDns, DNS_MAX_NAME_LENGTH );
        m_pszDnsName[ DNS_MAX_NAME_LENGTH ] = '\0';

        if ( !m_Storage.GetAlloc() ||
             (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
        {
            if ( !m_fIpResolved )
            {
                BOOL fSync;
                BOOL St;

                // get IP addr
                St = AsyncAddrByHost(
                        (PDNSFUNCDESC)&g_Dns2Ip,
                        (DNSARG)this,
                        &m_ResolvedAddr,
                        &fSync,
                        m_pszDnsName );

                if ( St )
                {
                    if ( !fSync )
                    {
                        return;
                    }
                    fSt = (!memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                                   (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                                   SIZEOF_IP_ADDRESS ) ||
                              (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS)) &&
                          CheckName( pDns );
                }
                else
                {
                    m_dwErrorResolving = ERROR_INVALID_PARAMETER;
                    fSt = FALSE;
                }
                m_fIpResolved = TRUE;
            }
        }
        else
        {
            fSt = CheckName( pDns );
        }
    }
    else
    {
        m_dwErrorResolving = ERROR_INVALID_PARAMETER;
    }

    (m_HttpReqCallback)( m_HttpReqParam, fSt );
}


VOID
ADDRESS_CHECK::AddrCheckDnsCallBack2(
    BOOL    fSt,
    struct sockaddr*pAddr
    )
/*++

Routine Description:

    Callback routine from reverse DNS2 resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pAddr - address if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fIpResolved = TRUE;

    memcpy( &m_ResolvedAddr, pAddr, sizeof(struct sockaddr*) );

    if ( fSt )
    {
        fSt = (!memcmp( (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr),
                       (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                       SIZEOF_IP_ADDRESS ) ||
                  (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS)) &&
              CheckName( m_pszDnsName );
    }
    else
    {
        m_dwErrorResolving = ERROR_INVALID_PARAMETER;
    }

    (m_HttpReqCallback)( m_HttpReqParam, fSt );
}


VOID
ADDRESS_CHECK::AddrCheckDnsCallBack3(
    BOOL    fSt,
    struct sockaddr*pAddr
    )
/*++

Routine Description:

    Callback routine from reverse DNS3 resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pAddr - address if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fIpResolved = TRUE;

    memcpy( &m_ResolvedAddr, pAddr, sizeof(struct sockaddr*) );

    if ( fSt )
    {
        fSt = !memcmp( (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr),
                       (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                       SIZEOF_IP_ADDRESS ) ||
              (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS);
        if ( !fSt )
        {
            m_pszDnsName[ 0 ] = '\0';
        }
    }

    (m_HttpReqCallbackEx)( m_HttpReqParam, fSt, m_pszDnsName );
}


VOID
ADDRESS_CHECK::ResolveDnsCallBack(
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fDnsResolved = TRUE;

    if ( fSt )
    {
        strncpy( m_pszDnsName, pDns, DNS_MAX_NAME_LENGTH );
        m_pszDnsName[ DNS_MAX_NAME_LENGTH ] = '\0';

        if ( !m_Storage.GetAlloc() ||
             (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
        {
            if ( !m_fIpResolved )
            {
                BOOL fSync;
                BOOL St;

                // get IP addr
                St = AsyncAddrByHost(
                        (PDNSFUNCDESC)&g_ResolveDns2Ip,
                        (DNSARG)this,
                        &m_ResolvedAddr,
                        &fSync,
                        m_pszDnsName );

                if ( St )
                {
                    if ( !fSync )
                    {
                        return;
                    }
                    fSt = (!memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                                   (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                                   SIZEOF_IP_ADDRESS ) ||
                              (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS)) &&
                          CheckName( pDns );
                }
                else
                {
                    fSt = FALSE;
                }
                m_fIpResolved = TRUE;
            }
        }
    }

    (m_HttpReqCallbackEx)( m_HttpReqParam, fSt, pDns );
}


AC_RESULT
ADDRESS_CHECK::CheckAccess(
    LPBOOL           pfSync,
    ADDRCHECKFUNC    pFunc,
    ADDRCHECKARG     pArg
    )
/*++

Routine Description:

    Check that bound address has access to bound check list
    validation can be either synchronous or asynchronous, caller
    must handle both cases.
    If async, caller must be prepared to handle completion notification
    at any time after calling this function.

Arguments:

    pfSync - updated with TRUE if validation was synchronous
             ( i.e. if return value reflect validation status )
    pFunc - ptr to callback routine use if asynchronous validation
    pArg - argument used when calling pFunc

Return Value:

    If sync, TRUE if bound address validated, otherwise FALSE
    If async, TRUE if request successfully queued, otherwise FALSE

--*/
{
    BOOL St;
    AC_RESULT fSt = CheckAddress( m_pAddr );

    if ( fSt == AC_IN_DENY_LIST || fSt == AC_IN_GRANT_LIST )
    {
        *pfSync = TRUE;
        return fSt;
    }

    if ( !GetNbName( TRUE ) && !GetNbName(FALSE) )
    {
        *pfSync = TRUE;
        return fSt;
    }

    if ( !m_fDnsResolved )
    {
        if ( m_pszDnsName == NULL )
        {
            m_pszDnsName = (CHAR*) LocalAlloc( LPTR, DNS_MAX_NAME_LENGTH + 1 );
            if ( m_pszDnsName == NULL )
            {
                *pfSync = TRUE;
                return AC_NOT_CHECKED;
            }
        }

        m_HttpReqCallback = pFunc;
        m_HttpReqParam = pArg;

        // get DNS name
        St = AsyncHostByAddr(
                (PDNSFUNCDESC)&g_Ip2Dns,
                (DNSARG)this,
                m_pAddr,
                pfSync,
                m_pszDnsName,
                DNS_MAX_NAME_LENGTH
                );
        if ( !St || !*pfSync )
        {
            return AC_NOT_CHECKED;
        }
        m_fDnsResolved = TRUE;
    }
    else
    {
        *pfSync = TRUE;
    }

    if ( !m_Storage.GetAlloc() ||
         (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
    {
        if ( !m_fIpResolved )
        {
            // get IP addr
            St = AsyncAddrByHost(
                    (PDNSFUNCDESC)&g_Dns2Ip,
                    (DNSARG)this,
                    &m_ResolvedAddr,
                    pfSync,
                    m_pszDnsName );
            if ( !St || !*pfSync )
            {
                return AC_NOT_CHECKED;
            }
            m_fIpResolved = TRUE;
        }
        if ( memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                     (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                     SIZEOF_IP_ADDRESS ) &&
             (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr != LOCALHOST_ADDRESS))
        {
            return AC_IN_DENY_LIST;
        }
    }

    return CheckName( m_pszDnsName );
}


AC_RESULT
ADDRESS_CHECK::CheckIpAccess(
    LPBOOL pfNeedDns
    )
/*++

Routine Description:

    Check that bound address has access to bound IP check list

Arguments:

    pfNeedDns - updated with TRUE if DNS access check necessary

Return Value:

    returns AC_RESULT

--*/
{
    AC_RESULT ac = CheckAddress( m_pAddr );

    if ( ac != AC_IN_DENY_LIST && ac != AC_IN_GRANT_LIST )
    {
        *pfNeedDns = (GetNbName( TRUE ) || GetNbName(FALSE));
    }
    else
    {
        *pfNeedDns = FALSE;
    }

    return ac;
}

#if 0
AC_RESULT
ADDRESS_CHECK::CheckDnsAccess(
    LPBOOL pfGranted,
    LPBOOL pfIsList
    )
/*++

Routine Description:

    Check that bound DNS name has access to bound DNS check list

Arguments:

    pfGranted - updated with TRUE if access granted, otherwise FALSE
    pfIsList- updated with TRUE if address found in deny/grant list

Return Value:

    return TRUE if no error, otherwise FALSE

--*/
{
    return CheckName( m_pszDnsName );

}
#endif


LPSTR
ADDRESS_CHECK::InitReverse(
    LPSTR pR,
    LPSTR pTarget,
    LPBOOL pfAlloc
    )
/*++

Routine Description:

    Build a reversed DNS representation of supplied DNS name

Arguments:

    pR - DNS name to reverse
    pTarget - ptr to buffer to be used for reverse representation,
              assumed to be SIZE_FAST_REVERSE_DNS byte wide
    pfAlloc - updated with TRUE if memory allocation was necessary
              to hold result. To be presented to TerminateReverse()

Return Value:

    buffer holding reversed representation of DNS name, to be presented
    to TerminateReverse()

--*/
{
    UINT    l = strlen( pR );
    LPSTR   p = pTarget;
    if ( l > SIZE_FAST_REVERSE_DNS )
    {
        if ( (p = (LPSTR)LocalAlloc( LMEM_FIXED, l ))==NULL )
        {
                        // BugFix: 47980, 47981, 47989 Whistler
                        //         Prefix bug pfAlloc not being set.
                        //         EBK 5/5/2000
                        *pfAlloc = FALSE;
            return p;
        }
        *pfAlloc = TRUE;
    }
    else
    {
        *pfAlloc = FALSE;
    }

    // reverse pR to p

    LPSTR pD;
    UINT cS;
    LPSTR pT = p + l;

    *pT = '\0';

    if ( *pR )
    {
        for ( ;; )
        {
            if ( pD = (LPSTR)memchr( pR, '.', l ) )
            {
                cS = DIFF(pD - pR);
            }
            else
            {
                cS = l;
            }

            memcpy( pT - cS, pR, cS );

            if ( pR[cS++] )
            {
                pR += cS;
                pT -= cS;
                *pT = '.';
                l -= cS;
            }
            else
            {
                break;
            }
        }
    }

    return p;
}


VOID
ADDRESS_CHECK::TerminateReverse(
    LPSTR   pAlloc,
    BOOL    fAlloc
    )
/*++

Routine Description:

    Free resources used by InitReverse

Arguments:

    pAlloc - buffer holding result of InitReverse()
    fAlloc - flag updated by InitReverse()

Return Value:

    Nothing

--*/
{
    if ( fAlloc )
    {
        LocalFree( pAlloc );
    }
}


BOOL
ADDRESS_CHECK::CheckReversedName(
    LPSTR            pName
    )
/*++

Routine Description:

    Check if DNS name ( reversed format ) is in grant or deny list

Arguments:

    pName - DNS name

Return Value:

    TRUE if name is granted access, otherwise FALSE

--*/
{
    CHAR    achReversed[SIZE_FAST_REVERSE_DNS];

        // BugFix: 117800, 117809, 117818,  Whistler
        //         Prefix bug fAlloc not being set.
        //         Prefix did not like the fix to just make
        //         sure it was set in InitReverse, so now I 
        //         am initializing it prior to the call.  It's
        //         overkill, but should make prefix happy.
        //         EBK 5/15/2000
    BOOL    fAlloc = FALSE;
    LPSTR   pReversed;
    BOOL    fSt;

    if ( pReversed = InitReverse( pName, achReversed, &fAlloc ) )
    {
        fSt = CheckReversedName( pReversed );
    }
    else
    {
        fSt = FALSE;
    }

    TerminateReverse( pReversed, fAlloc );

    return fSt;
}


AC_RESULT
ADDRESS_CHECK::CheckName(
    LPSTR            pName
    )
/*++

Routine Description:

    Check if DNS name is in grant or deny list

Arguments:

    pName - DNS name

Return Value:

    TRUE if name is granted access, otherwise FALSE

--*/
{
    // if name is empty, it cannot be checked
    if (pName[0] == '\0')
    {
        return AC_NOT_CHECKED;
    }
    
    // if deny list non empty, check not in list

    if ( GetNbName( FALSE ) )
    {
        if ( IsMatchName( FALSE, pName ) )
        {
            return AC_IN_DENY_LIST;
        }
        return AC_NOT_IN_DENY_LIST;
    }

    // if grant list non empty, check in list

    if ( GetNbName( TRUE ) )
    {
        if ( IsMatchName( TRUE, pName ) )
        {
            return AC_IN_GRANT_LIST;
        }
        return AC_NOT_IN_GRANT_LIST;
    }

    return AC_NO_LIST;
}


UINT
ADDRESS_CHECK::GetNbComponent(
    LPSTR pName
    )
/*++

Routine Description:

    Returns number of components in DNS name

Arguments:

    pName - DNS name

Return Value:

    Number of components.

--*/
{
    LPSTR   pDot = pName;
    UINT    cComp;

    for ( cComp = 1 ; pDot = strchr( pDot, '.') ; ++cComp )
    {
        ++pDot;
    }

    return cComp;
}


BOOL
ADDRESS_CHECK::AddReversedName(
    BOOL fGrant,
    LPSTR pName
    )
/*++

Routine Description:

    Add a name entry, reversing its DNS components

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    pName - ptr to DNS name

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CHAR    achReversed[SIZE_FAST_REVERSE_DNS];
        // BugFix: 117800, 117809, 117818,  Whistler
        //         Prefix bug fAlloc not being set.
        //         Prefix did not like the fix to just make
        //         sure it was set in InitReverse, so now I 
        //         am initializing it prior to the call.  It's
        //         overkill, but should make prefix happy.
        //         EBK 5/15/2000
    BOOL    fAlloc = FALSE;
    LPSTR   pReversed;
    BOOL    fSt;

    if ( pReversed = InitReverse( pName, achReversed, &fAlloc ) )
    {
        fSt = AddName( fGrant, pReversed );
    }
    else
    {
        fSt = FALSE;
    }

    TerminateReverse( pReversed, fAlloc );

    return fSt;
}


BOOL
ADDRESS_CHECK::AddName(
    BOOL    fGrant,
    LPSTR   pName,
    DWORD   dwFlags
    )
/*++

Routine Description:

    Add a name entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    pName - ptr to DNS name
    dwFlags - flags

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    UINT                iL;
    UINT                cS = GetNbComponent( pName ) | ( dwFlags & DNSLIST_FLAG_NOSUBDOMAIN );
    UINT                cN = strlen( pName ) + 1;
    LPBYTE              pA;
    LPBYTE              pS;
    PNAME_LIST_ENTRY    pE;
    UINT                iS;
    int                 cm;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( pE->cComponents == cS )
            {
                // found matching family, mask
                // find where to insert
                DWORD i;
                for ( i= 0 ; i < pE->cNames ; ++i )
                {
                    pS = MAKEPTR(pStore, pE->iName[i] );
                    if ( !(cm = _stricmp( pName, (LPSTR)pS )) )
                    {
                        // already exist
                        return FALSE;
                    }
                    else if ( cm < 0 )
                    {
                        // insert @ i
insert_name:
                        UINT s = m_Storage.GetUsed();
                        iS = DIFF((LPBYTE)pE - pStore);
                        if ( m_Storage.Resize( sizeof(SELFREFINDEX)+cN ) )
                        {
                            int l;
                            // refresh ptrs
                            pStore = m_Storage.GetAlloc();
                            pList = (PADDRESS_CHECK_LIST)pStore;
                            pHd = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
                            pE = (PNAME_LIST_ENTRY)(pStore+iS);

                            pS = MAKEPTR(pStore, l=DIFF((LPBYTE)(pE->iName+i)-pStore) );
                            memmove( pS+sizeof(SELFREFINDEX), pS, s-l );
                            pList->cRefSize += sizeof(SELFREFINDEX);
                            AdjustRefs( pStore, l, sizeof(SELFREFINDEX) );
                            s+=sizeof(SELFREFINDEX);
                            pE->iName[i] = MAKEREF(s);
                            memcpy( MAKEPTR(pStore,s), pName, cN );
                            ++pE->cNames;
                            ++pHd->cNames;
                            return TRUE;
                        }
                        return FALSE;
                    }
                }
                goto insert_name;
            }
            else if ( cS < pE->cComponents )
            {
insert_at_current_pos:
                // must insert new Entry @ pE
                int i = m_Storage.GetUsed()+sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX);
                UINT iS = DIFF((LPBYTE)pE - pStore);
                UINT cWasUsed = m_Storage.GetUsed();
                if ( m_Storage.Resize( sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX)+cN ) )
                {
                    // refresh ptrs
                    pStore = m_Storage.GetAlloc();
                    pList = (PADDRESS_CHECK_LIST)pStore;
                    pHd = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
                    pE = (PNAME_LIST_ENTRY)(pStore +iS);
                    pList->cRefSize += sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX);

                    // make room for entry
                    memmove( (LPBYTE)(pE+1) + sizeof(SELFREFINDEX),
                             pE,
                             cWasUsed - iS );
                    AdjustRefs( pStore, iS, sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX) );

                    pE->cComponents = cS;
                    pE->cNames = 1;
                    pE->iName[0] = MAKEREF( i );

                    // copy name
                    pA = MAKEPTR( pStore, i );
                    memcpy( pA, pName, cN );

                    ++pHd->cEntries;
                    ++pHd->cNames;
                    return TRUE;
                }
                break;
            }
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
        goto insert_at_current_pos;
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::DeleteName(
    BOOL fGrant,
    DWORD iIndex
    )
/*++

Routine Description:

    Delete a DNS name entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PNAME_LIST_ENTRY    pE;
    PNAME_HEADER        pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateName( fGrant, iIndex, &pHd, &pE, &iIndexInHeader ) )
    {
        UINT iS = MAKEOFFSET( pE->iName[iIndexInHeader] );
        LPBYTE pAddr = MAKEPTR(pStore, iS);
        UINT cS = strlen( (LPSTR)pAddr ) + 1;

        memmove( pAddr,
                 pAddr + cS,
                 m_Storage.GetUsed() - iS - cS );
        AdjustRefs( pStore, iS, -(int)cS );
        m_Storage.AdjustUsed( -(int)cS );

        iS = DIFF((LPBYTE)(pE->iName+iIndexInHeader) - pStore);
        memmove( pE->iName+iIndexInHeader,
                 pE->iName+iIndexInHeader+1,
                 m_Storage.GetUsed() - iS - sizeof(SELFREFINDEX) );
        ((PADDRESS_CHECK_LIST)pStore)->cRefSize -= sizeof(SELFREFINDEX);
        AdjustRefs( pStore, DIFF((LPBYTE)pE - pStore), (DWORD)-(int)sizeof(SELFREFINDEX) );
        m_Storage.AdjustUsed( -(int)sizeof(SELFREFINDEX) );

        --pE->cNames;
        --pHd->cNames;

        return TRUE;
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::GetReversedName(
    BOOL fGrant,
    DWORD iIndex,
    LPSTR pName,
    LPDWORD pdwSize
    )
/*++

Routine Description:

    Get DNS name in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index (0-based) in specified list
    pName - ptr to buffer to be used to hold result
    pdwSize - in: specify buffer max length. out: result size
              ( including '\0' delimiter )

Return Value:

    TRUE if iIndex valid in specified list and buffer wide enough
    to hold result, FALSE otherwise ( can be ERROR_NOT_ENOUGH_MEMORY,
    ERROR_INVALID_PARAMETER )

--*/
{
    CHAR    achReversed[SIZE_FAST_REVERSE_DNS];

        // BugFix: 117800, 117809, 117818,  Whistler
        //         Prefix bug fAlloc not being set.
        //         Prefix did not like the fix to just make
        //         sure it was set in InitReverse, so now I 
        //         am initializing it prior to the call.  It's
        //         overkill, but should make prefix happy.
        //         EBK 5/15/2000
    BOOL    fAlloc = FALSE;
    LPSTR   pReversed;
    BOOL    fSt = FALSE;
    LPSTR   pRName;

    if ( GetName( fGrant, iIndex, &pRName ) )
    {
        if ( pReversed = InitReverse( pRName, achReversed, &fAlloc ) )
        {
            UINT l = strlen( pReversed ) + 1;
            if ( l <= *pdwSize )
            {
                memcpy( pName, pReversed, l );
                fSt = TRUE;
            }
            else
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }
            *pdwSize = l;
        }
        else
        {
            SetLastError( 0 );
            *pdwSize = 0;
        }

        TerminateReverse( pReversed, fAlloc );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        *pdwSize = 0;
    }

    return fSt;
}


BOOL
ADDRESS_CHECK::GetName(
    BOOL        fGrant,
    DWORD       iIndex,
    LPSTR*      ppName,
    LPDWORD     pdwFlags
    )
/*++

Routine Description:

    Get DNS name in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index (0-based) in specified list
    ppName - updated with ptr to DNS name
    pdwFlags - updated with DNS flags, can be NULL

Return Value:

    TRUE if iIndex valid in specified list, otherwise FALSE

--*/
{
    PNAME_LIST_ENTRY    pHeader;
    PNAME_HEADER        pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateName( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        *ppName = (LPSTR)MAKEPTR(pStore, pHeader->iName[iIndexInHeader] );
        if ( pdwFlags )
        {
            *pdwFlags = pHeader->cComponents & DNSLIST_FLAGS;
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
ADDRESS_CHECK::GetNbName(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        return pHd->cNames;
    }

    return 0;
}


BOOL
ADDRESS_CHECK::LocateName(
    BOOL fGrant,
    DWORD iIndex,
    PNAME_HEADER* ppHd,
    PNAME_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate a name in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list ( 0-based )
    ppHd - updated with ptr to name header
    pHeader - updated with ptr to name list entry
    piIndexInHeader - updated with index in array pHeader->iName

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    PNAME_LIST_ENTRY    pE;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( iIndex < pE->cNames )
            {
                *pHeader = pE;
                *piIndexInHeader = iIndex;
                return TRUE;
            }
            iIndex -= pE->cNames;
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::DeleteAllName(
    BOOL fGrant
    )
/*++

Routine Description:

    Delete all DNS name entries

Arguments:

    fGrant - TRUE to delete in grant list, FALSE for deny list

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    while ( DeleteName( fGrant, 0 ) )
    {
    }

    return TRUE;
}


BOOL
ADDRESS_CHECK::IsMatchName(
    BOOL fGrant,
    LPSTR pName
    )
/*++

Routine Description:

    Check if name in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    pName - ptr to DNS name

Return Value:

    TRUE if name is in specified list, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    PNAME_LIST_ENTRY    pE;
    UINT                iL;
    UINT                cS;
    NAMECMPDESC         ncd;
    DWORD               cbNameLength;
    BOOL                fTryAgain = FALSE;
    CHAR                achName[ DNS_MAX_NAME_LENGTH + 1 ];
    
    ncd.pBase = pStore;

    if ( pStore )
    {
        strncpy( achName, pName, DNS_MAX_NAME_LENGTH );
        achName[ DNS_MAX_NAME_LENGTH ] = '\0';
        
        cbNameLength = strlen( achName );
        pName = achName; 

        // BugFix: 47983 Whistler
        //         Prefix bug pName not being valid.
        //         EBK 5/5/2000         
        DBG_ASSERT(cbNameLength >= 1);
        
        if ( pName && pName[ cbNameLength - 1 ] == '.' )
        {
            // This is an FQDN (i.e. it has a period at the end).  
            // We need to be more careful with our handling of it, since we want
            // to match against checks which didn't specify the trailing period.
        
            fTryAgain = TRUE;
     
            // Temporarily remove the trailing period
        
            pName[ cbNameLength - 1 ] = '\0';
        }
TryAgain:
        /* INTRINSA suppress = uninitialized */
        cS = GetNbComponent( pName );

        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries  ; ++iL )
        {
            UINT cASComp = pE->cComponents & ~DNSLIST_FLAGS;
            if ( cS == cASComp ||
                 ((cS > cASComp) && !(pE->cComponents & DNSLIST_FLAG_NOSUBDOMAIN)) )
            {
                LPSTR p = pName;
                BOOL fSt;
                if ( cS > cASComp )
                {
                    int i = cS - cASComp;
                    for ( ; i-- ; )
                    {
                        if ( p = strchr( p, '.' ) )
                        {
                            ++p;
                        }
                    }
                }
                ncd.pName = (LPVOID)p;

                fSt = BsearchEx( p,
                                 pE->iName,
                                 pE->cNames,
                                 sizeof(SELFREFINDEX),
                                 (CMPFUNC)NameCmp,
                                 &ncd ) != NULL;
                if ( fSt )
                {
                    return TRUE;
                }
            }
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
        
        if ( fTryAgain )
        {
            fTryAgain = FALSE;
            
            pName[ cbNameLength - 1 ] = '.';
            goto TryAgain;
        }
    }

    return FALSE;
}

#if 0 // inlined now

BOOL
ADDRESS_CHECK::BindAddr(
    struct sockaddr* pAddr
    )
/*++

Routine Description:

    Bind an address to an ADDRESS_CHECK object

Arguments:

    pAddr - ptr to address

Return Value:

    TRUE if sucess, FALSE otherwise

--*/
{
    m_pAddr = pAddr;
    m_fDnsResolved = FALSE;
    m_fIpResolved = FALSE;
    m_dwErrorResolving = 0;

    return TRUE;
}


VOID
ADDRESS_CHECK::UnbindAddr(
    VOID
    )
/*++

Routine Description:

    Unbind an address to an ADDRESS_CHECK object

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_pAddr = NULL;
    m_fDnsResolved = FALSE;
}

# endif // 0

BOOL
ADDRESS_CHECK::QueryDnsName(
    LPBOOL           pfSync,
    ADDRCHECKFUNCEX  pFunc,
    ADDRCHECKARG     pArg,
    LPSTR *          ppName
    )
/*++

Routine Description:

    Reverse resolve bound address to DNS name

Arguments:

    pfSync - updated with TRUE if validation was synchronous
             ( i.e. if return value reflect validation status )
    pFunc - ptr to callback routine use if asynchronous validation
    pArg - argument used when calling pFunc

Return Value:

    If sync, TRUE if bound address validated, otherwise FALSE
    If async, TRUE if request successfully queued, otherwise FALSE

--*/
{
    BOOL fSt;

    if ( !m_pAddr )
    {
        return FALSE;
    }

    if ( !m_fDnsResolved )
    {
        if ( m_pszDnsName == NULL )
        {
            m_pszDnsName = (CHAR*) LocalAlloc( LPTR, DNS_MAX_NAME_LENGTH + 1 );
            if ( m_pszDnsName == NULL )
            {
                return FALSE;
            }
        }

        m_HttpReqCallbackEx = pFunc;
        m_HttpReqParam = pArg;

        // get DNS name
        fSt = AsyncHostByAddr(
            (PDNSFUNCDESC)(pFunc ? &g_ResolveDns : NULL),
                (DNSARG)this,
                m_pAddr,
                pfSync,
                m_pszDnsName,
                DNS_MAX_NAME_LENGTH
                );
        if ( !fSt || !*pfSync )
        {
            return fSt;
        }
        m_fDnsResolved = TRUE;
        
        if ( m_pszDnsName[ 0 ] == '\0' )
        {
            m_dwErrorResolving = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
    }
    else
    {
        *pfSync = TRUE;
    }

    if ( !m_Storage.GetAlloc() ||
         (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
    {
        if ( !m_fIpResolved )
        {
            m_HttpReqCallbackEx = pFunc;
            m_HttpReqParam = pArg;

            // get IP addr
            fSt = AsyncAddrByHost(
                (PDNSFUNCDESC)(pFunc ? &g_ResolveDns2Ip : NULL),
                    (DNSARG)this,
                    &m_ResolvedAddr,
                    pfSync,
                    m_pszDnsName );
            if ( !fSt || !*pfSync )
            {
                return fSt;
            }
            m_fIpResolved = TRUE;
            if ( !memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                          (LPBYTE)NULL_IP_ADDR,
                          SIZEOF_IP_ADDRESS ) )
            {
                m_dwErrorResolving = ERROR_INVALID_PARAMETER;
                return FALSE;
            }
        }
        if ( memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                     (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                     SIZEOF_IP_ADDRESS ) && 
             (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr != LOCALHOST_ADDRESS ) )
        {
            m_pszDnsName[ 0 ] = '\0';
            return FALSE;
        }
    }

    *ppName = m_pszDnsName;

    return TRUE;
}


BOOL
CSidCache::Init(
    VOID
    )
/*++

Routine Description:

    Initialize SID cache object

Arguments:

    None

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    INITIALIZE_CRITICAL_SECTION( &csLock );

    return TRUE;
}


VOID
CSidCache::Terminate(
    VOID
    )
/*++

Routine Description:

    Terminate SID cache object

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DeleteCriticalSection( &csLock );
}


BOOL
CSidCache::AddToCache(
    PSID pSid,
    DWORD dwTTL
    )
/*++

Routine Description:

    Add SID entry to cache

Arguments:

    pSid - SID to add to cache
    dwTTL - Time to Live ( in seconds ) in cache

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    BOOL fSt = TRUE;

    EnterCriticalSection( &csLock );

    if ( !IsInCache( pSid ) )
    {
        DWORD dwL = GetLengthSid( pSid );
        DWORD dwWas = xaStore.GetUsed();
        if ( xaStore.Resize( sizeof(SID_CACHE_ENTRY) + dwL ) )
        {
            PSID_CACHE_ENTRY pB = (PSID_CACHE_ENTRY)(xaStore.GetAlloc()
                                                     + dwWas );
            pB->tExpire = (DWORD)(time(NULL) + dwTTL);
            pB->dwSidLen = dwL;
            memcpy( pB->Sid, pSid, dwL );
        }
        else
        {
            fSt = FALSE;
        }
    }

    LeaveCriticalSection( &csLock );

    return fSt;
}


BOOL
CSidCache::IsInCache(
    PSID  pSid
    )
/*++

Routine Description:

    Check if SID present and in cache

Arguments:

    pSid - SID to add to cache

Return Value:

    TRUE if found, FALSE otherwise

--*/
{
    return CheckPresentAndResetTtl( pSid, 0xffffffff );
}


BOOL
CSidCache::CheckPresentAndResetTtl(
    PSID  pSid,
    DWORD dwTtl
    )
/*++

Routine Description:

    Check if SID present and in cache and if found
    update its TTL

Arguments:

    pSid - SID to add to cache
    dwTTL - Time to Live ( in seconds ) in cache

Return Value:

    TRUE if found, FALSE otherwise

--*/
{
    // walk through xaStore,
    BOOL fSt = FALSE;

    EnterCriticalSection( &csLock );

    PSID_CACHE_ENTRY pB = (PSID_CACHE_ENTRY)(xaStore.GetAlloc() );
    PSID_CACHE_ENTRY pM = (PSID_CACHE_ENTRY)(xaStore.GetAlloc()
                                             + xaStore.GetUsed());

    if ( pB )
    {
        while ( pB < pM )
        {
            if ( EqualSid( (PSID)(pB->Sid), pSid ) )
            {
                if ( dwTtl != 0xffffffff )
                {
                    pB->tExpire = (DWORD)(time(NULL) + dwTtl);
                }
                fSt = TRUE;
                break;
            }
            pB = (PSID_CACHE_ENTRY)( (LPBYTE)pB + pB->dwSidLen + sizeof(SID_CACHE_ENTRY) );
        }
    }

    LeaveCriticalSection( &csLock );

    return fSt;
}


BOOL
CSidCache::Scavenger(
    VOID
    )
/*++

Routine Description:

    Remove expired entries from cache based on TTL

Arguments:

    None

Return Value:

    TRUE if no error, FALSE otherwise

--*/
{
    // walk through xaStore,
    BOOL fSt = TRUE;

    EnterCriticalSection( &csLock );

    PSID_CACHE_ENTRY pB = (PSID_CACHE_ENTRY)(xaStore.GetAlloc() );
    PSID_CACHE_ENTRY pM = (PSID_CACHE_ENTRY)(xaStore.GetAlloc()
                                             + xaStore.GetUsed());
    DWORD tNow = (DWORD)(time(NULL));
    DWORD dwAdj = 0;

    if ( pB )
    {
        while ( pB < pM )
        {
            DWORD dwL = pB->dwSidLen+sizeof(SID_CACHE_ENTRY);
            if ( pB->tExpire <= tNow )
            {
                dwAdj += dwL;
            }
            else if ( dwAdj )
            {
                memmove( (LPBYTE)pB-dwAdj,
                         pB,
                         dwL );
            }
            pB = (PSID_CACHE_ENTRY)( (LPBYTE)pB + dwL );
        }
        xaStore.AdjustUsed( -(int)dwAdj );
    }

    LeaveCriticalSection( &csLock );

    return fSt;
}


#if DBG
VOID
ADDRESS_CHECK::DumpAddr(
    BOOL fGrant
    )
{
    UINT i = GetNbAddr( fGrant );
    UINT x;
    for ( x = 0 ; x < i ; ++x )
    {
        LPBYTE pM;
        LPBYTE pA;
        DWORD dwF;
        GetAddr( fGrant, x, &dwF, &pM, &pA );

        CHAR achE[80];
        wsprintf( achE, "%d.%d.%d.%d %d.%d.%d.%d\r\n",
            pM[0], pM[1], pM[2], pM[3],
            pA[0], pA[1], pA[2], pA[3] );
        OutputDebugString( achE );
    }
}


VOID
ADDRESS_CHECK::DumpName(
    BOOL fGrant
    )
{
    UINT i = GetNbName( fGrant );
    UINT x;
    for ( x = 0 ; x < i ; ++x )
    {
        //CHAR achN[80];
        //DWORD dwN = sizeof(achN);
        LPSTR pN;
        GetName( fGrant, x, &pN );  //achN, &dwN );
        OutputDebugString( pN );
        OutputDebugString( "\r\n" );
    }
}


VOID
ADDRESS_CHECK::DumpAddrAndName(
    VOID
    )
{
    OutputDebugString( "Addr granted:\r\n" );
    DumpAddr( TRUE );
    OutputDebugString( "Addr denied:\r\n" );
    DumpAddr( FALSE );

    OutputDebugString( "Name granted:\r\n" );
    DumpName( TRUE );
    OutputDebugString( "Name denied:\r\n" );
    DumpName( FALSE );
}


void CaBack( ADDRCHECKARG pArg, BOOL f )
{
    CHAR achE[80];
    wsprintf( achE, "pArg=%08x, BOOL = %d\r\n", pArg, f );
    OutputDebugString( achE );
}


VOID TestAPI()
{
    ADDRESS_CHECK *pac=new ADDRESS_CHECK;

    pac->BindCheckList();

    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x55\x66\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x44\x66\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x55\x77\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x55\x66\x77\x88" );  // should fail
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\x00\x0\x0", (LPBYTE)"\x55\x66\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\xff\x0",(LPBYTE)"\x55\x66\x77\x88" );

    UINT i = pac->GetNbAddr( TRUE );
    UINT x;
    for ( x = 0 ; x < i ; ++x )
    {
        LPBYTE pM;
        LPBYTE pA;
        DWORD dwF;
        pac->GetAddr( TRUE, x, &dwF, &pM, &pA );
    }

    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );   // should fail
    pac->DeleteAddr( TRUE, 0 );
    pac->DeleteAddr( TRUE, 0 );   // should fail

    // names

    pac->AddName( TRUE, "msft.com" );
    pac->AddName( TRUE, "msft.com" ); // should fail
    pac->AddName( TRUE, "fr" );
    pac->AddName( TRUE, "www.sunw.com" );
    pac->AddName( TRUE, "ftp.sunw.com" );
    pac->AddName( TRUE, "aapl.com" );

    i = pac->GetNbName( TRUE );
    x;
    for ( x = 0 ; x < i ; ++x )
    {
        //CHAR achN[80];
        //DWORD dwN = sizeof(achN);
        LPSTR pN;
        pac->GetName( TRUE, x, &pN );  //achN, &dwN );
    }

    pac->CheckName( "msft.com" );

    sockaddr* psa = new sockaddr;
    BOOL fInList;
    psa->sa_family = AF_INET;
    memcpy( (&((PSOCKADDR_IN)psa)->sin_addr), "\x44\x66\xaa\xbb", SIZEOF_IP_ADDRESS );
    pac->CheckAddress( psa );

    BOOL fSync;
    psa->sa_family = AF_INET;
    memcpy( (&((PSOCKADDR_IN)psa)->sin_addr), "\x9d\x37\x53\x48", SIZEOF_IP_ADDRESS );    // PHILLICH3
    pac->BindAddr( psa );
    pac->CheckAccess( &fSync, (ADDRCHECKFUNC)CaBack, (ADDRCHECKARG)NULL );

//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );   // should fail
//    pac->DeleteName( TRUE, 0 );
//    pac->DeleteName( TRUE, 0 );   // should fail
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\sec\secobj.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    secobj.c

Abstract:

    This module provides support routines to simplify the creation of
    security descriptors for user-mode objects.

    Adapted the code from \nt\private\net\netlib\secobj.h

Author:

    Rita Wong (ritaw) 27-Feb-1991

Environment:

    Contains NT specific code.

Revision History:

    16-Apr-1991 JohnRo
        Include header files for <netlib.h>.

    14 Apr 1992 RichardW
        Changed for modified ACE_HEADER struct.

    19 Sep. 1995 MadanA
        Adapted the code for the internet project and made to use WIN32
        APIs instead RTL functions.

--*/

#include <windows.h>
#include <rpc.h>

#include <inetsec.h>
#include <proto.h>

#if DBG
#define STATIC
#else
#define STATIC static
#endif // DBG

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// NT well-known SIDs
//

PSID NullSid = NULL;                  // No members SID
PSID WorldSid = NULL;                 // All users SID
PSID LocalSid = NULL;                 // NT local users SID
PSID NetworkSid = NULL;               // NT remote users SID
PSID LocalSystemSid = NULL;           // NT system processes SID
PSID BuiltinDomainSid = NULL;         // Domain Id of the Builtin Domain

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

PSID LocalAdminSid = NULL;            // NT local admins SID
PSID AliasAdminsSid = NULL;
PSID AliasUsersSid = NULL;
PSID AliasGuestsSid = NULL;
PSID AliasPowerUsersSid = NULL;
PSID AliasAccountOpsSid = NULL;
PSID AliasSystemOpsSid = NULL;
PSID AliasPrintOpsSid = NULL;
PSID AliasBackupOpsSid = NULL;

STATIC
struct _SID_DATA {
    PSID *Sid;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG SubAuthority;
} SidData[] = {
 {&NullSid,          SECURITY_NULL_SID_AUTHORITY,  SECURITY_NULL_RID},
 {&WorldSid,         SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID},
 {&LocalSid,         SECURITY_LOCAL_SID_AUTHORITY, SECURITY_LOCAL_RID},
 {&NetworkSid,       SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_RID},
 {&LocalSystemSid,   SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SYSTEM_RID},
 {&BuiltinDomainSid, SECURITY_NT_AUTHORITY,        SECURITY_BUILTIN_DOMAIN_RID}
};

STATIC
struct _BUILTIN_DOMAIN_SID_DATA {
    PSID *Sid;
    ULONG RelativeId;
} BuiltinDomainSidData[] = {
    { &LocalAdminSid, DOMAIN_ALIAS_RID_ADMINS},
    { &AliasAdminsSid, DOMAIN_ALIAS_RID_ADMINS },
    { &AliasUsersSid, DOMAIN_ALIAS_RID_USERS },
    { &AliasGuestsSid, DOMAIN_ALIAS_RID_GUESTS },
    { &AliasPowerUsersSid, DOMAIN_ALIAS_RID_POWER_USERS },
    { &AliasAccountOpsSid, DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { &AliasSystemOpsSid, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { &AliasPrintOpsSid, DOMAIN_ALIAS_RID_PRINT_OPS },
    { &AliasBackupOpsSid, DOMAIN_ALIAS_RID_BACKUP_OPS }
};

PVOID
INetpMemoryAllocate(
    DWORD Size
    )
/*++

Routine Description:

    This function allocates the required size of memory by calling
    LocalAlloc.

Arguments:

    Size - size of the memory block required.

Return Value:

    Pointer to the allocated block.

--*/
{

    LPVOID NewPointer;

    NewPointer = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size );

#if DBG
    // ASSERT( NewPointer != NULL );
#endif

    return( NewPointer );
}

VOID
INetpMemoryFree(
    PVOID Memory
    )
/*++

Routine Description:

    This function frees up the memory that was allocated by
    InternetAllocateMemory.

Arguments:

    Memory - pointer to the memory block that needs to be freed up.

Return Value:

    none.

--*/
{

    LPVOID Ptr;

#if DBG
    // ASSERT( Memory != NULL );
#endif

    Ptr = LocalFree( Memory );

#if DBG
    // ASSERT( Ptr == NULL );
#endif
}

DWORD
INetpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    WIN32 Error Code.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    if( CopySid(
            GetLengthSid(AllowedSid), // should be valid SID ??
            &(AllowedAce->SidStart),
            AllowedSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

DWORD
INetpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    WIN32 Error Code.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    if( CopySid(
            GetLengthSid(DeniedSid), // should be valid SID ??
            &(DeniedAce->SidStart),
            DeniedSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

DWORD
INetpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    WIN32 Error Code.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    if( CopySid(
               GetLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}
DWORD
INetpAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    )
/*++

Routine Description:

    This function allocates memory for a SID and initializes it.

Arguments:

    None.

Return Value:

    WIN32 Error Code.

--*/
{
    *Sid = (PSID)
        INetpMemoryAllocate(
            GetSidLengthRequired( (BYTE)SubAuthorityCount) );

    if (*Sid == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeSid( *Sid, IdentifierAuthority, (BYTE)SubAuthorityCount );

    return( ERROR_SUCCESS );
}

DWORD
INetpDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Given a domain Id and a relative ID create a SID

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

    Sid - Returns a pointer to an allocated buffer containing the resultant
            Sid.  Free this buffer using NetpMemoryFree.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD Error;
    BYTE DomainIdSubAuthorityCount; // Number of sub authorities in domain ID
    ULONG SidLength;    // Length of newly allocated SID

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(GetSidSubAuthorityCount( DomainId ));

    SidLength = GetSidLengthRequired( (BYTE)(DomainIdSubAuthorityCount+1) );

    if ((*Sid = (PSID) INetpMemoryAllocate( SidLength )) == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if( CopySid(SidLength, *Sid, DomainId) == FALSE ) {

        Error = GetLastError();

        INetpMemoryFree( *Sid );
        return( Error );
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(GetSidSubAuthorityCount( *Sid ))) ++;
    *GetSidSubAuthority( *Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return( ERROR_SUCCESS );
}

DWORD
INetpCreateSecurityDescriptor(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolutes security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        return NetpCreateSecurityDescriptor(
                   AceData,
                   4,
                   NullSid,
                   LocalSystemSid,
                   &ConfigurationInfoSd
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute secutiry descriptor
        allocated using NetpMemoryAllocate.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL Sacl = NULL;   // Pointer to the SACL portion of above buffer

    DWORD DaclSize = sizeof(ACL);
    DWORD SaclSize = sizeof(ACL);
    DWORD MaxAceSize = 0;
    PVOID MaxAce = NULL;

    LPBYTE CurrentAvailable;
    DWORD Size;

    // ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for (i = 0; i < AceCount; i++) {

        DWORD AceSize;

        AceSize = GetLengthSid( *(AceData[i].Sid) );

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            DaclSize += AceSize;
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE);
            DaclSize += AceSize;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            SaclSize += AceSize;
            break;

        default:
            return( ERROR_INVALID_PARAMETER );
        }

        MaxAceSize = max( MaxAceSize, AceSize );
    }

    //
    // Allocate a chunk of memory large enough the security descriptor
    // the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    Size = SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {
        Size += DaclSize;
    }

    if ( SaclSize != sizeof(ACL) ) {
        Size += SaclSize;
    }

    if ((AbsoluteSd = INetpMemoryAllocate( Size )) == NULL) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the Dacl and Sacl
    //

    CurrentAvailable = (LPBYTE)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {

        Dacl = (PACL)CurrentAvailable;
        CurrentAvailable += DaclSize;

        if( InitializeAcl( Dacl, DaclSize, ACL_REVISION ) == FALSE ) {

            Error = GetLastError();
            goto Cleanup;
        }
    }

    if ( SaclSize != sizeof(ACL) ) {

        Sacl = (PACL)CurrentAvailable;
        CurrentAvailable += SaclSize;

        if( InitializeAcl( Sacl, SaclSize, ACL_REVISION ) == FALSE ) {

            Error = GetLastError();
            goto Cleanup;
        }
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    //

    if ((MaxAce = INetpMemoryAllocate( MaxAceSize )) == NULL ) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for (i = 0; i < AceCount; i++) {

        DWORD AceSize;
        PACL CurrentAcl;

        AceSize = GetLengthSid( *(AceData[i].Sid) );

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:

            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            CurrentAcl = Dacl;

            Error = INetpInitializeAllowedAce(
                            MaxAce,
                            (USHORT) AceSize,
                            AceData[i].InheritFlags,
                            AceData[i].AceFlags,
                            AceData[i].Mask,
                            *(AceData[i].Sid) );
            break;

        case ACCESS_DENIED_ACE_TYPE:

            AceSize += sizeof(ACCESS_DENIED_ACE);
            CurrentAcl = Dacl;

            Error = INetpInitializeDeniedAce(
                            MaxAce,
                            (USHORT) AceSize,
                            AceData[i].InheritFlags,
                            AceData[i].AceFlags,
                            AceData[i].Mask,
                            *(AceData[i].Sid) );
            break;

        case SYSTEM_AUDIT_ACE_TYPE:

            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            CurrentAcl = Sacl;

            Error = INetpInitializeAuditAce(
                            MaxAce,
                            (USHORT) AceSize,
                            AceData[i].InheritFlags,
                            AceData[i].AceFlags,
                            AceData[i].Mask,
                            *(AceData[i].Sid) );
            break;
        }

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //


        if ( AddAce(
                CurrentAcl,
                ACL_REVISION,
                MAXDWORD,
                MaxAce,
                AceSize ) == FALSE ) {

            Error = GetLastError();
            goto Cleanup;
        }
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = OwnerSid
    // Group = GroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if ( InitializeSecurityDescriptor(
            AbsoluteSd,
            SECURITY_DESCRIPTOR_REVISION ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorOwner(
            AbsoluteSd,
            OwnerSid,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorGroup(
            AbsoluteSd,
            GroupSid,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorDacl(
            AbsoluteSd,
            TRUE,
            Dacl,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorSacl(
            AbsoluteSd,
            FALSE,
            Sacl,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Done
    //

    *NewDescriptor = AbsoluteSd;
    AbsoluteSd = NULL;
    Error = ERROR_SUCCESS;

    //
    // Clean up
    //

Cleanup:

    if( AbsoluteSd != NULL ) {

        //
        // delete the partially made SD if we are not completely
        // successful
        //

        INetpMemoryFree( AbsoluteSd );
    }

    //
    // Delete the temporary ACE
    //

    if ( MaxAce != NULL ) {

        INetpMemoryFree( MaxAce );
    }

    return( Error );
}

DWORD
INetCreateWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function creates some well-known SIDs and store them in global
    variables.

Arguments:

    none.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    //
    // Allocate and initialize well-known SIDs which aren't relative to
    // the domain Id.
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        Error = INetpAllocateAndInitializeSid(
                        SidData[i].Sid,
                        &(SidData[i].IdentifierAuthority),
                        1);

        if ( Error != ERROR_SUCCESS ) {
            return Error;
        }

        *(GetSidSubAuthority(*(SidData[i].Sid), 0)) = SidData[i].SubAuthority;
    }

    //
    // Build each SID which is relative to the Builtin Domain Id.
    //

    for ( i = 0;
                i < (sizeof(BuiltinDomainSidData) /
                        sizeof(BuiltinDomainSidData[0]));
                    i++) {


        Error = INetpDomainIdToSid(
                        BuiltinDomainSid,
                        BuiltinDomainSidData[i].RelativeId,
                        BuiltinDomainSidData[i].Sid );

        if ( Error != ERROR_SUCCESS ) {
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

VOID
INetFreeWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function frees up the dynamic memory consumed by the well-known
    SIDs.

Arguments:

    none.

Return Value:

    none

--*/
{
    DWORD i;

    //
    // free up memory allocated for well-known SIDs
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        if( *SidData[i].Sid != NULL ) {
            INetpMemoryFree( *SidData[i].Sid );
            *SidData[i].Sid = NULL;
        }
    }

    //
    // free up memory allocated for Builtin Domain SIDs
    //

    for (i = 0;
            i < (sizeof(BuiltinDomainSidData) /
                sizeof(BuiltinDomainSidData[0])) ;
                    i++) {

        if( *BuiltinDomainSidData[i].Sid != NULL ) {
            INetpMemoryFree( *BuiltinDomainSidData[i].Sid );
            *BuiltinDomainSidData[i].Sid = NULL;
        }
    }

}

DWORD
INetCreateSecurityObject(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

    A sample usage of this function:

        //
        // Structure that describes the mapping of Generic access rights to
        // object specific access rights for the ConfigurationInfo object.
        //

        GENERIC_MAPPING WsConfigInfoMapping = {
            STANDARD_RIGHTS_READ            |      // Generic read
                WKSTA_CONFIG_GUEST_INFO_GET |
                WKSTA_CONFIG_USER_INFO_GET  |
                WKSTA_CONFIG_ADMIN_INFO_GET,
            STANDARD_RIGHTS_WRITE |                // Generic write
                WKSTA_CONFIG_INFO_SET,
            STANDARD_RIGHTS_EXECUTE,               // Generic execute
            WKSTA_CONFIG_ALL_ACCESS                // Generic all
            };

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        return INetCreateSecurityObject(
                   AceData,
                   4,
                   NullSid,
                   LocalSystemSid,
                   &WsConfigInfoMapping,
                   &ConfigurationInfoSd
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    WIN32 Error Code.

    NOTE : the security object created by calling this function may be
                freed up by calling INetDeleteSecurityObject().

--*/
{
    DWORD Error;
    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    HANDLE TokenHandle = NULL;


    Error = INetpCreateSecurityDescriptor(
                   AceData,
                   AceCount,
                   OwnerSid,
                   GroupSid,
                   &AbsoluteSd
                   );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &TokenHandle ) == FALSE ) {

        TokenHandle = INVALID_HANDLE_VALUE;
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Create the security object (a user-mode object is really a pseudo-
    // object represented by a security descriptor that have relative
    // pointers to SIDs and ACLs).  This routine allocates the memory to
    // hold the relative security descriptor so the memory allocated for the
    // DACL, ACEs, and the absolute descriptor can be freed.
    //
    if( CreatePrivateObjectSecurity(
            NULL,                   // Parent descriptor
            AbsoluteSd,             // Creator descriptor
            NewDescriptor,          // Pointer to new descriptor
            FALSE,                  // Is directory object
            TokenHandle,            // Token
            GenericMapping          // Generic mapping
                ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( TokenHandle != NULL ) {
        CloseHandle( TokenHandle );
    }

    //
    // Free dynamic memory before returning
    //

    if( AbsoluteSd != NULL ) {
        INetpMemoryFree( AbsoluteSd );
    }

    return( Error );
}

DWORD
INetDeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    )
/*++

Routine Description:

    This function deletes a security object that was created by calling
    INetCreateSecurityObject() function.

Arguments:

    Descriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    WIN32 Error Code.

--*/
{
    if( DestroyPrivateObjectSecurity( Descriptor ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

DWORD
INetAccessCheckAndAuditW(
    IN  LPCWSTR SubsystemName,
    IN  LPWSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    DWORD Error;

    ACCESS_MASK GrantedAccess;
    BOOL GenerateOnClose;
    BOOL AccessStatus;

    Error = RpcImpersonateClient( NULL ) ;

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( AccessCheckAndAuditAlarmW(
            SubsystemName,
            NULL,                        // No handle for object
            ObjectTypeName,
            NULL,
            SecurityDescriptor,
            DesiredAccess,
            GenericMapping,
            FALSE,  // open existing object.
            &GrantedAccess,
            &AccessStatus,
            &GenerateOnClose ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( AccessStatus == FALSE ) {

        Error = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    RpcRevertToSelf();

    return( Error );
}

DWORD
INetAccessCheckAndAuditA(
    IN  LPCSTR SubsystemName,
    IN  LPSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    DWORD Error;

    ACCESS_MASK GrantedAccess;
    BOOL GenerateOnClose;
    BOOL AccessStatus;

    Error = RpcImpersonateClient( NULL ) ;

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( AccessCheckAndAuditAlarmA(
            SubsystemName,
            NULL,                        // No handle for object
            ObjectTypeName,
            NULL,
            SecurityDescriptor,
            DesiredAccess,
            GenericMapping,
            FALSE,  // open existing object.
            &GrantedAccess,
            &AccessStatus,
            &GenerateOnClose ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( AccessStatus == FALSE ) {

        Error = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    RpcRevertToSelf();

    return( Error );
}

DWORD
INetAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheck; and reverts back to
    itself before returning.

    This routine differs from NetpAccessCheckAndAudit in that it doesn't require
    the caller to have SE_AUDIT_PRIVILEGE nor does it generate audits.
    That is typically fine since the passed in security descriptor typically doesn't
    have a SACL requesting an audit.

Arguments:

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    DWORD Error;

    HANDLE ClientToken = NULL;

    DWORD GrantedAccess = 0;
    BOOL AccessStatus;
    BYTE PrivilegeSet[500]; // Large buffer

    DWORD PrivilegeSetSize;


    //
    // Impersonate the client.
    //

    Error = RpcImpersonateClient(NULL);

    if ( Error != ERROR_SUCCESS ) {

        return( Error );
    }

    //
    // Open the impersonated token.
    //

    if ( OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE, // use process security context to open token
            &ClientToken ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Check if the client has the required access.
    //

    PrivilegeSetSize = sizeof(PrivilegeSet);
    if ( AccessCheck(
            SecurityDescriptor,
            ClientToken,
            DesiredAccess,
            GenericMapping,
            (PPRIVILEGE_SET)&PrivilegeSet,
            &PrivilegeSetSize,
            &GrantedAccess,
            &AccessStatus ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;

    }

    if ( AccessStatus == FALSE ) {

        Error = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Success
    //

    Error = ERROR_SUCCESS;

Cleanup:

    RpcRevertToSelf();

    if ( ClientToken != NULL ) {
        CloseHandle( ClientToken );
    }

    return( Error );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\httphdr\httphdr.cxx ===
/*++


   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       httphdr.cxx

   Abstract:
       This module defines the functions for handling the dictionary items.
       It contains custom implementation of dictionary for HTTP header parsing.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Nov-1996

   Environment:
       User Mode - Win32

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "httphdr.hxx"
# include <iis64.h>


// NYI:  Temporary copy for now
struct NAME_COLLECTION {
 LPCSTR pszName;
 INT    cchName;
};

# define HfmHeader( HfmId, HfmString)  { HfmString, (sizeof( HfmString) - 1) },

NAME_COLLECTION   g_HttpHeaders[] = {

    ALL_HTTP_FAST_MAP_HEADERS()
    { NULL, NULL}
};

# undef HfmHeader


# define NUM_HTTP_HEADERS (sizeof( g_HttpHeaders)/sizeof( g_HttpHeaders[0]) - 1)


# define  _HTTP_HEADER_SIG_CHARS    ( 32)

// SigBits avoids the upcase-low-case troubles.
# define  SigBits( ch)    ( (ch) & 0x1F)

# define  SigBit_I        ( ('I') & 0x1F)  // SigBit of I
# define  SigBit_U        ( ('U') & 0x1F)  // SigBit of U

//
// This header hash is specifically tailored for HTTP Headers in
//  ALL_HTTP_FAST_MAP_HEADERS()
//

inline int _HTTP_HEADER_HASH( LPCSTR psz, DWORD cchLen, DWORD sigChar)
{
    register DWORD ch = SigBits( (DWORD ) *psz);

    return (( ch * (sigChar/2)) +
            //            ((( SigBits( *psz) == SigBit_I) && (cchLen > 6)) ?
            // ((cchLen > 6) ? SigBits(psz[6]) :
            ((ch == SigBit_I && cchLen>6) ? SigBits(psz[6]) :
             (((ch == SigBit_U)?
               (cchLen) :
               SigBits( psz[cchLen/2])))
             )
            );
} // _HTTP_HEADER_HASH()


// extract the case-insetive bits for US-ASCII character set.
# define IcaseBits(ch)         ( (ch) & 0xDF)

// emulate stricmp by disregarding bit 5
inline BOOL _HTTP_HEADER_CHAR_I_NOTEQUAL( CHAR ch1, CHAR ch2)
{   return ( (IcaseBits(ch1)) != ( IcaseBits(ch2))); }


/*++
  I tried using the cached case-insensitive name for comparison
  using the _HTTP_HEADER_CHAR_I_NORMAL_1()
  but that requires more instructions since the x86 generated
  some unwanted instructions for access to memory :(
  x86 is smart to execute the above function _HTTP_HEADER_CHAR_I_NOTEQUAL()
   very well.
  --*/

// same as func _HTTP_HEADER_CHAR_I_NOTEQUAL()
// except that ch2 is already normalized
inline BOOL _HTTP_HEADER_CHAR_I_NOTEQUAL_1( CHAR ch1, CHAR ch2)
{   return ( (IcaseBits(ch1)) != ( ch2)); }



#if COMPRESSED_HEADERS
//
// Lookup table for compressed headers.
//

HTTP_FAST_MAP_HEADERS
CHeaderLUT[] =
{
    HM_ACC,                 //#A  // Accept:
    HM_MAX,                 //#B
    HM_MAX,                 //#C
    HM_MAX,                 //#D
    HM_MAX,                 //#E
    HM_MAX,                 //#F
    HM_MAX,                 //#G
    HM_AUT,                 //#H  // Authorization:
    HM_MAX,                 //#I
    HM_CON,                 //#J  // Connection:
    HM_MAX,                 //#K
    HM_MAX,                 //#L
    HM_MAX,                 //#M
    HM_CLE,                 //#N  // Content-Length:
    HM_MAX,                 //#O
    HM_MAX,                 //#P
    HM_MAX,                 //#Q
    HM_CTY,                 //#R  // Content-Type:
    HM_MAX,                 //#S
    HM_MAX,                 //#T
    HM_MAX,                 //#U
    HM_VIA,                 //#V
    HM_HST,                 //#W  // Host:
    HM_IMS,                 //#X  // If-Modified-Since:
    HM_MAX,                 //#Y
    HM_MAX,                 //#Z
    HM_MAX,                 //#a
    HM_MAX,                 //#b
    HM_MAX,                 //#c
    HM_MAX,                 //#d
    HM_MAX,                 //#e
    HM_MAX,                 //#f
    HM_MAX,                 //#g
    HM_PRA,                 //#h  // Proxy-Authorization:
    HM_MAX,                 //#i
    HM_RNG,                 //#j  // Range:
    HM_MAX,                 //#k
    HM_MAX,                 //#l
    HM_MAX,                 //#m
    HM_TEC,                 //#n  // Transfer-Encoding:
    HM_MAX,                 //#o
    HM_MAX,                 //#p
    HM_MAX,                 //#q
    HM_MAX,                 //#r
    HM_MAX,                 //#s
    HM_MAX,                 //#t
    HM_UMS                  //#u  // Unless-Modified-Since:

};

#endif

/************************************************************
 *    Functions
 ************************************************************/


HTTP_HEADER_MAPPER::~HTTP_HEADER_MAPPER( VOID)
{
    if ( NULL != m_rgOnNameMapper) {
        delete [] m_rgOnNameMapper;
        m_rgOnNameMapper = NULL;
    }

} // HTTP_HEADER_MAPPER::~HTTP_HEADER_MAPPER()

BOOL
HTTP_HEADER_MAPPER::Initialize( VOID)
{
    DWORD i;

    m_rgOnNameMapper = new int[ SizeOfNameMapper()];

    if ( NULL == m_rgOnNameMapper) {
        IF_DEBUG(ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Allocation of Name Mapper of size %d failed\n",
                        SizeOfNameMapper()));
        }
        return FALSE;
    }

    // initialize the array of indexes
    for ( i = 0 ; i < SizeOfNameMapper() ; ++i ) {
        m_rgOnNameMapper[i] = -1; // set to invalid index
    }

    NAME_COLLECTION * pnc = g_HttpHeaders;

    for( pnc = g_HttpHeaders; pnc->pszName != NULL; pnc++) {


        int iN = _HTTP_HEADER_HASH(pnc->pszName, pnc->cchName, m_nSigChars);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF(( DBG_CONTEXT,
                        " _HTTP_HEADER_HASH( %s, len=%d, %d) => %d\n",
                        pnc->pszName, pnc->cchName, m_nSigChars, iN));
        }


        // We are using a very strict Algorithm for generating the mapping.
        // If the following assert fails, then someone has broken the algo's
        //   assumption, by adding a new entry. We have to find a new algo.
        // Algo's assumption: 1st char and next to last char are unique.
        // If not, modify the algo to use another pair or a different method
        //   (different hash function).

        if ((iN < 0)                              ||
            (((DWORD ) iN) >= SizeOfNameMapper()) ||
            (m_rgOnNameMapper[ iN] != -1)) {
            IF_DEBUG( ERROR) {
                DBGPRINTF(( DBG_CONTEXT,
                            " %08x::Initialize() OnName Mapper failed."
                            " Item (%s) indexes to location %d=>%d with (%s).\n",
                            this, pnc->pszName, iN,
                            m_rgOnNameMapper[iN],
                            g_HttpHeaders[ m_rgOnNameMapper[iN]].pszName
                            ));
            }

            // DBG_ASSERT( m_rgOnNameMapper[iN] == -1 );
            return ( FALSE);
        }

        // store the index here
        m_rgOnNameMapper[iN] = DIFF(pnc - g_HttpHeaders);

    } // for

    m_nItems = DIFF(pnc - g_HttpHeaders);

    return (TRUE);
} // HTTP_HEADER_MAPPER::Initialize()


BOOL
HTTP_HEADER_MAPPER:: FindOrdinal(
   IN LPCSTR pszName,
   IN INT    cchName,
   OUT DWORD * pdwOrdinal) const
{
    DBG_ASSERT( m_rgOnNameMapper);

    if ( cchName > 2 ) {


#if COMPRESSED_HEADERS

        if (*pszHeader == '#')
        {
            HM_ID       i;
            CHAR        c;

            c = pszHeader[1];
            if (c >= 'A')
            {
                i = CHeaderLUT[c - ( !(c & 0x20) ? 'A' : ('a' - ('Z' - 'A') - 1) )];

                *FieldIndex = i;

                return (i != HM_MAX);
            }

            return FALSE;

        }
#endif

        int iHash = _HTTP_HEADER_HASH( pszName, cchName, m_nSigChars);
        DBG_ASSERT( iHash >= 0);

        if (((DWORD ) iHash) >= SizeOfNameMapper()) {

            //
            // Out of bounds index value received for the index into our
            // lookup table => our hash calculator indicates this is not
            // a fast-mappable header => fail the FindOrdinal() call
            //

            return ( FALSE);
        }

        int i = m_rgOnNameMapper[iHash];

        //
        // The value from the m_rgOnNameMapper should be
        //  -1, if the header is not a fast-map header at all
        //  < NUM_HTTP_HEADERS if this is a valid fast-map header thus
        //    giving the index of the header in the header-mapper structure.
        //

        DBG_ASSERT( (i== -1) || (i < NUM_HTTP_HEADERS));

        if ( (i != -1) && (cchName == g_HttpHeaders[i].cchName) ) {

            LPCSTR pszFN = g_HttpHeaders[i].pszName;

            // let us use stride 2 and be pipeline friendly
            if ((cchName & 0x1)) {
                // odd length => eliminate the first char
                cchName--;
                if ( _HTTP_HEADER_CHAR_I_NOTEQUAL(
                        pszName[cchName],
                        pszFN[cchName] ) )
                {
                    return FALSE;
                }
            }


            DBG_ASSERT( (cchName % 2) == 0);
            while ( (cchName-= 2) >= 0 ) {

                if ( _HTTP_HEADER_CHAR_I_NOTEQUAL( pszName[cchName],
                                                   pszFN[cchName] ) ||
                     _HTTP_HEADER_CHAR_I_NOTEQUAL( pszName[cchName + 1],
                                                   pszFN[cchName + 1] )
                     )
                {
                    return FALSE;
                }
            } // while

            *pdwOrdinal = (DWORD ) i;
            return TRUE;
        }
    }

    return FALSE;
} // HTTP_HEADER_MAPPER::FindOrdinal()


LPCSTR
HTTP_HEADER_MAPPER::FindName( IN DWORD dwOrdinal) const
{
    DBG_ASSERT( dwOrdinal < NUM_HTTP_HEADERS );
    return ( g_HttpHeaders[dwOrdinal].pszName);

} // HTTP_HEADER_MAPPER::FindName()



VOID
HTTP_HEADER_MAPPER::PrintToBuffer( IN CHAR * pchBuffer,
                                   IN OUT LPDWORD pcch) const
{
    DWORD cb;
    DWORD i;

    DBG_ASSERT( NULL != pchBuffer);

    // 0. Print the location of this object
    // 1. Print all the <Name, ordinal> pairs
    // 2. Print the OnNameMapper values

    cb = wsprintfA( pchBuffer,
                    "HTTP_HEADER_MAPPER (%08x). NumItems= %d. NameColl= %08x"
                    " NSigChars= %d\n\n",
                    this, m_nItems, g_HttpHeaders, m_nSigChars
                    );

    for ( i = 0; i < NUM_HTTP_HEADERS; i++) {

        if ( cb + 80 < *pcch) {
            cb += wsprintfA( pchBuffer + cb,
                             " [%2d] @%4d\tLen=%-4d %-25s\n",
                             i,
                             _HTTP_HEADER_HASH( g_HttpHeaders[i].pszName,
                                                g_HttpHeaders[i].cchName,
                                                m_nSigChars),
                             g_HttpHeaders[i].cchName,
                             g_HttpHeaders[i].pszName
                             );

        } else {
            cb += 80;
        }
    } // for

    if ( cb + 60 < *pcch) {
        cb += wsprintfA( pchBuffer + cb, "\n Sizeof OnNameMapper = %d\n\n",
                         SizeOfNameMapper()
                         );
    } else {
        cb += 60;
    }

    if ( NULL != m_rgOnNameMapper) {

        for( i = 0; i < SizeOfNameMapper(); i++) {

            if ( (i % 20) == 0) {
                pchBuffer[cb++] = '\n';
                pchBuffer[cb] = '\0';
            }

            if ( cb + 5 < *pcch) {
                cb += wsprintfA( pchBuffer + cb,
                                 "%4d", m_rgOnNameMapper[ i]
                                 );
            } else {
                cb += 5;
            }
        } // for
    }


    if ( cb + 80 < *pcch) {
        cb += wsprintfA( pchBuffer+cb,
                         "\n   %d items stored in %d buckets. Density = %5d\n",
                         NUM_HTTP_HEADERS, SizeOfNameMapper(),
                         ( 10000 * NUM_HTTP_HEADERS)/SizeOfNameMapper()
                         );
    } else {
        cb += 80;
    }

    *pcch = cb;
    return;
} // HTTP_HEADER_MAPPER::PrintToBuffer( )


VOID
HTTP_HEADER_MAPPER::Print( VOID) const
{
    CHAR  pchBuffer[ 20000];
    DWORD cb = sizeof( pchBuffer);

    PrintToBuffer( pchBuffer, &cb);
    DBG_ASSERT( cb < sizeof(pchBuffer));

    DBGDUMP(( DBG_CONTEXT, pchBuffer));

    return;
} // HTTP_HEADER_MAPPER::Print()



/************************************************************
 *   HTTP_HEADERS
 ************************************************************/

#ifdef _PRIVATE_HTTP_HEADERS_TEST
HTTP_HEADER_MAPPER *
HTTP_HEADERS::QueryHHMapper(void)
{
   return ( &sm_hhm);

} // HTTP_HEADERS::QueryHHMapper()
# endif //  _PRIVATE_HTTP_HEADERS_TEST

inline VOID
UpdatePointer( IN OUT LPCSTR * ppsz, IN const CHAR * pchOld,
               IN DWORD cchLen, IN const CHAR * pchNew)
{
    if ( (*ppsz >= pchOld) &&
         (*ppsz < (pchOld + cchLen))
         ){

        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                        " Updating pointer [%08x] from %08x to %08x\n",
                        ppsz, *ppsz,  ((*ppsz - pchOld) + pchNew)));
        }

        // update the pointer
        *ppsz = ((*ppsz - pchOld) + pchNew);
    }
}

DWORD
NAME_VALUE_CHUNK::PrintToBuffer( IN CHAR * pchOut, IN OUT LPDWORD  pcchMax) const
{
    DBG_ASSERT( NULL != pchOut);
    DBG_ASSERT( NULL != pcchMax);

    NAME_VALUE_PAIR * pnv;
    DWORD cch = 0;

    if ( m_nPairs == 0) {
        *pcchMax = 0;
        return ( 0);
    }

    if ( 80 < *pcchMax) {
        cch = wsprintfA( pchOut, " NAME_VALUE_CHUNK: %08x;  NumPairs = %d\n",
                         this, m_nPairs);
    } else {
        cch = 80;
    }

    // Iterate over given pairs of name-value items and dump the output
    for ( pnv = (NAME_VALUE_PAIR *) m_rgNVP;
          pnv < ((NAME_VALUE_PAIR *) m_rgNVP) + m_nPairs;
          pnv++) {

        if ( pnv->pchName != NULL) {

            if ( (cch + pnv->cchName + pnv->cchValue + 3) < *pcchMax ) {
                pchOut[cch++] = '\t';
                CopyMemory( pchOut + cch, pnv->pchName, pnv->cchName);
                cch += pnv->cchName;
                pchOut[cch++] = '=';
                CopyMemory( pchOut + cch, pnv->pchValue, pnv->cchValue);
                cch += pnv->cchValue;
                pchOut[cch++] = '\n';
            } else {
                cch +=  pnv->cchName + pnv->cchValue + 3;
            }
        }
    } // for

    *pcchMax = cch;
    return (cch);
} // NAME_VALUE_CHUNK::PrintToBuffer()


BOOL
NAME_VALUE_CHUNK::AddEntry( IN const CHAR * pszHeader, IN DWORD cchHeader,
                            IN const CHAR * pszValue,  IN DWORD cchValue
                            )
{
    NAME_VALUE_PAIR  * pnp;

    DBG_ASSERT( IsSpaceAvailable());


    // Walk the array and pick the first location that is free.
    for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
          pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
          pnp++) {

        if ( NULL == pnp->pchName) {

            // Found a blank one. Fill up the contents.
            // NOTE: We are not making copies of the contents,
            // We are just storing the pointers.
            pnp->pchName  = pszHeader;
            pnp->cchName  = cchHeader;
            pnp->pchValue = pszValue;
            pnp->cchValue = cchValue;

            return (TRUE);
        }
    } // for

    if ( m_nPairs < MAX_HEADERS_PER_CHUNK) {

        // store it at the next available location.
        pnp = (NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs;
        m_nPairs++;
        pnp->pchName  = pszHeader;
        pnp->cchName  = cchHeader;
        pnp->pchValue = pszValue;
        pnp->cchValue = cchValue;
        return ( TRUE);
    }

    SetLastError( ERROR_INSUFFICIENT_BUFFER);
    return (FALSE);
} // NAME_VALUE_CHUNK::AddEntry()




NAME_VALUE_PAIR *
NAME_VALUE_CHUNK::FindEntry( IN const CHAR * pszHeader, IN DWORD cchHeader)
{
    NAME_VALUE_PAIR  * pnp;

    // Walk the array and pick the first location that is free.
    for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
          pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
          pnp++) {

        DBG_ASSERT( (cchHeader != pnp->cchName) || (pnp->pchName != NULL) );

        if ( (cchHeader == pnp->cchName) &&
             !_strnicmp( pszHeader, pnp->pchName, cchHeader)
             ) {

            return ( pnp);
        }
    } // for

    SetLastError( ERROR_NO_MORE_ITEMS);
    return ( NULL);
} // NAME_VALUE_CHUNK::FindEntry()



NAME_VALUE_PAIR *
NAME_VALUE_CHUNK::FindMatchingOrFreeEntry( IN const CHAR * pszHeader,
                                           IN DWORD   cchHeader,
                                           IN LPBOOL  pfFound )
{
    NAME_VALUE_PAIR  * pnp;

    DBG_ASSERT( pszHeader != NULL);
    DBG_ASSERT( pfFound != NULL);

    // Walk the array and pick the first location that is free.
    for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
          pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
          pnp++) {

        DBG_ASSERT( (cchHeader != pnp->cchName) || (pnp->pchName != NULL) );

        if ( (cchHeader == pnp->cchName) &&
             !_strnicmp( pszHeader, pnp->pchName, cchHeader)
             ) {

            *pfFound = TRUE;
            return ( pnp);
        }
    } // for

    if ( m_nPairs < MAX_HEADERS_PER_CHUNK) {

        // return the free entry
        DBG_ASSERT(((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs) == pnp);
        *pfFound = FALSE;
        return ( pnp);
    }

    SetLastError( ERROR_NO_MORE_ITEMS);
    return ( NULL);
} // NAME_VALUE_CHUNK::FindMatchingOrFreeEntry()


BOOL
NAME_VALUE_CHUNK::UpdatePointers(
    IN const CHAR * pchOld,
    IN DWORD cchLen,
    IN const CHAR * pchNew)
{
    if ( m_nPairs > 0) {

        NAME_VALUE_PAIR  * pnp;

        // Walk the array and pick the first location that is free.
        for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
              pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
              pnp++) {

            UpdatePointer( &pnp->pchName, pchOld, cchLen, pchNew);
            UpdatePointer( &pnp->pchValue, pchOld, cchLen, pchNew);
        } // for
    }
    return (TRUE);
} // NAME_VALUE_CHUNK::UpdatePointers()




//
// Declare the header mapper. For the existing set of headers,
//  use of 14X14 hash bucket is sufficient.
//
HTTP_HEADER_MAPPER  HTTP_HEADERS::sm_hhm(14);

BOOL
HTTP_HEADERS::Initialize( VOID)
{
    sm_hhm.SetSigChars( 14);
    if ( !sm_hhm.Initialize()) {

        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                        " HTTP_HEADERS::Initialize() failed. \n"
                        ));
        }

        return ( FALSE);
    }

    return ( TRUE);
} // HTTP_HEADERS::Initialize()



VOID
HTTP_HEADERS::Cleanup( VOID)
{
    // Currently there is no function to cleanup sm_hmm :(

} // HTTP_HEADERS::Cleanup()



HTTP_HEADERS::HTTP_HEADERS(VOID)
    : m_chNull      ( '\0'),
      m_buffHeaders (),
      m_iMaxFastMapHeader ( 0),
      m_cchHeaders  ( 0),
      m_cchBuffHeaders  ( 0)
{
    InitializeListHead( &m_ActiveList);
    InitializeListHead( &m_FreeList);

    IF_DEBUG( INIT_CLEAN) {

        DBGPRINTF(( DBG_CONTEXT, "HTTP_HEADERS() => %08x\n", this));
    }

    Reset();

} // HTTP_HEADERS::HTTP_HEADERS()


HTTP_HEADERS::~HTTP_HEADERS( VOID)
{
    NAME_VALUE_CHUNK *      pNVC = NULL;
    
    while ( !IsListEmpty( &m_FreeList ) )
    {
        pNVC = CONTAINING_RECORD( m_FreeList.Flink,
                                  NAME_VALUE_CHUNK,
                                  m_listEntry );
        RemoveEntryList( &pNVC->m_listEntry );
        delete pNVC;
    }

    while ( !IsListEmpty( &m_ActiveList ) )
    {
        pNVC = CONTAINING_RECORD( m_ActiveList.Flink,
                                  NAME_VALUE_CHUNK,
                                  m_listEntry );
        RemoveEntryList( &pNVC->m_listEntry );
        delete pNVC;
    }

    IF_DEBUG( INIT_CLEAN) {

        DBGPRINTF(( DBG_CONTEXT, "deleted HTTP_HEADERS %08x\n", this));
    }

} // HTTP_HEADERS::~HTTP_HEADERS()


VOID
HTTP_HEADERS::Reset( VOID)
{
    m_cchHeaders = 0;
    m_rcInlinedHeader[0] = '\0';

    m_cchBuffHeaders = 0;
    m_buffHeaders.Resize( HH_MIN);

    m_iMaxFastMapHeader = 0;
    ZeroMemory( m_rgpszHeaders, sizeof( m_rgpszHeaders));
    // We will skip setting the m_rgpszHeaders to be NULL.
    // the iMaxFastMapHeader does the necessary job for the same

    //
    // Move the Name-Value chunks from active list to the free-list.
    //
    while ( !IsListEmpty( &m_ActiveList)) {

        PLIST_ENTRY pl = m_ActiveList.Flink;
        RemoveEntryList( pl);
        InsertTailList( &m_FreeList, pl);
    } // while

    DBG_ASSERT( IsListEmpty( &m_ActiveList));
    DBG_CODE( InitializeListHead( &m_ActiveList)); // just paranoid!

    return;
} // HTTP_HEADERS::Reset()

VOID
HTTP_HEADERS::CancelHeader( IN LPCSTR    pszName)
{
    HTTP_FAST_MAP_HEADERS iField;
    DWORD cchName = strlen( pszName);

    // Find and store the header and value
    if ( sm_hhm.FindOrdinal( pszName, cchName, (LPDWORD ) &iField ) ) {

        FastMapCancel( iField);
    }  else {
        CancelHeaderInChunks( pszName, cchName);
    }

} // HTTP_HEADERS::CancelHeader()



BOOL
HTTP_HEADERS::StoreHeader(IN const CHAR * pszHeader, IN DWORD cchHeader,
                          IN const CHAR * pszValue,  IN DWORD cchValue
                          )
/*++
  This function is used to copy the header values instead of just
  storing the pointer values. This function can be used by filters to set/reset
  headers.
--*/
{
    HTTP_FAST_MAP_HEADERS iField;

    // Find and store the header and value
    if ( sm_hhm.FindOrdinal( pszHeader, cchHeader, (LPDWORD ) &iField ) ) {

        return ( FastMapStoreWithConcat( iField, pszValue, cchValue) );
    }
    else
    {
    return ( AddEntryToChunks( pszHeader, cchHeader, pszValue,  cchValue, TRUE));
    }
} // HTTP_HEADERS::StoreHeader()

BOOL
HTTP_HEADERS::StoreHeader(IN const CHAR * pszHeader,
                          IN const CHAR * pszValue
                          )
{
    return ( StoreHeader( pszHeader, strlen( pszHeader),
                          pszValue,  strlen( pszValue)
                          )
             );
} // HTTP_HEADERS::StoreHeader()


BOOL
HTTP_HEADERS::FastMapStoreWithConcat( IN HTTP_FAST_MAP_HEADERS hfm,
                                      IN LPCSTR pszValue, IN DWORD cchValue)
{
    // NYI: Following storage introduces fragmentation,
    //  which we do not care about for now :(

    return (ConcatToHolder( m_rgpszHeaders + hfm, pszValue, cchValue));

} // FastMapStoreWithConcat()



VOID
HTTP_HEADERS::PrintToBuffer( IN CHAR * pchBuffer, IN OUT LPDWORD pcchMax) const
{
    DWORD cb;
    PLIST_ENTRY pl;

    DBG_ASSERT( pchBuffer != NULL);
    DBG_ASSERT( pcchMax != NULL);

    // 0. Print the summary of the object
    // 1. Print all the Fast Map headers
    // 2. Print the rest of the headers

    if( 100 < *pcchMax) {
        cb = wsprintfA( pchBuffer,
                        "\nHTTP_HEADERS (%08x). cchHeaders = %d (buff = %d/%d)\n"
                        " Fast-Map headers:  MaxFastMapHeaders = %d\n"
                        ,
                        this, m_cchHeaders,
                        m_cchBuffHeaders, m_buffHeaders.QuerySize(),
                        FastMapMaxIndex()
                        );
    } else {
        cb = 100;
    }


    for ( DWORD i = 0; i < FastMapMaxIndex(); i++) {

        if ( m_rgpszHeaders[i] != NULL) {
            if ( cb + 200 < *pcchMax) {
                cb += wsprintfA( pchBuffer + cb,
                                 "\t%s = %s\n",
                                 sm_hhm.FindName( i),
                                 m_rgpszHeaders[i]
                                 );
            } else {
                cb += 200;
            }
        }
    } // for

    // Print all other headers starting with the cached 1st chunk
    DWORD cb1 = (cb < *pcchMax) ? *pcchMax - cb : 0;

    for ( pl =  m_ActiveList.Flink; pl != &m_ActiveList; pl = pl->Flink) {

        NAME_VALUE_CHUNK * pnvc =
            CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        cb1 = (cb < *pcchMax) ? *pcchMax - cb : 0;
        cb += pnvc->PrintToBuffer ( pchBuffer + cb, &cb1);
    } // for

    pchBuffer[cb] = '\0';

    //
    // Print the Raw header from buffer ... NYI
    //

    if ( cb + 2 < *pcchMax ) {
        lstrcat( pchBuffer + cb, "\n\n");
        cb += 2;
    } else {
        cb += 2;
    }

    *pcchMax = cb;

    return;
} // HTTP_HEADERS::PrintToBuffer()


BOOL
HTTP_HEADERS::UpdatePointers(
    IN const CHAR * pchOld,
    IN DWORD cchLen,
    IN const CHAR * pchNew)
{

    // REMOVE
    IF_DEBUG( ERROR) {
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::UpdatePointers( %08x, %d, %08x) - is costly\n",
                    this, pchOld, cchLen, pchNew));
    }

    DBG_ASSERT( pchOld != pchNew); // if this is true why call this function?

    // 1. Update the fast map pointers.
    LPCSTR * ppsz;
    for ( ppsz = m_rgpszHeaders;
          ppsz < (m_rgpszHeaders +  MAX_HTTP_FAST_MAP_HEADERS);
          ppsz++) {

        UpdatePointer( ppsz, pchOld, cchLen, pchNew);
    } // for

    // 3. Update pointers in the name-value chunk list
    PLIST_ENTRY pl;
    for ( pl =  m_ActiveList.Flink; pl != &m_ActiveList; pl = pl->Flink) {

        NAME_VALUE_CHUNK * pnvc =
            CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        // REMOVE
        DBGPRINTF(( DBG_CONTEXT,
                    "HH(%08x)::UpdatePointers( %08x, %d, %08x)"
                    " for the NVC %08x (pl = %08x)\n",
                    this, pchOld, cchLen, pchNew, pnvc, pl));

        pnvc->UpdatePointers( pchOld, cchLen, pchNew);
    } // for

    return ( TRUE);
} // HTTP_HEADERS::UpdatePointers()


BOOL
HTTP_HEADERS::MakeRoomInBuffer( IN DWORD cchReqd, IN LPCSTR * ppszVal)
{

    // REMOVE
    DBGPRINTF(( DBG_CONTEXT, "%08x:: MakeRoomInBuffer( %d, %08x). buff=%08x. size=%d\n",
                this, cchReqd, ppszVal,&m_buffHeaders, m_buffHeaders.QuerySize()));

    //
    // Bug 136637 : Because of the way we move our headers around when we get a new header
    // value for an existing header, it's really easy to chew up lots of memory rather 
    // quickly, so we'll artificially limit the size of the buffer to avoid denial-of-service
    // attacks. 
    // 
    if ( cchReqd > HH_MAX )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Reached max buffer size (%d), refusing request to resize buffer to %d bytes\n",
                   HH_MAX,
                   cchReqd));
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    if ( cchReqd > m_buffHeaders.QuerySize()) {

        // cache old pointer to update the other pointers properly
        LPSTR pszOld = (LPSTR ) m_buffHeaders.QueryPtr();

        if ( !m_buffHeaders.Resize( cchReqd, HH_GROW_BY)) {

            IF_DEBUG( ERROR) {
                DBGPRINTF(( DBG_CONTEXT, "%08x::Unable to allocate %d bytes\n",
                            this, cchReqd));
            }
            return ( FALSE);
        }

        DBG_ASSERT( cchReqd <= m_buffHeaders.QuerySize());
        LPSTR pszNew = (LPSTR ) m_buffHeaders.QueryPtr();
        if ( pszNew != pszOld) {

            // Trouble starts.
            // I have to update all the guys pointing inside the old blob
            // especially the pointers in
            //   the range (pszOld  to pszOld + m_cchBuffHeaders)

            UpdatePointer(ppszVal, pszOld, m_cchBuffHeaders, pszNew);

            // REMOVE
            DBGPRINTF(( DBG_CONTEXT, "%08x:: MakeRoomInBuffer( %d, %08x). buff=%08x. size=%d\n",
                        this, cchReqd, ppszVal,&m_buffHeaders, m_buffHeaders.QuerySize()));

            return ( UpdatePointers( pszOld, m_cchBuffHeaders, pszNew));
        }

        // We are just lucky to be able to have reallocated at same place.
    }

    return ( TRUE);
} // HTTP_HEADERS::MakeRoomInBuffer()


VOID
HTTP_HEADERS::Print( VOID)  const
{
    CHAR  pchBuffer[ 20000];
    DWORD cchMax = sizeof( pchBuffer);

    PrintToBuffer( pchBuffer, &cchMax);

    DBGDUMP(( DBG_CONTEXT, pchBuffer));

} // HTTP_HEADERS::Print()


CHAR *
HTTP_HEADERS::FindValue( IN LPCSTR pszName, OUT LPDWORD pcchValue)
{
    DWORD cchName = strlen( pszName);
    HTTP_FAST_MAP_HEADERS iField;

    //
    //  1. Lookup in the fast map for this item
    //

    if ( sm_hhm.FindOrdinal( pszName, cchName, (LPDWORD ) &iField)) {

        // found in the fast-map.
        CHAR * pszValue = (CHAR * ) FastMapQueryValue( iField);

        if ( pcchValue != NULL) {
            *pcchValue = (( pszValue != NULL) ? strlen( pszValue) : 0);
        }

        return ( pszValue);
    }

    // 2. Search in the slow list - name-value-chunks
    NAME_VALUE_PAIR * pnp = FindValueInChunks( pszName, cchName);

    if ( pnp != NULL) {

        if ( pcchValue != NULL) {
            DBG_ASSERT( pnp->pchValue != NULL);
            *pcchValue = pnp->cchValue;
        }

        return ( (CHAR *) pnp->pchValue);
    }

    return ( NULL);
} // HTTP_HEADERS::FindValue()


NAME_VALUE_PAIR *
HTTP_HEADERS::FindValueInChunks( IN LPCSTR  pszName, IN DWORD cchName)
{
    PLIST_ENTRY pl;
    NAME_VALUE_PAIR * pnp = NULL;

    // find a Name-value-pair/chunk that holds this entry.
    for ( pl = m_ActiveList.Flink;
          (pl != &m_ActiveList);
          pl = pl->Flink) {

        NAME_VALUE_CHUNK *
            pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindEntry( pszName, cchName);

        if ( NULL != pnp) {
            // we found the required name-value-pair.stop searching
            break;
        }
    } // for

    return ( pnp);
} // HTTP_HEADERS::FindValueInChunks()


VOID
HTTP_HEADERS::CancelHeaderInChunks( IN LPCSTR pszName, IN DWORD cchName)
{
    PLIST_ENTRY pl;
    NAME_VALUE_PAIR * pnp = NULL;
    NAME_VALUE_CHUNK * pnc;

    // NYI:  This function can benefit from better implementation
    //  instead of moving memory around.
    // Since the freq. of use of this func is less, we will not optimize :(

    // find the Name-value-pair/chunk that holds this entry.
    for ( pl = m_ActiveList.Flink;
          (pnp == NULL) && (pl != &m_ActiveList);
          pl = pl->Flink) {

            pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindEntry( pszName, cchName);
    } // for

    if ( pnp != NULL) {

        // pnp - current item
        // pnc - the current chunk

        // to cancel the item, just left-shift the array of
        //  NAME_VALUE_PAIRS in the chunk and reset the m_nPairs value

        DBG_ASSERT( (pnp >= pnc->m_rgNVP) &&
                    (pnp < pnc->m_rgNVP + pnc->m_nPairs));

        DBG_ASSERT( (pnc->m_nPairs  - (pnp - pnc->m_rgNVP)) >= 1 );
        MoveMemory( pnp, (pnp + 1),
                    ((pnc->m_nPairs - 1 - (pnp - pnc->m_rgNVP)) *
                     sizeof( NAME_VALUE_PAIR))
                    );
        pnc->m_nPairs--;

        // NYI:  if pnc->m_nPairs == 0,
        // we can move this away from the active list
    }

    return;
} // CancelHeaderInChunks()



BOOL
HTTP_HEADERS::NextPair( IN OUT HH_ITERATOR *   phi,
                        OUT NAME_VALUE_PAIR ** ppnp
                        )
{
    DBG_ASSERT( phi );
    DBG_ASSERT( ppnp );

    if ( phi->dwOrdinal < FastMapMaxIndex()) {

        // Iterate over the FastMap headers ...
        for ( DWORD i = phi->dwOrdinal; i < FastMapMaxIndex(); i++ ) {
            if ( m_rgpszHeaders[i] != NULL) {

                NAME_VALUE_PAIR * pnp = &phi->np;
                // found a non-NULL value.

                pnp->pchValue = m_rgpszHeaders[i];
                pnp->pchName  = sm_hhm.FindName( i);

                // NYI: It will be nice to get the length directly :(
                pnp->cchName = strlen( pnp->pchName);
                pnp->cchValue= strlen( pnp->pchValue);
                phi->dwOrdinal = i + 1;
                *ppnp = pnp;
                return ( TRUE);
            }
        } // for

        // we exhausted the fast-map. Fall through after updating Ordinal
        phi->dwOrdinal = (i);
    }

    //
    // Find the pair in the chunk
    //

    return ( NextPairInChunks( phi, ppnp));
} // HTTP_HEADERS::NextPair()


BOOL
HTTP_HEADERS::NextPairInChunks( IN OUT HH_ITERATOR *   phi,
                                OUT NAME_VALUE_PAIR ** ppnp
                                )
{
    DBG_ASSERT( phi);
    DBG_ASSERT( ppnp);
    DBG_ASSERT( phi->dwOrdinal >= FastMapMaxIndex());
    PLIST_ENTRY pl;

    do {

        PLIST_ENTRY pl = (PLIST_ENTRY ) phi->pChunk;
        if ( pl == &m_ActiveList) {
            break;
        }

        NAME_VALUE_CHUNK * pnc =
            (NAME_VALUE_CHUNK *) CONTAINING_RECORD( pl, NAME_VALUE_CHUNK,
                                                    m_listEntry);
        while ( phi->dwPair < pnc->m_nPairs) {

            // extract the current pair, update pair pointer and return
            *ppnp = (NAME_VALUE_PAIR *) (pnc->m_rgNVP + phi->dwPair);
            phi->dwPair++;

            if ( (*ppnp)->pchName ) {
                return ( TRUE);
            }
        }

        // we could not find any in the current chunk. Move to next chunk.
        phi->pChunk = (PVOID)pnc->m_listEntry.Flink;
        phi->dwPair = 0;  // pair # within the chunk
    } while ( TRUE);

    SetLastError( ERROR_NO_MORE_ITEMS);
    return ( FALSE);
} // HTTP_HEADERS::NextPairInChunks()



BOOL
HTTP_HEADERS::AddEntryToChunks(
    IN const CHAR * pszHeader,
    IN DWORD        cchHeader,
    IN const CHAR * pszValue,
    IN DWORD        cchValue,
    BOOL            fCopyValue
    )
/*++
  This function stores the <header, value> pair for headers not found
  in the fast-map. It checks to see if the header already exists
  with some value. If it does, then the new value is just concatenated
  to the old one. Else the new value is stored separately in the first
  available free chunk.

  If there is no free chunk available, this function also allocates a free
  chunk and stores the data in the new chunk.
--*/
{
    // Store the header that is not part of the Fast Map

    PLIST_ENTRY pl;
    NAME_VALUE_CHUNK * pnc;
    NAME_VALUE_PAIR  * pnp;
    NAME_VALUE_CHUNK * pncFirst = NULL;
    NAME_VALUE_PAIR  * pnpFirst = NULL;
    BOOL fRet = FALSE;

    // find a Name-value-pair/chunk that can hold this entry.
    for ( pl = m_ActiveList.Flink;
          (pl != &m_ActiveList);
          pl = pl->Flink)
    {
        BOOL fFound = FALSE;

        pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindMatchingOrFreeEntry( pszHeader, cchHeader, &fFound);

        //
        // Found a matching entry, so update
        //
    
        if ( fFound )
        {
            DBG_ASSERT( pnp != NULL);

            // pnc points to the chunk containing the matched item
            // pnp points to the exact pair that matched up

            DBG_ASSERT( (pnp->cchName == cchHeader) &&
                        (!_strnicmp( pnp->pchName, pszHeader, cchHeader))
                        );

            IF_DEBUG( ERROR)
            {
                DBGPRINTF(( DBG_CONTEXT, "Match For (%s) found at PNP=%08x\n",
                            pszHeader, pnp));
            }

            // Concat the given value to the existing value element.
            // Nothing more needs to be done
        
            fRet = ConcatToHolder( &pnp->pchValue, pszValue, cchValue);
            if  ( fRet)
            {
                // update the length of the datum.
                pnp->cchValue += (1 + cchValue);  // 1 for the ',' concat sign.
            }
            return ( fRet);
        }
        else if ( pnp != NULL && pncFirst == NULL)
        {
            // cache it for later use, if header is never found
            pncFirst = pnc;
            pnpFirst = pnp;
        }
    } // for

    if (pncFirst == NULL )
    {
        // No match found. No free chunk is available.
        // Pull a new one from free list or create one
        if ( IsListEmpty( &m_FreeList))
        {
            pncFirst = new NAME_VALUE_CHUNK();
            if ( NULL == pncFirst)
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                return ( FALSE);
            }
        }
        else
        {
            // pull one from the free list and use it.
            pl = m_FreeList.Flink;
            RemoveEntryList( pl);
            pncFirst = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);
            pncFirst->Reset();
        }

        InsertTailList( &m_ActiveList, &pncFirst->m_listEntry);
        DBG_ASSERT( pncFirst->m_nPairs == 0);
        pnpFirst =  ((NAME_VALUE_PAIR * ) pncFirst->m_rgNVP);
    }

    //
    // At this point, we know it's a new header, so store the new <header, value> pair
    // in pnp and increment count of pairs.
    //

    DBG_ASSERT( NULL != pncFirst);
    DBG_ASSERT( NULL != pnpFirst);

    //
    // Sometimes, we need to make a copy of the header eg when the header to be added
    // comes from a filter. At other times, we can just store a copy of the pointer,
    // because we know it'll be valid for the duration of the use of the data structure
    //

    if (fCopyValue)
    {
        //
        // Copy actual values : ConcatToHolder assumes first parameter points to NULL
        // if it's a new value to be stored
        //

        //
        // Copy the header name
        //
        pnpFirst->pchName = NULL;
        fRet = ConcatToHolder(&pnpFirst->pchName, pszHeader, cchHeader);

        if (fRet)
        {
            pnpFirst->cchName  = cchHeader;
        }
        else
        {
            return FALSE;
        }

        //
        //Copy the header value
        //
        pnpFirst->pchValue = NULL;
        fRet = ConcatToHolder(&pnpFirst->pchValue, pszValue, cchValue);

        if (fRet)
        {
            pnpFirst->cchValue = cchValue;

            if ( pnpFirst == (NAME_VALUE_PAIR * ) pncFirst->m_rgNVP + pncFirst->m_nPairs )
            {
                pncFirst->m_nPairs++;
            }
        }
        else
        {
            pnpFirst->pchName = NULL;
            return FALSE;
        }
    }
    else
    {
        //
        // Just copy pointer to value
        //
        pnpFirst->pchName = pszHeader;
        pnpFirst->cchName = cchHeader;
        pnpFirst->pchValue = pszValue;
        pnpFirst->cchValue = cchValue;

        if ( pnpFirst == (NAME_VALUE_PAIR * ) pncFirst->m_rgNVP + pncFirst->m_nPairs )
        {
            pncFirst->m_nPairs++;
        }
        fRet = TRUE;
    }

    DBG_ASSERT( pncFirst->m_nPairs <= MAX_HEADERS_PER_CHUNK);

    return ( fRet );
} // HTTP_HEADERS::AddEntryToChunks()



BOOL
HTTP_HEADERS::ConcatToHolder( IN LPCSTR * ppsz,
                              IN LPCSTR pszNew,
                              IN DWORD  cchNew
                              )
/*++

  Given an internal pointer ppsz of the HTTP_HEADERS object,
   this function appends the new value to the old value present
   using ',' as the concatenation character.

  It automatically allocates room and grows buffers, updates pointers, etc
   if need be.

--*/
{
    BOOL fRet = TRUE;
    LPCSTR pszOld = *ppsz;
    DWORD  cchOld = pszOld ? strlen( pszOld) : 0;
    DWORD  cchReqd = cchOld + cchNew + 2;

    // Find if we have enough space in the inlined buffer
    if ( ( m_cchHeaders + cchReqd < sizeof( m_rcInlinedHeader))
         ) {

        // Aha we are lucky. Make a copy at the end and form concatenated result
        *ppsz = m_rcInlinedHeader + m_cchHeaders;
        m_cchHeaders += cchReqd;
    } else {

        // Clearly we do not have room in the Inlined Header,
        //  store the stuff in the aux buffer area.

        // Find if space is sufficient.
        //  This will automatically alloc and update pointers
        if ( MakeRoomInBuffer( (m_cchBuffHeaders + cchReqd), &pszNew)
             ){

            pszOld = *ppsz;  // get the new pointer (since it could have moved)
            LPSTR pszBuf = (LPSTR ) m_buffHeaders.QueryPtr();

            // we have space at the end of the buffer here. Use this space.
            *ppsz = pszBuf + m_cchBuffHeaders;
            m_cchBuffHeaders += cchReqd;
        } else {

            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create room for %d characters \n",
                        m_cchBuffHeaders + cchOld + cchNew + 3));
            return ( FALSE);
        }
    }

    if ( !cchOld )
    {
        CopyMemory( (PVOID) (*ppsz), pszNew, cchNew + 1 );
    }
    else
    {
        // Format the value as :=  <old> ',' <new>
        CopyMemory( (PVOID ) *ppsz, pszOld, cchOld);
        ((CHAR *) *ppsz)[cchOld] = ','; // concat character
        CopyMemory( (PVOID ) (*ppsz + cchOld + 1), pszNew, cchNew + 1);
    }

    DBG_ASSERT( fRet == TRUE);
    return ( fRet);
} // HTTP_HEADERS::ConcatToHolder()


/**************************************************
 *  PARSER for the HTTP_HEADERS
 **************************************************/

inline const CHAR *
SkipLeadingWhiteSpace( IN const CHAR * pchStart, IN DWORD cchLen)
{
    const CHAR * pchScan;

    for ( pchScan = pchStart;
          ((pchScan < (pchStart + cchLen)) && isspace( (UCHAR)(*pchScan)));
          pchScan++)
        ;

    return ( pchScan);
} // SkipLeadingWhiteSpace()

BOOL
HTTP_HEADERS::ParseHeaderFirstLine( IN const CHAR * pchFirstLine,
                                    IN CHAR * pchScan,
                                    IN DWORD cchFirstLine)
/*++
  Description:
    Extract the HTTP method, URL, & HTTP-version strings from the first
    line of header block.
    Input:  <Method> <URL> HTTP/<Version>
    Use <blank> or <tab> as the delimiter.
    NYI:  What about other delimiters?

    We will do only forward scans, because
     1) the header can be malformed
     2) HTTP/0.9 requests do not contain the version string
     3) there may be more than 3 parameters on the first line.
    In all the above cases reverse scans will cause trouble.

    Note that a line termination can be by using \r\n or just \n :(

  Arguments:
    pchFirstLine - pointer to character stream containing the
                   first char of the line
    pchScan      - points to the end of the first line.
    cchFirstLine - count of characters on the first line

  Returns:
    TRUE on success & FALSE for failure.
    Use GetLastError() to get correct Win32 error code on failure.
--*/
{
    LPSTR      pszScan2;
    pszScan2 = (LPSTR ) memchr ( pchFirstLine, ' ', cchFirstLine);

    if ( NULL != pszScan2) {

        LPSTR pszScan3;

        *pszScan2++ = '\0';  // replace the blank with a null char

        while ( _HTTP_IS_LINEAR_SPACE( *pszScan2 ) )
        {
            ++pszScan2;
        }

        //
        //  pszScan2 now points to the URL sent
        //

        DWORD cReq = DIFF(pchScan - pszScan2);
        pszScan3 = (LPSTR ) memchr( pszScan2, ' ', cReq);

        if ( NULL != pszScan3 ) {

            *pszScan3++ = '\0';

            while ( _HTTP_IS_LINEAR_SPACE( *pszScan3 ) )
            {
                ++pszScan3;
            }

            // pszScan3 should be now pointing to start of version info

            // Note that we are not removing spaces between the version
            // and the line delimiter

            pchScan[(( (pchScan > pszScan3) && (pchScan[-1] == '\r')) ?
                     -1: 0)] = '\0';
        } else {

            // only 2 parameters. No version is present.
            //  Point pszScan3 to the null-part of pszScan2)

            pszScan3 =
                pchScan + ((pchScan[-1] == '\r') ? -1 : 0);
            *pszScan3 = '\0';
        }

        //
        // We know that we are parsing a new request.
        // So we are not checking for concat during fast-map store here.
        //
        FastMapStore( HM_VER, pszScan3);
        FastMapStore( HM_URL, pszScan2 );
        FastMapStore( HM_MET, pchFirstLine);
    } else {

        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                        " The scan for fields where they are not separated "
                        " with space is intentionally left out!\n"
                        ));
        }
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // everything is happy here ... return success
    //
    return ( TRUE);

} // HTTP_HEADERS::ParseHeaderFirstLine()



BOOL
HTTP_HEADERS::ParseInput( IN const CHAR * pchHeaderBlob,
                          IN DWORD        cchLen,
                          OUT DWORD *     pcbExtraData
                          )
/*++
  Description:
    This function parses the input string and extracts the HTTP headers
    for storage inside the http header structure. Fast-map headers are stored
    in the dedicated fast-map storage area. Non-standard headers (that are
    not part of) fast-map are stored inside the Name-value chunks.

    The Grammar for incoming HTTP headers is:

       <HTTP-verb>  <URL>  <HTTP-version>
       {<Header-Name>:<Header-Value> { {\r\n} | {\n}}}*

     where,
       <HTTP-verb>     == A+
       <URL>           == /[A|D]*
       <HTTP-version>  == HTTP/D+.D+
       <Header-Name>   == A[A|D]*
       <Header-Value>  == [A|D]*
       <CRLF>          == \r\n
       A               == any ascii character except ' ' '\t' '\n' '\r'
       D               == 0-9

  Arguments:
    pchHeaderBlob - pointer to header containing the header blob (+ maybe
                      the body of the request).
    cchLen        - length of the header block alone.
    pcbExtraData  - pointer to a DWORD which on return will contain the
                      number of extra characters of data present in the
                      blob given.

  Returns:
    TRUE on successfully parsing and splitting the headers apart.
    FALSE if there is any failure.
--*/
{
    CHAR *    pchScan;
    CHAR *    pchRequest;
    DWORD     cReq;

    IF_DEBUG( INIT_CLEAN)
    {
        DBGPRINTF(( DBG_CONTEXT, "%08x::ParseInput( %08x:, %d) \n"
                    "Input Headers:\n%s\n",
                    this, pchHeaderBlob, cchLen, pchHeaderBlob));
    }

    //
    // 1. Skip all the leading spaces and ignore them all.
    //   We do not need these fields
    //

    pchScan = (CHAR *) SkipLeadingWhiteSpace( pchHeaderBlob, cchLen);
    cchLen -= DIFF(pchScan - pchHeaderBlob);

    //
    // 2. Make a copy of the incoming header blob so that we can own the
    //    input headers and munge it in our own fashion
    //  NYI: One can optimize this by selectively copying segments that
    //    are worth using (values), but that will be costly due to
    //    multiple small CopyMemory() operations.
    //
    if ( cchLen < sizeof( m_rcInlinedHeader)) {

        pchRequest = (CHAR * ) m_rcInlinedHeader;
        m_cchHeaders = cchLen;

    } else {

        if ( !m_buffHeaders.Resize( cchLen + 4, HH_GROW_BY)) {
            return ( FALSE);
        }

        pchRequest = (CHAR * ) m_buffHeaders.QueryPtr();
        m_cchBuffHeaders = cchLen;
    }

    // 2a. copy the header to the buffer
    CopyMemory( (PVOID ) pchRequest, pchScan, cchLen);

    //
    // pchRequest points to the local copy of the request headers
    //

    DBG_ASSERT( (pchRequest == m_rcInlinedHeader) ||
                (pchRequest == m_buffHeaders.QueryPtr())
                );

    //
    // 3. Get the first line and extract the method string
    //
    pchScan = (CHAR * ) memchr( pchRequest, '\n', cchLen);

    if ( pchScan == NULL ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // 4. Extract the Method, URL and Version Number
    //

    if ( !ParseHeaderFirstLine( pchRequest, pchScan, DIFF(pchScan - pchRequest))) {

        return ( FALSE);
    }

    //
    // 5. Extract all other headers
    //

    LPSTR pszHeader = pchScan + 1;
    cReq = DIFF(pchRequest + cchLen - pszHeader);
    LPSTR pchEnd = pszHeader + cReq;
    LPSTR pszEol, pszValue;

    //
    // pszHeader ( and thus pszEnd & pszEol ) are relative to pchRequest.
    // This needs to be preserved in this loop.
    //

    for ( ; (*pszHeader != '\r' || (cReq > 1 && *(pszHeader + 1) != '\n')) &&
            (*pszHeader != '\n') &&
            (pszValue = (LPSTR)memchr( pszHeader, ':', cReq ));
          pszHeader = (pszEol + 1), cReq = DIFF(pchEnd - pszHeader)
          )
    {
        UINT chN = (UINT)(*(PBYTE)++pszValue);

        //            *pszValue = '\0';
        int cchHeader = DIFF(pszValue - pszHeader);

        pszEol = (LPSTR ) memchr( pszValue, '\n', cReq - cchHeader);

        if ( NULL == pszEol ) {

            //
            // Aha! we found a completely malformed header block here.
            // Let us return a failure to the caller.
            //

            IF_DEBUG( ERROR) {
                DBGPRINTF(( DBG_CONTEXT,
                            " The scan for header-value blocks found a line"
                            " not properly terminated with \'\\n\'\n"
                            ));
            }
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        DBG_ASSERT( NULL != pszEol );

        DWORD  cchValue;
        DWORD  iField;

        // skip spaces if any.
        if ( _HTTP_IS_LINEAR_SPACE( (CHAR)chN ) )
        {
            while ( _HTTP_IS_LINEAR_SPACE( (CHAR)(*(PBYTE)++pszValue) ) )
                ;
        }

        // Terminate the value string
        if ( (pszEol > pszValue) && (pszEol[-1] == '\r') )
        {

            pszEol[-1] = '\0';
            cchValue = DIFF(pszEol - pszValue - 1);

        }
        else
        {

            pszEol[0] = '\0';
            cchValue = DIFF(pszEol - pszValue);
        }

        IF_DEBUG( INIT_CLEAN )
        {
            DBGPRINTF((DBG_CONTEXT, "\t[%s] = %s\n", pszHeader, pszValue ));
        }

        {  // Store the header - inline to reduce cost

            HTTP_FAST_MAP_HEADERS iField;
            BOOL  fRet = TRUE;

            // Find and store the header and value
            if ( sm_hhm.FindOrdinal( pszHeader, cchHeader,
                    (LPDWORD ) &iField ) )
            {

                if ( FastMapQueryValue(iField) == NULL )
                {

                // Store the item and continue scan for next header
                FastMapStore( iField, pszValue);
                continue;

                }
                else
                {
                    // FastMapStoreWithConcat can resize the header
                    // buffer. If the headers we're scanning are
                    // coming out of the header buffer, we'll need
                    // to update pszHeader later, so save the current
                    // pointer just in case.

                    CHAR        *pOldBuff = (CHAR *)m_buffHeaders.QueryPtr();

                    fRet =  FastMapStoreWithConcat( iField, pszValue,
                                                            cchValue);

                    if ( !fRet)
                    {

                        IF_DEBUG( ERROR)
                        {

                            DBGPRINTF(( DBG_CONTEXT, "Failed to StoreHeader %s"
                                "in fast map with concat\n",
                                pszHeader));
                        }

                        return ( FALSE);
                    }

                    // See if the buffer has changed. If it has,
                    // update the end pointer and the eol pointer. pszHeader
                    // gets updated at the end of the loop from pszEol. Be
                    // careful if you try and use any other pointers between
                    // here and the end of the loop.
                    // We update these pointers only if they were already pointing
                    // in alloced buffer space ( i.e. not using the m_rcInlinedHeader buffer )

                    if (pOldBuff != (CHAR *)m_buffHeaders.QueryPtr() &&
                        pOldBuff == pchRequest )
                    {
                        // Buffer got resized, fix up appropriate pointers.

                        pchEnd = (CHAR *)m_buffHeaders.QueryPtr() +
                                (pchEnd - pchRequest);
                        pszEol = (CHAR *)m_buffHeaders.QueryPtr() +
                                (pszEol - pchRequest);
                        pchRequest = (CHAR *)m_buffHeaders.QueryPtr();
                    }
                }
            }
            else
            {
                // AddEntry to chunks also has resizing buffer issues. See
                // comments above.

                CHAR        *pOldBuff = (CHAR *)m_buffHeaders.QueryPtr();

                fRet = AddEntryToChunks( pszHeader, cchHeader, pszValue,
                                            cchValue);
                if ( !fRet)
                {
                    IF_DEBUG( ERROR)
                    {

                    DBGPRINTF(( DBG_CONTEXT,
                        "Failed to StoreHeader %s in chunks\n",
                        pszHeader));
                    }
                    return ( FALSE);
                }

                if (pOldBuff != (CHAR *)m_buffHeaders.QueryPtr() &&
                    pOldBuff == pchRequest )
                {
                    // Buffer got resized, fix up appropriate pointers.

                    pchEnd = (CHAR *)m_buffHeaders.QueryPtr() +
                            (pchEnd - pchRequest);
                    pszEol = (CHAR *)m_buffHeaders.QueryPtr() +
                            (pszEol - pchRequest);
                    pchRequest = (CHAR *)m_buffHeaders.QueryPtr();
                }
            }
        }

    } // for()

    if ( (*pszHeader == '\r') || (*pszHeader == '\n') )
    {

        // blank header line - end of the parsing
        while ( cReq )
        {
            --cReq;
            if ( *pszHeader++ == '\n' )
            {
                break;
            }
        }
    }

    *pcbExtraData = DIFF(pchEnd - pszHeader);

    return ( TRUE);

} // HTTP_HEADERS::ParseInput()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\lib\exchbase.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    exchange.cxx

Abstract:

    This module implements the IIS_CRYPTO_EXCHANGE_BASE class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_EXCHANGE_BASE::IIS_CRYPTO_EXCHANGE_BASE()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_BASE class constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Just put the member variables into known states.
    //

    m_hServerSessionKey = CRYPT_NULL;
    m_hClientSessionKey = CRYPT_NULL;

}   // IIS_CRYPTO_EXCHANGE_BASE::IIS_CRYPTO_EXCHANGE_BASE


IIS_CRYPTO_EXCHANGE_BASE::~IIS_CRYPTO_EXCHANGE_BASE()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_BASE class destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hServerSessionKey );
    CLOSE_KEY( m_hClientSessionKey );

}   // IIS_CRYPTO_EXCHANGE_BASE::~IIS_CRYPTO_EXCHANGE_BASE


HRESULT
IIS_CRYPTO_EXCHANGE_BASE::CreatePhase3Hash(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob
    )

/*++

Routine Description:

    Creates the hash value used by phase 3 of the exchange protocol.

Arguments:

    ppHashBlob - Receives a pointer to the hash blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Let the worker function do the dirty work.
    //

    return CreateHashWorker(
               ppHashBlob,
               TRUE         // fPhase3
               );

}   // IIS_CRYPTO_EXCHANGE_BASE::CreatePhase3Hash


HRESULT
IIS_CRYPTO_EXCHANGE_BASE::CreatePhase4Hash(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob
    )

/*++

Routine Description:

    Creates the hash value used by phase 4 of the exchange protocol.

Arguments:

    ppHashBlob - Receives a pointer to the hash blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0
        otherwise.

--*/

{

    //
    // Let the worker function do the dirty work.
    //

    return CreateHashWorker(
               ppHashBlob,
               FALSE        // fPhase3
               );

}   // IIS_CRYPTO_EXCHANGE_BASE::CreatePhase4Hash


//
// Private functions.
//


HRESULT
IIS_CRYPTO_EXCHANGE_BASE::CreateHashWorker(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob,
    IN BOOL fPhase3
    )

/*++

Routine Description:

    Creates the hash value used by the exchange protocol.

Arguments:

    ppHashBlob - Receives a pointer to the hash blob if successful.

    fPhase3 - TRUE if this is the phase 3 hash.

Return Value:

    HRESULT - Completion status, 0 if successful, !0
        otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIIS_CRYPTO_BLOB hashBlob;
    PVOID hashData;
    DWORD hashDataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( m_hServerSessionKey != CRYPT_NULL );
    DBG_ASSERT( m_hClientSessionKey != CRYPT_NULL );
    DBG_ASSERT( ppHashBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    hashBlob = NULL;

    //
    // Create the hash object.
    //

    result = ::IISCryptoCreateHash(
                  &hash,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Hash in the session keys and the constant string.
    //

    result = ::IISCryptoHashSessionKey(
                  hash,
                  m_hClientSessionKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    if( fPhase3 ) {

        result = ::IISCryptoHashSessionKey(
                      hash,
                      m_hServerSessionKey
                      );

        if( FAILED(result) ) {
            goto fatal;
        }

        hashData = (PVOID)HASH_TEXT_STRING_1;
        hashDataLength = sizeof(HASH_TEXT_STRING_1);

    } else {

        hashData = (PVOID)HASH_TEXT_STRING_2;
        hashDataLength = sizeof(HASH_TEXT_STRING_2);

    }

    result = ::IISCryptoHashData(
                  hash,
                  hashData,
                  hashDataLength
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Create the blob.
    //

    result = ::IISCryptoExportHashBlob(
                  &hashBlob,
                  hash
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DESTROY_HASH(hash);
    *ppHashBlob = hashBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB(hashBlob);
    DESTROY_HASH(hash);

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_BASE::CreatePhase4Hash
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\lib\base.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    base.cxx

Abstract:

    This module implements the IIS_CRYPTO_BASE class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_BASE::IIS_CRYPTO_BASE()

/*++

Routine Description:

    IIS_CRYPTO_BASE class constructor. Just sets the member variables
    to known values; does nothing that can actually fail. All of the
    hard work is in the Initialize() method.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Set the handles to known values so we know what to cleanup
    // in the destructor.
    //

    m_hProv = CRYPT_NULL;
    m_fCloseProv = FALSE;
    m_hKeyExchangeKey = CRYPT_NULL;
    m_hSignatureKey = CRYPT_NULL;

}   // IIS_CRYPTO_BASE::IIS_CRYPTO_BASE


IIS_CRYPTO_BASE::~IIS_CRYPTO_BASE()

/*++

Routine Description:

    IIS_CRYPTO_BASE class destructor. Performs any necessary cleanup.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hSignatureKey );
    CLOSE_KEY( m_hKeyExchangeKey );

    //
    // Close the container.
    //

    if( m_fCloseProv && m_hProv != CRYPT_NULL ) {
        (VOID)::IISCryptoCloseContainer( m_hProv );
        m_hProv = CRYPT_NULL;
    }

}   // IIS_CRYPTO_BASE::~IIS_CRYPTO_BASE


HRESULT
IIS_CRYPTO_BASE::GetCryptoContainerByName(
    OUT HCRYPTPROV * phProv,
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    )

/*++

Routine Description:

    Creates or opens the specified crypto container. This method plays
    games to ensure the container can be opened regardless of the
    current security impersonation context.

Arguments:

    phProv - Receives the handle to the provider.

    pszContainerName - The name of the container to open/create. 
                       (NULL means temporary container)

    dwAdditionalFlags - Flags to pass into IISCryptoGetStandardContainer().

    fApplyAcl - If TRUE, then an ACL is applied to the container.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    HANDLE token = NULL;
    BOOL resetToken = FALSE;

    //
    // Sanity check.
    //

    DBG_ASSERT( phProv != NULL );


    //
    // If the caller is not already asking for CRYPT_MACHINE_KEYSET
    // *and* the current process is running in the local system context,
    // then forcibly set CRYPT_MACHINE_KEYSET and note that we need to
    // apply an ACL to the container. This is to workaround an issue
    // with the NT5 Protected Storage service that causes the client-side
    // containers to fail after NT5 GUI Setup. Apparently, there is some
    // as-yet unidentified interaction between creating the client-side
    // container under NT5 GUI Setup (which runs in the Local System
    // security context) and later attempts to create containers in
    // lesser security contexts.
    //

    if( !( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) ) {
        if( AmIRunningInTheLocalSystemContext() ) {
            dwAdditionalFlags |= CRYPT_MACHINE_KEYSET;
            fApplyAcl = TRUE;
        }
    }

    //
    // Step 1: Just try to open/create the container.
    //

    result = ::IISCryptoGetContainerByName(
                   phProv,
                   pszContainerName,
                   dwAdditionalFlags,
                   fApplyAcl
                   );

    if( SUCCEEDED(result) ) {
        goto complete;
    }

    //
    // NTE_BAD_KEYSET is typically returned when the caller has
    // insufficient privilege to access the key container registry
    // tree. If we failed for any other reason, bail.
    //

    if( result != NTE_BAD_KEYSET ) {
        goto complete;
    }

    //
    // Step 2: If the caller didn't ask for CRYPT_MACHINE_KEYSET, then
    // retry the operation with this flag set.
    //

    if( ( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) == 0 ) {

        result = ::IISCryptoGetContainerByName(
                       phProv,
                       pszContainerName,
                       dwAdditionalFlags | CRYPT_MACHINE_KEYSET,
                       fApplyAcl
                       );

        if( SUCCEEDED(result) ) {
            goto complete;
        }

    }

    //
    // OK, now things get a bit complex.
    //
    // If the current thread has an impersonation token, then
    // (temporarily) remove it and retry the container operation.
    // This is mainly here so that ISAPI applications (like, say, ASP)
    // can access the DCOM interface while impersonating a non-privileged
    // security context.
    //
    // Note that, after we remove the impersonation token, we first try
    // the operation with CRYPT_MACHINE_KEYSET ORed in. We do this on
    // the assumption that, if the thread had an impersonation token,
    // then we're probably running in the context of a server process.
    // If this operation fails, we try again without forcing the flag.
    //

    result = GetThreadImpersonationToken( &token );

    if( FAILED(result) ) {
        goto complete;
    }

    if( token != NULL ) {

        result = SetThreadImpersonationToken( NULL );

        if( FAILED(result) ) {
            goto complete;
        }

        resetToken = TRUE;

        //
        // Step 3: With the token removed, retry the operation with the
        // CRYPT_MACHINE_KEYSET flag set if not already set.
        //

        if( ( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) == 0 ) {

            result = ::IISCryptoGetContainerByName(
                           phProv,
                           pszContainerName,
                           dwAdditionalFlags | CRYPT_MACHINE_KEYSET,
                           fApplyAcl
                           );

            if( SUCCEEDED(result) ) {
                goto complete;
            }

        }

        //
        // Step 4: With the token removed, try to open/create the container.
        //

        result = ::IISCryptoGetContainerByName(
                       phProv,
                       pszContainerName,
                       dwAdditionalFlags,
                       fApplyAcl
                       );

        if( SUCCEEDED(result) ) {
            goto complete;
        }

    }

    //
    // If we made it this far, then the container cannot be opened.
    //

    result = NTE_BAD_KEYSET;

complete:

    if( resetToken ) {

        HRESULT result2;

        DBG_ASSERT( token != NULL );
        result2 = SetThreadImpersonationToken( token );

        if( FAILED(result2) ) {

            //
            // This is really, really, really bad news. The current
            // thread, which does not have an impersonation token
            // (and is therefore running in the system context)
            // cannot reset its impersonation token to the original
            // value.
            //

            DBG_ASSERT( SUCCEEDED( result2 ) );
        }

    }

    if( token != NULL ) {
        DBG_REQUIRE( CloseHandle( token ) );
    }

    return result;

}   // IIS_CRYPTO_BASE::GetCryptoContainerByName


HRESULT
IIS_CRYPTO_BASE::Initialize(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKeyExchangeKey,
    IN HCRYPTKEY hSignatureKey,
    IN BOOL fUseMachineKeyset
    )

/*++

Routine Description:

    Performs any complex initialization.

Arguments:

    hProv - Optional pre-opened handle to a crypto provider. If this
        is not present, then the standard container is opened. If this
        is present, then it is used and it is the responsibility of the
        caller to close the handle when no longer needed.

    hKeyExchangeKey - Optional pre-opened handle to a key exchange key. If
        this is not present, then the local key exchange key is used.

    hSignatureKey - Optional pre-opened handle to a signature key. If this
        is not present, then the local signature key is used.

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hProv == CRYPT_NULL );
    DBG_ASSERT( m_hKeyExchangeKey == CRYPT_NULL );
    DBG_ASSERT( m_hSignatureKey == CRYPT_NULL );

    IcpAcquireGlobalLock();

    if( hProv == CRYPT_NULL ) {

        //
        // Open the container.
        //

        result = ::IISCryptoGetStandardContainer(
                       &m_hProv,
                       fUseMachineKeyset
                           ? CRYPT_MACHINE_KEYSET
                           : 0
                       );

        m_fCloseProv = TRUE;

    } else {

        m_hProv = hProv;
        m_fCloseProv = FALSE;
        result = NO_ERROR;

    }

    if( SUCCEEDED(result) ) {

        if( hKeyExchangeKey == CRYPT_NULL ) {

            //
            // Get the key exchange key.
            //

            result = ::IISCryptoGetKeyExchangeKey(
                           &m_hKeyExchangeKey,
                           m_hProv
                           );

        } else {

            m_hKeyExchangeKey = hKeyExchangeKey;

        }

    }

    if( SUCCEEDED(result) ) {

        if( hSignatureKey == CRYPT_NULL ) {

            //
            // Get the signature key.
            //

            result = ::IISCryptoGetSignatureKey(
                           &m_hSignatureKey,
                           m_hProv
                           );

        } else {

            m_hSignatureKey = hSignatureKey;

        }

    }

    IcpReleaseGlobalLock();

    return result;

}   // IIS_CRYPTO_BASE::Initialize

HRESULT
IIS_CRYPTO_BASE::Initialize2(
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Performs any complex initialization.

Arguments:

    hProv - Optional pre-opened handle to a crypto provider. If this
        is not present, then the standard container is opened. If this
        is present, then it is used and it is the responsibility of the
        caller to close the handle when no longer needed.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hProv == CRYPT_NULL );
    DBG_ASSERT( m_hKeyExchangeKey == CRYPT_NULL );
    DBG_ASSERT( m_hSignatureKey == CRYPT_NULL );

    IcpAcquireGlobalLock();

    if( hProv == CRYPT_NULL ) {

        //
        // Open the container.
        //

        result = ::IISCryptoGetStandardContainer2(
                       &m_hProv
                       );

        m_fCloseProv = TRUE;

    } else {

        m_hProv = hProv;
        m_fCloseProv = FALSE;
        result = NO_ERROR;

    }

    IcpReleaseGlobalLock();

    return result;

}   // IIS_CRYPTO_BASE::Initialize2


HRESULT
IIS_CRYPTO_BASE::GetKeyExchangeKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppKeyExchangeKeyBlob
    )

/*++

Routine Description:

    Exports the key exchange key as a public blob.

Arguments:

    ppKeyExchangeKeyBlob - Receives a pointer to the key exchange key
        public blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppKeyExchangeKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   ppKeyExchangeKeyBlob,
                   m_hProv,
                   m_hKeyExchangeKey
                   );

    return result;

}   // IIS_CRYPTO_BASE::GetKeyExchangeKeyBlob


HRESULT
IIS_CRYPTO_BASE::GetSignatureKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSignatureKeyBlob
    )

/*++

Routine Description:

    Exports the signature key as a public blob.

Arguments:

    ppSignatureKeyBlob - Receives a pointer to the signature key
        public blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppSignatureKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   ppSignatureKeyBlob,
                   m_hProv,
                   m_hSignatureKey
                   );

    return result;

}   // IIS_CRYPTO_BASE::GetSignatureKeyBlob


//
// Private functions.
//


#if DBG

BOOL
IIS_CRYPTO_BASE::ValidateState()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hProv != CRYPT_NULL &&
        m_hKeyExchangeKey != CRYPT_NULL &&
        m_hSignatureKey != CRYPT_NULL ) {

        return TRUE;

    }

    return FALSE;

}   // IIS_CRYPTO_BASE::ValidateState

BOOL
IIS_CRYPTO_BASE::ValidateState2()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hProv != CRYPT_NULL )
    {
        return TRUE;
    }

    return FALSE;

}   // IIS_CRYPTO_BASE::ValidateState2

#endif  // DBG


HRESULT
IIS_CRYPTO_BASE::SafeImportSessionKeyBlob(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSignatureKey
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted and the digital signature can be validated.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    hSignatureKey - Handle to the encryption key to use when validating
        the digital signature.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTKEY sessionKey = CRYPT_NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoImportSessionKeyBlob(
                 &sessionKey,
                 pSessionKeyBlob,
                 hProv,
                 hSignatureKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoImportSessionKeyBlob(
                              &sessionKey,
                              pSessionKeyBlob,
                              hProv,
                              hSignatureKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKey != NULL );
        *phSessionKey = sessionKey;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeImportSessionKeyBlob

HRESULT
IIS_CRYPTO_BASE::SafeImportSessionKeyBlob2(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTKEY sessionKey = CRYPT_NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoImportSessionKeyBlob2(
                 &sessionKey,
                 pSessionKeyBlob,
                 hProv,
                 pszPasswd
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoImportSessionKeyBlob2(
                              &sessionKey,
                              pSessionKeyBlob,
                              hProv,
                              pszPasswd
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKey != NULL );
        *phSessionKey = sessionKey;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeImportSessionKeyBlob2


HRESULT
IIS_CRYPTO_BASE::SafeExportSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    private key exchange key) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    hKeyExchangeKey - The key to use when encrypting the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB sessionKeyBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoExportSessionKeyBlob(
                 &sessionKeyBlob,
                 hProv,
                 hSessionKey,
                 hKeyExchangeKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoExportSessionKeyBlob(
                              &sessionKeyBlob,
                              hProv,
                              hSessionKey,
                              hKeyExchangeKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKeyBlob != NULL );
        *ppSessionKeyBlob = sessionKeyBlob;
    }

    return result;

}       // IIS_CRYPTO_BASE::SafeExportSessionKeyBlob

HRESULT
IIS_CRYPTO_BASE::SafeExportSessionKeyBlob2(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    password) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB sessionKeyBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoExportSessionKeyBlob2(
                 &sessionKeyBlob,
                 hProv,
                 hSessionKey,
                 pszPasswd
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoExportSessionKeyBlob2(
                              &sessionKeyBlob,
                              hProv,
                              hSessionKey,
                              pszPasswd
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKeyBlob != NULL );
        *ppSessionKeyBlob = sessionKeyBlob;
    }

    return result;

}       // IIS_CRYPTO_BASE::SafeExportSessionKeyBlob

HRESULT
IIS_CRYPTO_BASE::SafeEncryptDataBlob(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB dataBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoEncryptDataBlob(
                 &dataBlob,
                 pBuffer,
                 dwBufferLength,
                 dwRegType,
                 hProv,
                 hSessionKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoEncryptDataBlob(
                              &dataBlob,
                              pBuffer,
                              dwBufferLength,
                              dwRegType,
                              hProv,
                              hSessionKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( dataBlob != NULL );
        *ppDataBlob = dataBlob;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeEncryptDataBlob

HRESULT
IIS_CRYPTO_BASE::SafeEncryptDataBlob2(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB dataBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoEncryptDataBlob2(
                 &dataBlob,
                 pBuffer,
                 dwBufferLength,
                 dwRegType,
                 hProv,
                 hSessionKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoEncryptDataBlob2(
                              &dataBlob,
                              pBuffer,
                              dwBufferLength,
                              dwRegType,
                              hProv,
                              hSessionKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( dataBlob != NULL );
        *ppDataBlob = dataBlob;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeEncryptDataBlob2

HRESULT
IIS_CRYPTO_BASE::GetThreadImpersonationToken(
    OUT HANDLE * Token
    )
/*++

Routine Description:

    Gets the impersonation token for the current thread.

Arguments:

    Token - Receives a handle to the impersonation token if successful.
        If successful, it is the caller's responsibility to CloseHandle()
        the token when no longer needed.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;

    DBG_ASSERT( Token != NULL );

    //
    // Open the token.
    //

    if( !OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ALL_ACCESS,
            TRUE,
            Token
            ) ) {

        DWORD err = GetLastError();

        //
        // There are a couple of "expected" errors here:
        //
        //     ERROR_NO_TOKEN - The thread has no impersonation token.
        //     ERROR_CALL_NOT_IMPLEMENTED - We're probably on Win9x.
        //     ERROR_NOT_SUPPORTED - Ditto.
        //
        // If OpenThreadToken() failed with any of the above error codes,
        // then succeed the call, but return a NULL token handle.
        //

        if( err != ERROR_NO_TOKEN &&
            err != ERROR_CALL_NOT_IMPLEMENTED &&
            err != ERROR_NOT_SUPPORTED ) {

            result = HRESULT_FROM_WIN32(err);

        }

        *Token = NULL;
    }

    return result;

}   // IIS_CRYPTO_BASE::GetThreadImpersonationToken


HRESULT
IIS_CRYPTO_BASE::SetThreadImpersonationToken(
    IN HANDLE Token
    )
/*++

Routine Description:

    Sets the impersonation token for the current thread.

Arguments:

    Token - A handle to the impersonation token.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;

    //
    // Set it.
    //

    if( !SetThreadToken(
            NULL,
            Token
            ) ) {
        DWORD err = GetLastError();
        result = HRESULT_FROM_WIN32(err);
    }

    return result;

}   // IIS_CRYPTO_BASE::SetThreadImpersonationToken


BOOL
IIS_CRYPTO_BASE::AmIRunningInTheLocalSystemContext(
    VOID
    )
/*++

Routine Description:

    Determines if the current process is running in the local system
    security context.

Arguments:

    None.

Return Value:

    BOOL - TRUE if we're running in the local system context, FALSE
        otherwise.

--*/
{

    BOOL result;
    HANDLE token;
    DWORD lengthRequired;
    PTOKEN_USER tokenInfo;
    PSID systemSid;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    //
    // Setup local so we know how to cleanup on exit.
    //

    result = FALSE;     // until proven otherwise...
    token = NULL;
    tokenInfo = NULL;
    systemSid = NULL;

    //
    // Get a handle to the current process token.
    //

    if( !OpenProcessToken(
            GetCurrentProcess(),                // ProcessHandle
            TOKEN_READ,                         // DesiredAccess
            &token                              // TokenHandle
            ) ) {
        goto cleanup;
    }

    //
    // Determine the length of the token information, then allocate
    // a buffer and read the info.
    //

    if( !GetTokenInformation(
            token,                                  // TokenHandle
            TokenUser,                              // TokenInformationClass
            NULL,                                   // TokenInformation
            0,                                      // TokenInformationLength
            &lengthRequired                         // ReturnLength
            ) ) {
        goto cleanup;
    }

    tokenInfo = (PTOKEN_USER)new char[lengthRequired];

    if( tokenInfo == NULL ) {
        goto cleanup;
    }

    if( !GetTokenInformation(
            token,                              // TokenHandle
            TokenUser,                          // TokenInformationClass
            tokenInfo,                          // TokenInformation
            lengthRequired,                     // TokenInformationLength
            &lengthRequired                     // ReturnLength
            ) ) {
        goto cleanup;
    }

    //
    // OK, we have the token. Now build the system SID so we can compare
    // it with the one stored in the token.
    //

    if( !AllocateAndInitializeSid(
            &ntAuthority,                       // pIdentifierAuthority
            1,                                  // nSubAuthorityCount
            SECURITY_LOCAL_SYSTEM_RID,          // nSubAuthority0
            0,                                  // nSubAuthority1
            0,                                  // nSubAuthority2
            0,                                  // nSubAuthority3
            0,                                  // nSubAuthority4
            0,                                  // nSubAuthority5
            0,                                  // nSubAuthority6
            0,                                  // nSubAuthority7
            &systemSid                          // pSid
            ) ) {
        goto cleanup;
    }

    //
    // Now that we have the SID from the token and our hand-built
    // local system SID, we can compare them.
    //

    result = EqualSid(
                 tokenInfo->User.Sid,           // pSid1
                 systemSid                      // pSid2
                 );

cleanup:

    if( systemSid != NULL ) {
        FreeSid( systemSid );
    }

    if( tokenInfo != NULL ) {
        delete[] tokenInfo;
    }

    if( token != NULL ) {
        CloseHandle( token );
    }

    return result;

}   // IIS_CRYPTO_BASE::AmIRunningInTheLocalSystemContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\lib\exchcli.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    exchange.cxx

Abstract:

    This module implements the IIS_CRYPTO_EXCHANGE_CLIENT class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_EXCHANGE_CLIENT::IIS_CRYPTO_EXCHANGE_CLIENT()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_CLIENT class constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Just put the member variables into known states.
    //

    m_hServerKeyExchangeKey = CRYPT_NULL;
    m_hServerSignatureKey = CRYPT_NULL;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::IIS_CRYPTO_EXCHANGE_CLIENT


IIS_CRYPTO_EXCHANGE_CLIENT::~IIS_CRYPTO_EXCHANGE_CLIENT()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_CLIENT class destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hServerKeyExchangeKey );
    CLOSE_KEY( m_hServerSignatureKey );

}   // IIS_CRYPTO_EXCHANGE_CLIENT::~IIS_CRYPTO_EXCHANGE_CLIENT


HRESULT
IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase1(
    OUT PIIS_CRYPTO_BLOB * ppClientKeyExchangeKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppClientSignatureKeyBlob
    )

/*++

Routine Description:

    Performs client-side phase 1 of the multi-phase key exchange protocol.

Arguments:

    ppClientKeyExchangeKeyBlob - Receives a pointer to the client's key
        exchange key public blob if successful. It is the client's
        responsibility to (somehow) transmit this to the server.

    ppClientSignatureKeyBlob - Receives a pointer to the client's signature
        public blob if successful. It is the client's responsibility to
        (somehow) transmit this to the server.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB keyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB signatureKeyBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppClientKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ppClientSignatureKeyBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    keyExchangeKeyBlob = NULL;
    signatureKeyBlob = NULL;

    //
    // Export the key exchange key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   &keyExchangeKeyBlob,
                   m_hProv,
                   m_hKeyExchangeKey
                   );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export the signature key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                  &signatureKeyBlob,
                  m_hProv,
                  m_hSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DBG_ASSERT( keyExchangeKeyBlob != NULL );
    DBG_ASSERT( signatureKeyBlob != NULL );

    *ppClientKeyExchangeKeyBlob = keyExchangeKeyBlob;
    *ppClientSignatureKeyBlob = signatureKeyBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB( keyExchangeKeyBlob );
    FREE_BLOB( signatureKeyBlob );

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase1


HRESULT
IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase2(
    IN PIIS_CRYPTO_BLOB pServerKeyExchangeKeyBlob,
    IN PIIS_CRYPTO_BLOB pServerSignatureKeyBlob,
    IN PIIS_CRYPTO_BLOB pServerSessionKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppClientSessionKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppClientHashBlob
    )

/*++

Routine Description:

    Performs client-side phase 2 of the multi-phase key exchange protocol.

Arguments:

    pServerKeyExchangeKeyBlob - Pointer to the server's key exchange
        public key blob.

    pServerSignatureKeyBlob - Pointer to the server's signature public
        key blob.

    pServerSessionKeyBlob - Pointer to the server's session key
        blob.

    ppClientSessionKeyBlob - Receives a pointer to the client's
        session key blob if successful.

    ppClientHashBlob - Receives a pointer to the client's hash
        blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB sessionKeyBlob;
    PIIS_CRYPTO_BLOB hashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pServerKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerKeyExchangeKeyBlob ) );
    DBG_ASSERT( pServerSignatureKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerSignatureKeyBlob ) );
    DBG_ASSERT( pServerSessionKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerSessionKeyBlob ) );
    DBG_ASSERT( ppClientSessionKeyBlob != NULL );
    DBG_ASSERT( ppClientHashBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    sessionKeyBlob = NULL;
    hashBlob = NULL;

    //
    // Import the server's keys.
    //

    DBG_ASSERT( m_hServerKeyExchangeKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hServerKeyExchangeKey,
                  pServerKeyExchangeKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    DBG_ASSERT( m_hServerSignatureKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hServerSignatureKey,
                  pServerSignatureKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    DBG_ASSERT( m_hServerSessionKey == CRYPT_NULL );
    result = SafeImportSessionKeyBlob(
                  &m_hServerSessionKey,
                  pServerSessionKeyBlob,
                  m_hProv,
                  m_hServerSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Generate our local session key.
    //

    DBG_ASSERT( m_hClientSessionKey == CRYPT_NULL );
    result = ::IISCryptoGenerateSessionKey(
                  &m_hClientSessionKey,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export it.
    //

    result = SafeExportSessionKeyBlob(
                  &sessionKeyBlob,
                  m_hProv,
                  m_hClientSessionKey,
                  m_hServerKeyExchangeKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Create the phase 3 hash blob.
    //

    result = CreatePhase3Hash(
                  &hashBlob
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    *ppClientSessionKeyBlob = sessionKeyBlob;
    *ppClientHashBlob = hashBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB( sessionKeyBlob );
    FREE_BLOB( hashBlob );

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase2


HRESULT
IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase3(
    IN PIIS_CRYPTO_BLOB pServerHashBlob
    )

/*++

Routine Description:

    Performs client-side phase 3 of the multi-phase key exchange protocol.

Arguments:

    pServerHashBlob - Pointer to the server's hash blob.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB hashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pServerHashBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerHashBlob ) );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hashBlob = NULL;

    //
    // Create the phase 4 hash blob.
    //

    result = CreatePhase4Hash(
                 &hashBlob
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Compare this blob with the one we got from the server.
    // If they match, then the exchange is complete.
    //

    if( !::IISCryptoCompareBlobs(
              pServerHashBlob,
              hashBlob
              ) ) {

        result = ERROR_INVALID_DATA;
        goto fatal;

    }

    //
    // Success!
    //

    FREE_BLOB(hashBlob);

    return NO_ERROR;

fatal:

    FREE_BLOB(hashBlob);

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase3


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\httphdr\tdict.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      tdict.cxx

   Abstract:
      This is a test module for the dictionary objects
      
   Author:

       Murali R. Krishnan    ( MuraliK )     8-Nov-1996 

   Environment:
    
       User Mode - Win32 

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "httphdr.hxx"

#define DEFAULT_TRACE_FLAGS     ((DEBUG_ERROR | DEBUG_PARSING | DEBUG_INIT_CLEAN)

# include "dbgutil.h"
# include <stdio.h>
# include <stdlib.h>

/************************************************************
 *    Functions 
 ************************************************************/

# define INPUT_HEADER_LENGTH_LIMIT   (100000)

DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisTDictGuid, 
0x784d8926, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();    
#endif

CHAR  g_rgchUsage[] = 
" Usage:  %s  [header <header-sequence> | mapper]\n"
"   mapper tests the HTTP_HEADER_MAPPER object which maps HTTP headers\n"
"            to the ordinals\n"
"   header   loads headers and tests the dictionary functions (HTTP_HEADERS)\n"
"          input headers are limited to 100K characters\n"
"   <header-sequence> is a sequence of test vector numbers [0..6] of standard\n"
"            headers built in. Use \'-\' to make it read headers from stdin\n"
"\n"
;

CHAR * g_pszHttpHeader1 = 
"GET / HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:42 GMT; length=4051\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"\r\n"
;

// check if and non-fast map header works
CHAR * g_pszHttpHeader2 = 
"GET /samples/images/background.gif HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Referer: http://muralik0/\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:47 GMT; length=10282\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"MyHeader1: MyValue1\r\n"
"MyHeader2: MyValue2\r\n"
"\r\n"
;


// Checks if concatenation of headers work
CHAR * g_pszHttpHeader3 = 
"GET / HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Accept-Language: en\r\n"
"Accept-Language: es\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:42 GMT; length=4051\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"Connection: 5m\r\n"
"Accept: Testing it \r\n"
"\r\n"
;

// check if and non-fast map header works with concatenation
CHAR * g_pszHttpHeader4 = 
"GET /samples/images/background.gif HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Referer: http://muralik0/\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:47 GMT; length=10282\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"MyHeader1: MyValue1\r\n"
"MyHeader2: MyValue2\r\n"
"MyHeader1: MyValue1_2\r\n"
"\r\n"
;
// check if and non-fast map header works with concatenation and
//  different length aux headers
CHAR * g_pszHttpHeader5 = 
"GET /samples/images/background.gif HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Referer: http://muralik0/\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:47 GMT; length=10282\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"MyHead2: MyValue2\r\n"
"MyHeader1: MyValue1\r\n"
"MyHeader1: MyValue1_2\r\n"
"\r\n"
;

/*
  Headers Sent by Netscape 3.0 client  -- 
  note No CACHE because of this being the first-request :(
 */
CHAR * g_pszHttpHeader6 = 
"GET /scripts/asp/test.asp HTTP/1.0\r\n"
"Connection: Keep-Alive\r\n"
"User-Agent: Mozilla/3.0.(WinNT; I)\r\n"
"Pragma: no-cache\r\n"
"Host: phillich1\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"\r\n";

/*
  Headers Sent by Netscape 3.0 client  -- 
  note No CACHE because of this being the first-request :(
 */
CHAR * g_pszHttpHeader7 = 
"GET /scripts/asp/test.asp HTTP/1.0\r\n"
"Connection: Keep-Alive\r\n"
"User-Agent: Mozilla/3.0 (WinNT; I)\r\n"
"Pragma: no-cache\r\n"
"Host: phillich1\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Cookie: ASPSESSIONID=PVZQGHUMEAYFNRFK\r\n"
"\r\n";


CHAR * g_ppHeaders[] = {
  g_pszHttpHeader1,
  g_pszHttpHeader2,
  g_pszHttpHeader3,
  g_pszHttpHeader4,
  g_pszHttpHeader5,
  g_pszHttpHeader6,
  g_pszHttpHeader7

};

# define MAX_TEST_HEADERS   ( sizeof( g_ppHeaders) / sizeof( g_ppHeaders[0]))


/************************************************************
 *  Functions
 ************************************************************/

VOID PrintUsage( char * pszProgram) 
{
    fprintf( stderr, g_rgchUsage, pszProgram);
    return;
} // PrintUsage()


VOID
TestMapper( int argc, char * argv[]) 
{
    int argSeen;

    const DICTIONARY_MAPPER * pdm = HTTP_HEADERS::QueryHHMapper();

    for( argSeen = 0; argSeen < argc; argSeen++) {
        DWORD dwOrdinal = 0;
        
        if ( pdm->FindOrdinal( argv[argSeen], strlen( argv[argSeen]),
                               & dwOrdinal)
             ) {
            
            DBGPRINTF(( DBG_CONTEXT, "\nFindOrdinal(%d, %s) => %d\n",
                        argSeen, argv[argSeen], dwOrdinal));
            
            LPCSTR pszHeader = pdm->FindName( dwOrdinal);
            
            DBGPRINTF(( DBG_CONTEXT, "FindOrdinal( %d) => %s\n",
                        dwOrdinal, 
                        ( NULL == pszHeader) ? "not found" : pszHeader
                        ));
        } else {

            DBGPRINTF(( DBG_CONTEXT, "\nFindOrdinal( %d, %s) returns failure\n",
                        argSeen, argv[argSeen]));
        }
    } // for

    CHAR pchBuffer[20000];
    DWORD cch = sizeof( pchBuffer);
    pdm->PrintToBuffer( pchBuffer, &cch);
    DBG_ASSERT( cch < sizeof(pchBuffer));

    fprintf( stdout, "Header Mapper is: size=%d\n", cch);
    fwrite( pchBuffer, 1, cch,  stdout);
    
    return;
} // TestMapper()



VOID
ThPrint( IN HTTP_HEADERS * phd) 
{
    // Test Header PrintToBuffer() 

    CHAR pchBuffer[20000];
    DWORD cch;
        
    cch = sizeof( pchBuffer);
    phd->PrintToBuffer( pchBuffer, &cch);
    DBG_ASSERT( cch < sizeof(pchBuffer));
    
    fwrite( pchBuffer, 1, cch,  stdout);
    
    return;
} // ThPrint()


VOID
ThIterator( IN HTTP_HEADERS * phd)
{
    HH_ITERATOR  hhi;
    NAME_VALUE_PAIR * pnp;
    int i;
    
    printf( "\t---- Test Iterator on all headers\n");
    
    phd->InitIterator( &hhi);
    
    for( i = 0; phd->NextPair( &hhi, &pnp); i++) {
        
        // dump the header-value pairs
        printf( "\n   [%d] ", i);
        fwrite( pnp->pchName, 1, pnp->cchName, stdout);
        fputc('\t', stdout);
        fwrite( pnp->pchValue, 1, pnp->cchValue, stdout);
    } // for
    
    printf( "\nTotal of %d headers found. Error = %d\n", i, GetLastError());
    return;
} // ThIterator()


CHAR * pTh1 = "TestHeader1";
CHAR * pTv1 = "TestVal1";
CHAR * pTh2 = "Accept:";
CHAR * pTv2 = "TestVal2";

VOID ThStoreHeader( IN HTTP_HEADERS * phd)
{
    BOOL fRet;

    
    printf( "\n\t---- Test StoreHeader \n");

    fRet = phd->StoreHeader( pTh1, strlen( pTh1),
                             pTv1, strlen( pTv1)
                             );

    printf( "%08x::StoreHeader( %s, %s) return %d\n",
            phd, pTh1, pTv1, fRet);

    fRet = phd->StoreHeader( pTh2, strlen( pTh2),
                             pTv2, strlen( pTv2)
                             );

    printf( "%08x::StoreHeader( %s, %s) return %d\n",
            phd, pTh2, pTv2, fRet);

    // print the headers to test this out.
    ThPrint( phd);

    return;
} // ThStoreHeader()


VOID ThFindValue( IN HTTP_HEADERS * phd)
{
    LPCSTR pszVal;
    DWORD  cchVal;

    printf( "\n\t---- Test FindHeader \n");

    pszVal = phd->FindValue( pTh1, &cchVal);

    printf( "%08x::FindValue( %s, %08x) returns %08x [size=%d] %s\n",
            phd, pTh1, &cchVal, pszVal, cchVal, pszVal);

    cchVal = 0;
    pszVal = phd->FindValue( pTh2);

    printf( "%08x::FindValue( %s, NULL) returns %08x [size=%d] %s\n",
            phd, pTh2, pszVal, cchVal, pszVal);

    // Ask non-existent header
    cchVal = 10000;
    pszVal = phd->FindValue( "random", &cchVal);

    printf( "%08x::FindValue( %s, %08x) returns %08x [size=%d] %s\n",
            phd, "random", &cchVal, pszVal, cchVal, pszVal);

    return;
} // ThFindValue()


VOID ThCancelHeader( IN HTTP_HEADERS * phd)
{
    LPCSTR pszVal;

    printf( "\n\t---- Test CancelHeader \n");

    phd->CancelHeader( pTh1);
    printf( "%08x::CancelHeader( %s) done \n", phd, pTh1);

    phd->CancelHeader( pTh2);
    printf( "%08x::CancelHeader( %s) done \n", phd, pTh2);

    ThPrint( phd);
    return;
} // ThCancelHeader()


VOID ThFmStore( IN HTTP_HEADERS * phd)
{
    BOOL fRet;

    printf( "\n\t---- Test FastMap Store \n");
    phd->FastMapStore( HM_ACC, "text/plain");
    printf( "%08x::FastMapStore( %d, %s) done\n",
            phd, HM_ACC, "text/plain");

    fRet = phd->FastMapStoreWithConcat( HM_ACC, "*/*", 3);
    printf( "%08x::FastMapStoreWithConcat( %d, %s) returns %d\n",
            phd, HM_ACC, "*/*", fRet);
    
    ThPrint( phd);

} // ThFmStore()


BOOL
TestHeaderFuncs( IN HTTP_HEADERS * phd) 
{
    
    DBG_ASSERT( phd);

    ThPrint( phd);
    ThIterator(phd);
    ThStoreHeader( phd);
    ThFindValue( phd);
    ThCancelHeader( phd);
    ThFmStore(phd);
    ThIterator(phd);

    return ( TRUE);
} // TestHeaderFuncs()


BOOL
TestHeader( IN HTTP_HEADERS * phd, 
            IN const CHAR * pszHeader, 
            IN DWORD cchHeader)
{
    DWORD cbExtra = 0;

    phd->Reset();
    
    phd->Print();
    if ( phd->ParseInput( pszHeader, cchHeader, &cbExtra)) {
        
        DBGPRINTF(( DBG_CONTEXT, " Parsed Header \n%s\n was successful. "
                    " Extra bytes = %d\n",
                    pszHeader, cbExtra));

        fprintf( stdout, "Successfully parsed Header @ %08x (size=%d)\n", 
                 pszHeader, cchHeader);

        return ( TestHeaderFuncs( phd));

    } else {

        fprintf( stderr, " Parsing Header \n%s\n failed. Error = %d\n",
                 pszHeader, GetLastError());
        return ( FALSE);
    }

    return (FALSE);
} // TestHeader()


BOOL
GetInputHeader(IN CHAR * pchBuffer, IN OUT LPDWORD pcbHeader)
{
    DWORD cb, cbRead;

    // read the header given in the input - one line at a time

    for ( cb = 0, cbRead = 0; 
          (fgets( pchBuffer + cb, *pcbHeader - cb, stdin) != NULL);
          cb += cbRead
          ){

        if ( pchBuffer[cb] == ';') {

            // This is a comment line. Skip and continue.
            cbRead = 0;
            continue;
        }

        cbRead = strlen( pchBuffer + cb);

        // check for endof line marker
        if ( !strcmp( pchBuffer + cb, "\r\n") ||
             !strcmp( pchBuffer + cb, "\n")
             ){
         
            // we are done. exit now.
            *pcbHeader = (cb + cbRead);
            pchBuffer[ cb + cbRead] = '\0';
            return ( TRUE);
        }
        
    } // for

    return ( FALSE);
} // GetInputHeader()


VOID
TestDictionary( int argc, char * argv[]) 
{
    HTTP_HEADERS  * phd; 

    phd = new HTTP_HEADERS();
    if ( NULL == phd) {
        
        fprintf( stderr, " Unable to create the dictionary. \n");
        exit( 1);
    }

    for ( int i = 0; i < argc; i++) {

        if ( argv[i][0] == '-') {
            
            CHAR pchBuffer[INPUT_HEADER_LENGTH_LIMIT + 2];

            for ( ; ; ) {
                DWORD cchBuffer = sizeof( pchBuffer);
                
                if (!GetInputHeader( pchBuffer, &cchBuffer)) {
                    
                    break;
                }
                
                fprintf( stdout, 
                         "\n ------------  Header from input -----------\n"
                         );
                
                TestHeader( phd, pchBuffer, cchBuffer);
            
                fprintf( stdout,
                         "\n --------------------------------------------\n");
            } // for - as long as there is input
            
        } else { 
            int iHeader = atoi( argv[i]);
            
            if ( iHeader < MAX_TEST_HEADERS) { 
                fprintf( stdout, 
                         "\n ------------  [%4d] =  Header %4d -----------\n",
                         i, iHeader);
                
                TestHeader( phd, g_ppHeaders[iHeader],
                            strlen( g_ppHeaders[iHeader]));
                
                fprintf( stdout,
                     "\n --------------------------------------------\n");
            }
        }
    } // for
    
    delete phd;

    return;
} // TestDictionary()



int __cdecl
main(int argc, char * argv[])
{
    int argSeen = 1;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( argv[0], IisTDictGuid);
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( argv[0]);
    SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_PARSING | DEBUG_INIT_CLEAN);
#endif

    if ( argc < 2) {

        PrintUsage( argv[0]);
        exit(1);
    }

    fprintf( stdout,
             " sizeof( HTTP_HEADERS) = %d\t sizeof(HTTP_HEADER_MAPPER) = %d\n",
             sizeof( HTTP_HEADERS),  sizeof(HTTP_HEADER_MAPPER));
    
    if (  !HTTP_HEADERS::Initialize()) {
        fprintf( stderr, " Initialization failed\n");
        exit (1);
    }
    
    if ( !strcmp( argv[1], "mapper") ) {
        TestMapper( argc-2, argv+2);
    } else if ( !strcmp( argv[1], "header")) {
        TestDictionary( argc-2, argv+2);
    } else {

        PrintUsage( argv[0]);
    }
    
    HTTP_HEADERS::Cleanup();
    
    DELETE_DEBUG_PRINT_OBJECT();

    return (1);
} // main()




/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\client\exchcli.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    exchcli.cxx

Abstract:

    IIS Crypto client-side key exchange test.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define TEST_SOCKERR(api)                                                   \
            if( sockerr != NO_ERROR ) {                                     \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %d\n",                            \
                    api,                                                    \
                    __LINE__,                                               \
                    sockerr                                                 \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
                (b) = NULL;                                                 \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisCryptGuid, 
0x784d8927, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR ClientPlainText[] = "Client Client Client Client Client Client";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    INT sockerr;
    HRESULT result;
    IIS_CRYPTO_EXCHANGE_CLIENT * pclient;
    BUFFERED_SOCKET * psocket;
    PIIS_CRYPTO_BLOB clientKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB clientSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB serverSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientHashBlob;
    PIIS_CRYPTO_BLOB serverHashBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    IIS_CRYPTO_STORAGE * clientStorage;
    IIS_CRYPTO_STORAGE * serverStorage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD bufferType;

    if( argc != 2 ) {

        printf(
            "use: exchcli target_server\n"
            );

        return 1;

    }

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisCryptGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    pclient = NULL;
    psocket = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverHashBlob = NULL;
    dataBlob = NULL;
    clientStorage = NULL;
    serverStorage = NULL;

    //
    // Initialize the crypto package.
    //

    printf( "exchcli: Initializing...\n" );

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create & initialize the client-side key exchange object.
    //

    pclient = new IIS_CRYPTO_EXCHANGE_CLIENT;

    if( pclient == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = pclient->Initialize(
                 CRYPT_NULL,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );

    TEST_HRESULT( "pclient->Initialize()" );

    //
    // Create & initialize the buffered socket object.
    //

    psocket = new BUFFERED_SOCKET;

    if( psocket == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = psocket->InitializeClient( argv[1], SERVER_PORT );

    TEST_HRESULT( "psocket->Initialize()" );

    //
    // 1. CLIENT(1)
    //

    printf( "exchcli: Phase 1...\n" );

    result = pclient->ClientPhase1(
                 &clientKeyExchangeKeyBlob,
                 &clientSignatureKeyBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase1()" );

    sockerr = psocket->SendBlob( clientKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientSignatureKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 3. CLIENT(2)
    //

    printf( "exchcli: Phase 2...\n" );

    sockerr = psocket->RecvBlob( &serverKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSignatureKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSessionKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase2(
                 serverKeyExchangeKeyBlob,
                 serverSignatureKeyBlob,
                 serverSessionKeyBlob,
                 &clientSessionKeyBlob,
                 &clientHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase2()" );

    sockerr = psocket->SendBlob( clientSessionKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientHashBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 5. CLIENT(3)
    //

    printf( "exchcli: Phase 3...\n" );

    sockerr = psocket->RecvBlob( &serverHashBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase3(
                 serverHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase3()" );

    //
    // Create the storage objects.
    //

    printf( "exchcli: Creating storage objects...\n" );

    clientStorage = new IIS_CRYPTO_STORAGE;

    if( clientStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = clientStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeClientSessionKey(),
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );
    TEST_HRESULT( "clientStorage->Initialize()" );

    serverStorage = new IIS_CRYPTO_STORAGE;

    if( serverStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = serverStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeServerSessionKey(),
                 CRYPT_NULL,
                 pclient->AssumeServerSignatureKey(),
                 TRUE
                 );
    TEST_HRESULT( "serverStorage->Initialize()" );

    //
    // Send some encrypted data.
    //

    printf( "exchcli: Encrypting '%s'...\n", ClientPlainText );

    result = clientStorage->EncryptData(
                 &dataBlob,
                 ClientPlainText,
                 sizeof(ClientPlainText),
                 REG_SZ
                 );
    TEST_HRESULT( "clientStorage->EncryptData()" );

    printf( "exchcli: Sending encrypted data...\n" );

    sockerr = psocket->SendBlob( dataBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    FREE_BLOB( dataBlob );

    //
    // Receive some encrypted data.
    //

    printf( "exchcli: Receiving encrypted data...\n" );

    sockerr = psocket->RecvBlob( &dataBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = serverStorage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &bufferType,
                 dataBlob
                 );
    TEST_HRESULT( "serverStorage->DecryptData()" );

    printf( "exchcli: Received data[%lu] = '%s'\n", bufferLength, buffer );

    //
    // Tests complete.
    //

    printf( "exchcli: Done!\n" );

cleanup:

    FREE_BLOB( dataBlob );
    FREE_BLOB( serverHashBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientKeyExchangeKeyBlob );

    delete psocket;
    delete clientStorage;
    delete serverStorage;
    delete pclient;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\lib\storage.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    storage.cxx

Abstract:

    This module implements the IIS_CRYPTO_STORAGE class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_STORAGE::IIS_CRYPTO_STORAGE()

/*++

Routine Description:

    IIS_CRYPTO_STORAGE class constructor. Just sets the member variables
    to known values; does nothing that can actually fail. All of the
    hard work is in the Initialize() methods.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Set the handles to known values so we know what to cleanup
    // in the destructor.
    //

    m_hSessionKey = CRYPT_NULL;

}   // IIS_CRYPTO_STORAGE::IIS_CRYPTO_STORAGE


IIS_CRYPTO_STORAGE::~IIS_CRYPTO_STORAGE()

/*++

Routine Description:

    IIS_CRYPTO_STORAGE class destructor. Performs any necessary cleanup.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hSessionKey );

}   // IIS_CRYPTO_STORAGE::~IIS_CRYPTO_STORAGE


HRESULT
IIS_CRYPTO_STORAGE::Initialize(
    IN BOOL fUseMachineKeyset,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Generates a new (random) session key.

Arguments:

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize(
                 hProv,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 fUseMachineKeyset
                 );

    if( SUCCEEDED(result) ) {

        //
        // Generate the session key.
        //

        result = ::IISCryptoGenerateSessionKey(
                       &m_hSessionKey,
                       m_hProv
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IISCryptoGenerateSessionKey err=0x%x.\n",result));
        }

    }
    else
    {
        // something failed.
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize:IIS_CRYPTO_BASE::Initialize Failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE::Initialize

HRESULT
IIS_CRYPTO_STORAGE2::Initialize(
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Generates a new (random) session key.

Arguments:

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );

    //
    // Initialize the base class.
    //

    result = Initialize2( hProv );

    if( SUCCEEDED(result) ) {

        //
        // Generate the session key.
        //

        result = ::IISCryptoGenerateSessionKey(
                       &m_hSessionKey,
                       m_hProv
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IISCryptoGenerateSessionKey err=0x%x.\n",result));
        }

    }
    else
    {
        // something failed.
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize:IIS_CRYPTO_BASE::Initialize Failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE2::Initialize


HRESULT
IIS_CRYPTO_STORAGE::Initialize(
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN BOOL fUseMachineKeyset,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Imports the specified session key blob.

Arguments:

    pSessionKeyBlob - Points to the secure key blob to import.

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize(
                 hProv,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 fUseMachineKeyset
                 );

    if( SUCCEEDED(result) ) {

        //
        // Import the session key blob.
        //

        result = SafeImportSessionKeyBlob(
                       &m_hSessionKey,
                       pSessionKeyBlob,
                       m_hProv,
                       m_hSignatureKey
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize SafeImportSessionKeyBlob failed err=0x%x.\n",result));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IIS_CRYPTO_BASE::Initialize failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE::Initialize

HRESULT
IIS_CRYPTO_STORAGE2::Initialize(
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN LPSTR pszPasswd,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Imports the specified session key blob.

Arguments:

    pSessionKeyBlob - Points to the secure key blob to import.

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );
    DBG_ASSERT( pszPasswd != NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize( hProv );

    if( SUCCEEDED(result) ) {

        //
        // Import the session key blob.
        //

        result = SafeImportSessionKeyBlob2(
                       &m_hSessionKey,
                       pSessionKeyBlob,
                       m_hProv,
                       pszPasswd
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize SafeImportSessionKeyBlob failed err=0x%x.\n",result));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IIS_CRYPTO_BASE::Initialize failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE2::Initialize


HRESULT
IIS_CRYPTO_STORAGE::Initialize(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey,
    IN HCRYPTKEY hSignatureKey,
    IN BOOL fUseMachineKeyset
    )

/*++

Routine Description:

    Initializes the object using pre-created provider and session key.

Arguments:

    hProv - An open handle to a crypto provider.

    hSessionKey - The session key for the object.

    hKeyExchangeKey - A pre-opened key exchange key.

    hSignatureKey - A pre-opened signature key.

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize(
                 hProv,
                 hKeyExchangeKey,
                 hSignatureKey,
                 fUseMachineKeyset
                 );

    if( SUCCEEDED(result) ) {

        //
        // Save the session key.
        //

        m_hSessionKey = hSessionKey;
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IIS_CRYPTO_BASE::Initialize failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE::Initialize


HRESULT
IIS_CRYPTO_STORAGE::GetSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob
    )

/*++

Routine Description:

    Exports the session key as a secure key blob.

Arguments:

    ppSessionKeyBlob - Receives a pointer to the session key secure
        blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppSessionKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeExportSessionKeyBlob(
                   ppSessionKeyBlob,
                   m_hProv,
                   m_hSessionKey,
                   m_hKeyExchangeKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE::GetSessionKeyBlob

HRESULT
IIS_CRYPTO_STORAGE2::GetSessionKeyBlob(
    IN LPSTR pszPasswd,
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob
    )

/*++

Routine Description:

    Exports the session key as a secure key blob.

Arguments:

    ppSessionKeyBlob - Receives a pointer to the session key secure
        blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppSessionKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeExportSessionKeyBlob2(
                   ppSessionKeyBlob,
                   m_hProv,
                   m_hSessionKey,
                   pszPasswd
                   );

    return result;

}   // IIS_CRYPTO_STORAGE2::GetSessionKeyBlob


HRESULT
IIS_CRYPTO_STORAGE::EncryptData(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType
    )

/*++

Routine Description:

    Encrypts a block of data and produces a secure data blob.

Arguments:

    ppDataBlob - Receives a pointer to the secure data blob if
        successful.

    pBuffer - Pointer to the buffer to encrypt.

    dwBufferLength - The length of the data buffer.

    dwRegType - The REG_* type for the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeEncryptDataBlob(
                   ppDataBlob,
                   pBuffer,
                   dwBufferLength,
                   dwRegType,
                   m_hProv,
                   m_hSessionKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE::EncryptData

HRESULT
IIS_CRYPTO_STORAGE2::EncryptData(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType
    )

/*++

Routine Description:

    Encrypts a block of data and produces a secure data blob.

Arguments:

    ppDataBlob - Receives a pointer to the secure data blob if
        successful.

    pBuffer - Pointer to the buffer to encrypt.

    dwBufferLength - The length of the data buffer.

    dwRegType - The REG_* type for the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeEncryptDataBlob2(
                   ppDataBlob,
                   pBuffer,
                   dwBufferLength,
                   dwRegType,
                   m_hProv,
                   m_hSessionKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE2::EncryptData


HRESULT
IIS_CRYPTO_STORAGE::DecryptData(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob
    )

/*++

Routine Description:

    Decrypts a secure data blob, producing a data pointer and data
    length.

Arguments:

    ppBuffer - Receives a pointer to the decrypted data if succesful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - A pointer to the data blob to decrypt.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoDecryptDataBlob(
                   ppBuffer,
                   pdwBufferLength,
                   pdwRegType,
                   pDataBlob,
                   m_hProv,
                   m_hSessionKey,
                   m_hSignatureKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE::DecryptData

HRESULT
IIS_CRYPTO_STORAGE2::DecryptData(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob
    )

/*++

Routine Description:

    Decrypts a secure data blob, producing a data pointer and data
    length.

Arguments:

    ppBuffer - Receives a pointer to the decrypted data if succesful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - A pointer to the data blob to decrypt.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoDecryptDataBlob2(
                   ppBuffer,
                   pdwBufferLength,
                   pdwRegType,
                   pDataBlob,
                   m_hProv,
                   m_hSessionKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE2::DecryptData


//
// Private functions.
//


#if DBG

BOOL
IIS_CRYPTO_STORAGE::ValidateState()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hSessionKey != CRYPT_NULL ) {

        return IIS_CRYPTO_BASE::ValidateState();

    }

    return FALSE;

}   // IIS_CRYPTO_STORAGE::ValidateState

BOOL
IIS_CRYPTO_STORAGE2::ValidateState()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hSessionKey != CRYPT_NULL ) {

        return IIS_CRYPTO_BASE::ValidateState2();

    }

    return FALSE;

}   // IIS_CRYPTO_STORAGE::ValidateState

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\lib\exchsrv.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    exchange.cxx

Abstract:

    This module implements the IIS_CRYPTO_EXCHANGE_SERVER class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_EXCHANGE_SERVER::IIS_CRYPTO_EXCHANGE_SERVER()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_SERVER class constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Just put the member variables into known states.
    //

    m_hClientKeyExchangeKey = CRYPT_NULL;
    m_hClientSignatureKey = CRYPT_NULL;

}   // IIS_CRYPTO_EXCHANGE_SERVER::IIS_CRYPTO_EXCHANGE_SERVER


IIS_CRYPTO_EXCHANGE_SERVER::~IIS_CRYPTO_EXCHANGE_SERVER()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_SERVER class destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hClientKeyExchangeKey );
    CLOSE_KEY( m_hClientSignatureKey );

}   // IIS_CRYPTO_EXCHANGE_SERVER::~IIS_CRYPTO_EXCHANGE_SERVER


HRESULT
IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase1(
    IN PIIS_CRYPTO_BLOB pClientKeyExchangeKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerKeyExchangeKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSessionKeyBlob
    )

/*++

Routine Description:

    Performs server-side phase 1 of the multi-phase key exchange protocol.

Arguments:

    pClientKeyExchangeKeyBlob - Pointer to the client's key exchange key
        public blob.

    pClientSignatureKeyBlob - Pointer to the client's signature public
        blob.

    ppServerKeyExchangeKeyBlob - Receives a pointer to the server's key
        exchange key public blob if successful. It is the server's
        responsibility to (somehow) transmit this to the client.

    ppServerSignatureKeyBlob - Receives a pointer to the server's signature
        public blob if successful. It is the server's responsibility to
        (somehow) transmit this to the client.

    ppServerSessionKeyBlob - Receives a pointer to the server's
        session key blob if successful. It is the server's responsibility
        to (somehow) transmit this to the client.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB keyExchangeKeyBlob = NULL;
    PIIS_CRYPTO_BLOB signatureKeyBlob = NULL;
    PIIS_CRYPTO_BLOB sessionKeyBlob = NULL;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pClientKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ::IISCryptoIsValidBlob( pClientKeyExchangeKeyBlob ) );
    DBG_ASSERT( pClientSignatureKeyBlob != NULL );
    DBG_ASSERT( ::IISCryptoIsValidBlob( pClientSignatureKeyBlob ) );
    DBG_ASSERT( ppServerKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ppServerSessionKeyBlob != NULL );

    //
    // Import the client's keys.
    //

    DBG_ASSERT( m_hClientKeyExchangeKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hClientKeyExchangeKey,
                  pClientKeyExchangeKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    DBG_ASSERT( m_hClientSignatureKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hClientSignatureKey,
                  pClientSignatureKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export the key exchange key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   &keyExchangeKeyBlob,
                   m_hProv,
                   m_hKeyExchangeKey
                   );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export the signature key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                  &signatureKeyBlob,
                  m_hProv,
                  m_hSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Generate our local session key.
    //

    DBG_ASSERT( m_hServerSessionKey == CRYPT_NULL );
    result = ::IISCryptoGenerateSessionKey(
                  &m_hServerSessionKey,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export it.
    //

    result = SafeExportSessionKeyBlob(
                  &sessionKeyBlob,
                  m_hProv,
                  m_hServerSessionKey,
                  m_hClientKeyExchangeKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    *ppServerKeyExchangeKeyBlob = keyExchangeKeyBlob;
    *ppServerSignatureKeyBlob = signatureKeyBlob;
    *ppServerSessionKeyBlob = sessionKeyBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB(sessionKeyBlob);
    FREE_BLOB(signatureKeyBlob);
    FREE_BLOB(keyExchangeKeyBlob);

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase1


HRESULT
IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase2(
    IN PIIS_CRYPTO_BLOB pClientSessionKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientHashBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerHashBlob
    )

/*++

Routine Description:

    Performs server-side phase 2 of the multi-phase key exchange protocol.

Arguments:

    pClientSessionKeyBlob - Pointer to the client's session key blob.

    pClientHashBlob - Pointer to the client's hash blob.

    ppServerHashBlob - Receives a pointer to the server's hash blob
        if successful.


Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB phase3HashBlob;
    PIIS_CRYPTO_BLOB phase4HashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pClientSessionKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pClientSessionKeyBlob ) );
    DBG_ASSERT( pClientHashBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pClientHashBlob ) );
    DBG_ASSERT( ppServerHashBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    phase3HashBlob = NULL;
    phase4HashBlob = NULL;

    //
    // Import the client's session key.
    //

    DBG_ASSERT( m_hClientSessionKey == CRYPT_NULL );
    result = SafeImportSessionKeyBlob(
                  &m_hClientSessionKey,
                  pClientSessionKeyBlob,
                  m_hProv,
                  m_hClientSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Create the phase 3 hash and compare it with the incoming hash.
    //

    result = CreatePhase3Hash(
                 &phase3HashBlob
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    if( !::IISCryptoCompareBlobs(
              pClientHashBlob,
              phase3HashBlob
              ) ) {

        result = ERROR_INVALID_DATA;
        goto fatal;

    }

    //
    // Create the phase 4 hash to return to the client.
    //

    result = CreatePhase4Hash(
                 &phase4HashBlob
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    *ppServerHashBlob = phase4HashBlob;
    FREE_BLOB( phase3HashBlob );

    return NO_ERROR;

fatal:

    FREE_BLOB( phase3HashBlob );
    FREE_BLOB( phase4HashBlob );

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase2


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\client\exchcli2.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    exchcli2.cxx

Abstract:

    IIS Crypto client-side key exchange test with security impersonation.

Author:

    Keith Moore (keithmo)        14-Oct-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define TEST_SOCKERR(api)                                                   \
            if( sockerr != NO_ERROR ) {                                     \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %d\n",                            \
                    api,                                                    \
                    __LINE__,                                               \
                    sockerr                                                 \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
                (b) = NULL;                                                 \
                                                                            \
            }

#define PACKAGE_NAME    L"NTLM"

#define KEY_CTRL_C      '\x03'
#define KEY_BACKSPACE   '\x08'
#define KEY_ENTER       '\x0d'
#define KEY_EOF         '\x1a'
#define KEY_ESCAPE      '\x1b'

#define STR_BEEP        "\x07"
#define STR_HIDDEN      "*"
#define STR_BACKSPACE   "\x08 \x08"

#define ALLOC_MEM(cb)   (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(p)     (VOID)LocalFree( (HLOCAL)(p) )

#define DIM(x)          (sizeof(x) / sizeof(x[0]))


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisCrypt2Guid, 
0x784d8928, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR ClientPlainText[] = "Client Client Client Client Client Client";


//
// Private prototypes.
//

SECURITY_STATUS
MyLogonUser(
    IN LPWSTR UserName,
    IN LPWSTR UserDomain,
    IN LPWSTR UserPassword,
    OUT PCtxtHandle ServerContext,
    OUT PCredHandle ServerCredential
    );

BOOL
GetStringFromUser(
    LPSTR Prompt,
    LPWSTR String,
    ULONG MaxLength,
    BOOL Echo
    );


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    INT sockerr;
    HRESULT result;
    IIS_CRYPTO_EXCHANGE_CLIENT * pclient;
    BUFFERED_SOCKET * psocket;
    PIIS_CRYPTO_BLOB clientKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB clientSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB serverSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientHashBlob;
    PIIS_CRYPTO_BLOB serverHashBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    IIS_CRYPTO_STORAGE * clientStorage;
    IIS_CRYPTO_STORAGE * serverStorage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD bufferType;
    PSecurityFunctionTable ftab;
    CtxtHandle serverContext;
    CredHandle serverCredential;
    WCHAR name[128];
    WCHAR domain[128];
    WCHAR password[128];

    if( argc != 2 ) {

        printf(
            "use: exchcli2 target_server\n"
            );

        return 1;

    }

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisCrypt2Guid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    pclient = NULL;
    psocket = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverHashBlob = NULL;
    dataBlob = NULL;
    clientStorage = NULL;
    serverStorage = NULL;

    //
    // Initialize SSPI.
    //

    ftab = InitSecurityInterface();

    if( ftab == NULL ) {
        sockerr = GetLastError();
        TEST_SOCKERR( "InitSecurityInterface()" );
    }

    //
    // Prompt for the user name, domain, and password.
    //

    if( !GetStringFromUser( "name: ", name, DIM(name), TRUE ) ||
        !GetStringFromUser( "domain: ", domain, DIM(domain), TRUE ) ||
        !GetStringFromUser( "password: ", password, DIM(password), FALSE ) ) {
        goto cleanup;
    }

    //
    // Logon.
    //

    result = MyLogonUser(
                 name,
                 domain,
                 password,
                 &serverContext,
                 &serverCredential
                 );

    RtlZeroMemory(
        password,
        sizeof(password)
        );

    TEST_HRESULT( "MyLogonUser" );

    result = ImpersonateSecurityContext( &serverContext );
    TEST_HRESULT( "ImpersonateSecurityContext" );

    //
    // Initialize the crypto package.
    //

    printf( "exchcli2: Initializing...\n" );

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create & initialize the client-side key exchange object.
    //

    pclient = new IIS_CRYPTO_EXCHANGE_CLIENT;

    if( pclient == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = pclient->Initialize(
                 CRYPT_NULL,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );

    TEST_HRESULT( "pclient->Initialize()" );

    //
    // Create & initialize the buffered socket object.
    //

    psocket = new BUFFERED_SOCKET;

    if( psocket == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = psocket->InitializeClient( argv[1], SERVER_PORT );

    TEST_HRESULT( "psocket->Initialize()" );

    //
    // 1. CLIENT(1)
    //

    printf( "exchcli2: Phase 1...\n" );

    result = pclient->ClientPhase1(
                 &clientKeyExchangeKeyBlob,
                 &clientSignatureKeyBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase1()" );

    sockerr = psocket->SendBlob( clientKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientSignatureKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 3. CLIENT(2)
    //

    printf( "exchcli2: Phase 2...\n" );

    sockerr = psocket->RecvBlob( &serverKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSignatureKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSessionKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase2(
                 serverKeyExchangeKeyBlob,
                 serverSignatureKeyBlob,
                 serverSessionKeyBlob,
                 &clientSessionKeyBlob,
                 &clientHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase2()" );

    sockerr = psocket->SendBlob( clientSessionKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientHashBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 5. CLIENT(3)
    //

    printf( "exchcli2: Phase 3...\n" );

    sockerr = psocket->RecvBlob( &serverHashBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase3(
                 serverHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase3()" );

    //
    // Create the storage objects.
    //

    printf( "exchcli2: Creating storage objects...\n" );

    clientStorage = new IIS_CRYPTO_STORAGE;

    if( clientStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = clientStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeClientSessionKey(),
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );
    TEST_HRESULT( "clientStorage->Initialize()" );

    serverStorage = new IIS_CRYPTO_STORAGE;

    if( serverStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = serverStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeServerSessionKey(),
                 CRYPT_NULL,
                 pclient->AssumeServerSignatureKey(),
                 TRUE
                 );
    TEST_HRESULT( "serverStorage->Initialize()" );

    //
    // Send some encrypted data.
    //

    printf(
        "exchcli2: Encrypting '%s'...\n",
        ClientPlainText
        );

    result = clientStorage->EncryptData(
                 &dataBlob,
                 ClientPlainText,
                 sizeof(ClientPlainText),
                 REG_SZ
                 );
    TEST_HRESULT( "clientStorage->EncryptData()" );

    printf( "exchcli2: Sending encrypted data...\n" );

    sockerr = psocket->SendBlob( dataBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    FREE_BLOB( dataBlob );

    //
    // Receive some encrypted data.
    //

    printf( "exchcli2: Receiving encrypted data...\n" );

    sockerr = psocket->RecvBlob( &dataBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = serverStorage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &bufferType,
                 dataBlob
                 );
    TEST_HRESULT( "serverStorage->DecryptData()" );

    printf(
        "exchcli2: Received data[%lu] = '%s'\n",
        bufferLength,
        buffer
        );

    //
    // Tests complete.
    //

    printf( "exchcli2: Done!\n" );

cleanup:

    FREE_BLOB( dataBlob );
    FREE_BLOB( serverHashBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientKeyExchangeKeyBlob );

    delete psocket;
    delete clientStorage;
    delete serverStorage;
    delete pclient;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//

SECURITY_STATUS
MyLogonUser(
    IN LPWSTR UserName,
    IN LPWSTR UserDomain,
    IN LPWSTR UserPassword,
    OUT PCtxtHandle ServerContext,
    OUT PCredHandle ServerCredential
    )
{

    SECURITY_STATUS status;
    PSecPkgInfoW packageInfo;
    PSEC_WINNT_AUTH_IDENTITY_W additionalCredentials;
    ULONG additionalCredentialsLength;
    LPWSTR next;
    CredHandle clientCredential;
    TimeStamp expiration;
    SecBufferDesc tokenBuffer1Desc;
    SecBuffer tokenBuffer1;
    SecBufferDesc tokenBuffer2Desc;
    SecBuffer tokenBuffer2;
    ULONG contextAttributes;
    CtxtHandle clientContext;
    PVOID rawTokenBuffer1;
    PVOID rawTokenBuffer2;
    BOOL haveClientCredential;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    packageInfo = NULL;
    additionalCredentials = NULL;
    rawTokenBuffer1 = NULL;
    rawTokenBuffer2 = NULL;
    haveClientCredential = FALSE;

    //
    // Get the package info. We must do this to get the maximum
    // token length.
    //

    status = QuerySecurityPackageInfoW(
                 PACKAGE_NAME,                  // pszPackageName
                 &packageInfo                   // ppPackageInfo
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Allocate the token buffers.
    //

    rawTokenBuffer1 = ALLOC_MEM( packageInfo->cbMaxToken );
    rawTokenBuffer2 = ALLOC_MEM( packageInfo->cbMaxToken );

    if( rawTokenBuffer1 == NULL ||
        rawTokenBuffer2 == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Build the credential info containing the cleartext user name,
    // domain name, and password.
    //

    additionalCredentialsLength = sizeof(*additionalCredentials);

    if( UserName != NULL ) {
        additionalCredentialsLength += ( wcslen( UserName ) + 1 ) * sizeof(WCHAR);
    }

    if( UserDomain != NULL ) {
        additionalCredentialsLength += ( wcslen( UserDomain ) + 1 ) * sizeof(WCHAR);
    }

    if( UserPassword != NULL ) {
        additionalCredentialsLength += ( wcslen( UserPassword ) + 1 ) * sizeof(WCHAR);
    }

    additionalCredentials = (PSEC_WINNT_AUTH_IDENTITY_W)ALLOC_MEM( additionalCredentialsLength );

    if( additionalCredentials == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(
        additionalCredentials,
        additionalCredentialsLength
        );

    next = (LPWSTR)( additionalCredentials + 1 );

    additionalCredentials->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    if( UserName != NULL ) {
        additionalCredentials->User = (unsigned short *)next;
        additionalCredentials->UserLength = wcslen( UserName );
        wcscpy( next, UserName );
        next += additionalCredentials->UserLength + 1;
    }

    if( UserDomain != NULL ) {
        additionalCredentials->Domain = (unsigned short *)next;
        additionalCredentials->DomainLength = wcslen( UserDomain );
        wcscpy( next, UserDomain );
        next += additionalCredentials->DomainLength + 1;
    }

    if( UserPassword != NULL ) {
        additionalCredentials->Password = (unsigned short *)next;
        additionalCredentials->PasswordLength = wcslen( UserPassword );
        wcscpy( next, UserPassword );
        next += additionalCredentials->PasswordLength + 1;
    }

    //
    // Get the client-side credentials.
    //

    status = AcquireCredentialsHandleW(
                 NULL,                          // pszPrincipal
                 PACKAGE_NAME,                  // pszPackage
                 SECPKG_CRED_OUTBOUND,          // fCredentialUse
                 NULL,                          // pvLogonID
                 additionalCredentials,         // pAuthData
                 NULL,                          // pGetKeyFn
                 NULL,                          // pvGetKeyArgument
                 &clientCredential,             // phCredential
                 &expiration                    // ptsExpiry
                 );

    RtlZeroMemory(
        additionalCredentials->Password,
        additionalCredentials->PasswordLength
        );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    haveClientCredential = TRUE;

    //
    // Get the server-side credentials.
    //

    status = AcquireCredentialsHandleW(
                 NULL,                          // pszPrincipal
                 PACKAGE_NAME,                  // pszPackage
                 SECPKG_CRED_INBOUND,           // fCredentialUse
                 NULL,                          // pvLogonID
                 NULL,                          // pAuthData
                 NULL,                          // pGetKeyFn
                 NULL,                          // pvGetKeyArgument
                 ServerCredential,              // phCredential
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Initialize the client-side security context.
    //

    tokenBuffer1Desc.cBuffers = 1;
    tokenBuffer1Desc.pBuffers = &tokenBuffer1;
    tokenBuffer1Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer1.BufferType = SECBUFFER_TOKEN;
    tokenBuffer1.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer1.pvBuffer = rawTokenBuffer1;

    status = InitializeSecurityContext(
                 &clientCredential,             // phCredential
                 NULL,                          // phContext
                 NULL,                          // pszTargetName
                 ISC_REQ_REPLAY_DETECT,         // fContextReq
                 0,                             // Reserved1
                 SECURITY_NATIVE_DREP,          // TargetDataRep,
                 NULL,                          // pInput
                 0,                             // Reserved2
                 &clientContext,                // phNewContext
                 &tokenBuffer1Desc,             // pOutput,
                 &contextAttributes,            // pfContextAttr,
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Import the client-side context into the server side.
    //

    tokenBuffer2Desc.cBuffers = 1;
    tokenBuffer2Desc.pBuffers = &tokenBuffer2;
    tokenBuffer2Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer2.BufferType = SECBUFFER_TOKEN;
    tokenBuffer2.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer2.pvBuffer = rawTokenBuffer2;

    status = AcceptSecurityContext(
                 ServerCredential,              // phCredential
                 NULL,                          // phContext
                 &tokenBuffer1Desc,             // pInput
                 0,                             // fContextReq
                 SECURITY_NATIVE_DREP,          // TargetDataRep
                 ServerContext,                 // phNewContext
                 &tokenBuffer2Desc,             // pOutput
                 &contextAttributes,            // pfContextAttr
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Pass it back into the client.
    //

    tokenBuffer1Desc.cBuffers = 1;
    tokenBuffer1Desc.pBuffers = &tokenBuffer1;
    tokenBuffer1Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer1.BufferType = SECBUFFER_TOKEN;
    tokenBuffer1.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer1.pvBuffer = rawTokenBuffer1;

    status = InitializeSecurityContext(
                 &clientCredential,             // phCredential
                 &clientContext,                // phContext
                 NULL,                          // pszTargetName
                 0,                             // fContextReq
                 0,                             // Reserved1
                 SECURITY_NATIVE_DREP,          // TargetDataRep,
                 &tokenBuffer2Desc,             // pInput
                 0,                             // Reserved2
                 &clientContext,                // phNewContext
                 &tokenBuffer1Desc,             // pOutput,
                 &contextAttributes,            // pfContextAttr,
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // And one last time back into the server.
    //

    tokenBuffer2Desc.cBuffers = 1;
    tokenBuffer2Desc.pBuffers = &tokenBuffer2;
    tokenBuffer2Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer2.BufferType = SECBUFFER_TOKEN;
    tokenBuffer2.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer2.pvBuffer = rawTokenBuffer2;

    status = AcceptSecurityContext(
                 ServerCredential,              // phCredential
                 ServerContext,                 // phContext
                 &tokenBuffer1Desc,             // pInput
                 0,                             // fContextReq
                 SECURITY_NATIVE_DREP,          // TargetDataRep
                 ServerContext,                 // phNewContext
                 NULL,                          // pOutput
                 &contextAttributes,            // pfContextAttr
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

Cleanup:

    if( haveClientCredential ) {
        FreeCredentialsHandle( &clientCredential );
    }

    if( rawTokenBuffer2 != NULL ) {
        FREE_MEM( rawTokenBuffer2 );
    }

    if( rawTokenBuffer1 != NULL ) {
        FREE_MEM( rawTokenBuffer1 );
    }

    if( additionalCredentials != NULL ) {
        FREE_MEM( additionalCredentials );
    }

    if( packageInfo != NULL ) {
        FreeContextBuffer( packageInfo );
    }

    return status;

}   // MyLogonUser

BOOL
GetStringFromUser(
    LPSTR Prompt,
    LPWSTR String,
    ULONG MaxLength,
    BOOL Echo
    )
{

    ULONG length;
    INT ch;

    printf( "%s", Prompt );

    length = 0;

    for( ; ; ) {

        ch = _getch();

        switch( ch ) {

        case KEY_CTRL_C :
            return FALSE;

        case KEY_BACKSPACE :
            if( length == 0 ) {

                printf( STR_BEEP );

            } else {

                length--;
                printf( STR_BACKSPACE );

            }
            break;

        case KEY_ENTER :
        case KEY_EOF :
            String[length] = L'\0';
            printf( "\n" );
            return TRUE;

        case KEY_ESCAPE :
            while( length > 0 ) {

                length--;
                printf( STR_BACKSPACE );

            }
            break;

        default :
            if( length < MaxLength ) {

                String[length++] = (WCHAR)ch;

                if( Echo ) {
                    printf( "%c", ch );
                } else {
                    printf( STR_HIDDEN );
                }

            } else {

                printf( STR_BEEP );

            }
            break;

        }

    }

    return TRUE;

}   // GetStringFromUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\client\makefile.inc ===
obj\$(TARGET_DIRECTORY)\exchcli.res: exchcli.rc

obj\$(TARGET_DIRECTORY)\exchcli2.res: exchcli2.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\test\lib\buffsock.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    buffsock.cxx

Abstract:

    Implements the BUFFERED_SOCKET class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define BUFFER_LENGTH   4096    // bytes

#define ALLOC_MEM(cb) (PVOID)::LocalAlloc(LPTR, (cb))
#define FREE_MEM(p) (VOID)::LocalFree((HLOCAL)(p))


//
// Private types.
//


//
// Private globals.
//

LONG BUFFERED_SOCKET::m_InitCount = -1;


//
// Private prototypes.
//


//
// Public functions.
//


BUFFERED_SOCKET::BUFFERED_SOCKET()
{

    m_Socket = INVALID_SOCKET;
    m_Buffer = NULL;
    m_BufferLength = 0;
    m_BytesAvailable = NULL;
    m_Offset = 0;
    m_Initialized = FALSE;

}   // BUFFERED_SOCKET::BUFFERED_SOCKET()


BUFFERED_SOCKET::~BUFFERED_SOCKET()
{

    if( m_Socket != INVALID_SOCKET ) {

        ::closesocket( m_Socket );

    }

    if( m_Buffer != NULL ) {

        FREE_MEM( m_Buffer );

    }

    if( ::InterlockedDecrement( &BUFFERED_SOCKET::m_InitCount ) == -1 ) {

        ::WSACleanup();

    }

}   // BUFFERED_SOCKET::~BUFFERED_SOCKET()


INT
BUFFERED_SOCKET::InitializeClient(
    LPSTR HostName,
    USHORT Port
    )
{

    LPHOSTENT hostent;
    INT result;
    SOCKADDR_IN addr;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    addr.sin_family = AF_INET;
    addr.sin_port = htons( Port );
    addr.sin_addr.s_addr = ::inet_addr( HostName );

    if( addr.sin_addr.s_addr == INADDR_NONE ) {

        hostent = ::gethostbyname( HostName );

        if( hostent == NULL ) {

            return ::WSAGetLastError();

        }

        addr.sin_addr.s_addr = *(PULONG)hostent->h_addr_list[0];

    }

    return InitializeClient( &addr );

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::InitializeClient(
    LPSOCKADDR_IN HostAddress
    )
{

    INT result;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    if( m_Socket == INVALID_SOCKET ) {

        m_Socket = ::socket(
                        AF_INET,
                        SOCK_STREAM,
                        0
                        );

        if( m_Socket == INVALID_SOCKET ) {

            return ::WSAGetLastError();

        }

    }

    if( ::connect(
            m_Socket,
            (SOCKADDR *)HostAddress,
            sizeof(*HostAddress)
            ) == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    return InitializeClient( m_Socket );

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::InitializeClient(
    SOCKET Socket
    )
{

    INT result;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    m_Socket = Socket;

    return 0;

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::InitializeServer(
    USHORT Port
    )
{

    INT result;
    SOCKET tmpSocket;
    SOCKADDR_IN addr;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    tmpSocket = ::socket(
                     AF_INET,
                     SOCK_STREAM,
                     0
                     );

    if( tmpSocket == INVALID_SOCKET ) {

        return ::WSAGetLastError();

    }

    addr.sin_family = AF_INET;
    addr.sin_port = htons( Port );
    addr.sin_addr.s_addr = INADDR_ANY;

    result = ::bind(
                 tmpSocket,
                 (SOCKADDR *)&addr,
                 sizeof(addr)
                 );

    if( result == SOCKET_ERROR ) {

        result = ::WSAGetLastError();
        ::closesocket( tmpSocket );
        return result;

    }

    result = ::listen(
                 tmpSocket,
                 1
                 );

    if( result == SOCKET_ERROR ) {

        result = ::WSAGetLastError();
        ::closesocket( tmpSocket );
        return result;

    }

    m_Socket = ::accept(
                    tmpSocket,
                    NULL,
                    NULL
                    );

    if( m_Socket == INVALID_SOCKET ) {

        result = ::WSAGetLastError();
        ::closesocket( tmpSocket );
        return result;

    }

    ::closesocket( tmpSocket );
    return 0;

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::Send(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;

    result = ::send(
                  m_Socket,
                  (CHAR *)Buffer,
                  (INT)*BufferLength,
                  0
                  );

    if( result == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    *BufferLength = (DWORD)result;
    return 0;

}   // BUFFERED_SOCKET::Send


INT
BUFFERED_SOCKET::Recv(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;

    result = ::recv(
                  m_Socket,
                  (CHAR *)Buffer,
                  (INT)*BufferLength,
                  0
                  );

    if( result == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    *BufferLength = (DWORD)result;
    return 0;

}   // BUFFERED_SOCKET::Recv


INT
BUFFERED_SOCKET::SendFrame(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;
    WSABUF buffers[2];

    buffers[0].len = sizeof(DWORD);
    buffers[0].buf = (CHAR *)BufferLength;
    buffers[1].len = *BufferLength;
    buffers[1].buf = (CHAR *)Buffer;

    result = ::WSASend(
                  m_Socket,
                  buffers,
                  2,
                  BufferLength,
                  0,
                  NULL,
                  NULL
                  );

    if( result == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    *BufferLength -= sizeof(DWORD);
    return 0;

}   // BUFFERED_SOCKET::SendFrame


INT
BUFFERED_SOCKET::RecvFrame(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;
    DWORD frameLength;

    result = BufferedRecv( &frameLength, sizeof(frameLength) );

    if( result != 0 ) {

        return result;

    }

    if( frameLength > *BufferLength ) {

        return WSAEMSGSIZE;

    }

    result = BufferedRecv( Buffer, frameLength );

    if( result != 0 ) {

        return result;

    }

    *BufferLength = frameLength;
    return 0;

}   // BUFFERED_SOCKET::RecvFrom


INT
BUFFERED_SOCKET::SendBlob(
    PIIS_CRYPTO_BLOB Blob
    )
{

    DWORD length;

    length = IISCryptoGetBlobLength( Blob );

    return SendFrame(
               (PVOID)Blob,
               &length
               );

}   // BUFFERED_SOCKET::SendFrame


INT
BUFFERED_SOCKET::RecvBlob(
    PIIS_CRYPTO_BLOB * ppBlob
    )
{

    INT result;
    DWORD blobLength;
    PIIS_CRYPTO_BLOB blob;

    result = BufferedRecv( &blobLength, sizeof(blobLength) );

    if( result != 0 ) {

        return result;

    }

    blob = (PIIS_CRYPTO_BLOB)ALLOC_MEM(blobLength);

    if( blob == NULL ) {

        return WSAENOBUFS;

    }

    result = BufferedRecv( blob, blobLength );

    if( result != 0 ) {

        return result;

    }

    *ppBlob = blob;
    return 0;

}   // BUFFERED_SOCKET::RecvFrom


//
// Private functions.
//


INT
BUFFERED_SOCKET::BufferedRecv(
    PVOID Buffer,
    DWORD BufferLength
    )
{

    PCHAR buffer = (PCHAR)Buffer;
    DWORD bytesToCopy;
    INT result;

    while( BufferLength > 0 ) {

        if( m_BytesAvailable == 0 ) {

            m_BytesAvailable = m_BufferLength;
            result = Recv( m_Buffer, &m_BytesAvailable );

            if( result != 0 ) {

                return result;

            }

            if( m_BytesAvailable == 0 ) {

                return WSAEMSGSIZE;

            }

            m_Offset = 0;

        }

        bytesToCopy = min( m_BytesAvailable, BufferLength );

        memcpy(
            buffer,
            (PCHAR)m_Buffer + m_Offset,
            bytesToCopy
            );

        m_Offset += bytesToCopy;
        m_BytesAvailable -= bytesToCopy;
        BufferLength -= bytesToCopy;

    }

    return 0;

}   // BUFFERED_SOCKET::BufferedRecv


INT
BUFFERED_SOCKET::CommonInitialize()
{

    INT result = 0;
    WSADATA data;

    if( m_Initialized ) {

        return 0;

    }

    if( m_Buffer == NULL ) {

        m_Buffer = ALLOC_MEM( BUFFER_LENGTH );

        if( m_Buffer == NULL ) {

            return WSAENOBUFS;

        }

    }

    m_BufferLength = BUFFER_LENGTH;
    m_BytesAvailable = 0;
    m_Offset = 0;

    if( ::InterlockedIncrement( &BUFFERED_SOCKET::m_InitCount ) == 0 ) {

        result = ::WSAStartup( 0x0202, &data );

    }

    m_Initialized = ( result == 0 );

    return result;

}   // BUFFERED_SOCKET::CommonInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\server\exchsrv.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    exchsrv.cxx

Abstract:

    IIS Crypto server-side key exchange test.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define TEST_SOCKERR(api)                                                   \
            if( sockerr != NO_ERROR ) {                                     \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %d\n",                            \
                    api,                                                    \
                    __LINE__,                                               \
                    sockerr                                                 \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
                (b) = NULL;                                                 \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisKeySrvGuid, 
0x784d8929, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR ServerPlainText[] = "Server Server Server Server Server Server";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    INT sockerr;
    HRESULT result;
    IIS_CRYPTO_EXCHANGE_SERVER * pserver;
    BUFFERED_SOCKET * psocket;
    PIIS_CRYPTO_BLOB clientKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB clientSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB serverSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientHashBlob;
    PIIS_CRYPTO_BLOB serverHashBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    IIS_CRYPTO_STORAGE * clientStorage;
    IIS_CRYPTO_STORAGE * serverStorage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD bufferType;

    if( argc != 1 ) {

        printf(
            "use: exchsrv\n"
            );

        return 1;

    }

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisKeySrvGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    pserver = NULL;
    psocket = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverHashBlob = NULL;
    dataBlob = NULL;
    clientStorage = NULL;
    serverStorage = NULL;

    //
    // Initialize the crypto package.
    //

    printf( "exchsrv: Initializing...\n" );

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create & initialize the server-side key exchange object.
    //

    pserver = new IIS_CRYPTO_EXCHANGE_SERVER;

    if( pserver == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = pserver->Initialize(
                 CRYPT_NULL,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );

    TEST_HRESULT( "pserver->Initialize()" );

    //
    // Create & initialize the buffered socket object.
    //

    psocket = new BUFFERED_SOCKET;

    if( psocket == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = psocket->InitializeServer( SERVER_PORT );

    TEST_HRESULT( "psocket->Initialize()" );

    //
    // 2. SERVER(1)
    //

    printf( "exchsrv: Phase 1...\n" );

    sockerr = psocket->RecvBlob( &clientKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &clientSignatureKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pserver->ServerPhase1(
                 clientKeyExchangeKeyBlob,
                 clientSignatureKeyBlob,
                 &serverKeyExchangeKeyBlob,
                 &serverSignatureKeyBlob,
                 &serverSessionKeyBlob
                 );
    TEST_HRESULT( "pserver->ServerPhase1()" );

    sockerr = psocket->SendBlob( serverKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( serverSignatureKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( serverSessionKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 4. SERVER(2)
    //

    printf( "exchsrv: Phase 2...\n" );

    sockerr = psocket->RecvBlob( &clientSessionKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &clientHashBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pserver->ServerPhase2(
                 clientSessionKeyBlob,
                 clientHashBlob,
                 &serverHashBlob
                 );
    TEST_HRESULT( "pserver->ServerPhase2()" );

    sockerr = psocket->SendBlob( serverHashBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // Create the storage objects.
    //

    printf( "exchsrv: Creating storage objects...\n" );

    clientStorage = new IIS_CRYPTO_STORAGE;

    if( clientStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = clientStorage->Initialize(
                 pserver->QueryProviderHandle(),
                 pserver->AssumeClientSessionKey(),
                 CRYPT_NULL,
                 pserver->AssumeClientSignatureKey(),
                 TRUE
                 );
    TEST_HRESULT( "clientStorage->Initialize()" );

    serverStorage = new IIS_CRYPTO_STORAGE;

    if( serverStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = serverStorage->Initialize(
                 pserver->QueryProviderHandle(),
                 pserver->AssumeServerSessionKey(),
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );
    TEST_HRESULT( "serverStorage->Initialize()" );

    //
    // Receive some encrypted data.
    //

    printf( "exchsrv: Receiving encrypted data...\n" );

    sockerr = psocket->RecvBlob( &dataBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = clientStorage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &bufferType,
                 dataBlob
                 );
    TEST_HRESULT( "clientStorage->DecryptData()" );

    printf( "exchsrv: Received data[%lu] = '%s'\n", bufferLength, buffer );

    FREE_BLOB( dataBlob );

    //
    // Send some encrypted data.
    //

    printf( "exchsrv: Encrypting '%s'...\n", ServerPlainText );

    result = serverStorage->EncryptData(
                 &dataBlob,
                 ServerPlainText,
                 sizeof(ServerPlainText),
                 REG_SZ
                 );
    TEST_HRESULT( "serverStorage->EncryptData()" );

    printf( "exchsrv: Sending encrypted data...\n" );

    sockerr = psocket->SendBlob( dataBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // Tests complete.
    //

    printf( "exchsrv: Done!\n" );

cleanup:

    FREE_BLOB( dataBlob );
    FREE_BLOB( serverHashBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientKeyExchangeKeyBlob );

    delete psocket;
    delete clientStorage;
    delete serverStorage;
    delete pserver;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\icrypt\test\simple\icrypt.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icrypt.cxx

Abstract:

    IIS Crypto test app.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define CLOSE_KEY(h)                                                        \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoCloseKey( h );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoCloseKey( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define DESTROY_HASH(h)                                                     \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoDestroyHash( h );                        \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoDestroyHash( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisICryptGuid, 
0x784d892A, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR PlainText[] = "This is our sample plaintext that we'll encrypt.";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    HRESULT result;
    IIS_CRYPTO_STORAGE * storage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD type;
    PIIS_CRYPTO_BLOB dataBlob;

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisICryptGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    storage = NULL;
    dataBlob = NULL;

    //
    // Initialize the crypto package.
    //

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create the crypto storage object.
    //

    storage = new(IIS_CRYPTO_STORAGE);

    if( storage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    //
    // Initialize with a new session key.
    //

    result = storage->Initialize();
    TEST_HRESULT( "storage->Initialize()" );

    //
    // Create an encrypted data blob.
    //

    printf( "PlainText[%lu] = %s\n", sizeof(PlainText), PlainText );

    result = storage->EncryptData(
                 &dataBlob,
                 PlainText,
                 sizeof(PlainText),
                 REG_SZ
                 );

    TEST_HRESULT( "storage->EncryptData()" );
    printf( "dataBlob = %08lx\n", dataBlob );

    //
    // Decrypt the data blob.
    //

    result = storage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &type,
                 dataBlob
                 );

    TEST_HRESULT( "storage->DecryptData()" );
    printf( "decrypted data[%lu] = %s\n", bufferLength, buffer );

cleanup:

    FREE_BLOB( dataBlob );
    delete storage;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\data.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    data.c

Abstract:

    Data encryption/decryption routines for the IIS cryptographic
    package.

    The following routines are exported by this module:

        IISCryptoEncryptDataBlob
        IISCryptoDecryptDataBlob

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//

//
// The IC_DATA structure allows us to store our own private data
// along with the data we're encrypting for the application.
//

typedef struct _IC_DATA {

    DWORD RegType;
    // BYTE Data[];

} IC_DATA; 

typedef UNALIGNED64 IC_DATA *PIC_DATA;


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoEncryptDataBlob(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;
    DWORD hashLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppDataBlob,
                       pBuffer,
                       dwBufferLength
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the hash data length.
    //

    result = IcpGetHashLength(
                 &hashLength,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the required size of the encrypted data.
    //

    dwBufferLength += sizeof(*data);
    dataLength = dwBufferLength;

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();

    if( !CryptEncrypt(
            hSessionKey,
            CRYPT_NULL,
            TRUE,
            0,
            NULL,
            &dataLength,
            dwBufferLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;

    }
    
    IcpReleaseGlobalLock();

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               DATA_BLOB_SIGNATURE,
               dataLength,
               hashLength
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Copy the data into the blob, then encrypt it.
    //

    data = (PIC_DATA)BLOB_TO_DATA(blob);
    data->RegType = dwRegType;

    RtlCopyMemory(
        data + 1,
        pBuffer,
        dwBufferLength - sizeof(*data)
        );

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptEncrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dwBufferLength,
            dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }

    IcpReleaseGlobalLock();


    DBG_ASSERT( dataLength == blob->DataLength );

    //
    // Generate the signature.
    //

    if( !CryptSignHash(
            hash,
            AT_SIGNATURE,
            NULL,
            0,
            BLOB_TO_SIGNATURE(blob),
            &hashLength
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    DBG_ASSERT( hashLength == blob->SignatureLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppDataBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoEncryptDataBlob

HRESULT
WINAPI
IISCryptoEncryptDataBlob2(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;
    DWORD hashLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppDataBlob,
                       pBuffer,
                       dwBufferLength
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the hash data length.
    //

    result = IcpGetHashLength(
                 &hashLength,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the required size of the encrypted data.
    //

    dwBufferLength += sizeof(*data);
    dataLength = dwBufferLength;


	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptEncrypt(
            hSessionKey,
            CRYPT_NULL,
            TRUE,
            0,
            NULL,
            &dataLength,
            dwBufferLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
	IcpReleaseGlobalLock();

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               DATA_BLOB_SIGNATURE,
               dataLength,
               hashLength
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Copy the data into the blob, then encrypt it.
    //

    data = (PIC_DATA)BLOB_TO_DATA(blob);
    data->RegType = dwRegType;

    RtlCopyMemory(
        data + 1,
        pBuffer,
        dwBufferLength - sizeof(*data)
        );

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptEncrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dwBufferLength,
            dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
    IcpReleaseGlobalLock();


    DBG_ASSERT( dataLength == blob->DataLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppDataBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoEncryptDataBlob2


HRESULT
WINAPI
IISCryptoDecryptDataBlob(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hSignatureKey
    )

/*++

Routine Description:

    This routine validates and decrypts a data blob, resulting in a
    buffer containing plaintext.

    N.B. This routine effectively destroys the blob; once the data
    is decrypted, it cannot be decrypted again, as the data is
    decrypted "in place".

    N.B. The pointer returned in *ppBuffer points within the blob.
    This pointer will become invalid when the blob is freed. Note also
    that the calling application is still responsible for calling
    IISCryptoFreeBlob() on the data blob.

Arguments:

    ppBuffer - Receives a pointer to the data buffer if successful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - The data blob to decrypt.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to decrypt the data.

    hSignatureKey - Handle to the encryption key to use when validating
        the digital signature.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pDataBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );
    DBG_ASSERT( hSignatureKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY &&
            hSignatureKey == DUMMY_HSIGNATUREKEY &&
            pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *ppBuffer = (PVOID)( pDataBlob + 1 );
            *pdwBufferLength = pDataBlob->BlobDataLength;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Short-circuit for cleartext blobs.
    //

    if( pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE ) {
        *ppBuffer = (PVOID)( pDataBlob + 1 );
        *pdwBufferLength = pDataBlob->BlobDataLength;
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB)pDataBlob;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Decrypt the data.
    //

    dataLength = blob->DataLength;

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptDecrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
    
    IcpReleaseGlobalLock();


    //
    // Verify the signature.
    //

    if( !CryptVerifySignature(
            hash,
            BLOB_TO_SIGNATURE(blob),
            blob->SignatureLength,
            hSignatureKey,
            NULL,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Success!
    //

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    data = (PIC_DATA)BLOB_TO_DATA(blob);
    *ppBuffer = data + 1;
    *pdwBufferLength = dataLength - sizeof(*data);
    *pdwRegType = data->RegType;

    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoDecryptDataBlob

HRESULT
WINAPI
IISCryptoDecryptDataBlob2(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine validates and decrypts a data blob, resulting in a
    buffer containing plaintext.

    N.B. This routine effectively destroys the blob; once the data
    is decrypted, it cannot be decrypted again, as the data is
    decrypted "in place".

    N.B. The pointer returned in *ppBuffer points within the blob.
    This pointer will become invalid when the blob is freed. Note also
    that the calling application is still responsible for calling
    IISCryptoFreeBlob() on the data blob.

Arguments:

    ppBuffer - Receives a pointer to the data buffer if successful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - The data blob to decrypt.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to decrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pDataBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY &&
            pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *ppBuffer = (PVOID)( pDataBlob + 1 );
            *pdwBufferLength = pDataBlob->BlobDataLength;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Short-circuit for cleartext blobs.
    //

    if( pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE ) {
        *ppBuffer = (PVOID)( pDataBlob + 1 );
        *pdwBufferLength = pDataBlob->BlobDataLength;
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB)pDataBlob;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Decrypt the data.
    //

    dataLength = blob->DataLength;


	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptDecrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
    IcpReleaseGlobalLock();

    //
    // Success!
    //

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    data = (PIC_DATA)BLOB_TO_DATA(blob);
    *ppBuffer = data + 1;
    *pdwBufferLength = dataLength - sizeof(*data);
    *pdwRegType = data->RegType;

    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoDecryptDataBlob2


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\globals.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    globals.c

Abstract:

    Global definitions and initialization routines for the IIS
    cryptographic package.

    The following routines are exported by this module:

        IISCryptoInitialize
        IISCryptoTerminate
        IcpGetLastError

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Public globals.
//

IC_GLOBALS IcpGlobals;

#if IC_ENABLE_COUNTERS
IC_COUNTERS IcpCounters;
#endif  // IC_ENABLE_COUNTERS


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


// these flags are used for programatic override of encryption presnece/absence
// and are used for the case when on French machine  without encryption locale becomes
// changed and encryption becomes available

// in NT5 RC3 French encryption was enabled, so French now has encryption!
BOOL  fCryptoSettingsDoOverrride = FALSE;
BOOL  fCryptoSettingsOverrideFlag = FALSE;



//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
WINAPI
IISCryptoInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the IIS crypto package.

    N.B. This routine may only be called via a single thread of
    execution; it is not necessarily multi-thread safe.

Arguments:

    None.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    BOOL isNt = FALSE;
    OSVERSIONINFO osInfo;

    if( !IcpGlobals.Initialized ) {

        //
        // Initialize our critical section.
        //

        INITIALIZE_CRITICAL_SECTION(
            &IcpGlobals.GlobalLock
            );

#if IC_ENABLE_COUNTERS
        //
        // Initialize our object counters.
        //

        RtlZeroMemory(
            &IcpCounters,
            sizeof(IcpCounters)
            );
#endif  // IC_ENABLE_COUNTERS

        //
        // The hash length will get initialized the first time
        // it's needed.
        //

        IcpGlobals.HashLength = 0;

        //
        // Determine if cryptography should be enabled.
        //

        osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( GetVersionEx( &osInfo ) ) {
            isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
        } 

        if( isNt &&
            (IcpIsEncryptionPermitted())) {
            IcpGlobals.EnableCryptography = TRUE;
        } else {
            IcpGlobals.EnableCryptography = FALSE;
        }

#ifdef _WIN64
//      64 bit hack... 64 bit crypto should be working now, so no need to do this anymore.
//	IcpGlobals.EnableCryptography = FALSE;
#endif


#if DBG
        {

            //
            // On checked builds, you can override the default
            // EnableCryptography flag via a registry parameter.
            //

            HKEY key;
            LONG err;
            LONG flag;
            DWORD type;
            DWORD length;

            err = RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\K2"),
                      0,
                      KEY_ALL_ACCESS,
                      &key
                      );

            if( err == NO_ERROR ) {

                length = sizeof(flag);

                err = RegQueryValueEx(
                          key,
                          TEXT("EnableCryptography"),
                          NULL,
                          &type,
                          (LPBYTE)&flag,
                          &length
                          );

                if( err == NO_ERROR && type == REG_DWORD ) {
                    IcpGlobals.EnableCryptography = ( flag != 0 );
                }

                RegCloseKey( key );

            }

        }
#endif  // DBG

        //
        // Remember that we're successfully initialized.
        //

        IcpGlobals.Initialized = TRUE;

    }


    // that's a special case for handling for override of encryption presense
    // will be called only on French machines with english locale
    if (fCryptoSettingsDoOverrride)
    {
        IcpGlobals.EnableCryptography = fCryptoSettingsOverrideFlag;
    }
    

    //
    // Success!
    //

    return NO_ERROR;

}   // IISCryptoInitialize


HRESULT
WINAPI
IISCryptoTerminate(
    VOID
    )

/*++

Routine Description:

    This routine terminates the IIS crypto package.

    N.B. This routine may only be called via a single thread of
    execution; it is not necessarily multi-thread safe.

Arguments:

    None.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    if( IcpGlobals.Initialized ) {

        //
        // Nuke our critical section.
        //

        DeleteCriticalSection( &IcpGlobals.GlobalLock );

        //
        // Remember that we're successfully terminated.
        //

        IcpGlobals.Initialized = FALSE;

    }

    //
    // Success!
    //

    return NO_ERROR;

}   // IISCryptoTerminate


VOID 
WINAPI
IISCryptoInitializeOverride(BOOL flag) 
/*++

Routine Description:

    This routine overides global flag about presence of encryption
    functions. It should be used only in one case, when French machine 
    without encryption, has locale changed to US and then gets encryption
    capability what breaks a lot of code where attemt to decrypt is made on
    non encrypted data

Arguments:

    BOOL flag indicating how to override encryption presence. Only False suppose
    to be used.


Return Value:

    None

--*/

{
	IcpGlobals.EnableCryptography = flag;
	fCryptoSettingsDoOverrride = TRUE;
	fCryptoSettingsOverrideFlag = flag;
	
}   //IISCryptoInitializeOverride



BOOL
IcpIsEncryptionPermitted(
    VOID
    )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

    This code was received from Jeff Spelman, and is the same
    code the crypto API's use do determine if encryption is
    allowed.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
    // in NT5 RC3 French encryption was enabled, so French now has encryption!
    // since French was the only special case for encryption, just return TRUE all the time.

/*
    LCID DefaultLcid;
    CHAR CountryCode[10];
    ULONG CountryValue;
    DefaultLcid = GetSystemDefaultLCID();
    //
    // Check if the default language is Standard French
    //
    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //
    if (GetLocaleInfoA(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }
    CountryValue = (ULONG) atol(CountryCode);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
    //
    // and it still we think that encryption is permited thetre it comes a special hack for that
    // setup case where english or whatever install is installed with France locality from the begining and setup
    // thread still thinks that it is not in France. 
    // Setup in  iis.dll sets SetThreadLocale to the correct one
    //
    DefaultLcid = GetThreadLocale();
    //
    // Check if the default language is Standard French
    //
    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }
*/

    return(TRUE);
}


VOID
WINAPI
IcpAcquireGlobalLock(
    VOID
    )

/*++

Routine Description:

    This routine acquires the global IIS crypto lock.

    N.B. This routine is "semi-private"; it is only used by IISCRYPT.LIB
         and ICRYPT.LIB, not by "normal" code.

Arguments:

    None.

Return Value:

    None.

--*/

{

    EnterCriticalSection( &IcpGlobals.GlobalLock );

}   // IcpAcquireGlobalLock


VOID
WINAPI
IcpReleaseGlobalLock(
    VOID
    )

/*++

Routine Description:

    This routine releases the global IIS crypto lock.

    N.B. This routine is "semi-private"; it is only used by IISCRYPT.LIB
         and ICRYPT.LIB, not by "normal" code.

Arguments:

    None.

Return Value:

    None.

--*/

{

    LeaveCriticalSection( &IcpGlobals.GlobalLock );

}   // IcpReleaseGlobalLock


HRESULT
IcpGetLastError(
    VOID
    )

/*++

Routine Description:

    Returns the last error, mapped to an HRESULT.

Arguments:

    None.

Return Value:

    HRESULT - Last error.

--*/

{

    DWORD lastErr;

    lastErr = GetLastError();
    return RETURNCODETOHRESULT(lastErr);

}   // IcpGetLastError


//
// Private functions.
//

#if IC_ENABLE_COUNTERS

PVOID
WINAPI
IcpAllocMemory(
    IN DWORD Size
    )
{

    PVOID buffer;

    buffer = IISCryptoAllocMemory( Size );

    if( buffer != NULL ) {
        UpdateAllocs();
    }

    return buffer;

}   // IcpAllocMemory

VOID
WINAPI
IcpFreeMemory(
    IN PVOID Buffer
    )
{

    UpdateFrees();
    IISCryptoFreeMemory( Buffer );

}   // IcpFreeMemory

#endif  // IC_ENABLE_COUNTERS




BOOL
WINAPI
IISCryptoIsClearTextSignature (
    IIS_CRYPTO_BLOB UNALIGNED *pBlob
    )

/*++

Routine Description:

    Returns TRUE if blob is clear text

Arguments:

    Ptr to blob

Return Value:

    BOOL 

--*/

{
    return (pBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\generic.c ===
HRESULT
WINAPI
IISCrypto xxx(
    IN xxx
    )

/*++

Routine Description:

    This routine xxx

Arguments:

    xxx

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );

    //
    // Success!
    //

    return NO_ERROR;

}   // IISCrypto xxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\contain.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    contain.c

Abstract:

    Container manipulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoGetStandardContainer
        IISCryptoGetStandardContainer2
        IISCryptoGetContainerByName
        IISCryptoDeleteContainer
        IISCryptoCloseContainer

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//

HRESULT
IcpGetContainerHelper(
    OUT HCRYPTPROV * phProv,
    IN LPCTSTR pszContainer,
    IN LPCTSTR pszProvider,
    IN DWORD dwProvType,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    );


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoGetStandardContainer(
    OUT HCRYPTPROV * phProv,
    IN DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    This routine attempts to open the crypto key container. If the
    container does not yet exist, this routine will attempt to create
    it.

Arguments:

    phProv - Receives the provider handle if successful.

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Let IcpGetContainerHelper() do the dirty work.
    //

    result = IcpGetContainerHelper(
                 phProv,
                 IC_CONTAINER,
                 IC_PROVIDER,
                 IC_PROVTYPE,
                 dwAdditionalFlags,
                 ( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) != 0
                 );

    return result;

}   // IISCryptoGetStandardContainer

HRESULT
WINAPI
IISCryptoGetStandardContainer2(
    OUT HCRYPTPROV * phProv
    )

/*++

Routine Description:

    This routine attempts to open the crypto key container. If the
    container does not yet exist, this routine will attempt to create
    it.

Arguments:

    phProv - Receives the provider handle if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );

    //
    // Let IcpGetContainerHelper() do the dirty work.
    //

    result = IcpGetContainerHelper(
                 phProv,
                 NULL,
                 NULL,
                 IC_PROVTYPE,
                 CRYPT_VERIFYCONTEXT,
                 FALSE
                 );

    return result;

}   // IISCryptoGetStandardContainer2

HRESULT
WINAPI
IISCryptoGetContainerByName(
    OUT HCRYPTPROV * phProv,
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    )

/*++

Routine Description:

    This routine attempts to open a specific named crypto key container.
    If the container does not yet exist, this routine will attempt to
    create it and (optionally) apply an ACL to the container.

Arguments:

    phProv - Receives the provider handle if successful.

    pszContainerName - The name of the container to open/create.
                       NULL means temporary container  

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

    fApplyAcl - If TRUE, then an ACL is applied to the container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Let IcpGetContainerHelper() do the dirty work.
    //

    result = IcpGetContainerHelper(
                 phProv,
                 pszContainerName,
                 IC_PROVIDER,
                 IC_PROVTYPE,
                 dwAdditionalFlags,
                 fApplyAcl
                 );

    return result;

}   // IISCryptoGetContainerByName


HRESULT
WINAPI
IISCryptoDeleteStandardContainer(
    IN DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    This routine deletes the standard crypto key container.

Arguments:

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTPROV cryptProv;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        return NO_ERROR;
    }

    //
    // Delete the container.
    //

    status = CryptAcquireContext(
                &cryptProv,
                IC_CONTAINER,
                IC_PROVIDER,
                IC_PROVTYPE,
                CRYPT_DELETEKEYSET | dwAdditionalFlags
                );

    if( !status ) {
        result = IcpGetLastError();
    }

    return result;

}   // IISCryptoDeleteStandardContainer


HRESULT
WINAPI
IISCryptoDeleteContainerByName(
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    This routine deletes the specified crypto key container.

Arguments:

    pszContainerName - The name of the container to delete.

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTPROV cryptProv;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        return NO_ERROR;
    }

    //
    // Delete the container.
    //

    status = CryptAcquireContext(
                &cryptProv,
                pszContainerName,
                IC_PROVIDER,
                IC_PROVTYPE,
                CRYPT_DELETEKEYSET | dwAdditionalFlags
                );

    if( !status ) {
        result = IcpGetLastError();
    }

    return result;

}   // IISCryptoDeleteContainerByName


HRESULT
WINAPI
IISCryptoCloseContainer(
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine closes the container associated with the specified
    provider handle.

Arguments:

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Close the provider.
    //

    status = CryptReleaseContext(
                 hProv,
                 0
                 );

    if( status ) {

        UpdateContainersClosed();
        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoCloseContainer


//
// Private functions.
//


HRESULT
IcpGetContainerHelper(
    OUT HCRYPTPROV * phProv,
    IN LPCTSTR pszContainer,
    IN LPCTSTR pszProvider,
    IN DWORD dwProvType,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    )

/*++

Routine Description:

    This is a helper routine for IISCryptoGetContainer. It tries
    to open/create the specified container in the specified provider.

Arguments:

    phProv - Receives the provider handle if successful.

    pszContainer - The key container name.

    pszProvider - The provider name.

    dwProvType - The type of provider to acquire.

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

    fApplyAcl - If TRUE, then an ACL is applied to the container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hProv;
    BOOL status;
    PSID systemSid;
    PSID adminSid;
    PACL dacl;
    DWORD daclSize;
    SECURITY_DESCRIPTOR securityDescriptor;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    BOOL isNt = FALSE;
    OSVERSIONINFO osInfo;

    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        *phProv = DUMMY_HPROV;
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hProv = CRYPT_NULL;
    systemSid = NULL;
    adminSid = NULL;
    dacl = NULL;

    //
    // Grab the lock protecting the container code. This is always
    // necessary to prevent race conditions between this code and
    // the code below that creates the container & adds a security
    // descriptor.
    //

    IcpAcquireGlobalLock();

    //
    // Try to open an existing container.
    //
    
    if ( pszContainer == NULL )
    {
        //
        // if container is NULL it means that temporary (ephemeral)
        // keys will be used
        // CRYPT_VERIFYCONTEXT must be used in this case
        // keys used for DCOM traffic encryption will be using 
        // NULL containers
        //

        status = CryptAcquireContext(
                     &hProv,
                     pszContainer,
                     pszProvider,
                     dwProvType,
                     CRYPT_VERIFYCONTEXT
                     );
        if( !status ) 
        {
            result = IcpGetLastError();
            DBGPRINTF(( DBG_CONTEXT,"IcpGetContainerHelper. CryptAcquireContext(advapi32.dll) with CRYPT_VERIFYCONTEXT failed err=0x%x\n",result));
            DBGPRINTF(( DBG_CONTEXT,"args for CryptAcquireContext(%p,%p,%p,%d,%d)\n",&hProv,pszContainer,pszProvider,dwProvType, CRYPT_VERIFYCONTEXT));

            goto fatal;
        }
        else
        {
            goto success;
        }
        
    }

    status = CryptAcquireContext(
                 &hProv,
                 pszContainer,
                 pszProvider,
                 dwProvType,
                 0 | dwAdditionalFlags
                 );

    if( !status ) {
        result = IcpGetLastError();
    }

    if( SUCCEEDED(result) ) {

        DBG_ASSERT( hProv != CRYPT_NULL );
        *phProv = hProv;

        IcpReleaseGlobalLock();

        UpdateContainersOpened();
        return NO_ERROR;

    }

    //
    // Could not open the container. If the failure was anything
    // other than NTE_BAD_KEYSET, then we're toast.
    //

    if( result != NTE_BAD_KEYSET ) {
        DBGPRINTF(( DBG_CONTEXT,"IcpGetContainerHelper. CryptAcquireContext(advapi32.dll) failed err=0x%x.toast.\n",result));
        DBGPRINTF(( DBG_CONTEXT,"args for CryptAcquireContext(%p,%p,%p,%d,%d)\n",&hProv,pszContainer,pszProvider,dwProvType,CRYPT_NEWKEYSET | dwAdditionalFlags));
        hProv = CRYPT_NULL;
        goto fatal;
    }

    if(result == NTE_BAD_KEYSET) 
    {
        DBGPRINTF(( DBG_CONTEXT,"CryptAcquireContext(%p,%p,%p,%d,%d) returned NTE_BAD_KEYSET, so lets create a keyset now...\n",&hProv,pszContainer,pszProvider,dwProvType,0 | dwAdditionalFlags));
    }

    //
    // OK, CryptAcquireContext() failed with NTE_BAD_KEYSET, meaning
    // that the container does not yet exist, so create it now.
    //

    status = CryptAcquireContext(
                 &hProv,
                 pszContainer,
                 pszProvider,
                 dwProvType,
                 CRYPT_NEWKEYSET | dwAdditionalFlags
                 );

    if( status ) {
        result = NO_ERROR;
    } else {
        result = IcpGetLastError();
    }

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IcpGetContainerHelper. CryptAcquireContext(advapi32.dll) failed err=0x%x.\n",result));
        DBGPRINTF(( DBG_CONTEXT,"args for CryptAcquireContext(%p,%p,%p,%d,%d)\n",&hProv,pszContainer,pszProvider,dwProvType,CRYPT_NEWKEYSET | dwAdditionalFlags));
        hProv = CRYPT_NULL;
        goto fatal;
    }

    //
    // We've created the container. If requested, then we must create
    // a security descriptor for the container. This security descriptor
    // allows full access to the the container by the local system and
    // the local administrators group. Other login contexts may not
    // access the container.
    //
    // Of course, we only need to do this under NT...
    //


    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } 

    if( fApplyAcl && isNt ) {

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     &securityDescriptor,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &systemSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &adminSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        daclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(adminSid)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(systemSid)
                       - sizeof(DWORD);

        dacl = (PACL)IcpAllocMemory( daclSize );

        if( dacl == NULL ) {
            result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto fatal;
        }

        status = InitializeAcl(
                     dacl,
                     daclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     dacl,
                     ACL_REVISION,
                     KEY_ALL_ACCESS,
                     systemSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     dacl,
                     ACL_REVISION,
                     KEY_ALL_ACCESS,
                     adminSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     &securityDescriptor,
                     TRUE,
                     dacl,
                     FALSE
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // And (finally!) set the security descriptor on the
        // container.
        //

        status = CryptSetProvParam(
                     hProv,
                     PP_KEYSET_SEC_DESCR,
                     (BYTE *)&securityDescriptor,
                     DACL_SECURITY_INFORMATION
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

    }

success:
    //
    // Success!
    //

    DBG_ASSERT( hProv != CRYPT_NULL );
    *phProv = hProv;

    UpdateContainersOpened();
    result = NO_ERROR;

fatal:

    if( dacl != NULL ) {
        IcpFreeMemory( dacl );
    }

    if( adminSid != NULL ) {
        FreeSid( adminSid );
    }

    if( systemSid != NULL ) {
        FreeSid( systemSid );
    }

    if( hProv != CRYPT_NULL && FAILED(result) ) {
        DBG_REQUIRE( CryptReleaseContext(
                         hProv,
                         0
                         ) );
    }

    IcpReleaseGlobalLock();
    return result;

}   // IcpGetContainerHelper
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\blob.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    blob.c

Abstract:

    Generic blob manipulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoReadBlobFromRegistry
        IISCryptoWriteBlobToRegistry
        IISCryptoIsValidBlob
        IISCryptoFreeBlob
        IISCryptoCompareBlobs
        IISCryptoCloneBlobFromRawData
        IISCryptoCreateCleartextBlob
        IcpCreateBlob

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoReadBlobFromRegistry(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    )

/*++

Routine Description:

    This routine creates a new blob, reading the blob out of the
    registry.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    hRegistryKey - An open handle to a registry key.

    pszRegistryValueName - The name of the REG_BINARY registry value
        containing the blob.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB blob;
    long status;
    DWORD type;
    long length;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( hRegistryKey != NULL );
    DBG_ASSERT( pszRegistryValueName != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;

    //
    // Determine the size of the blob.
    //

    length = 0;

    status = RegQueryValueEx(
                 hRegistryKey,
                 pszRegistryValueName,
                 NULL,
                 &type,
                 NULL,
                 ( LPDWORD )&length
                 );

    if( status != NO_ERROR ) {
        result = RETURNCODETOHRESULT(status);
        goto fatal;
    }

    //
    // Allocate a new blob.
    //

    blob = IcpAllocMemory( length );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Read the blob.
    //

    status = RegQueryValueEx(
                 hRegistryKey,
                 pszRegistryValueName,
                 NULL,
                 &type,
                 (LPBYTE)blob,
                 ( LPDWORD )&length
                 );

    if( status != NO_ERROR ) {
        result = RETURNCODETOHRESULT(status);
        goto fatal;
    }

    //
    // Validate the blob.
    //

    if( !IISCryptoIsValidBlob( blob ) ) {
        result = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto fatal;
    }

    //
    // Success!
    //

    *ppBlob = blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoReadBlobFromRegistry


HRESULT
WINAPI
IISCryptoWriteBlobToRegistry(
    IN PIIS_CRYPTO_BLOB pBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    )

/*++

Routine Description:

    This routine writes the given blob to the given registry location.

Arguments:

    pBlob - A pointer to the blob to write.

    hRegistryKey - An open handle to a registry key.

    pszRegistryValueName - The name of the REG_BINARY registry value
        that will receive the blob.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    long status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob ) );
    DBG_ASSERT( hRegistryKey != NULL );
    DBG_ASSERT( pszRegistryValueName != NULL );

    //
    // Write the blob.
    //

    status = RegSetValueEx(
                 hRegistryKey,
                 pszRegistryValueName,
                 0,
                 REG_BINARY,
                 (LPBYTE)pBlob,
                 IISCryptoGetBlobLength( pBlob )
                 );

    return RETURNCODETOHRESULT(status);

}   // IISCryptoWriteBlobToRegistry


BOOL
WINAPI
IISCryptoIsValidBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine determines if the specified blob is indeed a valid
    blob.

Arguments:

    pBlob - The blob to validate.

Return Value:

    BOOL - TRUE if the blob is valid, FALSE otherwise.

--*/

{

    PIC_BLOB blob;
    BOOL result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );

    //
    // Validate the signature.
    //

    blob = (PIC_BLOB)pBlob;

    switch( blob->Header.BlobSignature ) {

    case KEY_BLOB_SIGNATURE :
    case PUBLIC_KEY_BLOB_SIGNATURE :
    case DATA_BLOB_SIGNATURE :
    case HASH_BLOB_SIGNATURE :
    case CLEARTEXT_BLOB_SIGNATURE :
        result = TRUE;
        break;

    default :
        result = FALSE;
        break;

    }

    if( result &&
        blob->Header.BlobSignature != CLEARTEXT_BLOB_SIGNATURE ) {

        //
        // Validate some of the blob internal structure. Note that we
        // don't validate the internal structure of the cleartext blobs,
        // as they do not conform to the normal IC_BLOB structure.
        //

        if( blob->DataLength == 0 ||
            blob->Header.BlobDataLength !=
                CALC_BLOB_DATA_LENGTH( blob->DataLength, blob->SignatureLength ) ) {

            result = FALSE;

        }

    }

    return result;

}   // IISCryptoIsValidBlob

BOOL
WINAPI
IISCryptoIsValidBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine determines if the specified blob is indeed a valid
    blob.

Arguments:

    pBlob - The blob to validate.

Return Value:

    BOOL - TRUE if the blob is valid, FALSE otherwise.

--*/

{

    PIC_BLOB2 blob;
    BOOL      result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );

    //
    // Validate the signature.
    //

    blob = (PIC_BLOB2)pBlob;

    switch( blob->Header.BlobSignature ) {

    case SALT_BLOB_SIGNATURE :
        result = TRUE;
        break;

    default :
        result = FALSE;
        break;

    }

    if( result ) {

        //
        // Validate some of the blob internal structure. Note that we
        // don't validate the internal structure of the cleartext blobs,
        // as they do not conform to the normal IC_BLOB structure.
        //

        if( blob->DataLength == 0 ||
            blob->Header.BlobDataLength !=
                CALC_BLOB_DATA_LENGTH2( blob->DataLength, blob->SaltLength ) ) {

            result = FALSE;

        }

    }

    return result;

}   // IISCryptoIsValidBlob2


HRESULT
WINAPI
IISCryptoFreeBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine frees all resources associated with the given blob.
    After this routine completes, the blob is unusable.

Arguments:

    pBlob - The blob to free.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob ) );

    //
    // Corrupt the structure signature before freeing the blob.
    //

    *(PCHAR)(&pBlob->BlobSignature) = 'X';

    //
    // Free the resources.
    //

    IcpFreeMemory( pBlob );

    //
    // Success!
    //

    UpdateBlobsFreed();
    return NO_ERROR;

}   // IISCryptoFreeBlob

HRESULT
WINAPI
IISCryptoFreeBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine frees all resources associated with the given blob.
    After this routine completes, the blob is unusable.

Arguments:

    pBlob - The blob to free.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob2( pBlob ) );

    //
    // Corrupt the structure signature before freeing the blob.
    //

    *(PCHAR)(&pBlob->BlobSignature) = 'X';

    //
    // Free the resources.
    //

    IcpFreeMemory( pBlob );

    //
    // Success!
    //

    UpdateBlobsFreed();
    return NO_ERROR;

}   // IISCryptoFreeBlob2


BOOL
WINAPI
IISCryptoCompareBlobs(
    IN PIIS_CRYPTO_BLOB pBlob1,
    IN PIIS_CRYPTO_BLOB pBlob2
    )

/*++

Routine Description:

    This routine compares two blobs to determine if they are identical.

Arguments:

    pBlob1 - Pointer to a blob.

    pBlob2 - Pointer to another blob.

Return Value:

    BOOL - TRUE if the blobs match, FALSE otherwise, or if the blobs
        are invalid.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob1 != NULL );
    DBG_ASSERT( pBlob2 != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob1 ) );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob2 ) );

    //
    // Just do a straight memory compare of the two blobs.
    //

    if( memcmp( pBlob1, pBlob2, sizeof(*pBlob1) ) == 0 ) {
        return TRUE;
    }

    //
    // No match.
    //

    return FALSE;

}   // IISCryptoCompareBlobs


HRESULT
WINAPI
IISCryptoCloneBlobFromRawData(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    )

/*++

Routine Description:

    This routine makes a copy of a blob from raw data. The raw data
    buffer may be unaligned.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    pRawBlob - Pointer to the raw blob data.

    dwRawBlobLength - Length of the raw blob data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    PIIS_CRYPTO_BLOB newBlob;
    IIS_CRYPTO_BLOB UNALIGNED *unalignedBlob;
    DWORD blobLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( pRawBlob != NULL );

    //
    // Allocate space for the new blob.
    //

    unalignedBlob = (IIS_CRYPTO_BLOB UNALIGNED *)pRawBlob;
    blobLength = IISCryptoGetBlobLength( unalignedBlob );

    if( blobLength != dwRawBlobLength ) {
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    newBlob = IcpAllocMemory( blobLength );
    if( newBlob != NULL ) {

        //
        // Clone it. The (PCHAR) casts are necessary to force the compiler
        // to copy BYTE-wise.
        //

        RtlCopyMemory(
            (PCHAR)newBlob,
            (PCHAR)unalignedBlob,
            blobLength
            );

        //
        // Validate its contents.
        //

        if( IISCryptoIsValidBlob( newBlob ) ) {

            *ppBlob = newBlob;

            UpdateBlobsCreated();
            return NO_ERROR;

        }

        IcpFreeMemory( newBlob );
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    }

    return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

}   // IISCryptoCloneBlobFromRawData

HRESULT
WINAPI
IISCryptoCloneBlobFromRawData2(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    )

/*++

Routine Description:

    This routine makes a copy of a blob from raw data. The raw data
    buffer may be unaligned.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    pRawBlob - Pointer to the raw blob data.

    dwRawBlobLength - Length of the raw blob data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    PIIS_CRYPTO_BLOB newBlob;
    IIS_CRYPTO_BLOB UNALIGNED *unalignedBlob;
    DWORD blobLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( pRawBlob != NULL );

    //
    // Allocate space for the new blob.
    //

    unalignedBlob = (IIS_CRYPTO_BLOB UNALIGNED *)pRawBlob;
    blobLength = IISCryptoGetBlobLength( unalignedBlob );

    if( blobLength != dwRawBlobLength ) {
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    newBlob = IcpAllocMemory( blobLength );
    if( newBlob != NULL ) {

        //
        // Clone it. The (PCHAR) casts are necessary to force the compiler
        // to copy BYTE-wise.
        //

        RtlCopyMemory(
            (PCHAR)newBlob,
            (PCHAR)unalignedBlob,
            blobLength
            );

        //
        // Validate its contents.
        //

        if( IISCryptoIsValidBlob2( newBlob ) ) {

            *ppBlob = newBlob;

            UpdateBlobsCreated();
            return NO_ERROR;

        }

        IcpFreeMemory( newBlob );
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    }

    return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

}   // IISCryptoCloneBlobFromRawData2


HRESULT
WINAPI
IISCryptoCreateCleartextBlob(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pBlobData,
    IN DWORD dwBlobDataLength
    )

/*++

Routine Description:

    This routine creates a cleartext blob containing the specified
    data.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    pBlobData - Pointer to the blob data.

    dwBlobDataLength - Length of the blob data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    PIIS_CRYPTO_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( pBlobData != NULL );

    //
    // Allocate space for the new blob.
    //

    blob = IcpAllocMemory( dwBlobDataLength + sizeof(*blob) );

    if( blob != NULL ) {

        //
        // Initialize the blob.
        //

        blob->BlobSignature = CLEARTEXT_BLOB_SIGNATURE;
        blob->BlobDataLength = dwBlobDataLength;

        RtlCopyMemory(
            blob + 1,
            pBlobData,
            dwBlobDataLength
            );

        *ppBlob = blob;

        UpdateBlobsCreated();
        return NO_ERROR;

    }

    return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

}   // IISCryptoCreateCleartextBlob


PIC_BLOB
IcpCreateBlob(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSignatureLength OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new blob.

Arguments:

    dwBlobSignature - The structure signature for the new blob.

    dwDataLength - The data length for the blob.

    dwSignatureLength - The length of the digital signature, 0 if
        there is no signature for this blob. This value cannot be
        CLEARTEXT_BLOB_SIGNATURE; cleartext blobs are "special".

Return Value:

    PIC_BLOB - Pointer to the newly created blob if successful,
        NULL otherwise.

--*/

{

    PIC_BLOB blob;
    DWORD blobDataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( dwBlobSignature == KEY_BLOB_SIGNATURE ||
                dwBlobSignature == PUBLIC_KEY_BLOB_SIGNATURE ||
                dwBlobSignature == DATA_BLOB_SIGNATURE ||
                dwBlobSignature == HASH_BLOB_SIGNATURE );

    //
    // Allocate storage for the blob.
    //

    blobDataLength = CALC_BLOB_DATA_LENGTH( dwDataLength, dwSignatureLength );
    blob = IcpAllocMemory( blobDataLength + sizeof(IIS_CRYPTO_BLOB) );

    if( blob != NULL ) {

        //
        // Initialize the blob.
        //

        blob->Header.BlobSignature = dwBlobSignature;
        blob->Header.BlobDataLength = blobDataLength;

        blob->DataLength = dwDataLength;
        blob->SignatureLength = dwSignatureLength;

    }

    return blob;

}   // IcpCreateBlob

PIC_BLOB2
IcpCreateBlob2(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSaltLength OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new blob.

Arguments:

    dwBlobSignature - The structure signature for the new blob.

    dwDataLength - The data length for the blob.

    dwSaltLength - The length of the random salt

Return Value:

    PIC_BLOB2 - Pointer to the newly created blob if successful,
        NULL otherwise.

--*/

{

    PIC_BLOB2 blob;
    DWORD blobDataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( dwBlobSignature == SALT_BLOB_SIGNATURE );

    //
    // Allocate storage for the blob.
    //

    blobDataLength = CALC_BLOB_DATA_LENGTH( dwDataLength, dwSaltLength );
    blob = IcpAllocMemory( blobDataLength + sizeof(IIS_CRYPTO_BLOB) );

    if( blob != NULL ) {

        //
        // Initialize the blob.
        //

        blob->Header.BlobSignature = dwBlobSignature;
        blob->Header.BlobDataLength = blobDataLength;

        blob->DataLength = dwDataLength;
        blob->SaltLength = dwSaltLength;

    }

    return blob;

}   // IcpCreateBlob2


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\icryptp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icryptp.h

Abstract:

    This include file contains private constants, type definitions, and
    function prototypes for the IIS cryptographic routines.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _ICRYPTP_H_
#define _ICRYPTP_H_


//
// Set this to a non-zero value to enable various object counters.
//

#if DBG
#define IC_ENABLE_COUNTERS 1
#else
#define IC_ENABLE_COUNTERS 0
#endif


//
// Constants defining our target crypto provider.
//

#define IC_CONTAINER TEXT("Microsoft Internet Information Server")
#define IC_PROVIDER  MS_DEF_PROV
#define IC_PROVTYPE  PROV_RSA_FULL

#define IC_HASH_ALG CALG_MD5


//
// Alignment macros.
//

#define ALIGN_DOWN(count,size) \
            ((ULONG)(count) & ~((ULONG)(size) - 1))

#define ALIGN_UP(count,size) \
            (ALIGN_DOWN( (ULONG)(count)+(ULONG)(size)-1, (ULONG)(size) ))

#define ALIGN_8(count) \
            (ALIGN_UP( (ULONG)(count), 8 ))


//
// A blob. Note that we use these blobs for storing exported keys,
// encrypted data, and hash results. Outside of this package, only
// the IIS_CRYPTO_BLOB header is exposed; the blob internals are kept
// private.
//

typedef struct _IC_BLOB {

    //
    // The standard header.
    //

    IIS_CRYPTO_BLOB Header;

    //
    // The data length. This will always be >0.
    //

    DWORD DataLength;

    //
    // The digital signature length. This may be 0 if no digital
    // signature is present.
    //

    DWORD SignatureLength;

    //
    // The actual data and digital signature go here, at the end
    // of the structure, but part of the same memory allocation
    // block. Use the following macros to access these fields.
    //
    // UCHAR Data[];
    // UCHAR Signature[];
    //

} IC_BLOB;

typedef UNALIGNED64 IC_BLOB *PIC_BLOB;

#define BLOB_TO_DATA(p) \
            ((BYTE *)(((PIC_BLOB)(p)) + 1))

#define BLOB_TO_SIGNATURE(p) \
            ((BYTE *)(((PCHAR)(((PIC_BLOB)(p)) + 1)) + \
                ALIGN_8(((PIC_BLOB)(p))->DataLength)))

//
// The following data structure is for specific metabase Backup/Restore
//
typedef struct _IC_BLOB2 {

    //
    // The standard header.
    //

    IIS_CRYPTO_BLOB Header;

    //
    // The data length. This will always be >0.
    //

    DWORD DataLength;

    //
    // The random salt length. At least 80 bits( 8 bytes ) long
    //

    DWORD SaltLength;

    //
    // The actual data and random salt go here, at the end
    // of the structure, but part of the same memory allocation
    // block. Use the following macros to access these fields.
    //
    // UCHAR Data[];
    // UCHAR Salt[];
    //

} IC_BLOB2, *PIC_BLOB2;

#define RANDOM_SALT_LENGTH       16

#define BLOB_TO_DATA2(p) \
            ((BYTE *)(((PIC_BLOB2)(p)) + 1))

#define BLOB_TO_SALT2(p) \
            ((BYTE *)(((PCHAR)(((PIC_BLOB2)(p)) + 1)) + \
                ALIGN_8(((PIC_BLOB2)(p))->DataLength)))

//
// Macro to calculate the data length of a blob, given the data and
// signature lengths. To ensure natural alignment of the signature, we
// quad-word align the data length if a signature is present.
//

#define CALC_BLOB_DATA_LENGTH(datalen,siglen) \
            ((sizeof(IC_BLOB) - sizeof(IIS_CRYPTO_BLOB)) + \
                ((siglen) + ( (siglen) ? ALIGN_8(datalen) : (datalen) )))

//
// Macro to calculate the data length of a blob, given the data and
// salt lengths. To ensure natural alignment of the signature, we
// quad-word align the data length if a signature is present.
//

#define CALC_BLOB_DATA_LENGTH2(datalen,saltlen) \
            ((sizeof(IC_BLOB2) - sizeof(IIS_CRYPTO_BLOB)) + \
                (saltlen) + (ALIGN_8(datalen)))


//
// Globals defined in globals.c.
//

typedef struct _IC_GLOBALS {

    //
    // Global synchronization lock (used sparingly).
    //

    CRITICAL_SECTION GlobalLock;

    //
    // Hash length for digital signatures. Since we always use the
    // same crypto provider & signature algorithm, we can retrieve
    // this once up front, and save some cycles later on.
    //

    DWORD HashLength;

    //
    // Set to TRUE if cryptography is enabled, FALSE if disabled.
    //

    BOOL EnableCryptography;

    //
    // Set to TRUE if we've been succesfully initialized.
    //

    BOOL Initialized;

} IC_GLOBALS, *PIC_GLOBALS;

extern IC_GLOBALS IcpGlobals;


//
// Private functions.
//

BOOL
IcpIsEncryptionPermitted(
    VOID
    );

HRESULT
IcpGetLastError(
    VOID
    );

HRESULT
IcpGetHashLength(
    OUT LPDWORD pdwHashLength,
    IN HCRYPTPROV hProv
    );

PIC_BLOB
IcpCreateBlob(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSignatureLength OPTIONAL
    );

PIC_BLOB2
IcpCreateBlob2(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSaltLength OPTIONAL
    );


#if IC_ENABLE_COUNTERS

//
// Object counters.
//

typedef struct _IC_COUNTERS {

    LONG ContainersOpened;
    LONG ContainersClosed;
    LONG KeysOpened;
    LONG KeysClosed;
    LONG HashCreated;
    LONG HashDestroyed;
    LONG BlobsCreated;
    LONG BlobsFreed;
    LONG Allocs;
    LONG Frees;

} IC_COUNTERS, *PIC_COUNTERS;

extern IC_COUNTERS IcpCounters;

#define UpdateContainersOpened() InterlockedIncrement( &IcpCounters.ContainersOpened )
#define UpdateContainersClosed() InterlockedIncrement( &IcpCounters.ContainersClosed )
#define UpdateKeysOpened() InterlockedIncrement( &IcpCounters.KeysOpened )
#define UpdateKeysClosed() InterlockedIncrement( &IcpCounters.KeysClosed )
#define UpdateHashCreated() InterlockedIncrement( &IcpCounters.HashCreated )
#define UpdateHashDestroyed() InterlockedIncrement( &IcpCounters.HashDestroyed )
#define UpdateBlobsCreated() InterlockedIncrement( &IcpCounters.BlobsCreated )
#define UpdateBlobsFreed() InterlockedIncrement( &IcpCounters.BlobsFreed )
#define UpdateAllocs() InterlockedIncrement( &IcpCounters.Allocs )
#define UpdateFrees() InterlockedIncrement( &IcpCounters.Frees )

PVOID
WINAPI
IcpAllocMemory(
    IN DWORD Size
    );

VOID
WINAPI
IcpFreeMemory(
    IN PVOID Buffer
    );

#else   // !IC_ENABLE_COUNTERS

#define UpdateContainersOpened()
#define UpdateContainersClosed()
#define UpdateKeysOpened()
#define UpdateKeysClosed()
#define UpdateHashCreated()
#define UpdateHashDestroyed()
#define UpdateBlobsCreated()
#define UpdateBlobsFreed()
#define UpdateAllocs()
#define UpdateFrees()

#define IcpAllocMemory(cb) IISCryptoAllocMemory(cb)
#define IcpFreeMemory(p) IISCryptoFreeMemory(p)

#endif  // IC_ENABLE_COUNTERS


//
// Dummy crypto handles returned in cryptography is disabled.
//

#define DUMMY_HPROV             ((HCRYPTPROV)'vOrP')
#define DUMMY_HHASH             ((HCRYPTHASH)'hSaH')
#define DUMMY_HSESSIONKEY       ((HCRYPTKEY)'kSeS')
#define DUMMY_HSIGNATUREKEY     ((HCRYPTKEY)'kGiS')
#define DUMMY_HKEYEXCHANGEKEY   ((HCRYPTKEY)'kYeK')


#endif  // _ICRYPTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\memalloc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    memalloc.c

Abstract:

    Memory allocator for the crypto routines.

        IISCryptoAllocMemory
        IISCryptoFreeMemory

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    )
{

    return CoTaskMemAlloc( Size );

}   // IISCryptoAllocateMemory


VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    )
{

    CoTaskMemFree( Buffer );

}   // IISCryptoFreeMemory


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\hash.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hash manipulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoCreateHash
        IISCryptoDestroyHash
        IISCryptoHashData
        IISCryptoHashSessionKey
        IISCryptoExportHashBlob
        IcpGetHashLength

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoCreateHash(
    OUT HCRYPTHASH * phHash,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine creates a new hash object.

Arguments:

    phHash - Receives the hash handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phHash != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {
            *phHash = DUMMY_HHASH;
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Create the hash object.
    //

    if( CryptCreateHash(
            hProv,
            IC_HASH_ALG,
            CRYPT_NULL,
            0,
            phHash
            ) ) {

        UpdateHashCreated();
        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoCreateHash


HRESULT
WINAPI
IISCryptoDestroyHash(
    IN HCRYPTHASH hHash
    )

/*++

Routine Description:

    This routine destroys the specified hash object.

Arguments:

    hHash - The hash object to destroy.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hHash != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Destroy it.
    //

    if( CryptDestroyHash(
            hHash
            ) ) {

        UpdateHashDestroyed();
        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoDestroyHash


HRESULT
WINAPI
IISCryptoHashData(
    IN HCRYPTHASH hHash,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    This routine adds the specified data to the hash.

Arguments:

    hHash - A hash object handle.

    pBuffer - Pointer to the buffer to add to the hash.

    dwBufferLength - The buffer length.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hHash != CRYPT_NULL );
    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( dwBufferLength > 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Hash it.
    //

    if( CryptHashData(
            hHash,
            (BYTE *)pBuffer,
            dwBufferLength,
            0
            ) ) {

        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoHashData


HRESULT
WINAPI
IISCryptoHashSessionKey(
    IN HCRYPTHASH hHash,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine adds the given key object to the hash.

Arguments:

    hHash - A hash object handle.

    hSessionKey - The session key to add to the hash.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hHash != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH &&
            hSessionKey == DUMMY_HSESSIONKEY ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Hash it.
    //

    if( CryptHashSessionKey(
            hHash,
            hSessionKey,
            0
            ) ) {

        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoHashSessionKey


HRESULT
WINAPI
IISCryptoExportHashBlob(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob,
    IN HCRYPTHASH hHash
    )

/*++

Routine Description:

    This routine exports a hash object into a hash blob. Note that unlike
    the other blobs created by this package, hash blobs are not encrypted,
    nor do they have corresponding digital signatures.

Arguments:

    ppHashBlob - Will receive a pointer to the newly created hash blob
        if successful.

    hHash - The hash object to export.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    DWORD hashLength;
    DWORD hashLengthLength;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppHashBlob != NULL );
    DBG_ASSERT( hHash != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH ) {
            return IISCryptoCreateCleartextBlob(
                       ppHashBlob,
                       (PVOID)"",
                       1
                       );
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;

    //
    // Determine the length of the hash.
    //

    hashLengthLength = sizeof(hashLength);

    if( !CryptGetHashParam(
            hHash,
            HP_HASHSIZE,
            (BYTE *)&hashLength,
            &hashLengthLength,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               HASH_BLOB_SIGNATURE,
               hashLength,
               0
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Get the hash data.
    //

    if( !CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            BLOB_TO_DATA(blob),
            &hashLength,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    DBG_ASSERT( hashLength == blob->DataLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    *ppHashBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportHashBlob

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCacheHashLength(
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine calls IcpGetHashLength to cache the hash size.

Arguments:

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT

--*/

{
    DWORD               dwDummy = 0;

    return IcpGetHashLength( &dwDummy, hProv );
}



HRESULT
IcpGetHashLength(
    OUT LPDWORD pdwHashLength,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine determines the digital signature length used by the
    given provider. Since we always use the default provider, and
    we always use the same hash algorithm, we can retrieve this once,
    store it globally, then use that value.

Arguments:

    pdwHashLength - Receives the hash length if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( IcpGlobals.EnableCryptography );
    DBG_ASSERT( pdwHashLength != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // If the hash length has already been calculated, just use it.
    //

    if( IcpGlobals.HashLength > 0 ) {
        *pdwHashLength = IcpGlobals.HashLength;
        return NO_ERROR;
    }

    //
    // Grab the global lock, then check again, just in case another
    // thread has already done it.
    //

    IcpAcquireGlobalLock();

    if( IcpGlobals.HashLength > 0 ) {
        *pdwHashLength = IcpGlobals.HashLength;
        IcpReleaseGlobalLock();
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Hash some random data.
    //

    if( !CryptHashData(
            hash,
            (BYTE *)"IIS",
            4,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Attempt to sign the hash to get its length.
    //

    if( !CryptSignHash(
            hash,
            AT_SIGNATURE,
            NULL,
            0,
            NULL,
            &IcpGlobals.HashLength
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Success!
    //

    *pdwHashLength = IcpGlobals.HashLength;
    IcpReleaseGlobalLock();

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    IcpReleaseGlobalLock();

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IcpGetHashLength

//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\delcont\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

#include <windows.h>
#include <wincrypt.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//
// Project include files.
//

#include <dbgutil.h>
#include <iiscrypt.h>


//
// Local prototypes.
//

INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    );


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\key.c ===
/*++


Copyright (c) 1997 Microsoft Corporation

Module Name:

    key.c

Abstract:

    Key manpulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoGetKeyDeriveKey
        IISCryptoGetKeyExchangeKey
        IISCryptoGetSignatureKey
        IISCryptoGenerateSessionKey
        IISCryptoCloseKey
        IISCryptoExportSessionKeyBlob
        IISCryptoExportSessionKeyBlob2
        IISCryptoImportSessionKeyBlob
        IISCryptoImportSessionKeyBlob2
        IISCryptoExportPublicKeyBlob
        IISCryptoImportPublicKeyBlob

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//

HRESULT
IcpGetKeyHelper(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec
    );

//
// Public functions.
//
HRESULT
WINAPI
IISCryptoGetKeyDeriveKey2(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash
    )
/*++

Routine Description:

    This routine attempts to derive a key from a password in the given
    provider. 

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

    hHash - A hash object from which the key will be derived 

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{
    HRESULT      hr;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hHash != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) 
        {
            return NO_ERROR;
        } 
        else 
        {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Create a key based on the hash of the password.
    //
    IcpAcquireGlobalLock();

    if( !CryptDeriveKey(
                hProv, 
                CALG_RC4, 
                hHash, 
                CRYPT_EXPORTABLE, 
                phKey ) )
    {
        hr = IcpGetLastError();
        IcpReleaseGlobalLock();
        DBG_ASSERT( FAILED( hr ) );
        return hr;
    } 

    IcpReleaseGlobalLock();
    
    return NO_ERROR;
}

HRESULT
WINAPI
IISCryptoGetKeyExchangeKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine attempts to open the key exchange key in the given
    provider. If the key does not yet exist, this routine will attempt
    to create it.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Let IcpGetKeyHelper() do the dirty work.
    //

    result = IcpGetKeyHelper(
                 phKey,
                 hProv,
                 AT_KEYEXCHANGE
                 );

    return result;

}   // IISCryptoGetKeyExchangeKey


HRESULT
WINAPI
IISCryptoGetSignatureKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine attempts to open the signature key in the given provider.
    If the key does not yet exist, this routine will attempt to create it.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Let IcpGetKeyHelper() do the dirty work.
    //

    result = IcpGetKeyHelper(
                 phKey,
                 hProv,
                 AT_SIGNATURE
                 );

    return result;

}   // IISCryptoGetSignatureKey


HRESULT
WINAPI
IISCryptoGenerateSessionKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine generates a random session key.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{
    HRESULT result = NO_ERROR;
    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {
            *phKey = DUMMY_HSESSIONKEY;
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Generate the key.
    //

    status = CryptGenKey(
                 hProv,
                 CALG_RC4,
                 CRYPT_EXPORTABLE,
                 phKey
                 );

    if( !status ) {
        result = IcpGetLastError();
    }

    if( SUCCEEDED(result) ) 
    {
        UpdateKeysOpened();
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoGenerateSessionKey.CryptGenKey (advapi32.dll) failed err=0x%x.\n",result));
        *phKey = CRYPT_NULL;
       
    }

    return result;

}   // IISCryptoGenerateSessionKey


HRESULT
WINAPI
IISCryptoCloseKey(
    IN HCRYPTKEY hKey
    )

/*++

Routine Description:

    This routine closes the specified key.

Arguments:

    hKey - A key handle.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hKey == DUMMY_HSESSIONKEY ||
            hKey == DUMMY_HSIGNATUREKEY ||
            hKey == DUMMY_HKEYEXCHANGEKEY ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Close the key.
    //

    status = CryptDestroyKey(
                 hKey
                 );

    if( status ) {
        UpdateKeysClosed();
        return NO_ERROR;
    }

    return IcpGetLastError();

}   // IISCryptoCloseKey


HRESULT
WINAPI
IISCryptoExportSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    private key exchange key) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    hKeyExchangeKey - The key to use when encrypting the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTHASH hash;
    DWORD keyLength;
    DWORD hashLength;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppSessionKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );
    DBG_ASSERT( hKeyExchangeKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY &&
            hKeyExchangeKey == DUMMY_HKEYEXCHANGEKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppSessionKeyBlob,
                       (PVOID)"",
                       1
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Determine the required size of the key data.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyExchangeKey,
                 SIMPLEBLOB,
                 0,
                 NULL,
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptExportKey (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Determine the hash data length.
    //

    result = IcpGetHashLength(
                 &hashLength,
                 hProv
                 );

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.IcpGetHashLength failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               KEY_BLOB_SIGNATURE,
               keyLength,
               hashLength
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Export the key.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyExchangeKey,
                 SIMPLEBLOB,
                 0,
                 BLOB_TO_DATA(blob),
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( keyLength == blob->DataLength );

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the key and generate the signature.
    //

    status = CryptHashData(
                 hash,
                 BLOB_TO_DATA(blob),
                 keyLength,
                 0
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptSignHash(
                 hash,
                 AT_SIGNATURE,
                 NULL,
                 0,
                 BLOB_TO_SIGNATURE(blob),
                 &hashLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptSignHash failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( hashLength == blob->SignatureLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppSessionKeyBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportSessionKeyBlob


HRESULT
WINAPI
IISCryptoImportSessionKeyBlob(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSignatureKey
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted and the digital signature can be validated.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    hSignatureKey - Handle to the encryption key to use when validating
        the digital signature.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTHASH hash;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phSessionKey != NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pSessionKeyBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSignatureKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSignatureKey == DUMMY_HSIGNATUREKEY &&
            pSessionKeyBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *phSessionKey = DUMMY_HSESSIONKEY;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    DBG_ASSERT( pSessionKeyBlob->BlobSignature == KEY_BLOB_SIGNATURE );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB)pSessionKeyBlob;

    //
    // Validate the signature.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptHashData(
                 hash,
                 BLOB_TO_DATA(blob),
                 blob->DataLength,
                 0
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptVerifySignature(
                 hash,
                 BLOB_TO_SIGNATURE(blob),
                 blob->SignatureLength,
                 hSignatureKey,
                 NULL,
                 0
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptVerifySignature failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // OK, the signature looks good. Import the key into our CSP.
    //

    status = CryptImportKey(
                 hProv,
                 BLOB_TO_DATA(blob),
                 blob->DataLength,
                 CRYPT_NULL,
                 0,
                 phSessionKey
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptImportKey failed err=0x%x.\n",result));
    }

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DBG_ASSERT( *phSessionKey != CRYPT_NULL );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );

    UpdateKeysOpened();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoImportSessionKeyBlob

HRESULT
WINAPI
IISCryptoExportSessionKeyBlob2(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    private key exchange key) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    BYTE salt[ RANDOM_SALT_LENGTH ];
    HCRYPTHASH hash;
    DWORD keyLength;
    PIC_BLOB2 blob;
    HCRYPTKEY hKeyDerivedKey = CRYPT_NULL;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppSessionKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppSessionKeyBlob,
                       (PVOID)"",
                       1
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Generate a random salt of at least 80 bits
    //
    
    if( !CryptGenRandom( hProv, RANDOM_SALT_LENGTH, salt ) )
    {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptGenRandom (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash( &hash, hProv );
    if( FAILED(result) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the random salt
    
    if( !CryptHashData( hash, salt, RANDOM_SALT_LENGTH, 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the password string
    //

    if( !CryptHashData( hash, ( BYTE * )pszPasswd, ( DWORD )strlen( pszPasswd ), 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Derive a key from the supplied passwd
    //
    result = IISCryptoGetKeyDeriveKey2( &hKeyDerivedKey,
                                        hProv,
                                        hash
                                        );
    if( FAILED( result ) )
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.IISCryptoGetKeyDeriveKey2 failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Determine the required size of the key data.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyDerivedKey,
                 SYMMETRICWRAPKEYBLOB,
                 0,
                 NULL,
                 &keyLength
                 );
    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptExportKey (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob2(
               SALT_BLOB_SIGNATURE,
               keyLength,
               RANDOM_SALT_LENGTH
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Export the key.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyDerivedKey,
                 SYMMETRICWRAPKEYBLOB,
                 0,
                 BLOB_TO_DATA2(blob),
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptDestroyKey( hKeyDerivedKey );
    if( !status )
    {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptDestroyKey (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( keyLength == blob->DataLength );

    memcpy( BLOB_TO_SALT2( blob ), salt, RANDOM_SALT_LENGTH );

    //
    // Success!
    //

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppSessionKeyBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    

    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportSessionKeyBlob2


HRESULT
WINAPI
IISCryptoImportSessionKeyBlob2(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted and the digital signature can be validated.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT    result = NO_ERROR;
    BOOL       status;
    BYTE       salt[ RANDOM_SALT_LENGTH ];
    HCRYPTKEY  hKeyDerivedKey;
    HCRYPTHASH hash;
    PIC_BLOB2  blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phSessionKey != NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( pszPasswd != NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            pSessionKeyBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *phSessionKey = DUMMY_HSESSIONKEY;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    DBG_ASSERT( pSessionKeyBlob->BlobSignature == SALT_BLOB_SIGNATURE );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB2)pSessionKeyBlob;

    //
    // Get the random salt
    //

    memcpy( salt, BLOB_TO_SALT2( blob ), RANDOM_SALT_LENGTH );

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash( &hash, hProv );
    if( FAILED(result) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the random salt

    if( !CryptHashData( hash, salt, RANDOM_SALT_LENGTH, 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the password string
    //

    if( !CryptHashData( hash, ( BYTE * )pszPasswd, ( DWORD )strlen( pszPasswd ), 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Derive a key from the supplied passwd
    //
    result = IISCryptoGetKeyDeriveKey2( &hKeyDerivedKey,
                                        hProv,
                                        hash
                                        );
    if( FAILED( result ) )
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.IISCryptoGetKeyDeriveKey2 failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // OK, import the key into our CSP.
    //

    status = CryptImportKey(
                 hProv,
                 BLOB_TO_DATA2(blob),
                 blob->DataLength,
                 hKeyDerivedKey,
                 0,
                 phSessionKey
                 );

    if( !status ) {
        //result = IcpGetLastError();
        result = HRESULT_FROM_WIN32( ERROR_WRONG_PASSWORD );
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptImportKey failed err=0x%x.\n",result));
    }

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DBG_ASSERT( *phSessionKey != CRYPT_NULL );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );

    UpdateKeysOpened();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoImportSessionKeyBlob2


HRESULT
WINAPI
IISCryptoExportPublicKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppPublicKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hPublicKey
    )

/*++

Routine Description:

    This routine exports a key into a public key blob. Note that since
    public keys are, well, public, then the data in the blob is neither
    encrypted nor signed.

Arguments:

    ppPublicKeyBlob - Will receive a pointer to the newly created public
        key blob if successful.

    hProv - A handle to a crypto service provider.

    hPublicKey - The public key to export. This should identify either a
        key exchange key or a signature key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    DWORD keyLength;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppPublicKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hPublicKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            ( hPublicKey == DUMMY_HKEYEXCHANGEKEY ||
              hPublicKey == DUMMY_HSIGNATUREKEY ) ) {

            return IISCryptoCreateCleartextBlob(
                       ppPublicKeyBlob,
                       (PVOID)&hPublicKey,
                       sizeof(hPublicKey)
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;

    //
    // Determine the required size of the key data.
    //

    status = CryptExportKey(
                 hPublicKey,
                 CRYPT_NULL,
                 PUBLICKEYBLOB,
                 0,
                 NULL,
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportPublicKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               PUBLIC_KEY_BLOB_SIGNATURE,
               keyLength,
               0
               );

    if( blob == NULL ) {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto fatal;
    }

    //
    // Export the key.
    //

    status = CryptExportKey(
                 hPublicKey,
                 CRYPT_NULL,
                 PUBLICKEYBLOB,
                 0,
                 BLOB_TO_DATA(blob),
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportPublicKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( keyLength == blob->DataLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    *ppPublicKeyBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportPublicKeyBlob


HRESULT
WINAPI
IISCryptoImportPublicKeyBlob(
    OUT HCRYPTKEY * phPublicKey,
    IN PIIS_CRYPTO_BLOB pPublicKeyBlob,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine takes the specified public key blob and creates the
    corresponding key.

Arguments:

    phPublicKey - Receives a pointer to the newly created public key if
        successful.

    pPublicKeyBlob - Pointer to a public key blob created with
        IISCryptoExportPublicKeyBlob().

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phPublicKey != NULL );
    DBG_ASSERT( pPublicKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pPublicKeyBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            pPublicKeyBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *phPublicKey = *(HCRYPTKEY *)( pPublicKeyBlob + 1 );
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    DBG_ASSERT( pPublicKeyBlob->BlobSignature == PUBLIC_KEY_BLOB_SIGNATURE );

    //
    // Import the key into our CSP.
    //

    blob = (PIC_BLOB)pPublicKeyBlob;

    status = CryptImportKey(
                 hProv,
                 BLOB_TO_DATA(blob),
                 blob->DataLength,
                 CRYPT_NULL,
                 0,
                 phPublicKey
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportPublicKeyBlob.CryptImportKey failed err=0x%x.\n",result));
    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( *phPublicKey != CRYPT_NULL );
        UpdateKeysOpened();
    }

    return result;

}   // IISCryptoImportPublicKeyBlob


//
// Private functions.
//


HRESULT
IcpGetKeyHelper(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec
    )

/*++

Routine Description:

    This is a helper routine for IISCryptoGetKeyExchangeKey() and
    IISCryptoGetSignatureKey(). It tries to get/generate the specific
    key type within the given provider.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

    dwKeySpec - The specification of the key to open/create.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {

            if( dwKeySpec == AT_KEYEXCHANGE ) {
                *phKey = DUMMY_HKEYEXCHANGEKEY;
            } else {
                ASSERT( dwKeySpec == AT_SIGNATURE );
                *phKey = DUMMY_HSIGNATUREKEY;
            }

            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Try to retrieve the key.
    //

    status = CryptGetUserKey(
                 hProv,
                 dwKeySpec,
                 phKey
                 );

    if( status ) {
        DBG_ASSERT( *phKey != CRYPT_NULL );
        UpdateKeysOpened();
        return NO_ERROR;
    }

    //
    // Could not get the key. If the failure was anything other than
    // NTE_NO_KEY, then we're toast.
    //

    result = IcpGetLastError();

    if( result != NTE_NO_KEY ) {
        DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGetUserKey (advapi32.dll) failed err=0x%x.toast.\n",result));
        return result;
    }

    //
    // OK, CryptGetUserKey() failed with NTE_NO_KEY, meaning
    // that the key does not yet exist, so generate it now.
    //
    // Note that we must be careful to handle the inevitable race
    // conditions that can occur when multiple threads execute this
    // code and each thinks they need to generate the key. We handle
    // this by acquiring the global lock, then reattempting to get
    // the key. If we still cannot get the key, only then do we attempt
    // to generate one.
    //

    result = NO_ERROR;  // until proven otherwise...

    IcpAcquireGlobalLock();

    status = CryptGetUserKey(
                 hProv,
                 dwKeySpec,
                 phKey
                 );

    if( !status ) 
    {
        //
        // We still cannot get the key, so try to generate one.
        //
        DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGetUserKey:failed, lets try to generate another key.\n"));
        status = CryptGenKey(
                     hProv,
                     dwKeySpec,
                     0,
                     phKey
                     );

        if( !status ) {
            result = IcpGetLastError();
            DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGenKey (advapi32.dll) failed err=0x%x.\n",result));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGenKey:key generated.\n"));
        }

    }

    if( SUCCEEDED(result) ) 
    {
        UpdateKeysOpened();
    }
    else
    {
        *phKey = CRYPT_NULL;
    }

    IcpReleaseGlobalLock();
    return result;

}   // IcpGetKeyHelper
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\simple\iiscrypt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    iiscrypt.c

Abstract:

    IIS Crypto test app.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define CLOSE_KEY(h)                                                        \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoCloseKey( h );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoCloseKey( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define DESTROY_HASH(h)                                                     \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoDestroyHash( h );                        \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoDestroyHash( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisCryptSimpleGuid, 
0x784d892C, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR PlainText[] = "This is our sample plaintext that we'll encrypt.";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    HRESULT result;
    PVOID buffer;
    DWORD bufferLength;
    DWORD type;
    HCRYPTPROV hProv;
    HCRYPTKEY hKeyExchangeKey;
    HCRYPTKEY hKeyExchangeKey2;
    HCRYPTKEY hSignatureKey;
    HCRYPTKEY hSignatureKey2;
    HCRYPTKEY hSessionKey;
    HCRYPTKEY hSessionKey2;
    HCRYPTHASH hHash1;
    HCRYPTHASH hHash2;
    PIIS_CRYPTO_BLOB keyExchangePublicKeyBlob;
    PIIS_CRYPTO_BLOB signaturePublicKeyBlob;
    PIIS_CRYPTO_BLOB sessionKeyBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    PIIS_CRYPTO_BLOB hashBlob1;
    PIIS_CRYPTO_BLOB hashBlob2;

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisCryptSimpleGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hProv = CRYPT_NULL;

    hKeyExchangeKey = CRYPT_NULL;
    hKeyExchangeKey2 = CRYPT_NULL;
    hSignatureKey = CRYPT_NULL;
    hSignatureKey2 = CRYPT_NULL;
    hSessionKey = CRYPT_NULL;
    hSessionKey2 = CRYPT_NULL;

    hHash1 = CRYPT_NULL;
    hHash2 = CRYPT_NULL;

    keyExchangePublicKeyBlob = NULL;
    signaturePublicKeyBlob = NULL;
    sessionKeyBlob = NULL;
    dataBlob = NULL;
    hashBlob1 = NULL;
    hashBlob2 = NULL;

    //
    // Initialize the crypto package.
    //

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Open the container.
    //

    result = IISCryptoGetStandardContainer(
                 &hProv,
                 0
                 );

    TEST_HRESULT( "IISCryptoGetStandardContainer()" );
    printf( "hProv = %08lx\n", hProv );

    //
    // Get some keys.
    //

    result = IISCryptoGetKeyExchangeKey(
                 &hKeyExchangeKey,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoGetKeyExchangeKey()" );
    printf( "hKeyExchangeKey = %08lx\n", hKeyExchangeKey );

    result = IISCryptoGetSignatureKey(
                 &hSignatureKey,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoGetSignatureKey()" );
    printf( "hSignatureKey = %08lx\n", hSignatureKey );

    result = IISCryptoGenerateSessionKey(
                 &hSessionKey,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoGenerateSessionKey()" );
    printf( "hSessionKey = %08lx\n", hSessionKey );

    //
    // Create a couple of public key blobs.
    //

    result = IISCryptoExportPublicKeyBlob(
                 &keyExchangePublicKeyBlob,
                 hProv,
                 hKeyExchangeKey
                 );

    TEST_HRESULT( "IISCryptoExportPublicKeyBlob()" );
    printf( "keyExchangePublicKeyBlob = %p\n", keyExchangePublicKeyBlob );

    result = IISCryptoExportPublicKeyBlob(
                 &signaturePublicKeyBlob,
                 hProv,
                 hSignatureKey
                 );

    TEST_HRESULT( "IISCryptoExportPublicKeyBlob()" );
    printf( "signaturePublicKeyBlob = %p\n", signaturePublicKeyBlob );

    //
    // Now try to import them.
    //

    result = IISCryptoImportPublicKeyBlob(
                 &hKeyExchangeKey2,
                 keyExchangePublicKeyBlob,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoImportPublicKeyBlob()" );
    printf( "hKeyExchangeKey2 = %08lx\n", hKeyExchangeKey2 );

    result = IISCryptoImportPublicKeyBlob(
                 &hSignatureKey2,
                 signaturePublicKeyBlob,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoImportPublicKeyBlob()" );
    printf( "hSignatureKey2 = %08lx\n", hSignatureKey2 );

    //
    // Create a session key blob.
    //

    result = IISCryptoExportSessionKeyBlob(
                 &sessionKeyBlob,
                 hProv,
                 hSessionKey,
                 hKeyExchangeKey
                 );

    TEST_HRESULT( "IISCryptoExportSessionKeyBlob()" );
    printf( "sessionKeyBlob = %p\n", sessionKeyBlob );

    //
    // Now try to import it back, using the imported signature key.
    //

    result = IISCryptoImportSessionKeyBlob(
                 &hSessionKey2,
                 sessionKeyBlob,
                 hProv,
                 hSignatureKey2
                 );

    TEST_HRESULT( "IISCryptoImportKeyBlob()" );
    printf( "hSessionKey2 = %08lx\n", hSessionKey2 );

    //
    // Create an encrypted data blob using the original session key.
    //

    printf( "PlainText[%lu:%lu] = %s\n", sizeof(PlainText), REG_SZ, PlainText );

    result = IISCryptoEncryptDataBlob(
                 &dataBlob,
                 PlainText,
                 sizeof(PlainText),
                 REG_SZ,
                 hProv,
                 hSessionKey
                 );

    TEST_HRESULT( "IISCryptoEncryptDataBlob()" );
    printf( "dataBlob = %p\n", dataBlob );

    //
    // Decrypt the data blob using the imported session and signature keys.
    //

    result = IISCryptoDecryptDataBlob(
                 &buffer,
                 &bufferLength,
                 &type,
                 dataBlob,
                 hProv,
                 hSessionKey2,
                 hSignatureKey2
                 );

    TEST_HRESULT( "IISCryptoDecryptDataBlob()" );
    printf( "decrypted data[%lu:%lu] = %s\n", bufferLength, type, buffer );

    //
    // Create a hash object number 1 containing the plaintext data
    // and the original session key, then export it as a hash blob.
    //

    result = IISCryptoCreateHash(
                 &hHash1,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoCreateHash()" );
    printf( "hHash1 = %08lx\n", hHash1 );

    result = IISCryptoHashData(
                 hHash1,
                 PlainText,
                 sizeof(PlainText)
                 );

    TEST_HRESULT( "IISCryptoHashData()" );

    result = IISCryptoHashSessionKey(
                 hHash1,
                 hSessionKey
                 );

    TEST_HRESULT( "IISCryptoHashSessionKey()" );

    result = IISCryptoExportHashBlob(
                 &hashBlob1,
                 hHash1
                 );

    TEST_HRESULT( "IISCryptoExportHashBlob()" );
    printf( "hashBlob1 = %p\n", hashBlob1 );

    //
    // Now do the same with the decrypted data and the imported key.
    //

    result = IISCryptoCreateHash(
                 &hHash2,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoCreateHash()" );
    printf( "hHash2 = %08lx\n", hHash2 );

    result = IISCryptoHashData(
                 hHash2,
                 buffer,
                 bufferLength
                 );

    TEST_HRESULT( "IISCryptoHashData()" );

    result = IISCryptoHashSessionKey(
                 hHash2,
                 hSessionKey2
                 );

    TEST_HRESULT( "IISCryptoHashSessionKey()" );

    result = IISCryptoExportHashBlob(
                 &hashBlob2,
                 hHash2
                 );

    TEST_HRESULT( "IISCryptoExportHashBlob()" );
    printf( "hashBlob2 = %p\n", hashBlob2 );

    //
    // Now compare the hash blobs. They had better match.
    //

    if( IISCryptoCompareBlobs( hashBlob1, hashBlob2 ) ) {

        printf( "hashBlob1 == hashBlob2\n" );

    } else {

        printf( "HASH BLOBS DON'T MATCH!!\n" );

    }

cleanup:

    FREE_BLOB( hashBlob2);
    FREE_BLOB( hashBlob1);
    FREE_BLOB( dataBlob );
    FREE_BLOB( sessionKeyBlob );
    FREE_BLOB( signaturePublicKeyBlob );
    FREE_BLOB( keyExchangePublicKeyBlob );

    DESTROY_HASH( hHash2 );
    DESTROY_HASH( hHash1 );

    CLOSE_KEY( hSessionKey2 );
    CLOSE_KEY( hSessionKey );
    CLOSE_KEY( hSignatureKey2 );
    CLOSE_KEY( hSignatureKey );
    CLOSE_KEY( hKeyExchangeKey2 );
    CLOSE_KEY( hKeyExchangeKey );

    if( hProv != CRYPT_NULL ) {

        (VOID)IISCryptoCloseContainer( hProv );

    }

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

#include <windows.h>
#include <wincrypt.h>
#include <objbase.h>


//
// Project include files.
//

#include <dbgutil.h>
#include <iiscryptp.h>

#include <mdcommsg.h>


//
// Private include files.
//

#include <icryptp.h>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\simple\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

#include <windows.h>
#include <wincrypt.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//
// Project include files.
//

#include <dbgutil.h>
#include <iiscrypt.h>


//
// Local prototypes.
//

INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    );


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\delcont\delcont.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    delcont.c

Abstract:

    Delete Win32 Crypto Container.

Author:

    Keith Moore (keithmo)        19-Feb-1998

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else


//
// Private types.
//


//
// Private globals.
//

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT()
#endif

//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    HRESULT result;
    DWORD flags;
    PSTR container;

    //
    // Initialize debug stuff.
    //

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "delcont" );
#endif

    //
    // Validate the arguments.
    //

    flags = 0;
    container = argv[1];

    if( container != NULL ) {
        if( _stricmp( container, "-m" ) == 0 ) {
            flags = CRYPT_MACHINE_KEYSET;
            container = argv[2];
        }
    }

    if( !container ){
        printf(
            "use: delcont [-m] container_name\n"
            "\n"
            "    -m : Delete a machine keyset. Note: This is a very dangerous\n"
            "         option that can leave IIS in an unusable state requiring\n"
            "         reinstallation. Use at your own risk.\n"
            );
        return 1;
    }

    //
    // Initialize the crypto package.
    //

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Delete the container.
    //

    result = IISCryptoDeleteContainerByName(
                 container,
                 flags
                 );

    TEST_HRESULT( "IISDeleteContainerByName()" );

cleanup:

    (VOID)IISCryptoTerminate();
    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\inetmisc\mb.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mb.cxx

Abstract:

    This module implements the MB class.

Author:

    Keith Moore (keithmo)        05-Feb-1997
        Moved from "inlines" in MB.HXX.

Revision History:

--*/


#include "imiscp.hxx"


//
//  Default timeout
//

#define MB_TIMEOUT           (30 * 1000)

//
//  Default timeout for SaveData
//

#define MB_SAVE_TIMEOUT      (10 * 1000)        // milliseconds

MB::MB( IMDCOM * pMBCom )
    : _pMBCom( pMBCom ),
      _hMB   ( NULL )
{
    DBG_ASSERT( _pMBCom );
}

MB::~MB( VOID )
{
    Close();
    _pMBCom = NULL;
}

BOOL MB::EnumObjects( const CHAR * pszPath,
                      CHAR *       Name,
                      DWORD        Index )
{
    HRESULT hRes = _pMBCom->ComMDEnumMetaObjects( _hMB,
                                                  (BYTE *)pszPath,
                                                  (BYTE *)Name,
                                                  Index );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::AddObject( const CHAR * pszPath )
{
    HRESULT hRes = _pMBCom->ComMDAddMetaObject( _hMB,
                                                (BYTE *)pszPath );
    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::DeleteObject( const CHAR * pszPath )
{
    HRESULT hRes = _pMBCom->ComMDDeleteMetaObject( _hMB,
                                                   (BYTE *)pszPath );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::ReleaseReferenceData( DWORD dwTag )
{
    HRESULT hRes = _pMBCom->ComMDReleaseReferenceData( dwTag );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::Save( VOID )
{
    HRESULT hRes;
    METADATA_HANDLE mdhRoot;


    //
    // First try to lock the tree
    //

    hRes = _pMBCom->ComMDOpenMetaObjectW(METADATA_MASTER_ROOT_HANDLE,
                                            NULL,
                                            METADATA_PERMISSION_READ,
                                            MB_SAVE_TIMEOUT,
                                            &mdhRoot);

    //
    // If failed, then someone has a write handle open,
    // and there might be an inconsistent data state, so don't save.
    //

    if (SUCCEEDED(hRes)) {
        //
        // call metadata com api
        //

        hRes = _pMBCom->ComMDSaveData(mdhRoot);


        _pMBCom->ComMDCloseMetaObject(mdhRoot);

    }

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::GetSystemChangeNumber( DWORD *pdwChangeNumber )
{
    HRESULT hRes = _pMBCom->ComMDGetSystemChangeNumber(pdwChangeNumber);

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::DeleteData(const CHAR *  pszPath,
                    DWORD         dwPropID,
                    DWORD         dwUserType,
                    DWORD         dwDataType )
{
    HRESULT hRes = _pMBCom->ComMDDeleteMetaData( _hMB,
                                                (LPBYTE) pszPath,
                                                dwPropID,
                                                dwDataType );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
}

BOOL MB::Close( VOID )
{
    if ( _hMB )
    {
        DBG_REQUIRE( SUCCEEDED(_pMBCom->ComMDCloseMetaObject( _hMB )) );
        _hMB = NULL;
    }

    return TRUE;
}

BOOL
MB::Open(
    METADATA_HANDLE hOpenRoot,
    const CHAR *    pszPath,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Opens the metabase

Arguments:

    hOpenRoot - Relative root or METADATA_MASTER_ROOT_HANDLE
    pszPath - Path to open
    dwFlags - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    DBG_ASSERT(_hMB == NULL);

    hRes = _pMBCom->ComMDOpenMetaObject( hOpenRoot,
                                         (BYTE *) pszPath,
                                         dwFlags,
                                         MB_TIMEOUT,
                                         &_hMB );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[MB::Open] Failed to open %s, error %x (%d)\n",
                pszPath,
                hRes,
                HRESULTTOWIN32( hRes ) ));

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL
MB::SetData(
    const CHAR * pszPath,
    DWORD        dwPropID,
    DWORD        dwUserType,
    DWORD        dwDataType,
    VOID *       pvData,
    DWORD        cbData,
    DWORD        dwFlags
    )
/*++

Routine Description:

    Sets a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    cbData - Size of data
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    DBG_ASSERT( _hMB );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->ComMDSetMetaData( _hMB,
                                      (LPBYTE) pszPath,
                                      &mdRecord );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[MB::SetData] Failed to open %s, error %x (%d)\n",
                pszPath,
                hRes,
                HRESULTTOWIN32( hRes ) ));

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL
MB::GetData(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    DWORD         dwDataType,
    VOID *        pvData,
    DWORD *       pcbData,
    DWORD         dwFlags
    )
/*++

Routine Description:

    Retrieves a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DBG_ASSERT( _hMB );
    DBG_ASSERT(pcbData);

    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen = *pcbData;

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->ComMDGetMetaData( _hMB,
                                      (LPBYTE) pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes ))
    {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
    }

    *pcbData = dwRequiredLen;

#if 0
    DBGPRINTF(( DBG_CONTEXT,
                "[MB::GetData] Failed, PropID(%d), UserType(%d) Flags(%d) on %s, hRes = 0x%08x (%d)\n",
                dwPropID,
                dwUserType,
                dwFlags,
                pszPath,
                hRes,
                HRESULTTOWIN32( hRes ) ));
#endif

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL
MB::ReferenceData(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    DWORD         dwDataType,
    VOID * *      ppvData,
    DWORD *       pcbData,
    DWORD *       pdwTag,
    DWORD         dwFlags
    )
/*++

Routine Description:

    References a metadata property item

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    ppvData - Receives pointer to referenced data
    pdwTag - Receives dword tag for releasing this reference
    dwFlags - flags (must have METADATA_REFERENCE)

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    DBG_ASSERT( _hMB );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = 0;
    mdRecord.pbMDData        = NULL;

    hRes = _pMBCom->ComMDGetMetaData( _hMB,
                                      (LPBYTE) pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes ))
    {
        *ppvData = mdRecord.pbMDData;
        *pcbData = mdRecord.dwMDDataLen;
        *pdwTag  = mdRecord.dwMDDataTag;

        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL MB::GetAll(
    const CHAR *   pszPath,
    DWORD          dwFlags,
    DWORD          dwUserType,
    BUFFER *       pBuff,
    DWORD *        pcRecords,
    DWORD *        pdwDataSetNumber
    )
/*++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath - Path to set data on
    dwFlags - Inerhitance flags
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD   RequiredSize;
    HRESULT hRes;

    DBG_ASSERT( _hMB );

TryAgain:

    hRes = _pMBCom->ComMDGetAllMetaData( _hMB,
                            (unsigned char *)pszPath,
                            dwFlags,
                            dwUserType,
                            ALL_METADATA,
                            pcRecords,
                            pdwDataSetNumber,
                            pBuff->QuerySize(),
                            (PBYTE)pBuff->QueryPtr(),
                            &RequiredSize
                            );

    // See if we got it, and if we failed because of lack of buffer space
    // try again.

    if ( SUCCEEDED(hRes) )
    {
        return TRUE;
    }

    // Some sort of error, most likely not enough buffer space. Keep
    // trying until we get a non-fatal error.

    if (HRESULT_FACILITY(hRes) == FACILITY_WIN32 &&
        HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER) {

        // Not enough buffer space. RequiredSize contains the amount
        // the metabase thinks we need.

        if ( !pBuff->Resize(RequiredSize) ) {

            // Not enough memory to resize.
            return FALSE;
        }

        goto TryAgain;

    }

    return FALSE;
}

BOOL MB::GetDataSetNumber(
    const CHAR *   pszPath,
    DWORD *        pdwDataSetNumber
    )
/*++

Routine Description:

    Retrieves the data set number and size of the data from the
    metabase.

Arguments:

    pszPath - Path to set data on
    pdwDataSetNumber - Where to return the data set number.

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    //
    //  We allow _hMB to be null (root handle) for this API (though technically
    //  all the APIs allow the metabase handle to be null)
    //

    hRes = _pMBCom->ComMDGetDataSetNumber( _hMB,
                                           (unsigned char *)pszPath,
                                           pdwDataSetNumber );

    return SUCCEEDED(hRes);
}

BOOL
MB::GetStr(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    STR *         pstrValue,
    DWORD         dwFlags,
    const CHAR *  pszDefault
    )
/*++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath - Path to get data on
    dwPropID - property id to retrieve
    dwUserType - User type for this property
    pstrValue - string that receives the value
    dwFlags - Metabase flags
    pszDefault - Default value to use if the string isn't found, NULL
        for no default value (i.e., will return an error).

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD cbSize = pstrValue->QuerySize();

TryAgain:

    if ( !GetData( pszPath,
                   dwPropID,
                   dwUserType,
                   STRING_METADATA,
                   pstrValue->QueryStr(),
                   &cbSize,
                   dwFlags ))
    {
        if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
        {
            if ( pszDefault != NULL )
            {
                return pstrValue->Copy( pszDefault );
            }

            return FALSE;
        }
        else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                  pstrValue->Resize( cbSize ) )
        {
            goto TryAgain;
        }

        return FALSE;
    }

    DBG_REQUIRE( pstrValue->SetLen( cbSize ? (cbSize - 1) : 0  ));

    return TRUE;
}

BOOL
MB::GetMultisz(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    MULTISZ *     multiszValue,
    DWORD         dwFlags
    )
/*++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath - Path to get data on
    dwPropID - property id to retrieve
    dwUserType - User type for this property
    multiszValue - multi-string that receives the value
    dwFlags - Metabase flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD cbSize = multiszValue->QuerySize();

TryAgain:

    if ( !GetData( pszPath,
                   dwPropID,
                   dwUserType,
                   MULTISZ_METADATA,
                   multiszValue->QueryStr(),
                   &cbSize,
                   dwFlags ))
    {
        if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
        {
            return FALSE;
        }
        else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                  multiszValue->Resize( cbSize ) )
        {
            goto TryAgain;
        }

        return FALSE;
    }

    //
    //  Value was read directly into the buffer so update the member
    //  variables
    //

    multiszValue->RecalcLen();

    return TRUE;
}


BOOL MB::GetDataPaths(
    const CHAR *   pszPath,
    DWORD          dwPropID,
    DWORD          dwDataType,
    BUFFER *       pBuff
    )
/*++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath - Path to set data on
    dwFlags - Inerhitance flags
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD   RequiredSize;
    HRESULT hRes;

    DBG_ASSERT( _hMB );
    DBG_ASSERT( pBuff != NULL );

TryAgain:

    hRes = _pMBCom->ComMDGetMetaDataPaths( _hMB,
                                           (unsigned char *)pszPath,
                                           dwPropID,
                                           dwDataType,
                                           pBuff->QuerySize(),
                                           (PBYTE)pBuff->QueryPtr(),
                                            &RequiredSize
                                           );

    // See if we got it, and if we failed because of lack of buffer space
    // try again.

    if ( SUCCEEDED(hRes) )
    {
        return TRUE;
    }

    // Some sort of error, most likely not enough buffer space. Keep
    // trying until we get a non-fatal error.

    if (HRESULT_FACILITY(hRes) == FACILITY_WIN32 &&
        HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER) {

        // Not enough buffer space. RequiredSize contains the amount
        // the metabase thinks we need.

        if ( !pBuff->Resize(RequiredSize) ) {

            // Not enough memory to resize.
            return FALSE;
        }

        goto TryAgain;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\isplat\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <inetsvcs.h>

PLATFORM_TYPE TsPlatformType = PtInvalid;

typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( TsPlatformType != PtInvalid ) {
        return(TsPlatformType);
    }

    //
    // see if this is win95
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        IIS_PRINTF((buff,"GetVersionEx failed with %d\n",
            GetLastError()));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibrary("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtWindows95;
    }

    TsPlatformType = pt;
    return(pt);

} // IISGetPlatformType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\svmap\tsvmap.cpp ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
      tsvmap.cxx

   Abstract:
      This is a test module for the server variable map
      
   Author:

       Taylor Weiss    ( TaylorW )     19-Apr-1999

   Environment:
    
       User Mode - Win32 

   Project:

       Internet Information Services

   Functions Exported:


   Revision History:

--*/

#include <windows.h>

#include <dbgutil.h>

#include <svmap.h>
#include <stdio.h>
#include <stdlib.h>

DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisTSvMapGuid, 
0x784d8939, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();    
#endif

#define DEFINE_SV( token ) #token,

LPCSTR rgValidNames[] =
{
    ALL_SERVER_VARIABLES()
};

#undef DEFINE_SV

int cValidNames = sizeof(rgValidNames)/sizeof(rgValidNames[0]);

LPCSTR rgInvalidNames[] =
{
    "HTTP_BOGUS",
    "_HTTP_",
    "47",
    "",
    "Hello, There!",
    "0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz"
};

int cInvalidNames = sizeof(rgInvalidNames)/sizeof(rgInvalidNames[0]);

int __cdecl
main(int argc, char * argv[])
{
    int argSeen = 1;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( argv[0], IisTSvMapGuid);
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( argv[0]);
    SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_INIT_CLEAN);
#endif
    
    SV_CACHE_MAP    map;

    DBG_REQUIRE( map.Initialize() );

    // Dump the table
    
    // This should be more than enough space, see
    // SV_CACHE_MAP::Print if this asserts.

    CHAR  pchBuffer[ 5000 ];
    DWORD cb = sizeof( pchBuffer );

    map.PrintToBuffer( pchBuffer, &cb );
    DBG_ASSERT( cb < sizeof(pchBuffer) );

    printf( pchBuffer );

    DWORD dwId = 0;

    // Do lookups for all valid names

    for( int i = 0; i < cValidNames; ++i )
    {
        DBG_REQUIRE( map.FindOrdinal( rgValidNames[i], 
                                      strlen( rgValidNames[i] ), 
                                      &dwId 
                                      ) );
        
        DBG_REQUIRE( strcmp( rgValidNames[i], map.FindName( dwId ) ) == 0 );
    }

    // Do lookups for invalid names

    for( int j = 0; j < cInvalidNames; ++j )
    {
        DBG_REQUIRE( map.FindOrdinal( rgInvalidNames[j],
                                      strlen( rgInvalidNames[j] ),
                                      &dwId 
                                      ) == FALSE );
    }
   
    DELETE_DEBUG_PRINT_OBJECT();

    return 1;
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\mdadmin\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
      THIS IS A TEMPLATE. Please clone it for your DLL!
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>



//
//  Define the debugging constants
//

#define DEBUG_DLL_SERVICE_INFO     0x00200000L

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\mdadmin\admsub.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    admsub.cxx

    This module contains IISADMIN subroutines.


    FILE HISTORY:
    7/7/97      michth      created
*/
#define INITGUID
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <apiutil.h>
#include <loadadm.hxx>
#include <ole2.h>
#include <inetsvcs.h>
#include <ntsec.h>
#include <string.hxx>
#pragma warning(push, 3)
#include <stringau.hxx>
#pragma warning(pop)
#include <iadmext.h>
#include <admsub.hxx>
#include <imd.h>
#include <iiscnfg.h>
#include <initguid.h>

// IVANPASH
// It is just imposible to include the headers files defining the CLSID of the
// service extensions here. So I have to copy the definition.

// CLSID_WmRgSrv        =   {763A6C86-F30F-11D0-9953-00C04FD919C1}
// defined in iis\svcs\wam\wamreg\wmrgsv.idl
DEFINE_GUID(CLSID_WmRgSrv,          0X763A6C86, 0XF30F, 0X11D0, 0X99, 0X53, 0X00, 0XC0, 0X4F, 0XD9, 0X19, 0XC1);

// CLSID_ADMEXT         =   {C4376B00-F87B-11D0-A6A6-00A0C922E752}
// defined in iis\svcs\admex\secex\bootimp.hxx
// The extension is removed from IIS6/IIS5.1
// DEFINE_GUID(CLSID_ADMEXT,           0XC4376B00, 0XF87B, 0X11D0, 0XA6, 0XA6, 0X0, 0XA0, 0XC9, 0X22, 0XE7, 0X52);

// CLSID_W3EXTEND       =   {FCC764A0-2A38-11D1-B9C6-00A0C922E750}
// defined in iis\svcs\infocomm\extend\coimp.hxx
DEFINE_GUID(CLSID_W3EXTEND,         0XFCC764A0, 0X2A38, 0X11D1, 0XB9, 0XC6, 0X0, 0XA0, 0XC9, 0X22, 0XE7, 0X50);


static const CLSID          *g_rgpclsidExtension[]=
{
    &CLSID_W3EXTEND,
    &CLSID_WmRgSrv
};
static const DWORD          g_cExtensions = sizeof(g_rgpclsidExtension)/sizeof(*g_rgpclsidExtension);

PIADMEXT_CONTAINER          g_piaecHead = NULL;

HRESULT AddServiceExtension(IADMEXT *piaeExtension)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PIADMEXT_CONTAINER piaecExtension = new IADMEXT_CONTAINER;

    if (piaecExtension == NULL) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        piaecExtension->piaeInstance = piaeExtension;
        piaecExtension->NextPtr = g_piaecHead;
        g_piaecHead = piaecExtension;
    }
    return hresReturn;
}

HRESULT
StartServiceExtension(
    const CLSID         *pclsidExtension)
{
    HRESULT             hr = S_OK;
    IADMEXT             *piaeExtension = NULL;

    // Check args
    if ( pclsidExtension == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the extension
    hr = CoCreateInstance( *pclsidExtension,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IADMEXT,
                           (void**) &piaeExtension );
    if ( FAILED(hr) )
    {
        // IVANPASH
        // Not all service extensions are always registered.
        // For example wamreg is registered when w3svc is installed.
        // So if we cannot create a service extension, because the
        // it is not registered yet, just ignore the error.
        if ( hr == REGDB_E_CLASSNOTREG )
        {
            hr = S_OK;
        }
        goto exit;
    }

    // Initialize the extension
    hr = piaeExtension->Initialize();
    if ( FAILED(hr) )
    {
        goto exit;
    }

    // Add the extension to the list of the running extensions
    hr = AddServiceExtension(piaeExtension);
    if ( FAILED(hr) )
    {
        goto exit;
    }

    // Do not clear the extension
    piaeExtension = NULL;

exit:
    DBG_ASSERT( SUCCEEDED(hr) );

    // Cleanup
    if ( piaeExtension != NULL )
    {
        StopServiceExtension( piaeExtension );
        piaeExtension = NULL;
    }

    return hr;
}

HRESULT
StartServiceExtensions()
{
    HRESULT             hr = S_OK;
    DWORD               dwIndex;

    DBG_ASSERT(g_piaecHead == NULL);

    for ( dwIndex = 0; dwIndex < g_cExtensions; dwIndex++ )
    {
        hr = StartServiceExtension( g_rgpclsidExtension[dwIndex] );

        if ( FAILED(hr) )
        {
            goto exit;
        }
    }

exit:
    DBG_ASSERT( SUCCEEDED(hr) );

    // If failed
    if ( FAILED(hr) )
    {
        // Stop all service extenstions
        StopServiceExtensions();
    }

    return hr;
}

BOOL
RemoveServiceExtension(IADMEXT **ppiaeExtension)
{
    BOOL bReturn = FALSE;
    if (g_piaecHead != NULL) {
        PIADMEXT_CONTAINER piaecExtension = g_piaecHead;
        *ppiaeExtension = g_piaecHead->piaeInstance;
        g_piaecHead = g_piaecHead->NextPtr;
        delete piaecExtension;
        bReturn = TRUE;
    }
    return bReturn;
}

VOID
StopServiceExtension(IADMEXT *piaeExtension)
{
    piaeExtension->Terminate();
    piaeExtension->Release();
}


VOID StopServiceExtensions()
{
    IADMEXT *piaeExtension;

    while (RemoveServiceExtension(&piaeExtension)) {
        StopServiceExtension(piaeExtension);
    }
    DBG_ASSERT(g_piaecHead == NULL);
}

HRESULT
AddClsidToBuffer(CLSID clsidDcomExtension,
                 BUFFER *pbufCLSIDs,
                 DWORD *pdwMLSZLen,
                 LPMALLOC pmallocOle)
{
    HRESULT hresReturn = S_OK;

    LPWSTR pszCLSID;

    if (!pbufCLSIDs->Resize((*pdwMLSZLen + CLSID_LEN) * sizeof(WCHAR))) {
        hresReturn =  HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        if (SUCCEEDED(StringFromCLSID(clsidDcomExtension, &pszCLSID))) {
            DBG_ASSERT(wcslen(pszCLSID) + 1 == CLSID_LEN);
            memcpy(((LPWSTR)pbufCLSIDs->QueryPtr()) + *pdwMLSZLen, pszCLSID, CLSID_LEN * sizeof(WCHAR));
            (*pdwMLSZLen) += CLSID_LEN;
            if (pmallocOle != NULL) {
                pmallocOle->Free(pszCLSID);
            }
        }
    }
    return hresReturn;
}

VOID
RegisterServiceExtensionCLSIDs()
{
    HRESULT hresMDError;
    HRESULT hresExtensionError;
    HRESULT hresBufferError;
    HRESULT hresCom;
    CLSID clsidDcomExtension;
    DWORD i;
    IMDCOM * pcCom = NULL;
    METADATA_HANDLE mdhRoot;
    METADATA_HANDLE mdhExtension;
    METADATA_RECORD mdrData;
    PIADMEXT_CONTAINER piaecExtension;
    BUFFER bufCLSIDs;
    DWORD dwMLSZLen = 0;
    BOOL bAreCLSIDs = FALSE;
    LPMALLOC pmallocOle = NULL;

    hresCom = CoGetMalloc(1, &pmallocOle);
    if( SUCCEEDED(hresCom) ) {

        hresMDError = CoCreateInstance(CLSID_MDCOM,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IMDCOM,
                                       (void**) &pcCom);
        if (SUCCEEDED(hresMDError)) {
            hresMDError = pcCom->ComMDInitialize();
            if (SUCCEEDED(hresMDError)) {

                hresMDError = pcCom->ComMDOpenMetaObject(
                    METADATA_MASTER_ROOT_HANDLE,
                    (PBYTE)IISADMIN_EXTENSIONS_CLSID_MD_KEY,
                    METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                    MD_OPEN_DEFAULT_TIMEOUT_VALUE,
                    &mdhExtension);
                if (hresMDError == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
                    hresMDError = pcCom->ComMDOpenMetaObject(
                        METADATA_MASTER_ROOT_HANDLE,
                        NULL,
                        METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                        MD_OPEN_DEFAULT_TIMEOUT_VALUE,
                        &mdhRoot);
                    if (SUCCEEDED(hresMDError)) {
                        hresMDError = pcCom->ComMDAddMetaObject(
                            mdhRoot,
                            (PBYTE)IISADMIN_EXTENSIONS_CLSID_MD_KEY);
                        pcCom->ComMDCloseMetaObject(mdhRoot);
                        if (SUCCEEDED(hresMDError)) {
                            hresMDError = pcCom->ComMDOpenMetaObject(
                                METADATA_MASTER_ROOT_HANDLE,
                                (PBYTE)IISADMIN_EXTENSIONS_CLSID_MD_KEY,
                                METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                MD_OPEN_DEFAULT_TIMEOUT_VALUE,
                                &mdhExtension);
                        }
                    }
                }

                if (SUCCEEDED(hresMDError)) {

                    for (piaecExtension = g_piaecHead, hresBufferError = S_OK;
                         (piaecExtension != NULL) && (SUCCEEDED(hresBufferError));
                         piaecExtension = piaecExtension->NextPtr) {
                        hresMDError = ERROR_SUCCESS;
                        for (i = 0;
                            SUCCEEDED(hresExtensionError =
                                      piaecExtension->piaeInstance->EnumDcomCLSIDs(&clsidDcomExtension,
                                                                                   i));
                            i++) {

                            bAreCLSIDs = TRUE;
                            hresBufferError = AddClsidToBuffer(clsidDcomExtension,
                                                               &bufCLSIDs,
                                                               &dwMLSZLen,
                                                               pmallocOle);
                            if (FAILED(hresBufferError)) {
                                break;
                            }

                        }
                    }

                    BOOL fNeedToWrite = TRUE;

                    // If we failed to deal with the buffer above then we won't
                    // be trying to write new clsids below, but we will need to delete
                    // the old clsids.
                    if ( SUCCEEDED (hresBufferError) )
                    {
                        // Figure out if the clsids have changed.

                        BUFFER MbBuffer;
                        DWORD dwBufferRequiredSize = 0;

                        if (MbBuffer.Resize( (dwMLSZLen + 1) * sizeof(WCHAR) ) )
                        {

                            METADATA_RECORD mdrDataRetrieve;

                            mdrDataRetrieve.dwMDAttributes = METADATA_NO_ATTRIBUTES;
                            mdrDataRetrieve.dwMDUserType = IIS_MD_UT_SERVER;
                            mdrDataRetrieve.dwMDDataType = MULTISZ_METADATA;
                            mdrDataRetrieve.dwMDDataLen = (dwMLSZLen + 1) * sizeof(WCHAR);
                            mdrDataRetrieve.pbMDData = (PBYTE)MbBuffer.QueryPtr();
                            mdrDataRetrieve.dwMDIdentifier = IISADMIN_EXTENSIONS_CLSID_MD_ID;

                            hresMDError = pcCom->ComMDGetMetaDataW( mdhExtension,
                                                     NULL,
                                                     &mdrDataRetrieve,
                                                     &dwBufferRequiredSize );

                            //
                            // if we succeeded in getting info then check if the info
                            // is of the right size and matches the data we all ready have.
                            //
                            if ( SUCCEEDED ( hresMDError ) )
                            {
                                // if we succeeded then we had enough space, so we can
                                // check the full size that we thought should match.
                                // then check the content of the data
                                if ( memcmp ( MbBuffer.QueryPtr(), bufCLSIDs.QueryPtr(), (dwMLSZLen + 1) * sizeof(WCHAR) ) == 0 )
                                {
                                   fNeedToWrite = FALSE;
                                }
                            }
                        }
                    }

                    if ( fNeedToWrite )
                    {
                        //
                        // We need to remove the old clsids.
                        //
                        pcCom->ComMDDeleteMetaData(
                            mdhExtension,
                            NULL,
                            MD_IISADMIN_EXTENSIONS,
                            MULTISZ_METADATA);

                        //
                        // Now we decide if we want to write the
                        // new clsids.
                        //
                        if (bAreCLSIDs && SUCCEEDED(hresBufferError)) {
                            if (bufCLSIDs.Resize((dwMLSZLen + 1) * sizeof(WCHAR))) {

                                *(((LPWSTR)bufCLSIDs.QueryPtr()) + dwMLSZLen) = (WCHAR)'\0';
                                mdrData.dwMDAttributes = METADATA_NO_ATTRIBUTES;
                                mdrData.dwMDUserType = IIS_MD_UT_SERVER;
                                mdrData.dwMDDataType = MULTISZ_METADATA;
                                mdrData.dwMDDataLen = (dwMLSZLen + 1) * sizeof(WCHAR);
                                mdrData.pbMDData = (PBYTE)bufCLSIDs.QueryPtr();
                                mdrData.dwMDIdentifier = IISADMIN_EXTENSIONS_CLSID_MD_ID;

                                hresMDError = pcCom->ComMDSetMetaDataW(
                                    mdhExtension,
                                    NULL,
                                    &mdrData);

                            } // end of writting because we had to.
                        } // end of clsids
                    }  // end of needing to write
                    pcCom->ComMDCloseMetaObject(mdhExtension);
                }
                pcCom->ComMDTerminate(TRUE);
            }
            pcCom->Release();
        }
        if (pmallocOle != NULL) {
            pmallocOle->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\irtl\svmap\svmap.cpp ===
/*++

    Copyright    (c)    1995-1996    Microsoft Corporation

    Module  Name :
        
        svmap.cpp

    Abstract:
        
        Provides name/id mapping for server variables. Used
        to allow server variable values to be cached by out
        of process applications.   

    Author:

        Taylor Weiss    ( TaylorW )     19-Apr-1999

    Environment:


    Project:

        w3svc.dll       private\inet\iis\svcs\w3\server
        wam.dll         private\inet\iis\svcs\wam\object

    Functions Exported:


    Revision History:

--*/

#include <windows.h>
#include <dbgutil.h>

#include <svmap.h>

// Define a table of name, len pairs for each cachable server variable

#define DEFINE_SV( token ) { #token, sizeof(#token) - 1 },

SV_CACHE_MAP::SV_NAME 
SV_CACHE_MAP::sm_rgNames[] =
{
    ALL_SERVER_VARIABLES()
};

#undef DEFINE_SV

BOOL 
SV_CACHE_MAP::Initialize( VOID )
/*++

Routine Description:

    Fills our hash table with name, id pairs.

--*/
{
    BOOL    fInitialized = TRUE;
    DWORD   dwHashValue;

    for( int i = 0; i < SV_COUNT; ++i )
    {
        dwHashValue = HashString( FindName(i) );
        DBG_ASSERT( dwHashValue < TABLE_SIZE );
        
        // It really isn't bad if we collide, it just means that
        // this particular server variable will not be cachable

        DBG_REQUIRE( m_rgHashTable[dwHashValue].InsertValue( i ) );
    }
   
    return fInitialized;
}

BOOL 
SV_CACHE_MAP::FindOrdinal( 
    IN LPCSTR pszName,
    IN INT    cchName,
    OUT DWORD * pdwOrdinal
    ) const
/*++

Routine Description:

    Lookup the server variable specified by name and return it's
    ordinal if found.

    NOTE - We should provide method that doesn't require the 
    length!

Return Value
    
    FALSE == Not found
    TRUE == Found - pdwOrdinal contains the server variable id.

--*/
{
    BOOL    fFoundIt = FALSE;

    DBG_ASSERT( pdwOrdinal );
    
    DWORD                   dwHashValue  = HashString(pszName);
    const HASH_TABLE_ENTRY  &hte         = m_rgHashTable[dwHashValue];
    
    if( !hte.IsSlotEmpty(0) )
    {
        // Hashed to a non empty entry
        
        if( hte.IsSlotEmpty(1) )
        {
            // It's the only one.
            *pdwOrdinal = hte.GetSlotValue(0);
            fFoundIt = StringMatches( pszName, cchName, *pdwOrdinal );
        }
        else
        {
            // Collision, need to compare strings with all
            // the non empty slots or until we get a hit

            DBG_ASSERT( !hte.IsSlotEmpty(0) );
            DBG_ASSERT( !hte.IsSlotEmpty(1) );

            if( StringMatches(pszName, cchName, hte.GetSlotValue(0)) )
            {
                *pdwOrdinal = hte.GetSlotValue(0);
                fFoundIt = TRUE;
            }
            else if( StringMatches(pszName, cchName, hte.GetSlotValue(1)) )
            {
                *pdwOrdinal = hte.GetSlotValue(1);
                fFoundIt = TRUE;
            }
            else if( !hte.IsSlotEmpty(2) &&
                     StringMatches( pszName, cchName, hte.GetSlotValue(2) )
                     )
            {
                *pdwOrdinal = hte.GetSlotValue(2);
                fFoundIt = TRUE;
            }
            else if( !hte.IsSlotEmpty(3) &&
                     StringMatches( pszName, cchName, hte.GetSlotValue(3) )
                     )
            {
                *pdwOrdinal = hte.GetSlotValue(3);
                fFoundIt = TRUE;
            }
        }
    }
    return fFoundIt;
}

VOID 
SV_CACHE_MAP::PrintToBuffer( 
    IN CHAR *       pchBuffer,
    IN OUT LPDWORD  pcch
    ) const
/*++

Routine Description:

    Dump the hash table to pchBuffer.

    Note: We really aren't checking pcch as an in parameter. If
    the buffer is too small we will overwrite it.

--*/
{
    DWORD cb = 0;

    DBG_ASSERT( NULL != pchBuffer);

    cb += wsprintfA( pchBuffer + cb, 
                     "SV_CACHE_MAP(%p): sizeof(SV_CACHE_MAP)=%08x\n",
                     this,
                     sizeof(SV_CACHE_MAP)
                     );
    DBG_ASSERT( cb < *pcch );

    // Gather some stats on the hash table

    DWORD dwEmptyEntries = 0;
    DWORD dwFilledEntries = 0;
    DWORD dwCollisions = 0;

    for( int i = 0; i < TABLE_SIZE; ++i )
    {
        if( m_rgHashTable[i].IsSlotEmpty(0) )
        {
            ++dwEmptyEntries;
        }
        else
        {
            ++dwFilledEntries;
            if( !m_rgHashTable[i].IsSlotEmpty(1) )
            {
                ++dwCollisions;
            }
            if( !m_rgHashTable[i].IsSlotEmpty(2) )
            {
                ++dwCollisions;
            }
            if( !m_rgHashTable[i].IsSlotEmpty(3) )
            {
                ++dwCollisions;
            }
        }
    }

    cb += wsprintfA( pchBuffer + cb,
                     "Table Size = %d; Hashed Items = %d; Empty Entries = %d; "
                     "Filled Entries = %d; Collisions = %d;\n",
                     TABLE_SIZE, SV_COUNT, dwEmptyEntries, dwFilledEntries,
                     dwCollisions
                     );

    DBG_ASSERT( cb < *pcch );

    for( int j = 0; j < TABLE_SIZE; ++j )
    {
        if( !m_rgHashTable[j].IsSlotEmpty(0) )
        {
            cb += wsprintfA( pchBuffer + cb, "%03d", j );
            DBG_ASSERT( cb < *pcch );

            int k = 0;
            while( k < HASH_TABLE_ENTRY::MAX_ITEMS && !m_rgHashTable[j].IsSlotEmpty(k) )
            {
                cb += wsprintfA( pchBuffer + cb,
                                 " - %d (%s)",
                                 m_rgHashTable[j].GetSlotValue(k),
                                 sm_rgNames[m_rgHashTable[j].GetSlotValue(k)]
                                 );
                DBG_ASSERT( cb < *pcch );
                
                k++;
            }

            cb += wsprintfA( pchBuffer + cb, "\n" );
            DBG_ASSERT( cb < *pcch );
        }
    }

    *pcch = cb;
    return;
}

VOID 
SV_CACHE_MAP::Print( VOID ) const
/*++

Routine Description:


--*/
{
    // DANGER - This buffer size is much larger then necessary, but
    // changes to the PrintToBuffer or the underlying size of the
    // SV_CACHE_MAP may make this buffer insufficient.

    CHAR  pchBuffer[ 10000 ];
    DWORD cb = sizeof( pchBuffer );

    PrintToBuffer( pchBuffer, &cb );
    DBG_ASSERT( cb < sizeof(pchBuffer) );

    DBGDUMP(( DBG_CONTEXT, pchBuffer ));
}

VOID 
SV_CACHE_LIST::GetBufferItems
( 
    IN OUT BUFFER_ITEM *    pBufferItems,
    IN OUT DWORD *          pdwBufferItemCount
)
/*++

Routine Description:

    Initialize pBufferItems with the server variable ids that
    should be cached.

--*/
{
    DBG_ASSERT( pdwBufferItemCount && *pdwBufferItemCount >= SVID_COUNT );

    DWORD   dwCount = 0;

    for( DWORD svid = 0; svid < SVID_COUNT; ++svid )
    {
        if( m_rgItems[svid].fCached )
        {
            if( dwCount < *pdwBufferItemCount )
            {
                pBufferItems[dwCount].svid = svid;
                pBufferItems[dwCount].dwOffset = 0;
            }
            ++dwCount;
        }
    }
    *pdwBufferItemCount = dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\mdadmin\mdwriter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mdwriter.cxx

Abstract:

    This file contains implementation for snapshot writer class

Author:

    Ming Lu (MingLu)            30-Apr-2000

--*/

#include <dbgutil.h>
#include "mdwriter.hxx"

#define TIMEOUT_INTERVAL       ( 2 * 60 )
#define DEFAULT_SAVE_TIMEOUT   30000
#define IISCOMPONENT           L"IISMETABASE"
#define METABASEPATH           L"%windir%\\system32\\inetsrv"
#define METABASENAME1          L"metabase.bin"
#define METABASENAME2          L"MetaBase.XML"
#define METABASENAME3          L"MBSchema.XML"

#define NT_SETUP_KEY           "SYSTEM\\Setup"

static VSS_ID  s_WRITERID =
{
    0x59b1f0cf, 0x90ef, 0x465f,
    0x96, 0x09, 0x6c, 0xa8, 0xb2, 0x93, 0x83, 0x66
};

static LPCWSTR  s_WRITERNAME         = L"IIS Metabase Writer";

BOOL            g_fWriterSubscribed  = FALSE;
CIISVssWriter * g_pIISVssWriter      = NULL;

VOID CALLBACK UnlockMBProc(
    LPVOID pIISVssWriter,
    DWORD  dwTimerLowValue,
    DWORD  dwTimerHighValue
);


BOOL
CIISVssWriter::Initialize(
    VOID
    )
{
    HRESULT hr;

    if ( !InitializeCriticalSectionAndSpinCount( &m_csMBLock, 0 ) )
    {
        return FALSE;
    }
    m_fCSInited = TRUE;


    hr = CVssWriter::Initialize( s_WRITERID,
                                 s_WRITERNAME,
                                 VSS_UT_SYSTEMSERVICE,
                                 VSS_ST_OTHER
                                 );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in base object Initialize().  hr = %x\n",
                    hr ));

        return FALSE;
    }

    m_hTimer = CreateWaitableTimer( NULL, FALSE, NULL );
    if( !m_hTimer )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating timer object.  hr = %x\n",
                    HRESULT_FROM_WIN32( GetLastError() ) ));

        return FALSE;
    }

    hr = CoCreateInstance( CLSID_MDCOM, NULL, CLSCTX_INPROC_SERVER, IID_IMDCOM, (void**) &m_pMdObject);
    if( SUCCEEDED( hr ) )
    {
        hr = m_pMdObject->ComMDInitialize();
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initialize MDCOM object.  hr = %x\n",
                        hr ));

            m_pMdObject->Release();
            m_pMdObject = NULL;

            return FALSE;
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating MDCOM object.  hr = %x\n",
                    hr ));

        return FALSE;
    }

    return TRUE;
}

bool STDMETHODCALLTYPE
CIISVssWriter::OnIdentify(
    IN IVssCreateWriterMetadata *pMetadata
    )
{
    HRESULT hr;

    hr = pMetadata->AddComponent( VSS_CT_FILEGROUP,
                                  NULL,
                                  IISCOMPONENT,
                                  NULL,
                                  0,
                                  0,
                                  FALSE,
                                  FALSE,
                                  FALSE );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error AddComponent().  hr = %x\n",
                    hr ));

        return FALSE;
    }

    if ( TsIsNtWksta() )
    {
        hr = pMetadata->AddFilesToFileGroup( NULL,
                                             IISCOMPONENT,
                                             METABASEPATH,
                                             METABASENAME1,
                                             FALSE,
                                             NULL );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error AddFilesToFileGroup().  hr = %x\n",
                        hr ));

            return FALSE;
        }
    }
    else
    {
        hr = pMetadata->AddFilesToFileGroup( NULL,
                                             IISCOMPONENT,
                                             METABASEPATH,
                                             METABASENAME2,
                                             FALSE,
                                             NULL );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error AddFilesToFileGroup().  hr = %x\n",
                        hr ));

            return FALSE;
        }

        hr = pMetadata->AddFilesToFileGroup( NULL,
                                             IISCOMPONENT,
                                             METABASEPATH,
                                             METABASENAME3,
                                             FALSE,
                                             NULL );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error AddFilesToFileGroup().  hr = %x\n",
                        hr ));

            return FALSE;
        }
    }

    hr = pMetadata->SetRestoreMethod(
               VSS_RME_RESTORE_AT_REBOOT,    // restore method
               NULL,                         // service name
               NULL,                         // user procedure
               VSS_WRE_NEVER,                // when to call writer restore method
               TRUE                          // reboot is required
               );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error setting restore method.  hr = %x\n",
                    hr ));

        return FALSE;
    }

    return TRUE;
}

bool STDMETHODCALLTYPE
CIISVssWriter::OnPrepareBackup(
    IN IVssWriterComponents *)
{
    return TRUE;
}

bool STDMETHODCALLTYPE
CIISVssWriter::OnPrepareSnapshot(
    VOID
    )
{
    HRESULT           hr;

    if( IsPathAffected( METABASEPATH ) )
    {
        //
        // First try to lock the tree
        //

        hr = m_pMdObject->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                                NULL,
                                                METADATA_PERMISSION_READ,
                                                DEFAULT_SAVE_TIMEOUT,
                                                &m_mdhRoot);

        if ( SUCCEEDED( hr ) ) {
            //
            // call metadata com api
            //

            hr = m_pMdObject->ComMDSaveData( m_mdhRoot );

            if( SUCCEEDED( hr ) )
            {
                hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

                if( SUCCEEDED ( hr ) )
                {
                    return TRUE;
                }

                DBGPRINTF(( DBG_CONTEXT,
                            "Error on unlocking the metabase.  hr = %x\n",
                            hr ));

                return FALSE;
            }

            DBGPRINTF(( DBG_CONTEXT,
                        "Error on saving the metabase.  hr = %x\n",
                        hr ));

            m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

            return FALSE;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "Error on locking down the metabase.  hr = %x\n",
                    hr ));

        return FALSE;
    }

    return TRUE;
}


bool STDMETHODCALLTYPE
CIISVssWriter::OnFreeze(
    VOID
    )
{
    HRESULT hr;

    if( IsPathAffected( METABASEPATH ) )
    {
        //
        // Lock down the metabase
        //

        hr = m_pMdObject->ComMDOpenMetaObjectW(METADATA_MASTER_ROOT_HANDLE,
                                               NULL,
                                               METADATA_PERMISSION_READ,
                                               DEFAULT_SAVE_TIMEOUT,
                                               &m_mdhRoot);

        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on locking down the metabase.  hr = %x\n",
                        hr ));

            return FALSE;
        }
        else
        {
            if( !ResetTimer( m_hTimer, TIMEOUT_INTERVAL ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Could not reset the internal timer.  hr = %x\n",
                            hr ));

                return FALSE;
            }

            EnterCriticalSection( &m_csMBLock );

            m_fMBLocked = TRUE;

            LeaveCriticalSection( &m_csMBLock );

        }
    }

    return TRUE;
}

bool STDMETHODCALLTYPE
CIISVssWriter::OnThaw(
    VOID
    )
{
    HRESULT hr;

    if( IsPathAffected( METABASEPATH ) )
    {

        EnterCriticalSection( &m_csMBLock );

        if( m_fMBLocked )
        {
            hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error on unlocking the metabase.  hr = %x\n",
                            hr ));

                LeaveCriticalSection( &m_csMBLock );

                return FALSE;
            }

            m_fMBLocked = FALSE;

            LeaveCriticalSection( &m_csMBLock );

            CancelWaitableTimer( m_hTimer );
        }
        else
        {
            LeaveCriticalSection( &m_csMBLock );
        }
    }

    return TRUE;
}

bool STDMETHODCALLTYPE
CIISVssWriter::OnBackupComplete(
    IN IVssWriterComponents *)
{
    return TRUE;
}

bool STDMETHODCALLTYPE
CIISVssWriter::OnAbort(
    VOID
    )
{
    HRESULT hr;

    if( IsPathAffected( METABASEPATH ) )
    {

        EnterCriticalSection( &m_csMBLock );

        if( m_fMBLocked )
        {
            hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error on unlocking the metabase.  hr = %x\n",
                            hr ));

                LeaveCriticalSection( &m_csMBLock );

                return FALSE;
            }

            m_fMBLocked = FALSE;

            LeaveCriticalSection( &m_csMBLock );

            CancelWaitableTimer( m_hTimer );
        }
        else
        {
            LeaveCriticalSection( &m_csMBLock );
        }
    }

    return true;
}

VOID
CIISVssWriter::UnlockMetaBase(
     VOID
     )
{
    HRESULT hr;

    EnterCriticalSection( &m_csMBLock );

    if( m_fMBLocked )
    {
        hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on unlocking the metabase.  hr = %x\n",
                        hr ));

            LeaveCriticalSection( &m_csMBLock );

            return;
        }

        m_fMBLocked = FALSE;
    }

    LeaveCriticalSection( &m_csMBLock );
}

BOOL
CIISVssWriter::ResetTimer(
    HANDLE hTimer,
    DWORD  dwDuration
    )
{
    LARGE_INTEGER li;
    const int nNanosecondsPersecond = 10000000;
    __int64 qwTimeFromNowInNanoseconds =
                      (__int64)dwDuration * nNanosecondsPersecond;

    qwTimeFromNowInNanoseconds = -qwTimeFromNowInNanoseconds;

    li.LowPart = (DWORD) (qwTimeFromNowInNanoseconds & 0xFFFFFFFF);
    li.HighPart = (LONG) (qwTimeFromNowInNanoseconds >> 32);

    if( !SetWaitableTimer( hTimer, &li, 0, UnlockMBProc, this, FALSE ) )
    {
        return FALSE;
    }

    return TRUE;
}

VOID CALLBACK
UnlockMBProc(
    LPVOID  pIISVssWriter,
    DWORD   ,
    DWORD   )
{
    ( ( CIISVssWriter * )pIISVssWriter )->UnlockMetaBase();
}

DWORD
WINAPI
InitMDWriterThread(
    LPVOID
    )
{
    HRESULT             hr = S_OK;
    HKEY                hKey;
    DWORD               dwType;
    DWORD               cbData;
    DWORD               dwSetupInProgress  = 0;
    DWORD               dwUpgradeInProcess = 0;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // Read the setup registry key to see if we are in
    // setup mode. If we are, don't init IIS writer.
    //
    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        NT_SETUP_KEY,
                        0,
                        KEY_QUERY_VALUE,
                        &hKey ) )
    {
        cbData = sizeof( DWORD );

        if( !RegQueryValueEx( hKey,
                              "SystemSetupInProgress",
                              NULL,
                              &dwType,
                              ( LPBYTE )&dwSetupInProgress,
                              &cbData ) )
        {
            if( dwType == REG_DWORD && dwSetupInProgress != 0 )
            {
                //
                // We are in setup mode
                //
                RegCloseKey( hKey );
                goto exit;
            }
        }

        if( !RegQueryValueEx( hKey,
                              "UpgradeInProgress",
                              NULL,
                              &dwType,
                              ( LPBYTE )&dwUpgradeInProcess,
                              &cbData ) )
        {
            if( dwType == REG_DWORD && dwUpgradeInProcess != 0 )
            {
                //
                // We are in upgrade mode
                //
                RegCloseKey( hKey );
                goto exit;
            }
        }

        RegCloseKey( hKey );
    }

    //
    // OK, we are not in setup mode, initialize our IIS writer
    //

    g_pIISVssWriter = new CIISVssWriter;
    if ( g_pIISVssWriter == NULL )
    {
        //
        // oh well.  guess we wont support snapshots
        //

        DBGPRINTF(( DBG_CONTEXT,
                 "Error on creating the writer object, out of memory\n"
                 ));

        goto exit;
    }
    else
    {
        //
        // cool, weve got the object now.
        //

        if( !g_pIISVssWriter->Initialize() )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on initializing the writer object\n"
                        ));

            delete g_pIISVssWriter;
            g_pIISVssWriter = NULL;

            goto exit;
        }

        if( SUCCEEDED( g_pIISVssWriter->Subscribe() ) )
        {
            g_fWriterSubscribed = TRUE;
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on subscribing the writer object\n"
                        ));

            delete g_pIISVssWriter;
            g_pIISVssWriter = NULL;
        }
    }

exit:
    //
    // Let the TerminateMDWriter know we are ready to terminate during
    // IISADMIN service shutdown
    //
    if( SUCCEEDED( hr ) )
    {
        CoUninitialize();
    }

    return (DWORD)hr;
}

HRESULT
InitializeMDWriter(
    HANDLE              *phMDWriterThread
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwThreadID;

    DBG_ASSERT( phMDWriterThread != NULL );

    *phMDWriterThread = CreateThread( NULL,
                                      0,
                                      InitMDWriterThread,
                                      NULL,
                                      0,
                                      &dwThreadID);
    if( *phMDWriterThread == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
}

VOID
TerminateMDWriter(
    HANDLE              hMDWriterThread
    )
{
    DBG_ASSERT( hMDWriterThread != NULL );

    //
    // Only do cleanup if the hMDWriterThread is signaled
    //
    if( WAIT_OBJECT_0 == WaitForSingleObject( hMDWriterThread,
                                              INFINITE ) )
    {
        if( g_pIISVssWriter )
        {
            if( g_fWriterSubscribed )
            {
                DBG_ASSERT( g_pIISVssWriter );

                g_pIISVssWriter->Unsubscribe();
            }

            delete g_pIISVssWriter;
            g_pIISVssWriter = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\mdadmin\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the IISADMIN Service.

    Functions exported by this module:

        ServiceEntry


    FILE HISTORY:
        michth - created
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include <dbgutil.h>
#include <apiutil.h>
#include <loadadm.hxx>
#include <ole2.h>
#include <inetsvcs.h>
#include <ntsec.h>
#include <iadmext.h>
#include <string.hxx>
#include <admsub.hxx>
#include <imd.h>
#include <irtlmisc.h>
#include "mdwriter.hxx"

#define IISADMIN_SERVICE_NAME           TEXT("IISADMIN")
#define QueryServiceName()              IISADMIN_SERVICE_NAME
#define NULL_SERVICE_STATUS_HANDLE      ((SERVICE_STATUS_HANDLE)NULL)

#define IISADMIN_SVC_KEY                "SYSTEM\\CurrentControlSet\\Services\\IISADMIN"
#define IISADMIN_STARTUP_WAITHINT_VALUE "StartupWaitHintInMilliseconds"

//
// Note:  Due to how the system starts up, we can not have another thread that lies to the SCM
// and tells it we are still starting, so instead we are going to have a hard coded startup time
// limit of 3 minutes.  However, there is also a registry key that can override this value if we
// ever need to bump the start time limit to a larger value.
//
#define SERVICE_START_WAIT_HINT         (180000)        // milliseconds = 180 seconds = 3 minutes

//
// For shutdown it is fine to have the thread lie-ing to the SCM because it will not block any
// vital system operations ( like startup )
//
#define SERVICE_STOP_WAIT_HINT          (10000)        // milliseconds = 10 seconds
#define SERVICE_UPDATE_STATUS           (9000)         // milliseconds = 9 seconds (must be less that the stop wait hint)

//
//  Default timeout for SaveMetabase
//

#define MB_SAVE_TIMEOUT                 (10000)        // milliseconds

DECLARE_PLATFORM_TYPE();

SERVICE_STATUS          g_svcStatus;
SERVICE_STATUS_HANDLE   g_hsvcStatus;
HANDLE                  g_hShutdownEvent = NULL;
HANDLE                  g_hSCMNotifyThread = NULL;
HANDLE                  g_hSCMNotifyEvent  = NULL;

//
// Debugging stuff
//

DECLARE_DEBUG_PRINTS_OBJECT();

typedef struct _THREAD_PARAMS
{
    HANDLE hInitEvent;
    BOOL   bInitSuccess;
} THREAD_PARAMS, *PTHREAD_PARAMS;

extern "C"
{
BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    );
}

DWORD
GetStartupWaitHint();

VOID
StartUpIndicateClientActivity(VOID);

DWORD
SCMNotifyThread(
    PVOID pv);



BOOL
WINAPI
DLLEntry(
    HINSTANCE ,
    DWORD     dwReason,
    LPVOID    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    BOOL bReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        INITIALIZE_PLATFORM_TYPE();

        CREATE_DEBUG_PRINT_OBJECT( "iisadmin" );
        LOAD_DEBUG_FLAGS_FROM_REG_STR( "System\\CurrentControlSet\\Services\\iisadmin\\Parameters", 0 );

        //
        //  Create shutdown event.
        //

        g_hShutdownEvent = IIS_CREATE_EVENT( "g_hShutdownEvent",
                                             &g_hShutdownEvent,
                                             TRUE,                        // fManualReset
                                             FALSE );                     // fInitialState

        if( g_hShutdownEvent == NULL )
        {
            // Last Error is all ready set because the create event failed.
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        CloseHandle(g_hShutdownEvent);
        g_hShutdownEvent = NULL;

        DELETE_DEBUG_PRINT_OBJECT( );
        break;

    default:
        break;
    }

    return bReturn;
}

DWORD
ReportServiceStatus( VOID)
/*++
    Description:

        Wraps the call to SetServiceStatus() function.
        Prints the service status data if need be

    Arguments:

        None

    Returns:

        NO_ERROR if successful. other Win32 error code on failure.
        If successfull the new status has been reported to the service
         controller.
--*/
{
    DWORD err = NO_ERROR;

    IF_DEBUG( DLL_SERVICE_INFO)
    {
          DBGPRINTF(( DBG_CONTEXT, "dwServiceType             = %08lX\n",
                      g_svcStatus.dwServiceType ));

          DBGPRINTF(( DBG_CONTEXT, "dwCurrentState            = %08lX\n",
                      g_svcStatus.dwCurrentState ));

          DBGPRINTF(( DBG_CONTEXT, "dwControlsAccepted        = %08lX\n",
                      g_svcStatus.dwControlsAccepted ));

          DBGPRINTF(( DBG_CONTEXT, "dwWin32ExitCode           = %08lX\n",
                      g_svcStatus.dwWin32ExitCode ));

          DBGPRINTF(( DBG_CONTEXT, "dwServiceSpecificExitCode = %08lX\n",
                      g_svcStatus.dwServiceSpecificExitCode ));

          DBGPRINTF(( DBG_CONTEXT, "dwCheckPoint              = %08lX\n",
                      g_svcStatus.dwCheckPoint ));

          DBGPRINTF(( DBG_CONTEXT, "dwWaitHint                = %08lX\n",
                      g_svcStatus.dwWaitHint ));
    }

    if( !SetServiceStatus( g_hsvcStatus, &g_svcStatus ) )
    {

        err = GetLastError();

    }
    else
    {

        err = NO_ERROR;
    }

    return err;
}   // ReportServiceStatus()

DWORD
UpdateServiceStatus(
        IN DWORD dwState,
        IN DWORD dwWin32ExitCode,
        IN DWORD dwServiceSpecificExitCode,
        IN DWORD dwCheckPoint,
        IN DWORD dwWaitHint
        )
/*++
    Description:

        Updates the local copy status of service controller status
         and reports it to the service controller.

    Arguments:

        dwState - New service state.

        dwWin32ExitCode - Service exit code.

        dwCheckPoint - Check point for lengthy state transitions.

        dwWaitHint - Wait hint for lengthy state transitions.

    Returns:

        NO_ERROR on success and returns Win32 error if failure.
        On success the status is reported to service controller.

--*/
{
    g_svcStatus.dwCurrentState              = dwState;
    g_svcStatus.dwWin32ExitCode             = dwWin32ExitCode;
    g_svcStatus.dwServiceSpecificExitCode   = dwServiceSpecificExitCode;
    g_svcStatus.dwCheckPoint                = dwCheckPoint;
    g_svcStatus.dwWaitHint                  = dwWaitHint;

    return ReportServiceStatus();

} // UpdateServiceStatus()

VOID
InterrogateService( VOID )
/*++
    Description:

        This function interrogates with the service status.
        Actually, nothing needs to be done here; the
        status is always updated after a service control.
        We have this function here to provide useful
        debug info.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     15-Nov-1994 Ported to Tcpsvcs.dll
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO)
    {
        DBGPRINTF(( DBG_CONTEXT, "Interrogating service status for %s\n",
                    QueryServiceName() ));
    }
}   // InterrogateService()

VOID
PauseService( VOID )
/*++
    Description:

        This function pauses the service. When the service is paused,
        no new user sessions are to be accepted, but existing connections
        are not effected.

        This function must update the SERVICE_STATUS::dwCurrentState
         field before returning.

    Returns:

        None. If successful the service is paused.

--*/
{
    IF_DEBUG( DLL_SERVICE_INFO)
    {
        DBGPRINTF(( DBG_CONTEXT, "pausing service %s\n",
                    QueryServiceName() ));
    }

    g_svcStatus.dwCurrentState = SERVICE_PAUSED;
}   // PauseService()


VOID
ContinueService( VOID )
/*++

    Description:
        This function restarts ( continues) a paused service. This
        will return the service to the running state.

        This function must update the g_svcStatus.dwCurrentState
         field to running mode before returning.

    Returns:
        None. If successful then the service is running.

--*/
{

    IF_DEBUG( DLL_SERVICE_INFO)
    {
        DBGPRINTF(( DBG_CONTEXT, "continuing service %s\n",
                    QueryServiceName() ));
    }

    g_svcStatus.dwCurrentState = SERVICE_RUNNING;
}   // ContinueService()

VOID
StopService( VOID )
/*++
    Description:

        This function performs the shutdown on a service.
        This is called during system shutdown.

        This function is time constrained. The service controller gives a
        maximum of 20 seconds for shutdown for all active services.
         Only timely operations should be performed in this function.

    Returns:

        None. If successful, the service is shutdown.
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO)
    {
        DBGPRINTF(( DBG_CONTEXT, "shutting down service %s\n",
                    QueryServiceName() ));
    }

    // Transition the server status now to stop
    // pending so that net.exe sees that we are
    // planning on listening to them.  This has to
    // be done before the set event, because the set
    // event will startup the other thread which will
    // start updating these values as well.

    // I considered if there was any other way for this
    // event to get set that would cause a race with this call.
    // If the exe exits on it's own while we are being asked to
    // stop, but have not started stopping the service yet, it is
    // possible, but this situation all ready exists even if you
    // are transitioning to paused or continue.  So I did not worry
    // about it here.
    UpdateServiceStatus( SERVICE_STOP_PENDING,
                         NO_ERROR,
                         S_OK,
                         1,
                         SERVICE_STOP_WAIT_HINT );


    SetEvent( g_hShutdownEvent );
} // StopService()


BOOL
SaveMetabase( VOID )
/*++
    Description:

        This function tells the metabase to save itself.

    Returns:

        If TRUE, the metabase has been saved.
--*/
{
    HRESULT             hRes;
    METADATA_HANDLE     mdhRoot;
    IMDCOM              * pMDCom = NULL;

    hRes = CoCreateInstance( CLSID_MDCOM,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IMDCOM,
                             (void**) &pMDCom);

    if (SUCCEEDED(hRes))
    {
        hRes = pMDCom->ComMDInitialize();

        if (SUCCEEDED(hRes))
        {
            //
            // Try to lock the tree
            //

            hRes = pMDCom->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                                 NULL,
                                                 METADATA_PERMISSION_READ,
                                                 MB_SAVE_TIMEOUT,
                                                 &mdhRoot );

            //
            // If failed, then someone has a write handle open,
            // and there might be an inconsistent data state, so don't save.
            //

            if (SUCCEEDED(hRes))
            {
                //
                // Call metadata com api to save
                //

                hRes = pMDCom->ComMDSaveData(mdhRoot);


                pMDCom->ComMDCloseMetaObject(mdhRoot);

            }

            pMDCom->ComMDTerminate(TRUE);
        }

        pMDCom->Release();
    }


    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service, SaveMetabase() failed, hr=%lu\n", hRes ));
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;

} // SaveMetabase()


VOID
ServiceControlHandler(
    IN DWORD            dwOpCode)
/*++
    Description:

        This function received control requests from the service controller.
        It runs in the context of service controller's dispatcher thread and
        performs the requested function.
        ( Note: Avoid time consuming operations in this function.)

    Arguments:

        dwOpCode
            indicates the requested operation. This should be
            one of the SERVICE_CONTROL_* manifests.


    Returns:
        None. If successful, then the state of the service might be changed.

    Note:
        if an operation ( especially SERVICE_CONTROL_STOP) is very lengthy,
         then this routine should report a STOP_PENDING status and create
         a worker thread to do the dirty work. The worker thread would then
         perform the necessary work and for reporting timely wait hints and
         final SERVICE_STOPPED status.

    History:
        KeithMo     07-March-1993  Created
        MuraliK     15-Nov-1994    Generalized it for all services.
--*/
{
    //
    //  Interpret the opcode.
    //

    switch( dwOpCode )
    {

    case SERVICE_CONTROL_INTERROGATE :
        InterrogateService();
        break;

    case SERVICE_CONTROL_STOP :
        DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service received stop notice\n" ));
        StopService();
        break;

    case SERVICE_CONTROL_PAUSE :
        PauseService();
        break;

    case SERVICE_CONTROL_CONTINUE :
        ContinueService();
        break;

    case SERVICE_CONTROL_SHUTDOWN :
#if 0
        //
        //  On shutdown, service controller doesn't respect ordering so
        //  this call can block here or force unloading of some stuff that
        //  a subsequent service needs.

        StopService();
#else
        //
        // Although we aren't cleanly shutting down everything, we want
        // to at least make sure the metabase has been saved.
        //

        DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service saving metabase\n" ));

        SaveMetabase();

        DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service IGNORING shutdown notice\n" ));
#endif
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT, "Unrecognized Service Opcode %lu\n",
                    dwOpCode ));
        break;
    }

    //
    //  Report the current service status back to the Service
    //  Controller.  The workers called to implement the OpCodes
    //  should set the g_svcStatus.dwCurrentState field if
    //  the service status changed.
    //

    if ((dwOpCode != SERVICE_CONTROL_STOP) && (dwOpCode != SERVICE_CONTROL_SHUTDOWN))
    {
        // there is a race condition between this thread and the main thread, which
        // was kicked off in StopService.
        // The dll can get unloaded while this call is in progress.
        // Main thread reports status anyways, so don't report it.
        ReportServiceStatus();
    }

}   // ServiceControlHandler()

//
// While we are in the process of shutting down the timer
// code will call us so we can let the SCM no that we are still
// alive.
//
VOID CALLBACK ShutdownCallback(
    PVOID               ,
    BOOLEAN             )
{
    UpdateServiceStatus( SERVICE_STOP_PENDING,
                         0,
                         0,
                         g_svcStatus.dwCheckPoint + 1,
                         SERVICE_STOP_WAIT_HINT );

}


BOOL
StartThread(
    IN LPTHREAD_START_ROUTINE   pStartAddress,
    OUT PHANDLE                 phThread)
{
    BOOL                        bReturn = FALSE;
    HANDLE                      hThread = NULL;
    DWORD                       dwThreadID;
    DWORD                       dwWaitReturn;
    THREAD_PARAMS               tpParams;

    tpParams.bInitSuccess = FALSE;
    tpParams.hInitEvent = IIS_CREATE_EVENT( "THREAD_PARAMS::hInitEvent",
                                            &tpParams,
                                            TRUE,             // fManualReset
                                            FALSE );             // fInitialState

    if( tpParams.hInitEvent != NULL )
    {
        hThread = CreateThread( NULL,
                                0,
                                pStartAddress,
                                (PVOID)&tpParams,
                                0,
                                &dwThreadID );

        if (hThread != NULL)
        {
            //
            //  Wait for the init event.
            //
            dwWaitReturn = WaitForSingleObject( tpParams.hInitEvent,
                                                10000 );
            bReturn = tpParams.bInitSuccess;
        }

        CloseHandle(tpParams.hInitEvent);
    }

    *phThread = hThread;

    return(bReturn);
}

VOID
ServiceEntry(
    DWORD                   ,
    LPWSTR                  [],
    PTCPSVCS_GLOBAL_DATA    pGlobalData)
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    DWORD           err = NO_ERROR;
    HRESULT         hr = S_OK;
    HANDLE          hShutdownCallbackTimer = NULL;
    HANDLE          hMDWriterThread        = NULL;
    RPC_STATUS      rpcStatus;
    BOOL            bTempFlag = FALSE;
    DWORD           dwWait;
    BOOL            fComInitialized = FALSE;

    //
    // We are running as a service, tell the SCM what we are doing.
    //

    //
    // First initalize the global status structure.  This shouldn't be used
    // if we are not running as a service, but since this is legacy code I
    // will continue to initialize this here.
    //
    g_svcStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    g_svcStatus.dwCurrentState            = SERVICE_STOPPED;
    g_svcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;
    g_svcStatus.dwWin32ExitCode           = NO_ERROR;
    g_svcStatus.dwServiceSpecificExitCode = NO_ERROR;
    g_svcStatus.dwCheckPoint              = 0;
    g_svcStatus.dwWaitHint                = 0;


    //
    // We are running as a service then we need to register
    // with SCM.
    //
    g_hsvcStatus = RegisterServiceCtrlHandler( QueryServiceName(),
                                               ServiceControlHandler );
    //
    //  Register the Control Handler routine.
    //
    if( g_hsvcStatus == NULL_SERVICE_STATUS_HANDLE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        goto Cleanup;
    }

    //
    //  Update the service status.  (This will not update
    //  the service if we are not running as a service, but
    //  it will adjust the global service status
    //
    err = UpdateServiceStatus( SERVICE_START_PENDING,
                               NO_ERROR,
                               S_OK,
                               1,
                               GetStartupWaitHint() );

    if( err != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto Cleanup;
    }

    InitializeIISRTL();

    //
    //  Do the OLE security hack to setup the NT desktop
    //
    hr = InitDesktopWinsta();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY | COINIT_DISABLE_OLE1DDE );
    if ( FAILED( hr ) )
    {
        // This should be the 1st call in the thread.
        DBG_ASSERT( hr != RPC_E_CHANGED_MODE );

        goto Cleanup;
    }
    fComInitialized = TRUE;

    // Now initialize Com security
    // When called CoInitializeSecurity will make sure that the Ole Resolver connects to the OleSCM,
    // which will cache the IIS WindowStation\Desktop in the Resolver
    hr = InitComSecurity();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Revert back to the service winsta\desktop
    hr = RevertToServiceDesktopWinsta();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Initalize ABO
    // This should happen before any other pieces
    // of code attempt to use the metabase.
    hr = InitComAdmindata();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize ABO 0x%08x\n",
                    hr ));
        goto Cleanup;
    }

    //
    // Initialize IIS metabase writer.
    //
    hr = InitializeMDWriter( &hMDWriterThread );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize IIS metabase writer %x\n",
                    hr ));
        goto Cleanup;
    }

    // if this is a dc then wait for it to be ready before starting extensions
    // the reason for this is that the svcext.dll will try to create a user accounts
    // but it cannot do this on a dc, unless the dc is ready.
    //
    // this is also needed in the case where this is not a DC.
    // when a replica DC gets demoted, the server will restart
    // as a server not a DC and the create user/sync iwam stuff
    // needs to run and can timeout the SCM
    g_hSCMNotifyEvent = IIS_CREATE_EVENT( "g_hSCMNotifyEvent",
                                          &g_hSCMNotifyEvent,
                                          TRUE,                        // fManualReset
                                          FALSE );                     // fInitialState

    if( g_hSCMNotifyEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // start up thread to let scm know we are still alive
    // the StartServiceExtensions() function will take longer than
    // usual on a domain controlller
    bTempFlag = StartThread( SCMNotifyThread, &g_hSCMNotifyThread );

    hr = StartServiceExtensions();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }


    if (bTempFlag)
    {
        if ( g_hSCMNotifyThread != NULL )
        {
            if(g_hSCMNotifyEvent)
            {
                SetEvent(g_hSCMNotifyEvent);
            }

            dwWait = WaitForSingleObject(g_hSCMNotifyThread,10000);
            if ( dwWait != WAIT_OBJECT_0 )
            {
                IIS_PRINTF((buff, "Wait for SCMNotifyThread death returns %d[err %d]\n",err, GetLastError()));
            }
            CloseHandle(g_hSCMNotifyThread);
            g_hSCMNotifyThread = NULL;
        }
        bTempFlag = FALSE;
    }

    StartUpIndicateClientActivity();
    RegisterServiceExtensionCLSIDs();

    //
    // Start service RPC listening
    //
    if( pGlobalData != NULL )
    {
        rpcStatus = pGlobalData->StartRpcServerListen();
        if( rpcStatus != RPC_S_OK )
        {
            hr = HRESULT_FROM_WIN32( rpcStatus );
            goto Cleanup;
        }
    }

    //
    //  Update the service status.
    //  it is officially running now.
    //
    err = UpdateServiceStatus( SERVICE_RUNNING,
                               NO_ERROR,
                               S_OK,
                               0,
                               0 );

    if( err != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto Cleanup;
    }

    //
    //  Wait for the shutdown event.
    //

    err = WaitForSingleObject( g_hShutdownEvent,
                               INFINITE );

    if ( err != WAIT_OBJECT_0 )
    {
        //
        // Error. Unable to wait for single object.
        //
    }

    //
    //  Stop time.  Tell the Service Controller that we're stopping,
    //  then terminate the various service components.
    //

    err = UpdateServiceStatus( SERVICE_STOP_PENDING,
                               NO_ERROR,
                               S_OK,
                               1,
                               SERVICE_STOP_WAIT_HINT );

    if ( err != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32(err);
        //
        //  The event has already been logged.
        //
    }

    //
    //  Now setup a timer callback function that will tell
    //  the service we are still stopping.  Note, the COM
    //  thread will all ready be stopping too, but it won't
    //  setup the callback function.  Since both this routine
    //  and the com thread routine must finish before the
    //  timer is cancelled, it is fine that we just create it
    //  here.
    //

    DBG_ASSERT ( hShutdownCallbackTimer == NULL );

    if ( !CreateTimerQueueTimer( &hShutdownCallbackTimer,
                                 NULL,                      // handle to timer queue, use default queue
                                 &ShutdownCallback,
                                 NULL,
                                 SERVICE_UPDATE_STATUS,
                                 SERVICE_UPDATE_STATUS,
                                 WT_EXECUTEINIOTHREAD) )
    {
        //
        // Spew out that there was an error, but don't propogate
        // the error, we should still try and shutdown.
        //
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create the timer queue for shutdown %x\n",
                    HRESULT_FROM_WIN32(GetLastError()) ));
    }


Cleanup:

    //
    // Stop service RPC listening
    //
    if( pGlobalData != NULL )
    {
        pGlobalData->StopRpcServerListen();
    }

    StopServiceExtensions();

    //
    // Terminate IIS metabase wirter
    //
    if( hMDWriterThread != NULL )
    {
        TerminateMDWriter( hMDWriterThread );

        CloseHandle( hMDWriterThread );
        hMDWriterThread = NULL;
    }

    // This will only terminate the metabase if
    // it was initialized in the first place.
    TerminateComAdmindata();

    TerminateIISRTL();

    if ( fComInitialized )
    {
        CoUninitialize();
    }

    // Close the IIS windows station and desktop
    ShutdownDesktopWinsta();

    //
    // Now tell the SCM that we have shutdown the service
    // and mean it!!
    //
    if ( g_hsvcStatus != NULL_SERVICE_STATUS_HANDLE )
    {
        DWORD           ExitErr = NO_ERROR;

        //
        // Setup the error codes as they will be reported back
        // to the SCM.
        //
        if ( FAILED ( hr ) )
        {
            if ( HRESULT_FACILITY( hr ) == FACILITY_WIN32 )
            {
                ExitErr = HRESULT_CODE ( hr );
            }
            else
            {
                ExitErr = ERROR_SERVICE_SPECIFIC_ERROR;
            }
        }

        //
        // If the shutdown timer is still in play we need to
        // shut it down before we start the service.  Note that
        // we should never have both timers running at the same
        // time.
        //
        if ( hShutdownCallbackTimer )
        {
            //
            // Ping the server for more time, so we know we will
            // have enough time to shutdown the callback timer before
            // we end the service.
            //
            UpdateServiceStatus( SERVICE_STOP_PENDING,
                                 NO_ERROR,
                                 S_OK,
                                 g_svcStatus.dwCheckPoint + 1,
                                 SERVICE_STOP_WAIT_HINT );

            //
            // Stop the callback function.
            //
            if ( !DeleteTimerQueueTimer( NULL,
                                         hShutdownCallbackTimer,
                                         INVALID_HANDLE_VALUE ) )
            {
                //
                // Spew out that there was an error, but don't propogate
                // the error, we should still try and shutdown.
                //

                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to delete the timer queue for shutdown %x\n",
                            HRESULT_FROM_WIN32(GetLastError()) ));

            }

            hShutdownCallbackTimer = NULL;
        }

        //
        // Now let SCM know that we are done.
        //
        UpdateServiceStatus( SERVICE_STOPPED,
                             ExitErr,
                             hr,
                             0,
                             0 );
    }

} // ServiceEntry()


/***************************************************************************++

Routine Description:

    Checks the registry to see if there is an override set for the
    iisadmin startup time limit.  If there is we use that value, if there
    is not we will use the default 3 minutes.

Arguments:

    None.

Return Value:

    DWORD - time to tell scm to wait for our startup.

--***************************************************************************/
DWORD
GetStartupWaitHint(VOID)
{
    HKEY    hKey;
    DWORD   dwType;
    DWORD   cbData;
    DWORD   dwWaitHint;
    DWORD   dwActualWaitHint = SERVICE_START_WAIT_HINT;

    //
    // Read the registry key to see if we are trying to
    // override the startup wait hint limit.  If there are
    // any problems just return the default.
    //
    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        IISADMIN_SVC_KEY,
                        0,
                        KEY_QUERY_VALUE,
                        &hKey ) )
    {
        cbData = sizeof( DWORD );

        if( !RegQueryValueEx( hKey,
                              IISADMIN_STARTUP_WAITHINT_VALUE,
                              NULL,
                              &dwType,
                              ( LPBYTE )&dwWaitHint,
                              &cbData ) )
        {
            if( dwType == REG_DWORD && dwWaitHint != 0 )
            {
                dwActualWaitHint = dwWaitHint;
            }
        }

        RegCloseKey( hKey );
    }

    return dwActualWaitHint;
}

VOID
StartUpIndicateClientActivity(VOID)
{
    if (g_svcStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        UpdateServiceStatus( SERVICE_START_PENDING,
                             0,
                             0,
                             g_svcStatus.dwCheckPoint + 1,
                             GetStartupWaitHint());
    }
}

DWORD
SCMNotifyThread(
    PVOID               pv)
{
    DWORD               dwWaitReturn = WAIT_TIMEOUT;
    BOOL                bInitSucceeded = FALSE;
    DWORD               dwCount = 0;
    PTHREAD_PARAMS      ptpParams = (PTHREAD_PARAMS)pv;
    const DWORD         dwMaxTime = 1000 * 60 * 3; // max wait is 3 minutes
    const DWORD         dwTimeOut = 10000; // check every 10 seconds

    bInitSucceeded = ptpParams->bInitSuccess = TRUE;
    SetEvent(ptpParams->hInitEvent);

    do
    {
        // tell SCM we're still alive
        StartUpIndicateClientActivity();

        // wait 10 seconds
        dwWaitReturn = WaitForSingleObject(g_hSCMNotifyEvent,dwTimeOut);
        dwCount=dwCount+dwTimeOut;
    }
    while ( (dwWaitReturn != WAIT_OBJECT_0) && dwCount < dwMaxTime );

    return 0;
}

/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\mdadmin\ntsec.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1996-1997 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: NTSec.h

Owner: AndrewS

This file contains includes related to NT security on WinSta's and Desktops
===================================================================*/

#ifndef __NTSec_h
#define __NTSec_h

// Local Defines
// Note: These names are not hard to find, but COM+ uses them, so we cannot change to generated unique names.
#define SZ_IIS_WINSTA   "__X78B95_89_IW"
#define SZ_IIS_DESKTOP  "__A8D9S1_42_ID"

#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ALL  (WINSTA_ENUMDESKTOPS     | WINSTA_READATTRIBUTES    | \
                     WINSTA_ACCESSCLIPBOARD  | WINSTA_CREATEDESKTOP     | \
                     WINSTA_WRITEATTRIBUTES  | WINSTA_ACCESSGLOBALATOMS | \
                     WINSTA_EXITWINDOWS      | WINSTA_ENUMERATE         | \
                     WINSTA_READSCREEN       | \
                     STANDARD_RIGHTS_REQUIRED)

#define WINSTA_DESIRED (WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ENUMERATE | STANDARD_RIGHTS_READ | WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS)

#define DESKTOP_DESIRED (DESKTOP_READOBJECTS | DESKTOP_ENUMERATE | STANDARD_RIGHTS_READ | DESKTOP_WRITEOBJECTS | DESKTOP_CREATEWINDOW | DESKTOP_SWITCHDESKTOP)

HRESULT InitDesktopWinsta(VOID);
HRESULT RevertToServiceDesktopWinsta(VOID);
HRESULT InitComSecurity(VOID);
HRESULT ShutdownDesktopWinsta(VOID);

#endif //__NTSec_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#endif

#include <nntptype.h>
#include <nntpapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\mdadmin\ntsec.cxx ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1996-1997 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: NTSec.cxx

Owner: AndrewS

This file contains code related to NT security on WinSta's and Desktops
===================================================================*/
#include <windows.h>

#include <aclapi.h>

#include <dbgutil.h>
#include <apiutil.h>
#include <loadadm.hxx>
#include <ole2.h>
#include <inetsvcs.h>
#include "ntsec.h"

// Globals
HWINSTA                 g_hWinSta = NULL;
HDESK                   g_hDesktop = NULL;
HWINSTA                 g_hWinStaPrev = NULL;
HDESK                   g_hDesktopPrev = NULL;

HRESULT AllocateAndCreateWellKnownSid(
    WELL_KNOWN_SID_TYPE SidType,
    PSID                *ppSid);

VOID
FreeWellKnownSid(
    PSID* ppSid
    );

HRESULT
AllocateAndCreateWellKnownAcl(
    DWORD nSidCount,
    WELL_KNOWN_SID_TYPE SidType[],
    ACCESS_MASK AccessMask[],
    BOOL  fAccessAllowedAcl,
    PACL* ppAcl,
    DWORD* pcbAcl
    );

VOID
FreeWellKnownAcl(
    PACL* ppAcl
    );

/*===================================================================
InitDesktopWinsta

Create a desktop and a winstation for IIS to use

Parameters:

Returns:
    HRESULT     S_OK on success

Side effects
    Sets global variables
    Sets the process WindowStation and thread Desktop to the IIS
===================================================================*/
HRESULT
InitDesktopWinsta(VOID)
{
    HRESULT             hr = S_OK;
    DWORD               dwErr;
    HWINSTA             hWinSta = NULL;
    HDESK               hDesktop = NULL;
    HWINSTA             hWinStaPrev = NULL;
    HDESK               hDesktopPrev = NULL;
    SECURITY_ATTRIBUTES Sa;
    SECURITY_DESCRIPTOR Sd;
    PACL                pWinstaAcl = NULL;
    PACL                pDesktopAcl = NULL;
    DWORD               cbAcl;
    WELL_KNOWN_SID_TYPE SidType[2];
    ACCESS_MASK         AccessMask[2];

    SidType[0] = WinBuiltinAdministratorsSid;
    AccessMask[0] = WINSTA_ALL;
    SidType[1] = WinWorldSid;
    AccessMask[1] = WINSTA_DESIRED;
    hr = AllocateAndCreateWellKnownAcl( 2,
                                        SidType,
                                        AccessMask,
                                        TRUE,
                                        &pWinstaAcl,
                                        &cbAcl );
    if ( FAILED(hr) )
    {
        goto exit;
    }

    if ( !InitializeSecurityDescriptor( &Sd, SECURITY_DESCRIPTOR_REVISION ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    if ( !SetSecurityDescriptorDacl( &Sd, TRUE, pWinstaAcl, FALSE ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    Sa.nLength = sizeof(Sa);
    Sa.lpSecurityDescriptor = &Sd;
    Sa.bInheritHandle = FALSE;

    // Save our old desktop so we can restore it later
    hDesktopPrev = GetThreadDesktop( GetCurrentThreadId() );
    if ( hDesktopPrev == NULL )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Save our old window station so we can restore it later
    hWinStaPrev = GetProcessWindowStation();
    if ( hWinStaPrev == NULL )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Create a winsta for IIS to use
    hWinSta = CreateWindowStation( SZ_IIS_WINSTA, 0, WINSTA_ALL, &Sa );
    if ( hWinSta == NULL )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Set this as IIS's window station
    if ( !SetProcessWindowStation( hWinSta ) )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }


    SidType[0] = WinBuiltinAdministratorsSid;
    AccessMask[0] = DESKTOP_ALL;
    SidType[1] = WinWorldSid;
    AccessMask[1] = DESKTOP_DESIRED;
    hr = AllocateAndCreateWellKnownAcl( 2,
                                        SidType,
                                        AccessMask,
                                        TRUE,
                                        &pDesktopAcl,
                                        &cbAcl );
    if ( FAILED(hr) )
    {
        goto exit;
    }

    if ( !InitializeSecurityDescriptor( &Sd, SECURITY_DESCRIPTOR_REVISION ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    if ( !SetSecurityDescriptorDacl( &Sd, TRUE, pDesktopAcl, FALSE ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    Sa.nLength = sizeof(Sa);
    Sa.lpSecurityDescriptor = &Sd;
    Sa.bInheritHandle = FALSE;

    // Create a desktop for IIS to use
    hDesktop = CreateDesktop( SZ_IIS_DESKTOP, NULL, NULL, 0, DESKTOP_ALL, &Sa );
    if ( hDesktop == NULL )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Set the desktop
    if ( !SetThreadDesktop( hDesktop ) )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // store these handles in the globals
    g_hWinSta = hWinSta;
    g_hDesktop = hDesktop;
    g_hWinStaPrev = hWinStaPrev;
    g_hDesktopPrev = hDesktopPrev;
    hWinSta = NULL;
    hDesktop = NULL;
    hWinStaPrev = NULL;
    hDesktopPrev = NULL;

exit:
    if ( FAILED( hr ) )
    {
        DBG_ASSERT( g_hWinSta == NULL );
        DBG_ASSERT( g_hDesktop == NULL );
        DBG_ASSERT( g_hWinStaPrev == NULL );
        DBG_ASSERT( g_hDesktopPrev == NULL );

        if ( hWinStaPrev != NULL )
        {
            SetProcessWindowStation( hWinStaPrev );
        }
        if ( hDesktopPrev != NULL )
        {
            SetThreadDesktop( hDesktopPrev );
        }
    }
    else
    {
        DBG_ASSERT( g_hWinSta != NULL );
        DBG_ASSERT( g_hDesktop != NULL );
        DBG_ASSERT( g_hWinStaPrev != NULL );
        DBG_ASSERT( g_hDesktopPrev != NULL );
        DBG_ASSERT( hWinSta == NULL );
        DBG_ASSERT( hDesktop == NULL );
        DBG_ASSERT( hWinStaPrev == NULL );
        DBG_ASSERT( hDesktopPrev == NULL );
    }

    FreeWellKnownAcl( &pWinstaAcl );
    FreeWellKnownAcl( &pDesktopAcl );
    if ( hDesktop != NULL )
    {
        CloseDesktop( hDesktop );
        hDesktop = NULL;
    }
    if ( hWinSta != NULL )
    {
        CloseWindowStation( hWinSta );
        hWinSta = NULL;
    }
    if ( hDesktopPrev!= NULL )
    {
        CloseDesktop( hDesktopPrev );
        hDesktopPrev = NULL;
    }
    if ( hWinStaPrev != NULL )
    {
        CloseWindowStation( hWinStaPrev );
        hWinStaPrev = NULL;
    }

    return hr;
}

/*===================================================================
RevertToServiceDesktopWinsta

Set the process WindowStation and the thread Desktop to the default
service WindowStation\Desktop.
To be called after COM is initialized and cached the IIS WindowStation\Desktop

Parameters:

Returns:
    HRESULT     S_OK on success
                E_*  on failure

Side effects
    Reverst back the process WindowStation and thread Desktop
===================================================================*/
HRESULT
RevertToServiceDesktopWinsta(VOID)
{
    HRESULT             hr = S_OK;
    DWORD               dwErr;

    // This functions should be called only if InitDesktopWinsta succeeded
    DBG_ASSERT( g_hWinStaPrev != NULL );
    DBG_ASSERT( g_hDesktopPrev != NULL );

    if ( ( g_hWinStaPrev == NULL ) || ( g_hDesktopPrev == NULL ) )
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the old window station
    if ( !SetProcessWindowStation( g_hWinStaPrev ) )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Set the old desktop
    if ( !SetThreadDesktop( g_hDesktopPrev ) )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

exit:
    return hr;
}


/*===================================================================
ShutdownDesktopWinsta

Closes the IIS window station and desktop

Parameters:

Returns:
    HRESULT     S_OK on success
                E_*  on failure
    In all cases will try to restore the window station and desktop
    and will close and zero out the global handles

Side effects
    Sets global variables
===================================================================*/
HRESULT
ShutdownDesktopWinsta(VOID)
{
    HRESULT             hr = S_OK;
    DWORD               dwErr;
    HWINSTA             hWinSta = NULL;
    HDESK               hDesktop = NULL;
    HWINSTA             hWinStaPrev = NULL;
    HDESK               hDesktopPrev = NULL;

    // get these handles from the globals
    hWinSta = g_hWinSta;
    hDesktop = g_hDesktop;
    hWinStaPrev = g_hWinStaPrev;
    hDesktopPrev = g_hDesktopPrev;
    g_hWinSta = NULL;
    g_hDesktop = NULL;
    g_hWinStaPrev = NULL;
    g_hDesktopPrev = NULL;

    // Set the old window station
    if ( hWinStaPrev != NULL )
    {
        if ( !SetProcessWindowStation( hWinStaPrev ) )
        {
            // If not failed already save the failure
            if ( SUCCEEDED( hr ) )
            {
                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32( dwErr );
            }
            // Continue cleanup even on failure
        }
    }
    else
    {
        // If not failed already save the failure
        if ( SUCCEEDED( hr ) )
        {
            hr = E_FAIL;
        }
        // Continue cleanup even on failure
    }

    // Set the old desktop
    if ( hDesktopPrev!= NULL )
    {
        if ( !SetThreadDesktop( hDesktopPrev ) )
        {
            // If not failed already save the failure
            if ( SUCCEEDED( hr ) )
            {
                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32( dwErr );
            }
            // Continue cleanup even on failure
        }
    }
    else
    {
        // If not failed already save the failure
        if ( SUCCEEDED( hr ) )
        {
            hr = E_FAIL;
        }
        // Continue cleanup even on failure
    }

    if ( hDesktopPrev!= NULL )
    {
        CloseDesktop( hDesktopPrev );
        hDesktopPrev = NULL;
    }

    if ( hWinStaPrev != NULL )
    {
        CloseWindowStation( hWinStaPrev );
        hWinStaPrev = NULL;
    }

    if ( hDesktop != NULL )
    {
        CloseDesktop( hDesktop );
        hDesktop = NULL;
    }
    else
    {
        // If not failed already save the failure
        if ( SUCCEEDED( hr ) )
        {
            hr = E_UNEXPECTED;
        }
        // Continue cleanup even on failure
    }

    if ( hWinSta != NULL )
    {
        CloseWindowStation( hWinSta );
        hWinSta = NULL;
    }
    else
    {
        // If not failed already save the failure
        if ( SUCCEEDED( hr ) )
        {
            hr = E_UNEXPECTED;
        }
        // Continue cleanup even on failure
    }

    DBG_ASSERT( g_hWinSta == NULL );
    DBG_ASSERT( g_hDesktop == NULL );
    DBG_ASSERT( g_hWinStaPrev == NULL );
    DBG_ASSERT( g_hDesktopPrev == NULL );
    DBG_ASSERT( hWinSta == NULL );
    DBG_ASSERT( hDesktop == NULL );
    DBG_ASSERT( hWinStaPrev == NULL );
    DBG_ASSERT( hDesktopPrev == NULL );

    return hr;
}

/*===================================================================
InitComSecurity

Setup for and call CoInitializeSecurity. This will avoid problems with
DCOM security on sites that have no default security.

Parameters:
    None

Returns:
    HRESULT

    Debug -- DBG_ASSERTs on error and returns error code

Side effects:
    Sets desktop
===================================================================*/
HRESULT
InitComSecurity(VOID)
{
    HRESULT             hr = NOERROR;
    DWORD               dwErr;
    BOOL                fRet;
    SECURITY_DESCRIPTOR SecurityDesc = {0};
    EXPLICIT_ACCESS     ea = {0};
    ACL                 *pAcl = NULL;
    PSID                pSidAdmins = NULL;
    PSID                pSidAuthUser = NULL;

    // Initialize the security descriptor
    fRet = InitializeSecurityDescriptor( &SecurityDesc, SECURITY_DESCRIPTOR_REVISION );
    if ( !fRet )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Create SID for AuthenticatedUsers
    hr = AllocateAndCreateWellKnownSid( WinAuthenticatedUserSid, &pSidAuthUser );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    DBG_ASSERT( pSidAuthUser != NULL );

    // Create SID for Administrators
    hr = AllocateAndCreateWellKnownSid( WinBuiltinAdministratorsSid, &pSidAdmins );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    DBG_ASSERT( pSidAdmins != NULL );

    // Setup AuthenticatedUsers for COM access.
    ea.grfAccessPermissions = COM_RIGHTS_EXECUTE;
    ea.grfAccessMode = SET_ACCESS;
    ea.grfInheritance = NO_INHERITANCE;
    ea.Trustee.pMultipleTrustee = NULL;
    ea.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName = (LPSTR)pSidAuthUser;

    // Create new ACL with this ACE.
    dwErr = SetEntriesInAcl( 1, &ea, NULL, &pAcl );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }
    DBG_ASSERT( pAcl != NULL );

    // Set the security descriptor owner to Administrators
    fRet = SetSecurityDescriptorOwner( &SecurityDesc, pSidAdmins, FALSE);
    if ( !fRet )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Set the security descriptor group to Administrators
    fRet = SetSecurityDescriptorGroup( &SecurityDesc, pSidAdmins, FALSE);
    if ( !fRet )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Set the ACL to the security descriptor.
    fRet = SetSecurityDescriptorDacl( &SecurityDesc, TRUE, pAcl, FALSE );
    if ( !fRet )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    hr = CoInitializeSecurity( &SecurityDesc,
                               -1,
                               NULL,
                               NULL,
                               RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                               RPC_C_IMP_LEVEL_IDENTIFY,
                               NULL,
                               EOAC_DYNAMIC_CLOAKING | EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL,
                               NULL );
    if( FAILED( hr ) )
    {
        // This may fire if CoInitializeSecurity fails. So it is probably
        // overactive we would have let the CoInitializeSecurity call fail
        // in the past, before some PREFIX changes.
        DBG_ASSERT( SUCCEEDED( hr ) );

        DBGERROR(( DBG_CONTEXT,
                   "CoInitializeSecurity failed running with default "
                   "DCOM security settings, hr=%8x\n",
                   hr ));
    }

exit:
    if ( pSidAdmins != NULL )
    {
        LocalFree( pSidAdmins );
        pSidAdmins = NULL;
    }
    if ( pSidAuthUser != NULL )
    {
        LocalFree( pSidAuthUser );
        pSidAuthUser = NULL;
    }
    if ( pAcl != NULL )
    {
        LocalFree( pAcl );
        pAcl = NULL;
    }

    return (hr);
}

/***************************************************************************++
Routine Description:
    Figures out how much memory is needed and allocates the memory
    then requests the well known sid to be copied into the memory.  If
    all goes well then the SID is returned, if anything fails the
    SID is not returned.

    The allocated memory must be freed by the caller with LocalFree

Arguments:
    WELL_KNOWN_SID_TYPE SidType = Enum value for the SID being requested.
    PSID* ppSid = Ptr to the pSid that is returned.

Return Value:
    HRESULT.
--***************************************************************************/
HRESULT
AllocateAndCreateWellKnownSid(
    WELL_KNOWN_SID_TYPE SidType,
    PSID                *ppSid)
{
    HRESULT             hr = S_OK;
    DWORD               dwErr;
    BOOL                fRet;
    PSID                pSid  = NULL;
    DWORD               cbSid = SECURITY_MAX_SID_SIZE;

    DBG_ASSERT ( ( ppSid != NULL ) && ( *ppSid == NULL ) );

    // Check args
    if ( ( ppSid == NULL ) || ( *ppSid != NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // At this point we know the size of the sid to allocate.
    pSid = (PSID)LocalAlloc( LPTR, cbSid );
    if ( pSid == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Ok now we can get the SID
    fRet = CreateWellKnownSid( SidType, NULL, pSid, &cbSid );
    if ( !fRet )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // Return
    *ppSid = pSid;
    // Don't free
    pSid = NULL;

exit:
    // Cleanup
    FreeWellKnownSid( &pSid );

    return hr;
}

/***************************************************************************++

Routine Description:

    Frees memory that was allocated by the
    AllocateAndCreateWellKnownSid function.

Arguments:

    PSID* ppSid = Ptr to the pointer to be freed and set to NULL.

Return Value:

    VOID.

--***************************************************************************/
VOID
FreeWellKnownSid(
    PSID* ppSid
    )
{
    DBG_ASSERT ( ppSid );

    if ( *ppSid != NULL )
    {
        LocalFree ( *ppSid );
        *ppSid = NULL;
    }
}

/***************************************************************************++

Routine Description:

    Routine will create an acl for a well known sid and return it.
    It allocates all the memory so you don't have to.  But you do have to
    call FreeWellKnownAcl to free the memory.

    It also returns the size of memory allocated.


Arguments:

    WELL_KNOWN_SID_TYPE SidType = Enum value for the SID being requested.
    BOOL  fAccessAllowedAcl = Is this an allow or deny acl.
    PACL* ppAcl = the acl beign returned
    DWORD* pcbAcl = count of bytes in the acl being returned
    ACCESS_MASK AccessMask = the access mask that is being allowed or denied

Return Value:

    DWORD - Win32 Status Code.

  Note:  This code was writen to provide ACL's for COM interfaces but
         is not in use yet.  However, it may be useful when fix the acl'ing
         for the IISRESET interface as well as the WAS interface so I am leaving
         it in.

--***************************************************************************/
HRESULT
AllocateAndCreateWellKnownAcl(
    DWORD nSidCount,
    WELL_KNOWN_SID_TYPE SidType[],
    ACCESS_MASK AccessMask[],
    BOOL fAccessAllowedAcl,
    PACL* ppAcl,
    DWORD* pcbAcl
    )
{
    HRESULT hr = S_OK;
    PSID  pSid = NULL;
    DWORD dwSizeOfAcl = sizeof( ACL );
    PACL pAcl = NULL;

    DBG_ASSERT ( ppAcl != NULL && *ppAcl == NULL );
    DBG_ASSERT ( pcbAcl != NULL );

    if ( ppAcl == NULL ||
         *ppAcl != NULL ||
         pcbAcl == NULL )
    {
        return E_INVALIDARG;
    }

    *pcbAcl = 0;

    //
    // Figure out the side of the ACL to create.
    //

    // It all ready has the size of the ACl from above.
    // add in the size of the ace.
    if ( fAccessAllowedAcl )
    {
        ACCESS_ALLOWED_ACE a;
        dwSizeOfAcl = dwSizeOfAcl + nSidCount * (SECURITY_MAX_SID_SIZE + sizeof(a) - sizeof(a.SidStart));
    }
    else
    {
        ACCESS_DENIED_ACE d;
        dwSizeOfAcl = dwSizeOfAcl + nSidCount * (SECURITY_MAX_SID_SIZE + sizeof(d) - sizeof(d.SidStart));
    }

    // Now create enough space for all.
    pAcl = (PACL)LocalAlloc(LPTR, dwSizeOfAcl);
    if ( pAcl == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Now initalize the ACL.
    if ( !InitializeAcl ( pAcl, dwSizeOfAcl, ACL_REVISION ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    for (DWORD i=0; i<nSidCount; i++)
    {
        //
        // Create the sid
        //
        hr = AllocateAndCreateWellKnownSid ( SidType[i], &pSid );
        if ( FAILED(hr) )
        {
            goto exit;
        }


        // Now add an acl of the appropriate type.
        if ( fAccessAllowedAcl )
        {
            if ( !AddAccessAllowedAce( pAcl, ACL_REVISION,
                                       AccessMask[i], pSid ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
        }
        else
        {
            if ( !AddAccessDeniedAce( pAcl, ACL_REVISION,
                                      AccessMask[i], pSid ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
        }

        FreeWellKnownSid( &pSid );
    }


    // if we make it here then we have succeeded in creating the
    // acl, and we will be returning it out.

    *ppAcl = pAcl;
    *pcbAcl = dwSizeOfAcl;


exit:

    //
    // No matter what, we need to free the original sid that
    // was created for us.
    //
    FreeWellKnownSid( &pSid );

    //
    // If we are not returning the acl out
    // then we need to free any memory we created.
    //
    if ( *ppAcl == NULL )
    {
        FreeWellKnownAcl ( &pAcl );
    }

    return hr;
}

/***************************************************************************++

Routine Description:

    Frees memory that was allocated by the
    AllocateAndCreateWellKnownAcl function.

Arguments:

    PACL* ppAcl = Ptr to the pointer to be freed and set to NULL.

Return Value:

    VOID.

--***************************************************************************/
VOID
FreeWellKnownAcl(
    PACL* ppAcl
    )
{
    DBG_ASSERT ( ppAcl );

    if ( *ppAcl != NULL )
    {
        LocalFree ( *ppAcl );
        *ppAcl = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntp.inc ===
# Global settings for NNTP subprojects

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

!INCLUDE $(IISBASEDIR)\staxinc\build\paths.inc

STAXNNTP=$(STAXBASE)\nntp
STAXNNTPTARGET=$(STAXNNTP)\$(_OBJ_DIR)
STAXNNTPLIBPATH=$(STAXNNTPTARGET)\$(TARGET_DIRECTORY)

# Hack to create the lib directory
!if [mkdir $(STAXNNTPTARGET)\$(TARGET_DIRECTORY)]
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\admin.cpp ===
// admin.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"
#include "cmultisz.h"

#include "metautil.h"
#include "metakey.h"

#include "admin.h"
#include "version.h"

#define NNTP_DEF_SERVICE_VERSION	( 0 )

#define	DEFAULT_SERVER_BINDINGS		_T(":119:\0")
#define	DEFAULT_SECURE_BINDINGS		_T(":563:\0")

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Admin.1")
#define THIS_FILE_IID				IID_INntpAdmin

//
//	Metabase key strings used by CreateNewInstance:
//

const WCHAR * g_cszFeeds			= _T("Feeds");
const WCHAR * g_cszExpires			= _T("Expires");
const WCHAR * g_cszRoot				= _T("Root");
const WCHAR * g_cszBindingPoints	= _T("BindingPoints");
const WCHAR * g_cszDDropCLSID		= _T("{8b4316f4-af73-11d0-b0ba-00aa00c148be}");
const WCHAR * g_cszBindings			= _T("Bindings");
const WCHAR * g_cszDDrop			= _T("ddrop");
const WCHAR * g_cszDescription		= _T("Description");
const WCHAR * g_cszPriority			= _T("Priority");
const WCHAR * g_cszProgID			= _T("ProgID");
const WCHAR * g_cszDDropDescription	= _T("NNTP Directory Drop");
const WCHAR * g_cszDDropPriority	= _T("4");
const WCHAR * g_cszDDropProgID		= _T("DDropNNTP.Filter");

/////////////////////////////////////////////////////////////////////////////
//

CNntpAdmin::CNntpAdmin () :
	m_dwServiceVersion		( 0 ),
	m_dwServiceInstance		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );
}

CNntpAdmin::~CNntpAdmin ()
{
	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

STDMETHODIMP CNntpAdmin::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_INntpAdmin,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
STDMETHODIMP CNntpAdmin::get_ServiceAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpService>	pINntpService;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpService,
		IID_INntpService,
		&pINntpService,
		ppIDispatch
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpService->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}
*/

STDMETHODIMP CNntpAdmin::get_ServerAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpVirtualServer>	pINntpVirtualServer;
	CComBSTR strTemp = _T("");
	if (!strTemp) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpVirtualServer,
		IID_INntpVirtualServer,
		&pINntpVirtualServer,
		ppIDispatch
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpVirtualServer->put_Server ( m_strServer ? m_strServer : strTemp );
	if ( FAILED (hr) ) {
		goto Error;
	}

	hr = pINntpVirtualServer->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpVirtualServer
}

// Which service to configure:

STDMETHODIMP CNntpAdmin::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CNntpAdmin::put_Server ( BSTR strServer )
{
	return StdPropertyPutServerName ( &m_strServer, strServer );
}

STDMETHODIMP CNntpAdmin::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CNntpAdmin::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance );
}

// Versioning:

STDMETHODIMP CNntpAdmin::get_HighVersion ( long * plHighVersion )
{
	*plHighVersion = HIGH_VERSION;
	return NOERROR;
}

STDMETHODIMP CNntpAdmin::get_LowVersion ( long * plLowVersion )
{
	*plLowVersion = LOW_VERSION;
	return NOERROR;
}

STDMETHODIMP CNntpAdmin::get_BuildNum ( long * plBuildNumber )
{
	*plBuildNumber = CURRENT_BUILD_NUMBER;
	return NOERROR;
}

STDMETHODIMP CNntpAdmin::get_ServiceVersion ( long * plServiceVersion )
{
	*plServiceVersion = m_dwServiceVersion;
	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//	CNntpAdmin::EnumerateInstances
//
//	Description:
//
//		Returns a list of the virtual servers on the given machine.
//
//	Parameters:
//
//		ppsaInstances - Returned SAFEARRAY of instance IDs.
//			Must be freed by caller.
//		pErr - Error return code.
//
//	Returns:
//
//		Error code in *pErr.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::EnumerateInstances ( SAFEARRAY ** ppsaInstances)
{
	TraceFunctEnter ( "CNntpAdmin::EnumerateInstances" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;
	SAFEARRAY * 		psaEmpty	= NULL;
	SAFEARRAYBOUND		sabound[1];

	// Check parameters:
	_ASSERT ( ppsaInstances != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	if ( ppsaInstances == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameters:
	*ppsaInstances	= NULL;

	// Set the return array to an empty array:
	sabound[0].lLbound = 0;
	sabound[0].cElements = 0;

	psaEmpty = SafeArrayCreate ( VT_I4, 1, sabound );
	if ( psaEmpty == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	*ppsaInstances = psaEmpty;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Enumerate the instances:
	hr = QueryMetabaseInstances ( pMetabase, ppsaInstances );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	if ( FAILED(hr) ) {
		_VERIFY ( SUCCEEDED (SafeArrayDestroy ( psaEmpty )) );
		if (ppsaInstances)
		    *ppsaInstances	= NULL;
	}

	TRACE_HRESULT ( hr );
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdmin::EnumerateInstancesVariant ( SAFEARRAY ** ppsaInstances)
{
	TraceFunctEnter ( "CNntpAdmin::EnumerateInstancesVariant" );

	HRESULT			hr;
	SAFEARRAY	*	psaInstances	= NULL;

	hr = EnumerateInstances ( &psaInstances );
	BAIL_ON_FAILURE(hr);

	hr = LongArrayToVariantArray ( psaInstances, ppsaInstances );
	BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::CreateInstance
//
//	Description:
//
//		Creates a new NNTP virtual server on the given machine.
//
//	Parameters:
//
//		strNntpFileDirectory - Directory where all the hash files go.
//		strHomeDirectory - Path of the home directory vroot.
//		plInstanceId - The new virtual server ID.
//		pErr	- Resulting error code.
//
//	Returns:
//
//		Error condition in *pErr.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::CreateInstance (
	BSTR	strNntpFileDirectory,
	BSTR	strHomeDirectory,
    BSTR    strProgId,
    BSTR    strMdbGuid,
	long *	plInstanceId
	)
{
	TraceFunctEnter ( "CNntpAdmin::CreateInstance" );

	HRESULT					hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Check parameters:
	_ASSERT ( IS_VALID_STRING ( strNntpFileDirectory ) );
	_ASSERT ( IS_VALID_STRING ( strHomeDirectory ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	if ( !strNntpFileDirectory || !strHomeDirectory ) {
		FatalTrace ( 0, "Bad String Pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	if ( !plInstanceId ) {
		FatalTrace ( 0, "Bad return pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameter:
	*plInstanceId 	= 0;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Create a new instance:
	hr = CreateNewInstance (
		pMetabase,
		strNntpFileDirectory,
		strHomeDirectory,
        strProgId,
        strMdbGuid,
		plInstanceId
		);
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::DestroyInstance
//
//	Description:
//
//		Removes the given virtual server.
//
//	Parameters:
//
//		lInstanceId - The ID of the virtual server to delete.
//		pErr - Resulting error code.
//
//	Returns:
//
//		Error code in *pErr.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::DestroyInstance ( long lInstanceId )
{
	TraceFunctEnter ( "CNntpAdmin::DestroyInstance" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	if ( lInstanceId == 0 ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
		goto Exit;
	}

	if ( lInstanceId == 1 ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_CANT_DELETE_DEFAULT_INSTANCE );
		goto Exit;
	}

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Delete the instance:
	hr = DeleteInstance ( pMetabase, lInstanceId );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::ErrorToString
//
//	Description:
//
//		Translates an NNTP_ERROR_CODE to a readable string.
//
//	Parameters:
//
//		lErrorCode 	- Win32 error code.
//		pstrError	- the readable error string.
//
//	Returns:
//
//		The error string in *pstrError.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::ErrorToString ( long lErrorCode, BSTR * pstrError )
{
	TraceFunctEnter ( "CNntpAdmin::ErrorToString" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pstrError ) );

	HRESULT		hr = NOERROR;
	WCHAR		wszError [ 1024 ];

	if ( pstrError == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad return pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	Win32ErrorToString ( lErrorCode, wszError, 1024 );

	*pstrError = ::SysAllocString( wszError );

	if ( *pstrError == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::Tokenize
//
//	Description:
//
//		Makes the given string safe for HTML & Javascript
//
//	Parameters:
//
//		strIn - the input string
//		strOut - the resulting string with appropriate escape sequences.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::Tokenize ( BSTR strIn, BSTR * pstrOut )
{
	TraceFunctEnter ( "CNntpAdmin::Tokenize" );

	_ASSERT ( IS_VALID_STRING ( strIn ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	HRESULT		hr		= NOERROR;
	PWCHAR		pSrc	= strIn;
	PWCHAR		pSrcCur	= NULL;
	PWCHAR		pDstCur	= NULL;
	PWCHAR		pDst	= NULL;

	*pstrOut = NULL;

	pDst = new WCHAR [ 3 * lstrlen ( strIn ) + 1 ];
	if ( pDst == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    for ( pSrcCur = pSrc, pDstCur = pDst; *pSrcCur; pSrcCur++ ) {
        switch ( *pSrcCur ) {
            case L'\\':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'5';
                *(pDstCur++) = L'c';
                break;

            case L' ':
                *(pDstCur++) = L'+';
                break;

            case L':':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'3';
                *(pDstCur++) = L'a';
                break;

            case L'/':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'2';
                *(pDstCur++) = L'f';
                break;

            default:
                *(pDstCur++) = *pSrcCur;
        }
    }
    *pDstCur = L'\0';

	*pstrOut = ::SysAllocString ( pDst );
	if ( *pstrOut == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	delete pDst;

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::Truncate
//
//	Description:
//
//		Cuts off a string to a certain length using '...'
//
//	Parameters:
//
//		strIn 		- The input string.
//		cMaxChars	- The maximum characters allowed in the resulting string.
//		pstrOut		- The resulting (possibly truncated) string.
//
//	Returns:
//
//
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::Truncate ( BSTR strIn, long cMaxChars, BSTR * pstrOut )
{
	TraceFunctEnter ( "CNntpAdmin::Truncate" );

	PWCHAR	pSrc	= strIn;
	PWCHAR	pDst	= NULL;
	DWORD	cDst	= cMaxChars;
	HRESULT	hr		= NOERROR;

	*pstrOut = NULL;

    if ( wcslen( pSrc ) <= cDst ) {
        pDst = pSrc;
    } else {
        pDst = ::SysAllocStringLen( pSrc, cDst + 1 );
        if ( !pDst ) {
        	FatalTrace ( (LPARAM) this, "Out of memory" );
        	hr = E_OUTOFMEMORY;
        	goto Exit;
        }

        wcscpy( pDst + cDst - 3, L"..." );
    }

	*pstrOut = pDst;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::QueryMetabaseInstances
//
//	Description:
//
//		Retrieves the list of virtual servers from the metabase
//
//	Parameters:
//
//		pMetabase		- the metabase object
//		ppsaInstances	- resulting array of instance ids.
//		pErr			- resulting error code.
//
//	Returns:
//
//		Error code in *pErr.  If *pErr = 0 then an array of IDs in ppsaInstances.
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::QueryMetabaseInstances ( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CNntpAdmin::QueryMetabaseInstances" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeyNntp ( pMetabase );
	SAFEARRAY *		psaResult		= NULL;
	DWORD			cValidInstances	= 0;
	SAFEARRAYBOUND	rgsaBound[1];
	DWORD			i;
	WCHAR			wszName[ METADATA_MAX_NAME_LEN ];
	long			index[1];
	DWORD			dwInstance;

	hr = mkeyNntp.Open ( NNTP_MD_ROOT_PATH );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", hr );
		hr = HRESULT_FROM_WIN32 ( ERROR_SERVICE_DOES_NOT_EXIST );
		goto Exit;
	}

	//	pickup the service version number:
	hr = mkeyNntp.GetDword ( MD_NNTP_SERVICE_VERSION, &m_dwServiceVersion );
	if ( FAILED(hr) ) {
		m_dwServiceVersion	= NNTP_DEF_SERVICE_VERSION;
	}

	hr = mkeyNntp.GetIntegerChildCount ( &cValidInstances );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Allocate the array:
	rgsaBound[0].lLbound	= 0;
	rgsaBound[0].cElements	= cValidInstances;

	psaResult	= SafeArrayCreate ( VT_I4, 1, rgsaBound );

	if ( psaResult == NULL ) {
		FatalTrace ( 0, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	mkeyNntp.BeginChildEnumeration ();

	for ( i = 0; i < cValidInstances; i++ ) {
		hr = mkeyNntp.NextIntegerChild ( &dwInstance, wszName );
		_ASSERT ( SUCCEEDED(hr) );

		index[0]	= i;
		hr			= SafeArrayPutElement ( psaResult, index, &dwInstance );
		_ASSERT ( SUCCEEDED(hr) );
	}

	*ppsaInstances = psaResult;
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED (hr) ) {
		SafeArrayDestroy ( psaResult );
	}

	TraceFunctLeave ();
	return hr;
}

HRESULT WriteNntpFileLocation (
	CMetabaseKey * 	pmkeyNntp,
	LPCWSTR			wszSubkey,
	LPCWSTR			wszNntpFileDirectory,
	LPCWSTR			wszFilename,
	DWORD			mdValue
	)
{
	HRESULT		hr;
	WCHAR		wszFullPath	[ MAX_PATH ];

	if (wcslen( wszNntpFileDirectory )+1+wcslen( wszFilename )+1 > MAX_PATH )
		return HRESULT_FROM_WIN32 ( ERROR_FILENAME_EXCED_RANGE );
	wsprintf ( wszFullPath, _T("%s\\%s"), wszNntpFileDirectory, wszFilename );

	hr = pmkeyNntp->SetString ( wszSubkey, mdValue, wszFullPath );

	return hr;
}

//$-------------------------------------------------------------------
// CNntpAdmin::CreateVRoot
// 
// Description:
//  
//      Create a vroot for the new instance
//
// Parameters:
//
//      CMetabaseKey    &mkeyNntp   - The metabase key object
//      BSTR            strVPath    - The vroot path
//      BSTR            strProgId   - The prog id to identify vroot type
//      LPWSTR          wszKeyPath  - The key path to set values to
//
//  Returns:
//
//      HRESULT
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::CreateVRoot(    
    CMetabaseKey    &mkeyNntp,
    BSTR            strVPath,
    BSTR            strProgId,
    BSTR            strMdbGuid,
    LPWSTR          wszKeyPath
    )
{
    TraceFunctEnter( "CNntpAdmin::CreateVRoot" );

    HRESULT hr = S_OK;

	hr = mkeyNntp.SetString ( wszKeyPath, MD_KEY_TYPE, L"IIsNntpVirtualDir",  METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER);
	BAIL_ON_FAILURE(hr);

	hr = mkeyNntp.SetString ( wszKeyPath, MD_VR_PATH, strVPath );
	BAIL_ON_FAILURE(hr);

    if ( NULL == strProgId || *strProgId == 0 || _wcsicmp( strProgId, L"NNTP.FSPrepare" ) == 0 ) {
    
        //
        // File system driver case
        //
	    hr = mkeyNntp.SetString ( wszKeyPath, MD_FS_PROPERTY_PATH, strVPath );
	    BAIL_ON_FAILURE(hr);

	    if ( *strVPath == L'\\' && *(strVPath+1) == L'\\' ) {   // UNC
            hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_USE_ACCOUNT, 1 );
            BAIL_ON_FAILURE( hr );
        } else {    // regular file system
            hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_USE_ACCOUNT, 0 );
        }

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_DO_EXPIRE, 0 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_OWN_MODERATOR, 0 );
        BAIL_ON_FAILURE( hr );
    } else {

        //
        // Exchange store driver
        //
        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_USE_ACCOUNT, 0 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_DO_EXPIRE, 1 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_OWN_MODERATOR, 1 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetString( wszKeyPath, MD_EX_MDB_GUID, strMdbGuid );
        BAIL_ON_FAILURE( hr );

    }

	if (NULL == strProgId || *strProgId == 0) {
		hr = mkeyNntp.SetString ( wszKeyPath, MD_VR_DRIVER_PROGID, L"NNTP.FSPrepare" );
	} else {
    	hr = mkeyNntp.SetString ( wszKeyPath, MD_VR_DRIVER_PROGID, strProgId );
    }
    BAIL_ON_FAILURE(hr);

	hr = mkeyNntp.SetDword ( wszKeyPath, MD_ACCESS_PERM, MD_ACCESS_READ | MD_ACCESS_WRITE );
	BAIL_ON_FAILURE(hr);

Exit:

    TraceFunctLeave();
    return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::CreateNewInstance
//
//	Description:
//
//		Creates a new virtual server in the metabase.
//
//	Parameters:
//
//		pMetabase		- The metabase object
//		plInstanceId	- The new instance ID.
//		pErr			- The resulting error code
//
//	Returns:
//
//		Resulting error code in *pErr.  If *pErr = 0, then the new
//		ID in plInstanceId.
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::CreateNewInstance (
	IMSAdminBase *	pMetabase,
	BSTR			strNntpFileDirectory,
	BSTR			strHomeDirectory,
    BSTR            strProgId,
    BSTR            strMdbGuid,
	long * 			plInstanceId
	)
{
	TraceFunctEnter ( "CNntpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_IN_PARAM ( strNntpFileDirectory ) );
	_ASSERT ( IS_VALID_IN_PARAM ( strHomeDirectory ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeyNntp ( pMetabase );
	DWORD			dwInstance;
	WCHAR			wszInstance [ METADATA_MAX_NAME_LEN ];
	WCHAR			wszHomeDirKey [ METADATA_MAX_NAME_LEN ];
	WCHAR           wszSpecialDirKey[ METADATA_MAX_NAME_LEN ];
	WCHAR           wszSpecialDirectory[ MAX_PATH * 2 ];
	WCHAR			wszControlDirKey [ METADATA_MAX_NAME_LEN ];
	WCHAR           wszControlDirectory[ MAX_PATH * 2 ];
	WCHAR			wszBuf [ METADATA_MAX_NAME_LEN * 2 ];
    WCHAR           wszFeedTempDir [ MAX_PATH * 2 ];
    CMultiSz		mszBindings;
    DWORD           dwLen;

	// Zero the out parameter:
	*plInstanceId	= NULL;

	mszBindings			= DEFAULT_SERVER_BINDINGS;

	//
	//	Convert strings to ascii:
	//

	if (lstrlen(strNntpFileDirectory)+1>MAX_PATH)
	{ 
		HRESULT_FROM_WIN32 ( ERROR_FILENAME_EXCED_RANGE );
		goto Exit;
	}

	hr = mkeyNntp.Open ( NNTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", hr );
		goto Exit;
	}

	hr = mkeyNntp.CreateIntegerChild ( &dwInstance, wszInstance );
	if ( FAILED (hr) ) {
		goto Exit;
	}

    //
    //  Write out the subkeys of the instance key:
    //

	wsprintf ( wszBuf, _T("%s/%s"), wszInstance, g_cszFeeds );
	hr = mkeyNntp.CreateChild ( wszBuf );
    BAIL_ON_FAILURE ( hr );

    wsprintf ( wszFeedTempDir, _T("%s\\%s"), strNntpFileDirectory, _T("_temp.files_") );
    mkeyNntp.SetString ( wszBuf, MD_FEED_PEER_TEMP_DIRECTORY, wszFeedTempDir );
    BAIL_ON_FAILURE ( hr );

	wsprintf ( wszBuf, _T("%s/%s"), wszInstance, g_cszExpires );
	hr = mkeyNntp.CreateChild ( wszBuf );
    BAIL_ON_FAILURE ( hr );

	wsprintf ( wszHomeDirKey, _T("%s/%s"), wszInstance, g_cszRoot );
	hr = mkeyNntp.CreateChild ( wszHomeDirKey );
    BAIL_ON_FAILURE ( hr );

    //
    //  Set MD_KEY_TYPE for each key:
    //

    hr = mkeyNntp.SetString ( wszInstance, MD_KEY_TYPE, _T("IIsNntpServer"), METADATA_NO_ATTRIBUTES );
    BAIL_ON_FAILURE ( hr );

	hr = mkeyNntp.SetString ( wszHomeDirKey, MD_KEY_TYPE, _T("IIsNntpVirtualDir"), METADATA_NO_ATTRIBUTES );
	BAIL_ON_FAILURE(hr);

    //
    //  Write out the file locations:
    //

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("descrip.txt"),	MD_GROUP_HELP_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("group.lst"),	MD_GROUP_LIST_FILE );
    BAIL_ON_FAILURE(hr);

    hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("groupvar.lst"), MD_GROUPVAR_LIST_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("article.hsh"),	MD_ARTICLE_TABLE_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("history.hsh"),	MD_HISTORY_TABLE_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("moderatr.txt"),	MD_MODERATOR_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("xover.hsh"),	MD_XOVER_TABLE_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("pickup"),	MD_PICKUP_DIRECTORY );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("failedpickup"),	MD_FAILED_PICKUP_DIRECTORY );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("drop"),	MD_DROP_DIRECTORY );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("prettynm.txt"),	MD_PRETTYNAMES_FILE);
    BAIL_ON_FAILURE(hr);

    //
    //  Set the default vroot:
    //
    dwLen = wcslen( wszHomeDirKey );
    _ASSERT( dwLen > 0 );
    if ( dwLen == 0 ) hr = E_INVALIDARG;
    BAIL_ON_FAILURE(hr);
    hr = CreateVRoot(   mkeyNntp,
                        strHomeDirectory,
                        strProgId,
                        strMdbGuid,
                        wszHomeDirKey );
    BAIL_ON_FAILURE(hr);

    //
    //  Set the special vroots
    //
    if ( dwLen + wcslen(L"_slavegroup") >= METADATA_MAX_NAME_LEN - 2 ) 
        hr = HRESULT_FROM_WIN32( RPC_S_STRING_TOO_LONG );
    BAIL_ON_FAILURE(hr);
    if ( *(wszHomeDirKey + dwLen - 1 ) == L'/' ) *(wszHomeDirKey + dwLen - 1 ) = 0;
    wcscpy(wszControlDirKey, wszHomeDirKey);
    wcscat(wszControlDirKey, L"/control");
    wcscat( wszHomeDirKey, L"/_slavegroup" );

    //
    //  For the special _slavegroup vroot, we need to see if strProgId is "NNTP.ExDriverPrepare"
    //  If so, we need to re-calculate re-calculate wszSpecialDirectory as follow
    //
    if (_wcsicmp(L"NNTP.ExDriverPrepare", strProgId) == 0)
    {
        //  the default Vroot with the new instance is Exchange Vroot
        //  re-calculate wszSpecialDirectory
        wcscpy( wszSpecialDirectory, strNntpFileDirectory );
        dwLen = wcslen( wszSpecialDirectory );
        if ( dwLen > 0 && *(wszSpecialDirectory + dwLen - 1 ) == L'/' ) 
            *(wszSpecialDirectory + dwLen - 1 ) = 0;
        wcscpy(wszControlDirectory, wszSpecialDirectory);
        wcscat( wszControlDirectory, L"\\root\\control" );
        wcscat( wszSpecialDirectory, L"\\root\\_slavegroup" );
    }
    else
    {
        wcscpy( wszSpecialDirectory, strHomeDirectory );
        dwLen = wcslen( wszSpecialDirectory );
        if ( dwLen > 0 && *(wszSpecialDirectory + dwLen - 1 ) == L'/' ) 
            *(wszSpecialDirectory + dwLen - 1 ) = 0;
        wcscpy(wszControlDirectory, wszSpecialDirectory);
        wcscat( wszControlDirectory, L"\\control" );
        wcscat( wszSpecialDirectory, L"\\_slavegroup" );
    }

    hr = CreateVRoot(   mkeyNntp,
                        wszSpecialDirectory,
                        L"NNTP.FSPrepare",
                        NULL,
                        wszHomeDirKey );
    BAIL_ON_FAILURE(hr);

    //
    // Create the control groups on the file system
    //

    hr = CreateVRoot(   mkeyNntp,
                        wszControlDirectory,
                        L"NNTP.FSPrepare",
                        NULL,
                        wszControlDirKey );
    BAIL_ON_FAILURE(hr);

    
	//
	//	Write out the default bindings:
	//

	StdPutMetabaseProp ( &mkeyNntp, MD_SERVER_BINDINGS, &mszBindings, wszInstance );

    //
    //  Initialize the server state:
    //

    mkeyNntp.SetDword ( wszInstance, MD_SERVER_COMMAND, MD_SERVER_COMMAND_STOP );
    mkeyNntp.SetDword ( wszInstance, MD_SERVER_STATE, MD_SERVER_STATE_STOPPED );
    mkeyNntp.SetDword ( wszInstance, MD_SERVER_AUTOSTART, FALSE );
    mkeyNntp.SetDword ( wszInstance, MD_WIN32_ERROR, ERROR_SERVICE_REQUEST_TIMEOUT, METADATA_VOLATILE );

    //
    //  Save all the changes:
    //

	hr = mkeyNntp.Save ( );
    BAIL_ON_FAILURE(hr)

	mkeyNntp.Close ();

	//
	//	Now see if the service picked things up successfully:
	//

	DWORD	dwSleepTotal;
	DWORD	dwWin32Error;
	WCHAR	wszNewInstanceKey [ METADATA_MAX_NAME_LEN * 2 ];

	GetMDInstancePath ( wszNewInstanceKey, dwInstance );

	for ( dwWin32Error = ERROR_SERVICE_REQUEST_TIMEOUT, dwSleepTotal = 0; 
		dwWin32Error == ERROR_SERVICE_REQUEST_TIMEOUT && dwSleepTotal < MAX_SLEEP_INST;
		dwSleepTotal += SLEEP_INTERVAL
		) {

		HRESULT		hr2;

		Sleep ( SLEEP_INTERVAL );

		hr2 = mkeyNntp.Open ( wszNewInstanceKey );
		_ASSERT ( SUCCEEDED(hr2) );

		hr2 = mkeyNntp.GetDword ( MD_WIN32_ERROR, &dwWin32Error );
		_ASSERT ( SUCCEEDED(hr2) );
	}

	if ( dwWin32Error != NOERROR ) {
		HRESULT		hr2;

		//
		//	The service reported an error.
		//	Delete the new instance key
		//

		hr2 = mkeyNntp.Open ( NNTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );
		_ASSERT ( SUCCEEDED(hr2) );

		hr2 = mkeyNntp.DestroyChild ( wszInstance );
		_ASSERT ( SUCCEEDED(hr2) );

		hr2 = mkeyNntp.Save ();
		_ASSERT ( SUCCEEDED(hr2) );

		hr = HRESULT_FROM_WIN32 ( dwWin32Error );
		goto Exit;
	}

	*plInstanceId = dwInstance;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::DeleteInstance
//
//	Description:
//
//		Removes a virtual server from the metabase
//
//	Parameters:
//
//		pMetabase	- The metabase object
//		lInstanceId	- The ID of the virtual server to delete.
//		pErr		- The resulting error code.
//
//	Returns:
//
//		Resulting error code in *pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::DeleteInstance ( IMSAdminBase * pMetabase, long lInstanceId )
{
	TraceFunctEnter ( "CNntpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeyNntp ( pMetabase );

    //
    //  Tell U2 to delete any mappings associated with this virtual server:
    //

    ::DeleteMapping ( m_strServer, (BSTR) MD_SERVICE_NAME, lInstanceId );

    //
    //  Delete the virtual server from the metabase:
    //

	hr = mkeyNntp.Open ( NNTP_MD_ROOT_PATH );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", GetLastError() );
		goto Exit;
	}

	hr = mkeyNntp.DestroyIntegerChild ( (DWORD) lInstanceId );
	if ( FAILED (hr) ) {
		goto Exit;
	}

    hr = mkeyNntp.Save ();
    BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\admin.h ===
// admin.h : Declaration of the CNntpAdmin

// Dependencies:

#include "metafact.h"

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdmin : 
	public CComDualImpl<INntpAdmin, &IID_INntpAdmin, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdmin,&CLSID_CNntpAdmin>
{
public:
	CNntpAdmin();
	virtual ~CNntpAdmin ();

BEGIN_COM_MAP(CNntpAdmin)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpAdmin)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdmin) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdmin, _T("Nntpadm.Admin.1"), _T("Nntpadm.Admin"), IDS_NNTPADMIN_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpAdmin
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Pointers to other INntpAdmin interfaces:
		
	STDMETHODIMP	get_ServerAdmin		( IDispatch ** ppIDispatch );
//	STDMETHODIMP	get_ServiceAdmin	( IDispatch ** ppIDispatch );

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Versioning:

	STDMETHODIMP	get_HighVersion		( long * plHighVersion );
	STDMETHODIMP	get_LowVersion		( long * plLowVersion );
	STDMETHODIMP	get_BuildNum		( long * plBuildNumber );
	STDMETHODIMP	get_ServiceVersion	( long * plServiceVersion );
	
	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	EnumerateInstances	( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP	EnumerateInstancesVariant	( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP	CreateInstance		( 
		BSTR	strNntpFileDirectory,
		BSTR	strHomeDirectory,
        BSTR    strProgId,
        BSTR    strMdbGuid,
		long * plInstanceId 
		);
	STDMETHODIMP	DestroyInstance		( long lInstanceId );
	STDMETHODIMP	ErrorToString		( long lErrorCode, BSTR * pstrError );
	STDMETHODIMP	Tokenize			( BSTR strIn, BSTR * pstrOut );
	STDMETHODIMP	Truncate			( BSTR strIn, long cMaxChars, BSTR * pstrOut );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	DWORD		m_dwServiceVersion;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT			QueryMetabaseInstances	( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances );
	HRESULT			CreateNewInstance		(
		IMSAdminBase *	pMetabase,
		BSTR			strNntpFileDirectory,
		BSTR			strHomeDirectory,
        BSTR            strProgId,
        BSTR            strMdbGuid,
		long * 			plInstanceId
		);
	HRESULT			DeleteInstance			( IMSAdminBase * pMetabase, long lInstanceId );
	HRESULT         CreateVRoot(    
            CMetabaseKey    &mkeyNntp,
            BSTR            strVPath,
            BSTR            strProgId,
            BSTR            strMdbGuid,
            LPWSTR          wszKeyPath
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\binding.cpp ===
// binding.cpp : Implementation of CNntpServerBinding & CNntpServerBindings.

#include "stdafx.h"
#include "nntpcmn.h"
#include "cmultisz.h"
#include "binding.h"
#include "oleutil.h"

// #include <stdio.h>

HRESULT	CBinding::SetProperties ( 
	BSTR	strIpAddress, 
	long	dwTcpPort,
	long	dwSslPort
	)
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	m_strIpAddress	= strIpAddress;
	m_dwTcpPort		= dwTcpPort;
	m_dwSslPort		= dwSslPort;

	if ( !m_strIpAddress ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_INntpServerBinding

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpServerBinding::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpServerBinding,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpServerBinding::CNntpServerBinding ()
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpServerBinding::~CNntpServerBinding ()
{
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpServerBinding::get_IpAddress ( BSTR * pstrIpAddress )
{
	return StdPropertyGet ( m_binding.m_strIpAddress, pstrIpAddress );
}

STDMETHODIMP CNntpServerBinding::put_IpAddress ( BSTR strIpAddress )
{
	return StdPropertyPut ( &m_binding.m_strIpAddress, strIpAddress );
}

STDMETHODIMP CNntpServerBinding::get_TcpPort ( long * pdwTcpPort )
{
	return StdPropertyGet ( m_binding.m_dwTcpPort, pdwTcpPort );
}

STDMETHODIMP CNntpServerBinding::put_TcpPort ( long dwTcpPort )
{
	return StdPropertyPut ( &m_binding.m_dwTcpPort, dwTcpPort );
}

STDMETHODIMP CNntpServerBinding::get_SslPort ( long * plSslPort )
{
	return StdPropertyGet ( m_binding.m_dwSslPort, plSslPort );
}

STDMETHODIMP CNntpServerBinding::put_SslPort ( long lSslPort )
{
	return StdPropertyPut ( &m_binding.m_dwSslPort, lSslPort );
}

//
// Must define THIS_FILE_* macros to use NntpCreateException()
//

#undef THIS_FILE_HELP_CONTEXT
#undef THIS_FILE_PROG_ID
#undef THIS_FILE_IID

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_INntpServerBindings

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpServerBindings::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpServerBindings,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpServerBindings::CNntpServerBindings () :
	m_dwCount			( 0 ),
	m_rgBindings		( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpServerBindings::~CNntpServerBindings ()
{
	// All CComBSTR's are freed automatically.

	delete [] m_rgBindings;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpServerBindings::get_Count ( long * pdwCount )
{
	return StdPropertyGet ( m_dwCount, pdwCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpServerBindings::Item ( 
	long index, 
	INntpServerBinding ** ppBinding 
	)
{
	TraceFunctEnter ( "CNntpServerBindings::Item" );

	_ASSERT ( IS_VALID_OUT_PARAM ( ppBinding ) );

	*ppBinding = NULL;

	HRESULT								hr			= NOERROR;
	CComObject<CNntpServerBinding> *	pBinding	= NULL;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = CComObject<CNntpServerBinding>::CreateInstance ( &pBinding );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( pBinding );
	hr = pBinding->SetProperties ( m_rgBindings[index] );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->QueryInterface ( IID_INntpServerBinding, (void **) ppBinding );
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) ) {
		delete pBinding;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<INntpServerBinding>	pBinding;

	hr = Item ( index, &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = pBinding->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpServerBindings::Add ( 
	BSTR strIpAddress, 
	long dwTcpPort,
	long dwSslPort
	)
{
	TraceFunctEnter ( "CNntpServerBindings::Add" );

	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	HRESULT		hr	= NOERROR;
	CBinding *	rgNewBindings	= NULL;
	long		i;

	//
	//	Validate the new binding:
	//

	//
	//	See if we can merge this binding with an existing one:
	//
	if ( dwTcpPort == 0 || dwSslPort == 0 ) {
		for ( i = 0; i < m_dwCount; i++ ) {

			if ( (dwTcpPort == 0 && m_rgBindings[i].m_dwSslPort == 0) ||
				 (dwSslPort == 0 && m_rgBindings[i].m_dwTcpPort == 0) ) {

				if ( lstrcmpi ( m_rgBindings[i].m_strIpAddress, strIpAddress ) == 0 ) {

					if ( m_rgBindings[i].m_dwSslPort == 0 ) {
						m_rgBindings[i].m_dwSslPort = dwSslPort;
					}
					else {
						m_rgBindings[i].m_dwTcpPort = dwTcpPort;
					}
					hr = NOERROR;
					goto Exit;
				}
			}
		}
	}

	//	Allocate the new binding array:
	rgNewBindings	= new CBinding [ m_dwCount + 1 ];
	if ( !rgNewBindings ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//	Copy the old bindings to the new array:
	for ( i = 0; i < m_dwCount; i++ ) {
		hr = rgNewBindings[i].SetProperties ( m_rgBindings[i] );
		if ( FAILED (hr) ) {
			goto Exit;
		}
	}

	//	Add the new binding to the end of the array:
	hr = rgNewBindings[m_dwCount].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgBindings;
	m_rgBindings = rgNewBindings;
	rgNewBindings = NULL;
	m_dwCount++;

Exit:
    if (rgNewBindings) {
        delete [] rgNewBindings;
    }
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::ChangeBinding ( 
	long index, 
	INntpServerBinding * pBinding 
	)
{
	TraceFunctEnter ( "CNntpServerBindings::ChangeBinding" );

	HRESULT		hr	= NOERROR;

	CComBSTR	strIpAddress;
	long		dwTcpPort;
	long		dwSslPort;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = pBinding->get_IpAddress ( &strIpAddress );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_TcpPort ( &dwTcpPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_SslPort ( &dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_rgBindings[index].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::ChangeBindingDispatch ( long index, IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<INntpServerBinding>	pBinding;

	hr = pDispatch->QueryInterface ( IID_INntpServerBinding, (void **) &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = ChangeBinding ( index, pBinding );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpServerBindings::Remove ( long index )
{
	TraceFunctEnter ( "CNntpServerBindings::Remove" );

	HRESULT		hr	= NOERROR;
	CBinding	temp;
	long		cPositionsToSlide;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	//	Slide the array down by one position:

	_ASSERT ( m_rgBindings );

	cPositionsToSlide	= (m_dwCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_dwCount );

	if ( cPositionsToSlide > 0 ) {
		// Save the deleted binding in temp:
		CopyMemory ( &temp, &m_rgBindings[index], sizeof ( CBinding ) );

		// Move the array down one:
		MoveMemory ( &m_rgBindings[index], &m_rgBindings[index + 1], sizeof ( CBinding ) * cPositionsToSlide );

		// Put the deleted binding on the end (so it gets destructed):
		CopyMemory ( &m_rgBindings[m_dwCount - 1], &temp, sizeof ( CBinding ) );

		// Zero out the temp binding:
		ZeroMemory ( &temp, sizeof ( CBinding ) );
	}

	m_dwCount--;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::Clear ( )
{
	delete [] m_rgBindings;
	m_rgBindings 	= NULL;
	m_dwCount		= 0;

	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from INntpServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

static DWORD CountBindingChars ( LPCWSTR strIpAddress, DWORD dwPort )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	DWORD		cchResult	= 0;
	WCHAR		wszPort [256];

	wsprintf ( wszPort, _T("%u"), dwPort );

	cchResult += lstrlen ( strIpAddress );	// <IPADDRESS>
	cchResult += 1;							// :
	cchResult += lstrlen ( wszPort );		// <PORT>
	cchResult += 1;							// :
//	cchResult += lstrlen ( strPathHeader );	// <PATHHEADER>

	cchResult += 1;		// For the terminating NULL

	return cchResult;
}

static void ToBindingString ( LPCWSTR strIpAddress, DWORD dwPort, LPWSTR wszBinding )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );
	_ASSERT ( dwPort != 0 );

	_ASSERT ( !IsBadWritePtr ( wszBinding, CountBindingChars ( strIpAddress, dwPort ) ) );

	wsprintf ( wszBinding, _T("%s:%u:"), strIpAddress, dwPort );
}

static HRESULT FromBindingString ( LPCWSTR wszBinding, LPWSTR wszIpAddressOut, DWORD * pdwPort )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress	[ 256 ];
	WCHAR	wszPort			[ 256 ];
	long	dwPort;

	LPWSTR	pchColon;

	wszIpAddress[0]	= NULL;
	wszPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = HRESULT_FROM_WIN32 ( ERROR_INVALID_DATA );
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszPort, pchFirstColon + 1, 250 );

	// Get the Port:
	dwPort	= _wtoi ( wszPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	lstrcpy ( wszIpAddressOut, wszIpAddress );
	*pdwPort		= dwPort;

Exit:
	return hr;
}

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmsz, 
	BOOL					fTcpBindings,
	INntpServerBindings *	pBindings 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		WCHAR	wszIpAddress[512];
		DWORD	dwPort;

		hr = FromBindingString ( pchCurrent, wszIpAddress, &dwPort );
		BAIL_ON_FAILURE(hr);

		if ( fTcpBindings ) {
			hr = pBindings->Add ( wszIpAddress, dwPort, 0 );
		}
		else {
			hr = pBindings->Add ( wszIpAddress, 0, dwPort );
		}
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT IBindingsToMDBindings ( 
	INntpServerBindings *	pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmsz
	)
{
	HRESULT		hr	= NOERROR;
	long		cBindings;
	long		i;
	DWORD		cbCount		= 0;
	LPWSTR		wszBindings	= NULL;

	// Count the characters of the regular bindings list:
	cbCount	= 0;
	pBindings->get_Count ( &cBindings );

	for ( i = 0; i < cBindings; i++ ) {
		CComPtr<INntpServerBinding>	pBinding;
		CComBSTR					strIpAddress;
		long						lTcpPort;
		long						lSslPort;

		hr = pBindings->Item ( i, &pBinding );
		BAIL_ON_FAILURE(hr);

		pBinding->get_IpAddress	( &strIpAddress );
		pBinding->get_TcpPort	( &lTcpPort );
		pBinding->get_SslPort	( &lSslPort );

		if ( fTcpBindings ) {
			if ( lTcpPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lTcpPort );
			}
		}
		else {
			if ( lSslPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lSslPort );
			}
		}
	}

	if ( cbCount == 0 ) {
		cbCount		= 2;
		wszBindings	= new WCHAR [ cbCount ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {
		cbCount++;	// For double null terminator

		wszBindings	= new WCHAR [ cbCount ];
		if ( !wszBindings ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		LPWSTR		pchCurrent	= wszBindings;

		for ( i = 0; i < cBindings; i++ ) {
			CComPtr<INntpServerBinding>	pBinding;
			CComBSTR					strIpAddress;
			long						lTcpPort;
			long						lSslPort;

			hr = pBindings->Item ( i, &pBinding );
			BAIL_ON_FAILURE(hr);

			pBinding->get_IpAddress	( &strIpAddress );
			pBinding->get_TcpPort	( &lTcpPort );
			pBinding->get_SslPort	( &lSslPort );

			if ( fTcpBindings ) {
				if ( lTcpPort != 0 ) {
					ToBindingString ( strIpAddress, lTcpPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
			else {
				if ( lSslPort != 0 ) {
					ToBindingString ( strIpAddress, lSslPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
		}

		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cbCount - 1] == NULL );
	_ASSERT ( wszBindings[cbCount - 2] == NULL );

	pmsz->Attach ( wszBindings );

Exit:
	return hr;
}

#if 0
	
DWORD CBinding::SizeInChars ( )
{
	DWORD		cchResult	= 0;
	WCHAR		wszTcpPort [256];

	wsprintf ( wszTcpPort, _T("%d"), m_dwTcpPort );

	cchResult += lstrlen ( m_strIpAddress );	// <IPADDRESS>
	cchResult += 1;								// :
	cchResult += lstrlen ( wszTcpPort );		// <TCPPORT>
	cchResult += 1;								// :
//	cchResult += lstrlen ( m_strPathHeader );	// <PATHHEADER>

	return cchResult;
}

void CBinding::ToString	( LPWSTR wszBinding )
{
	wsprintf ( wszBinding, _T("%s:%d:"), m_strIpAddress, m_dwTcpPort );
}

HRESULT CBinding::FromString ( LPCWSTR wszBinding )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress 	[ 256 ];
	WCHAR	wszTcpPort		[ 256 ];
	long	dwTcpPort;

	LPWSTR	pchColon;

	wszIpAddress[0]		= NULL;
	wszTcpPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = E_FAIL;
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszTcpPort, pchFirstColon + 1, 250 );

	// Get the TcpPort:
	dwTcpPort = _wtoi ( wszTcpPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	m_strIpAddress	= wszIpAddress;
	m_dwTcpPort		= dwTcpPort;

	if ( !m_strIpAddress ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	return hr;
}

HRESULT CNntpServerBindings::FromMultiSz ( CMultiSz * pmsz )
{
	HRESULT		hr;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	hr = Clear ();
	_ASSERT ( SUCCEEDED(hr) );

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		hr = binding.FromString ( pchCurrent );
		if ( FAILED(hr) ) {
			if ( hr == E_FAIL ) {
				// Skip the bad binding strings.
				continue;
			}
			else {
				goto Exit;
			}
		}

		hr = Add ( binding.m_strIpAddress, binding.m_dwTcpPort );
		if ( FAILED(hr) ) {
			goto Exit;
		}
	}

Exit:
	return hr;
}

HRESULT CNntpServerBindings::ToMultiSz ( CMultiSz * pmsz )
{
	HRESULT	hr	= NOERROR;
	DWORD	cchSize;
	long	i;
	LPWSTR	wszBindings;
	LPWSTR	pchCurrent;

	// Special case - the empty binding list:
	if ( m_dwCount == 0 ) {
		cchSize		= 2;
		wszBindings	= new WCHAR [ cchSize ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {

		cchSize = 0;

		for ( i = 0; i < m_dwCount; i++ ) {
			cchSize += m_rgBindings[i].SizeInChars ( ) + 1;
		}
		// Add the size of the final terminator:
		cchSize += 1;

		wszBindings = new WCHAR [ cchSize ];
		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		for ( i = 0, pchCurrent = wszBindings; i < m_dwCount; i++ ) {

			m_rgBindings[i].ToString ( pchCurrent );
			pchCurrent += lstrlen ( pchCurrent ) + 1;
		}

		// Add the final NULL terminator:
		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cchSize - 1] == NULL );
	_ASSERT ( wszBindings[cchSize - 2] == NULL );

	pmsz->Attach ( wszBindings );

	_ASSERT ( pmsz->Count () == (DWORD) m_dwCount );

Exit:
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\expinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	expinfo.cpp

Abstract:


Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "oleutil.h"
#include "nntpcmn.h"
#include "nntptype.h"
#include "nntpapi.h"

#include "expinfo.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Expiration.1")
#define THIS_FILE_IID				IID_INntpAdminExpiration

CExpirationPolicy::CExpirationPolicy ( ) :
	m_dwExpireId	( 0 ),
	m_dwSize		( 0 ),
	m_dwTime		( 0 )
	// CMultiSz's are set to NULL automatically.
{
}

CExpirationPolicy::~CExpirationPolicy ( )
{
	// CMultiSz's are deleted automatically.
}

void CExpirationPolicy::Destroy ()
{
	m_mszNewsgroups.Empty ();
}

const CExpirationPolicy & CExpirationPolicy::operator= ( const CExpirationPolicy & Expire )
{
	// Check for assignment to self:

	if ( &Expire == this ) {
		return *this;
	}

	// Empty the old Expire values:
	this->Destroy ();

	// Copy all member variables:
	m_dwExpireId		= Expire.m_dwExpireId;
	m_strPolicyName		= Expire.m_strPolicyName;
	m_dwSize			= Expire.m_dwSize;
	m_dwTime			= Expire.m_dwTime;
	m_mszNewsgroups		= Expire.m_mszNewsgroups;

	// If anything didn't work, CheckValid will fail.

	return *this;
}

BOOL CExpirationPolicy::CheckValid ( )
{
	// Check Strings:

	if (
		!m_mszNewsgroups
		) {

		return FALSE;
	}

	return TRUE;
}

void CExpirationPolicy::FromExpireInfo ( const NNTP_EXPIRE_INFO * pExpireInfo )
{
	this->Destroy ();

	m_dwExpireId		= pExpireInfo->ExpireId;
	m_strPolicyName		= pExpireInfo->ExpirePolicy;
	m_dwSize			= pExpireInfo->ExpireSizeHorizon;
	m_dwTime			= pExpireInfo->ExpireTime;
	m_mszNewsgroups		= (LPWSTR) pExpireInfo->Newsgroups;

	_ASSERT ( pExpireInfo->cbNewsgroups == m_mszNewsgroups.SizeInBytes () );
}

HRESULT CExpirationPolicy::ToExpireInfo ( LPNNTP_EXPIRE_INFO pExpireInfo )
{
	TraceFunctEnter ( "CExpirationPolicy::ToExpireInfo" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pExpireInfo ) );

	HRESULT	hr	= NOERROR;

	ZeroMemory ( pExpireInfo, sizeof ( *pExpireInfo ) );

	pExpireInfo->ExpireId			= m_dwExpireId;
	pExpireInfo->ExpirePolicy		= m_strPolicyName;
	pExpireInfo->ExpireSizeHorizon	= m_dwSize;
	pExpireInfo->ExpireTime			= m_dwTime;
	pExpireInfo->Newsgroups			= (UCHAR *) (LPCWSTR) m_mszNewsgroups;
	pExpireInfo->cbNewsgroups		= m_mszNewsgroups.SizeInBytes ();

	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::Add ( LPCWSTR strServer, DWORD dwInstance)
{
	TraceFunctEnter ( "CExpirationPolicy::Add" );

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	DWORD			dwNewId		= 0;
	NNTP_EXPIRE_INFO	Expireinfo;

	FillMemory ( &Expireinfo, sizeof (Expireinfo), 0 );

	hr = ToExpireInfo ( &Expireinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	Expireinfo.ExpireId = 0;

	dwError = NntpAddExpire ( (LPWSTR) strServer, dwInstance, &Expireinfo, &dwParmErr, &dwNewId );
	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to add Expire %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	this->m_dwExpireId = dwNewId;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::Set ( LPCWSTR strServer, DWORD dwInstance)
{
	TraceFunctEnter ( "CExpirationPolicy::Set" );

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_EXPIRE_INFO	Expireinfo;

	FillMemory ( &Expireinfo, sizeof (Expireinfo), 0 );

	hr = ToExpireInfo ( &Expireinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	dwError = NntpSetExpireInformation ( (LPWSTR) strServer, dwInstance, &Expireinfo, &dwParmErr );
	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to set Expire[%d]: %x", m_dwExpireId, dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::Remove ( LPCWSTR strServer, DWORD dwInstance)
{
	TraceFunctEnter ( "CExpirationPolicy::Remove" );

	HRESULT				hr 			= NOERROR;
	DWORD				dwError		= NOERROR;

	dwError = NntpDeleteExpire ( (LPWSTR) strServer, dwInstance, m_dwExpireId );
	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to remove Expire[%d]: %x", m_dwExpireId );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

#if 0

BOOL CExpirationPolicy::CheckPolicyProperties ( )
{
	return TRUE;
}

HRESULT	CExpirationPolicy::GetFromMetabase ( CMetabaseKey * pmkeyExpiration, const LPWSTR wszPolicyKey )
{
	TraceFunctEnter ( "CExpirationPolicy::GetFromMetabase" );

	HRESULT	hr		= NOERROR;
	DWORD	cbData	= 0;
	char	Dummy[5];
	WCHAR *	msz = NULL;

	m_dwExpireId = GetExpireId ( szPolicyKey );
	// Assume that the ID is non-zero:
	_ASSERT ( m_dwExpireId != 0 );

	hr = pmkeyExpiration->GetDword ( szPolicyKey, MD_EXPIRE_SPACE, IIS_MD_UT_SERVER, &m_dwSize, 0 );
	if ( FAILED(hr) ) {
		m_dwSize = (DWORD) -1;
		hr = NOERROR;
	}

	hr = pmkeyExpiration->GetDword ( szPolicyKey, MD_EXPIRE_TIME, IIS_MD_UT_SERVER, &m_dwTime, 0 );
	if ( FAILED(hr) ) {
		m_dwTime = (DWORD) -1;
		hr = NOERROR;
	}

	hr = pmkeyExpiration->GetData ( szPolicyKey, MD_EXPIRE_NEWSGROUPS, IIS_MD_UT_SERVER, BINARY_METADATA, &Dummy, &cbData, 0 );
	if ( FAILED (hr) ) {
		cbData = 0;
		hr = NOERROR;
	}

	if ( cbData == 0 ) {
		m_mszNewsgroups = _T("\0");
	}
	else {
		_ASSERT ( (cbData % 2) == 0 );

		msz = new WCHAR [ (cbData + 1) / 2 ];

		if ( msz == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		hr = pmkeyExpiration->GetData ( szPolicyKey, MD_EXPIRE_NEWSGROUPS, IIS_MD_UT_SERVER, BINARY_METADATA, msz, &cbData, 0 );

		m_mszNewsgroups = msz;
	}

Exit:
	if ( msz ) {
		delete msz;
	}

	TraceFunctLeave ();
	return hr;
}

HRESULT	CExpirationPolicy::SendToMetabase ( CMetabaseKey * pmkeyExpiration, DWORD bvChangedFields )
{
	TraceFunctEnter ( "CExpirationPolicy::SendToMetabase" );

	HRESULT	hr	= NOERROR;
	DWORD	cbNewsgroups = 0;
	CHAR	szPolicyKey[ METADATA_MAX_NAME_LEN ];

	_ASSERT ( m_dwExpireId != 0 );
	wsprintfA ( szPolicyKey, "expire%ud", m_dwExpireId );

	hr = pmkeyExpiration->SetDword ( szPolicyKey, MD_EXPIRE_SPACE, IIS_MD_UT_SERVER, m_dwSize );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pmkeyExpiration->SetDword ( szPolicyKey, MD_EXPIRE_TIME, IIS_MD_UT_SERVER, m_dwTime );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	cbNewsgroups = m_mszNewsgroups.SizeInBytes ();

	hr = pmkeyExpiration->SetData ( szPolicyKey, MD_EXPIRE_NEWSGROUPS, IIS_MD_UT_SERVER, BINARY_METADATA, (void *) (LPCWSTR) m_mszNewsgroups, cbNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::AddToMetabase ( CMetabaseKey * pmkeyExpiration )
{
	TraceFunctEnter ( "CExpirationPolicy::AddToMetabase" );

	HRESULT		hr = NOERROR;
	char		szExpireKey [ METADATA_MAX_NAME_LEN ];

	m_dwExpireId = 0;

	while ( 1 ) {
		m_dwExpireId++;

		wsprintfA ( szExpireKey, "expire%ud", m_dwExpireId );

		hr = pmkeyExpiration->CreateChild ( szExpireKey );

		if ( SUCCEEDED(hr) ) {
			// Success, get out of the loop:
			break;
		}

		if ( HRESULTTOWIN32 ( hr ) == ERROR_ALREADY_EXISTS ) {
			// This key already exists, try the next one:
			continue;
		}

		_ASSERT ( FAILED(hr) );
		if ( FAILED(hr) ) {
			ErrorTraceX ( (LPARAM) this, "Error adding new expire policy [%d] : %x", m_dwExpireId, hr );
			goto Exit;
		}
	}

	return SendToMetabase ( pmkeyExpiration, (DWORD) -1 );

Exit:
	TraceFunctLeave ();
	return hr;
}

DWORD GetExpireId ( const LPWSTR wszKey )
{
	if ( strncmp ( szKey, "expire", sizeof ("expire") - 1 ) != 0 ) {
		return 0;
	}

	return atoi ( szKey + sizeof("expire") - 1 );
}

BOOL IsKeyValidExpire ( const LPWSTR wszKey )
{
/*
	if ( _strnicmp ( szKey, "expire" ) != 0 ) {
		return FALSE;
	}
*/

	if ( GetExpireId ( szKey ) != 0 ) {
		return TRUE;
	}

	return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\binding.h ===
// binding.h : Declaration of the CNntpServerBinding & CNntpServerBindings classes.


//
//	Dependencies:
//

class CMultiSz;

//
//	A simple binding class:
//

class CBinding
{
public:
	CBinding () : 
		m_dwTcpPort ( 0 ),
		m_dwSslPort ( 0 )
		{ }

	CComBSTR	m_strIpAddress;
	long		m_dwTcpPort;
	long		m_dwSslPort;

	HRESULT	SetProperties ( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	inline HRESULT	SetProperties ( const CBinding & binding )
	{
		return SetProperties ( 
			binding.m_strIpAddress, 
			binding.m_dwTcpPort,
			binding.m_dwSslPort
			);
	}

private:
	// Don't call this:
	const CBinding & operator= ( const CBinding & );
};

/////////////////////////////////////////////////////////////////////////////
// The Binding Object

class CNntpServerBinding : 
	public CComDualImpl<INntpServerBinding, &IID_INntpServerBinding, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CNntpServerBindings;
	friend class CNntpVirtualServer;

public:
	CNntpServerBinding();
	virtual ~CNntpServerBinding ();
BEGIN_COM_MAP(CNntpServerBinding)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpServerBinding)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpServerBinding) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpServerBinding
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IpAddress	( BSTR * pstrIpAddress );
	STDMETHODIMP	put_IpAddress	( BSTR strIpAddress );

	STDMETHODIMP	get_TcpPort	( long * pdwTcpPort );
	STDMETHODIMP	put_TcpPort	( long dwTcpPort );

	STDMETHODIMP	get_SslPort	( long * plSslPort );
	STDMETHODIMP	put_SslPort	( long lSslPort );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	inline HRESULT	SetProperties	( const CBinding & binding )
	{
		return m_binding.SetProperties ( binding );
	}

	// Property variables:
	CBinding	m_binding;
};

/////////////////////////////////////////////////////////////////////////////
// The Bindings Object

class CNntpServerBindings : 
	public CComDualImpl<INntpServerBindings, &IID_INntpServerBindings, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CNntpServerBinding;
	friend class CNntpVirtualServer;

public:
	CNntpServerBindings();
	virtual ~CNntpServerBindings ();
BEGIN_COM_MAP(CNntpServerBindings)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpServerBindings)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpServerBindings) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpServerBindings
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pdwCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Item			( long index, INntpServerBinding ** ppBinding );
	STDMETHODIMP	ItemDispatch	( long index, IDispatch ** ppBinding );
	STDMETHODIMP	Add				( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	STDMETHODIMP	ChangeBinding	( long index, INntpServerBinding * pBinding );
	STDMETHODIMP	ChangeBindingDispatch	( long index, IDispatch * pBinding );
	STDMETHODIMP	Remove			( long index );
	STDMETHODIMP	Clear			( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
	long			m_dwCount;
	CBinding *		m_rgBindings;
};

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from INntpServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmszBindings, 
	BOOL					fTcpBindings,
	INntpServerBindings *	pBindings 
	);

HRESULT IBindingsToMDBindings ( 
	INntpServerBindings *	pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmszBindings
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\expinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	expinfo.h

Abstract:

	Defines the CExpirationPolicy class that maintains all properties about an 
	expiration policy.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _EXPINFO_INCLUDED_
#define _EXPINFO_INCLUDED_

// Dependencies:

#include "cmultisz.h"

typedef struct _NNTP_EXPIRE_INFO NNTP_EXPIRE_INFO, * LPNNTP_EXPIRE_INFO;

//
//	Changed flags:
//

#define CHNG_EXPIRE_SIZE			0x00000001
#define CHNG_EXPIRE_TIME			0x00000002
#define CHNG_EXPIRE_NEWSGROUPS		0x00000004
#define CHNG_EXPIRE_ID				0x00000008
#define CHNG_EXPIRE_POLICY_NAME		0x00000010

/////////////////////////////////////////////////////////////////////////////
// Defaults:

#define DEFAULT_EXPIRE_SIZE			( 500 )			// 500 megabytes
#define DEFAULT_EXPIRE_TIME			( 24 * 7 )		// One week
#define DEFAULT_EXPIRE_NEWSGROUPS	( _T ("\0") )	// Empty list
#define DEFAULT_EXPIRE_POLICY_NAME	( _T ("") )		// No name

DWORD GetExpireId ( const LPWSTR wszKey );
BOOL IsKeyValidExpire ( const LPWSTR wszKey );

//$-------------------------------------------------------------------
//
//	Class:
//
//		CExpirationPolicy
//
//	Description:
//
//		Maintains properties about a expire & communicates with the metabase.
//
//	Interface:
//
//		
//
//--------------------------------------------------------------------

class CExpirationPolicy
{
public:
	CExpirationPolicy	( );
	~CExpirationPolicy	( );

	void	Destroy ();

	const CExpirationPolicy & operator= ( const CExpirationPolicy & Expire );
	inline const CExpirationPolicy & operator= ( const NNTP_EXPIRE_INFO & Expire ) {
		FromExpireInfo ( &Expire );
		return *this;
	}

	BOOL	CheckValid ();

	HRESULT		ToExpireInfo		( LPNNTP_EXPIRE_INFO pExpireInfo );
	void		FromExpireInfo	( const NNTP_EXPIRE_INFO * pExpireInfo );

	HRESULT		Add 	( LPCWSTR strServer, DWORD dwInstance);
	HRESULT		Set 	( LPCWSTR strServer, DWORD dwInstance);
//	HRESULT		Get 	( LPCWSTR strServer, DWORD dwInstance);
	HRESULT		Remove 	( LPCWSTR strServer, DWORD dwInstance);

	// expire Properties:
public:
	DWORD		m_dwExpireId;

	CComBSTR	m_strPolicyName;
	DWORD		m_dwSize;
	DWORD		m_dwTime;
	CMultiSz	m_mszNewsgroups;

private:
	// Don't call the copy constructor:
	CExpirationPolicy ( const CExpirationPolicy & );
};

#endif // _EXPINFO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\expire.h ===
// expire.h : Declaration of the CNntpAdminExpiration


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "metafact.h"
#include "expinfo.h"

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminExpiration : 
	public INntpAdminExpiration, 
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminExpiration,&CLSID_CNntpAdminExpiration>
{
public:
	CNntpAdminExpiration();
	virtual ~CNntpAdminExpiration ();
BEGIN_COM_MAP(CNntpAdminExpiration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminExpiration)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminExpiration) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminExpiration, _T("Nntpadm.Expiration.1"), _T("Nntpadm.Expiration"), IDS_NNTPADMINEXPIRATION_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminExpiration
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminExpiration
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Enumeration Properties:

	STDMETHODIMP	get_Count	( long * plCount );

	// Cursor Feed Properties:

	STDMETHODIMP	get_ExpireId	( long * plId );
	STDMETHODIMP	put_ExpireId	( long lId );

	STDMETHODIMP	get_PolicyName	( BSTR * pstrPolicyName );
	STDMETHODIMP	put_PolicyName	( BSTR strPolicyName );

	STDMETHODIMP	get_ExpireTime	( long * plExpireTime );
	STDMETHODIMP	put_ExpireTime	( long lExpireTime );

	STDMETHODIMP	get_ExpireSize	( long * plExpireSize );
	STDMETHODIMP	put_ExpireSize	( long lExpireSize );

	STDMETHODIMP	get_Newsgroups	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_Newsgroups	( SAFEARRAY * psastrNewsgroups );

	STDMETHODIMP	get_NewsgroupsVariant	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_NewsgroupsVariant	( SAFEARRAY * psastrNewsgroups );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Default		( );
	STDMETHODIMP	Enumerate	( );
	STDMETHODIMP	GetNth		( long lIndex );
	STDMETHODIMP	FindID		( long lID, long * plIndex );
	STDMETHODIMP	Add			( );
	STDMETHODIMP	Set			( );
	STDMETHODIMP	Remove		( long lID);

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	BOOL			m_fEnumerated;
	DWORD			m_cCount;
	CExpirationPolicy *	m_rgExpires;

	// The current expiration policy.  All properties manipulate this policy:
	CExpirationPolicy	m_expireCurrent;
	DWORD				m_bvChangedFields;

	//////////////////////////////////////////////////////////////////////
	//	Private Methods:
	//////////////////////////////////////////////////////////////////////

	long		IndexFromID ( long dwExpireId );

/*
	HRESULT		EnumerateMetabaseExpirationPolicies ( IMSAdminBase * pMetabase);
	HRESULT		AddPolicyToMetabase			( IMSAdminBase * pMetabase);
	HRESULT		AddPolicyToArray			( );
	HRESULT		SetPolicyToMetabase			( IMSAdminBase * pMetabase);
	HRESULT		SetPolicyToArray			( );
	HRESULT		RemovePolicyFromMetabase	( IMSAdminBase * pMetabase, DWORD index);
	HRESULT		RemovePolicyFromArray		( DWORD index );
	DWORD		IndexFromID 				( DWORD dwID );
*/
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\feedpach.h ===
#ifndef _FEED_PATCH_H_
#include "metakey.h"
#include <stdio.h>
#include <nntpmeta.h>
#include <nntptype.h>
#include <nntpapi.h>

HRESULT AddFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD, PDWORD );
HRESULT SetFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD );
HRESULT DeleteFeed( DWORD dwFeedId, CMetabaseKey* pMK, DWORD );
HRESULT OpenKey( DWORD, CMetabaseKey*, DWORD, DWORD );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\feedinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	feedinfo.cpp

Abstract:


Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

    Kangrong Yan ( KangYan )    Feb-28-1998
        Feed config change no longer calls NNTP RPC.  It directly writes to MB
        and synchronize with NNTPSVC's response in the metabase.

--*/

#include "stdafx.h"
#include "oleutil.h"
#include "nntpcmn.h"
#include "nntptype.h"
#include "nntpapi.h"
#include "feedpach.h"

#include "feeds.h"
#include "feedinfo.h"

#include <lmapibuf.h>

BOOL IsInboundFeed ( CFeed * pFeed )
{
    DWORD   dwType = pFeed->m_FeedType;

	return FEED_IS_PASSIVE ( dwType ) || FEED_IS_PULL ( dwType );
}

BOOL IsOutboundFeed ( CFeed * pFeed )
{
    DWORD   dwType = pFeed->m_FeedType;

	return FEED_IS_PUSH ( dwType );
}

NNTP_FEED_SERVER_TYPE FeedTypeToEnum ( FEED_TYPE ft )
{
	NNTP_FEED_SERVER_TYPE	type	= NNTP_FEED_TYPE_PEER;

	if ( FEED_IS_PEER ( ft ) ) {
		type = NNTP_FEED_TYPE_PEER;
	}
	else if ( FEED_IS_MASTER ( ft ) ) {
		type = NNTP_FEED_TYPE_MASTER;
	}
	else if ( FEED_IS_SLAVE ( ft ) ) {
		type = NNTP_FEED_TYPE_SLAVE;
	}
	else {
		_ASSERT ( FALSE );
	}

	return type;
}

void EnumToFeedType ( NNTP_FEED_SERVER_TYPE type, FEED_TYPE & ftMask )
{
	DWORD	dwType	= 0;

	//	Clear out the feed type from the mask

	ftMask &= ~FEED_REMOTE_MASK;

	switch ( type ) {
	case NNTP_FEED_TYPE_PEER:
		dwType = FEED_TYPE_PEER;
		break;

	case NNTP_FEED_TYPE_MASTER:
		dwType = FEED_TYPE_MASTER;
		break;

	case NNTP_FEED_TYPE_SLAVE:
		dwType = FEED_TYPE_SLAVE;
		break;
	}

	//	Move the feed type into the mask:
	ftMask |= dwType;
}

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Feeds.1")
#define THIS_FILE_IID				IID_INntpAdminFeeds

CFeed::CFeed ( )
	// CComBSTR's are automatically initialized to NULL
{
    //
    //  Initialize all properties to 0
    //

    m_dwFeedId                  = 0;
    m_dwPairFeedId              = 0;
    m_fAllowControlMessages     = FALSE;
    m_dwAuthenticationType      = AUTH_PROTOCOL_NONE;
    m_dwConcurrentSessions      = 0;
    m_fCreateAutomatically      = FALSE;
    m_dwFeedInterval            = 0;
    m_datePullNews              = 0;
    m_dwMaxConnectionAttempts   = 0;
    m_dwSecurityType            = 0;
    m_dwOutgoingPort            = 0;

	m_FeedType  = FEED_TYPE_PULL | FEED_TYPE_PEER;
    m_fEnabled  = TRUE;
}

CFeed::~CFeed ( )
{
	AssertValid ();

	// CComBSTR's are automatically freed.
}

void CFeed::Destroy ()
{
	AssertValid ();

	// Need to empty all strings:

	m_mszDistributions.Empty();
	m_mszNewsgroups.Empty();
	m_strRemoteServer.Empty();
	m_strUucpName.Empty();
	m_strAccountName.Empty();
	m_strPassword.Empty();
	m_strTempDirectory.Empty();
}

HRESULT CFeed::CreateFeed ( CFeed ** ppNewFeed )
{
	CFeed *	pFeedNew = new CFeed;

	if ( pFeedNew ) {
		*ppNewFeed	= pFeedNew;
		return NOERROR;
	}
	else {
		*ppNewFeed = NULL;
		return E_OUTOFMEMORY;
	}
}

HRESULT CFeed::CreateFeedFromFeedInfo ( LPNNTP_FEED_INFO pFeedInfo, CFeed ** ppNewFeed )
{
	HRESULT		hr	= NOERROR;
	CFeed * 	pFeedNew;

	*ppNewFeed = NULL;

	hr = CreateFeed ( &pFeedNew );
	BAIL_ON_FAILURE ( hr );

	hr = pFeedNew->FromFeedInfo ( pFeedInfo );
	BAIL_ON_FAILURE ( hr );

	*ppNewFeed = pFeedNew;

Exit:
	return hr;
}

HRESULT CFeed::CreateFeedFromINntpOneWayFeed ( INntpOneWayFeed * pFeed, CFeed ** ppNewFeed )
{
	HRESULT		hr	= NOERROR;
	CFeed * 	pFeedNew = NULL;

	*ppNewFeed = NULL;

	hr = CreateFeed ( &pFeedNew );
	BAIL_ON_FAILURE ( hr );

	hr = pFeedNew->FromINntpOneWayFeed ( pFeed );
	BAIL_ON_FAILURE ( hr );

	*ppNewFeed = pFeedNew;

	return hr;

Exit:
	if (pFeedNew)
		delete pFeedNew;
	return hr;
}

const CFeed & CFeed::operator= ( const CFeed & feed )
{
	AssertValid ();
	feed.AssertValid ();

	// Check for assignment to self:

	if ( &feed == this ) {
		return *this;
	}

	// Empty the old feed values:

	this->Destroy ();

	// Copy all member variables:

	m_dwFeedId					= feed.m_dwFeedId;
	m_dwPairFeedId				= feed.m_dwPairFeedId;
	m_FeedType					= feed.m_FeedType;
	m_fAllowControlMessages		= feed.m_fAllowControlMessages;
	m_dwAuthenticationType		= feed.m_dwAuthenticationType;
	m_dwConcurrentSessions		= feed.m_dwConcurrentSessions;
	m_fCreateAutomatically		= feed.m_fCreateAutomatically;
	m_fEnabled					= feed.m_fEnabled;
	m_mszDistributions			= feed.m_mszDistributions;
	m_dwFeedInterval			= feed.m_dwFeedInterval;
	m_datePullNews				= feed.m_datePullNews;
	m_dwMaxConnectionAttempts	= feed.m_dwMaxConnectionAttempts;
	m_mszNewsgroups				= feed.m_mszNewsgroups;
	m_dwSecurityType			= feed.m_dwSecurityType;
	m_dwOutgoingPort			= feed.m_dwOutgoingPort;
	m_strRemoteServer			= feed.m_strRemoteServer;
	m_strUucpName				= feed.m_strUucpName;
	m_strAccountName			= feed.m_strAccountName;
	m_strPassword				= feed.m_strPassword;
	m_strTempDirectory			= feed.m_strTempDirectory;

	m_strRemoteServer			= feed.m_strRemoteServer;
	m_EnumType					= feed.m_EnumType;

	return *this;
}

BOOL CFeed::CheckValid ( ) const
{
	AssertValid ();

	// Check Strings:

	if (
		!m_mszDistributions     ||
		!m_mszNewsgroups        ||
		!m_strUucpName          ||
		!m_strAccountName       ||
		!m_strPassword			||
		!m_strRemoteServer
		) {

		return FALSE;
	}

	return TRUE;
}

HRESULT	CFeed::get_FeedAction ( NNTP_FEED_ACTION * feedaction )
{
	AssertValid ();

	NNTP_FEED_ACTION	result;

	switch ( m_FeedType & FEED_ACTION_MASK ) {
	case FEED_TYPE_PULL:
		result = NNTP_FEED_ACTION_PULL;
		break;

	case FEED_TYPE_PUSH:
		result = NNTP_FEED_ACTION_PUSH;
		break;

	case FEED_TYPE_PASSIVE:
		result = NNTP_FEED_ACTION_ACCEPT;
		break;

	default:
		_ASSERT ( FALSE );
		result = NNTP_FEED_ACTION_PULL;
	}

	*feedaction = result;
	return NOERROR;
}

HRESULT	CFeed::put_FeedAction ( NNTP_FEED_ACTION feedaction )
{
	AssertValid ();

	FEED_TYPE	ftNew;

	ftNew = m_FeedType & (~FEED_ACTION_MASK);

	switch ( feedaction ) {
	case NNTP_FEED_ACTION_PULL:
		ftNew |= FEED_TYPE_PULL;
		break;

	case NNTP_FEED_ACTION_PUSH:
		ftNew |= FEED_TYPE_PUSH;
		break;

	case NNTP_FEED_ACTION_ACCEPT:
		ftNew |= FEED_TYPE_PASSIVE;
		break;

	default:
		_ASSERT ( FALSE );
		return TranslateFeedError ( ERROR_INVALID_PARAMETER, FEED_PARM_FEEDTYPE );
	}

	m_FeedType = ftNew;
	return NOERROR;
}

HRESULT CFeed::FromFeedInfo ( const NNTP_FEED_INFO * pFeedInfo )
{
	AssertValid ();

    FILETIME    ftPullNewsLocal;
	SYSTEMTIME	stPullNews;

	this->Destroy ();

	m_dwFeedId					= pFeedInfo->FeedId;
	m_dwPairFeedId				= pFeedInfo->FeedPairId;
	m_FeedType					= pFeedInfo->FeedType;
	m_fAllowControlMessages		= pFeedInfo->fAllowControlMessages;
	m_dwAuthenticationType		= pFeedInfo->AuthenticationSecurityType;
	m_dwConcurrentSessions		= pFeedInfo->ConcurrentSessions;
	m_fCreateAutomatically		= pFeedInfo->AutoCreate;
	m_fEnabled					= pFeedInfo->Enabled;
	m_mszDistributions			= pFeedInfo->Distribution ? pFeedInfo->Distribution : _T("\0");

    if ( !FEED_IS_PULL (m_FeedType) ||
            (
                pFeedInfo->PullRequestTime.dwLowDateTime == 0 &&
                pFeedInfo->PullRequestTime.dwHighDateTime == 0
            )
       ) {
        //
        //  Not a pull feed - so default to something reasonable here:
        //
        GetLocalTime ( &stPullNews );
    }
    else {
        FileTimeToLocalFileTime ( &pFeedInfo->PullRequestTime, &ftPullNewsLocal );
	    FileTimeToSystemTime ( &ftPullNewsLocal, &stPullNews );
    }
	SystemTimeToVariantTime		( &stPullNews, &m_datePullNews );

	m_dwFeedInterval			= pFeedInfo->FeedInterval;
	m_dwMaxConnectionAttempts	= pFeedInfo->MaxConnectAttempts;
	m_mszNewsgroups				= pFeedInfo->Newsgroups ? pFeedInfo->Newsgroups : _T("\0");
	m_dwSecurityType			= pFeedInfo->SessionSecurityType;
	m_dwOutgoingPort			= pFeedInfo->OutgoingPort;
	m_strUucpName				= pFeedInfo->UucpName ? pFeedInfo->UucpName : _T("");
	m_strAccountName			= pFeedInfo->NntpAccountName ? pFeedInfo->NntpAccountName : _T("");
	m_strPassword				= pFeedInfo->NntpPassword ? pFeedInfo->NntpPassword : _T("");
	m_strTempDirectory			= pFeedInfo->FeedTempDirectory;

	if ( pFeedInfo->Distribution ) {
		_ASSERT ( m_mszDistributions.SizeInBytes () == pFeedInfo->cbDistribution );
	}
	_ASSERT ( m_mszNewsgroups.SizeInBytes () == pFeedInfo->cbNewsgroups );

	m_strRemoteServer			= pFeedInfo->ServerName ? pFeedInfo->ServerName : _T("");
	m_EnumType					= FeedTypeToEnum ( m_FeedType );

	// Check Strings:
	if ( !CheckValid () ) {
		return E_OUTOFMEMORY;
	}
	return NOERROR;
}

HRESULT CFeed::ToFeedInfo ( LPNNTP_FEED_INFO 		pFeedInfo )
{
	TraceFunctEnter ( "CFeed::ToFeedInfo" );

	AssertValid ();
	_ASSERT ( IS_VALID_OUT_PARAM ( pFeedInfo ) );

	HRESULT	hr	= NOERROR;

	SYSTEMTIME	stPullNews;
    FILETIME    ftPullNewsLocal;

	EnumToFeedType ( m_EnumType, m_FeedType );

	ZeroMemory ( pFeedInfo, sizeof (*pFeedInfo) );

	pFeedInfo->ServerName					= m_strRemoteServer;
	pFeedInfo->FeedId						= m_dwFeedId;
	pFeedInfo->FeedPairId					= m_dwPairFeedId;
	pFeedInfo->FeedType						= m_FeedType;
	pFeedInfo->fAllowControlMessages		= m_fAllowControlMessages;
	pFeedInfo->AuthenticationSecurityType	= m_dwAuthenticationType;
	pFeedInfo->ConcurrentSessions			= m_dwConcurrentSessions;
	pFeedInfo->AutoCreate					= m_fCreateAutomatically;
	pFeedInfo->Enabled						= m_fEnabled;

    //
    //  Convert time formats:
    //

	VariantTimeToSystemTime		( m_datePullNews,	&stPullNews );

	SystemTimeToFileTime		( &stPullNews,	    &ftPullNewsLocal );

    LocalFileTimeToFileTime     ( &ftPullNewsLocal,  &pFeedInfo->PullRequestTime);
    ZeroMemory ( &pFeedInfo->StartTime, sizeof ( FILETIME ) );

	pFeedInfo->FeedInterval				= m_dwFeedInterval;
	pFeedInfo->MaxConnectAttempts		= m_dwMaxConnectionAttempts;
	pFeedInfo->SessionSecurityType		= m_dwSecurityType;
	pFeedInfo->OutgoingPort				= m_dwOutgoingPort;
	pFeedInfo->ServerName				= m_strRemoteServer;
	pFeedInfo->UucpName					= m_strUucpName;
	pFeedInfo->cbUucpName				= STRING_BYTE_LENGTH ( m_strUucpName );
	pFeedInfo->NntpAccountName			= m_strAccountName;
	pFeedInfo->cbAccountName			= STRING_BYTE_LENGTH ( m_strAccountName );
	pFeedInfo->NntpPassword				= m_strPassword;
	pFeedInfo->cbPassword				= STRING_BYTE_LENGTH ( m_strPassword );
	pFeedInfo->FeedTempDirectory		= m_strTempDirectory;
	pFeedInfo->cbFeedTempDirectory		= STRING_BYTE_LENGTH ( m_strTempDirectory );

	pFeedInfo->Distribution				= (LPWSTR) (LPCWSTR) m_mszDistributions;
	pFeedInfo->cbDistribution			= m_mszDistributions.SizeInBytes();
	pFeedInfo->Newsgroups				= (LPWSTR) (LPCWSTR) m_mszNewsgroups;
	pFeedInfo->cbNewsgroups				= m_mszNewsgroups.SizeInBytes();

	TraceFunctLeave ();
	return hr;
}

HRESULT	CFeed::FromINntpOneWayFeed ( INntpOneWayFeed * pFeed )
{
	AssertValid ();

	CNntpOneWayFeed *	pPrivateFeed;

	pPrivateFeed = (CNntpOneWayFeed *) pFeed;

	*this = pPrivateFeed->m_feed;

	if ( !CheckValid () ) {
		return E_OUTOFMEMORY;
	}
	return NOERROR;
}

HRESULT CFeed::ToINntpOneWayFeed ( INntpOneWayFeed ** ppFeed )
{
	AssertValid ();

	HRESULT							hr		= NOERROR;
	CComObject<CNntpOneWayFeed> *	pFeed	= NULL;

	hr = CComObject<CNntpOneWayFeed>::CreateInstance ( &pFeed );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	pFeed->m_feed = *this;
	if ( !pFeed->m_feed.CheckValid() ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	hr = pFeed->QueryInterface ( IID_INntpOneWayFeed, (void **) ppFeed );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	if ( FAILED(hr) ) {
		delete pFeed;
	}
	return hr;
}

HRESULT CFeed::CheckConfirm(    IN DWORD   dwFeedId,
                                IN DWORD   dwInstanceId,
                                IN CMetabaseKey* pMK,
                                OUT PDWORD  pdwErr,
                                OUT PDWORD  pdwErrMask )
{
    TraceFunctEnter( "CFeed::CheckConfirm" );
    _ASSERT( pMK );
    _ASSERT( dwFeedId > 0 );
    
    HRESULT         hr;
    const DWORD     dwMaxAttempts = 10;
    const DWORD     dwWaitMilliSeconds = 500;
    DWORD           dwHandShake;

    for ( int i = 0; i < dwMaxAttempts; i++ ) {
        hr = OpenKey( dwFeedId, pMK, METADATA_PERMISSION_READ, dwInstanceId );
        if ( FAILED( hr ) ) {
            if ( HRESULTTOWIN32( hr )  == ERROR_PATH_BUSY ) {
                Sleep( dwWaitMilliSeconds );
                continue;
            }
            else {
                ErrorTrace(0, "Open key fail with 0x%x", hr );
                return hr;
            }
        }

        //
        // getting the handshake    
        //
        hr = pMK->GetDword( MD_FEED_HANDSHAKE, &dwHandShake );
        if ( FAILED( hr ) ) {   // shouldn't happen , it's an error
            pMK->Close();
            ErrorTrace(0, "Get handshake fail with 0x%x", hr );
            return hr;
        }

        if ( dwHandShake != FEED_UPDATE_CONFIRM ) {
            pMK->Close();
            Sleep( dwWaitMilliSeconds );
            continue;
        }

        //
        // Now get error / masks
        //
        hr = pMK->GetDword( MD_FEED_ADMIN_ERROR, pdwErr );
        if ( FAILED(  hr  )  ) {    // the server is possibly not
                                    // writing the confirm /error
                                    // in good sequence, lets give
                                    // it more chances
            pMK->Close();
            Sleep( dwWaitMilliSeconds );
            continue;
        }

        hr = pMK->GetDword( MD_FEED_ERR_PARM_MASK, pdwErrMask );
        if ( FAILED( hr ) ) {       // same comments as above
            pMK->Close();
            Sleep( dwWaitMilliSeconds );
            continue;
        }

        //
        // Now we are done
        //
        pMK->Close();
        break;
    } 

    if ( i == dwMaxAttempts ) return E_FAIL;
    else return S_OK;
}

HRESULT CFeed::Add ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::Add" );

	AssertValid ();

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_FEED_INFO	feedinfo;
    DWORD           dwFeedId    = 0;

	FillMemory ( &feedinfo, sizeof (feedinfo), 0 );

	hr = ToFeedInfo ( &feedinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	feedinfo.FeedId = 0;

    //
    // KangYan: RPC goes away.  We use metabase writes
    //
    hr = AddFeedToMB( &feedinfo, pMK, &dwParmErr, dwInstance, &dwFeedId );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Add to MB fail with 0x%x", hr );
        goto Exit;
    }

    hr = CheckConfirm(  dwFeedId, dwInstance, pMK, &dwError, &dwParmErr );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Check confirm fail with 0x%x", hr );
        goto Exit;
    }

	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to add feed: %x (%x)", dwError, dwParmErr );
		hr = TranslateFeedError ( dwError, dwParmErr );
		goto Exit;
	}

	this->m_dwFeedId = dwFeedId;

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CFeed::Set ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::Set" );

	AssertValid ();

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_FEED_INFO	feedinfo;

	FillMemory ( &feedinfo, sizeof (feedinfo), 0 );

	hr = ToFeedInfo ( &feedinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

    //
    // KangYan: RPC goes away. We use metabase writes
    //
    hr = SetFeedToMB(   &feedinfo,
                        pMK,
                        &dwParmErr,
                        dwInstance );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Set MB fail with 0x%x", hr );
        goto Exit;
    }

    hr = CheckConfirm( feedinfo.FeedId, dwInstance, pMK, &dwError, &dwParmErr );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Check confirm fail with 0x%x", hr );
        goto Exit;
    } 

	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to set feed[%d]: %x (%x)", m_dwFeedId, dwError, dwParmErr );
		hr = TranslateFeedError ( dwError, dwParmErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CFeed::Remove ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::Remove" );

	AssertValid ();

	HRESULT				hr 			= NOERROR;
	DWORD				dwError		= NOERROR;

    hr = DeleteFeed( m_dwFeedId, pMK, dwInstance );
    if ( FAILED( hr ) ) {
        dwError = HRESULTTOWIN32( hr );
    	ErrorTraceX ( (LPARAM) this, "Failed to remove feed[%d]: %x", m_dwFeedId, hr );
		hr = TranslateFeedError ( dwError );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CFeed::SetPairId ( LPCWSTR strServer, DWORD dwInstance, DWORD dwPairId, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::SetPairID" );

	AssertValid ();

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_FEED_INFO	feedinfo;

	//
	//	Assume that this feed was just Added/Set to the server.
	//

	_ASSERT ( dwPairId != m_dwFeedId );
	m_dwPairFeedId	= dwPairId;

	FillMemory ( &feedinfo, sizeof (feedinfo), 0 );

	hr = ToFeedInfo ( &feedinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

    //
    // KangYan: RPC goes away. We use metabase writes
    //
    hr = SetFeedToMB(   &feedinfo,
                        pMK,
                        &dwParmErr,
                        dwInstance );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Set MB fail with 0x%x", hr );
        goto Exit;
    }

    hr = CheckConfirm( feedinfo.FeedId, dwInstance, pMK, &dwError, &dwParmErr );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Check confirm fail with 0x%x", hr );
        goto Exit;
    } 

	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to set feed[%d]: %x (%x)", m_dwFeedId, dwError, dwParmErr );
		hr = TranslateFeedError ( dwError, dwParmErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

DWORD GetBitPosition ( DWORD dwValue )
{
	_ASSERT ( dwValue != 0 );
	// _ASSERT ( Only one bit should be on );

	DWORD	dwResult;
	DWORD	dwTemp;

	for (	dwTemp = dwValue, dwResult = (DWORD) -1; 
			dwTemp != 0; 
			dwTemp = dwTemp >> 1, dwResult++ ) {
		// Empty for

		// Make sure there is at most one bit on:
		_ASSERT ( !(dwTemp & 1) || dwTemp == 1 );
	}

	return dwResult;
}

HRESULT	CFeed::TranslateFeedError ( DWORD dwErrorCode, DWORD dwParmErr )
{
	HRESULT		hr;

	_ASSERT ( dwErrorCode != NOERROR );

	if (    dwErrorCode != ERROR_INVALID_PARAMETER ||
            dwParmErr == 0 ||
            dwParmErr == (DWORD) -1 
            ) {
		hr = RETURNCODETOHRESULT ( dwErrorCode );
	}
	else {
		DWORD	dwBitPosition;
		DWORD	nID;

		dwBitPosition = GetBitPosition ( dwParmErr );
		nID = IDS_FEED_PARM_ERR_BASE + dwBitPosition;

		hr = NntpCreateException ( nID );
	}

	return hr;
}

#ifdef DEBUG

void CFeed::AssertValid ( ) const
{
	_ASSERT ( !IsBadWritePtr ( (void *) this, sizeof (*this) ) );

	//
	//	!!!magnush - Add more debug code here
	//
}

#endif

/////////////////////////////////////////////////////////////////////
//
//  CFeedPair Implementation
//

CFeedPair::CFeedPair () :
	m_type ( NNTP_FEED_TYPE_PEER ),
    m_pInbound ( NULL ),
    m_pOutbound ( NULL ),
    m_pNext     ( NULL )
{
}

CFeedPair::~CFeedPair ()
{
	AssertValid ();

    Destroy ();
}

void CFeedPair::Destroy ()
{
	AssertValid ();

    // !!!magnush - Fix reference counting problem here
    delete m_pInbound;
    delete m_pOutbound;

    m_pInbound = NULL; 
    m_pOutbound = NULL;
}

HRESULT CFeedPair::CreateFeedPair ( 
	CFeedPair ** 			ppNewFeedPair, 
	BSTR 					strRemoteServer,
	NNTP_FEED_SERVER_TYPE	type
	)
{
	_ASSERT ( IS_VALID_STRING (strRemoteServer) );

    HRESULT     hr  = NOERROR;
    CFeedPair *	pNewFeedPair;

	*ppNewFeedPair = NULL;

	// Allocate a new feed pair:
    pNewFeedPair = new CFeedPair;
    if ( pNewFeedPair == NULL ) {
    	BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

	// Copy properties:
	pNewFeedPair->m_strRemoteServer = strRemoteServer;
	pNewFeedPair->m_type = type;

	// Check for failed copy:
	if ( pNewFeedPair->m_strRemoteServer == NULL ) {
    	BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
	}

	// Set the out parameter to the new feed:
	*ppNewFeedPair = pNewFeedPair;

Exit:
	if ( FAILED(hr) ) {
		delete pNewFeedPair;
	}
	
    return hr;
}

HRESULT CFeedPair::AddFeed ( CFeed * pFeed )
{
	AssertValid ();

    HRESULT     hr  = NOERROR;

	_ASSERT ( IS_VALID_STRING ( m_strRemoteServer ) );
	_ASSERT ( IS_VALID_STRING ( pFeed->m_strRemoteServer ) );

	//
	//	Check error conditions:
	//		1. Different remote server name
	//		2. Different feed type
	//		3. Two inbound feeds
	//		4. Two outbound feeds
	//		5. Bad feed type
	//

	if ( lstrcmpi ( m_strRemoteServer, pFeed->m_strRemoteServer ) != 0 ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( m_type != pFeed->m_EnumType ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( IsInboundFeed ( pFeed ) && m_pInbound != NULL ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( IsOutboundFeed ( pFeed ) && m_pOutbound != NULL ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( !IsInboundFeed ( pFeed ) && !IsOutboundFeed ( pFeed ) ) {
        _ASSERT (FALSE);
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	//
	//	Everything is okay so take the feed into this pair:
	//

    if ( IsInboundFeed ( pFeed ) ) {
		m_pInbound = pFeed;
    }
    else {
    	// It's an outbound feed:
        m_pOutbound = pFeed;
    }

Exit:
    return hr;
}

HRESULT CFeedPair::FromINntpFeed ( INntpFeed * pFeed )
{
	AssertValid ();

    HRESULT                     hr              = NOERROR;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CFeed *                     pFeedInbound   = NULL;
    CFeed *                     pFeedOutbound   = NULL;

    m_strRemoteServer.Empty();
    pFeed->get_RemoteServer ( &m_strRemoteServer );
    pFeed->get_FeedType ( &m_type );

    pFeed->get_InboundFeed ( &pInbound );
    pFeed->get_OutboundFeed ( &pOutbound );

    if ( pInbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pInbound, &pFeedInbound );
        BAIL_ON_FAILURE(hr);

        pFeedInbound->m_strRemoteServer = m_strRemoteServer;
    }
    if ( pOutbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pOutbound, &pFeedOutbound );
        BAIL_ON_FAILURE(hr);

        pFeedOutbound->m_strRemoteServer = m_strRemoteServer;
    }

    delete m_pInbound;
    delete m_pOutbound;
    m_pInbound = pFeedInbound;
    m_pOutbound = pFeedOutbound;

Exit:
    if ( FAILED(hr) ) {
        delete pFeedInbound;
        delete pFeedOutbound;
    }

    return hr;
}

HRESULT CFeedPair::ToINntpFeed ( INntpFeed ** ppFeed )
{
	AssertValid ();

    CComObject<CNntpFeed> * pFeed   = NULL;

	HRESULT		hr	= NOERROR;

    hr = CComObject<CNntpFeed>::CreateInstance ( &pFeed );
    if ( FAILED(hr) ) { 
        goto Exit;
    }

    hr = pFeed->FromFeedPair ( this );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = pFeed->QueryInterface ( IID_INntpFeed, (void **) ppFeed );
    if ( FAILED(hr) ) {
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CFeedPair::AddIndividualFeed (  LPCWSTR strServer, 
                                        DWORD dwInstance, 
                                        CFeed * pFeed ,
                                        CMetabaseKey* pMK )
{
	AssertValid ();

	pFeed->m_dwPairFeedId		= 0;
	pFeed->m_EnumType			= m_type;
	pFeed->m_strRemoteServer	= m_strRemoteServer;

	return pFeed->Add ( strServer, dwInstance, pMK );
}

HRESULT CFeedPair::SetIndividualFeed ( LPCWSTR strServer, DWORD dwInstance, CFeed * pFeed, CMetabaseKey* pMK )
{
	AssertValid ();

	pFeed->m_dwPairFeedId		= 0;
	pFeed->m_EnumType			= m_type;
	pFeed->m_strRemoteServer	= m_strRemoteServer;

	return pFeed->Set ( strServer, dwInstance, pMK );
}

HRESULT	CFeedPair::SetPairIds ( LPCWSTR strServer, DWORD dwInstance, 
	CFeed * pFeed1, CFeed * pFeed2, CMetabaseKey* pMK )
{
	AssertValid ();

	HRESULT		hr	= NOERROR;
	DWORD		dwPairId1;
	DWORD		dwPairId2;

	dwPairId1 = pFeed2 ? pFeed2->m_dwFeedId : 0;
	dwPairId2 = pFeed1 ? pFeed1->m_dwFeedId : 0;

	if ( pFeed1 ) {
		hr = pFeed1->SetPairId ( strServer, dwInstance, dwPairId1, pMK );
		BAIL_ON_FAILURE(hr);
	}

	if ( pFeed2 ) {
		hr = pFeed2->SetPairId ( strServer, dwInstance, dwPairId2, pMK );
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT CFeedPair::AddToServer ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	AssertValid ();

    HRESULT     hr = E_UNEXPECTED;

    if ( m_pInbound ) {
    	hr = AddIndividualFeed ( strServer, dwInstance, m_pInbound, pMK );
    	BAIL_ON_FAILURE(hr);
    }

    if ( m_pOutbound ) {
    	hr = AddIndividualFeed ( strServer, dwInstance, m_pOutbound, pMK );
    	BAIL_ON_FAILURE(hr);
    }

	if ( m_pInbound && m_pOutbound ) {
		HRESULT		hr2;

		hr2 = SetPairIds ( strServer, dwInstance, m_pInbound, m_pOutbound, pMK );
		_ASSERT ( SUCCEEDED(hr2) );
	}

Exit:
    if ( FAILED(hr) ) {
		//
		//	Undo the add:
		//

		IErrorInfo *pErrorInfo = NULL;
		if (FAILED(GetErrorInfo(NULL, &pErrorInfo))) {
		    pErrorInfo = NULL;
		}

        if ( m_pInbound ) {
			m_pInbound->Remove ( strServer, dwInstance, pMK );
		}
		if ( m_pOutbound ) {
			m_pOutbound->Remove ( strServer, dwInstance, pMK );
		}

		if (pErrorInfo != NULL) {
		    SetErrorInfo(NULL, pErrorInfo);
		}
    }
    return hr;
}

HRESULT CFeedPair::UndoFeedAction ( 
	LPCWSTR strServer, 
	DWORD	dwInstance,
	CFeed *	pNewFeed,
	CFeed *	pOldFeed,
    CMetabaseKey* pMK
	)
{
	AssertValid ();

	HRESULT		hr	= NOERROR;

	if ( pNewFeed != NULL ) {
		if ( pOldFeed ) {
			hr = pOldFeed->Set ( strServer, dwInstance, pMK );
		}
		else {
			hr = pNewFeed->Remove ( strServer, dwInstance, pMK );
		}
	}

	return hr;
}

HRESULT CFeedPair::SetToServer ( LPCWSTR strServer, DWORD dwInstance, INntpFeed * pFeed, CMetabaseKey* pMK )
{
	AssertValid ();

    HRESULT                     hr = NOERROR;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CFeed *						pNewInbound		= NULL;
    CFeed *						pNewOutbound	= NULL;
    CComBSTR					strOldRemoteServer;

	strOldRemoteServer	= m_strRemoteServer;

	pFeed->get_RemoteServer ( &m_strRemoteServer );
    pFeed->get_InboundFeed ( &pInbound );
    pFeed->get_OutboundFeed ( &pOutbound );

	//
	//	Add the new feeds:
	//

	if ( !m_pInbound && pInbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pInbound, &pNewInbound );
        BAIL_ON_FAILURE(hr);

		hr = AddIndividualFeed ( strServer, dwInstance, pNewInbound, pMK );
        BAIL_ON_FAILURE(hr);
	}
	if ( !m_pOutbound && pOutbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pOutbound, &pNewOutbound );
        BAIL_ON_FAILURE(hr);

		hr = AddIndividualFeed ( strServer, dwInstance, pNewOutbound, pMK );
        BAIL_ON_FAILURE(hr);
	}

	//
	//	Set the existing feeds:
	//

    if ( m_pInbound && pInbound ) {
        // The Inbound feed exists already, so call set on it:
		hr = CFeed::CreateFeed ( &pNewInbound );
        BAIL_ON_FAILURE(hr);

		*pNewInbound = *m_pInbound;

		hr = pNewInbound->FromINntpOneWayFeed ( pInbound );
        BAIL_ON_FAILURE(hr);

		hr = SetIndividualFeed ( strServer, dwInstance, pNewInbound, pMK );
        BAIL_ON_FAILURE(hr);
    }

    if ( m_pOutbound && pOutbound ) {
        // The Outbound feed exists already, so call set on it:
		hr = CFeed::CreateFeed ( &pNewOutbound );
        BAIL_ON_FAILURE(hr);

		*pNewOutbound = *m_pOutbound;

		hr = pNewOutbound->FromINntpOneWayFeed ( pOutbound );
        BAIL_ON_FAILURE(hr);

		hr = SetIndividualFeed ( strServer, dwInstance, pNewOutbound, pMK );
        BAIL_ON_FAILURE(hr);
    }
    
	//
	//	Remove the deleted feeds:
	//

	if ( m_pInbound && !pInbound ) {
		HRESULT		hr2;

		hr2 = m_pInbound->Remove ( strServer, dwInstance, pMK );
		_ASSERT ( SUCCEEDED(hr2) );
	}

	if ( m_pOutbound && !pOutbound ) {
		HRESULT		hr2;
		
		hr2 = m_pOutbound->Remove ( strServer, dwInstance, pMK );
		_ASSERT ( SUCCEEDED(hr2) );
	}

	SetPairIds ( strServer, dwInstance, pNewInbound, pNewOutbound, pMK );

	_ASSERT ( SUCCEEDED(hr) );

	delete m_pInbound;
	delete m_pOutbound;
	m_pInbound	= pNewInbound;
	m_pOutbound	= pNewOutbound;

Exit:
	if ( FAILED(hr) ) {
		//
		// Attempt to back out the changes:
		//

		UndoFeedAction ( strServer, dwInstance, pNewInbound, m_pInbound, pMK );

		UndoFeedAction ( strServer, dwInstance, pNewOutbound, m_pOutbound, pMK );
		if ( pNewOutbound ) {
			if ( m_pOutbound ) {
				m_pOutbound->Set ( strServer, dwInstance, pMK );
			}
			else {
				pNewOutbound->Remove ( strServer, dwInstance, pMK );
			}
		}

		delete pNewInbound;
		delete pNewOutbound;

		m_strRemoteServer = strOldRemoteServer;
	}
    return hr;
}

HRESULT CFeedPair::RemoveFromServer ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	AssertValid ();

    HRESULT     hr  = NOERROR;

    if ( m_pInbound ) {
        hr = m_pInbound->Remove ( strServer, dwInstance, pMK );
    }
    if ( m_pOutbound ) {
        hr = m_pOutbound->Remove ( strServer, dwInstance, pMK );
    }

    return hr;
}

BOOL CFeedPair::ContainsFeedId ( DWORD dwFeedId )
{
	AssertValid ();

    if ( m_pInbound && m_pInbound->m_dwFeedId == dwFeedId ) {
        return TRUE;
    }
    if ( m_pOutbound && m_pOutbound->m_dwFeedId == dwFeedId ) {
        return TRUE;
    }

    return FALSE;
}

#ifdef DEBUG

void CFeedPair::AssertValid ( ) const
{
	_ASSERT ( !IsBadWritePtr ( (void *) this, sizeof (*this) ) );

	if ( m_pInbound ) {
		m_pInbound->AssertValid ();
	}

	if ( m_pOutbound ) {
		m_pOutbound->AssertValid ();
	}
}

#endif

/////////////////////////////////////////////////////////////////////
//
//  CFeedPairList Implementation
//

CFeedPairList::CFeedPairList () :
    m_cCount    ( 0 ),
    m_pHead     ( NULL ),
    m_pTail     ( NULL )
{
}

CFeedPairList::~CFeedPairList ()
{
	AssertValid ();
	
    Empty();
}

DWORD CFeedPairList::GetCount ( ) const
{
	AssertValid ();

    return m_cCount;
}

void CFeedPairList::Empty ( )
{
	AssertValid ();

    CFeedPair * pPair;
    CFeedPair * pKill;

    pPair = m_pHead;
    while ( pPair ) {
        pKill = pPair;
        pPair = pPair->m_pNext;
        delete pKill;
    }

    m_cCount    = 0;
    m_pHead     = NULL;
    m_pTail     = NULL;
}

CFeedPair * CFeedPairList::Item ( DWORD index )
{
	AssertValid ();

    CFeedPair * pResult = NULL;
    DWORD       i;

    if ( index >= m_cCount ) {
        return NULL;
    }

    pResult = m_pHead;
    _ASSERT ( pResult );

    for ( i = 0; i < index; i++ ) {
        pResult = pResult->m_pNext;
        _ASSERT ( pResult );
    }

    return pResult;
}

void CFeedPairList::Add ( CFeedPair * pFeedPair )
{
	AssertValid ();
    _ASSERT ( GetPairIndex ( pFeedPair ) == (DWORD) -1 );

    pFeedPair->m_pNext  = NULL;

    if ( m_pTail == NULL ) {
        //
        //  Handle special case - Adding to empty list:
        //

        _ASSERT ( m_pHead == NULL );

        m_pHead = pFeedPair;
        m_pTail = pFeedPair;
    }
    else {
        m_pTail->m_pNext = pFeedPair;
        m_pTail = pFeedPair;
    }
	m_cCount++;
}

void CFeedPairList::Remove ( CFeedPair * pFeedPair )
{
	AssertValid ();
    _ASSERT ( GetPairIndex ( pFeedPair ) != (DWORD) -1 );

    CFeedPair * pLead;
    CFeedPair * pFollow;

    for ( pLead = m_pHead, pFollow = NULL;
            pLead != NULL && pLead != pFeedPair;
            pFollow = pLead, pLead = pLead->m_pNext
            ) {
        // Empty For
    }
    _ASSERT ( pLead );
    if ( !pLead ) {
        return;
    }

    if ( pFollow != NULL ) {
        pFollow->m_pNext = pLead->m_pNext;
    }
    if ( m_pHead == pFeedPair ) {
        m_pHead = m_pHead->m_pNext;
    }
    if ( m_pTail == pFeedPair ) {
        m_pTail = pFollow;
    }

    delete pFeedPair;
	m_cCount--;
}

CFeedPair * CFeedPairList::Find ( DWORD dwFeedId )
{
	AssertValid ();
    CFeedPair   * pResult;

    if ( dwFeedId == 0 ) {
        return NULL;
    }

    for ( pResult = m_pHead; pResult != NULL; pResult = pResult->m_pNext ) {
        if ( pResult->ContainsFeedId ( dwFeedId ) ) {
            return pResult;
        }
    }

    return NULL;
}

DWORD CFeedPairList::GetPairIndex ( CFeedPair * pPairToFind ) const
{
	AssertValid ();
    _ASSERT ( pPairToFind );

    DWORD       index;
    CFeedPair * pFeedPair;

    for ( pFeedPair = m_pHead, index = 0;
            pFeedPair != NULL;
            pFeedPair = pFeedPair->m_pNext, index++ ) {

        if ( pFeedPair == pPairToFind ) {
            return index;
        }
    }

    return (DWORD) -1;
}

#ifdef DEBUG

void CFeedPairList::AssertValid ( ) const
{
	_ASSERT ( !IsBadWritePtr ( (void *) this, sizeof (*this) ) );

	// Walk the list and assert each feed pair is valid:

	CFeedPair *	pPair;
	DWORD		cCount;

	for ( cCount = 0, pPair = m_pHead; 
			pPair != NULL; 
			pPair = pPair->m_pNext, cCount++ 
			) {
		_ASSERT ( !IsBadWritePtr ( pPair, sizeof (*pPair) ) );

		_ASSERT ( IS_VALID_STRING ( pPair->m_strRemoteServer ) );

		_ASSERT ( pPair->m_pInbound || pPair->m_pOutbound );

		if ( pPair->m_pInbound ) {
			_ASSERT ( IS_VALID_STRING ( pPair->m_pInbound->m_strRemoteServer ) );
			_ASSERT ( !lstrcmpi ( pPair->m_pInbound->m_strRemoteServer, pPair->m_strRemoteServer ) );
		}
		if ( pPair->m_pOutbound ) {
			_ASSERT ( IS_VALID_STRING ( pPair->m_pOutbound->m_strRemoteServer ) );
			_ASSERT ( !lstrcmpi ( pPair->m_pOutbound->m_strRemoteServer, pPair->m_strRemoteServer ) );
		}
	}

	_ASSERT ( m_cCount == cCount );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\expire.cpp ===
// expire.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "expire.h"
#include "oleutil.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Expiration.1")
#define THIS_FILE_IID				IID_INntpAdminExpiration

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminExpiration, CNntpAdminExpiration, IID_INntpAdminExpiration)

STDMETHODIMP CNntpAdminExpiration::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminExpiration,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminExpiration::CNntpAdminExpiration () :
	m_fEnumerated				( FALSE ),
	m_bvChangedFields			( 0 ),
	m_cCount					( 0 ),
	m_rgExpires					( NULL )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Expires") );
    m_iadsImpl.SetClass ( _T("IIsNntpExpires") );
}

CNntpAdminExpiration::~CNntpAdminExpiration ()
{
	// All CComBSTR's are freed automatically.

	if ( m_rgExpires ) {
		delete [] m_rgExpires;

		m_rgExpires = NULL;
	}

	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminExpiration,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Enumeration Properties:

STDMETHODIMP CNntpAdminExpiration::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_cCount, plCount );
}

// Cursor Expire Properties:

STDMETHODIMP CNntpAdminExpiration::get_ExpireId ( long * plId )
{
	return StdPropertyGet ( m_expireCurrent.m_dwExpireId, plId );
}

STDMETHODIMP CNntpAdminExpiration::put_ExpireId ( long lId )
{
	return StdPropertyPut ( &m_expireCurrent.m_dwExpireId, lId, &m_bvChangedFields, CHNG_EXPIRE_ID );
}

STDMETHODIMP CNntpAdminExpiration::get_PolicyName ( BSTR * pstrPolicyName )
{
	return StdPropertyGet ( m_expireCurrent.m_strPolicyName, pstrPolicyName );
}

STDMETHODIMP CNntpAdminExpiration::put_PolicyName ( BSTR strPolicyName )
{
	return StdPropertyPut ( &m_expireCurrent.m_strPolicyName, strPolicyName, &m_bvChangedFields, CHNG_EXPIRE_POLICY_NAME );
}

STDMETHODIMP CNntpAdminExpiration::get_ExpireTime ( long * plExpireTime )
{
	return StdPropertyGet ( m_expireCurrent.m_dwTime, plExpireTime );
}

STDMETHODIMP CNntpAdminExpiration::put_ExpireTime ( long lExpireTime )
{
	return StdPropertyPut ( &m_expireCurrent.m_dwTime, lExpireTime, &m_bvChangedFields, CHNG_EXPIRE_TIME );
}

STDMETHODIMP CNntpAdminExpiration::get_ExpireSize ( long * plExpireSize )
{
	return StdPropertyGet ( m_expireCurrent.m_dwSize, plExpireSize );
}

STDMETHODIMP CNntpAdminExpiration::put_ExpireSize ( long lExpireSize )
{
	return StdPropertyPut ( &m_expireCurrent.m_dwSize, lExpireSize, &m_bvChangedFields, CHNG_EXPIRE_SIZE );
}

STDMETHODIMP CNntpAdminExpiration::get_Newsgroups ( SAFEARRAY ** ppsastrNewsgroups )
{
	return StdPropertyGet ( &m_expireCurrent.m_mszNewsgroups, ppsastrNewsgroups );
}

STDMETHODIMP CNntpAdminExpiration::put_Newsgroups ( SAFEARRAY * psastrNewsgroups )
{
	return StdPropertyPut ( &m_expireCurrent.m_mszNewsgroups, psastrNewsgroups, &m_bvChangedFields, CHNG_EXPIRE_NEWSGROUPS );
}

STDMETHODIMP CNntpAdminExpiration::get_NewsgroupsVariant ( SAFEARRAY ** ppsavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = get_Newsgroups ( &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrNewsgroups, ppsavarNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

STDMETHODIMP CNntpAdminExpiration::put_NewsgroupsVariant ( SAFEARRAY * psavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = VariantArrayToStringArray ( psavarNewsgroups, &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_Newsgroups ( psastrNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminExpiration::Default	( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Default" );
	HRESULT		hr	= NOERROR;

	m_expireCurrent.m_dwSize			= DEFAULT_EXPIRE_SIZE;
	m_expireCurrent.m_dwTime			= DEFAULT_EXPIRE_TIME;
	m_expireCurrent.m_mszNewsgroups		= DEFAULT_EXPIRE_NEWSGROUPS;

	m_bvChangedFields	= (DWORD) -1;

	if ( !m_expireCurrent.CheckValid() ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Enumerate	( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Enumerate" );

	HRESULT				hr			= NOERROR;
	DWORD				dwError		= NOERROR;
	DWORD				cExpires		= 0;
	LPNNTP_EXPIRE_INFO	pExpireInfo	= NULL;
	CExpirationPolicy * 			rgNewExpires	= NULL;
	DWORD				i;

	dwError = NntpEnumerateExpires (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &cExpires,
        &pExpireInfo
        );
	if ( dwError != 0 ) {
		ErrorTrace ( (LPARAM) this, "Error enumerating Expires: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	// Empty the old Expire list:
	m_fEnumerated = FALSE;

	if ( m_rgExpires ) {
		delete [] m_rgExpires;
		m_rgExpires 	= NULL;
	}
	m_cCount	= 0;

	// Attempt to copy the Expire list into our structures:

	if ( cExpires > 0 ) {
		rgNewExpires = new CExpirationPolicy [ cExpires ];
		for ( i = 0; i < cExpires; i++ ) {
			rgNewExpires[i].FromExpireInfo ( &pExpireInfo[i] );

			if ( !rgNewExpires[i].CheckValid () ) {
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
		}
	}

	m_fEnumerated 	= TRUE;
	m_rgExpires		= rgNewExpires;
	m_cCount		= cExpires;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgNewExpires;
	}

	if ( pExpireInfo ) {
		::NetApiBufferFree ( pExpireInfo );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::GetNth	( long lIndex )
{
	TraceFunctEnter ( "CNntpAdminExpiration::GetNth" );

	HRESULT		hr	= NOERROR;

	// Did we enumerate first?
	if ( m_rgExpires == NULL ) {
		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_rgExpires [ lIndex ] to member variables:
	//

	_ASSERT ( lIndex >= 0 );
	_ASSERT ( (DWORD) lIndex < m_cCount );
	_ASSERT ( m_rgExpires != NULL );

	m_expireCurrent = m_rgExpires[ (DWORD) lIndex ];

	// Check to make sure the strings were copied okay:
	if ( !m_expireCurrent.CheckValid() ) {
		return E_OUTOFMEMORY;
	}

	_ASSERT ( m_expireCurrent.CheckValid() );

	// ( CComBSTR handles free-ing of old properties )
	TraceFunctLeave ();
	return NOERROR;
}

STDMETHODIMP CNntpAdminExpiration::FindID ( long lID, long * plIndex )
{
	TraceFunctEnter ( "CNntpAdminExpiration::FindID" );

	HRESULT		hr	= NOERROR;

	// Assume that we can't find it:
	*plIndex = IndexFromID ( lID );

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Add ( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Add" );

	HRESULT		            hr 				= NOERROR;
	CExpirationPolicy *		rgNewExpireArray	= NULL;
	DWORD		            cNewCount		= m_cCount + 1;
	DWORD		            i;

	hr = m_expireCurrent.Add (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
    BAIL_ON_FAILURE(hr);

	// Add the new Expire to our current Expire list:
	_ASSERT ( IndexFromID ( m_expireCurrent.m_dwExpireId ) == (DWORD) -1 );

	// Allocate the new array:
	_ASSERT ( cNewCount == m_cCount + 1 );

	rgNewExpireArray = new CExpirationPolicy [ cNewCount ];
	if ( rgNewExpireArray == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );

		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Copy the old array into the new one:
	for ( i = 0; i < m_cCount; i++ ) {
		rgNewExpireArray[i] = m_rgExpires[i];
	}

	// Add the new element:
	rgNewExpireArray[cNewCount - 1] = m_expireCurrent;

	// Check to make sure everything was allocated okay:
	for ( i = 0; i < cNewCount; i++ ) {
		if ( !rgNewExpireArray[i].CheckValid() ) {
			FatalTrace ( (LPARAM) this, "Out of memory" );

			hr = E_OUTOFMEMORY;
			goto Exit;
		}
	}

	// Replace the old array with the new one:
	delete [] m_rgExpires;
	m_rgExpires 	= rgNewExpireArray;
	m_cCount	= cNewCount;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgNewExpireArray;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Set ( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Set" );

	HRESULT		hr = NOERROR;
	DWORD		index;

	hr = m_expireCurrent.Set (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	index = IndexFromID ( m_expireCurrent.m_dwExpireId );
	if ( index == (DWORD) -1 ) {
		ErrorTraceX ( (LPARAM) this, "Couldn't find Expire with ID: %d", m_expireCurrent.m_dwExpireId );
		// This is okay, since we succeeded in setting the current Expire already.
		goto Exit;
	}

	// Set the current Expire in the current Expire list:

	m_rgExpires[index] = m_expireCurrent;

	if ( !m_rgExpires[index].CheckValid () ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );

		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Remove ( long lID )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Remove" );

	HRESULT		hr = NOERROR;
	DWORD		index;

	index = IndexFromID ( lID );
	if ( index == (DWORD) -1 ) {
		ErrorTraceX ( (LPARAM) this, "Couldn't find Expire with ID: %d", lID );
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = m_rgExpires[index].Remove (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	//	Slide the array down by one position:

	_ASSERT ( m_rgExpires );

	DWORD	cPositionsToSlide;

	cPositionsToSlide	= (m_cCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_cCount );

	if ( cPositionsToSlide > 0 ) {
		CExpirationPolicy	temp;
		
		// Save the deleted binding in temp:
		CopyMemory ( &temp, &m_rgExpires[index], sizeof ( CExpirationPolicy ) );

		// Move the array down one:
		MoveMemory ( &m_rgExpires[index], &m_rgExpires[index + 1], sizeof ( CExpirationPolicy ) * cPositionsToSlide );

		// Put the deleted binding on the end (so it gets destructed):
		CopyMemory ( &m_rgExpires[m_cCount - 1], &temp, sizeof ( CExpirationPolicy ) );

		// Zero out the temp binding:
		ZeroMemory ( &temp, sizeof ( CExpirationPolicy ) );
	}

	m_cCount--;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

long CNntpAdminExpiration::IndexFromID ( long dwExpireId )
{
	TraceFunctEnter ( "CNntpAdminExpiration::IndexFromID" );

	DWORD	i;

	if ( m_rgExpires == NULL ) {
		return -1;
	}

	_ASSERT ( !IsBadReadPtr ( m_rgExpires, sizeof ( CExpirationPolicy ) * m_cCount ) );

	for ( i = 0; i < m_cCount; i++ ) {
		_ASSERT ( m_rgExpires[i].m_dwExpireId != 0 );

		if ( (DWORD) dwExpireId == m_rgExpires[i].m_dwExpireId ) {
			TraceFunctLeave ();
			return i;
		}
	}

	TraceFunctLeave ();
	return (DWORD) -1;
}

//
// Use RPCs instead of direct metabase calls:
//

#if 0

STDMETHODIMP CNntpAdminExpiration::Enumerate ( )
{
	TraceFunctEnter ( "CNntpadminExpiration::Enumerate" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Reset our last enumeration:
	delete [] m_rgExpires;
	m_rgExpires 	= NULL;
	m_cCount		= 0;
	m_fEnumerated	= FALSE;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Enumerate the policies:
	hr = EnumerateMetabaseExpirationPolicies ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::GetNth	( DWORD lIndex )
{
	HRESULT		hr	= NOERROR;

	// Did we enumerate first?
	if ( m_rgExpires == NULL ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_rgExpires [ lIndex ] to member variables:
	//

	_ASSERT ( lIndex >= 0 );
	_ASSERT ( (DWORD) lIndex < m_cCount );
	_ASSERT ( m_rgExpires != NULL );

	m_expireCurrent = m_rgExpires[ (DWORD) lIndex ];

	// Check to make sure the strings were copied okay:
	if ( !m_expireCurrent.CheckValid() ) {
		return E_OUTOFMEMORY;
	}

	m_bvChangedFields	= 0;

	_ASSERT ( m_expireCurrent.CheckValid() );

	// ( CComBSTR handles free-ing of old properties )
	return NOERROR;
}

STDMETHODIMP CNntpAdminExpiration::FindID ( DWORD lID, DWORD * plIndex )
{
	TraceFunctEnter ( "CNntpAdminExpiration::FindID" );

	HRESULT		hr	= NOERROR;
	DWORD		i;

	_ASSERT ( IS_VALID_OUT_PARAM ( plIndex ) );

	*plIndex = IndexFromID ( lID );

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Add ( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Add" );
	
	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = AddPolicyToMetabase ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	m_bvChangedFields = 0;
	hr = AddPolicyToArray ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Set		( BOOL fFailIfChanged)
{
	TraceFunctEnter ( "CNntpadminExpiration::Enumerate" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Set the policy:
	hr = SetPolicyToMetabase ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}
	
	m_bvChangedFields = 0;
	hr = SetPolicyToArray ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Remove	( DWORD lID)
{
	TraceFunctEnter ( "CNntpadminExpiration::Remove" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;
	DWORD				index;

	// Find the index of the policy to remove:
	index = IndexFromID ( lID );

	if ( index == (DWORD) -1 ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Remove the current policy:
	hr = RemovePolicyFromMetabase ( pMetabase, index );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = RemovePolicyFromArray ( index );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT	CNntpAdminExpiration::EnumerateMetabaseExpirationPolicies ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNE::EnumerateMetabaseExpirationPolicies" );

	_ASSERT ( pMetabase );

	HRESULT				hr		= NOERROR;
	char				szExpirationPath[ METADATA_MAX_NAME_LEN ];
	METADATA_HANDLE		hExpiration	= NULL;
	CMetabaseKey		mkeyExpiration	( pMetabase );
	DWORD				cExpires;
	DWORD				i;

	_ASSERT ( m_dwServiceInstance != 0 );

	hr = CreateSubkeyOfInstanceKey ( 
		pMetabase, 
		NNTP_MD_ROOT_PATH, 
		m_dwServiceInstance, 
		NNTP_MD_EXPIRES_PATH, 
		&hExpiration 
		);

	if ( FAILED(hr) ) {
		goto Exit;
	}

	mkeyExpiration.Attach ( hExpiration );

	// Count the items under the /LM/NntpSvc/Expires/ key:
	hr = mkeyExpiration.GetCustomChildCount ( IsKeyValidExpire, &cExpires );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	if ( cExpires != 0 ) {
		// Allocate the expiration policy array:
		m_rgExpires = new CExpirationPolicy [ cExpires ];

		mkeyExpiration.BeginChildEnumeration ();

		for ( i = 0; i < cExpires; i++ ) {
			char		szName[ METADATA_MAX_NAME_LEN ];
			DWORD		dwID;

			hr = mkeyExpiration.NextCustomChild ( IsKeyValidExpire, szName );
			_ASSERT ( SUCCEEDED(hr) );

			hr = m_rgExpires[i].GetFromMetabase ( &mkeyExpiration, szName );
			if ( FAILED (hr) ) {
				goto Exit;
			}
		}
	}

	m_cCount		= cExpires;
	m_fEnumerated	= TRUE;

	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) ) {
		delete [] m_rgExpires;
		m_rgExpires		= NULL;
		m_cCount		= 0;
		m_fEnumerated	= FALSE;
	}

	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::AddPolicyToMetabase ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNE::AddPolicyToMetabase" );

	_ASSERT ( pMetabase );

	HRESULT				hr = NOERROR;
	char				szExpirationPath [ METADATA_MAX_NAME_LEN ];
	METADATA_HANDLE		hExpiration	= NULL;
	CMetabaseKey		mkeyExpiration ( pMetabase );
	char				szNewId [ METADATA_MAX_NAME_LEN ];
	DWORD				dwNewId;

	if ( !m_expireCurrent.CheckPolicyProperties ( ) ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	hr = CreateSubkeyOfInstanceKey ( 
		pMetabase,
		NNTP_MD_ROOT_PATH,
		m_dwServiceInstance,
		NNTP_MD_EXPIRES_PATH,
		&hExpiration,
		METADATA_PERMISSION_WRITE
		);
		
	if ( FAILED(hr) ) {
		goto Exit;
	}

	mkeyExpiration.Attach ( hExpiration );

	hr = m_expireCurrent.AddToMetabase ( &mkeyExpiration );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	
	hr = pMetabase->SaveData ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::AddPolicyToArray ( )
{
	TraceFunctEnter ( "CNE::AddPolicyToArray" );

	HRESULT					hr 					= NOERROR;
	CExpirationPolicy *		rgNewPolicyArray 	= NULL;
	DWORD					i;

	// Adjust the expiration policy array:
	rgNewPolicyArray = new CExpirationPolicy [ m_cCount + 1 ];

	if ( rgNewPolicyArray == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Copy the old entries:
	for ( i = 0; i < m_cCount; i++ ) {
		_ASSERT ( m_rgExpires[i].CheckValid() );
		rgNewPolicyArray[i] = m_rgExpires[i];

		if ( !rgNewPolicyArray[i].CheckValid() ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}
	}

	// Add the new entry:
	_ASSERT ( m_expireCurrent.CheckValid() );
	rgNewPolicyArray[m_cCount] = m_expireCurrent;
	if ( !rgNewPolicyArray[m_cCount].CheckValid() ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgExpires;
	m_rgExpires = rgNewPolicyArray;
	m_cCount++;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgNewPolicyArray;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::SetPolicyToMetabase ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNE::SetPolicyToMetabase" );

	_ASSERT ( pMetabase );

	HRESULT			hr = NOERROR;
	CMetabaseKey	mkeyExpiration ( pMetabase );
	char			szExpirationPath [ METADATA_MAX_NAME_LEN ];

	if ( !m_expireCurrent.CheckPolicyProperties ( ) ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	GetMDExpirationPath ( szExpirationPath, m_dwServiceInstance );

	hr = mkeyExpiration.Open ( szExpirationPath, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( m_expireCurrent.m_dwExpireId != 0 );

	hr = m_expireCurrent.SendToMetabase ( &mkeyExpiration, m_bvChangedFields );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pMetabase->SaveData ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::SetPolicyToArray ( )
{
	TraceFunctEnter ( "CNE::SetPolicyToArray" );

	HRESULT	hr	= NOERROR;

	// Find the index of the current ID:
	DWORD	i;
	BOOL	fFound	= FALSE;
	DWORD	index;

	index = IndexFromID ( m_expireCurrent.m_dwExpireId );
	if ( index == (DWORD) -1 ) {
		// Couldn't find an id that matched, but the policy was successfully
		// set.  Just ignore:
		goto Exit;
	}

	_ASSERT ( index >= 0 && index < m_cCount );

	m_rgExpires[index] = m_expireCurrent;
	if ( !m_rgExpires[index].CheckValid() ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::RemovePolicyFromMetabase ( IMSAdminBase * pMetabase, DWORD index)
{
	TraceFunctEnter ( "CNE::RemovePolicyFromMetabase" );

	_ASSERT ( pMetabase );

	HRESULT				hr = NOERROR;
	CMetabaseKey		mkeyExpiration ( pMetabase );
	char				szExpirationPath [ METADATA_MAX_NAME_LEN ];
	char				szID [ METADATA_MAX_NAME_LEN ];

	GetMDExpirationPath ( szExpirationPath, m_dwServiceInstance );

	hr = mkeyExpiration.Open ( szExpirationPath, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( index >= 0 && index < m_cCount );

	wsprintfA ( szID, "expire%ud", m_rgExpires[index].m_dwExpireId );

	hr = mkeyExpiration.DestroyChild ( szID );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );

	hr = pMetabase->SaveData ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::RemovePolicyFromArray ( DWORD index )
{
	TraceFunctEnter ( "CNE::RemovePolicyFromArray" );

	HRESULT				hr					= NOERROR;
	CExpirationPolicy *	rgNewExpireArray	= NULL;
	DWORD				i;

	// !!!magnush - Should I just do a memmove and slide the entries
	// down, and zero out the last entry?

	_ASSERT ( index >= 0 && index < m_cCount );

	// Adjust the Expiration policy array:
	if ( m_cCount > 1 ) {
		// Allocate a new expiration policy array:
		rgNewExpireArray = new CExpirationPolicy [ m_cCount - 1 ];

		// Copy the items from 0 .. (current index) to the new list:
		for ( i = 0; i < index; i++ ) {
			_ASSERT ( m_rgExpires[i].CheckValid() );

			rgNewExpireArray[i] = m_rgExpires[i];

			if ( !rgNewExpireArray[i].CheckValid() ) {
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
		}

		// Copy the items from (current index + 1) .. m_cCount to the new list:
		for ( i = index + 1; i < m_cCount; i++ ) {
			_ASSERT ( m_rgExpires[i].CheckValid() );

			rgNewExpireArray[i - 1] = m_rgExpires[i];

			if ( !rgNewExpireArray[i - 1].CheckValid() ) {
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
		}
	}

	_ASSERT ( SUCCEEDED(hr) );

	// Replace the old expiration list with the new one:
	delete [] m_rgExpires;
	m_rgExpires = rgNewExpireArray;
	m_cCount--;

Exit:
	if ( FAILED (hr) ) {
		delete [] rgNewExpireArray;
	}

	TraceFunctLeave ();
	return hr;
}

long CNntpAdminExpiration::IndexFromID ( long dwID )
{
	TraceFunctEnter ( "CNE::IndexFromID" );

	DWORD	i;

	if ( m_rgExpires == NULL ) {

		DebugTrace ( (LPARAM) this, "Expire array is NULL" );
		TraceFunctLeave ();

		return (DWORD) -1;
	}

	_ASSERT ( !IsBadReadPtr ( m_rgExpires, sizeof ( CExpirationPolicy ) * m_cCount ) );

	for ( i = 0; i < m_cCount; i++ ) {
		if ( m_rgExpires[i].m_dwExpireId == dwID ) {

			DebugTraceX ( (LPARAM) this, "Found ID: %d, index = ", dwID, i );
			TraceFunctLeave ();

			return i;
		}
	}

	DebugTraceX ( (LPARAM) this, "Failed to find ID: %d", dwID );
	TraceFunctLeave ();
	return (DWORD) -1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\feedinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	feedinfo.h

Abstract:

	Defines the CFeed class that maintains all properties about a feed.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _FEEDINFO_INCLUDED_
#define _FEEDINFO_INCLUDED_

// Dependencies

#include "cmultisz.h"
#include "metakey.h"

typedef struct _NNTP_FEED_INFO NNTP_FEED_INFO, * LPNNTP_FEED_INFO;
typedef DWORD FEED_TYPE;

//
//  Forward declarations:
//

class CFeed;
class CFeedPair;
class CFeedPairList;

NNTP_FEED_SERVER_TYPE FeedTypeToEnum ( FEED_TYPE ft );
void EnumToFeedType ( NNTP_FEED_SERVER_TYPE type, FEED_TYPE & ftMask );

//$-------------------------------------------------------------------
//
//	Class:
//		CFeed
//
//	Description:
//
//--------------------------------------------------------------------

class CFeed
{
    friend class CFeedPair;
    friend class CFeedPairList;

public:
    //
    //  Creating CFeed objects:
    //
    static HRESULT CreateFeed ( CFeed ** ppNewFeed );
    static HRESULT CreateFeedFromFeedInfo ( LPNNTP_FEED_INFO pFeedInfo, CFeed ** ppNewFeed );
    static HRESULT CreateFeedFromINntpOneWayFeed ( INntpOneWayFeed * pFeed, CFeed ** ppNewFeed );

	CFeed	( );
	~CFeed	( );
	void	Destroy ();

	const CFeed & operator= ( const CFeed & feed );
	inline const CFeed & operator= ( const NNTP_FEED_INFO & feed ) {
		FromFeedInfo ( &feed );
		return *this;
	}

	//
	//	Conversion routines:
	//

	HRESULT		ToFeedInfo		( LPNNTP_FEED_INFO 		pFeedInfo );
	HRESULT		FromFeedInfo	( const NNTP_FEED_INFO * pFeedInfo );
	HRESULT		ToINntpOneWayFeed	( INntpOneWayFeed ** ppFeed );
	HRESULT		FromINntpOneWayFeed	( INntpOneWayFeed * pFeed );

	//
	//	Communicating changes to the service:
	//

	HRESULT		Add 	( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );
	HRESULT		Remove 	( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );
	HRESULT		Set 	( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );

	HRESULT		SetPairId ( LPCWSTR strServer, DWORD dwInstance, DWORD dwPairId, CMetabaseKey* pMK );

	// Feed Properties:
public:
	DWORD		m_dwFeedId;
	DWORD		m_dwPairFeedId;
	FEED_TYPE	m_FeedType;
	BOOL		m_fAllowControlMessages;
	DWORD		m_dwAuthenticationType;
	DWORD		m_dwConcurrentSessions;
	BOOL		m_fCreateAutomatically;
	BOOL		m_fEnabled;
	CMultiSz	m_mszDistributions;
	DWORD		m_dwFeedInterval;
	DATE		m_datePullNews;
	DWORD		m_dwMaxConnectionAttempts;
	CMultiSz	m_mszNewsgroups;
	DWORD		m_dwSecurityType;
	DWORD		m_dwOutgoingPort;
	CComBSTR	m_strUucpName;
	CComBSTR	m_strAccountName;
	CComBSTR	m_strPassword;
	CComBSTR	m_strTempDirectory;

	//
	//	CFeedPair sets these:
	//
	NNTP_FEED_SERVER_TYPE	m_EnumType;
	CComBSTR				m_strRemoteServer;

	//
	//	Routines to help property gets/puts:
	//

	HRESULT	get_FeedAction	( NNTP_FEED_ACTION * feedaction );
	HRESULT	put_FeedAction	( NNTP_FEED_ACTION feedaction );

	BOOL	CheckValid () const;

private:
#ifdef DEBUG
	void		AssertValid	( ) const;
#else
	inline void AssertValid ( ) const { }
#endif

private:
	HRESULT	TranslateFeedError ( DWORD dwErrorCode, DWORD dwParmErr = 0 );
    HRESULT CheckConfirm(   DWORD dwFeedId, 
                            DWORD dwInstanceId,
                            CMetabaseKey* pMK,
                            PDWORD pdwErr,
                            PDWORD pdwErrMask );

	// Don't call the copy constructor:
	CFeed ( const CFeed & );
};

//$-------------------------------------------------------------------
//
//	Class:
//		CFeedPair
//
//	Description:
//
//--------------------------------------------------------------------

class CFeedPair
{
	friend class CNntpFeed;
    friend class CFeedPairList;

public:
    CFeedPair();
    ~CFeedPair();

    static  HRESULT CreateFeedPair ( 
    	CFeedPair ** 			ppNewFeedPair, 
    	BSTR 					strRemoteServer,
    	NNTP_FEED_SERVER_TYPE	type
    	);
    void    Destroy ();

    HRESULT AddFeed         ( CFeed * pFeed );
    BOOL    ContainsFeedId  ( DWORD dwFeedId );

	//	Routines to help property gets/puts:
	HRESULT	get_FeedType	( NNTP_FEED_SERVER_TYPE * feedtype );
	HRESULT	put_FeedType	( NNTP_FEED_SERVER_TYPE feedtype );

    // CFeedPair <-> OLE INntpFeedPair:
    HRESULT ToINntpFeed     ( INntpFeed ** ppFeed );
    HRESULT FromINntpFeed   ( INntpFeed * pFeed );

    // Talking with the Server:
    HRESULT AddToServer         ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );
    HRESULT SetToServer         ( LPCWSTR strServer, DWORD dwInstance, INntpFeed * pFeed, CMetabaseKey* pMK );
    HRESULT RemoveFromServer    ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );

private:
	HRESULT	AddIndividualFeed ( LPCWSTR strServer, DWORD dwInstance, CFeed * pFeed, CMetabaseKey* pMK );
	HRESULT SetIndividualFeed ( LPCWSTR strServer, DWORD dwInstance, CFeed * pFeed, CMetabaseKey* pMK );
	HRESULT	SetPairIds ( 
		LPCWSTR		strServer, 
		DWORD		dwInstance, 
		CFeed *		pFeed1, 
		CFeed *		pFeed2,
		CMetabaseKey* pMK
		);
	HRESULT	UndoFeedAction ( 
		LPCWSTR strServer, 
		DWORD	dwInstance, 
		CFeed *	pNewFeed, 
		CFeed *	pOldFeed ,
        CMetabaseKey* pMK
		);

    CComBSTR        		m_strRemoteServer;
    NNTP_FEED_SERVER_TYPE	m_type;
    CFeed *         		m_pInbound;
    CFeed *         		m_pOutbound;
    CFeedPair *     		m_pNext;        // Used by CFeedPairList

private:
#ifdef DEBUG
	void		AssertValid	( ) const;
#else
	inline void AssertValid ( ) const { }
#endif

};

//$-------------------------------------------------------------------
//
//	Class:
//		CFeedPairList
//
//	Description:
//
//--------------------------------------------------------------------

class CFeedPairList
{
public:
    CFeedPairList ( );
    ~CFeedPairList ( );

    //
    // List interface:
    //

    DWORD   GetCount    ( ) const;
    void    Empty       ( );

    CFeedPair * Item    ( DWORD index );
    void        Add     ( CFeedPair * pPair );
    void        Remove  ( CFeedPair * pPair );
    CFeedPair * Find    ( DWORD dwFeedId );
    DWORD       GetPairIndex    ( CFeedPair * pPair ) const;

private:
#ifdef DEBUG
	void		AssertValid	( ) const;
#else
	inline void AssertValid ( ) const { }
#endif

private:
    DWORD           m_cCount;
    CFeedPair *     m_pHead;
    CFeedPair *     m_pTail;

};

#endif // _FEEDINFO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\feeds.cpp ===
// feeds.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "feeds.h"
#include "oleutil.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Feeds.1")
#define THIS_FILE_IID				IID_INntpAdminFeeds

/////////////////////////////////////////////////////////////////////////////
// Defaults:

#define DEFAULT_FEED_ID						0
#define DEFAULT_FEED_SERVER					_T("")
#define DEFAULT_PULL_NEWS_DATE				0
#define DEFAULT_START_TIME					0
#define DEFAULT_FEED_INTERVAL				15
#define DEFAULT_AUTO_CREATE					TRUE
#define DEFAULT_ENABLED						TRUE
#define DEFAULT_MAX_CONNECTIONS_ATTEMPTS	10
#define DEFAULT_SECURITY_TYPE				0
#define DEFAULT_AUTH_TYPE                   AUTH_PROTOCOL_NONE
#define DEFAULT_ACCOUNT_NAME				_T("")
#define DEFAULT_PASSWORD					_T("")
#define DEFAULT_ALLOW_CONTROL_MESSAGES		TRUE
#define DEFAULT_UUCP_NAME                   _T("")
#define DEFAULT_NEWSGROUPS                  _T("\0")
#define DEFAULT_DISTRIBUTION                _T("world\0")

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminFeeds, CNntpAdminFeeds, IID_INntpAdminFeeds)

STDMETHODIMP CNntpOneWayFeed::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpOneWayFeed,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpOneWayFeed::CNntpOneWayFeed ()
	// CComBSTR's are initialized to NULL by default.
{
//	InitAsyncTrace ( );
}

CNntpOneWayFeed::~CNntpOneWayFeed ()
{
	// All CComBSTR's are freed automatically.
//	TermAsyncTrace ( );
}

STDMETHODIMP CNntpOneWayFeed::get_FeedId ( long * plFeedId )
{
	return StdPropertyGet ( m_feed.m_dwFeedId, plFeedId );
}

STDMETHODIMP CNntpOneWayFeed::get_RemoteServer ( BSTR * pstrRemoteServer )
{
	return StdPropertyGet ( m_feed.m_strRemoteServer, pstrRemoteServer );
}

STDMETHODIMP CNntpOneWayFeed::get_FeedAction ( NNTP_FEED_ACTION * pfeedaction )
{
	return m_feed.get_FeedAction ( pfeedaction );
}

STDMETHODIMP CNntpOneWayFeed::put_FeedAction ( NNTP_FEED_ACTION feedaction )
{
	return m_feed.put_FeedAction ( feedaction );
}

STDMETHODIMP CNntpOneWayFeed::get_UucpName ( BSTR * pstrUucpName )
{
	return StdPropertyGet ( m_feed.m_strUucpName, pstrUucpName );
}

STDMETHODIMP CNntpOneWayFeed::put_UucpName ( BSTR strUucpName )
{
	return StdPropertyPut ( &m_feed.m_strUucpName, strUucpName );
}

STDMETHODIMP CNntpOneWayFeed::get_PullNewsDate ( DATE * pdatePullNews )
{
	return StdPropertyGet ( m_feed.m_datePullNews, pdatePullNews );
}

STDMETHODIMP CNntpOneWayFeed::put_PullNewsDate ( DATE datePullNews )
{
	return StdPropertyPut ( &m_feed.m_datePullNews, datePullNews );
}

STDMETHODIMP CNntpOneWayFeed::get_FeedInterval ( long * plFeedInterval )
{
	return StdPropertyGet ( m_feed.m_dwFeedInterval, plFeedInterval );
}

STDMETHODIMP CNntpOneWayFeed::put_FeedInterval ( long lFeedInterval )
{
	return StdPropertyPut ( &m_feed.m_dwFeedInterval, lFeedInterval );
}

STDMETHODIMP CNntpOneWayFeed::get_AutoCreate ( BOOL * pfAutoCreate )
{
	return StdPropertyGet ( m_feed.m_fCreateAutomatically, pfAutoCreate );
}

STDMETHODIMP CNntpOneWayFeed::put_AutoCreate ( BOOL fAutoCreate )
{
	return StdPropertyPut ( &m_feed.m_fCreateAutomatically, fAutoCreate );
}

STDMETHODIMP CNntpOneWayFeed::get_Enabled ( BOOL * pfEnabled )
{
	return StdPropertyGet ( m_feed.m_fEnabled, pfEnabled );
}

STDMETHODIMP CNntpOneWayFeed::put_Enabled ( BOOL fEnabled )
{
	return StdPropertyPut ( &m_feed.m_fEnabled, fEnabled );
}

STDMETHODIMP CNntpOneWayFeed::get_MaxConnectionAttempts ( long * plMaxConnectionAttempts )
{
	return StdPropertyGet ( m_feed.m_dwMaxConnectionAttempts, plMaxConnectionAttempts );
}

STDMETHODIMP CNntpOneWayFeed::put_MaxConnectionAttempts ( long lMaxConnectionAttempts )
{
	return StdPropertyPut ( &m_feed.m_dwMaxConnectionAttempts, lMaxConnectionAttempts );
}

STDMETHODIMP CNntpOneWayFeed::get_SecurityType ( long * plSecurityType )
{
	return StdPropertyGet ( m_feed.m_dwSecurityType, plSecurityType );
}

STDMETHODIMP CNntpOneWayFeed::put_SecurityType ( long lSecurityType )
{
	return StdPropertyPut ( &m_feed.m_dwSecurityType, lSecurityType );
}

STDMETHODIMP CNntpOneWayFeed::get_AuthenticationType ( long * plAuthenticationType )
{
	return StdPropertyGet ( m_feed.m_dwAuthenticationType, plAuthenticationType );
}

STDMETHODIMP CNntpOneWayFeed::put_AuthenticationType ( long lAuthenticationType )
{
	return StdPropertyPut ( &m_feed.m_dwAuthenticationType, lAuthenticationType );
}

STDMETHODIMP CNntpOneWayFeed::get_AccountName ( BSTR * pstrAccountName )
{
	return StdPropertyGet ( m_feed.m_strAccountName, pstrAccountName );
}

STDMETHODIMP CNntpOneWayFeed::put_AccountName ( BSTR strAccountName )
{
	return StdPropertyPut ( &m_feed.m_strAccountName, strAccountName );
}

STDMETHODIMP CNntpOneWayFeed::get_Password ( BSTR * pstrPassword )
{
	return StdPropertyGet ( m_feed.m_strPassword, pstrPassword );
}

STDMETHODIMP CNntpOneWayFeed::put_Password ( BSTR strPassword )
{
	return StdPropertyPut ( &m_feed.m_strPassword, strPassword );
}

STDMETHODIMP CNntpOneWayFeed::get_AllowControlMessages ( BOOL * pfAllowControlMessages )
{
	return StdPropertyGet ( m_feed.m_fAllowControlMessages, pfAllowControlMessages );
}

STDMETHODIMP CNntpOneWayFeed::put_AllowControlMessages ( BOOL fAllowControlMessages )
{
	return StdPropertyPut ( &m_feed.m_fAllowControlMessages, fAllowControlMessages );
}

STDMETHODIMP CNntpOneWayFeed::get_OutgoingPort ( long * plOutgoingPort )
{
	return StdPropertyGet ( m_feed.m_dwOutgoingPort, plOutgoingPort );
}

STDMETHODIMP CNntpOneWayFeed::put_OutgoingPort ( long lOutgoingPort )
{
	return StdPropertyPut ( &m_feed.m_dwOutgoingPort, lOutgoingPort );
}

STDMETHODIMP CNntpOneWayFeed::get_Newsgroups ( SAFEARRAY ** ppsastrNewsgroups )
{
	return StdPropertyGet ( &m_feed.m_mszNewsgroups, ppsastrNewsgroups );
}

STDMETHODIMP CNntpOneWayFeed::put_Newsgroups ( SAFEARRAY * psastrNewsgroups )
{
	return StdPropertyPut ( &m_feed.m_mszNewsgroups, psastrNewsgroups );
}

STDMETHODIMP CNntpOneWayFeed::get_NewsgroupsVariant ( SAFEARRAY ** ppsavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = get_Newsgroups ( &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrNewsgroups, ppsavarNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

STDMETHODIMP CNntpOneWayFeed::put_NewsgroupsVariant ( SAFEARRAY * psavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = VariantArrayToStringArray ( psavarNewsgroups, &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_Newsgroups ( psastrNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

STDMETHODIMP CNntpOneWayFeed::get_Distributions ( SAFEARRAY ** ppsastrDistributions )
{
	return StdPropertyGet ( &m_feed.m_mszDistributions, ppsastrDistributions );
}

STDMETHODIMP CNntpOneWayFeed::put_Distributions ( SAFEARRAY * psastrDistributions )
{
	return StdPropertyPut ( &m_feed.m_mszDistributions, psastrDistributions );
}

STDMETHODIMP CNntpOneWayFeed::get_TempDirectory ( BSTR * pstrTempDirectory )
{
	return StdPropertyGet ( m_feed.m_strTempDirectory, pstrTempDirectory );
}

STDMETHODIMP CNntpOneWayFeed::put_TempDirectory ( BSTR strTempDirectory )
{
	return StdPropertyPut ( &m_feed.m_strTempDirectory, strTempDirectory );
}

STDMETHODIMP CNntpOneWayFeed::Default	( )
{
	TraceFunctEnter ( "CNntpOneWayFeed::Default" );

	SYSTEMTIME	st;
	DATE		dateToday;

	GetSystemTime ( &st );
	SystemTimeToVariantTime ( &st, &dateToday );

	m_feed.m_dwFeedId				= DEFAULT_FEED_ID;
	m_feed.m_strRemoteServer		= DEFAULT_FEED_SERVER;
	m_feed.m_dwFeedInterval			= DEFAULT_FEED_INTERVAL;
	m_feed.m_fCreateAutomatically	= DEFAULT_AUTO_CREATE;
	m_feed.m_fEnabled				= DEFAULT_ENABLED;
	m_feed.m_dwMaxConnectionAttempts	= DEFAULT_MAX_CONNECTIONS_ATTEMPTS;
	m_feed.m_dwSecurityType			= DEFAULT_SECURITY_TYPE;
    m_feed.m_dwAuthenticationType   = DEFAULT_AUTH_TYPE;
	m_feed.m_strAccountName			= DEFAULT_ACCOUNT_NAME;
	m_feed.m_strPassword			= DEFAULT_PASSWORD;
	m_feed.m_fAllowControlMessages	= DEFAULT_ALLOW_CONTROL_MESSAGES;
    m_feed.m_strUucpName         	= DEFAULT_UUCP_NAME;
    m_feed.m_dwOutgoingPort			= 119;

    m_feed.m_mszNewsgroups           = DEFAULT_NEWSGROUPS;
    m_feed.m_mszDistributions        = DEFAULT_DISTRIBUTION;

	m_feed.m_datePullNews			= dateToday;

	if ( !m_feed.CheckValid() ) {
		TraceFunctLeave ();
		return E_OUTOFMEMORY;
	}
	
	TraceFunctLeave ();
	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpFeed::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpFeed,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpFeed::CNntpFeed () :
	m_type ( NNTP_FEED_TYPE_PEER )
	// CComBSTR's are initialized to NULL by default.
{
//	InitAsyncTrace ( );
}

CNntpFeed::~CNntpFeed ()
{
	// All CComBSTR's are freed automatically.
//	TermAsyncTrace ( );
}

STDMETHODIMP CNntpFeed::get_RemoteServer ( BSTR * pstrRemoteServer )
{
	return StdPropertyGet ( m_strRemoteServer, pstrRemoteServer );
}

STDMETHODIMP CNntpFeed::put_RemoteServer ( BSTR strRemoteServer )
{
	return StdPropertyPut ( &m_strRemoteServer, strRemoteServer );
}

STDMETHODIMP CNntpFeed::get_FeedType ( NNTP_FEED_SERVER_TYPE * pfeedtype )
{
	*pfeedtype = m_type;
	return NOERROR;
}

STDMETHODIMP CNntpFeed::put_FeedType ( NNTP_FEED_SERVER_TYPE feedtype )
{
	switch ( feedtype ) {
	case NNTP_FEED_TYPE_PEER:
	case NNTP_FEED_TYPE_MASTER:
	case NNTP_FEED_TYPE_SLAVE:
		m_type = feedtype;
		return NOERROR;
		break;

	default:
		return RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		break;
	}
}

STDMETHODIMP CNntpFeed::get_HasInbound ( BOOL * pfHasInbound )
{
    *pfHasInbound = m_pInbound != NULL;
    return NOERROR;
}

STDMETHODIMP CNntpFeed::get_HasOutbound ( BOOL * pfHasOutbound )
{
    *pfHasOutbound = m_pOutbound != NULL;
    return NOERROR;
}

STDMETHODIMP CNntpFeed::get_InboundFeed ( INntpOneWayFeed ** ppFeed )
{
    HRESULT     hr  = NOERROR;

    *ppFeed = NULL;
    if ( m_pInbound ) {
        hr = m_pInbound->QueryInterface ( IID_INntpOneWayFeed, (void **) ppFeed );
        return hr;
    }
    return E_FAIL;
}

STDMETHODIMP CNntpFeed::get_OutboundFeed ( INntpOneWayFeed ** ppFeed )
{
    HRESULT     hr  = NOERROR;

    *ppFeed = NULL;
    if ( m_pOutbound ) {
        hr = m_pOutbound->QueryInterface ( IID_INntpOneWayFeed, (void **) ppFeed );
    	return hr;
    }
    return E_FAIL;
}

STDMETHODIMP CNntpFeed::put_InboundFeed ( INntpOneWayFeed * pFeed )
{
    HRESULT     hr  = NOERROR;

    // !!!magnush - Do some feed type checking here.

    m_pInbound.Release ();
    m_pInbound = pFeed;

    return NOERROR;
}

STDMETHODIMP CNntpFeed::put_OutboundFeed ( INntpOneWayFeed * pFeed )
{
    HRESULT     hr  = NOERROR;

    // !!!magnush - Do some feed type checking here.

    m_pOutbound.Release ();
    m_pOutbound = pFeed;

    return hr;
}

STDMETHODIMP CNntpFeed::get_InboundFeedDispatch ( IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pInbound;

	hr = get_InboundFeed ( &pInbound );
	BAIL_ON_FAILURE(hr);

	hr = pInbound->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpFeed::put_InboundFeedDispatch ( IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pInbound;

	hr = pDispatch->QueryInterface ( IID_INntpOneWayFeed, (void **) &pInbound );
	BAIL_ON_FAILURE(hr);

	hr = put_InboundFeed ( pInbound );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpFeed::get_OutboundFeedDispatch ( IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pOutbound;

	hr = get_OutboundFeed ( &pOutbound );
	BAIL_ON_FAILURE(hr);

	hr = pOutbound->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpFeed::put_OutboundFeedDispatch ( IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pOutbound;

	hr = pDispatch->QueryInterface ( IID_INntpOneWayFeed, (void **) &pOutbound );
	BAIL_ON_FAILURE(hr);

	hr = put_OutboundFeed ( pOutbound );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

HRESULT	CNntpFeed::FromFeedPair ( CFeedPair * pFeedPair )
{
	HRESULT		hr	= NOERROR;

	m_pInbound.Release ();
	m_pOutbound.Release ();

	m_strRemoteServer	= pFeedPair->m_strRemoteServer;
	m_type				= pFeedPair->m_type;
	if ( pFeedPair->m_pInbound ) {
		hr = pFeedPair->m_pInbound->ToINntpOneWayFeed ( &m_pInbound );
		BAIL_ON_FAILURE(hr);
	}
	if ( pFeedPair->m_pOutbound ) {
		hr = pFeedPair->m_pOutbound->ToINntpOneWayFeed ( &m_pOutbound );
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpAdminFeeds::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminFeeds,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminFeeds::CNntpAdminFeeds () :
	m_fEnumerated				( FALSE )
	// CComBSTR's are initialized to NULL by default.
{

	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Feeds") );
    m_iadsImpl.SetClass ( _T("IIsNntpFeeds") );

    OleInitialize( NULL );
}

CNntpAdminFeeds::~CNntpAdminFeeds ()
{
	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
    OleUninitialize();
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminFeeds,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Enumeration Properties:

STDMETHODIMP CNntpAdminFeeds::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_listFeeds.GetCount(), plCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminFeeds::Enumerate	( )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Enumerate" );

	HRESULT				hr			= NOERROR;
	DWORD				dwError		= NOERROR;
	DWORD				cFeeds		= 0;
	LPNNTP_FEED_INFO	pFeedInfo	= NULL;
	DWORD				i;

	dwError = NntpEnumerateFeeds (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &cFeeds,
        &pFeedInfo
        );
	if ( dwError != 0 ) {
		ErrorTrace ( (LPARAM) this, "Error enumerating feeds: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	// Empty the old feed list:
	m_fEnumerated = FALSE;
    m_listFeeds.Empty ();

    // Add each feed to our list:
    for ( i = 0; i < cFeeds; i++ ) {
        DWORD           dwPairID;
        CFeedPair *     pFeedPair;
        CFeed *         pFeed;

        // Create a new Feed object:
        hr = CFeed::CreateFeedFromFeedInfo ( &pFeedInfo[i], &pFeed );
        if ( FAILED(hr) ) {
            goto Exit;
        }

        // Find the pair that matches Feed[i]:
        dwPairID = pFeed->m_dwPairFeedId;
        pFeedPair = m_listFeeds.Find ( dwPairID );

        if ( pFeedPair ) {
            // We found a matching pair, so add it:
            hr = pFeedPair->AddFeed ( pFeed );
            if ( hr == E_FAIL ) {
                // Something went wrong - Try to add the feed by itself.
                pFeedPair = NULL;
                hr = NOERROR;
            }
            if ( FAILED(hr) ) {
                goto Exit;
            }
        }

        if ( pFeedPair == NULL ) {
            // We need to create a new feed pair:
            hr = CFeedPair::CreateFeedPair ( 
            	&pFeedPair, 
            	pFeedInfo[i].ServerName,
            	FeedTypeToEnum ( pFeedInfo[i].FeedType )
            	);
            if ( FAILED(hr) ) {
                goto Exit;
            }

            // Add the current feed to the new pair:
            hr = pFeedPair->AddFeed ( pFeed );
            if ( FAILED(hr) ) {
                goto Exit;
            }

            // Add the new pair to the pair list:
            m_listFeeds.Add ( pFeedPair );
        }
    }

    // !!!magnush - Stop memory leaks here.

	m_fEnumerated 	= TRUE;

Exit:
	if ( FAILED(hr) ) {
        m_listFeeds.Empty();
	}

	if ( pFeedInfo ) {
		::NetApiBufferFree ( pFeedInfo );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Item ( long lIndex, INntpFeed ** ppFeed )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Item" );

	HRESULT		        hr	= NOERROR;
    CFeedPair *         pFeedPair;

	// Did we enumerate first?
	if ( !m_fEnumerated ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
		TraceFunctLeave ();
        return hr;
	}
	
    pFeedPair = m_listFeeds.Item ( lIndex );
    if ( !pFeedPair ) {
        hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

    hr = pFeedPair->ToINntpFeed ( ppFeed );
    if ( FAILED(hr) ) {
        goto Exit;
    }

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::FindID ( long lID, long * plIndex )
{
	TraceFunctEnter ( "CNntpAdminFeeds::FindID" );

	HRESULT		hr	= NOERROR;
    CFeedPair * pFeedPair;

    *plIndex = -1;

    pFeedPair   = m_listFeeds.Find ( (DWORD) lID );

    if ( pFeedPair ) {
        *plIndex = (long) m_listFeeds.GetPairIndex ( pFeedPair );
    }

	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminFeeds::ReturnFeedPair ( CFeedPair * pFeedPair, INntpFeed * pFeed )
{
	HRESULT						hr;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CComPtr<INntpFeed>          pNewFeedPair;

    hr = pFeedPair->ToINntpFeed ( &pNewFeedPair );
	BAIL_ON_FAILURE(hr);

    pNewFeedPair->get_InboundFeed ( &pInbound );
    pNewFeedPair->get_OutboundFeed ( &pOutbound );

    pFeed->put_InboundFeed ( pInbound );
    pFeed->put_OutboundFeed ( pOutbound );

Exit:
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Add ( INntpFeed * pFeed )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Add" );

	HRESULT		hr 				= NOERROR;
    CFeedPair * pFeedPair       = NULL;
    CComBSTR	strRemoteServer;
    CComBSTR	strServer;
    NNTP_FEED_SERVER_TYPE	    type;
    CMetabaseKey *pMK = NULL;
    IMSAdminBase *pMeta = NULL;

	hr = pFeed->get_RemoteServer ( &strRemoteServer );
	BAIL_ON_FAILURE(hr);

	hr = get_Server(&strServer);
	BAIL_ON_FAILURE(hr);

    hr = CreateMetabaseObject( strServer, &pMeta ); 
    _ASSERT( SUCCEEDED( hr ) );
    BAIL_ON_FAILURE(hr);

	pMK = new CMetabaseKey(pMeta);
	if (!pMK)
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);

	hr = pFeed->get_FeedType ( &type );
	BAIL_ON_FAILURE(hr);

    hr = CFeedPair::CreateFeedPair ( &pFeedPair, strRemoteServer, type );
	BAIL_ON_FAILURE(hr);

    hr = pFeedPair->FromINntpFeed ( pFeed );
	BAIL_ON_FAILURE(hr);

    hr = pFeedPair->AddToServer (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        pMK
        );
	BAIL_ON_FAILURE(hr);

    m_listFeeds.Add ( pFeedPair );

    //  Return the new feeds (and their IDs) to the caller:
	hr = ReturnFeedPair ( pFeedPair, pFeed );
	BAIL_ON_FAILURE(hr);

Exit:
    if ( FAILED(hr) ) {
        delete pFeedPair;
    }

    if (pMK)
    	delete pMK;

    if (pMeta)
    	pMeta->Release();

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Set ( long lIndex, INntpFeed * pFeed )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Set" );

	HRESULT		hr = NOERROR;
    CFeedPair * pFeedPair;
    CComPtr<INntpFeed>          pNewFeedPair;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CComBSTR	strServer;
    CMetabaseKey *pMK = NULL;
    IMSAdminBase *pMeta = NULL;

	hr = get_Server ( &strServer );
	BAIL_ON_FAILURE(hr);

    hr = CreateMetabaseObject( strServer, &pMeta ); 
    _ASSERT( SUCCEEDED( hr ) );
    BAIL_ON_FAILURE(hr);

	pMK = new CMetabaseKey(pMeta);
	if (!pMK)
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);

    pFeedPair = m_listFeeds.Item ( lIndex );
    if ( !pFeedPair ) {
        hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

    hr = pFeedPair->SetToServer (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        pFeed,
        pMK
        );
	BAIL_ON_FAILURE(hr);

    //  Return the new feeds (and their IDs) to the caller:
	hr = ReturnFeedPair ( pFeedPair, pFeed );
	BAIL_ON_FAILURE(hr);

Exit:
    if (pMK)
    	delete pMK;

    if (pMeta)
    	pMeta->Release();

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Remove ( long lIndex )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Remove" );

	HRESULT		hr = NOERROR;
	CFeedPair *	pFeedPair;
    CComBSTR	strServer;
    CMetabaseKey *pMK = NULL;
    IMSAdminBase *pMeta = NULL;

    pFeedPair   = m_listFeeds.Item ( lIndex );
    if ( !pFeedPair ) {
        hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

	hr = get_Server ( &strServer );
	BAIL_ON_FAILURE(hr);

    hr = CreateMetabaseObject( strServer, &pMeta ); 
    _ASSERT( SUCCEEDED( hr ) );
    BAIL_ON_FAILURE(hr);

	pMK = new CMetabaseKey(pMeta);
	if (!pMK)
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);

    hr = pFeedPair->RemoveFromServer (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        pMK
        );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    m_listFeeds.Remove ( pFeedPair );

Exit:
    if (pMK)
    	delete pMK;

    if (pMeta)
    	pMeta->Release();

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT				hr;
	CComPtr<INntpFeed>	pFeed;

	hr = Item ( index, &pFeed );
	BAIL_ON_FAILURE ( hr );

	hr = pFeed->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::AddDispatch ( IDispatch * pFeed )
{
	HRESULT				hr;
	CComPtr<INntpFeed>	pINntpFeed;

	hr = pFeed->QueryInterface ( IID_INntpFeed, (void **) &pINntpFeed );
	BAIL_ON_FAILURE(hr);

	hr = Add ( pINntpFeed );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::SetDispatch ( long lIndex, IDispatch * pFeed )
{
	HRESULT				hr;
	CComPtr<INntpFeed>	pINntpFeed;

	hr = pFeed->QueryInterface ( IID_INntpFeed, (void **) &pINntpFeed );
	BAIL_ON_FAILURE(hr);

	hr = Set ( lIndex, pINntpFeed );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\feedpach.cpp ===
#include "stdafx.h"
#include "feedpach.h"

#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

#define ERR_KEY_ALREADY_EXIST  0x800700b7    // BugBug: This key macro should be 
                                             // replaced by the official one

VOID
FillFeedRoot( DWORD dwInstance, LPWSTR  wszBuffer )
{
    swprintf( wszBuffer, L"/LM/nntpsvc/%d/feeds/", dwInstance );
} 
     
BOOL
VerifyMultiSzListW(
    LPBYTE List,
    DWORD cbList
    )
/*++

Routine Description:

    This routine verifies that the list is indeed a multisz

Arguments:

    List - the list to be verified
    cbList - size of the list

Return Value:

    TRUE, list is a multisz
    FALSE, otherwise

--*/
{
    PWCHAR wList = (PWCHAR)List;
    DWORD len;

    //
    // null are considered no hits
    //

    if ( (List == NULL) || (*List == L'\0') ) {
        return(FALSE);
    }

    //
    // see if they are ok
    //

    for ( DWORD j = 0; j < cbList; ) {

        len = wcslen((LPWSTR)&List[j]);

        if ( len > 0 ) {

            j += ((len + 1) * sizeof(WCHAR));
        } else {

            //
            // all done
            //

            return(TRUE);
        }
    }

#ifndef UNIT_TEST
        ErrorTraceX(0,"VerifyMultiSzListW: exception handled\n");
#endif
    return(FALSE);

} // VerifyMultiSzList

DWORD
MultiListSize(
    LPWSTR *List
    )
/*++

Routine Description:

    This routine computes the size of the multisz structure needed
    to accomodate a list.

Arguments:

    List - the list whose string lengths are to be computed

Return Value:

    Size of buffer needed to accomodate list.

--*/
{
    TraceFunctEnter( "MultiListSize" );
    _ASSERT( List );

    DWORD nBytes = 2;
    DWORD i = 0;

    if ( List != NULL ) {
        while ( List[i] != NULL ) {
            nBytes += ( lstrlen(List[i]) + 1 ) * sizeof( WCHAR );
            i++;
        }
    }

    TraceFunctLeave();
    return(nBytes);
} // MultiListSize

DWORD
GetNumStringsInMultiSz(
    PWCHAR Blob,
    DWORD BlobSize
    )
/*++

Routine Description:

    This routine returns the number of strings in the multisz

Arguments:

    Blob - the list to be verified
    BlobSize - size of the list

Return Value:

    number of entries in the multisz structure.

--*/
{
    TraceFunctEnter( "GetNumStringInMultiSz" );
    _ASSERT( Blob );

    DWORD entries = 0;
    DWORD len;
    DWORD j;

    for ( j = 0; j < BlobSize; ) {
        len = lstrlen(&Blob[j]);
        if ( len > 0 ) {
            entries++;
        }
        j += (len + 1);
        if( len == 0 ) {
            break;
        }
    }

    _ASSERT( j  == BlobSize );

    TraceFunctLeave();
    return(entries);

} // GetNumStringsInMultiSz

LPWSTR *
AllocateMultiSzTable(
            IN PWCHAR List,
            IN DWORD cbList
            )
{
    TraceFunctEnter( "AllocateMultiSzTable" );
    _ASSERT( List );

    DWORD len;
    PCHAR buffer;
    DWORD entries = 0;
    LPWSTR* table;
    PWCHAR nextVar;
    DWORD numItems;

    numItems = GetNumStringsInMultiSz( List, cbList );
    if ( numItems == 0 ) {
        return(NULL);
    }

    buffer = (PCHAR)ALLOCATE_HEAP((numItems + 1) * sizeof(LPWSTR) + cbList * sizeof( WCHAR ));
    if ( buffer == NULL ) {
        return(NULL);
    }

    table = (LPWSTR *)buffer;
    nextVar = PWCHAR( buffer + (numItems + 1)*sizeof(LPWSTR) );

    for ( DWORD j = 0; j < cbList; ) {

        len = lstrlen(&List[j]);
        if ( len > 0 ) {
            table[entries] = (LPWSTR)nextVar;
            CopyMemory(nextVar,&List[j],(len+1)*sizeof( WCHAR ));
            (VOID)_wcslwr(table[entries]);
            entries++;
            nextVar += (len+1);
        }
        j += (len + 1);
    }

    *nextVar = L'\0';
    table[numItems] = NULL;
    
    TraceFunctLeave();
    return(table);

} // AllocateMultiSzTable

HRESULT
OpenKey( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwPermission, DWORD dwInstance )
{
    
    TraceFunctEnter( "OpenKey" );
    _ASSERT( dwFeedId > 0 );
    _ASSERT( pMK );

    HRESULT hr;
    WCHAR   wszFeedKey[MAX_PATH];

    swprintf( wszFeedKey, L"/LM/nntpsvc/%d/Feeds/feed%d/", dwInstance, dwFeedId );
    hr = pMK->Open( METADATA_MASTER_ROOT_HANDLE,
                    wszFeedKey,
                    dwPermission );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Open feed key fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}

VOID
CloseKey( CMetabaseKey* pMK )
{
    pMK->Close();
}

VOID
SaveKey( CMetabaseKey* pMK )
{
    pMK->Save();
} 

HRESULT
AddKey( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwInstance )
{
    
    TraceFunctEnter( "Addkey" );
    _ASSERT( dwFeedId > 0 );
    _ASSERT( pMK );

    HRESULT hResult;
    WCHAR   wszFeedRoot[MAX_PATH];
    WCHAR   wszFeedKey[MAX_PATH];

    FillFeedRoot( dwInstance, wszFeedRoot );

    hResult = pMK->Open( METADATA_MASTER_ROOT_HANDLE,
                         wszFeedRoot,
                         METADATA_PERMISSION_WRITE );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Open root for write fail with 0x%x", hResult );
        return hResult;
    }

    swprintf( wszFeedKey, L"feed%d", dwFeedId );
    hResult = pMK->CreateChild( wszFeedKey );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Create key fail with 0x%x", hResult );
        pMK->Close();
        return hResult;
    }

    pMK->Close(); 
    TraceFunctLeave();
    return S_OK;
}    

HRESULT
DeleteKey( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwInstance )
{
    TraceFunctEnter( "DeleteKey" );
    _ASSERT( pMK );

    HRESULT hResult;
    WCHAR   wszFeedRoot[MAX_PATH];
    WCHAR   wszFeedKey[MAX_PATH];

    FillFeedRoot( dwInstance, wszFeedRoot );
    hResult = pMK->Open( METADATA_MASTER_ROOT_HANDLE,
                         wszFeedRoot,
                         METADATA_PERMISSION_WRITE );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Open root key for write fail with 0x%x", hResult );
        return hResult;
    }

    swprintf( wszFeedKey, L"feed%d", dwFeedId ); 
    hResult = pMK->DestroyChild( wszFeedKey );
    if ( FAILED( hResult ) ) {
        ErrorTrace(0, "Delete key fail with 0x%x", hResult );
        pMK->Close();
    }

    pMK->Close();
    TraceFunctLeave();
    return S_OK;
}

HRESULT
SetDwordProp( DWORD dwPropId, DWORD dwPropVal, CMetabaseKey* pMK )
{
    TraceFunctEnter( "SetDwordProp" );
    _ASSERT( pMK );

    HRESULT hResult;

    hResult = pMK->SetDword( dwPropId, dwPropVal );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Set DWord fail with 0x%x", hResult );
        return hResult;
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT
SetStringProp( DWORD dwPropId, LPWSTR wszStringVal, CMetabaseKey* pMK )
{
    TraceFunctEnter( "SetStringProp" );
    HRESULT hr;

    hr = pMK->SetString( dwPropId, wszStringVal );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Open key for property setting fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}
HRESULT
SetStringProp( DWORD dwPropId, LPWSTR wszStringVal, CMetabaseKey* pMK, DWORD dwFlags, DWORD dwUserType)
{
    TraceFunctEnter( "SetStringProp" );
    HRESULT hr;

    hr = pMK->SetString( dwPropId, wszStringVal, dwFlags, dwUserType );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Open key for property setting fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}
HRESULT 
SetMultiString(     DWORD dwPropId, 
                    LPWSTR*  mszPropVal,
                    CMetabaseKey* pMK )
{
    TraceFunctEnter( "SetMultiString" );

    HRESULT hr;

    hr = pMK->SetMultiSz( dwPropId, mszPropVal[0], MultiListSize( mszPropVal ) );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set multisz property fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT
AllocNextAvailableFeedId( CMetabaseKey* pMK, PDWORD pdwFeedId, DWORD dwInstance )
{
    TraceFunctEnter(  "AllocNextAvailableFeedId" );
    _ASSERT( pMK );

    HRESULT hr;
    DWORD   dwCounter = 0;

    while( TRUE ) {

        hr = AddKey( ++dwCounter, pMK, dwInstance );
        if ( SUCCEEDED( hr ) ) {
            TraceFunctLeave();
            *pdwFeedId = dwCounter;
            return S_OK;
        }

        if ( hr != ERR_KEY_ALREADY_EXIST ) {
            TraceFunctLeave();
            ErrorTrace( 0, "Alloc key fail with 0x%x", hr );
            return hr;
        }
    }

    TraceFunctLeave();  // will never reach here
    return E_FAIL;
}

//
// The pMK should already have been opened for write permission
//
HRESULT
UpdateFeedMetabaseValues(   CMetabaseKey* pMK, 
                            LPNNTP_FEED_INFO pFeedInfo, 
                            DWORD dwMask,
                            PDWORD dwRetMask   )
{
    TraceFunctEnter( "UpdateFeedMetabaseValues" );
    _ASSERT( pMK );
    _ASSERT( pFeedInfo );

    HRESULT hr;
    LPWSTR* stringList;

	//
	// Set the KeyType.
	//

	hr = SetStringProp(	MD_KEY_TYPE,
    					TEXT(NNTP_ADSI_OBJECT_FEED),
    					pMK,
    					METADATA_NO_ATTRIBUTES,
    					IIS_MD_UT_SERVER
					 );
	if (FAILED(hr))
	{
        goto fail_exit;
	}

    if ( ( dwMask & FEED_PARM_FEEDTYPE) != 0 ) {
        hr = SetDwordProp(  MD_FEED_TYPE,
                            pFeedInfo->FeedType,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set feed type fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_FEEDTYPE;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_AUTOCREATE  ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_CREATE_AUTOMATICALLY,
                            DWORD(pFeedInfo->AutoCreate),
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set auto creat fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_AUTOCREATE;
            goto fail_exit;
        }
    }

    if ( !FEED_IS_PASSIVE( pFeedInfo->FeedType ) ) {
        
        if (  ( dwMask &  FEED_PARM_FEEDINTERVAL ) != 0 ) {
            hr = SetDwordProp(  MD_FEED_INTERVAL,
                                pFeedInfo->FeedInterval,
                                pMK  );
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set feed interval fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_FEEDINTERVAL;
                goto fail_exit;
            }
        }

        if (  ( dwMask & FEED_PARM_STARTTIME ) != 0 ) {
            hr = SetDwordProp(  MD_FEED_START_TIME_HIGH,
                                (pFeedInfo->StartTime).dwHighDateTime,
                                pMK );
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set start time fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_STARTTIME;
                goto fail_exit;
            }

            hr = SetDwordProp(  MD_FEED_START_TIME_LOW,
                                (pFeedInfo->StartTime).dwLowDateTime,
                                pMK );
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set start time fail with 0x%x" , hr );
                *dwRetMask |= FEED_PARM_STARTTIME;
                goto fail_exit;
            }
        }

        if (  ( dwMask & FEED_PARM_PULLREQUESTTIME ) != 0 ) {
            
            hr = SetDwordProp(
                                MD_FEED_NEXT_PULL_HIGH,
                                (pFeedInfo->PullRequestTime).dwHighDateTime,
                                pMK ); 
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set pull request time fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_PULLREQUESTTIME;
                goto fail_exit;
            }

            hr = SetDwordProp(
                                MD_FEED_NEXT_PULL_LOW,
                                (pFeedInfo->PullRequestTime).dwLowDateTime,
                                pMK ); 
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set pull request time fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_PULLREQUESTTIME;
                goto fail_exit;
            }

        } 
        
    }

    if ( ( dwMask & FEED_PARM_SERVERNAME  ) != 0 ) {
        hr = SetStringProp( MD_FEED_SERVER_NAME,
                            pFeedInfo->ServerName,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set server name fail with 0x%x", hr ) ;
            *dwRetMask |= FEED_PARM_SERVERNAME;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_NEWSGROUPS ) != 0 ) {
        stringList =  AllocateMultiSzTable( pFeedInfo->Newsgroups,
                                             pFeedInfo->cbNewsgroups  / sizeof( WCHAR ));
        if ( !stringList ) {
            ErrorTrace(0, "Generate multi sz fail" );
            hr = E_OUTOFMEMORY;
            *dwRetMask |= FEED_PARM_NEWSGROUPS;
            goto fail_exit;
        }

        hr = SetMultiString(    MD_FEED_NEWSGROUPS,
                                stringList,
                                pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set newsgroups fail with 0x%x", hr );
            *dwRetMask |= MD_FEED_NEWSGROUPS;
            goto fail_exit;
        }

        FREE_HEAP( stringList );        
    }

    if (  ( dwMask & FEED_PARM_DISTRIBUTION  ) != 0 ) {
        stringList = AllocateMultiSzTable(  pFeedInfo->Distribution,
                                            pFeedInfo->cbDistribution / sizeof( WCHAR ));
        if ( !stringList ) {
            ErrorTrace(0, "Generate multi sz fail" );
            hr = E_OUTOFMEMORY;
            *dwRetMask |= FEED_PARM_DISTRIBUTION;
            goto fail_exit;
        }

        hr = SetMultiString(    MD_FEED_DISTRIBUTION,
                                stringList,
                                pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set distribution fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_DISTRIBUTION;
            goto fail_exit;
        }

        FREE_HEAP( stringList );
    }  

    if ( ( dwMask & FEED_PARM_ENABLED  ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_DISABLED,    
                            DWORD( pFeedInfo->Enabled ), 
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set feed enable fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_ENABLED;
            goto fail_exit;
        }
    }

    if (  ( dwMask & FEED_PARM_UUCPNAME  ) != 0 && pFeedInfo->UucpName ){
        hr = SetStringProp( MD_FEED_UUCP_NAME,
                            pFeedInfo->UucpName,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set uucp name fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_UUCPNAME;
            goto fail_exit;
        }
    }

    if (  ( dwMask & FEED_PARM_TEMPDIR ) != 0 && pFeedInfo->FeedTempDirectory ) {
        hr = SetStringProp( MD_FEED_TEMP_DIRECTORY,
                            pFeedInfo->FeedTempDirectory,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set temp dir fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_TEMPDIR;
            goto fail_exit;
        }
    }

    if (  ( dwMask & FEED_PARM_MAXCONNECT ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_MAX_CONNECTION_ATTEMPTS,
                            pFeedInfo->MaxConnectAttempts,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set max connect fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_MAXCONNECT;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_SESSIONSECURITY ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_SECURITY_TYPE,
                            pFeedInfo->SessionSecurityType,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set session sec type fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_SESSIONSECURITY;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_CONCURRENTSESSION ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_CONCURRENT_SESSIONS,
                            pFeedInfo->ConcurrentSessions,
                            pMK );
        if ( FAILED(hr ) ) {
            ErrorTrace(0, "Set concurrent sessions fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_CONCURRENTSESSION;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_AUTHTYPE ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_AUTHENTICATION_TYPE,
                            pFeedInfo->AuthenticationSecurityType,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set auth type fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_AUTHTYPE;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_ACCOUNTNAME ) != 0 && pFeedInfo->NntpAccountName ) {
        hr = SetStringProp( MD_FEED_ACCOUNT_NAME,
                        pFeedInfo->NntpAccountName,
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set account name fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_ACCOUNTNAME;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_PASSWORD ) != 0 && pFeedInfo->NntpPassword ) {
        hr = SetStringProp( MD_FEED_PASSWORD,
                        pFeedInfo->NntpPassword,
                        pMK,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER);
        if( FAILED( hr ) ) {
            ErrorTrace(0, "Set password fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_PASSWORD;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_ALLOW_CONTROL ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_ALLOW_CONTROL_MSGS,
                        DWORD( pFeedInfo->fAllowControlMessages ),
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Set allow control msgs fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_ALLOW_CONTROL;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_OUTGOING_PORT ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_OUTGOING_PORT,
                        pFeedInfo->OutgoingPort,
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set outgoing port fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_OUTGOING_PORT;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_FEEDPAIR_ID  ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_FEEDPAIR_ID,
                        pFeedInfo->FeedPairId,
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set pair id fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_FEEDPAIR_ID;
            goto fail_exit;
        }
    }

    TraceFunctLeave();
    return S_OK;

fail_exit:

    TraceFunctLeave();
    return hr;
}

VOID
SetPresenceMask( LPNNTP_FEED_INFO pFeedInfo, PDWORD pdwMask, BOOL fIsAdd )
{
    TraceFunctEnter( "SetPresenceMask" );
    _ASSERT( pFeedInfo );
    _ASSERT( pdwMask );

    BOOL    newsPresent = FALSE;

    *pdwMask = 0;

    //
    // feed type, assume always exist for add, non-existant for set
    //
    if ( fIsAdd ) *pdwMask |= FEED_PARM_FEEDTYPE;
    
    //
    // server name
    //
    if ( pFeedInfo->ServerName != FEED_STRINGS_NOCHANGE &&
         *pFeedInfo->ServerName != L'\0' )
        *pdwMask |= FEED_PARM_SERVERNAME;

    //
    // news groups
    //
    if ( VerifyMultiSzListW(    LPBYTE( pFeedInfo->Newsgroups ),
                                pFeedInfo->cbNewsgroups ) ) {
        *pdwMask |= FEED_PARM_NEWSGROUPS;
        newsPresent = TRUE;
    }

    //
    // Distribution
    //
    if ( VerifyMultiSzListW(    LPBYTE( pFeedInfo->Distribution ),
                                pFeedInfo->cbDistribution ) )
        *pdwMask |= FEED_PARM_DISTRIBUTION;

    //
    // Uucp Name
    //
    if (    pFeedInfo->UucpName != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->UucpName != L'\0' )
        *pdwMask |= FEED_PARM_UUCPNAME;

    //
    // account name
    //
    if (    pFeedInfo->NntpAccountName != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->NntpAccountName != L'\0' )
        *pdwMask |= FEED_PARM_ACCOUNTNAME;

    //
    // Password
    //
    if (    pFeedInfo->NntpPassword != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->NntpPassword != L'\0' )
        *pdwMask |= FEED_PARM_PASSWORD;

    //
    // Temp dir 
    //
    if (    pFeedInfo->FeedTempDirectory != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->FeedTempDirectory != L'\0' )
        *pdwMask |= FEED_PARM_TEMPDIR;

    //
    // auth type
    //
    if ( pFeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_NONE ||
            pFeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR ) {
        *pdwMask |= FEED_PARM_AUTHTYPE;

        if ( pFeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_NONE ) {
            *pdwMask &= ~FEED_PARM_ACCOUNTNAME;
            *pdwMask &= ~FEED_PARM_PASSWORD;
        }
    }

    //
    // start time
    //
    if ( pFeedInfo->StartTime.dwHighDateTime != FEED_STARTTIME_NOCHANGE )
        *pdwMask |= FEED_PARM_STARTTIME;

    //
    // pull request time
    //
    if ( pFeedInfo->PullRequestTime.dwHighDateTime != FEED_PULLTIME_NOCHANGE )
        *pdwMask |= FEED_PARM_PULLREQUESTTIME;

    //
    // feed interval
    //
    if ( pFeedInfo->FeedInterval != FEED_FEEDINTERVAL_NOCHANGE )
        *pdwMask |= FEED_PARM_FEEDINTERVAL;

    //
    // auto create
    //
    if ( pFeedInfo->AutoCreate != FEED_AUTOCREATE_NOCHANGE )
        *pdwMask |= FEED_PARM_AUTOCREATE;

    if ( newsPresent ) {
        *pdwMask |= FEED_PARM_AUTOCREATE;
        pFeedInfo->AutoCreate = TRUE;
    }

    //
    // allow control
    //
    *pdwMask |= FEED_PARM_ALLOW_CONTROL;

    //
    // Max connect
    //
    if ( pFeedInfo->MaxConnectAttempts != FEED_MAXCONNECTS_NOCHANGE )
        *pdwMask |= FEED_PARM_MAXCONNECT;

    //
    // outgoing port
    //
    *pdwMask |= FEED_PARM_OUTGOING_PORT;

    //
    // feedpair id
    //
    *pdwMask |= FEED_PARM_FEEDPAIR_ID;

    //
    // feed enable
    //
    *pdwMask |= FEED_PARM_ENABLED;

    TraceFunctLeave();
}

HRESULT AddFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD dwInstance, PDWORD pdwFeedId )
{
    TraceFunctEnter( "AddFeed" );
    _ASSERT( pFeedInfo );

    HRESULT hr;
    DWORD   dwSetMask = 0;

    //
    // Get set mask
    //
    //SetPresenceMask( pFeedInfo, &dwSetMask, TRUE );
    
    //
    // Alloc and create the feed key in the metabase
    //
    hr = AllocNextAvailableFeedId( pMK, pdwFeedId, dwInstance );
    if ( FAILED( hr ) ) {
        TraceFunctLeave();
        return hr;
    }

    pFeedInfo->FeedId = *pdwFeedId; 

    //
    // Open that key for write
    //
    hr = OpenKey( *pdwFeedId, pMK, METADATA_PERMISSION_WRITE, dwInstance );
    if ( FAILED( hr ) ) 
        goto fail_exit; 

    //
    // Write the handshake start updating flag
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE, 
                        FEED_UPDATING,
                        pMK ); 
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Set feed info
    //
    hr = UpdateFeedMetabaseValues(  pMK,
                                    pFeedInfo,
                                    FEED_ALL_PARAMS,
                                    pdwErrMask );
    if ( FAILED( hr ) ) 
        goto fail_exit;

    //
    // Set handshake
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE,
                        FEED_UPDATE_COMPLETE,
                        pMK );
    if ( FAILED( hr )  ) 
        goto fail_exit;

    //
    // done.
    //
    CloseKey( pMK );
    SaveKey( pMK );
    TraceFunctLeave();
    return S_OK;

fail_exit:

    CloseKey( pMK );
    DeleteKey( 1, pMK, dwInstance );
    TraceFunctLeave();
    return hr;
} 

HRESULT 
SetFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD dwInstance )
{
    TraceFunctEnter( "AddFeed" );
    _ASSERT( pFeedInfo );

    HRESULT hr;
    DWORD   dwSetMask = 0;

    //
    // Get set mask
    //
    SetPresenceMask( pFeedInfo, &dwSetMask, FALSE );

    //
    // Open that key for write
    //
    hr = OpenKey( pFeedInfo->FeedId, pMK, METADATA_PERMISSION_WRITE, dwInstance );
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Write the handshake start updating flag
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE,
                        FEED_UPDATING,
                        pMK );
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Set feed info
    //
    hr = UpdateFeedMetabaseValues(  pMK,
                                    pFeedInfo,
                                    dwSetMask,
                                    pdwErrMask );
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Set handshake
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE,
                        FEED_UPDATE_COMPLETE,
                        pMK );
    if ( FAILED( hr )  )
        goto fail_exit;

    //
    // done.
    //
    CloseKey( pMK );
    SaveKey( pMK );
    TraceFunctLeave();
    return S_OK;

fail_exit:

    CloseKey( pMK );
    TraceFunctLeave();
    return hr;
}

HRESULT
DeleteFeed( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwInstance )
{
    return  DeleteKey( dwFeedId, pMK, dwInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\feeds.h ===
// feeds.h : Declaration of the CNntpAdminFeeds


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "feedinfo.h"

/////////////////////////////////////////////////////////////////////////////
// CNntpOneWayFeed:

class CNntpOneWayFeed: 
	public CComDualImpl<INntpOneWayFeed, &IID_INntpOneWayFeed, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpOneWayFeed,&CLSID_CNntpOneWayFeed>
{
	friend class CFeed;

public:
	CNntpOneWayFeed();
	virtual ~CNntpOneWayFeed ();
BEGIN_COM_MAP(CNntpOneWayFeed)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpOneWayFeed)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpOneWayFeed) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpOneWayFeed, _T("Nntpadm.OneWayFeed.1"), _T("Nntpadm.OneWayFeed"), IDS_NNTPONEWAYFEED_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpOneWayFeed
public:
	STDMETHODIMP	get_FeedId			( long * plFeedId );
	STDMETHODIMP	get_RemoteServer	( BSTR * pstrRemoteServer );

	STDMETHODIMP	get_FeedAction	( NNTP_FEED_ACTION * pfeedaction );
	STDMETHODIMP	put_FeedAction	( NNTP_FEED_ACTION feedaction );

	STDMETHODIMP	get_UucpName	( BSTR * pstrUucpName );
	STDMETHODIMP	put_UucpName	( BSTR strUucpName );

	STDMETHODIMP	get_PullNewsDate	( DATE * pdatePullNews );
	STDMETHODIMP	put_PullNewsDate	( DATE datePullNews );

	STDMETHODIMP	get_FeedInterval	( long * plFeedInterval );
	STDMETHODIMP	put_FeedInterval	( long lFeedInterval );

	STDMETHODIMP	get_AutoCreate	( BOOL * pfAutoCreate );
	STDMETHODIMP	put_AutoCreate	( BOOL fAutoCreate );

	STDMETHODIMP	get_Enabled	( BOOL * pfEnabled );
	STDMETHODIMP	put_Enabled	( BOOL fEnabled );

	STDMETHODIMP	get_MaxConnectionAttempts	( long * plMaxConnectionAttempts );
	STDMETHODIMP	put_MaxConnectionAttempts	( long lMaxConnectionAttempts );

	STDMETHODIMP	get_SecurityType	( long * plSecurityType );
	STDMETHODIMP	put_SecurityType	( long lSecurityType );

	STDMETHODIMP	get_AuthenticationType	( long * plAuthenticationType );
	STDMETHODIMP	put_AuthenticationType	( long lAuthenticationType );

	STDMETHODIMP	get_AccountName	( BSTR * pstrAccountName );
	STDMETHODIMP	put_AccountName	( BSTR strAccountName );

	STDMETHODIMP	get_Password	( BSTR * pstrPassword );
	STDMETHODIMP	put_Password	( BSTR strPassword );

	STDMETHODIMP	get_AllowControlMessages	( BOOL * pfAllowControlMessages );
	STDMETHODIMP	put_AllowControlMessages	( BOOL fAllowControlMessages );

	STDMETHODIMP	get_OutgoingPort	( long * plOutgoingPort );
	STDMETHODIMP	put_OutgoingPort	( long lOutgoingPort );

	STDMETHODIMP	get_Newsgroups	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_Newsgroups	( SAFEARRAY * psastrNewsgroups );

	STDMETHODIMP	get_NewsgroupsVariant	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_NewsgroupsVariant	( SAFEARRAY * psastrNewsgroups );

	STDMETHODIMP	get_Distributions	( SAFEARRAY ** ppsastrDistributions );
	STDMETHODIMP	put_Distributions	( SAFEARRAY * psastrDistributions );

	STDMETHODIMP	get_TempDirectory	( BSTR * pstrTempDirectory );
	STDMETHODIMP	put_TempDirectory	( BSTR strTempDirectory );

	STDMETHODIMP	Default		( );

private:
    //
    //  Each one-way feed corresponds to an NNTP_FEED_INFO struct.
    //
    CFeed   m_feed;
};

/////////////////////////////////////////////////////////////////////////////
// CNntpFeed:

class CNntpFeed: 
	public CComDualImpl<INntpFeed, &IID_INntpFeed, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpFeed,&CLSID_CNntpFeed>
{
	friend class CFeedPair;

public:
	CNntpFeed();
	virtual ~CNntpFeed ();
BEGIN_COM_MAP(CNntpFeed)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpFeed)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpFeed) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpFeed, _T("Nntpadm.Feed.1"), _T("Nntpadm.Feed"), IDS_NNTPFEED_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpFeed
public:
	STDMETHODIMP	get_RemoteServer	( BSTR * pstrServerName );
	STDMETHODIMP	put_RemoteServer	( BSTR strServerName );

	STDMETHODIMP	get_FeedType	( NNTP_FEED_SERVER_TYPE * pfeedtype );
	STDMETHODIMP	put_FeedType	( NNTP_FEED_SERVER_TYPE feedtype );

    STDMETHODIMP    get_HasInbound	( BOOL * pfHasInbound );
    STDMETHODIMP    get_HasOutbound	( BOOL * pfHasOutbound );

	STDMETHODIMP	get_InboundFeed	( INntpOneWayFeed ** ppOneWayFeed );
	STDMETHODIMP	put_InboundFeed	( INntpOneWayFeed * pOneWayFeed );

	STDMETHODIMP	get_OutboundFeed	( INntpOneWayFeed ** ppOneWayFeed );
	STDMETHODIMP	put_OutboundFeed	( INntpOneWayFeed * pOneWayFeed );

	STDMETHODIMP	get_InboundFeedDispatch	( IDispatch ** ppOneWayFeed );
	STDMETHODIMP	put_InboundFeedDispatch	( IDispatch * pOneWayFeed );

	STDMETHODIMP	get_OutboundFeedDispatch	( IDispatch ** ppOneWayFeed );
	STDMETHODIMP	put_OutboundFeedDispatch	( IDispatch * pOneWayFeed );

private:
	HRESULT			FromFeedPair ( CFeedPair * pFeedPair );

private:
    CComBSTR                    m_strRemoteServer;
    NNTP_FEED_SERVER_TYPE		m_type;
    CComPtr<INntpOneWayFeed>    m_pInbound;
    CComPtr<INntpOneWayFeed>    m_pOutbound;
};

/////////////////////////////////////////////////////////////////////////////
// CNntpAdminFeeds:

class CNntpAdminFeeds : 
	public INntpAdminFeeds,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminFeeds,&CLSID_CNntpAdminFeeds>
{
public:
	CNntpAdminFeeds();
	virtual ~CNntpAdminFeeds ();
BEGIN_COM_MAP(CNntpAdminFeeds)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminFeeds)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminFeeds) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminFeeds, _T("Nntpadm.Feeds.1"), _T("Nntpadm.Feeds"), IDS_NNTPADMINFEEDS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminFeeds
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminFeeds
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Enumeration Properties:

	STDMETHODIMP	get_Count	( long * plCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate	( );
	STDMETHODIMP	Item		( long lIndex, INntpFeed ** ppFeed );
	STDMETHODIMP	ItemDispatch( long lIndex, IDispatch ** ppFeed );
	STDMETHODIMP	FindID		( long lID, long * plIndex );
	STDMETHODIMP	Add			( INntpFeed * pFeed );
	STDMETHODIMP	AddDispatch	( IDispatch * pFeed );
	STDMETHODIMP	Set			( long lIndex, INntpFeed * pFeed );
	STDMETHODIMP	SetDispatch	( long lIndex, IDispatch * pFeed );
	STDMETHODIMP	Remove		( long lIndex );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	BOOL		m_fEnumerated;
    CFeedPairList   m_listFeeds;

	//////////////////////////////////////////////////////////////////////
	//	Private Methods:
	//////////////////////////////////////////////////////////////////////

	HRESULT		ReturnFeedPair ( CFeedPair * pFeedPair, INntpFeed * pFeed );
	long		IndexFromID ( long dwFeedId );
    long        FindFeedPair ( long dwFeedId );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\groups.cpp ===
// groups.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"

#include "groups.h"
#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Groups.1")
#define THIS_FILE_IID				IID_INntpAdminGroups

#define DEFAULT_NEWSGROUP_NAME			_T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION	_T("")
#define DEFAULT_NEWSGROUP_PRETTYNAME	_T("")
#define DEFAULT_NEWSGROUP_MODERATED		FALSE
#define DEFAULT_NEWSGROUP_MODERATOR		_T("")
#define DEFAULT_NEWSGROUP_READONLY		FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminGroups, CNntpAdminGroups, IID_INntpAdminGroups)

STDMETHODIMP CNntpAdminGroups::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminGroups,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminGroups::CNntpAdminGroups () :
	m_fModerated			( FALSE ),
	m_fReadOnly				( FALSE ),
    m_dateCreation          ( 0 ),
	m_pFindList				( NULL ),
	m_cMatchingGroups		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Groups") );
    m_iadsImpl.SetClass ( _T("IIsNntpGroups") );
}

CNntpAdminGroups::~CNntpAdminGroups ()
{
	if ( m_pFindList ) {
		::NetApiBufferFree ( m_pFindList );
	}

	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminGroups,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Enumeration Properties:

STDMETHODIMP CNntpAdminGroups::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_cMatchingGroups, plCount );
}

STDMETHODIMP CNntpAdminGroups::get_Newsgroup ( BSTR * pstrNewsgroup )
{
	return StdPropertyGet ( m_strNewsgroup, pstrNewsgroup );
}

STDMETHODIMP CNntpAdminGroups::put_Newsgroup ( BSTR strNewsgroup )
{
	return StdPropertyPut ( &m_strNewsgroup, strNewsgroup );
}

STDMETHODIMP CNntpAdminGroups::get_Description ( BSTR * pstrDescription )
{
	return StdPropertyGet ( m_strDescription, pstrDescription );
}

STDMETHODIMP CNntpAdminGroups::put_Description ( BSTR strDescription )
{
	return StdPropertyPut ( &m_strDescription, strDescription );
}

STDMETHODIMP CNntpAdminGroups::get_PrettyName ( BSTR * pstrPrettyName )
{
	return StdPropertyGet ( m_strPrettyName, pstrPrettyName );
}

STDMETHODIMP CNntpAdminGroups::put_PrettyName ( BSTR strPrettyName )
{
    if ( strPrettyName && wcschr ( strPrettyName, _T('\n') ) ) {
        return E_INVALIDARG;
    }

	return StdPropertyPut ( &m_strPrettyName, strPrettyName );
}

STDMETHODIMP CNntpAdminGroups::get_IsModerated ( BOOL * pfIsModerated )
{
	return StdPropertyGet ( m_fModerated, pfIsModerated );
}

STDMETHODIMP CNntpAdminGroups::put_IsModerated ( BOOL fIsModerated )
{
	return StdPropertyPut ( &m_fModerated, fIsModerated );
}

STDMETHODIMP CNntpAdminGroups::get_Moderator ( BSTR * pstrModerator )
{
	return StdPropertyGet ( m_strModerator, pstrModerator );
}

STDMETHODIMP CNntpAdminGroups::put_Moderator ( BSTR strModerator )
{
	return StdPropertyPut ( &m_strModerator, strModerator );
}

STDMETHODIMP CNntpAdminGroups::get_ReadOnly ( BOOL * pfReadOnly )
{
	return StdPropertyGet ( m_fReadOnly, pfReadOnly );
}

STDMETHODIMP CNntpAdminGroups::put_ReadOnly ( BOOL fReadOnly )
{
	return StdPropertyPut ( &m_fReadOnly, fReadOnly );
}

STDMETHODIMP CNntpAdminGroups::get_CreationTime ( DATE * pdateCreation )
{
	return StdPropertyGet ( m_dateCreation, pdateCreation );
}

STDMETHODIMP CNntpAdminGroups::put_CreationTime ( DATE dateCreation )
{
	return StdPropertyPut ( &m_dateCreation, dateCreation );
}

STDMETHODIMP CNntpAdminGroups::get_MatchingCount ( long * plMatchingCount )
{
	return StdPropertyGet ( m_cMatchingGroups, plMatchingCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminGroups::Default ( )
{
	TraceFunctEnter ( "CNntpAdminGroups::Default" );

    SYSTEMTIME      st;

	m_strNewsgroup 		= DEFAULT_NEWSGROUP_NAME;
	m_strDescription 	= DEFAULT_NEWSGROUP_DESCRIPTION;
	m_strPrettyName		= DEFAULT_NEWSGROUP_PRETTYNAME;
	m_fModerated		= DEFAULT_NEWSGROUP_MODERATED;
	m_strModerator		= DEFAULT_NEWSGROUP_MODERATOR;
	m_fReadOnly			= DEFAULT_NEWSGROUP_READONLY;

    GetLocalTime ( &st );
    SystemTimeToVariantTime ( &st, &m_dateCreation );

	if ( 
		!m_strNewsgroup ||
		!m_strDescription ||
		!m_strModerator
		) {

		FatalTrace ( (LPARAM) this, "Out of memory" );
		return E_OUTOFMEMORY;
	}

	TraceFunctLeave ();
	return NOERROR;
}

STDMETHODIMP CNntpAdminGroups::Add ( )
{
	TraceFunctEnter ( "CNntpAdminGroups::Add" );

	HRESULT					hr				= NOERROR;
	DWORD					dwError			= NOERROR;
	LPSTR					szPrettyName	= NULL;
	NNTP_NEWSGROUP_INFO		newsgroup;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	_ASSERT ( m_strNewsgroup );

	hr = UnicodeToMime2 ( m_strPrettyName, &szPrettyName );
	BAIL_ON_FAILURE(hr);

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) m_strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( m_strNewsgroup );
	if ( szPrettyName && *szPrettyName ) {
		newsgroup.Prettyname	= (PUCHAR) szPrettyName;
		newsgroup.cbPrettyname	= strlen (szPrettyName) + sizeof(char);
	}
	else {
		newsgroup.Prettyname	= NULL;
		newsgroup.cbPrettyname	= 0;
	}
	newsgroup.Description	= (PUCHAR) (LPWSTR) m_strDescription;
	newsgroup.cbDescription	= STRING_BYTE_LENGTH ( m_strDescription );
	newsgroup.fIsModerated	= m_fModerated;
	if ( m_strModerator == NULL || *m_strModerator == NULL ) {
		newsgroup.Moderator		= NULL;
		newsgroup.cbModerator	= 0;
	}
	else {
		newsgroup.Moderator		= (PUCHAR) (LPWSTR) m_strModerator;
		newsgroup.cbModerator	= STRING_BYTE_LENGTH ( m_strModerator );
	}
	newsgroup.ReadOnly		= m_fReadOnly;

	dwError = NntpCreateNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &newsgroup
        );
	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to add newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	if ( szPrettyName ) {
		m_pMimeAlloc->Free ( szPrettyName );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Remove ( BSTR strNewsgroup )
{
	TraceFunctEnter ( "CNntpAdminGroups::Remove" );
	
	_ASSERT ( IS_VALID_STRING ( strNewsgroup ) );

	HRESULT					hr			= NOERROR;
	DWORD					dwError		= NOERROR;
	NNTP_NEWSGROUP_INFO		newsgroup;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( strNewsgroup );

	dwError = NntpDeleteNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &newsgroup
        );
	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to remove newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Get ( BSTR strNewsgroup )
{
	TraceFunctEnter ( "CNntpAdminGroups::Get" );

	_ASSERT ( IS_VALID_STRING ( strNewsgroup ) );

	HRESULT					hr			= NOERROR;
	DWORD					dwError		= NOERROR;
	NNTP_NEWSGROUP_INFO		newsgroup;
	LPNNTP_NEWSGROUP_INFO	pNewsgroup	= &newsgroup;
    SYSTEMTIME              st;
    FILETIME                ftLocal;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( strNewsgroup );

	dwError = NntpGetNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &pNewsgroup
        );
	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to get newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	_ASSERT ( IS_VALID_STRING ( (LPWSTR) pNewsgroup->Newsgroup ) );

	m_strNewsgroup 		= pNewsgroup->Newsgroup ? (LPWSTR) pNewsgroup->Newsgroup : _T("");
	m_strDescription 	= pNewsgroup->Description ? (LPWSTR) pNewsgroup->Description : _T("");
	m_fModerated		= pNewsgroup->fIsModerated;
	m_strModerator 		= pNewsgroup->Moderator ? (LPWSTR) pNewsgroup->Moderator : _T("");
	m_fReadOnly			= pNewsgroup->ReadOnly;

    FileTimeToLocalFileTime ( &pNewsgroup->ftCreationDate, &ftLocal );
    FileTimeToSystemTime ( &ftLocal, &st );
    SystemTimeToVariantTime ( &st, &m_dateCreation );

	if ( pNewsgroup->Prettyname && *pNewsgroup->Prettyname ) {
		hr = Mime2ToUnicode ( (LPSTR) pNewsgroup->Prettyname, m_strPrettyName );
		if ( FAILED(hr) ) {
			m_strPrettyName	= _T("");
			hr = NOERROR;
		}
	}
	else {
		m_strPrettyName     = _T("");
	}

	if ( 
		!m_strNewsgroup ||
		!m_strDescription ||
        !m_strPrettyName ||
		!m_strModerator 
		) {

		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	if ( pNewsgroup && pNewsgroup != &newsgroup ) {
		NetApiBufferFree ( pNewsgroup );
	}

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Set ( )
{
	TraceFunctEnter ( "CNntpAdminGroups::Set" );

	HRESULT		                    hr				= NOERROR;
	DWORD					        dwError			= NOERROR;
	LPSTR							szPrettyName	= NULL;
	NNTP_NEWSGROUP_INFO		        newsgroup;
    SYSTEMTIME                      st;
    FILETIME                        ftLocal;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	_ASSERT ( m_strNewsgroup );

	hr = UnicodeToMime2 ( m_strPrettyName, &szPrettyName );
	BAIL_ON_FAILURE(hr);

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) m_strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( m_strNewsgroup );
	newsgroup.Description	= (PUCHAR) (LPWSTR) m_strDescription;
	newsgroup.cbDescription	= STRING_BYTE_LENGTH ( m_strDescription );
	if ( szPrettyName && *szPrettyName ) {
		newsgroup.Prettyname	= (PUCHAR) szPrettyName;
		newsgroup.cbPrettyname	= strlen (szPrettyName) + sizeof(char);
	}
	else {
		newsgroup.Prettyname	= NULL;
		newsgroup.cbPrettyname	= 0;
	}
	newsgroup.fIsModerated	= m_fModerated;
	if ( m_strModerator == NULL || *m_strModerator == NULL ) {
		newsgroup.Moderator		= NULL;
		newsgroup.cbModerator	= 0;
	}
	else {
		newsgroup.Moderator		= (PUCHAR) (LPWSTR) m_strModerator;
		newsgroup.cbModerator	= STRING_BYTE_LENGTH ( m_strModerator );
	}
	newsgroup.ReadOnly		= m_fReadOnly;

    VariantTimeToSystemTime ( m_dateCreation, &st );
    SystemTimeToFileTime ( &st, &ftLocal );
    LocalFileTimeToFileTime ( &ftLocal, &newsgroup.ftCreationDate );

	dwError = NntpSetNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &newsgroup
        );

	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to set newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	if ( szPrettyName ) {
		m_pMimeAlloc->Free ( szPrettyName );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::MatchingGroup ( long iGroup, BSTR * pstrNewsgroup )
{
	TraceFunctEnter ( "CNntpAdminGroups::MatchingGroup" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pstrNewsgroup ) );

	HRESULT		hr			= NOERROR;

	if ( pstrNewsgroup == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	*pstrNewsgroup = NULL;

	// Did we enumerate first?
	if ( m_pFindList == NULL ) {
		ErrorTrace ( (LPARAM) this, "Failed to call find first" );

		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_FIND );
	}
	
	// Is the index valid?
	if ( iGroup < 0 || (DWORD) iGroup >= m_cMatchingGroups ) {
		ErrorTraceX ( (LPARAM) this, "Invalid index: %d", iGroup );

		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	_ASSERT ( IS_VALID_STRING ( m_pFindList->aFindEntry [ iGroup ].lpszName ) );

	// Copy the property into the result:
	*pstrNewsgroup = ::SysAllocString ( m_pFindList->aFindEntry [ iGroup ].lpszName );

	if ( *pstrNewsgroup == NULL ) {

		// Allocation failed.
		FatalTrace ( 0, "Out of memory" );
		hr = E_OUTOFMEMORY;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Find ( 
	BSTR strWildmat,
	long cMaxResults
	)
{
	TraceFunctEnter ( "CNntpAdminGroups::Find" );

	HRESULT		hr			= NOERROR;
	DWORD		dwError		= NOERROR;

	// Free the old newsgroup list:
	if ( m_pFindList ) {
		::NetApiBufferFree ( m_pFindList );
		m_pFindList		= NULL;
	}
	m_cMatchingGroups	= 0;

	dwError = NntpFindNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        strWildmat,
        cMaxResults,
        &m_cMatchingGroups,
        &m_pFindList
        );
	if ( dwError != 0 ) {
		ErrorTraceX ( (LPARAM) this, "Failed to find groups: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT
CNntpAdminGroups::CancelMessage (
    BSTR    strMessageID
    )
{
    TraceFunctEnter ( "CNntpAdminGroups::CancelMessage" );

    HRESULT     hr          = NOERROR;
    DWORD       dwError     = NOERROR;
    LPSTR       szMessageID = NULL;
    int         cchMessageID = 0;

    if ( !strMessageID ) {
        BAIL_WITH_FAILURE( hr, E_INVALIDARG );
    }

    cchMessageID = WideCharToMultiByte ( CP_ACP, 0, strMessageID, -1, NULL, 0, NULL, NULL );

    szMessageID = new char [ cchMessageID ];
    if ( !szMessageID ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    WideCharToMultiByte ( CP_ACP, 0, strMessageID, -1, szMessageID, cchMessageID, NULL, NULL );

    dwError = NntpCancelMessageID (
        m_iadsImpl.QueryComputer (),
        m_iadsImpl.QueryInstance (),
        szMessageID
        );

    if ( dwError != 0 ) {
        BAIL_WITH_FAILURE ( hr, RETURNCODETOHRESULT ( dwError ) );
    }

Exit:
    delete [] szMessageID;

    TRACE_HRESULT(hr);
    TraceFunctLeave ();
    return hr;
}

HRESULT CNntpAdminGroups::AllocateMimeOleObjects ( )
{
	HRESULT		hr	= NOERROR;

	if ( !m_pMimeAlloc ) {
	    hr = CoCreateInstance ( CLSID_IMimeAllocator,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IMimeAllocator,
								(void **) &m_pMimeAlloc
								);
	    BAIL_ON_FAILURE(hr);
	}

	if ( !m_pMimeInternational ) {
	    hr = CoCreateInstance ( CLSID_IMimeInternational,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IMimeInternational,
								(void **) &m_pMimeInternational
								);
	    BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT CNntpAdminGroups::UnicodeToMime2 ( LPCWSTR wszUnicode, LPSTR * pszMime2 )
{
    TraceQuietEnter("CNntpAdminGroups::UnicodeToMime2");

	_ASSERT ( IS_VALID_OUT_PARAM ( pszMime2 ) );

	HRESULT			hr = S_OK;
    PROPVARIANT    	pvSrc;
    RFC1522INFO    	rfc1522info;
    HCHARSET        hCharset = NULL;

	ZeroMemory ( &pvSrc, sizeof (pvSrc) );
	ZeroMemory ( &rfc1522info, sizeof (rfc1522info) );

    if ( !wszUnicode || !*wszUnicode ) {
        *pszMime2 = NULL;
        goto Exit;
    }

	_ASSERT ( IS_VALID_STRING ( wszUnicode ) );

	hr = AllocateMimeOleObjects ();
	BAIL_ON_FAILURE(hr);

    pvSrc.vt        = VT_LPWSTR;
    pvSrc.pwszVal   = const_cast<LPWSTR> (wszUnicode);

    rfc1522info.fRfc1522Used    = TRUE;
    rfc1522info.fRfc1522Allowed = TRUE;
    rfc1522info.fAllow8bit		= FALSE;

    // Try to get the UTF-8 character set
    hr = m_pMimeInternational->FindCharset("UTF-8", &hCharset);
    if (FAILED(hr)) {
        ErrorTrace(0, "Error getting UTF-8 character set, %x", hr);
        hCharset = NULL;
    }

    hr = m_pMimeInternational->EncodeHeader ( 
    		hCharset, 
    		&pvSrc, 
    		pszMime2, 
    		&rfc1522info 
    		);
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

HRESULT CNntpAdminGroups::Mime2ToUnicode ( LPCSTR szMime2, CComBSTR & strUnicode )
{
	_ASSERT ( IS_VALID_IN_PARAM (szMime2) );

	HRESULT			hr = S_OK;
    PROPVARIANT    	pvDest;
    RFC1522INFO    	rfc1522info;

	ZeroMemory ( &pvDest, sizeof (pvDest) );
	ZeroMemory ( &rfc1522info, sizeof (rfc1522info) );

    if ( !szMime2 || !*szMime2 ) {
        strUnicode = _T("");
        goto Exit;
    }

	hr = AllocateMimeOleObjects ();
	BAIL_ON_FAILURE(hr);

    pvDest.vt        = VT_LPWSTR;

    rfc1522info.fRfc1522Used    = TRUE;
    rfc1522info.fRfc1522Allowed = TRUE;
    rfc1522info.fAllow8bit		= TRUE;

    hr = m_pMimeInternational->DecodeHeader ( 
    		NULL, 
    		const_cast<LPSTR> (szMime2), 
    		&pvDest, 
    		&rfc1522info 
    		);
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

	_ASSERT ( pvDest.vt == VT_LPWSTR );

	strUnicode	= pvDest.pwszVal;
	if ( !strUnicode ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	m_pMimeAlloc->PropVariantClear ( &pvDest );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\guids.cpp ===
#include "stdafx.h"

#define INITGUIDS
#include "initguid.h"

#include "mimeole.h"

//
//	My GUIDS:
//

#include "nntpadm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\groups.h ===
// groups.h : Declaration of the CNntpAdminGroups


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "nntptype.h"
#include "nntpapi.h"
#include <mimeole.h>

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminGroups : 
	public INntpAdminGroups,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminGroups,&CLSID_CNntpAdminGroups>
{
public:
	CNntpAdminGroups();
	virtual ~CNntpAdminGroups();
BEGIN_COM_MAP(CNntpAdminGroups)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminGroups)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminGroups) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminGroups, _T("Nntpadm.Groups.1"), _T("Nntpadm.Groups"), IDS_NNTPADMINGROUPS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminGroups
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminGroups
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Enumeration Properties:

	STDMETHODIMP	get_Count	( long * plCount );

	// Newsgroup Properties:

	STDMETHODIMP	get_Newsgroup	( BSTR * pstrNewsgroup );
	STDMETHODIMP	put_Newsgroup	( BSTR strNewsgroup );

	STDMETHODIMP	get_Description	( BSTR * pstrDescription );
	STDMETHODIMP	put_Description	( BSTR strDescription );

	STDMETHODIMP	get_PrettyName  ( BSTR * pstrPrettyName );
	STDMETHODIMP	put_PrettyName  ( BSTR strPrettyName );

	STDMETHODIMP	get_IsModerated	( BOOL * pfIsModerated );
	STDMETHODIMP	put_IsModerated	( BOOL fIsModerated );

	STDMETHODIMP	get_Moderator	( BSTR * pstrModerator );
	STDMETHODIMP	put_Moderator	( BSTR strModerator );

	STDMETHODIMP	get_ReadOnly	( BOOL * pfReadOnly );
	STDMETHODIMP	put_ReadOnly	( BOOL fReadOnly );

	STDMETHODIMP	get_CreationTime	( DATE * pdateCreation );
	STDMETHODIMP	put_CreationTime	( DATE dateCreation );

	STDMETHODIMP	get_MatchingCount	( long * plCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Default	( );
	STDMETHODIMP	Add		( );
	STDMETHODIMP	Remove	( BSTR strNewsgroup );
	STDMETHODIMP	Get		( BSTR strNewsgroup );
	STDMETHODIMP	Set		( );

	STDMETHODIMP	MatchingGroup	( long iGroup, BSTR * pstrNewsgroup );
	STDMETHODIMP	Find			( BSTR strWildmat, long cMaxResults );

	STDMETHODIMP	CancelMessage	( BSTR strMessageID );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	CComPtr<IMimeAllocator>		m_pMimeAlloc;
	CComPtr<IMimeInternational>	m_pMimeInternational;

	CComBSTR	m_strNewsgroup;
	CComBSTR	m_strDescription;
	CComBSTR	m_strPrettyName;
	BOOL		m_fModerated;
	CComBSTR	m_strModerator;
	BOOL		m_fReadOnly;
    DATE        m_dateCreation;

	DWORD				m_cMatchingGroups;
	LPNNTP_FIND_LIST	m_pFindList;

	HRESULT		AllocateMimeOleObjects	 ( );
	HRESULT		UnicodeToMime2	( LPCWSTR wszUnicode, LPSTR * pszMime2 );
	HRESULT		Mime2ToUnicode	( LPCSTR szMime2, CComBSTR & strUnicode );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\ipaccess.cpp ===
// ipaccess.cpp : Implementation of CTcpAccess & CTcpAccessExceptions.

#include "stdafx.h"

#include "pudebug.h"
#define _RDNS_STANDALONE
#include <rdns.hxx>

DECLARE_DEBUG_PRINTS_OBJECT()

#include "nntpcmn.h"
#include "cmultisz.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.TcpAccess.1")
#define THIS_FILE_IID				IID_ITcpAccess

//
//	Useful macros:
//

#define MAKEIPADDRESS(b1,b2,b3,b4) (((DWORD)(b1)<<24) +\
                                    ((DWORD)(b2)<<16) +\
                                    ((DWORD)(b3)<< 8) +\
                                    ((DWORD)(b4)))

#define GETIP_FIRST(x)             ((x>>24) & 0xff)
#define GETIP_SECOND(x)            ((x>>16) & 0xff)
#define GETIP_THIRD(x)             ((x>> 8) & 0xff)
#define GETIP_FOURTH(x)            ((x)     & 0xff)

inline void 
DWORDtoLPBYTE ( 
	IN	DWORD	dw, 
	OUT	LPBYTE	lpBytes 
	)
{
	_ASSERT ( !IsBadWritePtr ( lpBytes, 4 * sizeof ( BYTE ) ) ); 

	lpBytes[0] = (BYTE)GETIP_FIRST(dw);
	lpBytes[1] = (BYTE)GETIP_SECOND(dw);
	lpBytes[2] = (BYTE)GETIP_THIRD(dw);
	lpBytes[3] = (BYTE)GETIP_FOURTH(dw);
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccess::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccess,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccess::CTcpAccess ()
	// CComBSTR's are initialized to NULL by default.
{
	m_pGrantList		= NULL;
	m_pDenyList			= NULL;
}

CTcpAccess::~CTcpAccess ()
{
	// All CComBSTR's are freed automatically.

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
    }
}

HRESULT CTcpAccess::GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC )
{
	HRESULT				hr		= NOERROR;
	DWORD				dwDummy	= 0;
	DWORD				cbIpSec	= 0;
	BYTE *				pIpSec	= NULL;

	hr = pMB->GetDataSize ( _T(""), MD_IP_SEC, BINARY_METADATA, &cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		hr = NOERROR;
		cbIpSec = 0;
	}
	BAIL_ON_FAILURE ( hr );

	if ( cbIpSec != 0 ) {
		pIpSec = new BYTE [ cbIpSec ];
		if ( !pIpSec ) {
			BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
		}

		hr = pMB->GetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
		BAIL_ON_FAILURE (hr);

		pAC->BindCheckList ( pIpSec, cbIpSec );
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Private admin object interface:
//////////////////////////////////////////////////////////////////////

HRESULT CTcpAccess::GetFromMetabase ( CMetabaseKey * pMB )
{
    HRESULT     	hr	= NULL;
	CComObject<CTcpAccessExceptions> *	pGrantList	= NULL;
	CComObject<CTcpAccessExceptions> *	pDenyList	= NULL;

    ADDRESS_CHECK	ac;

	hr = GetAddressCheckFromMetabase ( pMB, &ac );
	BAIL_ON_FAILURE ( hr );

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pGrantList );
	BAIL_ON_FAILURE(hr);

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pDenyList );
	BAIL_ON_FAILURE(hr);

	//
	//	Copy each list into our object:
	//

	hr = pGrantList->FromAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = pDenyList->FromAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	//
	//	Replace the old grant & deny lists with the new ones:
	//

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
        m_pGrantList = NULL;
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
        m_pDenyList = NULL;
    }

    m_pGrantList    = pGrantList;
    m_pDenyList     = pDenyList;

    m_pGrantList->AddRef ();
    m_pDenyList->AddRef ();

Exit:
	ac.UnbindCheckList ();

	if ( FAILED(hr) ) {
		delete pGrantList;
		delete pDenyList;
	}

	return hr;
}

HRESULT CTcpAccess::SendToMetabase ( CMetabaseKey * pMB )
{
	HRESULT			hr;
	ADDRESS_CHECK	ac;
	BYTE *			pIpSec	= NULL;
	DWORD			cbIpSec	= 0;

	_ASSERT ( m_pGrantList );
	_ASSERT ( m_pDenyList );

	ac.BindCheckList ();

	hr = m_pGrantList->ToAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = m_pDenyList->ToAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	cbIpSec	= ac.QueryCheckListSize ();
	pIpSec	= ac.QueryCheckListPtr ();

	hr = pMB->SetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE );

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccess::get_GrantedList ( ITcpAccessExceptions ** ppGrantedList )
{
	return m_pGrantList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppGrantedList );
}

STDMETHODIMP CTcpAccess::get_DeniedList ( ITcpAccessExceptions ** ppDeniedList )
{
	return m_pDenyList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppDeniedList );
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessExceptions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessExceptions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessExceptions::CTcpAccessExceptions () :
	m_cCount	( 0 ),
	m_rgItems	( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessExceptions::~CTcpAccessExceptions ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessExceptions::FromAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cNames;
	DWORD		cAddresses;
	DWORD		i;

	cNames		= pAC->GetNbName ( fGrantList );
	cAddresses	= pAC->GetNbAddr ( fGrantList );

	//
	//	Copy the Dns Names:
	//

	for ( i = 0; i < cNames; i++ ) {
		DWORD		dwFlags	= 0;
		LPSTR		lpName	= NULL;
		CComBSTR	strDomain;

		if ( pAC->GetName ( fGrantList, i, &lpName, &dwFlags ) ) {

			if ( !(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN) ) {
				strDomain = _T("*.");

				strDomain.Append ( lpName );
			}
			else {
				strDomain = lpName;
			}

			hr = AddDnsName ( strDomain );
			BAIL_ON_FAILURE(hr);
		}
	}

	//
	//	Copy the IpAddresses:
	//

	for ( i = 0; i < cAddresses; i++ ) {
		DWORD		dwFlags	= 0;
		LPBYTE		lpMask	= NULL;
		LPBYTE		lpAddr	= NULL;
		DWORD		dwIpAddress;
		DWORD		dwIpMask;

		if ( pAC->GetAddr ( fGrantList, i, &dwFlags, &lpMask, &lpAddr ) ) {

			dwIpAddress	= MAKEIPADDRESS( lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3] );
			dwIpMask	= MAKEIPADDRESS( lpMask[0], lpMask[1], lpMask[2], lpMask[3] );

			hr = AddIpAddress ( (long) dwIpAddress, (long) dwIpMask );
			BAIL_ON_FAILURE(hr);
		}
	}

Exit:
	return hr;
}

HRESULT 
CTcpAccessExceptions::ToAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList
	)
{
	HRESULT		hr	= NOERROR;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL	fIsName	= FALSE;
		BOOL	fIsAddr	= FALSE;

		m_rgItems[i]->get_IsDnsName		( &fIsName );
		m_rgItems[i]->get_IsIpAddress	( &fIsAddr );

		if ( fIsName ) {
			CComBSTR	strDnsName;
			DWORD		cchName		= 0;
			LPSTR		szAnsiName	= NULL;

			DWORD		dwFlags		= 0;
			LPSTR		lpName		= NULL;

			hr = m_rgItems[i]->get_DnsName ( &strDnsName );
			BAIL_ON_FAILURE(hr);

			cchName = strDnsName.Length ( );

			szAnsiName = new char [ cchName + 1 ];
			if ( !szAnsiName ) {
				BAIL_WITH_FAILURE( hr, E_OUTOFMEMORY );
			}

			WideCharToMultiByte ( CP_ACP, 0, strDnsName, -1, szAnsiName, cchName + 1, NULL, NULL );

			if ( strncmp ( szAnsiName, "*.", 2 ) == 0 ) {
				dwFlags	= 0;
				lpName	= szAnsiName + 2;
			}
			else {
				dwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;
				lpName	= szAnsiName;
			}
			pAC->AddName ( fGrantList, lpName, dwFlags );

			delete szAnsiName;
		}
		else if ( fIsAddr ) {
			long	lIpAddress	= 0;
			long	lIpMask		= 0;
			BYTE	bIp[4];
			BYTE	bMask[4];

			m_rgItems[i]->get_IpAddress ( &lIpAddress );
			m_rgItems[i]->get_IpMask	( &lIpMask );

			DWORDtoLPBYTE ( (DWORD) lIpAddress, bIp );
			DWORDtoLPBYTE ( (DWORD) lIpMask, bMask );

			pAC->AddAddr ( fGrantList, AF_INET, bMask, bIp );
		}
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessExceptions::get_Count ( long * pcCount )
{
	return StdPropertyGet ( m_cCount, pcCount );
}

STDMETHODIMP CTcpAccessExceptions::AddDnsName ( BSTR strDnsName )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( strDnsName, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::AddIpAddress ( long lIpAddress, long lIpMask )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( lIpAddress, lIpMask, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

HRESULT CTcpAccessExceptions::AddItem ( ITcpAccessException * pNew )
{
	HRESULT							hr			= NOERROR;
	CComPtr<ITcpAccessException> *	rgNewItems	= NULL;
	long							i;

	rgNewItems = new CComPtr<ITcpAccessException> [ m_cCount + 1 ];
	if ( !rgNewItems ) {
		BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
	}

	for ( i = 0; i < m_cCount; i++ ) {
		rgNewItems[i] = m_rgItems[i];
	}
	rgNewItems[m_cCount] = pNew;

	delete [] m_rgItems;
	m_rgItems = rgNewItems;
	m_cCount++;

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Item ( long index, ITcpAccessException ** ppTcpAccessException )
{
	HRESULT		hr;

	if ( index < 0 || index >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	hr = m_rgItems[index]->QueryInterface ( IID_ITcpAccessException, (void **) ppTcpAccessException );
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Remove ( long index )
{
	HRESULT					hr		= NOERROR;
	CComPtr<ITcpAccessException>	pTemp;
	long					i;

	if ( index < 0 || index >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	for ( i = index + 1; i < m_cCount; i++ ) {
		m_rgItems[i - 1] = m_rgItems[i];
	}

	m_rgItems[m_cCount - 1].Release ();
	m_cCount--;

	return hr;
}

STDMETHODIMP 
CTcpAccessExceptions::FindDnsIndex (
	BSTR	strDnsNameToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		HRESULT		hr1;
		CComBSTR	strDnsName;
		BOOL		fIsDnsName	= FALSE;

		hr1 = m_rgItems[i]->get_IsDnsName ( &fIsDnsName );
		if ( !fIsDnsName ) {
			continue;
		}

		hr1 = m_rgItems[i]->get_DnsName ( &strDnsName );

		if ( SUCCEEDED(hr1) &&
			!lstrcmpi ( strDnsName, strDnsNameToFind ) ) {

			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP 
CTcpAccessExceptions::FindIpIndex (
	long	lIpAddressToFind,
	long	lIpMaskToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL		fIsIpAddress	= FALSE;
		long		lIpAddress;
		long		lIpMask;

		m_rgItems[i]->get_IsIpAddress ( &fIsIpAddress );
		if ( !fIsIpAddress ) {
			continue;
		}

		m_rgItems[i]->get_IpAddress ( &lIpAddress );
		m_rgItems[i]->get_IpMask ( &lIpMask );

		if ( lIpAddress == lIpAddressToFind && lIpMask == lIpMaskToFind ) {
			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP CTcpAccessExceptions::Clear ( )
{
	delete [] m_rgItems;
	m_rgItems	= NULL;
	m_cCount		= 0;

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessException::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessException,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessException::CTcpAccessException () :
	m_fIsDnsName	( FALSE ),
	m_fIsIpAddress	( FALSE ),
	m_dwIpAddress	( 0 ),
	m_dwIpMask		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessException::~CTcpAccessException ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessException::CreateNew ( 
	LPWSTR strDnsName, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_DnsName ( strDnsName );
	BAIL_ON_FAILURE(hr);

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

HRESULT 
CTcpAccessException::CreateNew ( 
	DWORD dwIpAddress, 
	DWORD dwIpMask, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_IpAddress ( (long) dwIpAddress );
	hr = pNew->put_IpMask ( (long) dwIpMask );

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessException::get_IsDnsName ( BOOL * pfIsDnsName )
{
	return StdPropertyGet ( m_fIsDnsName, pfIsDnsName );
}

STDMETHODIMP CTcpAccessException::get_IsIpAddress ( BOOL * pfIsIpAddress )
{
	return StdPropertyGet ( m_fIsIpAddress, pfIsIpAddress );
}

STDMETHODIMP CTcpAccessException::get_DnsName ( BSTR * pstrDnsName )
{
	return StdPropertyGet ( m_strDnsName, pstrDnsName );
}

STDMETHODIMP CTcpAccessException::put_DnsName ( BSTR strDnsName )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_strDnsName, strDnsName );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= TRUE;
		m_fIsIpAddress	= FALSE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpAddress ( long * plIpAddress )
{
	return StdPropertyGet ( m_dwIpAddress, plIpAddress );
}

STDMETHODIMP CTcpAccessException::put_IpAddress ( long lIpAddress )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_dwIpAddress, lIpAddress );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= FALSE;
		m_fIsIpAddress	= TRUE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpMask ( long * plIpMask )
{
	return StdPropertyGet ( m_dwIpMask, plIpMask );
}

STDMETHODIMP CTcpAccessException::put_IpMask ( long lIpMask )
{
	return StdPropertyPut ( &m_dwIpMask, lIpMask );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\makefile.inc ===
$(O)\nntpadm.h $(O)\nntpadm_i.c : $(STAXINC)\export\nntpadm.idl
    $(MIDL) \
    $(INCPATH0) \
    -proxy $(PASS0_SOURCEDIR)\nntpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpadm_i.c \
    -header $@ \
    -tlb $(O)\nntpadm.tlb \
    $**

copytlb:
	xcopy /verifd $(IISBASEDIR)\svcs\adsi\oleds2.0\types\activeds.tlb $(O)

copyfiles:
!if "$(_NTTREE)" != ""
	#if not exist $(_NTTREE)\staxpt mkdir $(_NTTREE)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rexpire.vbs $(_NTTREE)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rgroup.vbs $(_NTTREE)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rserver.vbs $(_NTTREE)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rsess.vbs $(_NTTREE)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rcancel.vbs $(_NTTREE)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rfeed.vbs $(_NTTREE)\staxpt
!endif
!if "$(_NTTREE_NO_SPLIT)" != ""
	#if not exist $(_NTTREE_NO_SPLIT)\staxpt mkdir $(_NTTREE_NO_SPLIT)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rexpire.vbs $(_NTTREE_NO_SPLIT)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rgroup.vbs $(_NTTREE_NO_SPLIT)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rserver.vbs $(_NTTREE_NO_SPLIT)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rsess.vbs $(_NTTREE_NO_SPLIT)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rcancel.vbs $(_NTTREE_NO_SPLIT)\staxpt
	perl -S xcopy2binplace.pl /verifd scripts\rfeed.vbs $(_NTTREE_NO_SPLIT)\staxpt
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\ipaccess.h ===
//
//	Dependencies
//

class ADDRESS_CHECK;
class CTcpAccess;
class CTcpAccessExceptions;
class CTcpAccessException;
class CMetabaseKey;

/////////////////////////////////////////////////////////////////////////////
// The TcpAccess Object

class CTcpAccess : 
	public CComDualImpl<ITcpAccess, &IID_ITcpAccess, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccess();
	virtual ~CTcpAccess ();

BEGIN_COM_MAP(CTcpAccess)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccess)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccess) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccess, _T("Nntpadm.TcpAccess.1"), _T("Nntpadm.TcpAccess"), IDS_TCPACCESS_DESC, THREADFLAGS_BOTH)
// Private admin object interface:
public:
	HRESULT			GetFromMetabase ( CMetabaseKey * pMB );
	HRESULT			SendToMetabase ( CMetabaseKey * pMB );

// ITcpAccess
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_GrantedList	( ITcpAccessExceptions ** ppGrantedList );
	STDMETHODIMP	get_DeniedList	( ITcpAccessExceptions ** ppDeniedList );
/*
	STDMETHODIMP	put_GrantedList	( ITcpAccessExceptions * pGrantedList );
	STDMETHODIMP	put_DeniedList	( ITcpAccessExceptions * pDeniedList );
*/
	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComObject<CTcpAccessExceptions> *	m_pGrantList;
	CComObject<CTcpAccessExceptions> *	m_pDenyList;

	HRESULT	GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC );
};

/////////////////////////////////////////////////////////////////////////////
// The TcpAccessExceptions Object

class CTcpAccessExceptions : 
	public CComDualImpl<ITcpAccessExceptions, &IID_ITcpAccessExceptions, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessExceptions();
	virtual ~CTcpAccessExceptions ();

BEGIN_COM_MAP(CTcpAccessExceptions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessExceptions)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessExceptions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessExceptions, _T("Nntpadm.TcpAccessExceptions.1"), _T("Nntpadm.TcpAccessExceptions"), IDS_TCPACCESSEXCEPTIONS_DESC, THREADFLAGS_BOTH)
//
//	Private admin object interface:
//
	HRESULT FromAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );
	HRESULT ToAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );

// ITcpAccessExceptions
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pcCount );
	STDMETHODIMP	AddDnsName	( BSTR strDnsName );
	STDMETHODIMP	AddIpAddress( long lIpAddress, long lIpMask );
	STDMETHODIMP	Item		( long index, ITcpAccessException ** ppAccessException );
	STDMETHODIMP	Remove		( long index );
	STDMETHODIMP	FindDnsIndex( BSTR strDnsName, lon