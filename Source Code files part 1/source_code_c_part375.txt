
     &&  pSearchRes->count > 0) {
    
        DPRINT1(0,"%d sites returned\n", pSearchRes->count);

        EntInfList = &pSearchRes->FirstEntInf;
        while (EntInfList) {
        
            ULONG cost = 0xFFFFFFFF;
            PSCHEDULE  schedule = NULL;

            EntInf = &EntInfList->Entinf;

            DPRINT1(0,"Site link %ws found \n", EntInf->pName->StringName);
    
            for (j = 0; j < EntInf->AttrBlock.attrCount; j++) {
        
                ATTR *pAttr = &EntInf->AttrBlock.pAttr[j];
                ULONG Options;
            
                switch (pAttr->attrTyp) {
                
                case ATT_SCHEDULE:
    
                    schedule = (PSCHEDULE)pAttr->AttrVal.pAVal[0].pVal;
                    Assert(schedule->Size == pAttr->AttrVal.pAVal[0].valLen);
                    break;
    
                case ATT_COST:
    
                    Assert(sizeof(DWORD) == pAttr->AttrVal.pAVal[0].valLen);
                    cost = *(ULONG*)pAttr->AttrVal.pAVal[0].pVal;
                    break;
    
                }
            }
    
            if ( (minimumName == NULL)
              || (cost < minimumCost)   ) {

                //
                // A new winner!
                //
                minimumCost = cost;
                minimumSchedule = schedule;
                minimumName = EntInf->pName;
    
            }

            EntInfList = EntInfList->pNextEntInf;
        }
        
    }

    if (minimumName == NULL) {

        err = ERROR_NOT_FOUND;

    } else {

        //
        // Success
        //

        *ppSchedule = minimumSchedule;

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_PREFERRED_SITE_LINK,
                 szInsertDN(minimumName),
                 NULL,
                 NULL);

        err = 0;

    }
    
    return err;
 }

#if DBG

LPSTR
GetDay(
    ULONG i
    )
{
    switch (i) {
    case 0:
        return "Sun";
    case 1:
        return "Mon";
    case 2:
        return "Tue";
    case 3:
        return "Wed";
    case 4:
        return "Th";
    case 5:
        return "Fri";
    case 6:
        return "Sat";
    default:
        return NULL;
    }
}

LPSTR
GetMonth(
    ULONG i
    )
{
    switch (i) {
    case 1:
        return "Jan";
    case 2:
        return "Feb";
    case 3:
        return "Mar";
    case 4:
        return "Apr";
    case 5:
        return "May";
    case 6:
        return "Jun";
    case 7:
        return "Jul";
    case 8:
        return "Aug";
    case 9:
        return "Sep";
    case 10:
        return "Oct";
    case 11:
        return "Nov";
    case 12:
        return "Dec";
    default:
        return NULL;
    }
}


LPSTR
DbgPrintDsTime(
    DSTIME time,
    CHAR * buffer
    )
{
    FILETIME ft;
    SYSTEMTIME st;
    DSTIME localTime;

    localTime = (10*1000*1000L) * time;

    ft.dwHighDateTime = (DWORD)(localTime >> 32);
    ft.dwLowDateTime =  (DWORD)(localTime);

    if (FileTimeToSystemTime(&ft, &st)) {

        sprintf(buffer, 
                "%s %s %d, %d  %d:%d:%d", 
                GetDay(st.wDayOfWeek),
                GetMonth(st.wMonth),
                st.wDay,
                st.wYear,
                st.wHour,
                st.wMinute,
                st.wSecond);

        return buffer;
    }

    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\samdsply.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       samdsply.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains DS side services for  implementing the Display Information
    API from the DS.



Author:

    Murli Satagopan   (Murlis)  17 December 1996

Environment:

    User Mode - Win32

Revision History:



--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>
#include <mappings.h>
#include <objids.h>
#include <direrr.h>
#include <mdcodes.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <debug.h>
#include <dbglobal.h>
#include <dbintrnl.h>

#include <fileno.h>
#define  FILENO FILENO_SAM

#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <samisrv.h>


#define DEBSUB      "SAMDSPLY:"

#define MAX_INDEX_LENGTH 256

 //
 // Macro to guard against inconsistent returns by Jet, while querying fractional positions
 // This checks wether
 //    1. Denominator is 0
 //    2. Numerator is greater than Denominator
 //    3. Wether fractional position is monotonically increasing, from previous value
 //

#define GUARD_FRACTIONAL_POSITION(prevN,prevD,N,D)\
    {\
        if (D==0)\
        {\
            D=1;\
        }\
        if (N>D)\
        {\
            N=D;\
        }\
        if ((((double)(prevN))/((double)(prevD)))>(((double)(N))/((double)(D))))\
        {\
            D=prevD;\
            N=prevN;\
        }\
     }


NTSTATUS
SampGetDisplayEnumerationIndex(
      IN    DSNAME                    *DomainName,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING        Prefix,
      OUT   PULONG                     Index,
      OUT   PRESTART                   *RestartToReturn
      )
/*++

Routine Description:

    This helps implement QueryDisplayEnumerationIndex. Since it is a hopeless
    task in Jet to give an accurate offset of the object in the data table.
    This routine does the following

    1. Returns a number that signifies the offset of the object, depending upon type
       in the table
    2. Generates a Restart structure which allows QueryDisplayInformation to restart
       the search beginning from the object. The caller of this routine manipulates
       the state in the domain context, such that QueryDisplayInformation can restart
       the search, if the client came back with the value of the index that was returned.

Parameters:

    DomainName - Domain object's Name

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.

    RestartToReturn -- Returns a pointer to a restart structure which can be used
    to reposition the search by QueryDisplayInformation.


Return Values:

    STATUS_SUCCESS - normal, successful completion.
    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INTERNAL_ERROR
    STATUS_UNSUCCESSFUL

--*/
{

    ULONG SamAccountType;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PRESTART    pRestart;
    DWORD       dwError;

    *Index = 0;

    switch (DisplayInformation)
    {
    case DomainDisplayUser:
    case DomainDisplayOemUser:
        SamAccountType = SAM_NORMAL_USER_ACCOUNT;
        break;

    case DomainDisplayMachine:
        SamAccountType = SAM_MACHINE_ACCOUNT;
        break;

    case DomainDisplayGroup:
    case DomainDisplayOemGroup:
        SamAccountType = SAM_GROUP_OBJECT;
        break;

    default:
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // We should already be in a transaction by now
    //

    __try
    {
        if (SampExistsDsTransaction())
        {
            THSTATE     *pTHS = pTHStls;

            //
            // Position on the the domain object.
            //

            dwError=DBFindDSName(pTHS->pDB,DomainName);
            if (!dwError)
            {
                ULONG   NcDnt;
                INDEX_VALUE IV[3];
                BOOLEAN Match = FALSE;
                RESOBJ *pResObj;


                // Whilre we're still positioned on the search root, create
                // a RESOBJ for use in creating the restart
                pResObj = CreateResObj(pTHS->pDB,
                                       DomainName);

                //
                //  Get the NC value of the base object. For Display information,
                //  our base object is the domain object. Since the domain object
                //  is the head of a naming context, the DNT value itself is the NCDNT
                //  value
                //

                NcDnt = pTHS->pDB->DNT;

                //
                // Set the current Index such that we may search on the passed in prefix
                //
                dwError  = DBSetCurrentIndex(
                                pTHS->pDB,
                                Idx_NcAccTypeName,
                                NULL,
                                FALSE
                                );
                if (dwError)
                {
                    //
                    // We know we have this index
                    //

                    NtStatus = STATUS_INTERNAL_ERROR;
                    goto Error;
                }

                //
                //  Our index is in place . Now seek to a value greater than or equal to
                //  the value specified in the prefix
                //

                IV[0].pvData = &NcDnt;
                IV[0].cbData = sizeof(ULONG);
                IV[1].pvData = &SamAccountType;
                IV[1].cbData = sizeof(ULONG);
                IV[2].pvData = Prefix->Buffer;
                IV[2].cbData = Prefix->Length;

                //
                // Seek to the first object in the index that satisfies the prefix
                //

                dwError = DBSeek(
                            pTHS->pDB,
                            IV,
                            sizeof(IV)/sizeof(IV[0]),
                            DB_SeekGE
                            );

#if DBG
                if (0 == dwError)
                {
                    DWORD cbKey = 0;
                    //
                    // Just for grins, verify that this key wasn't too long
                    //
                    
                    DBGetKeyFromObjTable(pTHS->pDB, NULL, &cbKey);
                    Assert(cbKey <= DB_CB_MAX_KEY);
                }
#endif

                //
                // Now check the NC-Name and Account Type, both should
                // match our criteria.
                //

                if (0==dwError)
                {
                    //
                    // O.K. we have positioned ourselves on some record.
                    // Try to see if it satisfies the NC NAME
                    // 
                    if (NcDnt == pTHS->pDB->NCDNT)
                    {
                        ULONG  CurrentSamAccountType;

                        //
                        // if it satisfies the SAM_ACCOUNT_TYPE.
                        //
                        dwError = DBGetSingleValue(
                                    pTHS->pDB,
                                    ATT_SAM_ACCOUNT_TYPE,
                                    (PUCHAR) &CurrentSamAccountType,
                                    sizeof(ULONG),
                                    NULL
                                    );

                        if ((0==dwError) && (SamAccountType==CurrentSamAccountType))
                        {
                            //
                            // The object matches the SAM account type criteria
                            //
                            Match = TRUE;
                        }
                        else
                        {
                            //
                            // The object does not match the criteria (AccountType) 
                            //
                            Match = FALSE;
                        }
                    }
                    else
                    {
                        //
                        // The Object does not match the NC Name criteria
                        // 
                        Match = FALSE;
                    }
                }


                if ((Match) && (0==dwError))
                {
                    //
                    // Because DBCreateRestartForSAM() will position on the next entry.
                    // We need to manually move to the previous object at here, then
                    // create restart structure.  
                    //
                    dwError = DBMove(pTHS->pDB, FALSE, DB_MovePrevious); 
                    
                    if (dwError)
                    {
                        // 
                        // move out of bound
                        // 
                        *Index=0;
                        *RestartToReturn = 0;
                        NtStatus = STATUS_SUCCESS;
                        goto Error;
                    }

                    // set the Index to the current object DNT
                    // the current object is the last un-matched object
                    // Set the index to the one used by SampDsQueryDisplayInformation.
                    *Index = pTHS->pDB->DNT;


                    //
                    // Now we are on the last un-matched object, the very next object
                    // should match all criteria.
                    // Create a restart structure that can be used by SampDsQueryDisplayInformation
                    //

                    //
                    // Maintain Currency.
                    //

                    dwError  = DBSetCurrentIndex(
                                    pTHS->pDB,
                                    Idx_NcAccTypeName,
                                    NULL,
                                    TRUE
                                    );
                    if (dwError)
                    {
                        //
                        // We do know that we have this index
                        //
                        Assert(FALSE);
                        NtStatus = STATUS_INTERNAL_ERROR;
                        goto Error;
                    }



                    if(DBCreateRestartForSAM(pTHS->pDB,
                                             &pRestart,
                                             Idx_NcAccTypeName,
                                             pResObj,
                                             SamAccountType)) {
                       //
                       // Status internal error,as if we got this far, we must
                       // have the object asked by the Seek
                       //

                       Assert(FALSE);
                       NtStatus = STATUS_INTERNAL_ERROR;
                       goto Error;
                    }

                    // We only needed this for the restart.
                    THFreeEx(pTHS, pResObj);

                    //
                    // O.K. we have the restart structure now.
                    // 
                    *RestartToReturn = pRestart;

                }
                else if ((DB_ERR_RECORD_NOT_FOUND==dwError) || ((0==dwError) && (!Match)))
                {
                    //
                    // We counld not find a record, try to position the Index
                    // as the last unmatched DNT
                    // 
                    dwError = DBMove(pTHS->pDB, FALSE, DB_MovePrevious); 

                    if (0 == dwError)
                    {
                        *Index = pTHS->pDB->DNT;
                    }
                    else
                    {
                        *Index = 0;
                    }

                    *RestartToReturn = NULL;
                    NtStatus = STATUS_NO_MORE_ENTRIES;
                    goto Error;
                }
                else
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                }
            }
            else
            {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
        }
     }
  __except (HandleMostExceptions(GetExceptionCode()))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }


Error:

    return NtStatus;

}



NTSTATUS
SampSetIndexRanges(
    ULONG   IndexTypeToUse,
    ULONG   LowLimitLength1,
    PVOID   LowLimit1,
    ULONG   LowLimitLength2,
    PVOID   LowLimit2,
    ULONG   HighLimitLength1,
    PVOID   HighLimit1,
    ULONG   HighLimitLength2,
    PVOID   HighLimit2,
    BOOL    RootOfSearchIsNcHead
    )
/*++

  Routine Description

        This routine sets hints in pthsls for DBlayer to use, in order to speed up
        enumeration and display operations.

  Parameters

        IndexTypeToUse -- Specifies the index
        LowlimitLength -- The length of the low limit parameter
        LowLimit       -- The low limit paramter
        HighlimitLength-- The length of the high limit parameter
        HighLimit      -- The high limit parameter
        RootOfSearchIsNcHead -- Indicates that the root of search is an NC head. This
                          speeds up the whole subtree search, as we need not walk ancestors
--*/
{
    THSTATE     *pTHS=pTHStls;
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if (NULL!=pTHS)
    {

        __try
        {
            SAMP_SEARCH_INFORMATION *pSamSearchInformation = NULL;

            pSamSearchInformation =
                THAllocEx(pTHS, sizeof(SAMP_SEARCH_INFORMATION));

            if (NULL!=pSamSearchInformation)
            {

                if ARGUMENT_PRESENT(HighLimit1)
                {
                    pSamSearchInformation->HighLimitLength1 = HighLimitLength1;
                    pSamSearchInformation->HighLimit1
                            = THAllocEx(pTHS, HighLimitLength1);
                    RtlCopyMemory(
                        pSamSearchInformation->HighLimit1,
                        HighLimit1,
                        HighLimitLength1
                        );
                }

                if ARGUMENT_PRESENT(HighLimit2)
                {
                    pSamSearchInformation->HighLimitLength2 = HighLimitLength2;
                    pSamSearchInformation->HighLimit2
                            = THAllocEx(pTHS, HighLimitLength2);
                    RtlCopyMemory(
                        pSamSearchInformation->HighLimit2,
                        HighLimit2,
                        HighLimitLength2
                        );
                }

                if (ARGUMENT_PRESENT(LowLimit1))
                {
                    pSamSearchInformation->LowLimitLength1 = LowLimitLength1;
                    pSamSearchInformation->LowLimit1
                            = THAllocEx(pTHS, LowLimitLength1);
                    RtlCopyMemory(
                        pSamSearchInformation->LowLimit1,
                        LowLimit1,
                        LowLimitLength1
                        );
                }

                if (ARGUMENT_PRESENT(LowLimit2))
                {
                    pSamSearchInformation->LowLimitLength2 = LowLimitLength2;
                    pSamSearchInformation->LowLimit2
                            = THAllocEx(pTHS, LowLimitLength2);
                    RtlCopyMemory(
                        pSamSearchInformation->LowLimit2,
                        LowLimit2,
                        LowLimitLength2
                        );
                }


                pSamSearchInformation->IndexType = IndexTypeToUse;
                pSamSearchInformation->bRootOfSearchIsNcHead = (RootOfSearchIsNcHead != 0);

                //
                // In place Swap the Sid
                //

                if (SAM_SEARCH_SID==IndexTypeToUse)
                {
                    // The first argument is the SID
                    InPlaceSwapSid(pSamSearchInformation->HighLimit1);
                    InPlaceSwapSid(pSamSearchInformation->LowLimit1);
                }
                else
                {
                    if ((SAM_SEARCH_NC_ACCTYPE_SID == IndexTypeToUse) ||
                        (SAM_SEARCH_NC_ACCTYPE_NAME == IndexTypeToUse) )
                    {
                        // The second argument is the SID if presented.
                        if (NULL!=pSamSearchInformation->HighLimit2)
                        {
                             InPlaceSwapSid(pSamSearchInformation->HighLimit2);
                        }

                        if (NULL!=pSamSearchInformation->LowLimit2)
                        {
                             InPlaceSwapSid(pSamSearchInformation->LowLimit2);
                        }
                    }
                }


            }

            pTHS->pSamSearchInformation = (PVOID) pSamSearchInformation;
        }
        __except (HandleMostExceptions(GetExceptionCode()))
        {
            //
            // Only way we will reach here is memory alloc failure
            //
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return NtStatus;
}

NTSTATUS
SampGetAccountCounts(
	DSNAME * DomainObjectName,
    BOOLEAN  GetApproximateCount, 
	int    * UserCount,
	int    * GroupCount,
	int    * AliasCount
	)
/*++

    Routine Description:

        This Routine Uses Jet Fractional Position to Retrieve SAM account count
        counts.

    Parameters:

        DomainObjectName -- DSNAME of the domain object
        GetApproximateCount -- Indicate we don't need the exact value, so don't
                               make the expensive DBGetIndexSize()
        UserCount        -- The Count of Users in returned in Here
        GroupCount       -- The Count of Groups is returned in Here
        AliasCount       -- The Count of Aliases is returned in Here.

    Return Values

        STATUS_SUCCESS
        STATUS_INTERNAL_ERROR
--*/
{
	NTSTATUS	NtStatus = STATUS_SUCCESS;
    ULONG       dwError=0;
	ULONG       SamAccountType;
    ULONG       GroupNum=0,
                GroupDen=1,
                AliasNum=0,
                AliasDen=1,
                UserNum = 0,
                UserDen =1;
    ULONG       NcDnt;
    INDEX_VALUE IV[2];
    THSTATE     *pTHS;
    ULONG       IndexSize;




    Assert(SampExistsDsTransaction());

    pTHS = pTHStls;

    //
    // Initialize Return Values
    //

    *UserCount= 0;
    *GroupCount= 0;
    *AliasCount=0;

    __try
    {
	    //
	    // Obtain the NC of the Domain Object
	    //

        dwError=DBFindDSName(pTHS->pDB,DomainObjectName);
        if (0!=dwError)
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            goto Error;
        }


        //
        // DB find DS Name gets the DNT and PDNT in pDB
        //

	    //
        //  Get the NC value of the domain object. Since the domain object
        //  is the head of a naming context, the DNT value itself is the NCDNT
        //  value
        //

        NcDnt = pTHS->pDB->DNT;


        //
        // Set the current Index such that we may search on the passed in prefix
        //
        dwError  = DBSetCurrentIndex(
                        pTHS->pDB,
                        Idx_NcAccTypeSid,
                        NULL,
                        FALSE
                        );
        if (dwError)
        {
            //
            // We know we have this index
            //

            NtStatus = STATUS_INTERNAL_ERROR;
            goto Error;
        }

        if (!GetApproximateCount)
        {
            //
            //  Our index is in place . Get the more accurate index size
            //

            DBGetIndexSize(pTHS->pDB,&IndexSize);
        }


        //
        // First Target the group Count
        //

	    SamAccountType = SAM_GROUP_OBJECT;
        IV[0].pvData = &NcDnt;
        IV[0].cbData = sizeof(ULONG);
        IV[1].pvData = &SamAccountType;
        IV[1].cbData = sizeof(ULONG);


        //
        // Seek to the first object in the index that has a sam account type
	    // value greater than a group
        //


        dwError = DBSeek(
                    pTHS->pDB,
                    IV,
                    sizeof(IV)/sizeof(IV[0]),
                    DB_SeekGT
                    );

	    if (0==dwError)
	    {
		    //
		    // Seek was successful, get fractional position at this point
		    //

		    DBGetFractionalPosition(pTHS->pDB,&GroupNum,&GroupDen);
            GUARD_FRACTIONAL_POSITION(0,1,GroupNum,GroupDen);

            //
            // Now Seek to the End of the Alias Range
            //

            SamAccountType = SAM_ALIAS_OBJECT;
            IV[0].pvData = &NcDnt;
            IV[0].cbData = sizeof(ULONG);
            IV[1].pvData = &SamAccountType;
            IV[1].cbData = sizeof(ULONG);

            dwError = DBSeek(
                        pTHS->pDB,
                        IV,
                        sizeof(IV)/sizeof(IV[0]),
                        DB_SeekGT
                        );
		    if (0==dwError)
            {
                //
                // Seek was successful, get fractional position at this point
                //

                DBGetFractionalPosition(pTHS->pDB,&AliasNum,&AliasDen);
                GUARD_FRACTIONAL_POSITION(GroupNum,GroupDen,AliasNum,AliasDen);

                //
                // Seek for the end of the user range
                //

                SamAccountType = SAM_ACCOUNT_TYPE_MAX;
                IV[0].pvData = &NcDnt;
                IV[0].cbData = sizeof(ULONG);
                IV[1].pvData = &SamAccountType;
                IV[1].cbData = sizeof(ULONG);

                dwError = DBSeek(
                            pTHS->pDB,
                            IV,
                            sizeof(IV)/sizeof(IV[0]),
                            DB_SeekGT
                            );
                if (0!=dwError)
                {
                    //
                    // Could not go past, end of SAM account type range. This is normal
                    // and expected in a DC hosting only a single domain
                    //

                    UserNum = 1;
                    UserDen = 1;
                }
                else
                {
                    DBGetFractionalPosition(pTHS->pDB,&UserNum,&UserDen);
                    GUARD_FRACTIONAL_POSITION(AliasNum,AliasDen,UserNum,UserDen);

                }

            }
            else
            {
                //
                // Well could not go past alias range. Means that there are no users at
                // this point
                //

                AliasNum=1;
                AliasDen=1;
            }
        }
        else
        {
            //
            // Well , could not go past group range. Means that there are no aliases and users at
            // this point
            //

            GroupNum=1;
            GroupDen=1;
        }

        if (GetApproximateCount)
        {
            //
            // use the avarage of three denominators as the IndexSize
            // 
            IndexSize = (GroupDen + AliasDen + UserDen) / 3;
        }

        //
        // Now based on the fractional positons and index sizes calculate the counts
        //

        *GroupCount = (int)((double) GroupNum/ (double)GroupDen * IndexSize);
        *AliasCount = (int)((double) AliasNum/ (double)AliasDen * IndexSize) - *GroupCount;
        *UserCount =  (int)((double) UserNum/ (double)UserDen * IndexSize) - *GroupCount - *AliasCount;

    }
     __except (HandleMostExceptions(GetExceptionCode()))
    {
        //
        // Only way we will reach here is memory alloc failure
        //
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
Error:

    return (NtStatus);

}




NTSTATUS
SampGetQDIRestart(
    IN PDSNAME  DomainName,
    IN DOMAIN_DISPLAY_INFORMATION DisplayInformation, 
    IN ULONG    LastObjectDNT,
    OUT PRESTART *ppRestart
    )
/*++
Routine Description:

    This routine creates a fake restart structure for 
    SampDsQueryDisplayInformation() according the the LastObjectDNT.
    
Parameters:

    DomainName -- DSName of the Domain
    
    DisplayInforamtion -- Information Lever

    LastObjectDNT -- DNT of the last object returned

    ppRestart -- point to the restart structure.

Return Values:

    Ntstatus
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PRESTART    pRestart = NULL;
    ULONG       SamAccountType;
    DWORD       dwError;

    switch (DisplayInformation)
    {
    case DomainDisplayUser:
    case DomainDisplayOemUser:
        SamAccountType = SAM_NORMAL_USER_ACCOUNT;
        break;

    case DomainDisplayMachine:
        SamAccountType = SAM_MACHINE_ACCOUNT;
        break;

    case DomainDisplayGroup:
    case DomainDisplayOemGroup:
        SamAccountType = SAM_GROUP_OBJECT;
        break;

    default:
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // We should already be in a transaction by now
    //

    __try
    {
        if (SampExistsDsTransaction())
        {
            THSTATE     *pTHS = pTHStls;
            RESOBJ      *pResObj;
            ULONG       CurrentSamAccountType;

            dwError = DBFindDSName(pTHS->pDB, DomainName);

            if (dwError)
            {
                // Failed to find the domain object
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;

            }

            //
            // for creating the restart structure
            // 

            pResObj = CreateResObj(pTHS->pDB,
                                   DomainName);

            //
            // locate the last returned object
            // 

            dwError = DBFindDNT(pTHS->pDB, LastObjectDNT);

            if (dwError)
            {
                DPRINT2(0,"Failed at DBFindDNT DNT: %d Error: %d\n", LastObjectDNT, dwError);
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Now, we are on the last returned object
            // Try to retrieve the SAM Account Type.
            // If this object doesn't have SAM account type (means it 
            // was deleted) We will try to get the account name, 
            // use the account name as Prefix to create a restart
            //  
            // otherwise if this object has account type.
            // then we will set the index, create the restart without
            // searching the prefix
            // 

            dwError = DBGetSingleValue(pTHS->pDB,
                                       ATT_SAM_ACCOUNT_TYPE,
                                       (PVOID) &CurrentSamAccountType,
                                       sizeof(ULONG),
                                       NULL
                                       );

            if (DB_ERR_NO_VALUE == dwError)
            {
                //
                // Don't have this value
                // 
                PUCHAR  CurrentAccountName = NULL;
                ULONG   CurrentAccountNameLen = 0;
                PWSTR   AccountNameBuffer = NULL; 
                ULONG   Index;
                RPC_UNICODE_STRING  Prefix;


                //
                // Get Account Name
                // 

                dwError = DBGetAttVal(pTHS->pDB,
                                      1,
                                      ATT_SAM_ACCOUNT_NAME,
                                      0,
                                      0,
                                      &CurrentAccountNameLen,
                                      &CurrentAccountName
                                      );

                if (dwError)
                {
                    //
                    // Failed to get the Account name, not much we can do 
                    // 
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }

                //
                // O.K. Now have the account name, create Prefix
                // 

                AccountNameBuffer = THAllocEx(pTHS, CurrentAccountNameLen + sizeof(WCHAR));

                if (NULL == AccountNameBuffer)
                {
                    NtStatus = STATUS_NO_MEMORY;
                    goto Error;
                }
                else
                {
                    memset(&Prefix, 0, sizeof(RPC_UNICODE_STRING));
                    memset(AccountNameBuffer, 0, CurrentAccountNameLen);
                    memcpy(AccountNameBuffer, CurrentAccountName, CurrentAccountNameLen);
                    RtlInitUnicodeString((PUNICODE_STRING)&Prefix,
                                         AccountNameBuffer);
                }

                NtStatus = SampGetDisplayEnumerationIndex(DomainName,
                                                          DisplayInformation,
                                                          &Prefix,
                                                          &Index,
                                                          ppRestart
                                                          );
            }
            else if (0 == dwError)
            {
                // 
                // Now, we know that the current object has correct Account 
                // Type. set index to NcAccTypeName and maintain currency
                // 

                dwError = DBSetCurrentIndex(pTHS->pDB, 
                                            Idx_NcAccTypeName,
                                            NULL,
                                            TRUE
                                            );

                if (dwError)
                {
                    // we do know that we have this index
                    Assert(FALSE && "Failed in DBSetCurrentIndex to NcAccTypeName")
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
                    
                //
                // create restart 
                // 
                if (DBCreateRestartForSAM(pTHS->pDB,
                                          &pRestart,
                                          Idx_NcAccTypeName,
                                          pResObj,
                                          SamAccountType
                                          ))
                {
                    DPRINT(0, "Failed at DBCreateRestartForSAM\n");
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }

                //
                // set the return value
                // 
                *ppRestart = pRestart;
                THFreeEx(pTHS, pResObj);
            }
            else
            {
                // failure to get account type for some other reason
                NtStatus = STATUS_UNSUCCESSFUL;
            }

        }//transaction

    }//__try
    __except (HandleMostExceptions(GetExceptionCode()))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }

Error:

    return( NtStatus );
}

NTSTATUS
SampNetlogonPing(
    IN  ULONG           DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT PBOOLEAN        AccountExists,
    OUT PULONG          UserAccountControl
    )
/*++
Routine Description:

    This routine will based on a Domain Handle and on the account name will
    tell if the account exists and return the user account control.
    
Parameters:

    DomainHandle - The domain where the account name can be found
    
    AccountName - The account name for which to find the useraccountcontrol
    
    AccountExists - This will tell the call if the account exists or not
    
    UserAccountControl - This will have the return of the useraccountcontrol

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
    
--*/
{
    THSTATE         *pTHS = pTHStls;
    BOOL            fCommit = TRUE;
    BOOL            Found = TRUE;
    ULONG           isdel = 0;
    DWORD           samAccountType = 0;
    INDEX_VALUE     IV[1] = {0,0};
    ULONG           dbErr = 0;
    NTSTATUS        status = STATUS_SUCCESS;
    ATTCACHE*       ac = NULL;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;
    
    __try {

        DBOpen2(TRUE, &pTHS->pDB);

        __try {
        
            ac = SCGetAttById(pTHS, ATT_SAM_ACCOUNT_NAME);
            if (ac==NULL) {
                status = STATUS_UNSUCCESSFUL;
                __leave;
            }
           
            dbErr = DBSetCurrentIndex(pTHS->pDB,
                                      (eIndexId)0,
                                      ac,
                                      FALSE
                                      );
            if (0 != dbErr) {
                status = STATUS_UNSUCCESSFUL;
                _leave;
            }
            
            IV[0].pvData = AccountName->Buffer;
            IV[0].cbData = AccountName->Length;
    
            dbErr = DBSeek(pTHS->pDB,
                           IV,
                           sizeof(IV)/sizeof(IV[0]),
                           DB_SeekEQ
                           );
            if (0 != dbErr) {
                Found = FALSE;
                _leave;
            }
    
            //It is possible to find a delete but is not a value result for
            //this search.
            dbErr = DBGetSingleValue(pTHS->pDB,
                                     ATT_IS_DELETED,
                                     &isdel,
                                     sizeof(isdel),
                                     NULL);
            if (dbErr) {
                if (DB_ERR_NO_VALUE == dbErr) {
                    // Treat having no value the same as being false.
                    isdel = 0;
                    dbErr = 0;
                } else {
    
                    status = STATUS_UNSUCCESSFUL;
                    _leave;
                }
    
            }
    
            if ( (DomainHandle != pTHS->pDB->NCDNT) || isdel ) {
                dbErr = DBSetIndexRange(pTHS->pDB,
                                        IV,
                                        sizeof(IV)/sizeof(IV[0])
                                        );
                if (0 != dbErr) {
                    status = STATUS_UNSUCCESSFUL;
                    _leave;
                }
            }
    
            while ( (DomainHandle != pTHS->pDB->NCDNT) || isdel ) {
    
                dbErr = DBMove (pTHS->pDB,
                                FALSE,
                                DB_MoveNext
                                );
                if (0 != dbErr) {
                    Found = FALSE;
                    _leave;
                }
    
                //It is possible to find a delete but is not a value result for
                //this search.
                dbErr = DBGetSingleValue(pTHS->pDB,
                                         ATT_IS_DELETED,
                                         &isdel,
                                         sizeof(isdel),
                                         NULL);
                if (dbErr) {
                    if (DB_ERR_NO_VALUE == dbErr) {
                        // Treat having no value the same as being false.
                        isdel = 0;
                        dbErr = 0;
                    } else {
                
                        status = STATUS_UNSUCCESSFUL;
                        _leave;
                
                    }
                }
    
            }
    
            dbErr = DBGetSingleValue(pTHS->pDB,
                                     ATT_SAM_ACCOUNT_TYPE,
                                     &samAccountType,
                                     sizeof(samAccountType),
                                     NULL);
            if (dbErr) {
                
                status = STATUS_UNSUCCESSFUL;
                _leave;
    
            }
    
            if (!( (SAM_NORMAL_USER_ACCOUNT == samAccountType) || 
                   (SAM_MACHINE_ACCOUNT     == samAccountType) ||
                   (SAM_TRUST_ACCOUNT       == samAccountType) ) )
            {
                Found = FALSE;
                _leave;    
            }
    
            dbErr = DBGetSingleValue(pTHS->pDB,
                                     ATT_USER_ACCOUNT_CONTROL,
                                     (PVOID)UserAccountControl,
                                     sizeof(ULONG),
                                     NULL);
            if (0 != dbErr) {
                status = STATUS_UNSUCCESSFUL;
                _leave;
            }
            
        }
        __finally {
            if (0 == dbErr && Found == TRUE) {
                *AccountExists = TRUE;
            } else {
                *AccountExists = FALSE;
            }
            DBClose(pTHS->pDB,fCommit);
        }

    } 
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwExceptionAddress,
                              &ulErrorCode,
                              &dsid)) {

        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;

    }

    if ( DB_ERR_EXCEPTION == dbErr) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\samwrite.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samwrite.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains all SAMP_SAM_WRITE_FUNCTION_PTR implementations
    as defined in mappings.h.  These routines write all mapped properties
    which are tagged as SamWriteRequired.

    Call arguments include the entire SAMP_CALL_MAPPING even though each
    routine writes only a single attribute (at present).  In the future
    we can optimize the write calls by scanning ahead and writing multiple
    SamWriteRequired attributes in a single Samr* call.  But for now,
    we take the simplistic approach and write attributes individually.

    Each routine has the same arguments so we document them once here.

    Routine Description:

        Writes the attribute and object type named by the routine.
        Each routine name has the form SampWrite<type><attribute> as
        in SampWriterUserSecurityDescriptor.  Where possible, the
        <attribute> component matches the field name in the
        corresponding information struct.

    Arguments:

        hObj - open SAMPR_HANDLE for the object to write.

        iAttr - index into rCallMap representing the attribute to write.

        pObject - pointer to DSNAME of object being written.  Only used
            for error reporting.

        cCallMap - number of elements in rCallMap.

        rCallMap - address of SAMP_CALL_MAPPING array representing all
            attributes being modified by the high level Dir* call.

    Return Value:

        0 on success, !0 otherwise.  Sets pTHStls->errCode on error.

Author:

    DaveStr     01-Aug-96

Environment:

    User Mode - Win32

Revision History:

    As we move all loopback functions to SAMSRV.DLL (sam\server\dsmodify.c)
    most of below routines are not going to used any longer. 
    
    Once the SAM Lockless loopback mechanism runs stable. 
    We should remove those no longer used APIs

--*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>

// SAM interoperability headers
#include <mappings.h>
#include <samwrite.h>

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected atts
#include "debug.h"              // standard debugging header
#define DEBSUB "SAMWRITE:"      // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_SAMWRITE

// SAM headers
#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <samisrv.h>
#include <samsrvp.h>
#include <ridmgr.h>

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Local helpers                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
SampInitRpcUnicodeStringFromAttrVal(
    RPC_UNICODE_STRING  *pUnicodeString,
    ATTRVAL             *pAttrVal)

/*++

Routine Description:

    Initializes a RPC_UNICODE_STRING from an ATTRVAL.

Arguments:

    pUnicodeString - pointer to RPC_UNICODE_STRING to initialize.

    pAttrVal - pointer to ATTRVAL providing initialization value.

Return Value:

    None.

--*/

{
    if ( 0 == pAttrVal->valLen )
    {
        pUnicodeString->Length = 0;
        pUnicodeString->MaximumLength = 0;
        pUnicodeString->Buffer = NULL;
    }
    else
    {
        pUnicodeString->Length = (USHORT) pAttrVal->valLen;
        pUnicodeString->MaximumLength = (USHORT) pAttrVal->valLen;
        pUnicodeString->Buffer = (PWSTR) pAttrVal->pVal;
    }
}

#if defined LOOPBACK_SECURITY

ULONG
SampWriteSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )

/*++

Routine Description:

    Generic security descriptor writing routine for all classes of SAM
    objects.

Arguments:

    hObj - SAMPR_HANDLE of open SAM object.

    iAttr - Index into SAMP_CALL_MAPPING holding new security descriptor.

    pObject - pointer to DSNAME of object being modified.

    cCallMap - number of elements in SAMP_CALL_MAPPING.

    rCallMap - address of SAMP_CALL_MAPPING array representing all
        attributes being modified by the high level Dir* call.

Return Value:

    0 on success, !0 otherwise.

--*/
{
    NTSTATUS                        status;
    SAMPR_SR_SECURITY_DESCRIPTOR    sd;
    ATTR                            *pAttr = &rCallMap[iAttr].attr;

    // This attribute is a single-valued byte array and must exist, thus
    // only AT_CHOICE_REPLACE_ATT is allowed.

    if ( (AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice) ||
         (1 != pAttr->AttrVal.valCount) ||
         (0 == pAttr->AttrVal.pAVal[0].valLen) )
    {
        SetAttError(
                pObject,
                pAttr->attrTyp,
                PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                NULL,
                DIRERR_SINGLE_VALUE_CONSTRAINT);

        return(pTHStls->errCode);
    }

    sd.Length = pAttr->AttrVal.pAVal[0].valLen;
    sd.SecurityDescriptor = (PUCHAR) pAttr->AttrVal.pAVal[0].pVal;

    status = SamrSetSecurityObject(
                            hObj,
                            ( OWNER_SECURITY_INFORMATION |
                              GROUP_SECURITY_INFORMATION |
                              DACL_SECURITY_INFORMATION |
                              SACL_SECURITY_INFORMATION ),
                            &sd);

    if ( !NT_SUCCESS(status) )
    {
        if ( 0 == pTHStls->errCode )
        {
            SampMapSamLoopbackError(status);

           
        }

        return(pTHStls->errCode);
    }

    return(0);
}

#endif // LOOPBACK_SECURITY

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Default write function which sets an error.                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
SampWriteNotAllowed(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    // We should not get here in the typical case because
    // SampAddLoopbackRequired and SampModifyLoopbackRequired should
    // have returned an error back when we first detectd that the client
    // was trying to write a mapped attribute whose writeRule is SamReadOnly.
    // This function exists mostly to avoid dereferencing a NULL function
    // pointer in the mapping table.  The exception is the case of password
    // modification where SampModifyLoopbackRequired lets ATT_UNICODE_PWD
    // writes through so that we can detect the special change password
    // condition in SampWriteSamAttributes.  However, if the condition is
    // not met, we'll end up here at which time we should return an error.

    SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
    return(pTHStls->errCode);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Server object attribute write routines                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteServerSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Domain object attribute write routines                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteDomainSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Group object attribute write routines                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteGroupSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY



//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Alias object attribute write routines                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteAliasSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// User object attribute write routines                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteUserSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY





BOOLEAN
SampIsSecureLdapConnection(
    VOID
    )
/*++

Routine Description:

    Verify that this is a secure enough connection - one of the 
    requirements for accepting passwords sent over the wire.

Parameter:

    None:
    
Return Value:

    TRUE  - yes, it is a secure connection

    FALSE - no

--*/

{
    return( pTHStls->CipherStrength >= 128 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\samlogon.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samlogon.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains the routines for implementing SampGetMemberships
    which performs recursive membership retrieval.  This is called by
    SAM when a security principal logs on. It also has routines for transitively
    expanding the membership list of a security prinicpal, same domain/cross  domain

Author:

    DaveStr     07-19-96

Environment:

    User Mode - Win32

Revision History:

    DaveStr     07-19-96
        Created

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

extern "C" {

#include <ntdsa.h>
#include <filtypes.h>
#include <mappings.h>
#include <objids.h>
#include <direrr.h>
#include <mdcodes.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <debug.h>
#include <drsuapi.h>
#include <drserr.h>
#include <anchor.h>
#include <samsrvp.h>

#include <fileno.h>
#define  FILENO FILENO_SAMLOGON

#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <gcverify.h>
#include <samisrv.h>
#include <ntdsctr.h>
#include <dsconfig.h>
#include <samlogon.h>


#define DEBSUB "SAMLOGON:"


} // extern "C"


#define MAX_TOKEN_GROUPS_COUNT  (2 * LSAI_CONTEXT_SID_LIMIT)

// Declare some local helper classes to manage sets of SIDs.  Implementing
// them as C++ classes makes them easier to replace in the future with
// better performing implementations.  Care is taken to allocate everything
// via thread heap instead of using the global 'new' operator in order to
// be consistent with the rest of the core DS code.  Likewise, all
// destructors are no-ops.

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CDSNameSet - Manages a set of Values.                                //
// In the original version this class managed a set of DSNames.         //
// During the course of development its utility was appreciated and     //
// this class was extended to manage value types of DSNAME DNT and SID  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


typedef enum _REVMEMB_VALUE_TYPE {
    RevMembDsName =1,
    RevMembDNT,
    RevMembSid
} REVMEMB_VALUE_TYPE;

class CDSNameSet {

private:

    ULONG   _cNames;               // count of Values in set ( DSNAMES, dnts, or SIDS)
    ULONG   _cMax;                 // count of allocated elements
    REVMEMB_VALUE_TYPE _valueType; // Indicates that the kind of values we are managing
    PVOID *_rpNames;               // array of  pointers, to either DSNAMES , dnts or SIDs

public:

    // Constructor.

    CDSNameSet();

    // Destructor.

    ~CDSNameSet() { NULL; }

    // Tell to manage internal or external names
    VOID SetValueType(REVMEMB_VALUE_TYPE ValueType) {_valueType = ValueType;}

    // Return the count of DSNAMEs currently in the set.

    ULONG Count() { return(_cNames); }

    // Retrieve a pointer to the Nth DSNAME in the set.

    PVOID Get(ULONG idx) { Assert(idx < _cNames); return(_rpNames[idx]); }

#define DSNAME_NOT_FOUND 0xFFFFFFFF

    // Determine whether a DSNAME is in the set and if so, its index.

    ULONG Find(PVOID pDSName);

    // Add a DSNAME to the set.

    VOID Add(PVOID pDSName);

    // Remove the DSNAME at a given index from the set.

    VOID Remove(ULONG idx);

    // Add if the DSNAME is not already present

    VOID CheckDuplicateAndAdd(PVOID pDSName);

    //  Returns the pointer to the array of DSName pointers
    //  that represents the set of DS Names
    PVOID * GetArray() { return _rpNames; }

    // Cleans up the DSNameSet, by free-ing the array and resetting
    // the _cNames and _cMax fields
    VOID Cleanup();
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CReverseMembership - Manages the DSNAMEs in a reverse membership.    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

class CReverseMembership {

private:

    CDSNameSet  _recursed;
    CDSNameSet  _unRecursed;

public:

    // Constructor.

    CReverseMembership(){
                          _recursed.SetValueType(RevMembDNT);
                          _unRecursed.SetValueType(RevMembDNT);
                        }

    // Destructor.

    ~CReverseMembership() { _recursed.Cleanup(); _unRecursed.Cleanup(); }

    // Add a DSNAME to the set.

    VOID Add(PVOID pDSName);

    // Retrieve the next DSNAME which has not yet been recursively processed.

    PVOID NextUnrecursed();

    // Retrieve the count of DSNAMEs in the reverse membership set.

    ULONG Count();

    // Retrieve the DSNAME at a given index from the set - does not remove it.

    PVOID Get(ULONG idx);



};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CDSNameSet - Implementation                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// Define the factor by which we will grow the PDSNAME array in a CDSNameSet
// instance.  Make it small for debug builds so we test boundary conditions
// but big in a retail build for performance.

#if DBG == 1
#define PDSNAME_INCREMENT 1
#else
#define PDSNAME_INCREMENT 100
#endif

int _cdecl ComparePVOIDDNT(
        const void *pv1,
        const void *pv2
    )

/*++

Routine Description:

    Compares two DNTs that are stored in PVOID pointers

Arguments:

    pv1 - Pointer provided by qsort or bsearch which is the value
        of a DNT array element.

    pv2 - Pointer provided by qsort or bsearch which is the value
        of a DNT array element.

Return Value:

    Integer representing how much less than, equal or greater the
        first name is with respect to the second.

--*/

{
    PVOID p1 = * ((PVOID * ) pv1);
    PVOID p2 = * ((PVOID *)  pv2);
    ULONG u1 = PtrToUlong(p1);
    ULONG u2 = PtrToUlong(p2);
    ULONG   Result;

    if (u1==u2)
        return 0;

    if (u1>u2)
        return 1;

    return -1;
}

int _cdecl ComparePSID(
        const void *pv1,
        const void *pv2
    )

/*++

Routine Description:

    Compares two SIDs.

Arguments:

    pv1 - Pointer provided by qsort or bsearch which is the address
        of a PSID array element.

    pv2 - Pointer provided by qsort or bsearch which is the address
        of a PSID array element.

Return Value:

    Integer representing how much less than, equal or greater the
        first name is with respect to the second.

--*/

{
    PSID p1 = * ((PSID *) pv1);
    PSID p2 = * ((PSID *) pv2);
    ULONG   Result;



    if (RtlEqualSid(p1,p2))
    {
        return 0;
    }

    if (RtlLengthSid(p1)<RtlLengthSid(p2))
    {
        return -1;
    }
    else if (RtlLengthSid(p1) > RtlLengthSid(p2))
    {
        return 1;
    }
    else
    {
        Result = memcmp(p1,p2,RtlLengthSid(p1));
    }

    return Result;


}

int _cdecl ComparePDSNAME(
        const void *pv1,
        const void *pv2
    )

/*++

Routine Description:

    Compares two DSNAMEs.

Arguments:

    pv1 - Pointer provided by qsort or bsearch which is the address
        of a PDSNAME array element.

    pv2 - Pointer provided by qsort or bsearch which is the address
        of a PDSNAME array element.

Return Value:

    Integer representing how much less than, equal or greater the
        first name is with respect to the second.

--*/

{
    PDSNAME p1 = * ((PDSNAME *) pv1);
    PDSNAME p2 = * ((PDSNAME *) pv2);
    ULONG   Result;



    //
    // if both have guids then compare guids
    //

    if (!fNullUuid(&p1->Guid) && !fNullUuid(&p2->Guid))
    {
        return(memcmp(&p1->Guid, &p2->Guid, sizeof(GUID)));
    }

    //
    // At least one of the two Ds Names has a SID
    //

    //
    // Assert that a SID only name cannot be a security principal
    // in the builltin domain
    //

    Assert(!fNullUuid(&p1->Guid)||(p1->SidLen==sizeof(NT4SID)));
    Assert(!fNullUuid(&p2->Guid)||(p2->SidLen==sizeof(NT4SID)));

    //
    // Compare by SID
    //

    if (RtlEqualSid(&p1->Sid,&p2->Sid))
    {
        return 0;
    }

    if (p1->SidLen<p2->SidLen)
    {
        return -1;
    }
    else if (p1->SidLen > p2->SidLen)
    {
        return 1;
    }
    else
    {
        Result = memcmp(&p1->Sid,&p2->Sid,p1->SidLen);
    }

    return Result;


}

CDSNameSet::CDSNameSet()
{
    _cNames = 0;
    _cMax = 0;
    _rpNames = NULL;
}

ULONG
CDSNameSet::Find(
    PVOID pDSName
    )
{
    PVOID *ppDSName = &pDSName;
    PVOID *pFoundName;
    ULONG   idx;
    int (__cdecl *CompareFunction)(const void *, const void *) = NULL;

    switch(_valueType)
    {
    case    RevMembDsName:
                CompareFunction=ComparePDSNAME;
                break;
    case    RevMembDNT:
                CompareFunction=ComparePVOIDDNT;
                break;

    case    RevMembSid:
                CompareFunction=ComparePSID;
                break;
    default:
                Assert(FALSE&&"InvalidValueType");

    }

    pFoundName = (PVOID *) bsearch(
                    ppDSName,
                    _rpNames,
                    _cNames,
                    sizeof(PVOID),
                    CompareFunction);

    if ( NULL == pFoundName )
    {
        return(DSNAME_NOT_FOUND);
    }

    // Convert pFoundName into an array index.

    idx = (ULONG)(pFoundName - _rpNames);

    Assert(idx < _cNames);

    return(idx);
}

VOID
AddToSortedList(
    IN PVOID *rpNames,
    IN OUT ULONG  *pcNames,
    IN PVOID  pDSName,
    IN int (__cdecl *CompareFunction)(const void *, const void *)
    )
/*++

Routine Description:

    This routine adds pDSName into the rpNames array in sorted order.
    This routine assumes that rpNames has enough space to grow by at least
    one element.
    
    The algorithm used is a binary search to locate the position that the
    new element should be inserted into.

Arguments:

    rpNames -- an array of pointers with space to hold at least (*pcNames + 1)                
               elements
               
    pcNames -- a pointer to the count of elements in rpNames.
    
    pDSName -- a pointer to an element to place into rpNames
    
    CompareFunction -- a routine to determine the sort order of rpNames               

Return Value:

    None.  rpNames will be updated in place.

--*/
{
    BOOL fFound = FALSE;
    ULONG n = (*pcNames);
    ULONG index, start, end;
    LONG result;

    // initial case, the existing array contains no elements
    if ((*pcNames) == 0) {
        rpNames[0] = pDSName;
        (*pcNames) = 1;
        return;
    }

    // locate position in array for the new element
    // index is the position in the array that the new element will be added.
    // start and end determine what range of elements are being inspected.
    start = 0;
    end = n - 1;
    do {
        // goto the middle of the range
        index = (start + end) / 2;
        result = CompareFunction(&pDSName, &(rpNames[index]));
        if (result < 0) {
            if (index == start) {
                // the element goes before the first element of the 
                // left section -- we are done.
                fFound = TRUE;
            } else {
                // the element belongs in the left section, adjust the
                // end range to be just before the current position
                end = index-1;
            }
        } else if (result > 0 ) {
            if (index == end) {
                // the element goes after the last element of the right
                // section -- we are done
                fFound = TRUE;
                index = end + 1;
            } else{
                // the element belongs in the left section, adjust the
                // start range to be just after the current position.
                start = index+1;
            }
        } else {
            // we found an element that is equal to the new element
            // insert the element right here.
            fFound = TRUE;
        }
    } while ( !fFound );

#if DBG
    Assert(index <= n);
    if (index == n) {
        // the new element is at the end of the list, therefore value must be
        // greater than or equal to the last element
        Assert(CompareFunction(&pDSName, &(rpNames[n-1])) >= 0);
    } else if (index == 0) {
        // the new element is at the front of the list, therefore its value
        // must be less than or equal the first element
        Assert(CompareFunction(&pDSName, &(rpNames[0])) <= 0);
    } else {
        Assert(n > 1);
        // the new element must be less or equal to the element it is replacing
        Assert(CompareFunction(&pDSName, &(rpNames[index])) <= 0);
        // the new element must be greater than or equal to the previous element
        Assert(CompareFunction(&pDSName, &(rpNames[index-1])) >= 0);
    }
#endif

    // move the elements forward if necessary
    if (index < n) {
        memmove(&(rpNames[index+1]), &(rpNames[index]), (n-index) * sizeof(pDSName));
    }

    // add the new element
    rpNames[index] = pDSName;
    (*pcNames)++;

    return;
}

VOID
CDSNameSet::Add(
    PVOID pDSName
    )
{
    THSTATE *pTHS=pTHStls;
    PVOID *ppDSName = &pDSName;
    int (__cdecl *CompareFunction)(const void *, const void *) = NULL;

    // Caller should not add duplicates - verify.

#if DBG == 1

    if ( DSNAME_NOT_FOUND != Find(pDSName) )
    {
        Assert(FALSE && "Duplicate CDSNameSet::Add");
    }

#endif

    // See if we need to (re)allocate the array of DSNAME pointers.

    if ( _cNames == _cMax )
    {
        _cMax += PDSNAME_INCREMENT;

        if ( NULL == _rpNames )
        {
            _rpNames = (PVOID *) THAllocEx(pTHS,
                                        _cMax * sizeof(PVOID));
        }
        else
        {
            _rpNames = (PVOID *) THReAllocEx(pTHS,
                                        _rpNames,
                                        _cMax * sizeof(PVOID));
        }
    }

    // Now add the new element and maintain a sorted array.


    switch(_valueType)
    {
    case    RevMembDsName:
                CompareFunction=ComparePDSNAME;
                break;
    case    RevMembDNT:
                CompareFunction=ComparePVOIDDNT;
                break;

    case    RevMembSid:
                CompareFunction=ComparePSID;
                break;

    default:
                Assert(FALSE&&"InvalidValueType");
    }

    AddToSortedList(_rpNames,
                    &_cNames,
                     pDSName,
                     CompareFunction);

}


VOID
CDSNameSet::Remove(
    ULONG idx
    )
{
    Assert(idx < _cNames);

    for ( ULONG i = idx; i < (_cNames-1); i++ )
    {
        _rpNames[i] = _rpNames[i+1];
    }

    _cNames--;

    // Nothing to sort since shift-down didn't perturb sort order.
}


VOID
CDSNameSet::CheckDuplicateAndAdd(
    PVOID pDSName
    )
{
    if (DSNAME_NOT_FOUND==Find(pDSName))
    {
        Add(pDSName);
    }

    return;
}

VOID
CDSNameSet::Cleanup()
{
    if (NULL!=_rpNames)
        THFree(_rpNames);
    _rpNames = NULL;
    _cMax = NULL;
    _cNames = NULL;
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CReverseMembership - Implementation                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
CReverseMembership::Add(
    PVOID pDSName
    )
{
    // Nothing to do if we already have this DSNAME in either the recursed
    // or !recursed set.

    if ( (DSNAME_NOT_FOUND != _unRecursed.Find(pDSName)) ||
         (DSNAME_NOT_FOUND != _recursed.Find(pDSName)) )
    {
        return;
    }

    // Add to !recursed set of DSNAMEs.

    _unRecursed.Add(pDSName);
}

PVOID
CReverseMembership::NextUnrecursed(
    void
    )
{
    ULONG   cNames;
    ULONG   idx;
    PVOID pDSName;

    cNames = _unRecursed.Count();

    if ( 0 == cNames )
    {
        return(NULL);
    }

    idx = --cNames;

    pDSName = _unRecursed.Get(idx);

    // Transfer DSNAME from !recursed to recursed set.

    _unRecursed.Remove(idx);
    _recursed.Add(pDSName);

    return(pDSName);
}

ULONG
CReverseMembership::Count(
    void
    )
{
    return(_recursed.Count() + _unRecursed.Count());
}

PVOID
CReverseMembership::Get(
    ULONG idx
    )
{
    Assert(idx < Count());

    if ( idx >= _recursed.Count() )
    {
        return(_unRecursed.Get(idx - _recursed.Count()));
    }

    return(_recursed.Get(idx));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Helper functions                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


NTSTATUS
SampCheckGroupTypeAndDomainLocal (
        IN  THSTATE *pTHS,
        IN  ULONG    SidLen,
        IN  PSID     pSid,
        IN  DWORD    NCDNT,
        IN  DWORD    GroupType,
        IN  ATTRTYP  Class,
        IN  REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
        IN  ULONG    LimitingNCDNT,
        IN  PSID     LimitingDomainSid,
        OUT BOOLEAN *pfMatch
        )
/*++

  Given a DNT, try to look it up in the group cache.  If we find it, do the
  check for recursive membership.

  Parameters:

  OperationType  -- The type of reverse membership operation specified
  LimitingNCDNT  -- The limiting NCDNT where the operation restricts the
                    scope to a domain
  LimitingDomanSid -- The limiting DomainSid where the operation restricts
                    the scope to a domain
  pfMatch          -- Out parameter TRUE indicates that the current object is
                    should enter the reverse membeship list and be followed
                    transitively

  Return values

  STATUS_SUCCESS
  Other error codes to indicate resource failures
--*/
{
    CLASSCACHE  *pClassCache;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       len;
    ULONG       objectRid;
    NT4_GROUP_TYPE NT4GroupType;
    NT5_GROUP_TYPE NT5GroupType;
    BOOLEAN     SecurityEnabled;
    ULONG       MostBasicClass;
    //
    // Initialize return values
    //

    *pfMatch = FALSE;

    //
    // Perform the SID  Check
    //

    if (0==SidLen) {
        //
        // No Sid, then no no match
        //

        return STATUS_SUCCESS;
    }

    //
    // Sid is present and is a valid Sid
    //

    Assert(RtlValidSid((PSID) pSid));


    //
    // Filter out all builtin aliases, unless operation is
    // RevMembGetAliasMembership
    //

    objectRid = *RtlSubAuthoritySid(
            pSid,
            *RtlSubAuthorityCountSid(pSid)-1
            );

    if ((objectRid <= DOMAIN_ALIAS_RID_REPLICATOR)
        && (objectRid>=DOMAIN_ALIAS_RID_ADMINS)
        && (RevMembGetAliasMembership!=OperationType)) {
        return STATUS_SUCCESS;
    }

    // If a limiting domain SID was provided, filter SIDs
    // by domain. The limiting domain SID is important for
    // all operations except getting universal groups

    if (( NULL != LimitingDomainSid ) &&
        (OperationType!=RevMembGetUniversalGroups)) {

        NT4SID domainSid;

        SampSplitNT4SID((NT4SID *)pSid, &domainSid, &objectRid);

        if ( !RtlEqualSid(&domainSid, LimitingDomainSid) )  {
            return STATUS_SUCCESS;
        }
    }


    //
    // Perform the naming context test
    //
    if ((OperationType!=RevMembGetUniversalGroups)
        && (NCDNT!=LimitingNCDNT)) {
        //
        // Naming Context's do not match
        //

        return STATUS_SUCCESS;
    }

    //
    // Read the group type
    //
    if(!GroupType) {
        // No GroupType.
        // this means that the object is probaly
        // not a group, so does not enter token

        return(STATUS_SUCCESS);
    }


    //
    // And the actual class id.
    //

    if ( 0 == (pClassCache = SCGetClassById(pTHS, Class)) ) {
        return(STATUS_INTERNAL_ERROR);
    }

    //
    // Derive the most basic class
    //

    MostBasicClass = SampDeriveMostBasicDsClass(Class);

    //
    // Check the group type
    //

    if (SampGroupObjectType!=SampSamObjectTypeFromDsClass(MostBasicClass)) {
        //
        // The object is not a group, so does not enter the token
        //

        return STATUS_SUCCESS;
    }

    NtStatus = SampComputeGroupType(
            MostBasicClass,
            GroupType,
            &NT4GroupType,
            &NT5GroupType,
            &SecurityEnabled
            );

    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // If the group is not security enabled, bail
    //

    if (!SecurityEnabled) {
        return STATUS_SUCCESS;
    }

    //
    // Check wether the group type is correct for the specified
    // operation
    //

    switch(OperationType) {
    case RevMembGetGroupsForUser:
        if (NT4GlobalGroup!=NT4GroupType)
            return STATUS_SUCCESS;
        break;

    case RevMembGetAliasMembership:
        if (NT4LocalGroup!=NT4GroupType)
            return STATUS_SUCCESS;
        break;

    case RevMembGetAccountGroups:
    case RevMembGlobalGroupsNonTransitive:
        if (NT5AccountGroup!=NT5GroupType)
            return STATUS_SUCCESS;
        break;
    case RevMembGetResourceGroups:
        if (NT5ResourceGroup!=NT5GroupType)
            return STATUS_SUCCESS;
        break;

    case RevMembGetUniversalGroups:
        if (NT5UniversalGroup!=NT5GroupType)
            return STATUS_SUCCESS;
        break;
    }

    //
    // If we got upto here, it means that we passed the filter
    // test.
    //

    *pfMatch = TRUE;

    return STATUS_SUCCESS;

}

NTSTATUS
SampFindGroupByCache (
        IN  THSTATE *pTHS,
        IN  GUID    *pGuid,
        IN  DWORD   *pulDNT,
        IN  BOOL     fBaseObj,
        IN  REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
        IN  ULONG    LimitingNCDNT,
        IN  PSID     LimitingDomainSid,
        IN  BOOL     bNeedSidHistory,
        OUT BOOLEAN *pfHasSidHistory,
        OUT BOOLEAN *pfMatch,
        OUT PDSNAME *ppDSName
        )
/*++

  Given a DNT, try to look it up in the group cache.  If we find it, do the
  check for recursive membership.

  Parameters:

  OperationType  -- The type of reverse membership operation specified
  LimitingNCDNT  -- The limiting NCDNT where the operation restricts the
                    scope to a domain
  LimitingDomanSid -- The limiting DomainSid where the operation restricts
                    the scope to a domain
  pfMatch          -- Out parameter TRUE indicates that the current object is
                    should enter the reverse membeship list and be followed
                    transitively

  Return values

  STATUS_SUCCESS
  Other error codes to indicate resource failures
--*/
{
    GROUPTYPECACHERECORD GroupCacheRecord;
    NTSTATUS         NtStatus = STATUS_SUCCESS;
    ULONG            len;
    DWORD            ulDNT=INVALIDDNT;

    //
    // Initialize return values
    //

    *pfMatch = FALSE;

    if(!pulDNT) {
        pulDNT = &ulDNT;
    }

    // First, see if the object is in the cache
    if(!GetGroupTypeCacheElement(pGuid, pulDNT, &GroupCacheRecord)) {
        // failed to find the object in the cache, just return
        return STATUS_INTERNAL_ERROR;
    }

    // Get the shortdsname that's stored in the cache.
    *ppDSName = (PDSNAME)THAllocEx(pTHS, DSNameSizeFromLen(0));
    (*ppDSName)->structLen = DSNameSizeFromLen(0);
    (*ppDSName)->Guid = GroupCacheRecord.Guid;
    (*ppDSName)->Sid = GroupCacheRecord.Sid;
    (*ppDSName)->SidLen = GroupCacheRecord.SidLen;

    // Say that we have a sid history if we were asked for sid history and we
    // actually have one.  That is, if the caller didn't need the sid history
    // checked, tell him we don't have one.
    *pfHasSidHistory = (bNeedSidHistory &&
                        (GroupCacheRecord.flags & GTC_FLAGS_HAS_SID_HISTORY));

    if(!fBaseObj) {

        NtStatus = SampCheckGroupTypeAndDomainLocal (
                pTHS,
                (*ppDSName)->SidLen,
                &(*ppDSName)->Sid,
                GroupCacheRecord.NCDNT,
                GroupCacheRecord.GroupType,
                GroupCacheRecord.Class,
                OperationType,
                LimitingNCDNT,
                LimitingDomainSid,
                pfMatch);

        if(!NT_SUCCESS(NtStatus)) {
            *pfMatch = FALSE;
            return NtStatus;
        }

        if(!*pfMatch) {
            return STATUS_SUCCESS;
        }
    }

    if(!(*pfHasSidHistory)) {
        // Don't actually need to be current in the obj table since the caller
        // doesn't intend to check the SID history, or he does and the Group
        // Type Cache says that he will find no value. So just tweak the DNT in
        // the DBPOS so that we get to the correct place in the link table.

        // NOTE!!! This is highly dangerous!!! We are lying to the DBLayer,
        // telling it currency is set to a specific object in the object table.
        // We do this so that the code to read link values will pick the DNT out
        // of the DBPOS, and that code doesn't actually read from the object
        // table, just the link table.

        // We're doing this extra curicular tweaking in very controlled
        // circumstances, when we believe that no one will use the currency in
        // the object table before we re-set currency to somewhere else.  This
        // is a very likely source for bugs and unexplained behaviour later, but
        // doing it now will make us a LOT faster, and this code desperately
        // needs to be optimized.
        pTHS->pDB->DNT = *pulDNT;
    }
    else {
        DPRINT(3,"Found in the group cache, have to move anyway\n");
        //
        // If we got up to here, it means that we passed the filter
        // test.  Furthermore, the caller is going to check SID history, and the
        // cache says that one exists.  Since someone is going to read from the
        // object, we have to actually position on the object in the DIT.
        //

        // Try to find the DNT.
        if(DBTryToFindDNT(pTHS->pDB,*pulDNT)) {
            *pfMatch = FALSE;
            return STATUS_INTERNAL_ERROR;
        }

        Assert(DBCheckObj(pTHS->pDB));
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SampCheckGroupTypeAndDomain(
    IN  THSTATE *pTHS,
    IN  DSNAME  *pDSName,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
    IN  ULONG   LimitingNCDNT,
    IN  PSID    LimitingDomainSid,
    OUT BOOLEAN *pfMatch
    )
/*++

    Given the Operation type, the limiting NCDNT and the LimitingDomainSid
    this routine determines wether the currently positioned object
    is of the right type and belongs to the correct domain, and indicate whether
    it can enter the reverse membership list and /or be followed transitively

    Parameters:

          OperationType  -- The type of reverse membership operation specified
          LimitingNCDNT  -- The limiting NCDNT where the operation restricts the
                            scope to a domain
          LimitingDomanSid -- The limiting DomainSid where the operation restricts
                              the scope to a domain
          pfMatch          -- Out parameter TRUE indicates that the current object is
                              should enter the reverse membeship list and be followed
                              transitively

    Return values

        STATUS_SUCCESS
        Other error codes to indicate resource failures
--*/
{
    ULONG       actualClass;
    ULONG       actualNCDNT;
    ULONG       actualGroupType;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    //
    // Initialize return values
    //

    *pfMatch = FALSE;

    // Get the data
    if ( 0 != DBGetSingleValue(
            pTHS->pDB,
            FIXED_ATT_NCDNT,
            &actualNCDNT,
            sizeof(actualNCDNT),
            NULL) ) {
        return(STATUS_INTERNAL_ERROR);
    }

    if ( 0 != DBGetSingleValue(
            pTHS->pDB,
            ATT_GROUP_TYPE,
            &actualGroupType,
            sizeof(actualGroupType),
            NULL) ) {

        // Cannot read the GroupType.
        // this means that the object is probaly
        // not a group, so does not enter token

        return(STATUS_SUCCESS);
    }

    if ( 0 != DBGetSingleValue(
            pTHS->pDB,
            ATT_OBJECT_CLASS,
            &actualClass,
            sizeof(actualClass),
            NULL) ) {
        // Failed to Read Object Class
        return STATUS_INTERNAL_ERROR;
    }

    NtStatus = SampCheckGroupTypeAndDomainLocal (
            pTHS,
            pDSName->SidLen,
            &pDSName->Sid,
            actualNCDNT,
            actualGroupType,
            actualClass,
            OperationType,
            LimitingNCDNT,
            LimitingDomainSid,
            pfMatch);

    if(!NT_SUCCESS(NtStatus)) {
        *pfMatch = FALSE;
        return NtStatus;
    }

    return STATUS_SUCCESS;
}

ULONG ulDNTDomainUsers=0;
ULONG ulDNTDomainComputers=0;
ULONG ulDNTDomainControllers=0;

NTSTATUS
SampGetPrimaryGroup(
    IN  THSTATE *pTHS,
    IN  DSNAME  * UserName OPTIONAL,
    OUT PULONG   pPrimaryGroupDNT)
/*++

    Routine Description

        This routine retrieves the primary group of an object.
        At input the database cursor is assumed to be positioned on
        the object. At successful return time the database cursor is
        positioned on the priamry group object

    Parameters

        UserName     - If the User's DS Name has been specified, then
                       grab the SID, from the user's DS Name as opposed
                       to reading the SID again

        PrimaryGroupDNT - DNT of the Primary Group is returned in here
                       If the object does not have a primary group then
                       the return code is SUCCESS and this parameter is
                       set to NULL
    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       PrimaryGroupIdVal;
    PULONG      PrimaryGroupId = &PrimaryGroupIdVal;
    ULONG       outLen;
    DWORD       err;
    ULONG       ulDNTToReturn=0;

    *pPrimaryGroupDNT = 0;

    //
    // At this point we are positioned on the object whose
    // primary group Id we want to retrieve. Issue a DBGetAttVal
    // to retrieve the value of Primary Group Id
    //

    err=DBGetAttVal(
                    pTHS->pDB,
                    1,
                    ATT_PRIMARY_GROUP_ID,
                    DBGETATTVAL_fCONSTANT,   // DB layer should alloc
                    sizeof(ULONG),                      // initial buffer size
                    &outLen,                // output buffer size
                    (UCHAR **) &PrimaryGroupId
                );

    if (0==err)
    {
        NT4SID  SidBuffer;
        PSID    Sid=&SidBuffer;
        NT4SID  DomainSid;
        ULONG   sidLen;
        DSNAME   PrimaryGroupDN;

        //
        // Found the Primary Group Id of the user object.
        //

        Assert(sizeof(ULONG)==outLen);

        //
        // check if primary group is one of the standard groups
        //


        switch(PrimaryGroupIdVal)
        {
        case DOMAIN_GROUP_RID_USERS:
             if (0!=ulDNTDomainUsers)
             {
                 ulDNTToReturn = ulDNTDomainUsers;
                 break;
             }

        case DOMAIN_GROUP_RID_COMPUTERS:
             if (0!=ulDNTDomainComputers)
             {
                 ulDNTToReturn = ulDNTDomainComputers;
                 break;
             }

        case DOMAIN_GROUP_RID_CONTROLLERS:
             if (0!=ulDNTDomainControllers)
             {
                 ulDNTToReturn = ulDNTDomainControllers;
                 break;
             }

        default:

            if (UserName->SidLen > 0)
            {
                //
                // Try making use of the SID in the User DN
                //

                RtlCopyMemory(Sid,&(UserName->Sid),sizeof(NT4SID));
                sidLen = RtlLengthSid(Sid);
            }
            else
            {
                //
                // Retrieve the User Object's SID
                //

                if (0!=DBGetAttVal(
                        pTHS->pDB,
                        1,
                        ATT_OBJECT_SID,
                        DBGETATTVAL_fCONSTANT,   // DB layer should alloc
                        sizeof(NT4SID),          // initial buffer size
                        &sidLen,                // output buffer size
                        (UCHAR **) &Sid
                        ))
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
            }

            Assert(RtlValidSid(Sid));
            Assert(sidLen<=sizeof(NT4SID));

            //
            // Compose the Primary group object's Sid.
            // This makes the assumption the the primary group
            // and the user are in the same domain, so only their
            // Rids are affected, so munge the Rid field in the Sid
            //

            *RtlSubAuthoritySid(
                Sid,
                *RtlSubAuthorityCountSid(Sid)-1) = *PrimaryGroupId;

            //
            // Construct a Sid Only name. With full support for positioning
            // by SID we should be able to construct a Sid only name
            //

            RtlZeroMemory(&PrimaryGroupDN, sizeof(DSNAME));
            PrimaryGroupDN.SidLen = RtlLengthSid(Sid);
            RtlCopyMemory(&(PrimaryGroupDN.Sid), Sid, RtlLengthSid(Sid));
            PrimaryGroupDN.structLen = DSNameSizeFromLen(0);

            //
            // Position using the SID only Name
            //

            err = DBFindDSName(pTHS->pDB, &PrimaryGroupDN);

            if (0!=err)
            {
                //
                // Cannot find the Primary Group
                // object. This is again ok, as the group could
                // have been deleted, and since we maintain
                // no consistency wrt primary group, this can
                // happen
                //

                NtStatus = STATUS_SUCCESS;
                goto Error;
            }

            //
            // O.k We are now postioned on the primary group
            // object.Update the standard DNT's if required
            //

            ulDNTToReturn = pTHS->pDB->DNT;

            switch(ulDNTToReturn)
            {
            case DOMAIN_GROUP_RID_USERS:
                ulDNTDomainUsers = ulDNTToReturn;
                break;

            case DOMAIN_GROUP_RID_COMPUTERS:
                ulDNTDomainComputers = ulDNTToReturn;
                break;

            case DOMAIN_GROUP_RID_CONTROLLERS:
                ulDNTDomainControllers = ulDNTToReturn;
                break;
            }

        }
    }
    else if (DB_ERR_NO_VALUE==err)
    {
        //
        // We cannot give the Primary Group Id. THis is
        // ok as the object in question does not have a
        // valid primary group
        //

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        //
        // Else we must fail the call. Cannot ever give a wrong value for
        // someone's token
        //
        NtStatus = STATUS_UNSUCCESSFUL;
    }

Error:

    if (NT_SUCCESS(NtStatus))
    {
        *pPrimaryGroupDNT = ulDNTToReturn;
    }

    return NtStatus;

}

NTSTATUS
SampReadSidHistory(
    THSTATE    * pTHS,
    CDSNameSet * pSidHistory
    )
/*++

    Routine Description

        This Routine Reads the Sid History Off of the Currently Positioned
        object. This routine does not alter the cursor position.

    Parameters

        pSidHistory This is a pointer to a CDSNameSet Object. The SIDs
                 pertaining to SID history are added to this object. Using the
                 CDSNameSet class, allows for automatic memory allocation
                 management, plus also automatically filters out any duplicates.
                 This is actually a performance saver, because higher layers now
                 need not manually check for duplicates.

--*/
{
    ULONG   dwErr=0;
    ULONG   iTagSequence =0;
    ATTCACHE *pAC = NULL;
    ULONG    outLen;
    PSID     SidValue;
    // Get attribute cache entry for reverse membership.

    if (!(pAC = SCGetAttById(pTHS, ATT_SID_HISTORY))) {
        LogUnhandledError(ATT_SID_HISTORY);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Read all the values in JET.
    // PERFHINT: at some point see if we can do everything in 1 retrieve
    // column
    //

    while (0==dwErr)
    {
        dwErr = DBGetAttVal_AC( 
                        pTHS->pDB,              // DBPos
                        ++iTagSequence,         // which value to get
                        pAC,                    // which attribute
                        DBGETATTVAL_fREALLOC,   // DB layer should alloc
                        0,                      // initial buffer size
                        &outLen,                // output buffer size
                        (UCHAR **) &SidValue);

        if (0==dwErr)
        {

            // We Successfully retrieved a Sid History value
            // Add it to the List. Construct a SID only DSNAME
            // for the SID history and add to the CReverseMembership

            Assert(RtlValidSid(SidValue));
            Assert(RtlLengthSid(SidValue)<=sizeof(NT4SID));
            pSidHistory->CheckDuplicateAndAdd(SidValue);

            if (pSidHistory->Count() > MAX_TOKEN_GROUPS_COUNT)
            {
                break;
            }

        }
        else if (DB_ERR_NO_VALUE==dwErr)
        {

            //
            // It's Ok to have no Sid History.
            //

            continue;
        }
        else
        {
            return STATUS_UNSUCCESSFUL;
        }

    }

    return STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SampGetMemberships - Implementation                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


extern "C" {

DWORD
SampFindObjectByGuid(
    IN THSTATE * pTHS,
    IN DSNAME  * ObjectName,
    IN REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
    IN BOOLEAN  fBaseObject,
    IN BOOLEAN  fUserObject,
    IN ULONG    LimitingNCDNT,
    IN PSID     LimitingDomainSid,
    IN BOOLEAN  fSidHistoryRequired,
    OUT BOOLEAN * pfChecked,
    OUT BOOLEAN * pfMatch,
    OUT BOOLEAN * pfHasSidHistory,
    OUT BOOLEAN * pfMorePassesRequired
    )
/*++

    Routine Description

    This routine finds the object by GUID. It first checks the group type cache
    for a match. If the cache lookup did not succeed it positions on the object
    by GUID

    Parameters


    pTHS -- The current Thread State
    ObjectName -- The GUID based object Name
    OperationType -- The reverse membership operation type
    fUserObject   -- Indicates that the given DS name indicates a user object
    fBaseObject   -- The base object of the search
    LimitingNcDNT -- Specifies the NC where we want to lookup the object in
    LimitingDomainSid -- The SID of the domain ( builtin/account ) that we want
                         to lookup the object in
    pfChecked         -- Indicates that the group type check has been performed on this
                         object.

    pfMatch           -- If pfChecked is true means that the group type matched

    pfHasSidHistory   -- Wether or not a group has sid history is returned in there if the
                         above 2 are true

    Return Values

       0 On Success
       Other DB Layer error codes on failure


--*/
{
    DWORD   dwErr = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Initialize Return Values
    //

    *pfChecked = FALSE;
    *pfMatch   = TRUE;
    *pfHasSidHistory = TRUE;

    //
    // First try looking up by  guid in the group type cache
    // No Point trying to lookup user objects
    //



    if (!fUserObject)
    {
        NtStatus = SampFindGroupByCache(
                        pTHS,
                        &ObjectName->Guid,
                        NULL,
                        fBaseObject,
                        OperationType,
                        LimitingNCDNT,
                        LimitingDomainSid,
                        fSidHistoryRequired,
                        pfHasSidHistory,
                        pfMatch,
                        &ObjectName
                        );
    }

    if ((NT_SUCCESS(NtStatus)) && (!fUserObject))
    {
        // Found it in the cache

        //
        // If we are looking up by guid, this is typically the object passed
        // in as opposed to recursing up the tree. The object passed need not
        // match, any criterio plus also can be a phantom ( as in the case
        // of cross domain memberships ).
        //

        *pfChecked = TRUE;
    }
    else
    {
        //
        // Try to find the DS Name.
        //

        dwErr = DBFindDSName(pTHS->pDB, ObjectName);

        //
        // If we missed a group in the cache then
        // then try add that to the group type cache.
        //

        if ((!dwErr) && (!fUserObject))
        {
            GroupTypeCacheAddCacheRequest(pTHS->pDB->DNT);
        }
    }

    // We are finished with the current DS name
    *pfMorePassesRequired = FALSE;

    return(dwErr);
}

DWORD
SampFindObjectByDNT(
    IN THSTATE * pTHS,
    IN ULONG     ulDNT,
    IN REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
    IN ULONG    LimitingNCDNT,
    IN PSID     LimitingDomainSid,
    IN BOOLEAN  fSidHistoryRequired,
    OUT BOOLEAN * pfChecked,
    OUT BOOLEAN * pfMatch,
    OUT BOOLEAN * pfHasSidHistory,
    OUT BOOLEAN * pfMorePassesRequired,
    OUT DSNAME  ** ObjectName
    )
/*++

    Routine Description

    This routine finds the object by DNT. It first checks the group type cache
    for a match. If the cache lookup did not succeed it positions on the object
    by GUID

    Parameters


    pTHS              -- The current Thread State
    ulDNT             -- The DNT of the object
    OperationType     -- The reverse membership operation type
    LimitingNcDNT     -- Specifies the NC where we want to lookup the object in
    LimitingDomainSid -- The SID of the domain ( builtin/account ) that we want
                         to lookup the object in
    pfChecked         -- Indicates that the group type check has been performed on this
                         object.

    pfMatch           -- If pfChecked is true means that the group type matched

    pfHasSidHistory   -- Wether or not a group has sid history is returned in there if the
                         above 2 are true

    ObjectName        -- The GUID and SID of the object are returned in this valid DS Name
                         structure
    Return Values

       0 On Success
       Other DB Layer error codes on failure


--*/
{
    DWORD   dwErr = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    len = 0;


    //
    // Initialize Return Values
    //

    *pfChecked = FALSE;
    *pfMatch   = TRUE;
    *pfHasSidHistory = TRUE;

    //
    // Try the group type cache.
    //

    NtStatus = SampFindGroupByCache(
                    pTHS,
                    NULL,
                    &ulDNT,
                    FALSE, //fBaseObject
                    OperationType,
                    LimitingNCDNT,
                    LimitingDomainSid,
                    fSidHistoryRequired,
                    pfHasSidHistory,
                    pfMatch,
                    ObjectName
                    );

    if (NT_SUCCESS(NtStatus))
    {
        // Found the object in the cache.


        // Since finding by DNT is used only for objects that
        // were returned as part of the reverse membership list
        // of someone, we should always find it, and it should not
        // be a phantom. Assert that that matched object that has
        // no sid history ( common case of cache hits ) is not a
        // phantom.

        Assert(!(*pfMatch )|| !(*pfHasSidHistory) || DBCheckObj(pTHS->pDB));

        *pfChecked = TRUE;
    }
    else
    {

         //
         // Try to find the DNT. by looking up the database
         //

        dwErr = DBTryToFindDNT(pTHS->pDB,ulDNT);

        // Since finding by DNT is used only for objects that
        // were returned as part of the reverse membership list
        // of someone, we should always find it, and it should not
        // be a phantom

        if (0==dwErr)
        {
            Assert(DBCheckObj(pTHS->pDB));

            //
            // Obtain the DS Name of the Currently Positioned Object
            //

            *ObjectName = (DSNAME *)THAllocEx(pTHS,sizeof(DSNAME));
            RtlZeroMemory(*ObjectName,sizeof(DSNAME));
            dwErr = DBFillGuidAndSid(
                        pTHS->pDB,
                        *ObjectName
                        );
            (*ObjectName)->NameLen = 0;
            (*ObjectName)->structLen = DSNameSizeFromLen(0);


        }
    }

    *pfMorePassesRequired = FALSE;

    return(dwErr);
}

NTSTATUS
SampFindAndAddPrimaryMembers(
    IN THSTATE * pTHS,
    IN DSNAME  * GroupName,
    OUT CDSNameSet * pMembership
    )
/*++

    Routine Description

        This routine finds and adds the set of members that are members by virtue of 
        the primary group id property to the set of memberships. This is done by walking
        the primary group id index.

    Parameters

        pTHS -- The current thread state
        GroupName  The DSNAME of the group
        pMembership --  The transitive membership is added to this set.

    
    Return Values

        STATUS_SUCCESS
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DSNAME          *pSearchRoot;
    FILTER          filter;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    ATTRVAL         attrValFilter;
    ATTRBLOCK       *pAttrBlock;
    ULONG           i=0;
    RESTART         *pRestart = NULL;
    ATTRBLOCK       RequiredAttrs;
    NT4SID          DomainSid;
    ULONG           Rid;
    ULONG           BuiltinDomainSid[] = {0x101,0x05000000,0x20};

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);



    RtlZeroMemory(&RequiredAttrs,sizeof(ATTRBLOCK));

    // Find the Root Domain Object, for the specified Sid
    // This ensures that we find only real security prinicpals,
    // but not turds ( Foriegn Domain Security Principal ) and
    // other objects in various other domains in the G.C that might
    // have been created in the distant past before all the DS
    // stuff came together

    SampSplitNT4SID(&GroupName->Sid,&DomainSid,&Rid);

    //
    // If the SID is from the builtin Domain then return success.
    // Builtin domain contains only builtin local groups therefore
    //

    if (RtlEqualSid(&DomainSid,(PSID) &BuiltinDomainSid))
    {
        return STATUS_SUCCESS;
    }

    if (!FindNcForSid(&DomainSid,&pSearchRoot))
    {
        // This is a case of an FPO that is a member of some
        // group in the forest. The FPO by itself will not have
        // any members. So it is O.K to skip without returning
        // an error

        return STATUS_SUCCESS;
    }

    do 
    {
        attrValFilter.valLen = sizeof(ULONG);
        // Rid is pointer to last subauthority in SID
        attrValFilter.pVal = (PUCHAR )RtlSubAuthoritySid(
                                    &GroupName->Sid,
                                    *RtlSubAuthorityCountSid(&GroupName->Sid)-1);
        memset(&filter, 0, sizeof(filter));
        filter.choice = FILTER_CHOICE_ITEM;
        filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        filter.FilterTypes.Item.FilTypes.ava.type = ATT_PRIMARY_GROUP_ID;
        filter.FilterTypes.Item.FilTypes.ava.Value = attrValFilter;

        memset(&searchArg, 0, sizeof(SEARCHARG));
        InitCommarg(&searchArg.CommArg);
        // Search in multiples of 256
        searchArg.CommArg.ulSizeLimit = 256;


        entInfSel.attSel = EN_ATTSET_LIST;
        entInfSel.AttrTypBlock = RequiredAttrs;
        entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

        searchArg.pObject = pSearchRoot;
        searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
        // Do not Cross NC boundaries.
        searchArg.bOneNC = TRUE;
        searchArg.pFilter = &filter;
        searchArg.searchAliases = FALSE;
        searchArg.pSelection = &entInfSel;

        pSearchRes = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
        pSearchRes->CommRes.aliasDeref = FALSE;
        pSearchRes->PagedResult.pRestart = pRestart;

        SearchBody(pTHS, &searchArg, pSearchRes,0);

        if (pSearchRes->count>0)
        {
           ENTINFLIST * CurrentEntInf;

            for (CurrentEntInf = &(pSearchRes->FirstEntInf);
                    CurrentEntInf!=NULL;
                    CurrentEntInf=CurrentEntInf->pNextEntInf)

            {   
                pMembership->CheckDuplicateAndAdd(CurrentEntInf->Entinf.pName);
                
            }
        }

        pRestart = pSearchRes->PagedResult.pRestart;
    } while ((NULL!=pRestart) && (pSearchRes->count>0));
             
    return ( Status);

}


NTSTATUS
SampGetMembersTransitive(
    IN THSTATE * pTHS,
    IN DSNAME * GroupName,
    OUT CDSNameSet  *pMembership
    )
/*++

    Routine Description

        This is the worker routine to find the transitive membership list of a group by
        traversing the link table. This routine does not consider the membership
        by virtue of the primary group id property. This is O.K for transitive
        membership computation as only users have a primary group id property and
        users are by defintion "leaves" in a membership list

    Parameters

        pTHS -- The current thread state
        GroupName  The DSNAME of the group
        pMembership --  The transitive membership is added to this set.

    Return Values

        STATUS_SUCCESS
        STATUS_OBJECT_NAME_NOT_FOUND
        Other Error codes
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    CReverseMembership Membership;
    DWORD dwErr =0 ;
    ULONG    ulDNT=0;
    BOOLEAN  fBaseObject = TRUE;
    ATTCACHE * pAC;
    ULONG len;
    DSNAME * pDsName;
    BOOL    bFirst;


    __try
    {
        //
        // Get an attribute cache entry for membership
        //

        if (!(pAC = SCGetAttById(pTHS, ATT_MEMBER))) {
            LogUnhandledError(ATT_MEMBER);
            Status =STATUS_UNSUCCESSFUL;
            __leave;
        }

        while(fBaseObject || (0!=ulDNT))
        {
            CLASSCACHE  *pClassCache;
            ULONG       iClass;
            BOOL        FindPrimaryMembers = FALSE;

            //
            // Position on the object locally
            //

            if (!fBaseObject)
            {
                dwErr = DBTryToFindDNT(pTHS->pDB,ulDNT);
                if (0!=dwErr)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    __leave;
                }

                //
                // Get the DSNAME corresponding to this object
                //

                dwErr = DBGetAttVal(pTHS->pDB,
                            1,
                            ATT_OBJ_DIST_NAME,
                            DBGETATTVAL_fSHORTNAME,
                            0,
                            &len,
                            (PUCHAR *)&pDsName
                            );

                if (DB_ERR_NO_VALUE==dwErr)
                {
                    //
                    // This could be because the object we are
                    // positioned right now might be a phantom. In that
                    // case, we neither need to modify the object, nor need
                    // to follow it transitively. Therefore start again with
                    // the next object
                    //

                    dwErr = 0;
                    goto NextObject;
                }            
                else if (0!=dwErr)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    __leave;
                }


                //
                // Add it to the list being returned
                //

                pMembership->CheckDuplicateAndAdd(pDsName);

            }
            else
            {
                dwErr = DBFindDSName(pTHS->pDB,GroupName);
                
                if ((DIRERR_OBJ_NOT_FOUND==dwErr) || (DIRERR_NOT_AN_OBJECT==dwErr))
                {
                    //
                    // if the object was not found, or was a phantom, then return
                    // an NtStatus code that indicates that the object was not
                    // found
                    //

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                    __leave;
                }
                else if (0!=dwErr)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    __leave;
                }

                pDsName = GroupName;
            }


            // 
            // determine whether the current object is a group account or not.
            // 

            if ( 0 != SampDetermineObjectClass(pTHS, &pClassCache) )
            {
                Status = STATUS_UNSUCCESSFUL;
                __leave;
            }

            if ( SampSamClassReferenced(pClassCache, &iClass) && 
                 (ClassMappingTable[iClass].SamObjectType == SampGroupObjectType || 
                  ClassMappingTable[iClass].SamObjectType == SampAliasObjectType)
               )
            {
	            FindPrimaryMembers = TRUE;
            }



            //
            // Recurse through all the objects in the membership
            // list of the group
            //

            bFirst = TRUE;
            while ( TRUE )  
            {
                PULONG  pNextDNT=NULL;
                ULONG   ulNextDNT;

                dwErr = DBGetNextLinkValForLogon(
                            pTHS->pDB,
                            bFirst,
                            pAC,
                            &ulNextDNT
                            );

                if ( DB_ERR_NO_VALUE == dwErr )  
                {
                    // No more values.
                    break;
                }
                else if ( 0 != dwErr )  
                {
                    Status =STATUS_INSUFFICIENT_RESOURCES;
                    __leave;
                }

                bFirst = FALSE;

                //
                // We are casting a 32 bit unsigned integer to a pointer
                // The assumption here is that the pointer type is
                // always equal or bigger ( in terms of bits )
                //

                Membership.Add((PVOID)(ULONG_PTR)ulNextDNT);
            }

            //
            // Add the membership by virtue of the primary
            // group id property. No need to follow this
            // transitively
            // only do so for group object
            //

            if ( FindPrimaryMembers )
            {
                Status = SampFindAndAddPrimaryMembers(
                                pTHS,
                                pDsName,
                                pMembership
                                );

                if (!NT_SUCCESS(Status))
                {
                    __leave;
                }
            }

NextObject:
            //
            // For Sundown the Assumption here is that DNT will always be
            // a 32 bit value and so truncating and losing the upper few
            // bits is O.K
            //

            ulDNT = PtrToUlong(Membership.NextUnrecursed());
            pDsName = NULL;
            fBaseObject = FALSE;

        } // while ( 0!=ulDNT )
   }
   __finally
   {

   
   }


   return Status;

}

NTSTATUS
SampGetMembershipsActual(
    IN  THSTATE         *pTHS,
    IN  DSNAME          *pObjName,
    IN  BOOLEAN         fUserObject,
    IN  OPTIONAL        DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    IN  OUT CDSNameSet  *pReverseMembership,
    IN  OUT CDSNameSet      *pSidHistory OPTIONAL
    )

/*++

Routine Description:

    Derives the transitive reverse membership of an object local
    to this machine. This is the worker routine for reverse membership
    derivation

Arguments:

    pObjName - pointer to DSNAME of the object whose reverse membership
        is desired.


    fUserObject     - Set to true if the object specified in pObjName is a user object.
                      This information is used to optimize lookups/fills in the group
                      type cache. Note Getting this flag wrong, only results in a small
                      performance penalty, does not cause any incorrect operation.

    pLimitingDomain - optional pointer to the DSNAME of a domain ( or builtin
                      domain to filter results on ie groups not from this domain
                      are neither returned nor followed transitively.

    OperationType  -- Indicates the type of group membership evaluation we need to
                      perform. Valid values are

                      RevMembGetGroupsForUsers    -- Gets the non transitive ( one level)
                                                   membership, of an object in groups
                                                   confined to the same domain ( specified
                                                   by pLimitingDomain. Will filter out
                                                   builtin groups.

                      RevMembGetAliasMembership   -- Gets the non transitive ( one level)
                                                   membership of an object in local groups
                                                   confined to the same domain ( specified
                                                   by limiting domain SID and limiting
                                                   naming context ).

                      RevMembGetUniversalGroups   -- Gets the transitive reverse membership
                                                  in all universal groups, without regard to
                                                  any restrictions. Will filter out builtin
                                                  groups. The pLimitingDomain Parameter
                                                  should not be specified

                      RevMembGetAccountGroups     -- Gets the transitive reverse membership
                                                  in all account groups, in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups.

                      RevMembGetResourceGroups    -- Gets the transitive reverse membership
                                                  in all resource groups in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups

                      GroupMembersTransitive    -- Gets the transitive membership list in 
                                                  the specified set of groups. SID history 
                                                  and attributes are not returned and are ignored
                                                  if this value is specified for the operation type

                      RevMembGlobalGroupsNonTransitive -- Gets the list of global groups, but
                                                  does not do the transitive closure of these groups


    pReverseMembership -- This is a pointer to a DS Name set to which the filtered membership
                          is added. Using DSName sets as parameters simplifies the implementation
                          of routines that get the membership of multiple security principals,
                          as this class has all the logic to filter duplicates.

    pSidHistory        -- This is a pointer to a DS Name set to which the SID history is added.



Return Value:

    STATUS_SUCCESS on success.
    STATUS_INSUFFICIENT_RESOURCES on a resource failure
    STATUS_TOO_MANY_CONTEXT_IDS if the number of groups is greater than what can be fit in
                                a token.

--*/

{
    ATTCACHE            *pAC;
    DWORD               dwErr;
    INT                 iErr;
    BOOLEAN             bFirst;
    PDSNAME             pDSName = pObjName;
    CReverseMembership  revMemb;
    NTSTATUS            status = STATUS_SUCCESS;
    BOOLEAN             fMatch;
    BOOLEAN             fHasSidHistory;
    ULONG               dwException,
                        ulErrorCode,
                        ul2;
    PVOID               dwEA;
    ULONG               i;
    ULONG               LimitingNCDNT;
    PSID                LimitingDomainSid;
    BOOLEAN             fBaseObject = TRUE;
    BOOLEAN             fTransitiveClosure;
    BOOLEAN             fChecked = FALSE;
    BOOLEAN             fFirstTimeUserObject = FALSE;

    ULONG               ulDNT=0;


    __try
    {
        //
        // pLimiting domain should be specified if and only if
        // op type is not RevMembGetUniversalGroups or GroupMembersTransitive
        //

        Assert((OperationType==RevMembGetUniversalGroups)
                ||(OperationType==GroupMembersTransitive)
                ||(NULL!=pLimitingDomain));

       Assert((OperationType!=RevMembGetUniversalGroups)||(NULL==pLimitingDomain));

        //
        // Return data will be allocated off the thread heap, so insure
        // we're within the context of a DS transaction.

        Assert(SampExistsDsTransaction());

        //
        // Caller better specify pObjName
        //

        Assert(NULL!=pObjName);

        //
        // If the transitive membership list is specified then compute that and leave
        //

        if (GroupMembersTransitive==OperationType)
        {
            status =  SampGetMembersTransitive(
                            pTHS,
                            pObjName,
                            pReverseMembership
                            );

            goto ExitTry;
        }

        //
        // Compute whether we need transitive closure
        //

        fTransitiveClosure = ((OperationType!=RevMembGetGroupsForUser )
                                && (OperationType!=RevMembGetAliasMembership)
                                && (OperationType!=RevMembGlobalGroupsNonTransitive));

        if ( fTransitiveClosure )
        {
            INC( pcMemberEvalTransitive );

            //
            // Update counters for various transitive cases
            //

            switch ( OperationType )
            {
            case RevMembGetUniversalGroups:
                INC( pcMemberEvalUniversal );
                break;
            case RevMembGetAccountGroups:
                INC( pcMemberEvalAccount );
                break;
            case RevMembGetResourceGroups:
                INC( pcMemberEvalResource );
                break;
            }
        }
        else
        {
            INC( pcMemberEvalNonTransitive );
        }

        //
        // Get attribute cache entry for reverse membership.
        //

        if (!(pAC = SCGetAttById(pTHS, ATT_IS_MEMBER_OF_DL))) {
            LogUnhandledError(ATT_IS_MEMBER_OF_DL);
            status =STATUS_UNSUCCESSFUL;
            goto ExitTry;
        }

        //
        // If a Limiting Domain is specified, the limiting domain test is (theoretically)
        // applied in the following manner ( note limiting domain can be a builtin domain )
        //      1. Get an NCDNT value, such that a group with that NCDNT value will
        //         may fall within the domain and groups with different NCDNT value will
        //         definately fall outside that domain. If the domain object specfied
        //         is an NC head this corresponds to the case of a "normal" domain use
        //         the DNT of the domain as the NCDNT value. Otherwise assume it is a
        //         builtin domain.
        //
        //      2. Get the Domain SID from the specified DSNAME and throw away groups which
        //         do not have the domain prefix equal to the domain SID.
        //
        //    Product1 however does not have multiple hosted domain support. Therefore it is
        //    safe to assume that the limiting domain that is passed in always either the
        //    authoritative domain for the domain controller , or its corresponding builtin
        //    domain.

        if (ARGUMENT_PRESENT(pLimitingDomain))
        {


            Assert(pLimitingDomain->SidLen>0);
            LimitingDomainSid = &pLimitingDomain->Sid;
            Assert(RtlValidSid(LimitingDomainSid));

            Assert(NULL!=gAnchor.pDomainDN);
           // Assert((NameMatched(gAnchor.pDomainDN,pLimitingDomain))
           //             ||(IsBuiltinDomainSid(LimitingDomainSid)));

            LimitingNCDNT = gAnchor.ulDNTDomain;
        }
        else
        {
            LimitingDomainSid = NULL;
            LimitingNCDNT = 0;
        }
                

        //
        // Loop getting reverse memberships until we're done.
        //

        while (fBaseObject || (0!=ulDNT))
        {
            DWORD iObject=0;
            BOOLEAN fSearchBySid = FALSE;
            BOOLEAN fSearchByDNT = FALSE;
            BOOLEAN fMorePassesOverCurrentName = TRUE;
            ULONG   TotalCount = 0;


            fSearchBySid = (NULL!=pDSName)&&(fNullUuid( &pDSName->Guid ))&&(0==pDSName->NameLen)
                            &&(pDSName->SidLen>0)&&(RtlValidSid(&(pDSName->Sid)));

            fSearchByDNT = (NULL==pDSName);

            while(fMorePassesOverCurrentName)
            {

                //
                    // Position database to the name.
                //
                // SampGetMemberships accepts several types of Names
                //
                // 1. Standard DS Name , with either the GUID or Name Filled in. In this
                //    case SampGetMemberships uses DBFindDSName to position on the object.
                //    Only a single pass is made over the name
                //
                // 2. A Sid Only DSName, with no GUID and String name Filled in. In this case
                //    this routine Uses DBFindObjectWithSid to position on the object.
                //    Multiple passes are made , each type with a different sequence number
                //    to find all occurrences of Object's with the given SID. Note on a G.C
                //    several object's may co-exist with the same Sid, but on different
                //    naming context. A simple case is the builtin groups. A more complex case
                //    is (former)NT4 security prinicipals being members of DS groups. ( FPO's
                //    and regular objects for the same security principals ).
                //
                //
                // 3. It is possible that the DS name is that of a phantom
                //    object in the DIT. This happens during an AliasMembership expansion, or
                //    a resource group expansion, where a cross domain member's reverse membership
                //    is being expanded.
                //
                // 4. The name is simpy a DNT. This happens when recursing up, as for performance
                //    reasons it is more efficient to keep the identity of the object as a DNT.
                //
                // Also since DBFindDsName and DBFIndObjectWithSid can throw exceptions,
                // they are enclosed within a exception handler
                //

                // assume the object has not been checked in the group type cache
                fChecked = FALSE;
                // Assume object will match any limited group constraints
                fMatch = TRUE;
                // Assume a sid history
                fHasSidHistory = TRUE;
                __try {
                    if (fSearchByDNT) {

                        //
                        // Base object Cannot be a DNT
                        //
                        Assert(!fBaseObject);

                        //
                        // Lookup the object by DNT
                        //

                        dwErr = SampFindObjectByDNT(
                                    pTHS,
                                    ulDNT,
                                    OperationType,
                                    LimitingNCDNT,
                                    LimitingDomainSid,
                                    ARGUMENT_PRESENT(pSidHistory),
                                    &fChecked,
                                    &fMatch,
                                    &fHasSidHistory,
                                    &fMorePassesOverCurrentName,
                                    &pDSName
                                    );

                    }
                    else if (fSearchBySid)
                    {
                        dwErr = DBFindObjectWithSid(pTHS->pDB, pDSName,iObject++);
                        // We have not yet found all occurences of object's with the given
                        // Sid. Therefore do not as yet mark this ds Name as finished. Down
                        // below when we examing the error code, we will decide whether more
                        // passes are needed or not.

                    }
                    else
                    {
                        //
                        // Search By GUID
                        //

                        dwErr = SampFindObjectByGuid(
                                    pTHS,
                                    pDSName,
                                    OperationType,
                                    fBaseObject,
                                    (fBaseObject) && (fUserObject),
                                    LimitingNCDNT,
                                    LimitingDomainSid,
                                    ARGUMENT_PRESENT(pSidHistory),
                                    &fChecked,
                                    &fMatch,
                                    &fHasSidHistory,
                                    &fMorePassesOverCurrentName
                                    );

                    }

                    switch(dwErr)
                    {
                    case 0:

                        // Success
                        break;

                    case DIRERR_NOT_AN_OBJECT:

                        if (fBaseObject)
                        {
                            // Positioning on Phantom is OK for base Object
                            dwErr=0;
                        }
                        else
                        {
                            //
                            // While recursing up we should never position
                            // on a phantom. This is because
                            // Membership "travels" with the group, not the member.
                                    // Therefore the reverse membership property points only
                                    // to memberships in groups in naming contexts on this
                                    // machine.  Thus returned name is real, not a phantom.
                            //

                            Assert(FALSE && "Positioned on a Phantom while recursing up");
                            status = STATUS_INTERNAL_ERROR;
                            goto ExitTry;

                        }
                        break;

                    case DIRERR_OBJ_NOT_FOUND:

                        if (fSearchBySid)
                        {
                            // If we are Searching By Sid its Ok to not find the
                            // object. Skip the object and attempt processing the
                            // next object

                            dwErr=0;
                            // We are finished with the current DS name
                            // as all occurances of the object(s) with the given SID
                            // have been processed.
                            // We are not positioned on any object at this time. We must
                            // go get the next DS Name to process. So exit this loop.
                            fMorePassesOverCurrentName=FALSE;
                            continue;
                        }
                        else
                        {
                            status = STATUS_OBJECT_NAME_NOT_FOUND;
                            goto ExitTry;
                        }

                        break;

                    default:

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ExitTry;
                    }

                }
                __except (HandleMostExceptions(GetExceptionCode()))  {
                    // bail on exception. Most likely cause of an exception
                    // is a resource failure. So set error code as
                    // STATUS_INSUFFICINET_RESOURCES
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ExitTry;
                }
        
                //
                // If We are here we have a DSName for the current object
                //

                Assert(NULL!=pDSName);

                //
                // If the specified object is not the base object specified then
                // apply the filter test
                //

                if (!fBaseObject) {

                    //
                    // If the object registered a group type cache hit, then the lookup
                    // itself has done the filter test for the match. Therefore there is
                    // no need to perform a (slow) match test again. In thos cases the
                    // fChecked flag is set.
                    //

                    if(!fChecked)
                    {
                        //
                        // Now depending upon the operation requested evaluate
                        // the filter. We are positioned on the object right now
                        // and can get some properties on a demand basis. Further
                        // we know that the object is not the base object
                        //

                        status = SampCheckGroupTypeAndDomain(
                                pTHS,
                                pDSName,
                                OperationType,
                                LimitingNCDNT,
                                LimitingDomainSid,
                                &fMatch
                                );

                        if (!NT_SUCCESS(status)) {
                            goto ExitTry;
                        }
                    }

                    if (!fMatch)
                    {
                        //
                        // Our Filter Indicates that we need not consider this
                        // object for further reverse membership processing,
                        // (either adding to the list ) or following up transtively.
                        // Therefore move on to the next object
                        //

                        continue;
                    }

                    //
                    // Since this is not the base object add this to the reverse membership
                    // list to be returned
                    //

                    pReverseMembership->CheckDuplicateAndAdd(pDSName);
                }

                //
                // Read The Sid History If required.
                // The SID history is added in , in general only for objects that are retrieved as part of this
                // routine. The one exception to the rule is for the case of the user object that is passed in first
                // around for evaluation.
                //

                fFirstTimeUserObject = fBaseObject && 
                   ((OperationType == RevMembGetAccountGroups ) || (OperationType==RevMembGetGroupsForUser));

                if (ARGUMENT_PRESENT(pSidHistory) && fHasSidHistory && ( !fBaseObject || fFirstTimeUserObject))
                {
                    //
                    // Caller Wanted Sid History
                    //

                    status = SampReadSidHistory(pTHS, pSidHistory);
                    if (!NT_SUCCESS(status))
                        goto ExitTry;
                }

                //
                // for performance consideration (to prevent/recovery from the Deny of Service Attack)
                // stop group expansion if reached the limit
                // see windows bug 452255 for more detail.
                // 
                TotalCount = pReverseMembership->Count();

                if (ARGUMENT_PRESENT(pSidHistory))
                {
                    TotalCount += pSidHistory->Count();
                }

                if (TotalCount > MAX_TOKEN_GROUPS_COUNT)
                {
                    goto ExitTry;
                }




                // This object satisfies all filter criterions, therefore we should
                // follow the object. Call DBGetAttVal_AC multiple times to get all the values
                // in the reverse membership, and add it to the list to be
                // examined. We will always follow the object if transitive closure is specified
                // or if it is the base object, whose reverse membership we need to compute

                bFirst = TRUE;

                while ( fBaseObject || fTransitiveClosure )  {
                    PULONG  pNextDNT=NULL;
                    ULONG   ulNextDNT;

                    dwErr = DBGetNextLinkValForLogon(
                                pTHS->pDB,
                                bFirst,
                                pAC,
                                &ulNextDNT
                                );

                    if ( DB_ERR_NO_VALUE == dwErr )
                    {
                        // No more values.
                        break;
                    }
                    else if ( 0 != dwErr )
                    {
                        status =STATUS_INSUFFICIENT_RESOURCES;
                        goto ExitTry;
                    }

                    bFirst = FALSE;

                    //
                    // We are casting a 32 bit unsigned integer to a pointer
                    // The assumption here is that the pointer type is
                    // always equal or bigger ( in terms of bits )
                    //

                    revMemb.Add((PVOID)(ULONG_PTR)ulNextDNT);
                }


                //
                // The primary group for users is not stored explicity, but rather in
                // the primary group id property implicitly. Merge this into the reverse
                // memberships. Note further that SampGetPrimaryGroup will alter cursor
                // positioning. Therefore this should be the last element in the group
                //
                // Note: if fChecked is true at this point along with fBase object then
                // this means that the base object was also successfully looked up using
                // the GUID in the group type cache. Since groups have no notion of primary
                // group ID we should not need too call SampGetPrimaryGroup to get the primary
                // group of the object.
                //

                //
                // Note that the PrimaryGroup can be a universal group. If so,
                // only return this membership when the retrieving the 
                // UniversalGroups.  If the PrimaryGroup is a universal group
                // and AccountGroups are being requested, then the 
                // PrimaryGroup will be rejected when the "type" of the group
                // is determined above.
                //

                if ((fBaseObject) &&
                    (!fChecked)   &&
                    ((RevMembGetGroupsForUser==OperationType)
                   ||(RevMembGetAccountGroups==OperationType)
                   ||(RevMembGetUniversalGroups==OperationType)
                   ||(RevMembGlobalGroupsNonTransitive==OperationType)))
                {
                    ULONG  PrimaryGroupDNT = 0;

                    status = SampGetPrimaryGroup(pTHS,
                                                 pDSName,
                                                 &PrimaryGroupDNT);
                    if (!NT_SUCCESS(status))
                        goto ExitTry;

                    if (0!=PrimaryGroupDNT)
                        revMemb.Add((PVOID)(ULONG_PTR)PrimaryGroupDNT);
                }
            }


            // Time to recurse.  Get the next unrecursed value from UnrecursedSet,
            // position at it in the database, and return to the top of the
            // loop.  Quit if there are no more unrecursed values.

            //
            // For Sundown the Assumption here is that DNT will always be
            // a 32 bit value and so truncating and losing the upper few
            // bits is O.K
            //

            ulDNT = PtrToUlong(revMemb.NextUnrecursed());
            pDSName = NULL;
            fBaseObject = FALSE;

        } // while ( NULL != pulDNT )

        
        status = STATUS_SUCCESS;

    ExitTry:
        ;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &ul2))
    {
            HandleDirExceptions(dwException, ulErrorCode, ul2);
            status = STATUS_UNSUCCESSFUL;
    }



    return(status);
}



        



NTSTATUS
SampGetMemberships(
    IN  PDSNAME         *rgObjNames,
    IN  ULONG           cObjNames,
    IN  OPTIONAL        DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT ULONG           *pcDsNames,
    IN  OUT PDSNAME     **prpDsNames,
    IN  OUT PULONG      *Attributes OPTIONAL,
    IN  OUT PULONG      pcSidHistory OPTIONAL,
    IN  OUT PSID        **rgSidHistory OPTIONAL
    )
/*++

Routine Description:

    Derives the transitive reverse membership of an object local
    to this machine. This is the main reverse membership derivation routine for SAM.
    This routine will call SampGetMembershipsActual to perform most of the operations

Arguments:

    rgObjNames        pointer to an array of DS Name pointers. Each DS Name represents
                      a security prinicipal whose reverse membership we desire

    cObjNames         Count, specifies the number of DS Names in rgObjNames


    pLimitingDomain - optional pointer to the DSNAME of a domain ( or builtin
                      domain to filter results on ie groups not from this domain
                      are neither returned nor followed transitively.

    OperationType  -- Indicates the type of group membership evaluation we need to
                      perform. Valid values are

                      RevMembGetGroupsForUsers    -- Gets the non transitive ( one level)
                                                   membership, of an object in groups
                                                   confined to the same domain ( specified
                                                   by pLimitingDomain. Will filter out
                                                   builtin groups.

                      RevMembGetAliasMembership   -- Gets the non transitive ( one level)
                                                   membership of an object in local groups
                                                   confined to the same domain ( specified
                                                   by limiting domain SID and limiting
                                                   naming context ).

                      RevMembGetUniversalGroups   -- Gets the transitive reverse membership
                                                  in all universal groups, without regard to
                                                  any restrictions. Will filter out builtin
                                                  groups. The pLimitingDomain Parameter
                                                  should not be specified

                      RevMembGetAccountGroups     -- Gets the transitive reverse membership
                                                  in all account groups, in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups.

                      RevMembGetResourceGroups    -- Gets the transitive reverse membership
                                                  in all resource groups in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups

                      GetGroupMembersTransitive   -- Gets the transitive direct membership in 
                                                  the group based on the information in the direct
                                                  database. Information about the primary group
                                                  is also merged in. SID history values and attributes
                                                  are not returned as part of this call.



    pcSid - pointer to ULONG which contains SID count on return.

    prpDsNames - pointer to array of DSname pointers which is allocated and
        filled in on return. Note Security Code Requires Sids. DsNames structure
        contains the SID plus the full object Name. The Advantage of returning DS Names
        is that the second phase of the logon need not come back to resolve the Sids
        back into DS Names. Resolving them again may cause a potential trip to
        the G.C again. To avoid this it is best to return DS Names. If second phase
        needs to run, it can directly use the results fr

    Attributes - OPTIONAL parameter, which is used to query the Attributes corresponding
        to the group memberhip . In NT4 and NT5 SAM this is wired to
        SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED

    pcSidHistory OPTIONAL parameter, the count of returned Sids due to the
                 SID history property is returned in here,

    rgSidHistory Array of Sids in the Sid Historuy

Return Value:

    STATUS_SUCCESS on success.
    STATUS_INSUFFICIENT_RESOURCES on a resource failure
    STATUS_TOO_MANY_CONTEXT_IDS if the number of groups is greater than what can be fit in
                                a token.

--*/
{
    THSTATE             *pTHS=pTHStls;
    NTSTATUS            status = STATUS_SUCCESS;
    CDSNameSet          ReverseMembership;      // External format DSNames
    CDSNameSet          SidHistory;             // External format DSNames
    ULONG               dwException,
                        ulErrorCode,
                        ul2;
    PVOID               dwEA;
    ULONG               i;

    __try
    {
        
        //
        // Init return values.
        //

            *pcDsNames = 0;
            *prpDsNames = NULL;

        if (ARGUMENT_PRESENT(pcSidHistory))
            *pcSidHistory = 0;

        if (ARGUMENT_PRESENT(rgSidHistory))
            *rgSidHistory = NULL;

        //
        // Check for valid operation types
        //

        if ((OperationType!=RevMembGetGroupsForUser) &&
           (OperationType!=RevMembGetAliasMembership) &&
           (OperationType!=RevMembGetUniversalGroups) &&
           (OperationType!=RevMembGetAccountGroups) &&
           (OperationType!=RevMembGlobalGroupsNonTransitive)&&
           (OperationType!=RevMembGetResourceGroups) &&
           (OperationType!=GroupMembersTransitive))
        {
            return(STATUS_INVALID_PARAMETER);
        }

        //
        // Init the classes
        //

        ReverseMembership.SetValueType(RevMembDsName);
        SidHistory.SetValueType(RevMembSid);

        //
        // Iterate through each of the objects passed in
        //

        for (i=0;i<cObjNames;i++)
        {
            if (NULL==rgObjNames[i])
            {
                //
                // if a NULL was passed in, then simply ignore
                // This allows sam to simply call resolve Sids,
                // and pass the entire set of DS names down to
                // evaluate for reverse memberships
                //

                continue;
            }

            status = SampGetMembershipsActual(
                        pTHS,
                        rgObjNames[i],
                        (0==i)?TRUE:FALSE, // fUserObject. SAM has this contract with
                                           // the DS that in passing an array of DSNAMES
                                           // to evaluate the reverse membership of an object
                                           // at logon time the user object will be first object
                                           // in the list. At other times, notably ACL conversion
                                           // this need not be true, but then we can take a peformance
                                           // penalty.
                        pLimitingDomain,
                        OperationType,
                        &ReverseMembership,
                        ARGUMENT_PRESENT(rgSidHistory)?&SidHistory:NULL
                        );

            if (STATUS_OBJECT_NAME_NOT_FOUND==status)
            {

                if ((RevMembGetGroupsForUser!=OperationType)
                    && (RevMembGetAccountGroups!=OperationType)
                    && (RevMembGlobalGroupsNonTransitive!=OperationType))
                {
                    //
                    // If the object name was not found, its probaly O.K.
                    // just that the DS Name is not a member of anything
                    // and probably represents a security prinicipal in a
                    // different domain
                    //

                    status = STATUS_SUCCESS;
                    THClearErrors();
                    continue;
                }
                else
                {
                    //
                    // This is a fatal error in a get groups for user or
                    // get account group membership. This is because SAM
                    // in this case typically evaluating the reverse membership
                    // of a user or a group, that it has verified that it exists
                    //

                    break;
                }
            }
        }

        if (NT_SUCCESS(status))
        {
            //
            // Call Succeeded, transfer parameters in the form that caller
            // wants
            //

            *pcDsNames = ReverseMembership.Count();
            if (0!=*pcDsNames)
            {
                *prpDsNames = (PDSNAME *)ReverseMembership.GetArray();
            }

            if (ARGUMENT_PRESENT(rgSidHistory) &&
                    ARGUMENT_PRESENT(pcSidHistory))
            {
                *pcSidHistory = SidHistory.Count();
                if (0!=*pcSidHistory)
                {
                    *rgSidHistory = SidHistory.GetArray();
                }
            }
        }

            // We may have allocated and assigned to *prDsnames, but never filled
            // in any return data due to class filtering.  Null out the return
            // pointer in this case just to be safe.
        
            if ( 0 == *pcDsNames )
        {
                *prpDsNames = NULL;
            }

        //
        // If Attributes were asked for then
        //

        if (ARGUMENT_PRESENT(Attributes))
        {
            *Attributes = NULL;
            if (*pcDsNames>0)
            {
                *Attributes = (ULONG *)THAllocEx(pTHS, *pcDsNames * sizeof(ULONG));
                for (i=0;i<*pcDsNames;i++)
                {
                    (*Attributes)[i]=SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
                }
            }
        }
    }  __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &ul2))
    {
            HandleDirExceptions(dwException, ulErrorCode, ul2);
            status = STATUS_UNSUCCESSFUL;
    }


    return(status);
}

NTSTATUS
SampGetMembershipsFromGC(
    IN  PDSNAME  *rgObjNames,
    IN  ULONG    cObjNames,
    IN  OPTIONAL DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT PULONG   pcDsNames,
    OUT PDSNAME  **rpDsNames,
    OUT PULONG   *pAttributes OPTIONAL,
    OUT PULONG   pcSidHistory OPTIONAL,
    OUT PSID     **rgSidHistory OPTIONAL
    )
/*++

    Routine Description:

        This routine computes the reverse membership of an object at the
        G.C.

    Parameters:

          Same as SampGetMemberships  
          
    Return Values

        STATUS_SUCCESS Upon A Successful Evaluation
        STATUS_NO_SUCH_DOMAIN If a G.C did not exist or could not be contacted
        STATUS_UNSUCCESSFUL   Otherwise
 --*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    ULONG       dwErr=0;
    NTSTATUS    ActualNtStatus = STATUS_SUCCESS;
    THSTATE     *pTHS=pTHStls;

    Assert(NULL!=pTHS);
    Assert(!SampExistsDsTransaction());

    __try
    {
        //
        // Make the Reverse Membership call on the G.C
        //

        dwErr = I_DRSGetMembershipsFindGC(
                    pTHS,
                    NULL,
                    NULL,
                    ARGUMENT_PRESENT(pAttributes) ?
                        DRS_REVMEMB_FLAG_GET_ATTRIBUTES : 0,
                    rgObjNames,
                    cObjNames,
                    pLimitingDomain,
                    OperationType,
                    (DWORD *)&ActualNtStatus,
                    pcDsNames,
                    rpDsNames,
                    pAttributes,
                    pcSidHistory,
                    rgSidHistory,
                    FIND_DC_USE_CACHED_FAILURES | FIND_DC_USE_FORCE_ON_CACHE_FAIL
                    );

        if ((0!=dwErr) && (NT_SUCCESS(ActualNtStatus)))
        {
            //
            // The Failure is an RPC Failure
            // set an appropriate error code
            //

            NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
        }
        else
        {
            NtStatus = ActualNtStatus;
        }
    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {

        //
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        //

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return NtStatus;
}

BOOL
SampAmIGC()
/*++
    Tells SAM wether we are a G.C

--*/
{
    return(gAnchor.fAmGC || gAnchor.fAmVirtualGC);
}








//
// Table of well known accounts (account domain / builtin domain)
// 
// The system will automatically apply the same security descriptor 
// of AdminSDHolder object on each every entry in the following table
// if BOOLEAN fExcludeMembers is TRUE, we will not apply the secure SD
// on members of the groups. Otherwise, include all transitive members 
// of each group.
// 
// 


typedef struct _SAMP_SECURE_ADMIN_TABLE
{
    ULONG   Rid;
    BOOLEAN fExcludeMembers;
} SAMP_SECURE_ADMIN_TABLE, *PSAMP_SECURE_ADMIN_TABLE;


SAMP_SECURE_ADMIN_TABLE BuiltinDomainSecureAdminTable[] = 
{
    { DOMAIN_ALIAS_RID_ADMINS, FALSE },
    { DOMAIN_ALIAS_RID_ACCOUNT_OPS, FALSE },
    { DOMAIN_ALIAS_RID_SYSTEM_OPS, FALSE },
    { DOMAIN_ALIAS_RID_PRINT_OPS, FALSE },
    { DOMAIN_ALIAS_RID_BACKUP_OPS, FALSE },
    { DOMAIN_ALIAS_RID_REPLICATOR, FALSE }
};


SAMP_SECURE_ADMIN_TABLE AccountDomainSecureAdminTable[] = 
{
    { DOMAIN_USER_RID_ADMIN, FALSE },
    { DOMAIN_USER_RID_KRBTGT, FALSE },
    { DOMAIN_GROUP_RID_ADMINS, FALSE },
    { DOMAIN_GROUP_RID_SCHEMA_ADMINS, FALSE },
    { DOMAIN_GROUP_RID_ENTERPRISE_ADMINS, FALSE },
    { DOMAIN_GROUP_RID_CONTROLLERS, TRUE }
};




NTSTATUS    
SampFilterWellKnownAccounts(
    IN THSTATE *pTHS,
    IN SEARCHRES *BuiltinDomainSearchRes,
    IN SEARCHRES *AccountDomainSearchRes,
    OUT ULONG *CountOfBuiltinLocalGroups,
    OUT PDSNAME **BuiltinLocalGroups,
    OUT ULONG *CountOfDomainLocalGroups,
    OUT PDSNAME **DomainLocalGroups,
    OUT ULONG *CountOfDomainGlobalGroups,
    OUT PDSNAME **DomainGlobalGroups,
    OUT ULONG *CountOfDomainUniversalGroups,
    OUT PDSNAME **DomainUniversalGroups,
    OUT ULONG *CountOfDomainUsers,
    OUT PDSNAME **DomainUsers,
    OUT ULONG *CountOfExclusiveGroups,
    OUT PDSNAME **ExclusiveGroups
    )
/*++
Routine Description

    This routines walks through all well known accounts, find out users
    and groups which should be protected using the special ACL, and groups 
    them to following 5 categories:
    
        1. Builtin Domain Local Group
        2. Account Domain Local Group
        3. Account Domain Global Group
        4. Account Domain Universal Group
        5. Account Domain Users 

Parameters:

Return Values:

    STATUS_SUCCESS - succeed. This is the only return code so far.

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    CDSNameSet  BuiltinLocalList;
    CDSNameSet  DomainLocalList;
    CDSNameSet  DomainGlobalList;
    CDSNameSet  DomainUniversalList;
    CDSNameSet  DomainUserList;
    CDSNameSet  ExclusiveGroupList;
    ENTINFLIST  *CurrentEntInf;
    NT4SID      DomainSid;
    ULONG       ObjectRid = 0;
    ULONG       GroupType = 0;
    ULONG       i;
    BOOLEAN     fIgnore = TRUE;


    //
    // init return values
    //

    *CountOfBuiltinLocalGroups = 0;
    *BuiltinLocalGroups = NULL;

    *CountOfDomainLocalGroups = 0;
    *DomainLocalGroups = NULL;

    *CountOfDomainGlobalGroups = 0;
    *DomainGlobalGroups = NULL;

    *CountOfDomainUniversalGroups = 0;
    *DomainUniversalGroups = NULL;

    *CountOfDomainUsers = 0;
    *DomainUsers = NULL;

    *CountOfExclusiveGroups = 0;
    *ExclusiveGroups = NULL;
    //
    // initialize local varibles
    // 

    BuiltinLocalList.SetValueType( RevMembDsName );
    DomainLocalList.SetValueType( RevMembDsName );
    DomainGlobalList.SetValueType( RevMembDsName );
    DomainUniversalList.SetValueType( RevMembDsName );
    DomainUserList.SetValueType( RevMembDsName );
    ExclusiveGroupList.SetValueType( RevMembDsName );


    if (BuiltinDomainSearchRes->count > 0)
    {
        //
        // walk through Builtin Domain well known accounts 
        // 

        for (CurrentEntInf = &(BuiltinDomainSearchRes->FirstEntInf);
             CurrentEntInf != NULL;
             CurrentEntInf = CurrentEntInf->pNextEntInf)
        {

            //
            // get well known account RID
            //

            SampSplitNT4SID(&(CurrentEntInf->Entinf.pName->Sid), 
                            &DomainSid, 
                            &ObjectRid
                            );

            //
            // compare the objectRid against the Builtin Domain table
            // 

            fIgnore = TRUE;
            for (i = 0; i < ARRAY_COUNT(BuiltinDomainSecureAdminTable); i++)
            {
                if (ObjectRid == BuiltinDomainSecureAdminTable[i].Rid)
                {
                    // RID matches, protect this account
                    fIgnore = FALSE;
                    break;
                }
            }


            if ( !fIgnore )
            {
                if (BuiltinDomainSecureAdminTable[i].fExcludeMembers)
                {
                    //
                    // protect this group itself only, (don't apply secure SD
                    // onto any member of this group)
                    // 
                    ExclusiveGroupList.Add( CurrentEntInf->Entinf.pName ); 
                }
                else
                {
                    //
                    // add this account to Builtin LocalGroup List
                    // 
                    BuiltinLocalList.Add( CurrentEntInf->Entinf.pName );
                }
            }
        }
    }


    if (AccountDomainSearchRes->count > 0)
    {
        //
        // Now walk through Account Domain well known accounts 
        // 

        for (CurrentEntInf = &(AccountDomainSearchRes->FirstEntInf);
             CurrentEntInf != NULL;
             CurrentEntInf = CurrentEntInf->pNextEntInf)
        {
            //
            // get well known account RID
            //

            SampSplitNT4SID(&(CurrentEntInf->Entinf.pName->Sid), 
                            &DomainSid, 
                            &ObjectRid
                            );

            //
            // compare the objectRid against secure admin table
            // 

            fIgnore = TRUE;
            for (i = 0; i < ARRAY_COUNT(AccountDomainSecureAdminTable); i++)
            {
                if (ObjectRid == AccountDomainSecureAdminTable[i].Rid)
                {
                    // RID matches, protect this account
                    fIgnore = FALSE;
                    break;
                }
            }


            //
            // get object GroupType, then add it to corresponding List
            // 

            if ( !fIgnore )
            {
                if (AccountDomainSecureAdminTable[i].fExcludeMembers)
                {
                    ExclusiveGroupList.Add( CurrentEntInf->Entinf.pName );
                }
                else
                {
                    if ((1 == CurrentEntInf->Entinf.AttrBlock.attrCount) &&
                        (ATT_GROUP_TYPE == CurrentEntInf->Entinf.AttrBlock.pAttr->attrTyp) &&
                        (1 == CurrentEntInf->Entinf.AttrBlock.pAttr->AttrVal.valCount) &&
                        (sizeof(ULONG) == CurrentEntInf->Entinf.AttrBlock.pAttr->AttrVal.pAVal[0].valLen)
                       )
                    {
                        // this is a group
                        GroupType = *((ULONG *)CurrentEntInf->Entinf.AttrBlock.pAttr->AttrVal.pAVal[0].pVal);

                        if (GroupType & GROUP_TYPE_SECURITY_ENABLED)
                        {
                            if (GroupType & GROUP_TYPE_RESOURCE_GROUP)
                            {
                                DomainLocalList.Add( CurrentEntInf->Entinf.pName );
                            }
                            else if (GroupType & GROUP_TYPE_ACCOUNT_GROUP)
                            {
                                DomainGlobalList.Add( CurrentEntInf->Entinf.pName );
                            }
                            else if (GroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                            {
                                DomainUniversalList.Add( CurrentEntInf->Entinf.pName );
                            }
                        }
                    }
                    else
                    {
                        // this is a user
                        DomainUserList.Add( CurrentEntInf->Entinf.pName );
                    }

                }
            }
        }
    }


    //
    // set return value
    //

    *CountOfBuiltinLocalGroups = BuiltinLocalList.Count();
    if (0 != *CountOfBuiltinLocalGroups)
    {
        *BuiltinLocalGroups = (PDSNAME *)BuiltinLocalList.GetArray();
    }

    *CountOfDomainLocalGroups = DomainLocalList.Count();
    if (0 != *CountOfDomainLocalGroups)
    {
        *DomainLocalGroups = (PDSNAME *)DomainLocalList.GetArray();
    }

    *CountOfDomainGlobalGroups = DomainGlobalList.Count();
    if (0 != *CountOfDomainGlobalGroups)
    {
        *DomainGlobalGroups = (PDSNAME *)DomainGlobalList.GetArray();
    }

    *CountOfDomainUniversalGroups = DomainUniversalList.Count();
    if (0 != *CountOfDomainUniversalGroups)
    {
        *DomainUniversalGroups = (PDSNAME *)DomainUniversalList.GetArray();
    }

    *CountOfDomainUsers = DomainUserList.Count();
    if (0 != *CountOfDomainUsers)
    {
        *DomainUsers = (PDSNAME *)DomainUserList.GetArray();
    }

    *CountOfExclusiveGroups = ExclusiveGroupList.Count();
    if (0 != *CountOfExclusiveGroups)
    {
        *ExclusiveGroups = (PDSNAME *)ExclusiveGroupList.GetArray();
    }

    return( NtStatus );

}


NTSTATUS
SampBuildAdministratorsSet(
    IN THSTATE *pTHS,
    IN ULONG CountOfBuiltinLocalGroups,
    IN PDSNAME *BuiltinLocalGroups,
    IN ULONG CountOfDomainLocalGroups,
    IN PDSNAME *DomainLocalGroups,
    IN ULONG CountOfDomainGlobalGroups,
    IN PDSNAME *DomainGlobalGroups,
    IN ULONG CountOfDomainUniversalGroups,
    IN PDSNAME *DomainUniversalGroups,
    IN DSNAME * EnterpriseAdminsDsName,
    IN DSNAME * SchemaAdminsDsName,
    OUT PULONG  pcCountOfMembers,
    OUT PDSNAME **prpMembers
    )
/*++

    Routine Description

        This routine builds the set of members in all well known groups

    Parameters

        pcCountOfMembers -- The count of members is returned in here
        ppMembers        -- The list of members is returned in here

    Return Values

        STATUS_SUCCESS
        Other Error Codes

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;

    PDSNAME     *pBuiltinLocalGroupsList = NULL;
    PDSNAME     *pDomainGlobalGroupsList = NULL;
    PDSNAME     *pDomainLocalGroupsList = NULL;
    PDSNAME     *pDomainUniversalGroupsList = NULL;
    PDSNAME     *pGcEvaluationList = NULL;
    PDSNAME     *pLocalEvaluationList = NULL;
    PDSNAME     *pFinalLocalEvaluationList = NULL;

    ULONG       cBuiltinLocalGroupsList = 0;
    ULONG       cDomainGlobalGroupsList = 0;
    ULONG       cDomainLocalGroupsList = 0;
    ULONG       cDomainUniversalGroupsList = 0;
    ULONG       cGcEvaluationList = 0;
    ULONG       cLocalEvaluationList =0;
    ULONG       cFinalLocalEvaluationList =0;

    CDSNameSet  GCEvaluationSet;
    CDSNameSet  FinalAdminList;
    ULONG       i=0;

    __try
    {
        //
        // Initialize return values
        //

        *pcCountOfMembers =0;
        *prpMembers = NULL;

        FinalAdminList.SetValueType(RevMembDsName);
        GCEvaluationSet.SetValueType(RevMembDsName);

        //
        // Begin a transaction
        //

        DBOpen(&pTHS->pDB);


        //
        // Evaluate the transitive membership in domain global groups locally
        //

        if ( CountOfDomainGlobalGroups )
        {
            Status = SampGetMemberships(
                            DomainGlobalGroups,
                            CountOfDomainGlobalGroups,
                            NULL,
                            GroupMembersTransitive,
                            &cDomainGlobalGroupsList,
                            &pDomainGlobalGroupsList,
                            NULL,
                            NULL,
                            NULL
                            );

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }
        }

        //
        // Evaluate the transitive membership in domain local groups locally
        //

        if ( CountOfDomainLocalGroups )
        {
            Status = SampGetMemberships(
                            DomainLocalGroups,
                            CountOfDomainLocalGroups,
                            NULL,
                            GroupMembersTransitive,
                            &cDomainLocalGroupsList,
                            &pDomainLocalGroupsList,
                            NULL,
                            NULL,
                            NULL
                            );

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }
        }

        //
        // Evaluate the transitive membership in domain universal groups locally
        //

        if ( CountOfDomainUniversalGroups )
        {
            Status = SampGetMemberships(
                            DomainUniversalGroups,
                            CountOfDomainUniversalGroups,
                            NULL,
                            GroupMembersTransitive,
                            &cDomainUniversalGroupsList,
                            &pDomainUniversalGroupsList,
                            NULL,
                            NULL,
                            NULL
                            );

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }
        }



        //
        // Evaluate the transitive membership in all Builtin Local Group locally
        //

        if ( CountOfBuiltinLocalGroups )
        {
            Status = SampGetMemberships(
                            BuiltinLocalGroups,
                            CountOfBuiltinLocalGroups,
                            NULL,
                            GroupMembersTransitive,
                            &cBuiltinLocalGroupsList,
                            &pBuiltinLocalGroupsList,
                            NULL,
                            NULL,
                            NULL
                            );

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }
        }


        //
        // Commit the transaction but keep the thread state as we prepare to go off machine
        //

        DBClose(pTHS->pDB,TRUE);

        //
        // Evaluate memberships of following sets at G.C. 
        // 
        // 1. account domain local groups
        // 2. members of account domain local groups
        // 3. account domain universal groups  
        // 4. members of account domain universal groups
        // 5. members of builtin local groups
        // 6. enterprise admins and schema admins
        // 
        // Note: Do NOT send 
        //    account domain global groups or  
        //    builtin domain local groups 
        // to G.C.
        //

        // 1. account domain local groups
        for (i = 0; i < CountOfDomainLocalGroups; i++)
        {
            GCEvaluationSet.CheckDuplicateAndAdd( DomainLocalGroups[i] );
        }

        // 2. members of account domain local groups
        for (i = 0; i < cDomainLocalGroupsList; i++)
        {
            GCEvaluationSet.CheckDuplicateAndAdd( pDomainLocalGroupsList[i] );
        }

        // 3. account domain universal groups  
        for (i = 0; i < CountOfDomainUniversalGroups; i++)
        {
            GCEvaluationSet.CheckDuplicateAndAdd( DomainUniversalGroups[i] );
        }

        // 4. members of account domain universal groups
        for (i = 0; i < cDomainUniversalGroupsList; i++)
        {
            GCEvaluationSet.CheckDuplicateAndAdd( pDomainUniversalGroupsList[i] );
        }

        // 5. members of builtin local groups
        for (i = 0; i < cBuiltinLocalGroupsList; i++)
        {
            GCEvaluationSet.CheckDuplicateAndAdd( pBuiltinLocalGroupsList[i] );
        }

        // 6. enterprise admins and schema admins
        GCEvaluationSet.CheckDuplicateAndAdd(EnterpriseAdminsDsName);
        GCEvaluationSet.CheckDuplicateAndAdd(SchemaAdminsDsName);


        cGcEvaluationList = GCEvaluationSet.Count();
        if (0 != cGcEvaluationList)
        {
            pGcEvaluationList = (PDSNAME *) GCEvaluationSet.GetArray();
        }

        Status = SampGetMembershipsFromGC(
                        pGcEvaluationList,
                        cGcEvaluationList,
                        NULL,
                        GroupMembersTransitive,
                        &cLocalEvaluationList,
                        &pLocalEvaluationList,
                        NULL,
                        NULL,
                        NULL
                        );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // Begin Transaction again to process locally
        //

        DBOpen(&pTHS->pDB);

        //
        // Evaluate the results of the above evaluation locally
        //
    
        Status = SampGetMemberships(
                     pLocalEvaluationList,
                     cLocalEvaluationList,
                     NULL,
                     GroupMembersTransitive,
                     &cFinalLocalEvaluationList,
                     &pFinalLocalEvaluationList,
                     NULL,
                     NULL,
                     NULL
                     );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // Compose the final set, by utilizing the CDSNAMESET's check duplicate and add function.
        //
        // 1.  Account Domain Global Groups
        // 2.  Account Domain Local Groups
        // 3.  Account Domain Univesal Groups
        // 4.  members of Account Domain Global Groups
        // 5.  members of Account Domain Local Groups
        // 6.  members of Account Domain Universal Groups
        // 7.  members of Builtin Domain Local Groups
        // 8.  result coming from G.C. evaluation
        // 9.  result of the local evaluation on the GC list 
        // 10. Enterprise / Schema Administrators Groups
        //

        // 
        // 1. Account Domain Global Groups
        // 

        for (i = 0; i < CountOfDomainGlobalGroups; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( DomainGlobalGroups[i] );
        }


        // 
        // 2. Account Domain Local Groups
        // 

        for (i = 0; i < CountOfDomainLocalGroups; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( DomainLocalGroups[i] );
        }


        // 
        // 3. Account Domain Univesal Groups
        // 

        for (i = 0; i < CountOfDomainUniversalGroups; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( DomainUniversalGroups[i] );
        }



        //
        // 4. members of Account Domain Global Groups
        //

        for (i=0; i<cDomainGlobalGroupsList; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( pDomainGlobalGroupsList[i] );
        }

        //
        // 5. members of Account Domain Local Groups
        //

        for (i=0; i<cDomainLocalGroupsList; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( pDomainLocalGroupsList[i] );
        }

        //
        // 6. members of Account Domain Universal Groups
        //

        for (i=0; i<cDomainUniversalGroupsList; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( pDomainUniversalGroupsList[i] );
        }


        //
        // 7. members of Builtin Domain Local Groups
        //

        for (i=0; i<cBuiltinLocalGroupsList; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( pBuiltinLocalGroupsList[i] );
        }

        //
        // Add the set returned from the G.C
        // 8. result coming from G.C. evaluation
        //

        for (i=0; i<cLocalEvaluationList; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( pLocalEvaluationList[i] );
        }

        //
        // Add the locally evaluated set of the set returned from the G.C
        // 9. result of the local evaluation on the GC list 
        //

        for (i=0; i<cFinalLocalEvaluationList; i++)
        {
            FinalAdminList.CheckDuplicateAndAdd( pFinalLocalEvaluationList[i] );
        }


        //
        // 10. Add Enterprise / Schema Administrators Groups
        // 

        FinalAdminList.CheckDuplicateAndAdd(EnterpriseAdminsDsName);
        FinalAdminList.CheckDuplicateAndAdd(SchemaAdminsDsName);

       



        //
        // Get the final list of members
        //

        *pcCountOfMembers = FinalAdminList.Count();
        if (0!=*pcCountOfMembers)
        {
            *prpMembers = (PDSNAME *)FinalAdminList.GetArray();
        }


    }
    __finally
    {
        //
        // Commit the transaction, but keep the thread state
        //

        if (NULL!=pTHS->pDB)
        {        
            DBClose(pTHS->pDB,TRUE);
        }
    }


    return (Status);
    
}












NTSTATUS
SampGetGroupsForToken(
    IN  DSNAME * pObjName,
    IN  ULONG    Flags,
    OUT ULONG    *pcSids,
    OUT PSID     **prpSids
   )
/*++

   Routine Description:

       This functions evaluates the full reverse membership,
       as in a logon. No Open Transactions Must Exist if GC membership
       query is desired. Depending upon circumstances this routine
       may begin a Read Transaction. Caller must be capable of handling
       this. If caller wants control of transaction type and does not
       want to go to the G.C then the caller can open appropriate transaction
       prior to calling this routine.

   Parameters:

       pObjName -- Security Principal Whose Reverse Membership is
                   desired.
       Flags    -- Control the operation of the Routine. Currently
                   defined flags are as follows

                     SAM_GET_MEMBERSHIPS_NO_GC -- If specified this routine
                     will not go to the G.C . All Operations are local.

                     SAM_GET_MEMBERSHIPS_TWO_PHASE -- Does both Phase 1 and Phase 2
                     of Reverse membership Evaluation , as in the construction
                     of a Logon Token for this DC.

       pcSids  -- The count of Sids Returned
       prpSids -- A pointer to an array of pointers to Sids is returned in here.

   Return Values

       STATUS_SUCCESS - On SuccessFul Completion
       STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY - If We could not contact G.C and evaluated locally instead
       STATUS_DS_GC_NOT_AVAILABLE - If we could not find a G.C and could not
                        evaluate locally.


--*/
{
    THSTATE *pTHS=pTHStls;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  fPartialMemberships=FALSE;
    DSNAME *BuiltinDomainObject=NULL;
    PDSNAME * Phase1DsNames=NULL,
            * Phase2DsNames=NULL,
            * Phase3DsNames=NULL,
            * Phase4DsNames=NULL,
            * TempDsNames0=NULL,
            * TempDsNames1=NULL,
            * TempDsNames2=NULL,
            * TempDsNames3=NULL,
            * ReturnedDsNames;
    ULONG    cPhase1DsNames=0,
             cPhase2DsNames=0,
             cPhase3DsNames=0,
             cPhase4DsNames=0,
             cTempDsNames0=0,
             cTempDsNames1=0,
             cTempDsNames2=0,
             cTempDsNames3=0,
             TotalDsNames=0;
    ULONG    cSidHistory1=0,cSidHistory2=0,cSidHistory3=0;
    PSID     *rgSidHistory1=NULL,*rgSidHistory2=NULL,*rgSidHistory3=NULL;
    ULONG    dsErr = 0;
    ULONG    i,j;
    BOOLEAN fMixedDomain = ((Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN)!=0);
    BOOL    fCommit = FALSE;
    ULONG   BuiltinDomainSid[] = {0x101,0x05000000,0x20};
    ULONG   Size;
    AUG_MEMBERSHIPS *pAccountMemberships = NULL;
    AUG_MEMBERSHIPS *pUniversalMemberships = NULL;



    //
    // This macro collects all names into a stack array, that is alloca'd
    // so that this can be passed onto SampGetMemberships for the next phase
    // of logon evaluation.
    //
    #define COLLECT_NAMES(p1,c1,p2,c2,pt,ct)\
    {\
        ct=0;\
        pt = (DSNAME**)THAlloc((c1+c2)*sizeof(PDSNAME));\
        if (pt)\
        {\
            RtlZeroMemory(pt, (c1+c2)*sizeof(PDSNAME));\
            if (c1)\
                RtlCopyMemory(pt+ct,p1,c1*sizeof(PDSNAME));\
            ct+=c1;\
            if (c2)\
                RtlCopyMemory(pt+ct,p2,c2*sizeof(PDSNAME));\
            ct+=c2;\
        }\
    }

    //
    // initialize return value first
    // 
    *prpSids = NULL;
    *pcSids = 0;

    _try
    {
        //
        // This routine assumes an open transaction
        //
        Assert(pTHS->pDB != NULL);
    
        NtStatus = GetAccountAndUniversalMemberships(pTHS,
                                                     Flags,
                                                     NULL,
                                                     NULL,
                                                     1,
                                                     &pObjName,
                                                     FALSE, // not the refresh task
                                                     &pAccountMemberships,
                                                     &pUniversalMemberships);

        if (!NT_SUCCESS(NtStatus)) {
            goto Error;
        }

        // Account memberships should always be returned
        cPhase1DsNames = pAccountMemberships[0].MembershipCount;
        Phase1DsNames = pAccountMemberships[0].Memberships;

        cSidHistory1 = pAccountMemberships[0].SidHistoryCount;
        rgSidHistory1 = pAccountMemberships[0].SidHistory;

        cPhase2DsNames = pUniversalMemberships[0].MembershipCount;
        Phase2DsNames = pUniversalMemberships[0].Memberships;

        cSidHistory2 = pUniversalMemberships[0].SidHistoryCount;
        rgSidHistory2 = pUniversalMemberships[0].SidHistory;

        fPartialMemberships = (pUniversalMemberships[0].Flags & AUG_PARTIAL_MEMBERSHIP_ONLY) ? TRUE : FALSE;

        
        if (Flags & SAM_GET_MEMBERSHIPS_TWO_PHASE)
        {
        
        
            //
            // Two phase flag is specified only by callers within SAM,
            // like ACL conversion or check for sensitive groups, that
            // should not result in a call to the G.C. Therefore a DS
            // transaction should exist at this point in time
            //

            Assert(pTHS->pDB != NULL);

            if (!NT_SUCCESS(NtStatus))
               goto Error;
        
            //
            // Again remember to merge in the base object itself
            // into this.
            //
        
            COLLECT_NAMES(&pObjName,1,Phase1DsNames,cPhase1DsNames,TempDsNames1,cTempDsNames1)
            if (NULL == TempDsNames1)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
            //
            // Combine the reverse memberships from the account and universal
            // group evaluation into one big buffer, containing both. Note the
            // big buffer will not have any duplicates, as one buffer is account
            // groups and the other contains universal groups.
            //
        
            COLLECT_NAMES(
                TempDsNames1,
                cTempDsNames1,
                Phase2DsNames,
                cPhase2DsNames,
                TempDsNames2,
                cTempDsNames2
                );
            if (NULL == TempDsNames2)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
        
            //
            // Get the resource group membership of all these groups.
            //
        
            NtStatus = SampGetMemberships(
                            TempDsNames2,
                            cTempDsNames2,
                            gAnchor.pDomainDN,
                            RevMembGetResourceGroups,
                            &cPhase3DsNames,
                            &Phase3DsNames,
                            NULL,
                            &cSidHistory3,
                            &rgSidHistory3 
                            );
        
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        
        
            //
            // Again collect all the names
            //
        
            COLLECT_NAMES(
                Phase3DsNames,
                cPhase3DsNames,
                TempDsNames2,
                cTempDsNames2,
                TempDsNames3,
                cTempDsNames3
                );
            if (NULL == TempDsNames3)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
        
            //
            // Get the reverse membership in the builtin domain for
            // all the objects that the object is a transitive reverse-
            // member of
            //
        
            Size = DSNameSizeFromLen(0);
            BuiltinDomainObject = (DSNAME*) THAllocEx(pTHS,Size);
            BuiltinDomainObject->structLen = Size;
            BuiltinDomainObject->SidLen = RtlLengthSid(BuiltinDomainSid);
            RtlCopySid(sizeof(BuiltinDomainObject->Sid),
                       (PSID)&BuiltinDomainObject->Sid, 
                       BuiltinDomainSid);
        
            NtStatus = SampGetMemberships(
                            TempDsNames3,
                            cTempDsNames3,
                            BuiltinDomainObject,
                            RevMembGetAliasMembership,
                            &cPhase4DsNames,
                            &Phase4DsNames,
                            NULL,
                            NULL,
                            NULL
                            );
            THFreeEx(pTHS,BuiltinDomainObject);
        
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        
            TotalDsNames = cPhase3DsNames;
            ReturnedDsNames = Phase3DsNames;
        }
        
        TotalDsNames = cPhase1DsNames+cPhase2DsNames+cPhase3DsNames+cPhase4DsNames;
        
        //
        // Alloc Memory for Returning the reverse membership. If TWO_PHASE
        // logon was requested then alloc Max token size amount of memory.
        //
        
        *prpSids = (VOID**)THAllocEx(pTHS,
                     (TotalDsNames + cSidHistory1 + cSidHistory2 + cSidHistory3)
                     * sizeof(PSID)
                     );
        if (NULL==*prpSids)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        
        //
        // Copy In the  SIDS for all the DS Names that we obtained.
        // Note we need not check for duplicates because
        //
        
        *pcSids=0;
        for (i=0;i<cPhase1DsNames;i++)
        {
           Assert(Phase1DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase1DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase1DsNames;
        for (i=0;i<cPhase2DsNames;i++)
        {
           Assert(Phase2DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase2DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase2DsNames;
        for (i=0;i<cPhase3DsNames;i++)
        {
           Assert(Phase3DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase3DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase3DsNames;
        for (i=0;i<cPhase4DsNames;i++)
        {
           Assert(Phase4DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase4DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase4DsNames;
        
        //
        // Merge In the Sid History
        //
    
        for (i=0;i<cSidHistory1;i++)
        {
           (*prpSids)[(*pcSids)++] = rgSidHistory1[i];
        
        }
    
        for (i=0;i<cSidHistory2;i++)
        {
            (*prpSids)[(*pcSids)++] = rgSidHistory2[i];
    
        }
        for (i=0;i<cSidHistory3;i++)
        {
            (*prpSids)[(*pcSids)++] = rgSidHistory3[i];
    
        }

    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The Transaction should be kept open, for further processing
    // by SAM
    //

Error:

    if (TempDsNames0)
    {
        THFreeEx(pTHS, TempDsNames0);
        TempDsNames0 = NULL;
    }
    if (TempDsNames1)
    {
        THFreeEx(pTHS, TempDsNames1);
        TempDsNames1 = NULL;
    }
    if (TempDsNames2)
    {
        THFreeEx(pTHS, TempDsNames2);
        TempDsNames2 = NULL;
    }
    if (TempDsNames3)
    {
        THFreeEx(pTHS, TempDsNames3);
        TempDsNames3 = NULL;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*prpSids)
        {
            THFreeEx(pTHS, *prpSids);
            *prpSids = NULL;
            *pcSids = 0;
        }
    }

    //
    // Return STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY, if we could not contact the G.C and
    // evaluated memberships locally
    //

    if (fPartialMemberships && (NT_SUCCESS(NtStatus)))
        NtStatus = STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY;

    return NtStatus;
}


NTSTATUS
GetAccountMemberships(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    OUT AUG_MEMBERSHIPS* pAccountMemberships
    )
/*++

Routine Description:

    This routine obtains the account group memberships for Users.

Parameters:

    pTHS -- thread state
    
    Flags -- flags for SampGetGroupsForToken
    
    Count -- number of elements in Users
    
    Users -- an array of users in dsname format
    
    ppAccountMemberships -- the account memberships of Users

Return Values

    STATUS_SUCCESS, a resource error otherwise.
    
 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i;
    BOOLEAN fMixedDomain = ((Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN)!=0);

    for (i = 0; (i < Count) && NT_SUCCESS(NtStatus); i++) {

        //
        // Call SampGetMemberships
        //
        NtStatus = SampGetMemberships(
                        &Users[i],
                        1,
                        gAnchor.pDomainDN,
                        fMixedDomain?RevMembGetGroupsForUser:RevMembGetAccountGroups,
                        &pAccountMemberships[i].MembershipCount,
                        &pAccountMemberships[i].Memberships,
                        NULL,
                        &pAccountMemberships[i].SidHistoryCount,
                        &pAccountMemberships[i].SidHistory
                        );


    }

    return NtStatus;
}

NTSTATUS
GetUniversalMembershipsBatching(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc,
    IN  LPWSTR  PreferredGcDomain,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    IN  AUG_MEMBERSHIPS* AccountMemberships,
    OUT AUG_MEMBERSHIPS* UniversalMemberships
    )
/*++

Routine Description:

    This routine gets the universal group memberships for Users by
    calling I_DRSGetMemberships2, which allows for multiple users
    to passed in.

                         
    N.B.  This routine assumes that a GC is passed in.  Support for
    FindGC has not been added.                         

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    STATUS_DS_GC_NOT_AVAILABLE
    
    nt resource errors otherwise.

 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD err;
    DRS_MSG_GETMEMBERSHIPS2_REQ   Req;
    DRS_MSG_GETMEMBERSHIPS2_REPLY Reply;
    ULONG                         ReplyVersion;
    ULONG i;

    memset(&Req, 0, sizeof(Req));
    memset(&Reply, 0, sizeof(Reply));

    Assert(NULL != PreferredGc);
    Assert(NULL != PreferredGcDomain);

    err = I_DRSIsExtSupported(pTHS, PreferredGc, DRS_EXT_GETMEMBERSHIPS2);
    if (err) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Setup the request
    //
    Req.V1.Count = Count;
    Req.V1.Requests = (DRS_MSG_REVMEMB_REQ_V1*) THAllocEx(pTHS, Count * sizeof(*Req.V1.Requests));
    for ( i = 0; i < Count; i++ ) {

        COLLECT_NAMES(&Users[i], 
                      1,
                      AccountMemberships[i].Memberships,
                      AccountMemberships[i].MembershipCount,
                      Req.V1.Requests[i].ppDsNames, 
                      Req.V1.Requests[i].cDsNames)

        Req.V1.Requests[i].dwFlags = 0;
        Req.V1.Requests[i].OperationType = RevMembGetUniversalGroups;
        Req.V1.Requests[i].pLimitingDomain = NULL;

    }

    //
    // Make the call
    //
    err = I_DRSGetMemberships2(pTHS,
                               PreferredGc,
                               PreferredGcDomain,
                               1,
                               &Req,
                               &ReplyVersion,
                               &Reply);

    if (err) {
        // BUGBUG -- Reliability -- more error handling?
        goto Error;
    }
    Assert(ReplyVersion == 1);

    //
    // Unpackage the request
    //
    for ( i = 0; i < Count; i++ ) {
        if (ERROR_SUCCESS == Reply.V1.Replies[i].errCode ) {
            UniversalMemberships[i].MembershipCount = Reply.V1.Replies[i].cDsNames;
            UniversalMemberships[i].Memberships = Reply.V1.Replies[i].ppDsNames;
            UniversalMemberships[i].Attributes = Reply.V1.Replies[i].pAttributes;
            UniversalMemberships[i].SidHistoryCount  = Reply.V1.Replies[i].cSidHistory;
            UniversalMemberships[i].SidHistory = (PSID*)Reply.V1.Replies[i].ppSidHistory;
        } else {
            UniversalMemberships[i].Flags |= AUG_PARTIAL_MEMBERSHIP_ONLY;
        }
    }

Error:

    if (err) {
        for ( i = 0; i < Count; i++) {
            UniversalMemberships[i].Flags |= AUG_PARTIAL_MEMBERSHIP_ONLY;
        }
        NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
    }

    //
    // Free the request
    //
    if (Req.V1.Requests) {
        for (i = 0; i < Count; i++) {
            if (Req.V1.Requests[i].ppDsNames) {
                THFreeEx(pTHS, Req.V1.Requests[i].ppDsNames);
            }
        }
        THFreeEx(pTHS, Req.V1.Requests);
    }

    return NtStatus;
}
    
NTSTATUS
GetUniversalMembershipsSequential(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    OUT AUG_MEMBERSHIPS* pAccountMemberships,
    OUT AUG_MEMBERSHIPS* pUniversalMemberships
    )
/*++

Routine Description:

    This routine gets the universal group memberships 'sequentially' by 
    calling I_DRSGetMemberships for each user individually.

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    STATUS_DS_GC_NOT_AVAILABLE
    
    nt resource errors otherwise.

 --*/
 {
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i;
    DWORD err;
    NTSTATUS ActualNtStatus = STATUS_SUCCESS;
    DSNAME **TempDsNames = NULL;
    ULONG   cTempDsNames = 0;


    Assert(NULL == PreferredGc || NULL != PreferredGcDomain);

    for ( i = 0; i < Count; i++ ) {
    
        // Merge in the user name
        COLLECT_NAMES(&Users[i],
                      1,
                      pAccountMemberships->Memberships,
                      pAccountMemberships->MembershipCount,
                      TempDsNames,
                      cTempDsNames);
        
        //
        // Make the Reverse Membership call on the G.C
        //

        err = I_DRSGetMembershipsFindGC(
                    pTHS,
                    PreferredGc,
                    PreferredGcDomain,
                    0,  // don't get attributes for universal memberships
                    TempDsNames,
                    cTempDsNames,
                    NULL,  // no limiting domain
                    RevMembGetUniversalGroups,
                    (DWORD *)&ActualNtStatus,
                    &pUniversalMemberships[i].MembershipCount,
                    &pUniversalMemberships[i].Memberships,
                    &pUniversalMemberships[i].Attributes,
                    &pUniversalMemberships[i].SidHistoryCount,
                    &pUniversalMemberships[i].SidHistory,
                    FIND_DC_USE_CACHED_FAILURES | FIND_DC_USE_FORCE_ON_CACHE_FAIL
                    );

        if (err && (NT_SUCCESS(ActualNtStatus)))
        {
            //
            // The Failure is an RPC Failure
            // set an appropriate error code
            //

            NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
        }
        else
        {
            NtStatus = ActualNtStatus;
        }
    }
 
    return NtStatus;

}

NTSTATUS
GetUniversalMemberships(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    IN  AUG_MEMBERSHIPS* AccountMemberships,
    OUT AUG_MEMBERSHIPS* UniversalMemberships
    )
/*++

Routine Description:

    This routine obtains the universal group memberships for Users.  If the
    batching method is available (new for Whistler) then it will be used;
    otherwise the downlevel method of making a network per user is used.

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    STATUS_DS_GC_NOT_AVAILABLE
    
    nt resource errors otherwise.

 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOL     fUseSequentialMethod = TRUE;
    ULONG    i;

    //
    // First check if we need to go off machine
    //
    if ((SampAmIGC())||(Flags & SAM_GET_MEMBERSHIPS_NO_GC)) {

        //
        // We are the GC ourselves or have been instructed to not go to the
        // GC. Therefore obtain reverse memberships locally
        //
        for (i = 0; (i < Count) && NT_SUCCESS(NtStatus); i++) {

            DSNAME **TempDsNames = NULL;
            ULONG   cTempDsNames = 0;
        
            // Merge in the user name
            COLLECT_NAMES(&Users[i],
                          1,
                          AccountMemberships->Memberships,
                          AccountMemberships->MembershipCount,
                          TempDsNames,
                          cTempDsNames);


            NtStatus = SampGetMemberships(TempDsNames,
                                          cTempDsNames,
                                          NULL,
                                          RevMembGetUniversalGroups,
                                          &UniversalMemberships[i].MembershipCount,
                                          &UniversalMemberships[i].Memberships,
                                          NULL,
                                          &UniversalMemberships[i].SidHistoryCount,
                                          &UniversalMemberships[i].SidHistory);

            THFreeEx(pTHS, TempDsNames);
        }

        // We are done
        goto Cleanup;
    }

    //
    // We are going off machine -- end the current transaction
    //
    if (Flags & SAM_PRESERVE_DBPOS) {
        //
        // We're being called by DS code that expects to have the same
        // DBPOS when the call completes.
        //
        DBTransOut(pTHS->pDB, TRUE, FALSE);
    } else {
        DBClose(pTHS->pDB, TRUE);
    }

    if (  PreferredGc
      && (Count > 1) ) {

        fUseSequentialMethod = FALSE;

        //
        // GetUniversalMembershipsBatching doesn't support FindGCInfo
        // currently
        //

        //
        // Call into GetUniversalMembershipsBatching
        //
        NtStatus = GetUniversalMembershipsBatching(pTHS,
                                                   Flags,
                                                   PreferredGc,
                                                   PreferredGcDomain,
                                                   Count,
                                                   Users,
                                                   AccountMemberships,
                                                   UniversalMemberships);
        if (STATUS_NOT_SUPPORTED == NtStatus) {
            fUseSequentialMethod = TRUE;
        }
    }

    if (fUseSequentialMethod) {

        //
        // Call into GetUniversalMembershipsSequential
        //
        NtStatus = GetUniversalMembershipsSequential(pTHS,
                                                     Flags,
                                                     PreferredGc,
                                                     PreferredGcDomain,
                                                     Count,
                                                     Users,
                                                     AccountMemberships,
                                                     UniversalMemberships);

    }

    if (Flags & SAM_PRESERVE_DBPOS) {
        //
        // DS code expects to still have an open transaction so open a new one.
        //
        DBTransIn(pTHS->pDB);
    }

Cleanup:

    if ( STATUS_DS_GC_NOT_AVAILABLE == NtStatus ) {
        // Set the partial information
        for (i = 0; i < Count; i++) {
            freeAUGMemberships(pTHS, &UniversalMemberships[i]);
            memset(&UniversalMemberships[i], 0, sizeof(AUG_MEMBERSHIPS));
            UniversalMemberships[i].Flags |= AUG_PARTIAL_MEMBERSHIP_ONLY;
        }
        NtStatus = STATUS_SUCCESS;
    }

    return NtStatus;
}



NTSTATUS
GetAccountAndUniversalMembershipsWorker(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    OUT AUG_MEMBERSHIPS **ppAccountMemberships,
    OUT AUG_MEMBERSHIPS **ppUniversalMemberships
    )
/*++

Routine Description:

    This routine performs the work obtaining the group memberships from the
    local directory as well as remotely for the universal groups if
    necessary.

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories obtained
                          for Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    nt resource errors otherwise.


 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    AUG_MEMBERSHIPS *accountMemberships = NULL;
    AUG_MEMBERSHIPS *universalMemberships = NULL;


    // Allocate the space for the UniversalMemberships
    accountMemberships =   (AUG_MEMBERSHIPS*)THAllocEx(pTHS,
                                                       Count * sizeof(AUG_MEMBERSHIPS));

    universalMemberships = (AUG_MEMBERSHIPS*)THAllocEx(pTHS, 
                                                       Count * sizeof(AUG_MEMBERSHIPS));

    NtStatus = GetAccountMemberships(pTHS,
                                     Flags,
                                     Count,
                                     Users,
                                     accountMemberships);

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }


    if (Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN) {

        //
        // No universal memberships
        //
        Assert(Count == 1);
        universalMemberships[0].MembershipCount = 0;
        universalMemberships[0].SidHistoryCount = 0;

    } else {

        NtStatus = GetUniversalMemberships(pTHS,
                                           Flags,
                                           PreferredGc,
                                           PreferredGcDomain,
                                           Count,
                                           Users,
                                           accountMemberships,
                                           universalMemberships);

    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Return the OUT parameters
    //
    *ppAccountMemberships = accountMemberships;
    *ppUniversalMemberships = universalMemberships;
    accountMemberships = NULL;
    universalMemberships = NULL;

Cleanup:

    if (accountMemberships) {
        freeAUGMemberships(pTHS, accountMemberships);
        THFreeEx(pTHS, accountMemberships);
    }
    if (universalMemberships) {
        freeAUGMemberships(pTHS, universalMemberships);
        THFreeEx(pTHS, universalMemberships);
    }

    return NtStatus;
}


NTSTATUS
GetAccountAndUniversalMemberships(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    IN  BOOL    fRefreshTask,
    OUT AUG_MEMBERSHIPS **ppAccountMemberships OPTIONAL,
    OUT AUG_MEMBERSHIPS **ppUniversalMemberships OPTIONAL
    )
/*++

Routine Description:

    This routine obtains the account and universal memberships of a
    set of users.  It may involve performing a network call to obtain
    the universal memberships, thus any open transaction will be closed.
    If caching is enabled, then values from the cache will be used.

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    RefreshTask -- TRUE if the caller is the group refresh task; FALSE otherwise
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         

Return Values

    STATUS_SUCCESS, 
    
    nt resource errors otherwise.

 --*/    
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i;
    AUG_MEMBERSHIPS *pUniversalMemberships = NULL;
    AUG_MEMBERSHIPS *pAccountMemberships = NULL;
    BOOL fDontUseCache;

    fDontUseCache =  (Flags & SAM_GET_MEMBERSHIPS_NO_GC)
                  || (Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN);


    //
    // Check cache
    //

    if (  !fDontUseCache
       && !fRefreshTask
       && isGroupCachingEnabled()
       && (1 == Count) ) {

        //
        // Currently don't support cases where some users have caches
        // and other's don't.
        //
        NtStatus = GetMembershipsFromCache(Users[0],
                                          &pAccountMemberships,
                                          &pUniversalMemberships);

        if (NT_SUCCESS(NtStatus)) {

            DPRINT1(3, "Cache successful for user %ws\n", Users[0]->StringName);
            // Done
            *ppAccountMemberships = pAccountMemberships;
            *ppUniversalMemberships = pUniversalMemberships;
            return NtStatus;
        } else if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE != NtStatus) {
            DPRINT1(3, "Cache failed for user %ws\n", Users[0]->StringName);
            goto Cleanup;
     }
         //
         // In this case the cache didn't help because of the known error
         // STATUS_DS_NO_ATTRIBUTE_OR_VALUE, continue on to perform
         // the work of getting the memberships
         //           
    }

    //
    // Perform a full group expansion
    //
    NtStatus = GetAccountAndUniversalMembershipsWorker(pTHS,
                                                       Flags,
                                                       PreferredGc,
                                                       PreferredGcDomain,
                                                       Count,
                                                       Users,
                                                       &pAccountMemberships,
                                                       &pUniversalMemberships);

    if ( !fDontUseCache
     &&  isGroupCachingEnabled()
     &&  NT_SUCCESS(NtStatus) ) {

        //
        // Cache the results
        //
        for ( i = 0; i < Count; i++) {

            if (!((pUniversalMemberships)[i].Flags & AUG_PARTIAL_MEMBERSHIP_ONLY)) {

                NTSTATUS IgnoreStatus;

                IgnoreStatus = CacheMemberships(Users[i],
                                              &(pAccountMemberships)[i],
                                              &(pUniversalMemberships)[i]);

                if (NT_SUCCESS(IgnoreStatus)) {
                    DPRINT1(3, "Cache save successful for user %ws\n", Users[i]->StringName);
                } else {

                    DPRINT2(3, "Cache save failed for user %ws (0x%x)\n", Users[i]->StringName,
                            IgnoreStatus);
                }                       
            }
        }
    }

    Cleanup:

    if (NT_SUCCESS(NtStatus)) {
        if (ppAccountMemberships) {
            *ppAccountMemberships = pAccountMemberships;
            pAccountMemberships = NULL;
        }
        if (ppUniversalMemberships) {
            *ppUniversalMemberships = pUniversalMemberships;
            pUniversalMemberships = NULL;
        }
    }

    if (pAccountMemberships) {
        freeAUGMemberships(pTHS, pAccountMemberships);
        THFreeEx(pTHS, pAccountMemberships);
    }

    if (pUniversalMemberships) {
        freeAUGMemberships(pTHS, pUniversalMemberships);
        THFreeEx(pTHS, pUniversalMemberships);
    }

    return NtStatus;

}

} //extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\servinfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       servinfo.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <dsjet.h>		/* for error codes */
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>
#include <filtypes.h>
#include <usn.h>
#include "dsexcept.h"
//#include "attids.h"
#include <dsconfig.h>                   // Definition of mask for visible
                                        // containers

#include <lmcons.h>                     // CNLEN
#include <lsarpc.h>                     // PLSAPR_foo
#include <lmerr.h>
#include <lsaisrv.h>

#include <winldap.h>
#include <dns.h>
#include <ntdsapip.h>

#include <servinfo.h>

#include "debug.h"          // standard debugging header 
#define DEBSUB "SERVEINFO:"              // define the subsystem for debugging


// pause is currently 22 minutes.  Why?  Why not?
#define SERVER_INFO_WRITE_PAUSE (22 * 60)

#include <fileno.h>
#define  FILENO FILENO_SERVINFO

#define LDAPServiceType L"ldap"
#define HostSpnType     L"HOST"
#define GCSpnType       L"GC"
#define ExchangeAbType  L"exchangeAB"
#define KadminSPNType   L"kadmin"
#define KadminInstanceType L"changepw"


PWCHAR  OurServiceClassVals[]={
    LDAPServiceType,
    HostSpnType,
    GCSpnType,
    DRS_IDL_UUID_W,
    ExchangeAbType
};
#define NUM_OURSERVICES (sizeof(OurServiceClassVals)/sizeof(WCHAR *))
ServiceClassArray OurServiceClasses = {
    NUM_OURSERVICES,
    OurServiceClassVals
};


// The HostSPNType isn't removed because that is used for non DC machine accounts
PWCHAR  OurServiceClassValsToRemove[]={
    LDAPServiceType,
    GCSpnType,
    DRS_IDL_UUID_W
};
#define NUM_OURSERVICESTOREMOVE (sizeof(OurServiceClassValsToRemove)/sizeof(WCHAR *))
ServiceClassArray ServicesToRemove = {
    NUM_OURSERVICESTOREMOVE,
    OurServiceClassValsToRemove
};

PWCHAR KerberosServiceClassVals[]={
    KadminSPNType
};
#define NUM_KERBEROSSERVICES (sizeof(KerberosServiceClassVals)/sizeof(WCHAR *))
ServiceClassArray KerberosServiceClasses = {
    NUM_KERBEROSSERVICES,
    KerberosServiceClassVals
};

gulKerberosAccountDNT = INVALIDDNT;
DWORD gfWriteNdncSpns = TRUE;

DWORD
FindKerbAccountDNT (
        THSTATE *pTHS
        );
BOOL
GetDnsRootAliasWorker( 
    THSTATE *pTHS,
    DBPOS *pDB,
    WCHAR * DnsRootAlias,
    WCHAR * RootDnsRootAlias )
/* This function will get the ATT_MS_DS_DNSROOTALIAS attributes from
   the current domain and the root domain crossref object.
   It expects DnsRootAlias and RootDnsRootAlias preallocated, and the
   size of each is DNS_MAX_NAME_BUFFER_LENGTH*/
{

    CLASSCACHE *pCC;
    BOOL rtn = FALSE;
    ULONG i;
    DWORD err;
    BOOL fDomain, fRootDomain;

    SEARCHARG SearchArg;
    SEARCHRES SearchRes;
    FILTER AndFilter,OrFilter,DomainFilter,RootDomainFilter,ObjCategoryFilter;
    ENTINFLIST *pEnf;
    ENTINFSEL sel;
    ATTR attr[2];
    ATTRVAL *pVal;
    
    // default values
    DnsRootAlias[0] = L'\0';
    RootDnsRootAlias[0] = L'\0';

    //initialize SearchArg
    memset(&SearchArg,0,sizeof(SearchArg));
    SearchArg.pObject = gAnchor.pPartitionsDN;
    SearchArg.choice  = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.bOneNC  = TRUE;

    if (err = DBFindDSName(pDB,SearchArg.pObject)) {
               goto cleanup;
    }

    SearchArg.pResObj = CreateResObj(pDB,SearchArg.pObject);

    InitCommarg(&SearchArg.CommArg);

    // we need two attributes only
    memset(&sel,0,sizeof(ENTINFSEL));
    SearchArg.pSelection= &sel;
    sel.attSel = EN_ATTSET_LIST;
    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.AttrTypBlock.attrCount = 2;

    memset(attr,0,sizeof(ATTR)*2);
    sel.AttrTypBlock.pAttr = attr;
    attr[0].attrTyp = ATT_NC_NAME;
    attr[1].attrTyp = ATT_MS_DS_DNSROOTALIAS;

    pCC = SCGetClassById(pTHS, CLASS_CROSS_REF);
    Assert(pCC);

    //set filters "objCategory==CLASS_CROSS_REF && (NC_NAME=pDomainDN || NC_NAME=pRootDomainDN)"
    memset(&AndFilter,0,sizeof(AndFilter));
    AndFilter.choice = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;

    memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
    ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
    ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                     pCC->pDefaultObjCategory->structLen;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                     (BYTE*)(pCC->pDefaultObjCategory);
    
    ObjCategoryFilter.pNextFilter = &OrFilter;

    memset(&OrFilter,0,sizeof(OrFilter));
    OrFilter.choice = FILTER_CHOICE_OR;
    OrFilter.FilterTypes.Or.pFirstFilter = &DomainFilter;

    memset(&DomainFilter,0,sizeof(DomainFilter));
    DomainFilter.choice = FILTER_CHOICE_ITEM;
    DomainFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DomainFilter.FilterTypes.Item.FilTypes.ava.type = ATT_NC_NAME;
    DomainFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = gAnchor.pDomainDN->structLen;
    DomainFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)gAnchor.pDomainDN;

    DomainFilter.pNextFilter = &RootDomainFilter;

    memset(&RootDomainFilter,0,sizeof(RootDomainFilter));
    RootDomainFilter.choice = FILTER_CHOICE_ITEM;
    RootDomainFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    RootDomainFilter.FilterTypes.Item.FilTypes.ava.type = ATT_NC_NAME;
    RootDomainFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = gAnchor.pRootDomainDN->structLen;
    RootDomainFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)gAnchor.pRootDomainDN;


    SearchArg.pFilter = &AndFilter;

    memset(&SearchRes,0,sizeof(SearchRes));

    if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
        goto cleanup;
    }

    if (!SearchRes.count) {
        goto cleanup;
    }

    // for every object in the result
    for (pEnf = &(SearchRes.FirstEntInf); pEnf; pEnf = pEnf->pNextEntInf) {
        
        pVal = NULL;
        fRootDomain = fDomain = FALSE;

        // for every attribute of the object
        for (i=0; i<pEnf->Entinf.AttrBlock.attrCount; i++) {
            
            if (ATT_NC_NAME == pEnf->Entinf.AttrBlock.pAttr[i].attrTyp ) {

                if (NameMatched(gAnchor.pRootDomainDN, (DSNAME*)pEnf->Entinf.AttrBlock.pAttr[i].AttrVal.pAVal->pVal)) {
                    fRootDomain = TRUE;  //root domain NC
                    
                }
                if (NameMatched(gAnchor.pDomainDN, (DSNAME*)pEnf->Entinf.AttrBlock.pAttr[i].AttrVal.pAVal->pVal)) {
                    fDomain = TRUE;     //current domain NC
                }

            }
            else if (ATT_MS_DS_DNSROOTALIAS == pEnf->Entinf.AttrBlock.pAttr[i].attrTyp ) {
                
                pVal = pEnf->Entinf.AttrBlock.pAttr[i].AttrVal.pAVal;

            }
        }

        //root domain NC
        if (fRootDomain && pVal) {
            
            Assert(pVal->valLen<DNS_MAX_NAME_BUFFER_LENGTH*sizeof(WCHAR));

            memcpy( (UCHAR*)RootDnsRootAlias,
                    pVal->pVal,
                    pVal->valLen );
            RootDnsRootAlias[(pVal->valLen)/sizeof(WCHAR)] = 0;

        }

        //current domain NC
        if (fDomain && pVal) {
            
            Assert(pVal->valLen<DNS_MAX_NAME_BUFFER_LENGTH*sizeof(WCHAR));

            memcpy( (UCHAR*)DnsRootAlias,
                    pVal->pVal,
                    pVal->valLen );
            DnsRootAlias[(pVal->valLen)/sizeof(WCHAR)] = 0;
        }
        
        
    }
    

    rtn = TRUE;

cleanup:
    // Since the callers are short-lived, it is probably
    // ok not to clean the mess.

    return rtn;

}


NTSTATUS
GetDnsRootAlias(
    WCHAR *pDnsRootAlias,
    WCHAR *pRootDnsRootAlias )
/* This function will get the ATT_MS_DS_DNSROOTALIAS attributes from
   the current domain and the root domain crossref object.
   It expects DnsRootAlias and RootDnsRootAlias preallocated, and the
   size of each is DNS_MAX_NAME_BUFFER_LENGTH.
   THSTATE will be allocated.  This function is exported to netlogon.*/
{
    THSTATE *pTHS=NULL;
    NTSTATUS ntstatus=STATUS_SUCCESS;

    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    
    pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    if (NULL == pTHS) {
        ntstatus = STATUS_NO_MEMORY;
        return ntstatus;
    }
    pTHS->fDSA = TRUE;
    
    __try{
        DBOpen(&(pTHS->pDB));
        __try{
            ntstatus=GetDnsRootAliasWorker(pTHS,pTHS->pDB, pDnsRootAlias, pRootDnsRootAlias);
        }
        __finally{
             
            //End the transaction.  Faster to commit a read only
            // transaction than abort it - so set commit to TRUE.
            DBClose(pTHS->pDB,TRUE);
            pTHS->pDB = NULL;
        }
    }
    
    __except(GetExceptionData( GetExceptionInformation(),
                               &dwException,
                               &dwEA,
                               &ulErrorCode,
                               &dsid ) ){
        HandleDirExceptions(dwException, ulErrorCode, dsid );
        ntstatus = STATUS_UNSUCCESSFUL;
    }


    if (NULL != pTHS) {
        free_thread_state();
    }

    return ntstatus;
 
}


void
WriteSPNsHelp(
        THSTATE *pTHS,
        ATTCACHE *pAC_SPN,
        ATTRVALBLOCK *pAttrValBlock,
        ServiceClassArray *pClasses,
        BOOL *pfChanged
        )
{
    DWORD i, index;
    DWORD cbBuff = 0, cbActual = 0;
    WCHAR *pBuff = NULL;
    DWORD  cbServiceClass;
    WCHAR  ServiceClass[256];
    USHORT InstancePort;

    // Read the values that are already on the object and locate any that are
    // ours.  If they are ours and are in the list of new attributes to write,
    // remove the value from the list.  If they are ours and are not in the list
    // of new attributes to write, remove them from the object.  Finally, add
    // any remaining values in the list.

    index = 1;
    while(!DBGetAttVal_AC(
            pTHS->pDB,
            index,
            pAC_SPN,
            DBGETATTVAL_fREALLOC,
            cbBuff,
            &cbActual,
            (PUCHAR *)&pBuff)) {
        // Before we use this value, null terminate it in the buffer.
        if((cbActual + sizeof(WCHAR)) <= cbBuff) {
            // There is room to just add a NULL to the buffer
            pBuff[cbActual/sizeof(WCHAR)] = L'\0';
            // We aren't changing the size of the buffer, so cbBuff is already
            // correct. 
        }
        else {
            // Alloc up the buffer to have room for the NULL
            pBuff = THReAllocEx(pTHS, pBuff, cbActual + sizeof(WCHAR));
            pBuff[cbActual/sizeof(WCHAR)] = L'\0';

            // We have made the buffer large, so track the new size.
            cbBuff = cbActual + sizeof(WCHAR);
        }

        // Got an SPN.  Crack it apart.
        cbServiceClass = 256;
        DsCrackSpnW(pBuff,
                    &cbServiceClass, ServiceClass,
                    NULL, 0,
                    NULL, 0,
                    &InstancePort);
        if(cbServiceClass < 256) { // None of our service classes are longer
            BOOL fFound = FALSE;

            for(i=0;i<pClasses->count;i++) {
                if(2 == CompareStringW(
                        DS_DEFAULT_LOCALE,
                        DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                        ServiceClass,
                        cbServiceClass,
                        (WCHAR *)
                        pClasses->Vals[i],
                        wcslen(pClasses->Vals[i]))) {
                    fFound=TRUE;
                }
            }

            if(!fFound) {
                // Nope, not ours. Next value.
                index++;
                continue;
            }

            
            // Yep, it's ours.
            fFound = FALSE;
            
            //  See if it's in the list.
            for(i=0;i<pAttrValBlock->valCount;i++) {
                if(2 == CompareStringW(
                        DS_DEFAULT_LOCALE,
                        DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                        pBuff,
                        (cbActual / sizeof(WCHAR)),
                        (WCHAR *)pAttrValBlock->pAVal[i].pVal,
                        (pAttrValBlock->pAVal[i].valLen / sizeof(WCHAR)))) {
                    // Yep, remove it from the list
                    fFound = TRUE;
                    pAttrValBlock->valCount--;
                    // Next value.
                    index++;
                    if(i == pAttrValBlock->valCount) {
                        break;
                    }

                    // OK to use pAttrValBlock->valCount as opposed to
                    // (pAttrValBlock->valCount -1) because its already
                    // been decremented a moment ago.
                    
                    pAttrValBlock->pAVal[i].pVal =
                        pAttrValBlock->pAVal[pAttrValBlock->valCount].pVal;
                    pAttrValBlock->pAVal[i].valLen =
                        pAttrValBlock->pAVal[pAttrValBlock->valCount].valLen;
                    break;
                }
            }
            
            if(!fFound) {
                *pfChanged = TRUE;
                // Nope, remove it from the object.
                DBRemAttVal_AC(pTHS->pDB, pAC_SPN, cbActual, pBuff);
            }
        }
        else {
            // Not ours.  Next value.
            index++;
        }
    }

    if(pBuff) {
        THFreeEx(pTHS, pBuff);
    }
    
    for(i=0;i<pAttrValBlock->valCount;i++) {
        *pfChanged = TRUE;
        DBAddAttVal_AC(pTHS->pDB,
                       pAC_SPN,
                       pAttrValBlock->pAVal[i].valLen,
                       pAttrValBlock->pAVal[i].pVal); 
    }
}


DWORD
WrappedMakeSpnW(
        THSTATE *pTHS,
        WCHAR   *ServiceClass,
        WCHAR   *ServiceName,
        WCHAR   *InstanceName,
        USHORT  InstancePort,
        WCHAR   *Referrer,
        DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
        WCHAR  **ppszSpn
        )
{
    DWORD cSpnLength=128;
    WCHAR SpnBuff[128];
    DWORD err;

    cSpnLength = 128;
    err = DsMakeSpnW(ServiceClass,
                     ServiceName,
                     InstanceName,
                     InstancePort,
                     Referrer,
                     &cSpnLength,
                     SpnBuff);
    
    if(err && err != ERROR_BUFFER_OVERFLOW) {
        return err;
    }
    
    *ppszSpn = THAllocEx(pTHS, (cSpnLength * sizeof(WCHAR)));
    *pcbSpnLength = cSpnLength * sizeof(WCHAR);
    
    if(err == ERROR_BUFFER_OVERFLOW) {
        err = DsMakeSpnW(ServiceClass,
                         ServiceName,
                         InstanceName,
                         InstancePort,
                         Referrer,
                         &cSpnLength,
                         *ppszSpn);
        if(err) {
            return err;
        }
    }
    else {
        memcpy(*ppszSpn, SpnBuff, *pcbSpnLength);
    }
    Assert(*pcbSpnLength == (sizeof(WCHAR) * (1 + wcslen(*ppszSpn))));
    // Drop the null off.
    *pcbSpnLength -= sizeof(WCHAR);
    return 0;
}

BOOL
GetNetBIOSDomainName(
        THSTATE *pTHS,
        WCHAR **DomainName
        )
{
    CROSS_REF *pDomainCF = NULL;
    COMMARG CommArg;
    DWORD cbActual=0;
    DBPOS * pDBSave = pTHS->pDB;
    ATTCACHE *pAC;
    BOOL ret = TRUE;
    
    *DomainName = NULL;

    pTHS->pDB = NULL;
    pAC=SCGetAttById(pTHS,ATT_NETBIOS_NAME);
    Assert(pAC);

    DBOpen(&(pTHS->pDB));

    __try{
        InitCommarg(&CommArg);
        
        pDomainCF = FindExactCrossRef(gAnchor.pDomainDN, &CommArg);
        
        LooseAssert(pDomainCF, GlobalKnowledgeCommitDelay);

        if (!pDomainCF) {
            ret = FALSE;
            __leave;

        }
        
        if(DBFindDSName(pTHS->pDB, pDomainCF->pObj)){
            ret = FALSE;
            __leave;
           
        }
        
        if(DBGetAttVal_AC( pTHS->pDB,
                           1,
                           pAC,
                           DBGETATTVAL_fREALLOC,
                           0,
                           &cbActual,
                           (PUCHAR *)DomainName)){

            ret = FALSE;
        }else{
            (*DomainName) = THReAllocEx(pTHS,*DomainName,cbActual+sizeof(WCHAR));
        }
        
        
        
    } __finally
    {
        // End the transaction.  Faster to commit a read only
        // transaction than abort it - so set commit to TRUE.
        DBClose(pTHS->pDB,TRUE);
        pTHS->pDB = pDBSave;
        
    }

    return ret;
}
    
void
WriteServerInfo(
    void *  pv,
    void ** ppvNext,
    DWORD * pcSecsUntilNextIteration
    )
/*++
Note: This routine is no longer called at GC promotion and demotion time to
re-write the SPNs that are GC-releated because there aren't any.  If there
are any GC related SPNs in the future, the code to enable is in
mdinidsa.c:UpdateGcAnchorFromDsaOptions().
--*/
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE *pAC_SPN, *pAC_DNSHostName, *pAC_ServerReference;
    ATTCACHE *pAC_osName, *pAC_osServicePack, *pAC_osVersionNumber;
    ATTCACHE *pACs[2];
    WCHAR *pwszOsName = L"Windows Server 2003";

    CROSS_REF *         pCR;
    NCL_ENUMERATOR      nclEnum;
    NAMING_CONTEXT_LIST * pNCL;
    COMMARG CommArg;
    
    WCHAR *NetBIOSMachineName=NULL, *wComputerName=NULL, *hostDnsName=NULL, *pCurrentDnsHostName=NULL;
    WCHAR *domainDnsAlias=NULL, *rootDomainDnsAlias=NULL;

    DWORD cchNetBIOSMachineName = CNLEN+1;
    DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH+1;
    DWORD cchHostDnsName = DNS_MAX_NAME_BUFFER_LENGTH;

    WCHAR   *NetBIOSDomainName;
    
    WCHAR  *domainDnsName=NULL;

    ATTR         *pCurrentAttr = NULL;
    DWORD         cCurrentOut;
    DWORD         i, j;
    ATTRVALBLOCK *pAdditionalDNSHostName = NULL;
    ATTRVALBLOCK *pAdditionalSamAccountName = NULL;

    WCHAR  *pszServerGuid = NULL;
    WCHAR  *pszDomainGuid = NULL;

    WCHAR  *pszGuidBasedDnsName = NULL;

    WCHAR  *pNameString[1];
    PDS_NAME_RESULTW servicename = NULL;
    DWORD   err;
    DWORD   dsid = 0;
   
    WCHAR  *versionNumber=NULL;
    DWORD  cbVersionNumber;

    ATTRVALBLOCK AttrValBlock;
    ATTRVAL      *AttrVal;
    DWORD        AttrIndex;
    DWORD        cAllocated;
    
    ATTRVALBLOCK KerbAttrValBlock;
    ATTRVAL      KerbAttrVal[1];

    DWORD ulKerberosAccountDNT;
    
    BOOL   fSetVersionStuff = FALSE;
    DSNAME *pDN = NULL, *pTempDN=NULL;
    DWORD  len;
    BOOL   fCommit=FALSE,fChanged;
    OSVERSIONINFOW *pVersionInformationW=NULL;

    pTHS->fDSA = TRUE;
    
    __try {

        //allocate some space in thread heap

        if (    NULL == (NetBIOSMachineName=THAlloc((CNLEN+1)*sizeof(WCHAR)))
             || NULL == (wComputerName=THAlloc((MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR)))
             || NULL == (hostDnsName=THAlloc(DNS_MAX_NAME_BUFFER_LENGTH*sizeof(WCHAR)))
             || NULL == (domainDnsAlias=THAlloc((DNS_MAX_NAME_BUFFER_LENGTH+1)*sizeof(WCHAR)))
             || NULL == (rootDomainDnsAlias=THAlloc((DNS_MAX_NAME_BUFFER_LENGTH+1)*sizeof(WCHAR)))
             || NULL == (pVersionInformationW=THAlloc(sizeof(OSVERSIONINFOW)))
             || NULL == (versionNumber = THAlloc(64*sizeof(WCHAR))))
        {
           dsid = DSID(FILENO, __LINE__);
           err = ERROR_NOT_ENOUGH_MEMORY;
           __leave;
        }

        pVersionInformationW->dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
        

        // Calcluate the SPNs

        pAC_SPN=SCGetAttById(pTHS, ATT_SERVICE_PRINCIPAL_NAME);
        pAC_DNSHostName=SCGetAttById(pTHS, ATT_DNS_HOST_NAME);
        pAC_ServerReference=SCGetAttById(pTHS, ATT_SERVER_REFERENCE);;
        pAC_osName=SCGetAttById(pTHS, ATT_OPERATING_SYSTEM);
        pAC_osServicePack=SCGetAttById(pTHS, ATT_OPERATING_SYSTEM_SERVICE_PACK);
        pAC_osVersionNumber=SCGetAttById(pTHS, ATT_OPERATING_SYSTEM_VERSION);
        
        pACs[0]=SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME);
        pACs[1]=SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME);

        if(!pAC_SPN || !pAC_DNSHostName || !pAC_ServerReference ||
           !pAC_osName || !pAC_osServicePack || !pAC_osVersionNumber ||
           !pACs[0] || !pACs[1] ) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        // First, we need the raw data to form the SPNs out of.  We need:
        //
        // 1) DNS of the server (from GetComputerNameEx)
        // 2) DNS of the domain (from DsCrackNames)
        // 3) Name of the computer (from GetComputerNameW, we use it to actually
        //    find the object we're messing with).
        // 4) Guids for the server and domain objects


        if(!GetComputerNameW(&wComputerName[0], &cchComputerName)) {
            dsid = DSID(FILENO, __LINE__);
            err = GetLastError();
            __leave;
        }
 
        // First DNS of the server
        if(!GetComputerNameExW(ComputerNameDnsFullyQualified,
                               hostDnsName,&cchHostDnsName)) {
            dsid = DSID(FILENO, __LINE__);
            err = GetLastError();
            __leave;
        }

        // Strip trailing '.' if it exists so 1) we don't have to register
        // both dot, and dot-less versions, and 2) so we have a consistent
        // story for clients.  Its true that under official DNS rules, 
        // fully qualified DNS names have a '.' on the end, but in practice
        // few programmers adhere to this.  Various DNS-savvy persons have
        // agreed to this.

        if ( L'.' == hostDnsName[cchHostDnsName-1] )
        {
            hostDnsName[cchHostDnsName-1] = L'\0';
            cchHostDnsName--;
        }

        // Now DNS of the domain
        pNameString[0] = (WCHAR *)&(gAnchor.pDomainDN->StringName);

        err = DsCrackNamesW((HANDLE) -1,
                            (DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC |
                             DS_NAME_FLAG_SYNTACTICAL_ONLY),
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            1,
                            pNameString,
                            &servicename);

        if ( err                                // error from the call
            || !(servicename->cItems)            // no items returned
            || (servicename->rItems[0].status)   // DS_NAME_ERROR returned
            || !(servicename->rItems[0].pName)   // No name returned
            ) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        // This is just to improve readability.
        domainDnsName = servicename->rItems[0].pDomain;

        // Assert that we're not dot terminated.
        Assert(L'.' !=
               servicename->rItems[0].pName[wcslen(servicename->rItems[0].pName) - 2]);

        // Stringize some useful GUIDs
        err = UuidToStringW( &(gAnchor.pDSADN->Guid), &pszServerGuid );
        if (err) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        err = UuidToStringW( &(gAnchor.pDomainDN->Guid), &pszDomainGuid );
        if (err) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }


        // Now, the netbios machine name
        if(!GetComputerNameExW(ComputerNameNetBIOS,
                               NetBIOSMachineName,&cchNetBIOSMachineName)) {
            dsid = DSID(FILENO, __LINE__);
            err = GetLastError();
            __leave;
        }

        // THE netbios name of the domain
        if(!GetNetBIOSDomainName(pTHS, &NetBIOSDomainName)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        // Guid-based DNS name
        pszGuidBasedDnsName = TransportAddrFromMtxAddr( gAnchor.pmtxDSA );
        if (!pszGuidBasedDnsName) {
            __leave;
        }

        err = 0;

        DBOpen(&(pTHS->pDB));
        __try{
            
            // Domain DNS Alias and root domain DNS Alias
            if( !GetDnsRootAliasWorker(pTHS, 
                                       pTHS->pDB, 
                                       domainDnsAlias, 
                                       rootDomainDnsAlias )) {
                err = 1;
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
                
            
            // find the computer object of this DC;
            
            if(err = DBFindComputerObj(pTHS->pDB,
                                       cchComputerName,
                                       wComputerName)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            // Additional DNS Host Name
            // & Additional Sam Account Name
            if (err = DBGetMultipleAtts(pTHS->pDB,
                                        2,
                                        pACs,
                                        NULL,
                                        NULL,
                                        &cCurrentOut,
                                        &pCurrentAttr,
                                        DBGETMULTIPLEATTS_fEXTERNAL,
                                        0)) {

                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
        }__finally{
            //End the transaction.  Faster to commit a read only
            // transaction than abort it - so set commit to TRUE.
            DBClose(pTHS->pDB,TRUE);
            pTHS->pDB = NULL;
        }
        
        // error occurs in above __try block, bail
        if (err) {
            __leave;
        }

        // get the additionalDnsHostname and additionalSamAccountName

        for(i=0;i<cCurrentOut;i++) {
            switch(pCurrentAttr[i].attrTyp) {
            
            case ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME:
                // NOTE: not only null terminate, but trim any trailing '$'
                pAdditionalSamAccountName = &pCurrentAttr[i].AttrVal;
                for(j=0;j<pAdditionalSamAccountName->valCount;j++) {
#define PAVAL  (pAdditionalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                    if(PWVAL[CCHVAL - 1] == L'$') {
                        PWVAL[CCHVAL - 1] = 0;
                        PAVAL.valLen -= sizeof(WCHAR);
                    }
                    else {
                        PWVAL = THReAllocEx(pTHS,
                                            PWVAL,
                                            PAVAL.valLen + sizeof(WCHAR));
                    }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
                }
                break;
            
            case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                pAdditionalDNSHostName = &pCurrentAttr[i].AttrVal;
                for(j=0;j<pAdditionalDNSHostName->valCount;j++) {
                    pAdditionalDNSHostName->pAVal[j].pVal =
                        THReAllocEx(pTHS,
                                    pAdditionalDNSHostName->pAVal[j].pVal,
                                    (pAdditionalDNSHostName->pAVal[j].valLen +
                                     sizeof(WCHAR)));
                }

                break;
            
            default:
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
        }

            
        // We've set up some raw data fields to work with.  The following
        // examples assume we're on the machine foo.baz.bar.com in the domain
        // baz.bar.com. There is a parent domain bar.com
        // domainDnsName = the dot delimited domain dns name.
        //                 baz.bar.com
        //
        // hostDnsName   = the dot delimited host dns name.
        //                 foo.baz.bar.com
        //
        // NetBIOSMachineName = the netBIOS name of this machine.
        //
        // NetBIOSDomainName = the netBIOS name of the domain.
        //
        // pszDomainGuid = stringized guid of the domain object, dc=bar,dc=com.
        //
        // pszServerGuid = stringized guid of the host object.
        //
        // pszGuidBasedDnsName = The guid-based name of this machine
        //
        
        // allocate cache for new SPNs
        cAllocated = 64;
        AttrVal = THAllocEx(pTHS,cAllocated*sizeof(ATTRVAL));
        AttrIndex = 0;

#define INC_AttrIndex AttrIndex++;                                                      \
                  if (AttrIndex>=cAllocated) {                                          \
                      cAllocated+=16;                                                   \
                      AttrVal = THReAllocEx(pTHS, AttrVal, cAllocated*sizeof(ATTRVAL)); \
                  }                                                                     \

        
        // Make the first LDAP SPN
        // This is of the format
        //   LDAP/host.dns.name/domain.dns.name
        //
        for (i=0; i<=1; i++) {
            if(err = WrappedMakeSpnW(pTHS,
                                     LDAPServiceType,
                                     (0==i)?domainDnsName:domainDnsAlias,
                                     hostDnsName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                    (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex

            if (pAdditionalDNSHostName) {
                for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                    if(err = WrappedMakeSpnW(pTHS,
                                             LDAPServiceType,
                                             (0==i)?domainDnsName:domainDnsAlias,
                                             (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                             0,
                                             NULL,
                                             &AttrVal[AttrIndex].valLen,
                                            (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                    INC_AttrIndex
                }
            }
            // quit if domain DnsRootAlias is not present
            if (!domainDnsAlias[0]) {
                break;
            }
        }

        // Make the first LDAP SPN (for each NDNC now)
        // This is of the format
        //   LDAP/host.dns.name/ndnc.dns.name
        //

        if (gfWriteNdncSpns) {
            Assert(gAnchor.pConfigDN && gAnchor.pDMD && gAnchor.pDomainDN && gAnchor.pCRL);

            Assert(!DsaIsInstalling()); // fISNDNC() in loop is assuming this.

            NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
            for (pNCL = NCLEnumeratorGetNext(&nclEnum); pNCL != NULL; pNCL = NCLEnumeratorGetNext(&nclEnum)) {

                DPRINT1(2, "Attempting to register NDNC SPNs for NC: %ws\n", pNCL->pNC->StringName);

                ZeroMemory(&CommArg, sizeof(COMMARG));
                pCR = FindExactCrossRef(pNCL->pNC, &CommArg);
                if (!pCR) {
                    // We kind of gloss over errors in this function ... and
                    // not being able to find the cross-ref usually indicates
                    // that this NC is about to be or is being removed by the
                    // KCC.  If this is a temporary cross-ref disappearance, 
                    // we'll pick up and add this NC on our next SPN writing.
                    continue;
                }
                
                if (!fIsNDNCCR(pCR)) {
                    // non-NDNCs are handled elsewhere (above or below this section) ...
                    continue;
                    // FUTURE-2002/05/06-BrettSh We could really merge this loop with the immediately
                    // previous SPN registrations (for gAnchor.pDomainDn, because the data comes 
                    // from the same place.  And then if we cache the CR for gAnchor.pRootDomainDN,
                    // we could remove GetDnsRootAliasWorker altogether if we changed NetLogon to
                    // do the same thing ... can we rely on the CR cache though?  During init? 
                    // Is this ever called during DsaIsInstalling(), I don't think so?  Do for 
                    // Longhorn?  XinHe correctly noted that the cache may not reliable enough for 
                    // NetLogon. NetLogon will call DS immediately after dns-root-alias is changed, 
                    // the cache may not get updated by then.  And NetLogon does not retry when they 
                    // get a failure.  Hopefully, though we'll have a synchronous and reliable cache
                    // by longhorn.
                }
                // Must be an NDNC, lets give it an SPN.

                if(err = WrappedMakeSpnW(pTHS,
                                         LDAPServiceType,
                                         pCR->DnsName,
                                         hostDnsName,
                                         0,
                                         NULL,
                                         &AttrVal[AttrIndex].valLen,
                                        (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex

                if (pCR->DnsAliasName) {
                    if(err = WrappedMakeSpnW(pTHS,
                                             LDAPServiceType,
                                             pCR->DnsAliasName,
                                             hostDnsName,
                                             0,
                                             NULL,
                                             &AttrVal[AttrIndex].valLen,
                                            (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                    INC_AttrIndex
                }

                if (pAdditionalDNSHostName) {
                    for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                        if(err = WrappedMakeSpnW(pTHS,
                                                 LDAPServiceType,
                                                 pCR->DnsName,
                                                 (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                                 0,
                                                 NULL,
                                                 &AttrVal[AttrIndex].valLen,
                                                (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                            dsid = DSID(FILENO, __LINE__);
                            __leave;
                        }
                        INC_AttrIndex

                        if(pCR->DnsAliasName){
                            if(err = WrappedMakeSpnW(pTHS,
                                                     LDAPServiceType,
                                                     pCR->DnsAliasName,
                                                     (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                                     0,
                                                     NULL,
                                                     &AttrVal[AttrIndex].valLen,
                                                    (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                                dsid = DSID(FILENO, __LINE__);
                                __leave;
                            }
                            INC_AttrIndex
                        }
                    }
                }
            } // end for each NC ..
        }

        // Make the second LDAP SPN
        // This is of the format
        //   LDAP/host.dns.name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 hostDnsName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalDNSHostName) {
             for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                          LDAPServiceType,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          0,
                                          NULL,
                                          &AttrVal[AttrIndex].valLen,
                                          (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                        __leave;
                  }
                  INC_AttrIndex
            }
        }


        // Make the third LDAP SPN
        // This is of the format
        //   LDAP/machinename
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 NetBIOSMachineName,
                                 NetBIOSMachineName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalSamAccountName) {
            for (j=0; j<pAdditionalSamAccountName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                          LDAPServiceType,
                                          (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                          (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                          0,
                                          NULL,
                                          &AttrVal[AttrIndex].valLen,
                                          (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex
            }
            
        }


        // Make the fourth LDAP SPN
        // This is of the format
        //   LDAP/host.dns.name/netbiosDoamainName
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 NetBIOSDomainName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex  

        if (pAdditionalDNSHostName) {
            for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                if(err = WrappedMakeSpnW(pTHS,
                                         LDAPServiceType,
                                         NetBIOSDomainName,
                                         (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                         0,
                                         NULL,
                                         &AttrVal[AttrIndex].valLen,
                                        (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex

            }
        }
        
        // Make the fifth LDAP SPN
        // This is of the format
        //   LDAP/guid-based-dns-name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 pszGuidBasedDnsName,
                                 pszGuidBasedDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            __leave;
        }
        INC_AttrIndex


        // Make the DRS RPC SPN (for dc to dc replication)
        // This is of the format
        //   E3514235-4B06-11D1-AB04-00C04FC2DCD2/ntdsa-guid/
        //                      domain.dns.name@domain.dns.name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 DRS_IDL_UUID_W,
                                 domainDnsName,
                                 pszServerGuid,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (domainDnsAlias[0]) {
            if(err = WrappedMakeSpnW(pTHS,
                                     DRS_IDL_UUID_W,
                                     domainDnsAlias,
                                     pszServerGuid,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                     (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex
        }

        // Make the default host SPN
        // This is of the format
        //   HOST/host.dns.name/domain.dns.name
        //
        for (i=0; i<=1; i++) {
            if(err = WrappedMakeSpnW(pTHS,
                                     HostSpnType,
                                     (0==i)?domainDnsName:domainDnsAlias,
                                     hostDnsName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                    (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex

            if (pAdditionalDNSHostName) {
                for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                    if(err = WrappedMakeSpnW(pTHS,
                                             HostSpnType,
                                             (0==i)?domainDnsName:domainDnsAlias,
                                             (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                             0,
                                             NULL,
                                             &AttrVal[AttrIndex].valLen,
                                            (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                    INC_AttrIndex

                }
            }
            if (!domainDnsAlias[0]) {
                break;
            }
        }


        // Make the second host SPN - hostDnsName-only HOST SPN
        // This is of the format
        //   HOST/host.dns.name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 HostSpnType,
                                 hostDnsName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalDNSHostName) {
             for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                          HostSpnType,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          0,
                                          NULL,
                                          &AttrVal[AttrIndex].valLen,
                                          (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                        __leave;
                  }
                  INC_AttrIndex
            }
        }


        // Make the third host SPN - 
        // This is of the format
        //   HOST/machinename
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 HostSpnType,
                                 NetBIOSMachineName,
                                 NetBIOSMachineName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalSamAccountName) {
            for (j=0; j<pAdditionalSamAccountName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                      HostSpnType,
                                      (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                      (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                      0,
                                      NULL,
                                      &AttrVal[AttrIndex].valLen,
                                      (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex
            }
            
        }


        // Make the fourth host SPN - 
        // This is of the format
        //   HOST/host.dns.name/netbiosDomainName
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 HostSpnType,
                                 NetBIOSDomainName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex  

        if (pAdditionalDNSHostName) {
            for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                if(err = WrappedMakeSpnW(pTHS,
                                         HostSpnType,
                                         NetBIOSDomainName,
                                         (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                         0,
                                         NULL,
                                         &AttrVal[AttrIndex].valLen,
                                        (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex

            }
        }
        

        // Make the GC SPN. This is done on all systems, even non-GC.
        // See bug 339634. Jeffparh writes:
        // However, I would assert that always registering the GC SPN is equally secure.
        // I.e., there is no increased security to be had by registering the SPN only
        // if the DC is a GC.  The functional test of whether a machine is a GC is whether
        // it answers on the GC port.  There is nothing preventing an admin of any domain
        // in the forest making his favorite DC a GC (causing the registration of the GC
        // SPN as well as initialization of the GC port), ergo "do I trust this GC" is
        // equivalent to "do I trust this is a DC in my forest that is answering on the GC
        // port."

        // Providing hostDnsName for both ServiceName and InstanceName args
        // results in an SPN of HOST/dot.delimited.dns.host.name form.
        // This is of the format
        //   GC/host.dns.name/root.domain.dns.name
        //
        for (i=0; i<=1; i++) {
            if(err = WrappedMakeSpnW(pTHS,
                                     GCSpnType,
                                     (0==i)?gAnchor.pwszRootDomainDnsName:rootDomainDnsAlias,
                                     hostDnsName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                    (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex       
            
            if (pAdditionalDNSHostName) {
                for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                    if(err = WrappedMakeSpnW(pTHS,
                                             GCSpnType,
                                             (0==i)?gAnchor.pwszRootDomainDnsName:rootDomainDnsAlias,
                                             (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                             0,
                                             NULL,
                                             &AttrVal[AttrIndex].valLen,
                                            (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                    INC_AttrIndex

                }
            }
            // quit if the DnsRootAlias attribute of root domain object is not present
            if (!rootDomainDnsAlias[0]) {
                break;
            }
        }

        //
        // if this computer has Mapi service,
        // publish "exchangeAB/machinename"
        // and "exchangeAB/dnsHostName".
        //

        if (gbLoadMapi) {

            //
            //"exchangeAB/machinename"
            //
            if(err = WrappedMakeSpnW(pTHS,
                                     ExchangeAbType,
                                     NetBIOSMachineName,
                                     NetBIOSMachineName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                     (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex

            if (pAdditionalSamAccountName) {
                for (j=0; j<pAdditionalSamAccountName->valCount; j++) {
                     if(err = WrappedMakeSpnW(pTHS,
                                              ExchangeAbType,
                                              (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                              (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                              0,
                                              NULL,
                                              &AttrVal[AttrIndex].valLen,
                                              (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                     }
                     INC_AttrIndex
                }
            }

            //
            //"exchangeAB/dnsHostName"
            //
            
            if(err = WrappedMakeSpnW(pTHS,
                                     ExchangeAbType,
                                     hostDnsName,
                                     hostDnsName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                     (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex
            
            if (pAdditionalDNSHostName) {
                 for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                     if(err = WrappedMakeSpnW(pTHS,
                                              ExchangeAbType,
                                              (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                              (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                              0,
                                              NULL,
                                              &AttrVal[AttrIndex].valLen,
                                              (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                      }
                      INC_AttrIndex
                }
            }
            
        }  // end  "if (gbLoadMapi) "


#undef INC_AttrIndex

        AttrValBlock.valCount = AttrIndex;
        AttrValBlock.pAVal = AttrVal;

        Assert(AttrIndex <= cAllocated);

        // Make the kerberos account SPNs
        KerbAttrValBlock.pAVal = KerbAttrVal;
        
        // Make the first kadmin SPN -
        // This is of the format
        //    kadmind/changepw
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 KadminSPNType,
                                 KadminInstanceType,
                                 KadminInstanceType,
                                 0,
                                 NULL,
                                 &KerbAttrVal[0].valLen,
                                 (WCHAR **)&KerbAttrVal[0].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        KerbAttrValBlock.valCount = 1;
        
        // We also need the OS information to write on the Computer.
        if(GetVersionExW(pVersionInformationW)) {

            swprintf(versionNumber,L"%d.%d (%d)",
                     pVersionInformationW->dwMajorVersion,
                     pVersionInformationW->dwMinorVersion,
                     pVersionInformationW->dwBuildNumber);
            cbVersionNumber = wcslen(versionNumber) * sizeof(wchar_t);
            fSetVersionStuff = TRUE;
        }

        // Now that we've created the data we need, find some objects and update
        // them
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            // Note: In general, we don't check the return code from the writes
            // we make here.  If some succeed but some fail for some reason, we
            // still want the ones that succeeded, and we will try everything
            // again in a few minutes anyway.
            // We DO check the various DBFind calls, since we can't update
            // anything if we cant find the objects.
            
            // Step 1 is to find the compupter object.
            if(DBFindComputerObj(pTHS->pDB,
                                 cchComputerName,
                                 wComputerName)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }

            // Get the DN of the object, we'll need to write it as an attribute
            // on another object in a minute.
            DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_OBJ_DIST_NAME,
                        0,
                        0,
                        &len,
                        (UCHAR **)&pDN);

            // Now, replace some values there.
            // First, replace the Service_Principal_Name
            fChanged = FALSE;
            WriteSPNsHelp(pTHS,
                          pAC_SPN,
                          &AttrValBlock,
                          &OurServiceClasses,
                          &fChanged);
            
            // Second, replace the OS name.  Reuse the AttrValBlock
            AttrValBlock.valCount = 1;
            AttrVal[0].pVal = (PUCHAR) pwszOsName;
            AttrVal[0].valLen = wcslen(pwszOsName) * sizeof(WCHAR);
            DBReplaceAtt_AC(pTHS->pDB, pAC_osName, &AttrValBlock,
                            (fChanged?NULL:&fChanged));
            
            if(fSetVersionStuff) {
                // Third, service pack info.  Reuse the AttrValBlock
                AttrVal[0].pVal = (PUCHAR)(pVersionInformationW->szCSDVersion);
                AttrVal[0].valLen = wcslen(pVersionInformationW->szCSDVersion)
                    * sizeof(WCHAR);
                if(AttrVal[0].valLen) {
                    // Actually have a value to set.
                    DBReplaceAtt_AC(pTHS->pDB, pAC_osServicePack, &AttrValBlock,
                                    (fChanged?NULL:&fChanged));
                }
                else {
                    // No service pack info.  Make sure the value is empty in
                    // the DB.
                    // Assume that there is a value in the DB.
                    BOOL fHasValues = TRUE;
                    
                    if(!fChanged) {
                        // Nothing has changed yet.  We have to know if the
                        // DBRemAtt call is going to change things.
                        fHasValues =
                            fChanged =
                                DBHasValues_AC(pTHS->pDB, pAC_osServicePack);
                    }
                    if(fHasValues) {
                        // OK, force the attribute to be empty.  DBRemAtt_AC
                        // does nothing if no values are present.
                        DBRemAtt_AC(pTHS->pDB,pAC_osServicePack);
                    }
                }

                // Fourth, version number.  Reuse the AttrValBlock
                AttrVal[0].pVal = (PUCHAR)versionNumber;
                AttrVal[0].valLen = cbVersionNumber;
                DBReplaceAtt_AC(pTHS->pDB, pAC_osVersionNumber, &AttrValBlock,
                                (fChanged?NULL:&fChanged));
            }

            if(fChanged ||!gfDsaWritable) {
                // OK, put these changes into the DB.  We check here for
                // gfDsaWritable so that if the DSA has become non-writable for
                // memory reasons, we will eventually try a write and perhaps
                // notice that the memory constraints have cleared up a little.
                // Thus, we can make ourselves writable again.  The attempted
                // write here is used as a trigger for that case.
                DBRepl(pTHS->pDB, FALSE, 0, NULL, 0);
            }
            else {
                // Nothing actually changed, don't write this to the DB
                DBCancelRec(pTHS->pDB);
            }

            // If the dnshostname on computer object need to be changed, we should 
            // use localModify to update it, because localModify will also
            // change the SPNs accordingly.  Even DS-owned SPNs are already rewritten 
            // above, but those non-DS-owned SPNs are not touched, and need to be
            // updated by localModify.

            AttrVal[0].pVal = (PUCHAR)hostDnsName;
            AttrVal[0].valLen = cchHostDnsName * sizeof(WCHAR);

            err = DBGetAttVal_AC(pTHS->pDB,
                              1,
                              pAC_DNSHostName,
                              0,
                              0,
                              &len,
                              (UCHAR **)&pCurrentDnsHostName);

            if (!err){
                //make sure it is NULL-terminated
                pCurrentDnsHostName = THReAllocEx(pTHS,pCurrentDnsHostName,len+sizeof(WCHAR));
            }
            else if (err !=DB_ERR_NO_VALUE ){
                dsid = DSID(FILENO, __LINE__);
                __leave;
            } 
           
            if ( !DnsNameCompare_W(pCurrentDnsHostName,hostDnsName) ) {
                
                // If the the dnshostname returned by GetComputerNameEx is different 
                // than what is in the current DnsHostName attribute on the computer 
                // object, we should update the attribute.  As a side-effect, the 
                // SPNs will be updated too.
                
                MODIFYARG ModifyArg;
                memset((CHAR*)&ModifyArg,0, sizeof(ModifyArg));
                ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
                ModifyArg.FirstMod.AttrInf.attrTyp = ATT_DNS_HOST_NAME;
                ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
                ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = AttrVal;
                InitCommarg(&(ModifyArg.CommArg));
                ModifyArg.pObject = pDN;
                ModifyArg.count = 1;
    
                ModifyArg.pResObj = CreateResObj(pTHS->pDB, ModifyArg.pObject);
    
                err = LocalModify(pTHS,&ModifyArg);

                if ( err || pTHS->errCode ) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                
                DPRINT2(0, "DnsHostName on the computer object is changed from %ws to %ws.\n",pCurrentDnsHostName, hostDnsName);

            }

            
            // Next object to update is the server object.  We find it by doing
            // some surgery on a DN in the anchor.
            pTempDN = THAllocEx(pTHS,gAnchor.pDSADN->structLen);

            if(TrimDSNameBy(gAnchor.pDSADN, 1, pTempDN)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }

            if(DBFindDSName(pTHS->pDB, pTempDN)) {
                // Huh?
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
                

            // Now, replace some values there.
            // First, replace the DNSHostName.  This is the same value we put on
            // the computer.
            fChanged = FALSE;
            DBReplaceAtt_AC(pTHS->pDB, pAC_DNSHostName, &AttrValBlock,
                            &fChanged);

            // Second, the server reference
            AttrVal[0].valLen = pDN->structLen;
            AttrVal[0].pVal = (PUCHAR)pDN;
            DBReplaceAtt_AC(pTHS->pDB, pAC_ServerReference, &AttrValBlock,
                            (fChanged?NULL:&fChanged));

            if(fChanged || !gfDsaWritable) {
                // OK, put these changes into the DB.  We check here for
                // gfDsaWritable so that if the DSA has become non-writable for
                // memory reasons, we will eventually try a write and perhaps
                // notice that the memory constraints have cleared up a little.
                // Thus, we can make ourselves writable again.  The attempted
                // write here is used as a trigger for that case.
                DBRepl(pTHS->pDB, FALSE, 0, NULL, 0);
            }
            else {
                // Nothing actually changed, don't write this to the DB
                DBCancelRec(pTHS->pDB);
            }

            // Final object to update is the kerberos account object.
            ulKerberosAccountDNT =  FindKerbAccountDNT(pTHS);
            if(ulKerberosAccountDNT != INVALIDDNT &&
               !DBTryToFindDNT(pTHS->pDB, gulKerberosAccountDNT)) {
                
                // Now, replace some values there.
                // First, replace the Service_Principal_Name
                fChanged = FALSE;
                WriteSPNsHelp(pTHS,
                              pAC_SPN,
                              &KerbAttrValBlock,
                              &KerberosServiceClasses,
                              &fChanged);
                
                if(fChanged ||!gfDsaWritable) {
                    // OK, put this change into the DB.  We check here for
                    // gfDsaWritable so that if the DSA has become non-writable
                    // for memory reasons, we will eventually try a write and
                    // perhaps notice that the memory constraints have cleared
                    // up a little. Thus, we can make ourselves writable again.
                    // The attempted write here is used as a trigger for that
                    //case. 
                    DBRepl(pTHS->pDB, FALSE, 0, NULL, 0);
                }
                else {
                    // Nothing actually changed, don't write this to the DB
                    DBCancelRec(pTHS->pDB);
                }
            }
            
            fCommit = TRUE;
        }
        __finally {
            DBClose(pTHS->pDB, fCommit);
        }

    }
    __finally {
        if (servicename) {
            DsFreeNameResultW(servicename);
        }
        if (pszServerGuid) {
            RpcStringFreeW( &pszServerGuid );
        }
        if (pszDomainGuid) {
            RpcStringFreeW( &pszDomainGuid );
        }
        if (pszGuidBasedDnsName) {
            THFreeEx(pTHS, pszGuidBasedDnsName );
        }
        if (pTempDN) {
            THFreeEx(pTHS,pTempDN);
        }

        if (NetBIOSMachineName){
            THFreeEx(pTHS,NetBIOSMachineName);
        }
        if (wComputerName){
            THFreeEx(pTHS, wComputerName);
        }
        if (hostDnsName){
            THFreeEx(pTHS,hostDnsName);
        }
        if (domainDnsAlias)
        {
            THFreeEx(pTHS,domainDnsAlias);
        }
        if (rootDomainDnsAlias){
            THFreeEx(pTHS,rootDomainDnsAlias);
        }

        if (pVersionInformationW){
            THFreeEx(pTHS,pVersionInformationW);
        }

        if (versionNumber) {
            THFreeEx(pTHS,versionNumber);
        }

        if (pCurrentDnsHostName) {
            THFreeEx(pTHS, pCurrentDnsHostName);
        }
             
        
        // reschedule the next server info write
        *ppvNext = pv;
        switch(PtrToUlong(pv)) {
        case SERVINFO_RUN_ONCE:
            *pcSecsUntilNextIteration = TASKQ_DONT_RESCHEDULE;
            break;

        default:
            *pcSecsUntilNextIteration = SERVER_INFO_WRITE_PAUSE;
            break;
        }
    }

    if(!fCommit) {
        // We failed to write what we needed to.  Log an error.
        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_SERVER_INFO_UPDATE_FAILED,
                  szInsertUL((SERVER_INFO_WRITE_PAUSE/60)),
                  szInsertHex(dsid),
                  szInsertUL(err),
                  szInsertWin32Msg(err),
                  NULL, NULL, NULL, NULL );

    }

    return;
}



DWORD
FindKerbAccountDNT (
        THSTATE *pTHS)
// Find the DNT of the kerberos account for the default domain and put it in a
// global variable.  Obviously, don't look it up if we already have it.
// Return whatever the value of the global is after we're done.
{   FILTER                 Filter;
    FILTER                 FilterClause;
    SEARCHARG              SearchArg;
    SEARCHRES             *pSearchRes;
    ENTINFSEL              eiSel;

    if(gulKerberosAccountDNT != INVALIDDNT) {
        return gulKerberosAccountDNT;
    }
    
    // We haven't yet found the kerberos account.  Look for it.
    
    // Issue a search from the default domain.
    // Filter is
    //   (& (samaccountname=krbtgt))
    // Size limit 1.
    // Atts selected = NONE

    // build search argument
    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = gAnchor.pDomainDN;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.bOneNC = TRUE;
    SearchArg.pSelection = &eiSel;
    InitCommarg(&(SearchArg.CommArg));
    SearchArg.CommArg.ulSizeLimit = 1;
    SearchArg.CommArg.Svccntl.localScope = TRUE;
    
    // build filter
    memset (&Filter, 0, sizeof (Filter));
    Filter.pNextFilter = NULL;
    Filter.choice = FILTER_CHOICE_AND;
    Filter.FilterTypes.And.count = 1;
    Filter.FilterTypes.And.pFirstFilter = &FilterClause;
#define KERBEROS_ACCOUNTNAME L"krbtgt"
    memset (&FilterClause, 0, sizeof (Filter));
    FilterClause.pNextFilter = NULL;
    FilterClause.choice = FILTER_CHOICE_ITEM;
    FilterClause.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FilterClause.FilterTypes.Item.FilTypes.ava.type =
        ATT_SAM_ACCOUNT_NAME;
    FilterClause.FilterTypes.Item.FilTypes.ava.Value.valLen =
        sizeof(KERBEROS_ACCOUNTNAME) - sizeof(WCHAR);
    FilterClause.FilterTypes.Item.FilTypes.ava.Value.pVal =
        (PUCHAR) KERBEROS_ACCOUNTNAME;
    
    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_ONLY;
    eiSel.AttrTypBlock.attrCount = 0;
    eiSel.AttrTypBlock.pAttr = NULL;
    
    
    // Search for the kerberos account;
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    SearchBody(pTHS, &SearchArg, pSearchRes,0);
    
    
    if(pSearchRes->count) {
        DBFindDSName(pTHS->pDB,pSearchRes->FirstEntInf.Entinf.pName);
        gulKerberosAccountDNT = pTHS->pDB->DNT;
        
    }
    
    THFreeEx(pTHS, pSearchRes);
        
    return gulKerberosAccountDNT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\scache.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       scache.c
//
//  Abstract:
//
//   Contains Schema Cache and Schema Access Check Functions
//
//----------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <prefix.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>           // HandleMostExceptions

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>
#include "sync.h"

#include <filtypes.h>           // For FILTER_CHOICE_??? and
                                // FI_CHOICE_???
#include <dsconfig.h>
#include "permit.h"

#include "debug.h"          // standard debugging header
#define DEBSUB "SCACHE:"                // define the subsystem for debugging

// DRA headers
#include "drautil.h"

#include <samsrvp.h>

#include "drserr.h"
#include "drasch.h"

#include <sddlp.h>  // for SD conversion

#include <mbstring.h>  // multibyte string comparison in unit test

#include <seopaque.h>
#include <sertlp.h>

#include <fileno.h>
#define  FILENO FILENO_SCACHE

// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x.
//
// If you change schash.c, you must touch scchk.c and scache.c
// so that they get rebuilt.
#include <schash.c>   // for hash function definitions

extern VOID  SampBuildNT4FullSid(NT4SID *DomSid, ULONG Rid, NT4SID *NewSid);

extern BOOL gfRunningAsExe;
extern BOOL gfRunningAsMkdit;

VOID
scTreatDupsAsDefunct(
    IN THSTATE *pTHS
    );

ATTCACHE*   scAddAtt(THSTATE *pTHS,
                     ENTINF *pEI);
CLASSCACHE* scAddClass(THSTATE *pTHS,
                       ENTINF *pEI);
int
scCloseClass(THSTATE *pTHS,
             CLASSCACHE *pCC);

int
scDupString(
    IN THSTATE  *pTHS,
    IN VOID     *pOldStr,
    OUT VOID    **ppNewStr
    );


int
scDupStruct(
    IN THSTATE  *pTHS,
    IN VOID     *pOldMem,
    OUT VOID    **ppNewMem,
    IN  DWORD   nBytes
    );


// Hammer the default SD on cached classes when running as
// dsamain.exe w/security disabled
#if DBG && INCLUDE_UNIT_TESTS
VOID
scDefaultSdForExe(
    IN THSTATE      *pTHS,
    IN CLASSCACHE   *pCC
    );
#define DEFAULT_SD_FOR_EXE(_pTHS_, _pCC_) scDefaultSdForExe(_pTHS_, _pCC_);
#else DBG && INCLUDE_UNIT_TESTS
#define DEFAULT_SD_FOR_EXE(_pTHS_, _pCC_)
#endif DBG && INCLUDE_UNIT_TESTS


int iSCstage;

// Global schema cache pointer
SCHEMAPTR *CurrSchemaPtr=0;
DSTIME lastSchemaUpdateTime;

// for when updating the dirContentRules in the SCHEMAPTR
CRITICAL_SECTION csDitContentRulesUpdate;

// Global from dsamain.c to indicate if this is the first cache load after boot.
// We skip certain things in that case in order to boot faster
extern BOOL gFirstCacheLoadAfterBoot;

// To serialize blocking and async cache updates
CRITICAL_SECTION csSchemaCacheUpdate;

// Global to store thread handle for async schema cache update thread
// Used to dynamically boost its priority during blocking updates, and
// to close the handle when the thread terminates

HANDLE hAsyncSchemaUpdateThread = NULL;

// Global to ignore bad default SDs during schema cache load.
// Set through Heuristics reg key to allow the system to at least boot
// so that any corrupted default SDs can be corrected

ULONG gulIgnoreBadDefaultSD = 0;


// To prevent jet columns from being updated in the middle of a
// JetGetColumnInfo
CRITICAL_SECTION csJetColumnUpdate;

// To access the global gNoOfSchChangeSinceBoot that is loaded
// in the schema cache to keep track of how uptodate the schema cache is
DWORD gNoOfSchChangeSinceBoot = 0;
CRITICAL_SECTION csNoOfSchChangeUpdate;

DWORD gdwRecalcDelayMs = (5*60*1000);  // 5 minutes of milliseconds
DWORD gdwDelayedMemFreeSec = (10*60);   // 10 minutes of seconds

// Maximum no. of retry's on async schema cache update failure
ULONG maxRetry = 4;

// To ensure two threads don't try to build the colId-sorted att list
// for a class. Not catastrophic, but inefficient and causes memory leak
CRITICAL_SECTION csOrderClassCacheAtts;

// Simple helper function used by qsort to sort a list of attcache pointers
// by attrtyp.  Implemented in mdread.c
extern int __cdecl CmpACByAttType(const void * keyval, const void * datum) ;


// Maximum Number of Jet Tables as stored in the registry
DWORD gulMaxTables = 0;


//
// Events fpr signaling Schema Updates
//
HANDLE evSchema;  // Lazy reload
HANDLE evUpdNow;  // reload now
HANDLE evUpdRepl; // synchronize reload and replication threads (SCReplReloadCache())

//
// Data structures for the communication between the schemaUpdate thread
// and SCIndexCreationThread.
//

// The following structure stores an attribute to be indexed
typedef struct _ATTR_TO_INDEX {
    DWORD fIndexMask;               // which index to create
    ATTCACHE *pAC;                  // a copy of the ATTCACHE
    struct _ATTR_TO_INDEX *pNext;   // next item
} ATTR_TO_INDEX;

// The following structure stores one index creation request
typedef struct _INDEX_CREATION_REQUEST {
    ATTR_TO_INDEX * pAttrs;        // Attribute link list
    struct _INDEX_CREATION_REQUEST * pNext; // next request in the list
} INDEX_CREATION_REQUEST;

// Global variables for async index creation

// The list of the index creation request
INDEX_CREATION_REQUEST *gpIndexToCreateList = NULL;

// whether SCIndexCreationThread is running
BOOL gfIndexThreadRunning = FALSE;

// the semaphore for protecting the above variables
CRITICAL_SECTION csIndexCreation;


// define increment attr count for the partial set allocation
#define DEFAULT_PARTIAL_ATTR_COUNT  (10)
#define PARTIAL_ATTR_COUNT_INC      (10)

// Crude stats for debug and perf analysis
SCHEMASTATS_DECLARE;

#if DBG
struct _schemahashstat {
    int idLookups;
    int idTries;
    int colLookups;
    int colTries;
    int mapiLookups;
    int mapiTries;
    int linkLookups;
    int linkTries;
    int classLookups;
    int classTries;
    int nameLookups;
    int nameTries;
    int PropLookups;
    int PropTries;
    int classNameLookups;
    int classNameTries;
    int classPropLookups;
    int classPropTries;
} hashstat;
#endif

DWORD scFillInSchemaInfo(THSTATE *pTHS);

int
ComputeCacheClassTransitiveClosure(BOOL fForce);


//-----------------------------------------------------------------------
//
// Function Name:            scInitWellKnownAttids
//
// Routine Description:
//
//     Not all attribute and class ids (attids and clsids) can be added
//     as #defines in attids.h because the ids are different on every DC
//     they replicate into. So, whenever the schema is loaded, these
//     variable ids for well known attributes and classes are stored in
//     the SCHEMAPTR.
//
// Arguments:
//    None.
//
// Return Value:
//     None.
//
//-----------------------------------------------------------------------
VOID
scInitWellKnownAttids()
{
    THSTATE *pTHS = pTHStls;
    int err = 0;

    // Entry-TTL
    if (err = OidStrToAttrType(pTHS,
                               FALSE,
                               "\\x2B060104018B3A657703",
                               &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId)) {
          DPRINT1(0, "OidStrToAttrType(EntryTTL) Failed in scInitWellKnownAttids %d\n", err);
          ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId = 0;
     }

     // Dynamic-Object
     if (err = OidStrToAttrType(pTHS,
                                FALSE,
                                "\\x2B060104018B3A657702",
                                &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId)) {
           DPRINT1(0, "OidStrToAttrType(DynamicObject) Failed in scInitWellKnownAttids %d\n", err);
           ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId = 0;
      }

     // InetOrgPerson
     if (err = OidStrToAttrType(pTHS,
                                FALSE,
                                "\\x6086480186F842030202",
                                &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->InetOrgPersonId)) {
           DPRINT1(0, "OidStrToAttrType(InetOrgPersonId) Failed in scInitWellKnownAttids %d\n", err);
           ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->InetOrgPersonId = 0;
      }


}

ATTCACHE * __fastcall
SCGetAttByPropGuid(
        THSTATE *pTHS,
        ATTCACHE *ac
        )
/*++

Routine Description:

    Find an attcache that matches the provided attcache's PropGuid

Arguments:
    pTHS   - pointer to current thread state
    ac - supplies PropGuid

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
    register ATTCACHE *nc;
#if DBG
    hashstat.PropLookups++;
#endif
    if (ahcAttSchemaGuid) {
        for (i=SCGuidHash(ac->propGuid, ATTCOUNT);
                  ahcAttSchemaGuid[i]; i=(i+1)%ATTCOUNT)
        {
#if DBG
            hashstat.PropTries++;
#endif
            nc = (ATTCACHE*)ahcAttSchemaGuid[i];
            if (nc != FREE_ENTRY
                && (0 == memcmp(&nc->propGuid,&ac->propGuid,sizeof(GUID)))) {
                return nc;
            }
        }
    }

    return NULL;
}


ATTCACHE * __fastcall
SCGetAttById(
        THSTATE *pTHS,
        ATTRTYP attrid
        )
/*++

Routine Description:

    Find an attcache given its attribute id.

Arguments:
    pTHS   - pointer to current thread state
    attrid - the attribute id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.idLookups++;
    hashstat.idTries++;
#endif


    for (i=SChash(attrid,ATTCOUNT);
         (ahcId[i].pVal
          && (ahcId[i].pVal == FREE_ENTRY
              || ahcId[i].hKey != attrid)); i=(i+1)%ATTCOUNT){
#if DBG
    hashstat.idTries++;
#endif
    }

    // if we didn't find it in the global cache, look in the local thread cache
    //
    if ((ahcId[i].pVal == NULL) && pTHS->pExtSchemaPtr) {
        ATTCACHE **ppACs = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->ppACs;
        DWORD count = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->cUsed;

        for (i=0; i<count; i++) {
            if (ppACs[i]->id == attrid) {
                return ppACs[i];
            }
        }
        return NULL;
    }

    return (ATTCACHE*)ahcId[i].pVal;
}


ATTCACHE * __fastcall
SCGetAttByExtId(
        THSTATE *pTHS,
        ATTRTYP attrid
        )
/*++

Routine Description:

    Find an attcache given its attribute id.

Arguments:
    pTHS   - pointer to current thread state
    attrid - the attribute id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.idLookups++;
    hashstat.idTries++;
#endif


    for (i=SChash(attrid,ATTCOUNT);
         (ahcExtId[i].pVal
          && (ahcExtId[i].pVal == FREE_ENTRY
              || ahcExtId[i].hKey != attrid)); i=(i+1)%ATTCOUNT){
#if DBG
    hashstat.idTries++;
#endif
    }
    return (ATTCACHE*)ahcExtId[i].pVal;
}


ATTRTYP __fastcall
SCAttIntIdToExtId(
        THSTATE *pTHS,
        ATTRTYP IntId
        )
/*++

Routine Description:

    convert internal id into an external id

Arguments:
    pTHS   - pointer to current thread state
    IntId - the internal id to be translated

Return Value:
    tokenized OID if IntId is in the hash. Otherwise, IntId

--*/
{
    ATTCACHE *pAC;
    if (pAC = SCGetAttById(pTHS, IntId)) {
        return pAC->Extid;
    }
    return IntId;
}


ATTRTYP __fastcall
SCAttExtIdToIntId(
        THSTATE *pTHS,
        ATTRTYP ExtId
        )
/*++

Routine Description:

    convert external id into an internal id

Arguments:
    pTHS   - pointer to current thread state
    ExtId - the external id to be translated

Return Value:
    ATTRTYP
    Internal Id if ExtId is in the hash. Otherwise, ExtId

--*/
{
    ATTCACHE *pAC;
    if (pAC = SCGetAttByExtId(pTHS, ExtId)) {
        return pAC->id;
    }
    return ExtId;
}

ATTCACHE * __fastcall
SCGetAttByCol(
        THSTATE *pTHS,
        JET_COLUMNID jcol
        )
/*++

Routine Description:

    Find an attcache given its JET column id.

Arguments:
    pTHS   - pointer to current thread state
    jcol - the jet column id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.colLookups++;
    hashstat.colTries++;
#endif
    for (i=SChash(jcol,ATTCOUNT);
         (ahcCol[i].pVal
          && (ahcCol[i].pVal == FREE_ENTRY
              || ahcCol[i].hKey != jcol)); i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.colTries++;
#endif
    }

    // if we have extended the schema, take a look there too
    // if found it will overide the global schema
    if (pTHS->pExtSchemaPtr) {
        ATTCACHE **ppACs = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->ppACs;
        DWORD count = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->cUsed;
        register ULONG j;

        for (j=0; j<count; j++) {
            if (ppACs[j]->jColid == jcol) {
                return ppACs[j];
            }
        }
    }

    return (ATTCACHE*)ahcCol[i].pVal;
}

ATTCACHE * __fastcall
SCGetAttByMapiId(
        THSTATE *pTHS,
        ULONG ulPropID
        )
/*++

Routine Description:

    Find an attcache given its MAPI property id.

Arguments:
    pTHS   - pointer to current thread state
    ulPropID - the jet column id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.mapiLookups++;
    hashstat.mapiTries++;
#endif
    for (i=SChash(ulPropID,ATTCOUNT);
         (ahcMapi[i].pVal
           && (ahcMapi[i].pVal == FREE_ENTRY
               || ahcMapi[i].hKey != ulPropID)); i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.mapiTries++;
#endif
    }
    return (ATTCACHE*)ahcMapi[i].pVal;
}

ATTCACHE * __fastcall
SCGetAttByLinkId(
        THSTATE *pTHS,
        ULONG ulLinkID
        )
/*++

Routine Description:

    Find an attcache given its Link ID.

Arguments:
    pTHS   - pointer to current thread state
    ulLinkID - the link id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.linkLookups++;
    hashstat.linkTries++;
#endif
    for (i=SChash(ulLinkID,ATTCOUNT);
         (ahcLink[i].pVal
          && (ahcLink[i].pVal == FREE_ENTRY
              || ahcLink[i].hKey != ulLinkID)); i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.linkTries++;
#endif
    }
    return (ATTCACHE*)ahcLink[i].pVal;
}

__inline int
__ascii_tolower(
    IN      const int       c
    )
{
    if (c >= 'A' && c <= 'Z') {
        return c - 'A' + 'a';
    } else {
        return c;
    }
}

__inline int
__ascii_memicmp (
    IN      const void *    pv1,
    IN      const void *    pv2,
    IN      const size_t    cb
    )
{
    const unsigned char*    pb1     = (const unsigned char*)pv1;
    const unsigned char*    pb2     = (const unsigned char*)pv2;
    size_t                  cbRem   = cb;
    int                     i1      = 0;
    int                     i2      = 0;

    while (cbRem--) {
        if (*pb1 == *pb2 ||
            (i1 = __ascii_tolower(*pb1)) == (i2 = __ascii_tolower(*pb2))) {
            pb1++;
            pb2++;
        } else {
            break;
        }
    }

    return i1- i2;
}

ATTCACHE * __fastcall
SCGetAttByName(
        THSTATE *pTHS,
        ULONG ulSize,
        PUCHAR pVal
        )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    pTHS   - pointer to current thread state
    ulSize - the num of chars in the name.
    pVal - the chars in the name

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;

#if DBG
    hashstat.nameLookups++;
    hashstat.nameTries++;
#endif
    // NOTE: memicmp is OK here since ahcName is UTF8, and restricted to ASCII.
    for (i=SCNameHash(ulSize,pVal,ATTCOUNT);
         (ahcName[i].pVal  // this hash spot refers to an object,
          && (ahcName[i].pVal == FREE_ENTRY  // but its a free slot
              || ahcName[i].length != ulSize // or the size is wrong
              || __ascii_memicmp(ahcName[i].value,pVal,ulSize))); // or the value is wrong
         i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.nameTries++;
#endif
    }

    return (ATTCACHE*)ahcName[i].pVal;
}

void
scFreeHashCacheEntry (
        VOID        *pVal,
        ULONG       hKey,
        ULONG       nahc,
        HASHCACHE   *ahc
        )
/*++

Routine Description:

    Remove the first matching entry from a HASHCACHE table

Arguments:
    pVal    - val to match
    hKey    - key to match
    nahc    - size of hash table
    ahc     - hash table

Return Value:
    none.

--*/
{
    DWORD i;

    for (i=SChash(hKey, nahc); ahc[i].pVal; i=(i+1)%nahc) {
        if (ahc[i].pVal == pVal && ahc[i].hKey == hKey) {
            ahc[i].pVal = FREE_ENTRY;
            ahc[i].hKey = 0;
            return;
        }
    }
}


void
scFreeHashGuidEntry (
        VOID    *pVal,
        GUID    hKey,
        ULONG   nahc,
        VOID    **ahc
        )
/*++

Routine Description:

    Remove the first matching entry from a ATTCACHE** hash table

Arguments:
    pVal    - val to match
    hKey    - GUID to match
    nahc    - size of hash table
    ahc     - hash table

Return Value:
    none.

--*/
{
    DWORD i;

    for (i=SCGuidHash(hKey, nahc); ahc[i]; i=(i+1)%nahc) {
        if (ahc[i] == pVal) {
            ahc[i] = FREE_ENTRY;
            return;
        }
    }
}

void
scFreeHashCacheStringEntry (
        VOID            *pVal,
        ULONG           length,
        PUCHAR          value,
        ULONG           nahc,
        HASHCACHESTRING *ahc
        )
/*++

Routine Description:

    Remove the first matching entry from a HASHCACHESTRING table.

Arguments:
    pVal    - val to match
    length  - length to match
    value   - string to match
    nahc    - size of hash table
    ahc     - hash table

Return Value:
    none.

--*/
{
    DWORD i;

    for (i=SCNameHash(length, value, nahc); ahc[i].pVal; i=(i+1)%nahc) {
         // NOTE: memicmp is OK here since ahcName is UTF8, and is
         //       restricted to ASCII
         if (   ahc[i].pVal == pVal
             && ahc[i].value
             && ahc[i].length == length
             && (0 == _memicmp(ahc[i].value, value, length))) {

            ahc[i].pVal = FREE_ENTRY;
            ahc[i].value = NULL;
            ahc[i].length = 0;
            return;
         }
    }
}


#define SC_UNHASH_ALL           0
#define SC_UNHASH_LOST_OID      1
#define SC_UNHASH_LOST_LDN      2
#define SC_UNHASH_LOST_MAPIID   3
#define SC_UNHASH_DEFUNCT       4
void
scUnhashAtt(
        THSTATE     *pTHS,
        ATTCACHE    *pAC,
        DWORD       UnhashType
        )
/*++

Routine Description:

    Remove an attcache from specified hash tables

Arguments:
    pTHS - thread state
    pAC - attribute to be unhased
    UnhashType - Identifies groups of tables

Return Value:
    none.

--*/
{
    DECLARESCHEMAPTR

    // All
    if (UnhashType == SC_UNHASH_ALL) {
        // internal id, column, and linkid
        scFreeHashCacheEntry(pAC, pAC->id, ATTCOUNT, ahcId);
        if (pAC->jColid) {
            scFreeHashCacheEntry(pAC, pAC->jColid, ATTCOUNT, ahcCol);
        }
        if (pAC->ulLinkID) {
            scFreeHashCacheEntry(pAC, pAC->ulLinkID, ATTCOUNT, ahcLink);
        }
    }

    // All or Defunct
    if (UnhashType == SC_UNHASH_ALL
        || UnhashType == SC_UNHASH_DEFUNCT) {
        if (ahcAttSchemaGuid) {
            scFreeHashGuidEntry(pAC, pAC->propGuid, ATTCOUNT, ahcAttSchemaGuid);
        }
    }

    // All or Defunct or lost mapiID
    // defunct attrs don't own their OID, mapiId, LDN, or schemaIdGuid
    // A colliding RDN attribute may lose one or more of OID, mapiID, or LDN

    if (UnhashType == SC_UNHASH_ALL
        || UnhashType == SC_UNHASH_DEFUNCT
        || UnhashType == SC_UNHASH_LOST_MAPIID) {
        if (pAC->ulMapiID) {
            scFreeHashCacheEntry(pAC, pAC->ulMapiID, ATTCOUNT, ahcMapi);
        }
    }

    // All or Defunct or lost LDN
    if (UnhashType == SC_UNHASH_ALL
        || UnhashType == SC_UNHASH_DEFUNCT
        || UnhashType == SC_UNHASH_LOST_LDN) {
        if (pAC->name) {
            scFreeHashCacheStringEntry(pAC, pAC->nameLen, pAC->name, ATTCOUNT, ahcName);
        }
    }

    // All or Defunct or lost OID
    if (UnhashType == SC_UNHASH_ALL
        || UnhashType == SC_UNHASH_DEFUNCT
        || UnhashType == SC_UNHASH_LOST_OID) {
        scFreeHashCacheEntry(pAC, pAC->Extid, ATTCOUNT, ahcExtId);
    }
}


void
scUnhashCls(
        IN THSTATE     *pTHS,
        IN CLASSCACHE  *pCC,
        IN DWORD        UnhashType
        )
/*++

Routine Description:

    Remove a classcache from specified hash tables

Arguments:
    pTHS - thread state
    pAC - attribute to be unhased
    UnhashType - Identifies groups of tables

Return Value:
    none.

--*/
{
    DECLARESCHEMAPTR

    // Remove from hash of all classes
    if (UnhashType == SC_UNHASH_ALL) {
        scFreeHashCacheEntry(pCC, pCC->ClassId, CLSCOUNT, ahcClassAll);
    }

    // A defunct or duplicate classcache loses its name and guid
    // but not its OID. Some class must hold the OID so that
    // replication, rename, and delete work.
    if (UnhashType == SC_UNHASH_ALL || UnhashType == SC_UNHASH_DEFUNCT) {
        if (pCC->name) {
            scFreeHashCacheStringEntry(pCC, pCC->nameLen, pCC->name, CLSCOUNT, ahcClassName);
        }
        if (ahcClsSchemaGuid) {
            scFreeHashGuidEntry(pCC, pCC->propGuid, CLSCOUNT, ahcClsSchemaGuid);
        }
    }

    // Lost the OID. Remove from active hash. Some class must claim
    // the oid even if the "winner" is defunct so that replication,
    // rename, and delete work.
    if (UnhashType == SC_UNHASH_ALL || UnhashType == SC_UNHASH_LOST_OID) {
        scFreeHashCacheEntry(pCC, pCC->ClassId, CLSCOUNT, ahcClass);
    }
}

CLASSCACHE * __fastcall
SCGetClassByPropGuid(
        THSTATE *pTHS,
        CLASSCACHE *cc
        )
/*++

Routine Description:

    Find a classcache that matches the provided classcache's PropGuid

Arguments:
    pTHS   - pointer to current thread state
    cc - supplies PropGuid

Return Value:
    Pointer to CLASSCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
    register CLASSCACHE *nc;
#if DBG
    hashstat.classPropLookups++;
#endif
    if (ahcClsSchemaGuid) {
        for (i=SCGuidHash(cc->propGuid, CLSCOUNT);
                  ahcClsSchemaGuid[i]; i=(i+1)%CLSCOUNT)
        {
#if DBG
            hashstat.classPropTries++;
#endif
            nc = (CLASSCACHE*)ahcClsSchemaGuid[i];
            if (nc != FREE_ENTRY
                && (memcmp(&nc->propGuid,&cc->propGuid,sizeof(GUID))==0)) {
                return nc;
            }
        }
    }

    return NULL;
}

CLASSCACHE * __fastcall
SCGetClassById(
        THSTATE *pTHS,
        ATTRTYP classid
        )
/*++

Routine Description:

    Find a classcache given its class id (governsId).

Arguments:
    pTHS   - pointer to current thread state
    classid - the class id to look up.

Return Value:
    Pointer to CLASSCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.classLookups++;
    hashstat.classTries++;
#endif
    for (i=SChash(classid,CLSCOUNT);
         (ahcClass[i].pVal
          && (ahcClass[i].pVal == FREE_ENTRY
              || ahcClass[i].hKey != classid)); i=(i+1)%CLSCOUNT){
#if DBG
        hashstat.classTries++;
#endif
    }
    return (CLASSCACHE*)ahcClass[i].pVal;
}

CLASSCACHE * __fastcall
SCGetClassByName(
        THSTATE *pTHS,
        ULONG ulSize,
        PUCHAR pVal
        )
/*++

Routine Description:

    Find a classcache given its name.

Arguments:
    pTHS   - pointer to current thread state
    ulSize - the num of chars in the name.
    pVal - the chars in the name

Return Value:
    Pointer to CLASSCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.classNameLookups++;
    hashstat.classNameTries++;
#endif

    // NOTE: memicmp is OK here since ahcClassName is UTF8, and is restricted to
    //       ASCII
    for (i=SCNameHash(ulSize,pVal,CLSCOUNT);
         (ahcClassName[i].pVal          // this hash spot refers to an object,
          && (ahcClassName[i].pVal == FREE_ENTRY
              || ahcClassName[i].length != ulSize    // but the size is wrong
              || __ascii_memicmp(ahcClassName[i].value,pVal,ulSize))); // or value is wrong
         i=(i+1)%CLSCOUNT){
#if DBG
        hashstat.classNameTries++;
#endif
    }


    return (CLASSCACHE*)ahcClassName[i].pVal;
}

void scMemoryPanic(
      ULONG size
      )
/*++
     Wrapper around MemoryPanic (which is a macro wrapping around DoLogEvent,
     but does allocate some locals), so as to not bloat the stack size
     of scCloseClass, which is recursive
--*/
{
    MemoryPanic(size);
}

// Not for general use. Set to 0 in all builds.
//
// Set to 1 for quick and dirty check to make sure schema
// loads aren't leaking memory. Doesn't take into account memory
// freed/alloced outside of scchk.c, scache.c, and oidconv.c.
// Don't enable except in privates. Not stable.
#define _DEBUG_SCHEMA_ALLOC_ 0

#if !INCLUDE_UNIT_TESTS || !_DEBUG_SCHEMA_ALLOC_

//
// The real, shipped versions of the allocation routines.
//
VOID
SCFree(
    IN OUT VOID **ppMem
    )
/*++

Routine Description:

    Free memory allocated with SCCalloc or SCRealloc.

Arguments:
    ppMem - address of address of memory to free

Return Value:

    *ppMem is set to NULL;

--*/
{
    if (*ppMem) {
        free(*ppMem);
        *ppMem = NULL;
    }
}

int
SCReallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    realloc memory. Free with SCFree(). On error, log an event but leave
    *ppMem unaltered.

Arguments:

    ppMem - Address of address of memory to realloc
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of realloced memory. Free with SCFree().
    !0 - do not alter *ppMem and log an event

--*/
{
    PVOID mem;

    if (NULL == (mem = realloc(*ppMem, nBytes))) {
        // log an event
        scMemoryPanic(nBytes);
        return 1;
    }
    *ppMem = mem;
    return 0;
}

int
SCCallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nItems,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    malloc and clear memory. Free with SCFree(). On error, log an event
    and clear *ppMem.

Arguments:

    ppMem - address of address to return memory pointer
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of malloced, cleared memory. Free with SCFree().
    !0 - clear *ppMem and log an event

--*/
{
    if (NULL == (*ppMem = calloc(nItems, nBytes))) {
        // log an event
        scMemoryPanic(nBytes);
        return 1;
    }
    return 0;
}
#endif !INCLUDE_UNIT_TESTS || !_DEBUG_SCHEMA_ALLOC_

int
SCCalloc(
    IN OUT VOID **ppMem,
    IN DWORD    nItems,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    malloc and clear memory. Free with SCFree(). On error, set svc
    error in thread state and clear *ppMem.

Arguments:

    ppMem - address of address to return memory pointer
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of malloced, cleared memory. Free with SCFree().
    !0 - clear *ppMem and set svc error in thread state

--*/
{
    if (SCCallocWrn(ppMem, nItems, nBytes)) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_SCHEMA_ALLOC_FAILED);
    }
    return 0;
}

int
SCRealloc(
    IN OUT VOID **ppMem,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    realloc memory. Free with SCFree(). On error, set svc
    error in thread state but leave *ppMem unaltered.

Arguments:

    ppMem - Address of address of memory to realloc
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of realloced memory. Free with SCFree().
    !0 - do not alter *ppMem and set svc error in thread state

--*/
{
    if (SCReallocWrn(ppMem, nBytes)) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_SCHEMA_ALLOC_FAILED);
    }
    return 0;
}

#if 0
// Some primes to make the hash function work better
//
// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x.
//
// If you change schash.c, you must touch scchk.c and scache.c
// so that they get rebuilt.
DWORD scPrimes[] =
{      1031,      1543,      2053,      2579,      3079,      3593,
       4099,      4621,      5147,      5669,      6247,      6883,
       7177,      8209,      9221,     10243,     11273,     12401,
      13649,     15017,     16519,     18181,     20011,     22013,
      24223,     26647,     29327,     32261,     35491,     39041,
      42953,     47251,     51977,     57179,     62897,     69191,
      76123,     83737,     92111,    101323,    111467,    122651,
     134917,    148411,    163259,    179591,    197551,    217307,
     239053,    262981,    289283,    318229,    350087,    385109,
     423649,    466019,    512621,    563887,    620297,    682327,
     750571,    825637,    908213,    999043,   1098953,   1208849,
    1329761,   1462739,   1609021,   1769927,   1946921,   2141617,
    2355799,   2591389,   2850541,   3135607,   3449179,   3794101,
    4173523,   4590877,   5049977,   5554993,   6110501,   6721553,
    7393733,   8133107,   8946449,   9841099,  10825211,  11907733,
   13098511,  14408363,  15849221,  17434169,  19177589,  21095357,
   23204911,  25525403,  28077947,  30885749,  33974351,  37371821,
   41109041,  45219991,  49741997,  54716197,  60187879,  66206689,
   72827383,  80110139,  88121197,  96933349, 106626721, 117289433,
  129018403, 141920257, 156112291, 171723523, 188895881, 207785489,
  228564079, 251420539, 276562597, 304218881, 334640771, 368104871,
  404915393, 445406947, 489947659, 538942477, 592836773, 652120481,
  717332587, 789065857, 867972481, 954769757,
  0
};
#endif 0

ULONG
scRecommendedHashSize(
    IN ULONG    nExpectedEntries,
    IN ULONG    nSlots
    // IN ULONG    nExtra
    )
/*++

Routine Description:

    Return the number of hash slots to allocate based on the number
    of entries expected.

Arguments:

    nExpectedEntries - Number of total entries the hash table will hold

    nSlots - number of entries the hash table can currently hold

    nExtra - number of extra entries to add to the hash table size
    to prevent excessive hash table resizing when experimenting
    with prime hash table sizes

Return Value:

    Number of slots the hash table needs to effectively handle
    nExptectedEntries plus nExtra.

--*/
{
    DWORD i;

    DWORD PowerOf2;

    // Hash table size is ok if it can hold twice the expected entries
    //
    // Must be < and not <= because nSlots and nExpectedEntries
    // are 0 for the first allocation (or will be if you enable
    // nExtra for prime.
    nExpectedEntries *= 2;
    if (nExpectedEntries < nSlots) {
        return nSlots;
    }

    // Select a power of 2 large enough to hold twice the number of entries
    for (PowerOf2 = 256; PowerOf2 && PowerOf2 < nExpectedEntries; PowerOf2 <<= 1);
    return PowerOf2;

#if 0
// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x.

    // Reduce the frequency of hash table resizing by allocating
    // a few extra slots. This means the hash table will be resized
    // every nExtra/2 entries. A prime number close to this value
    // is then chosen. A prime number is used to improve hash
    // lookup performance

    nSlots = nExpectedEntries + nExtra;
    for (i = 0; scPrimes[i]; ++i) {
        if (scPrimes[i] > nSlots) {
            return scPrimes[i];
        }
    }

    // Wow, that's a lot of schema objects! Simply round the
    // nSlots up to a nExtra boundary and forget the prime number.
    DPRINT1(0, "nSlots == %d; exceeds prime number table!\n", nSlots);
    return (((nSlots + (nExtra - 1)) / nExtra) * nExtra);
#endif 0
}


int
SCResizeAttHash(
    IN THSTATE  *pTHS,
    IN ULONG    nNewEntries
    )
/*++

Routine Description:

    Resize the hash tables for attributes in the schema cache for
    pTHS. If present, the old entries are copied into the newly
    allocated tables before freeing the old tables.

    pTHS->CurrSchemaPtr is assumed to have been recently allocated by
    SCCacheSchemaInit and should NOT be the current global CurrSchemaPtr
    (unless running single-threaded during boot or install).

    The caller must refresh its local pointers, especially those
    declared by DECLARESCHEMAPTR.

Arguments:

    pTHS - thread state pointing at the schema cache to realloc
    nNewEntries - Number of new entries the resized hashes will hold

Return Value:

    0 on success, !0 otherwise.
    The caller should refresh the local pointers, especially those
    declared by DECLARESCHEMAPTR.

--*/
{
    int             err = 0;
    ULONG           nHE, i;
    ULONG           ATTCOUNT;
    ATTCACHE        *pAC;
    SCHEMAPTR       *pSch = pTHS->CurrSchemaPtr;
    // old (current) hash tables
    ULONG           OldATTCOUNT;
    HASHCACHE       *OldahcId;
    HASHCACHE       *OldahcExtId;
    HASHCACHE       *OldahcCol;
    HASHCACHE       *OldahcMapi;
    HASHCACHE       *OldahcLink;
    HASHCACHESTRING *OldahcName;
    ATTCACHE        **OldahcAttSchemaGuid;
    // new hash tables
    HASHCACHE       *ahcId;
    HASHCACHE       *ahcExtId;
    HASHCACHE       *ahcCol;
    HASHCACHE       *ahcMapi;
    HASHCACHE       *ahcLink;
    HASHCACHESTRING *ahcName;
    ATTCACHE        **ahcAttSchemaGuid;

    // Recommended hash size
    OldATTCOUNT = pSch->ATTCOUNT;
    ATTCOUNT = scRecommendedHashSize(nNewEntries + pSch->nAttInDB,
                                     OldATTCOUNT);
                                     // START_ATTCOUNT);

    // No resizing needed; return immediately and avoid cleanup
    if (ATTCOUNT <= OldATTCOUNT) {
        return 0;
    }

    DPRINT5(1, "Resize attr hash from %d (%d in DB) to %d (%d New entries) for %s\n",
            pSch->ATTCOUNT, pSch->nAttInDB, ATTCOUNT, nNewEntries,
            (pTHS->UpdateDITStructure) ? "normal cache load" : "validation cache");

    //
    // ALLOCATE NEW TABLES
    //

    OldahcId = pSch->ahcId;
    OldahcExtId = pSch->ahcExtId;
    OldahcCol = pSch->ahcCol;
    OldahcMapi = pSch->ahcMapi;
    OldahcLink = pSch->ahcLink;
    OldahcName = pSch->ahcName;
    OldahcAttSchemaGuid = pSch->ahcAttSchemaGuid;

    ahcId = NULL;
    ahcExtId = NULL;
    ahcCol = NULL;
    ahcMapi = NULL;
    ahcLink = NULL;
    ahcName = NULL;
    ahcAttSchemaGuid = NULL;


    // Must be running single threaded (Eg, install or boot)
    // or must *not* be using the global, shared schema cache.
    Assert (!DsaIsRunning() || pSch != CurrSchemaPtr || pSch->RefCount == 1);

    // Must have mandatory hash tables
    Assert((OldATTCOUNT == 0)
           || (OldahcId && OldahcExtId && OldahcCol && OldahcMapi && OldahcLink && OldahcName));

    // Allocate new hash tables (including optional table for validation cache)
    if (   SCCalloc(&ahcId, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcExtId, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcCol, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcMapi, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcLink, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcName, ATTCOUNT, sizeof(HASHCACHESTRING))
        || SCCalloc((VOID **)&ahcAttSchemaGuid, ATTCOUNT, sizeof(ATTCACHE **))) {
        err = ERROR_DS_CANT_CACHE_ATT;
        goto cleanup;
    }

    //
    // MOVE EXSTING HASH ENTRIES INTO THE NEW TABLES
    //

    // Just to be safe, take the perf hit and move each of the
    // entries in each of the hash tables instead of moving
    // just the entries pointed to by ahcId.
    for (nHE = 0; nHE < OldATTCOUNT; ++nHE) {

        // id
        pAC = OldahcId[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            for (i=SChash(pAC->id, ATTCOUNT);
                 ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcId[i].hKey = pAC->id;
            ahcId[i].pVal = pAC;
        }

        // Extid
        pAC = OldahcExtId[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            for (i=SChash(pAC->Extid, ATTCOUNT);
                 ahcExtId[i].pVal && (ahcExtId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcExtId[i].hKey = pAC->Extid;
            ahcExtId[i].pVal = pAC;
        }

        // jcolid
        pAC = OldahcCol[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            for (i=SChash(pAC->jColid,ATTCOUNT);
                 ahcCol[i].pVal && (ahcCol[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcCol[i].hKey = pAC->jColid;
            ahcCol[i].pVal = pAC;
        }

        // MapiID
        pAC = OldahcMapi[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            Assert(pAC->ulMapiID);
            for (i=SChash(pAC->ulMapiID, ATTCOUNT);
                 ahcMapi[i].pVal && (ahcMapi[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcMapi[i].hKey = pAC->ulMapiID;
            ahcMapi[i].pVal = pAC;
        }

        // Name
        pAC = OldahcName[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            Assert(pAC->name);
            for (i=SCNameHash(pAC->nameLen, pAC->name, ATTCOUNT);
                        ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcName[i].length = pAC->nameLen;
            ahcName[i].value = pAC->name;
            ahcName[i].pVal = pAC;
        }

        // LinkID
        pAC = OldahcLink[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            Assert(pAC->ulLinkID);
            for (i=SChash(pAC->ulLinkID, ATTCOUNT);
                    ahcLink[i].pVal && (ahcLink[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcLink[i].hKey = pAC->ulLinkID;
            ahcLink[i].pVal = pAC;
        }

        // schema guid (optional)
        if (!pTHS->UpdateDITStructure) {
            pAC = OldahcAttSchemaGuid[nHE];
            if (pAC && pAC != FREE_ENTRY) {
                for (i=SCNameHash(sizeof(GUID), (PUCHAR)&pAC->propGuid, ATTCOUNT);
                    ahcAttSchemaGuid[i]; i=(i+1)%ATTCOUNT) {
                }
                ahcAttSchemaGuid[i] = pAC;
            }
        }
    }

cleanup:
    if (err) {
        // Error: Retain old hash tables; free new hash tables
        SCFree(&ahcId);
        SCFree(&ahcExtId);
        SCFree(&ahcCol);
        SCFree(&ahcMapi);
        SCFree(&ahcLink);
        SCFree(&ahcName);
        SCFree((VOID **)&ahcAttSchemaGuid);
    } else {
        // Assign new hash tables
        pSch->ATTCOUNT          = ATTCOUNT;
        pSch->ahcId             = ahcId;
        pSch->ahcExtId          = ahcExtId;
        pSch->ahcCol            = ahcCol;
        pSch->ahcMapi           = ahcMapi;
        pSch->ahcLink           = ahcLink;
        pSch->ahcName           = ahcName;
        pSch->ahcAttSchemaGuid  = ahcAttSchemaGuid;

        // free old hash tables
        SCFree(&OldahcId);
        SCFree(&OldahcExtId);
        SCFree(&OldahcCol);
        SCFree(&OldahcMapi);
        SCFree(&OldahcLink);
        SCFree(&OldahcName);
        SCFree((VOID **)&OldahcAttSchemaGuid);
    }

    return(err);
}


int
SCResizeClsHash(
    IN THSTATE  *pTHS,
    IN ULONG    nNewEntries
    )
/*++

Routine Description:

    Resize the hash tables for classes in the schema cache for
    pTHS. If present, the old entries are copied into the newly
    allocated tables before freeing the old tables.

    pTHS->CurrSchemaPtr is assumed to have been recently allocated by
    SCCacheSchemaInit and should NOT be the current global CurrSchemaPtr
    (unless running single-threaded during boot or install).

    The caller must refresh its local pointers, especially those
    declared by DECLARESCHEMAPTR.

Arguments:

    pTHS - thread state pointing at the schema cache to realloc
    nNewEntries - Number of new entries the resized hashes will hold

Return Value:

    0 on success, !0 otherwise.
    The caller must refresh its local pointers, especially those
    declared by DECLARESCHEMAPTR.
--*/
{
    int             err = 0;
    ULONG           nHE, i;
    ULONG           CLSCOUNT;
    CLASSCACHE      *pCC;
    SCHEMAPTR       *pSch = pTHS->CurrSchemaPtr;
    // old (current) hash tables
    ULONG           OldCLSCOUNT;
    HASHCACHE       *OldahcClass;
    HASHCACHE       *OldahcClassAll;
    HASHCACHESTRING *OldahcClassName;
    CLASSCACHE      **OldahcClsSchemaGuid;
    // new hash tables
    HASHCACHE       *ahcClass;
    HASHCACHE       *ahcClassAll;
    HASHCACHESTRING *ahcClassName;
    CLASSCACHE      **ahcClsSchemaGuid;

    // Recommended hash size
    OldCLSCOUNT = pSch->CLSCOUNT;
    CLSCOUNT = scRecommendedHashSize(nNewEntries + pSch->nClsInDB,
                                     OldCLSCOUNT);
                                     // START_CLSCOUNT);

    // No resizing needed; return immediately and avoid cleanup
    if (CLSCOUNT <= OldCLSCOUNT) {
        return 0;
    }

    //
    // ALLOCATE THE NEW TABLES
    //
    DPRINT5(1, "Resize class hash from %d (%d in DB) to %d (%d New entries) for %s\n",
            pSch->CLSCOUNT, pSch->nClsInDB, CLSCOUNT, nNewEntries,
            (pTHS->UpdateDITStructure) ? "normal cache load" : "validation cache");

    OldahcClass = pSch->ahcClass;
    OldahcClassAll = pSch->ahcClassAll;
    OldahcClassName = pSch->ahcClassName;
    OldahcClsSchemaGuid = pSch->ahcClsSchemaGuid;

    ahcClass = NULL;
    ahcClassAll = NULL;
    ahcClassName = NULL;
    ahcClsSchemaGuid = NULL;

    // Must be running single threaded (Eg, install or boot)
    // or must *not* be using the global, shared schema cache.
    Assert (!DsaIsRunning() || pSch != CurrSchemaPtr || pSch->RefCount == 1);

    // Must have mandatory hash tables
    Assert((OldCLSCOUNT == 0)
           || (OldahcClass && OldahcClassName && OldahcClassAll));

    // Allocate new hash tables (including optional table for validation cache)
    if (   SCCalloc(&ahcClass, CLSCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcClassAll, CLSCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcClassName, CLSCOUNT, sizeof(HASHCACHESTRING))
        || SCCalloc((VOID **)&ahcClsSchemaGuid, CLSCOUNT, sizeof(CLASSCACHE **))) {
        err = ERROR_DS_CANT_CACHE_CLASS;
        goto cleanup;
    }

    //
    // MOVE EXSTING HASH ENTRIES INTO THE NEW TABLES
    //

    // Just to be safe, take the perf hit and move each of the
    // entries in each of the hash tables instead of moving
    // just the entries pointed to by ahcClassAll.
    for (nHE = 0; nHE < OldCLSCOUNT; ++nHE) {

        // Class
        pCC = OldahcClass[nHE].pVal;
        if (pCC && pCC != FREE_ENTRY) {
            for (i=SChash(pCC->ClassId, CLSCOUNT);
                 ahcClass[i].pVal && (ahcClass[i].pVal != FREE_ENTRY); i=(i+1)%CLSCOUNT) {
            }
            ahcClass[i].hKey = pCC->ClassId;
            ahcClass[i].pVal = pCC;
        }

        // ClassAll
        pCC = OldahcClassAll[nHE].pVal;
        if (pCC && pCC != FREE_ENTRY) {
            for (i=SChash(pCC->ClassId, CLSCOUNT);
                 ahcClassAll[i].pVal && (ahcClassAll[i].pVal != FREE_ENTRY); i=(i+1)%CLSCOUNT) {
            }
            ahcClassAll[i].hKey = pCC->ClassId;
            ahcClassAll[i].pVal = pCC;
        }

        // Name
        pCC = OldahcClassName[nHE].pVal;
        if (pCC && pCC != FREE_ENTRY) {
            Assert(pCC->name);
            for (i=SCNameHash(pCC->nameLen, pCC->name, CLSCOUNT);
                 ahcClassName[i].pVal && (ahcClassName[i].pVal!= FREE_ENTRY); i=(i+1)%CLSCOUNT) {
            }
            ahcClassName[i].length = pCC->nameLen;
            ahcClassName[i].value = pCC->name;
            ahcClassName[i].pVal = pCC;
        }

        // schema guid, the only usage for this cache is for the
        // the SchemaGuidCrackNames() API(cracknam.c).
        pCC = OldahcClsSchemaGuid[nHE];
        if (pCC && pCC != FREE_ENTRY) {
            for (i=SCNameHash(sizeof(GUID), (PCHAR)&pCC->propGuid, CLSCOUNT);
                 ahcClsSchemaGuid[i]; i=(i+1)%CLSCOUNT) {
            }
            ahcClsSchemaGuid[i] = pCC;
        }
        
    }

cleanup:
    if (err) {
        // Error: Retain old hash tables; free new hash tables
        SCFree(&ahcClass);
        SCFree(&ahcClassAll);
        SCFree(&ahcClassName);
        SCFree((VOID **)&ahcClsSchemaGuid);
    } else {
        // Assign new hash tables
        pSch->CLSCOUNT          = CLSCOUNT;
        pSch->ahcClass          = ahcClass;
        pSch->ahcClassAll       = ahcClassAll;
        pSch->ahcClassName      = ahcClassName;
        pSch->ahcClsSchemaGuid  = ahcClsSchemaGuid;

        // free old hash tables
        SCFree(&OldahcClass);
        SCFree(&OldahcClassAll);
        SCFree(&OldahcClassName);
        SCFree((VOID **)&OldahcClsSchemaGuid);
    }

    return(err);
}


int
SCCacheSchemaInit (
    VOID
    )
/*++

Routine Description:

    Scan the jet columns and pre-load the attribute hash tables with
    just enough info to allow searching the schemaNC (aka DMD).

    The ATTCACHE entries in the attribute hash tables are only
    partially filled in (id, syntax, and colid) and are in just
    the id and col hash tables. But this is enough info to allow
    searching the schemaNC. SCCacheSchema2 is responsible for
    searching the schemaNC and filling in the rest of the info
    in the ATTCACHE entries.

    If this isn't the first schema cache load at boot, then
    SCCacheSchema3 will delete the indexes and columns for attributes
    that don't have corresponding entries in the schemaNC and will
    add missing indexes and columns for attributes in the schemaNC.
    The expensive index creation is delayed until the second
    cache load after boot (approximately 5 minutes after boot)
    so that the AD comes online more quickly and isn't delayed
    for what could be hours.

    Sideeffects:
    1) A new schemaptr is allocated and assigned to pTHS->CurrSchemaPtr.

    2) During the first cache load the global schema pointer,
    CurrSchemaPtr, is set. This code assumes that during boot the
    DSA runs single threaded. Hence CurrSchemaPtr has only some
    info filled in until after the call to SCCacheSchema2. But
    its enough to search the schemaNC.

    3) All of the hash tables and the prefix table are allocated.
    The prefix table is initialized with the hardcoded prefixs
    in MSPrefixTable.

    Suggested Enhancements
    1) DECLARESCHEMAPTR consumes more stack than is needed in most functions.
       Just declare by hand. Fix declaration so casting not needed for
       pTHS->currSchemaPtr.

    2) Write SCMalloc to avoid memset when alloc followed by memcpy.

Arguments:

    None.

Return Value:

    !0 - failed; caller is responsible for freeing pTHS->CurrSchemaPtr
    with SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

    0 - Okay

--*/
{
    THSTATE *pTHS=pTHStls;
    JET_ERR je;
    JET_SESID jsid;
    JET_DBID jdbid;
    JET_TABLEID jtid;
    JET_COLUMNLIST jcl;
    JET_RETRIEVECOLUMN ajrc[2];
    char achColName[50];
    JET_COLUMNID jci;
    ATTCACHE *pac;
    ATTRTYP aid;
    ULONG i, times;
    ULONG err;
    ULONG colCount;
    HASHCACHE *ahcId;
    HASHCACHE *ahcCol;
    SCHEMAPTR *pSch;
    ULONG CLSCOUNT;
    ULONG ATTCOUNT;
    ULONG PREFIXCOUNT;

    // New schema struct for this thread

    if (SCCalloc(&pTHS->CurrSchemaPtr, 1, sizeof(SCHEMAPTR))) {
        return ERROR_DS_CANT_CACHE_ATT;
    }
    pSch = pTHS->CurrSchemaPtr;

    // Initial hash table sizes
    if (CurrSchemaPtr) {
        // Use values from previous cache load as a starting point
        ATTCOUNT = CurrSchemaPtr->nAttInDB;
        CLSCOUNT = CurrSchemaPtr->nClsInDB;
        PREFIXCOUNT = START_PREFIXCOUNT;
        while ( (2*(CurrSchemaPtr->PrefixTable.PrefixCount + 25)) > PREFIXCOUNT) {
            PREFIXCOUNT += START_PREFIXCOUNT;
        }
    } else {
        // First time through, use the defaults
        ATTCOUNT    = START_ATTCOUNT;
        CLSCOUNT    = START_CLSCOUNT;
        PREFIXCOUNT = START_PREFIXCOUNT;

        CurrSchemaPtr = pSch;

        // Adjust RefCount, since when this thread was created
        // CurrSchemaPtr was null, so InitTHSTATE didn't increase
        // any refcounts (but free_thread_state will decrement it,
        // since now the schema ptr is non-null)

        InterlockedIncrement(&(pSch->RefCount));
    }

    pSch->PREFIXCOUNT  = PREFIXCOUNT;
    pSch->sysTime = DBTime();

    // Allocate the prefix table and hash tables
    if (SCCalloc(&pSch->PrefixTable.pPrefixEntry, pSch->PREFIXCOUNT, sizeof(PrefixTableEntry))
        || InitPrefixTable(pSch->PrefixTable.pPrefixEntry, pSch->PREFIXCOUNT)
        || SCCalloc(&pSch->pPartialAttrVec, 1, PartialAttrVecV1SizeFromLen(DEFAULT_PARTIAL_ATTR_COUNT))
        || SCResizeAttHash(pTHS, ATTCOUNT)
        || SCResizeClsHash(pTHS, CLSCOUNT)) {
        return ERROR_DS_CANT_CACHE_ATT;
    }

    // Finish initializing the PAS table
    pSch->cPartialAttrVec = DEFAULT_PARTIAL_ATTR_COUNT;
    pSch->pPartialAttrVec->dwVersion = VERSION_V1;

    // Pick up the newly allocated hash tables and actual sizes (may
    // differ from the amounts requested)
    ATTCOUNT    = pSch->ATTCOUNT;
    CLSCOUNT    = pSch->CLSCOUNT;
    ahcId       = pSch->ahcId;
    ahcCol      = pSch->ahcCol;

    //
    // Scan the columns and extract the attribute's attid from
    // the column name. Use this info to fill in skeleton cache
    // entries in the hash tables for attributes. The skeletons
    // are needed to query the schemaNC for the actual classSchema
    // and attributeSchema objects used to fill in the rest
    // of the schema cache.
    //

    // Quiz JET to find a table that describes the columns
    jsid = pTHS->JetCache.sesid;
    jdbid = pTHS->JetCache.dbid;

    // Do this in a critical section to avoid getting the columns
    // when columns are being added/deleted by SCUpdate
    EnterCriticalSection(&csJetColumnUpdate);
    __try {
      je = JetGetColumnInfo(jsid, jdbid, SZDATATABLE, 0, &jcl,
                            sizeof(jcl), JET_ColInfoList);
    }
    __finally {
      LeaveCriticalSection(&csJetColumnUpdate);
    }
    if (je) {
        return(je);
    }

    // Ok, now walk the table and extract info for each column.  Whenever
    // we find a column that looks like an attribute (name starts with ATT)
    // allocate an attcache structure and fill in the jet col and the att
    // id (computed from the column name).
    memset(ajrc, 0, sizeof(ajrc));
    ajrc[0].columnid = jcl.columnidcolumnid;
    ajrc[0].pvData = &jci;
    ajrc[0].cbData = sizeof(jci);
    ajrc[0].itagSequence = 1;
    ajrc[1].columnid = jcl.columnidcolumnname;
    ajrc[1].pvData = achColName;
    ajrc[1].cbData = sizeof(achColName);
    ajrc[1].itagSequence = 1;

    jtid = jcl.tableid;

    je = JetMove(jsid, jtid, JET_MoveFirst, 0);

    colCount = 0;
    do {

        memset(achColName, 0, sizeof(achColName));
        je = JetRetrieveColumns(jsid, jtid, ajrc, 2);
        if (strncmp(achColName,"ATT",3)) {
            // not an att column
            continue;
        }

        // It is an ATT column
        colCount++;

        // Hash tables too small, reallocate them
        if (2*colCount > ATTCOUNT) {

            err = SCResizeAttHash(pTHS, colCount);
            if (err) {
                return (err);
            }

            // refresh locals thay may have been altered by SCResizeAttHash
            ATTCOUNT = pSch->ATTCOUNT;
            ahcId    = pSch->ahcId;
            ahcCol   = pSch->ahcCol;
        }

        // Fill in the skeleton attcache entry

        aid = atoi(&achColName[4]);
        if (SCCalloc(&pac, 1, sizeof(ATTCACHE))) {
            return ERROR_DS_CANT_CACHE_ATT;
        }
        pac->id = aid;

        pac->jColid = jci;
        pac->syntax = achColName[3] - 'a';

        // add to id cache
        for (i=SChash(aid,ATTCOUNT);
             ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY) ; i=(i+1)%ATTCOUNT){
        }
        ahcId[i].hKey = aid;
        ahcId[i].pVal = pac;

        // add to col cache
        for (i=SChash(jci,ATTCOUNT);
             ahcCol[i].pVal && (ahcCol[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
        }
        ahcCol[i].hKey = jci;
        ahcCol[i].pVal = pac;


        if (eServiceShutdown) {
            JetCloseTable(jsid, jtid);
            return 0;
        }

    } while ((je = JetMove(jsid, jtid, JET_MoveNext, 0)) == 0);

    je = JetCloseTable(jsid, jtid);

    // In newer builds, we fixed a bug such that we no longer create
    // columns for linked and constructed atts. So the following
    // attributes will no longer be in the cache at this stage.
    // However, they are needed since RebuildCatalog needs them before
    // the cache is built from the schemaNC. So we add them here now
    // as if they had a column, the rest of the information will be
    // filled up later by SCCacheSchema2
    //
    // Note that the SCGetAttById check is needed for the case
    // when the new binary is put on the old dit (which still has the columns
    // and so will have the attcaches at this stage. The columns will be
    // deleted in SCCacheSChema3 in the second schema cache load after a boot
    //
    // The above comments apply to pre-w2k DITs
    //
    {
        struct _MissingLinkIds {
            ATTRTYP aid;
            int syntaxId;
            ULONG linkId;
        } *pMissingLinkIds, aMissingLinkIds[] = {
            // NTRAID#NTBUG9-582921-2002/03/21-Brettsh  - When we can count on
            // no longer upgrading from Win2k or .NET Beta3 then we could
            // theoritically remove this deprecated attribute here
            { ATT_HAS_MASTER_NCS, SYNTAX_ID_HAS_MASTER_NCS, 76 }, // deprecated "old" hasMasterNCs
            { ATT_MS_DS_HAS_MASTER_NCS, SYNTAX_ID_MS_DS_HAS_MASTER_NCS, 2036 },
            { ATT_HAS_PARTIAL_REPLICA_NCS, SYNTAX_ID_HAS_PARTIAL_REPLICA_NCS, 74 },
            { ATT_MS_DS_SD_REFERENCE_DOMAIN, SYNTAX_ID_MS_DS_SD_REFERENCE_DOMAIN, 2000 },
            { INVALID_ATT }
        };

        for (pMissingLinkIds = aMissingLinkIds;
             pMissingLinkIds->aid != INVALID_ATT; ++pMissingLinkIds) {

            // If no column exists (shouldn't except on very, very
            // old DITs) allocate a new pac and add to id hash
            if (NULL == (pac = SCGetAttById(pTHS, pMissingLinkIds->aid))) {
                if (SCCalloc(&pac, 1, sizeof(ATTCACHE))) {
                    return ERROR_DS_CANT_CACHE_ATT;
                }
                for (i=SChash(pMissingLinkIds->aid,ATTCOUNT);
                    ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY) ; i=(i+1)%ATTCOUNT){
                }
                ahcId[i].hKey = pMissingLinkIds->aid;
                ahcId[i].pVal = pac;
            }
            // Hammer the pac entry to its correct values
            pac->id = pMissingLinkIds->aid;
            pac->syntax = pMissingLinkIds->syntaxId;
            pac->ulLinkID = pMissingLinkIds->linkId;
        }
    }

    Assert(SCGetAttById(pTHS, ATT_HAS_MASTER_NCS) && SCGetAttById(pTHS, ATT_MS_DS_HAS_MASTER_NCS)
           && SCGetAttById(pTHS, ATT_HAS_PARTIAL_REPLICA_NCS)
           && SCGetAttById(pTHS, ATT_MS_DS_SD_REFERENCE_DOMAIN));

    ++iSCstage;
    return(0);
}


// We will keep two lists of attributes of an attribute-schema or
// class-schema object to search - one for the regular cache load case
// here we are interested in caching nearly all attributes, and one
// for the validation-cache building case during schema updates, where
// we need to read only a subset that we will use in validation

// The list of attributes of an ATTRIBUTE object that we need to cache

//Regular case

ATTR AttributeSelList[] = {
    { ATT_SYSTEM_ONLY, {0, NULL}},
    { ATT_IS_SINGLE_VALUED, {0, NULL}},
    { ATT_RANGE_LOWER, {0, NULL}},
    { ATT_RANGE_UPPER, {0, NULL}},
    { ATT_ATTRIBUTE_ID, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_ATTRIBUTE_SYNTAX, {0, NULL}},
    { ATT_OM_SYNTAX, {0, NULL}},
    { ATT_OM_OBJECT_CLASS, {0, NULL}},
    { ATT_MAPI_ID, {0, NULL}},
    { ATT_LINK_ID, {0, NULL}},
    { ATT_SEARCH_FLAGS, {0, NULL}},
    { ATT_ATTRIBUTE_SECURITY_GUID, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_EXTENDED_CHARS_ALLOWED, {0, NULL}},
    { ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_MS_DS_INTID, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define NUMATTATT  sizeof(AttributeSelList)/sizeof(ATTR)

// Validation cache building case

ATTR RecalcSchAttributeSelList[] = {
    { ATT_RANGE_LOWER, {0, NULL}},
    { ATT_RANGE_UPPER, {0, NULL}},
    { ATT_ATTRIBUTE_ID, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_ATTRIBUTE_SYNTAX, {0, NULL}},
    { ATT_OM_SYNTAX, {0, NULL}},
    { ATT_OM_OBJECT_CLASS, {0, NULL}},
    { ATT_MAPI_ID, {0, NULL}},
    { ATT_LINK_ID, {0, NULL}},
    { ATT_SEARCH_FLAGS, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_MS_DS_INTID, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define RECALCSCHNUMATTATT  sizeof(RecalcSchAttributeSelList)/sizeof(ATTR)


// The list of attributes of an CLASS object that we need to cache

// Regular Case

ATTR ClassSelList[] = {
    { ATT_SYSTEM_ONLY, {0, NULL}},
    { ATT_DEFAULT_SECURITY_DESCRIPTOR, {0, NULL}},
    { ATT_GOVERNS_ID, {0, NULL}},
    { ATT_MAY_CONTAIN, {0, NULL}},
    { ATT_MUST_CONTAIN, {0, NULL}},
    { ATT_SUB_CLASS_OF, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_RDN_ATT_ID, {0, NULL}},
    { ATT_POSS_SUPERIORS, {0, NULL}},
    { ATT_AUXILIARY_CLASS, {0, NULL}},
    { ATT_OBJECT_CLASS_CATEGORY, {0, NULL}},
    { ATT_SYSTEM_AUXILIARY_CLASS, {0, NULL}},
    { ATT_SYSTEM_MUST_CONTAIN, {0, NULL}},
    { ATT_SYSTEM_MAY_CONTAIN, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_SYSTEM_POSS_SUPERIORS, {0, NULL}},
    { ATT_DEFAULT_HIDING_VALUE, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_DEFAULT_OBJECT_CATEGORY, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define NUMCLASSATT  sizeof(ClassSelList)/sizeof(ATTR)

// Validation cache building case

ATTR RecalcSchClassSelList[] = {
    { ATT_GOVERNS_ID, {0, NULL}},
    { ATT_MAY_CONTAIN, {0, NULL}},
    { ATT_MUST_CONTAIN, {0, NULL}},
    { ATT_SUB_CLASS_OF, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_RDN_ATT_ID, {0, NULL}},
    { ATT_POSS_SUPERIORS, {0, NULL}},
    { ATT_AUXILIARY_CLASS, {0, NULL}},
    { ATT_OBJECT_CLASS_CATEGORY, {0, NULL}},
    { ATT_SYSTEM_AUXILIARY_CLASS, {0, NULL}},
    { ATT_SYSTEM_MUST_CONTAIN, {0, NULL}},
    { ATT_SYSTEM_MAY_CONTAIN, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_SYSTEM_POSS_SUPERIORS, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define RECALCSCHNUMCLASSATT  sizeof(RecalcSchClassSelList)/sizeof(ATTR)


VOID
scAcquireSearchParameters(
    IN THSTATE *pTHS,
    IN DSNAME *pDnObjCat,
    IN ENTINFSEL *pSel,
    IN OUT SEARCHARG *pSearchArg,
    IN OUT FILTER *pFilter,
    OUT SEARCHRES **ppSearchRes
)

/*++
   Initialize search arguments, filters etc. for schema cache search

   Arguments:
      pTHS -- thread state
      pDnObjCat -- pointer to Dsname with object-category to put in filter
      pSel -- pointer to attribute selection list
      pSearchArg -- SearchArg to fill up
      pFilter -- filter to fill up
      ppSearchRes -- to allocate and initialize searchres. Free with
                     ReleaseSearchParamters.
--*/
{

    SEARCHRES *pSearchRes = NULL;

    // build search argument
    memset(pSearchArg, 0, sizeof(SEARCHARG));
    pSearchArg->pObject = gAnchor.pDMD;
    pSearchArg->choice = SE_CHOICE_IMMED_CHLDRN;
    pSearchArg->pFilter = pFilter;
    pSearchArg->searchAliases = FALSE;
    pSearchArg->pSelection = pSel;

    // Build Commarg
    InitCommarg(&(pSearchArg->CommArg));

    // build filter
    memset(pFilter, 0, sizeof(FILTER));
    pFilter->pNextFilter = (FILTER FAR *)NULL;
    pFilter->choice = FILTER_CHOICE_ITEM;
    pFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pFilter->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = pDnObjCat->structLen;
    pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (PCHAR) pDnObjCat;

    // allocate space for search res
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;   //Initialize to Default
    *ppSearchRes = pSearchRes;
}

VOID
scReleaseSearchParameters(
    IN THSTATE *pTHS,
    IN OUT SEARCHRES **ppSearchRes
)

/*++
   Free resources allocated by scAcquireSearchParameters
--*/
{
    if (*ppSearchRes) {
        THFreeEx(pTHS, *ppSearchRes);
        *ppSearchRes = NULL;
    }
}

VOID
scFixCollisions(
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    Treat dups as defunct in the schema-reuse sense of defunct. Schema-
    reuse handles collisions more gracefully than pre-schema-reuse forests.
    The better handling is needed because the behavior version replicates
    out-of-order wrt the schemaNC. In other words, a collision probably
    happend because someone raised the forest version and reused
    a defunct schema object but the schema objects are replicating
    BEFORE the forest version. Replication will no doubt clear up
    this case but handle it in the interim.

Arguments:

Return Value:

    None.

--*/
{
    DECLARESCHEMAPTR
    DWORD i, iAtt, iCls;
    ATTCACHE *pAC, *pACDup, *pACWinner;
    CLASSCACHE *pCC;
    // not really necessary because this function returns
    // immediately when called during a validation cache
    // load. But that may change someday.
    USHORT DebugLevel = (pTHS->UpdateDITStructure) ? DS_EVENT_SEV_ALWAYS
                                                   : DS_EVENT_SEV_MINIMAL;

    // the validation cache needs to see all of the active
    // attributes and classes, especially those that collide.
    if (!pTHS->UpdateDITStructure) {
        return;
    }

    // Treat dup attrs as if they were defunct
    for (iAtt = 0; iAtt < ATTCOUNT; ++iAtt) {
        pAC = ahcId[iAtt].pVal;
        if (!pAC
            || pAC == FREE_ENTRY
            || (    !pAC->bDupLDN
                 && !pAC->bDupOID
                 && !pAC->bDupMapiID
                // Okay to dup PropGuid during normal cache load;
                // && !pAC->bDupPropGuid
                )) {
            continue;
        }
        pAC->bDefunct = TRUE;

        // NOT AN RDN
        //
        // if the attr is not used as an rdn then remove from active hashes
        if (!pAC->bIsRdn) {
            scUnhashAtt(pTHS, pAC, SC_UNHASH_DEFUNCT);
            continue;
        }

        // USED AS RDN
        //
        // Treat all atts used as RdnAttId as live. A defunct rdnAttId
        // could only occur on pre-schema-reuse DCs and so could not
        // have been reused. schema-reuse DCs disallow reusing
        // rdnAttids.
        //
        // A problem might arise with divergent schemas if rdnAttids
        // collide with other attributes or with other rdnattid
        // attributes. In each case, decide who wins the OID, LDN,
        // and MapiID using the precedence
        //     1) attribute is used as RDN
        //     2) attribute has FLAG_ATTR_IS_RDN set in systemFlags
        //     3) attribute has the largest objectGuid
        // The loser is unhashed from the appropriate table.

        // Colliding OID; choose a winner
        if (pAC->bDupOID) {
            pACWinner = pAC;
            while (pACDup = SCGetAttByExtId(pTHS, pACWinner->Extid)) {
                scUnhashAtt(pTHS, pACDup, SC_UNHASH_LOST_OID);
                if (pACWinner->bIsRdn != pACDup->bIsRdn) {
                    pACWinner = (pACWinner->bIsRdn) ? pACWinner : pACDup;
                } else if (pACWinner->bFlagIsRdn != pACDup->bFlagIsRdn) {
                    pACWinner = (pACWinner->bFlagIsRdn) ? pACWinner : pACDup;
                } else {
                    pACWinner = (0 < memcmp(&pACWinner->objectGuid,
                                            &pACDup->objectGuid,
                                            sizeof(pAC->objectGuid)))
                                                ? pACWinner : pACDup;
                }
            }
            for (i=SChash(pACWinner->Extid,ATTCOUNT);
                ahcExtId[i].pVal && (ahcExtId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
            }
            ahcExtId[i].hKey = pACWinner->Extid;
            ahcExtId[i].pVal = pACWinner;
            DPRINT3(DebugLevel, "Attr %s (%x %x) won the attributeId\n",
                    pACWinner->name, pACWinner->id, pACWinner->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_ATTRIBUTE_WON_OID,
                      szInsertSz(pACWinner->name),
                      szInsertHex(pACWinner->id),
                      szInsertHex(pACWinner->Extid),
                      NULL, NULL, NULL, NULL, NULL);
        }

        // Colliding LDN; choose a winner
        if (pAC->bDupLDN) {
            pACWinner = pAC;
            while (pACDup = SCGetAttByName(pTHS, pACWinner->nameLen, pACWinner->name)) {
                scUnhashAtt(pTHS, pACDup, SC_UNHASH_LOST_LDN);
                if (pACWinner->bIsRdn != pACDup->bIsRdn) {
                    pACWinner = (pACWinner->bIsRdn) ? pACWinner : pACDup;
                } else if (pACWinner->bFlagIsRdn != pACDup->bFlagIsRdn) {
                    pACWinner = (pACWinner->bFlagIsRdn) ? pACWinner : pACDup;
                } else {
                    pACWinner = (0 < memcmp(&pACWinner->objectGuid,
                                            &pACDup->objectGuid,
                                            sizeof(pAC->objectGuid)))
                                                ? pACWinner : pACDup;
                }
            }
            for (i=SCNameHash(pACWinner->nameLen, pACWinner->name, ATTCOUNT);
                ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcName[i].length = pACWinner->nameLen;
            ahcName[i].value = pACWinner->name;
            ahcName[i].pVal = pACWinner;
            DPRINT3(DebugLevel, "Attr %s (%x %x) won the ldapDisplayName\n",
                    pACWinner->name, pACWinner->id, pACWinner->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_ATTRIBUTE_WON_LDN,
                      szInsertSz(pACWinner->name),
                      szInsertHex(pACWinner->id),
                      szInsertHex(pACWinner->Extid),
                      NULL, NULL, NULL, NULL, NULL);
        }
        // Colliding MapiID; choose a winner
        if (pAC->bDupMapiID) {
            pACWinner = pAC;
            while (pACDup = SCGetAttByMapiId(pTHS, pACWinner->ulMapiID)) {
                scUnhashAtt(pTHS, pACDup, SC_UNHASH_LOST_MAPIID);
                if (pACWinner->bIsRdn != pACDup->bIsRdn) {
                    pACWinner = (pACWinner->bIsRdn) ? pACWinner : pACDup;
                } else if (pACWinner->bFlagIsRdn != pACDup->bFlagIsRdn) {
                    pACWinner = (pACWinner->bFlagIsRdn) ? pACWinner : pACDup;
                } else {
                    pACWinner = (0 < memcmp(&pACWinner->objectGuid,
                                            &pACDup->objectGuid,
                                            sizeof(pAC->objectGuid)))
                                                ? pACWinner : pACDup;
                }
            }
            for (i=SChash(pACWinner->ulMapiID, ATTCOUNT);
                 ahcMapi[i].pVal && (ahcMapi[i].pVal!= FREE_ENTRY);
                 i=(i+1)%ATTCOUNT) {
            }
            ahcMapi[i].hKey = pACWinner->ulMapiID;
            ahcMapi[i].pVal = pACWinner;
            DPRINT4(DebugLevel, "Attr %s (%x %x) won the mapiID %x\n",
                    pACWinner->name, pACWinner->id, pACWinner->Extid, pACWinner->ulMapiID);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_ATTRIBUTE_WON_MAPIID,
                      szInsertSz(pACWinner->name),
                      szInsertHex(pACWinner->id),
                      szInsertHex(pACWinner->Extid),
                      szInsertHex(pACWinner->ulMapiID),
                      NULL, NULL, NULL, NULL);
        }
    }

    // Treat dup classes as if they were defunct (except oid is not lost.)
    // The oid is not lost because a class must win the oid for
    // replication to work. Keep the winner.
    //
    // Fixup the rdnIntId with the winner of the RdnExtId.
    for (iCls = 0; iCls < CLSCOUNT; ++iCls) {
        pCC = ahcClassAll[iCls].pVal;

        // free entry
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }

        // The active attribute corresponding to RdnExtId may have
        // changed when attribute collisions were resolved.
        pCC->RdnIntId = SCAttExtIdToIntId(pTHS, pCC->RdnExtId);

        // Colliding classes are treated as if they were defunct
        if (pCC->bDupLDN || pCC->bDupOID) {
            // Okay to dup PropGuid during normal cache load; don't defunct
            // || pCC->bDupPropGuid
            pCC->bDefunct = TRUE;
            scUnhashCls(pTHS, pCC, SC_UNHASH_DEFUNCT);
        }
    }
}

VOID
scFixRdnAttId (
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    Resurrect attributes used as rdnAttId for any class, live
    or defunct. The resurrected attributes will continue to own
    their attributeId, LDN, MapiId, and schemaIdGuid.

    Divergent schemas may have resulted in duplicate attributeIds.
    scFixCollisions will later decide on a "winner" for the
    OID, LDN, and MapiID.

    Attributes used as rdnattids continue to hold their identity
    because the DS depends on the relationship between ATT_RDN,
    FIXED_ATT_RDN_TYPE, the rdnattid column, the ldapDisplayName
    of the rdnattid, and the rdnattid in the object's class
    when replicating renames, adds, mods, and, perhaps,
    deletes.

Arguments:
    pTHS - thread state

Return Value:

    None.

--*/
{
    DECLARESCHEMAPTR
    DWORD i, j;
    ATTCACHE *pAC;
    CLASSCACHE *pCC;
    USHORT DebugLevel;

    // Resurrect attributes used as rdnAttId for any class, live
    // or defunct. Resurrecting the attributes means these attributes
    // cannot be reused. They are effectively live even when marked
    // defunct.
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }
        // Resurrect all attributes whose ExtId matches the rdnAttId
        // of any class.
        //
        // All of the attributes with matching OIDs are resurrected
        // so that they can again compete for the OID given the
        // new knowledge that this attribute and its peers are
        // used as rdnattids. scFixCollisions will choose a winner,
        // later.
            
        // avoid spew during a validation cache load and
        // when the class is defunct
        if (pCC->bDefunct || !pTHS->UpdateDITStructure) {
            DebugLevel = DS_EVENT_SEV_MINIMAL;
        } else {
            DebugLevel = DS_EVENT_SEV_ALWAYS;
        }
        
        // Reanimate potential rdnTypes.
        for (j = 0; j < ATTCOUNT; ++j) {
            if ((pAC = ahcId[j].pVal)
                && pAC != FREE_ENTRY
                && pAC->Extid == pCC->RdnExtId) {
                
                // mark it as rdn
                pAC->bIsRdn = TRUE;

                if (pAC->bDefunct) {
                    // Just to be safe, remove from relevent hashes
                    scUnhashAtt(pTHS, pAC, SC_UNHASH_DEFUNCT);
                    DPRINT5(DebugLevel, "Resurrect Att %s (%x %x) for class %s (%x)\n",
                            pAC->name, pAC->id, pAC->Extid,
                            pCC->name, pCC->ClassId);
                    LogEvent8(DS_EVENT_CAT_SCHEMA,
                              DebugLevel,
                              DIRLOG_SCHEMA_RESURRECT_RDNATTID,
                              szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                              szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                              NULL, NULL, NULL);
    
                    // Place into active hashes. Set bIsRdn to TRUE
                    // so that scAddAttSchema ignores bDefunct
                    
                    SCAddAttSchema(pTHS, pAC, FALSE, TRUE);
                }
                
            }
        }
        // For now, pick any one of the resurrected attrs
        // scFixCollisions will finalize the choice, later
        pAC = SCGetAttByExtId(pTHS, pCC->RdnExtId);
        
        if (pAC) {
            //pAC->bIsRdn = TRUE; // let folks know this att is an rdnattid
            pCC->RdnIntId = pAC->id; // first guess. May change in scFixCollisions.
        }   // else if (!pAC)
            // Not found. pCC->RdnIntId was initialized to
            // RdnExtId. Leave it that way because the attr
            // will probably replicate in later. No problem
            // because no rows can exist unless the LDN exists
            // (shouldn't except for divergent schemas). In that case,
            // the replicating row may have a different name on different
            // DCs. Not catastrophic and better than killing the DC.
    }
}

VOID
ValListToIntIdList(
    IN     THSTATE  *pTHS,
    IN     ULONG    *pCount,
    IN OUT ULONG    **ppVal
    )
/*++

Routine Description:

    Walk an array of attids and convert into intids compressing
    out the untranslatable and defunct on schema-reuse forests.

    Old forests still return defunct attributes.

Arguments:
    pTHS - Its schema ptr is NOT the global schema pointer

Return Value:

    None.

--*/
{
    DWORD       i;
    ATTCACHE    *pAC;
    ULONG       *pVal = *ppVal, *pNewVal;
    ULONG       NewCount;

    // The validation cache retains defunct or missing attids so
    // that scchk.c can correctly disallow the operation.
    if (!pTHS->UpdateDITStructure) {
        // Translate oids into intids; leaving non-translatable oids in place
        for (i = 0; i < *pCount; ++i) {
            pVal[i] = SCAttExtIdToIntId(pTHS, pVal[i]);
        }
    } else {
        // Collapse out defunct or missing attids on a schema-reuse forest.
        // This means defunct attrs are not returned on queries on
        // schema-reuse forests but are returned on pre-schema-reuse
        // forests.
        pNewVal = pVal;
        NewCount = 0;
        for (i = 0; i < *pCount; ++i) {
            if ((pAC = SCGetAttByExtId(pTHS, pVal[i]))
                && (!pAC->bDefunct || !ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr))) {
                pNewVal[NewCount++] = pAC->id;
            }
        }
        // Just in case there is code that expects a NULL array if count is 0
        if (0 == (*pCount = NewCount)) {
            SCFree(ppVal);
        } // else don't bother reallocating -- not enough savings
    }
}
VOID
scFixMayMust (
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    Fix the mays/musts for a class.
    Exclude defunct attrs if schema-reuse forest and convert
    tokenized OIDs into internal IDs. The defunct attrs are
    left in place if this is a validation cache load (scchk.c).

Arguments:
    pTHS - Its schema ptr is NOT the global schema pointer

Return Value:

    None.

--*/
{
    DECLARESCHEMAPTR
    DWORD i;
    CLASSCACHE *pCC;

    // Collapse the defunct atts out of the may/must of all classes
    // and change the ExtIds into IntIds. If this is a validation
    // cache load (scchk.c), the defunct ExtIds are left in place.
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }
        ValListToIntIdList(pTHS, &pCC->MayCount, &pCC->pMayAtts);
        ValListToIntIdList(pTHS, &pCC->MyMayCount, &pCC->pMyMayAtts);
        ValListToIntIdList(pTHS, &pCC->MustCount, &pCC->pMustAtts);
        ValListToIntIdList(pTHS, &pCC->MyMustCount, &pCC->pMyMustAtts);
    }
}

int
scPagedSearchAtt(
    IN THSTATE      *pTHS,
    IN ENTINF       *pEI
    )
{
    int         err = 0;
    ATTCACHE    *pAC;
    SCHEMAPTR   *pSch = pTHS->CurrSchemaPtr;

    if (NULL == (pAC = scAddAtt(pTHS, pEI))) {
        if (0 == pTHS->errCode) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_SCHEMA_ALLOC_FAILED);
        }
        err = pTHS->errCode;
        goto cleanup;
    }
    pSch->nAttInDB++;

    if (pAC->bMemberOfPartialSet) {
        // this attribute is a member of partial set
        if (pSch->cPartialAttrVec <= pSch->pPartialAttrVec->V1.cAttrs) {
            // not enough room to add one more attribute - reallocate the partial attribute vector
            pSch->cPartialAttrVec += PARTIAL_ATTR_COUNT_INC;
            if (SCRealloc(&pSch->pPartialAttrVec, PartialAttrVecV1SizeFromLen(pSch->cPartialAttrVec))) {
                err = pTHS->errCode;
                goto cleanup;
            }
        }

        // there is enough space to add the attribute into the partial set - add it
        GC_AddAttributeToPartialSet(pSch->pPartialAttrVec, pAC->id);
    }

cleanup:
    return(err);
}

int
scPagedSearchCls(
    IN THSTATE      *pTHS,
    IN ENTINF       *pEI
    )
{
    int         err = 0;
    CLASSCACHE  *pCC;
    SCHEMAPTR   *pSch = pTHS->CurrSchemaPtr;

    if (NULL == (pCC = scAddClass(pTHS, pEI))) {
        if (pTHS->errCode == 0) {
            // scAddClass can fail in only two cases: the default SD
            // conversion fails, in which case the thread state error
            // code is already set; or if mallocs fail
            SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_SCHEMA_ALLOC_FAILED);
        }
        err = pTHS->errCode;
        goto cleanup;
    }
    pSch->nClsInDB++;

cleanup:
    return(err);
}

int
scPagedSearch(
        IN THSTATE  *pTHS,
        IN PWCHAR   pBaseObjCat,
        IN ULONG    attrCount,
        IN ATTR     *pAttr,
        IN int      (*SearchResize)(IN THSTATE *pTHS,
                                    IN ULONG nNewEntries),
        IN int      (*SearchEntry)(IN THSTATE *pTHS,
                                   IN ENTINF *pEI)
        )
{
    int         err = 0;
    DWORD       i;
    ENTINFSEL   eiSel;
    PRESTART    pRestart;
    BOOL        fMoreData;
    DWORD       nDnObjCat;
    DSNAME      *pDnObjCat;
    SEARCHARG   SearchArg;
    FILTER      Filter;
    COMMARG     *pCommArg;
    ENTINFLIST  *pEIL, *pEILtmp;
    SEARCHRES   *pSearchRes = NULL;

    //build the object-category value to put in the filter
    nDnObjCat = DSNameSizeFromLen(gAnchor.pDMD->NameLen + wcslen(pBaseObjCat) + 1);
    pDnObjCat = THAllocEx(pTHS, nDnObjCat);
    wcscpy(pDnObjCat->StringName, pBaseObjCat);
    wcscat(pDnObjCat->StringName, gAnchor.pDMD->StringName);
    pDnObjCat->NameLen = wcslen(pDnObjCat->StringName);
    pDnObjCat->structLen = nDnObjCat;

    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    eiSel.AttrTypBlock.attrCount = attrCount;
    eiSel.AttrTypBlock.pAttr = pAttr;

    fMoreData = TRUE;
    pRestart = NULL;

    while (fMoreData && !eServiceShutdown) {

        scAcquireSearchParameters(pTHS, pDnObjCat, &eiSel, &SearchArg, &Filter, &pSearchRes);

        // Set for paged search;
        pCommArg = &(SearchArg.CommArg);
        pCommArg->PagedResult.fPresent = TRUE;
        pCommArg->PagedResult.pRestart = pRestart;
        pCommArg->ulSizeLimit = 200;

        SearchBody(pTHS, &SearchArg, pSearchRes, 0);
        if (err = pTHS->errCode) {
            LogAndAlertEvent(DS_EVENT_CAT_SCHEMA, DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SCHEMA_SEARCH_FAILED, szInsertUL(1),
                             szInsertUL(err), 0);
            goto cleanup;
        }

        if (eServiceShutdown) {
           break;
        }

        // Is there more data?
        if (pSearchRes->PagedResult.pRestart == NULL
            || !pSearchRes->PagedResult.fPresent) {
            // Nope
            fMoreData = FALSE;
        } else {
            // more data. save off the restart to use in the next iteration.
            // Note that freeing searchres does not free pRestart
            pRestart = pSearchRes->PagedResult.pRestart;
        }

        // Resize the hash tables, if needed
        err = (*SearchResize)(pTHS, pSearchRes->count);
        if (err) {
            goto cleanup;
        }

        //  for each attrSchema, add to caches
        pEIL = &(pSearchRes->FirstEntInf);
        for (i = 0; i < pSearchRes->count; i++) {

            // Check for service shutdown once every iteration
            if (eServiceShutdown) {
               return 0;
            }

            if (!pEIL) {
                LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_MINIMAL,
                    DIRLOG_SCHEMA_BOGUS_SEARCH, szInsertUL(1), szInsertUL(i),
                    szInsertUL(pSearchRes->count));
                break;
            }

            // Process the returned search entry
            if (err = (*SearchEntry)(pTHS, &pEIL->Entinf)) {
                goto cleanup;
            }

            pEILtmp = pEIL;
            pEIL = pEIL->pNextEntInf;
            if (i > 0) {
                THFreeEx(pTHS, pEILtmp);
            }
        }

        // free the searchres
        scReleaseSearchParameters(pTHS, &pSearchRes);

    }  // while (fMoreData)

cleanup:
    scReleaseSearchParameters(pTHS, &pSearchRes);
    THFreeEx(pTHS, pDnObjCat);
    return err;
}

LONG
scGetForestBehaviorVersion(
        VOID
        )
/*++

Routine Description:

    Return the effective ForestBehaviorVersion for the schema cache.

    The schema cache is loaded differently and presents a different
    view of the schema objects after the forest behavior version is
    raised to DS_BEHAVIOR_SCHEMA_REUSE to support the new defunct,
    delete, and reuse behavior. The gAnchor.ForestBehaviorVersion
    is not used because it may change during or after the schema
    cache has been loaded. This effective schema version is stored
    in the schemaptr.

    During install and mkdit, the effective forest version is
    set to DS_BEHAVIOR_SCHEMA_REUSE because the true forest
    version is not known and this more flexible schema cache
    can effectively handle both old and new schemas without
    generating bothersome events and without affecting the
    result of the install or mkdit.

    During boot, the version is read from the DIT. If this read
    fails, the effective version is returned as
    DS_BEHAVIOR_SCHEMA_REUSE for the reasons mentioned above. Later,
    the schema cache may be reloaded immediately if RebuildAnchor
    notices the forest behavior version and the schema's effective
    behavior version are not in sync.

    After boot, the gAnchor.ForestBehaviorVersion is used.

Arguments:

    None.

Return Value:

    Effective forest behavior version

--*/
{
    DWORD dwErr;
    DBPOS *pDB;
    LONG ForestBehaviorVersion;

    // Always use the most flexible cache version because the
    // more flexible, new cache can handle old and new cache behavior
    // while the old cache cannot. Using the new cache behavior doesn't
    // affect the outcome of dcpromo or mkdit.exe.
    if (DsaIsInstalling() || gfRunningAsMkdit || !gAnchor.pPartitionsDN) {
        return DS_BEHAVIOR_SCHEMA_REUSE;
    }

    // Not the boot load, use whatever is in the gAnchor. gAnchor
    // should have been initialized from the DIT by now so there
    // is no reason to reread the info.
    if (iSCstage > 2) {
        return gAnchor.ForestBehaviorVersion;
    }


    // read the forest's behavior version
    dwErr = 0;
    __try {
        DBOpen(&pDB);
        __try {
            dwErr = DBFindDSName(pDB, gAnchor.pPartitionsDN);
            if (dwErr) {
                __leave;
            }
            dwErr = DBGetSingleValue(pDB,
                                     ATT_MS_DS_BEHAVIOR_VERSION,
                                     &ForestBehaviorVersion,
                                     sizeof(ForestBehaviorVersion),
                                     NULL);

            // no value means w2k behavior version
            if (DB_ERR_NO_VALUE==dwErr) {
                ForestBehaviorVersion = DS_BEHAVIOR_WIN2000;
                dwErr = 0;
            }
        } __finally {
            DBClose(pDB, TRUE);
        }
    } __except (HandleAllExceptions(GetExceptionCode())) {
        DPRINT(0, "scGetForestBehaviorVersion: Exception reading version\n");
        dwErr = ERROR_DS_INCOMPATIBLE_VERSION;
    }

    // Can't be read, use the most flexible cache load
    if (dwErr) {
        DPRINT2(0, "scGetForestBehaviorVersion: error %d (%x)\n", dwErr, dwErr);
        ForestBehaviorVersion = DS_BEHAVIOR_SCHEMA_REUSE;
    }

    return ForestBehaviorVersion;
}

int
SCCacheSchema2(
        VOID
        )
/*++

Routine Description:

    Load the schema cache with information from the schemaNC.

    First, search the schemaNC for attributeSchema objects and then
    search for classSchema objects. The cache entries are constructed
    and added to the schema hash tables.

    The new (or updated) entries are added to the various hash tables
    according to the rules determined by the forest version in the
    gAnchor. During install or mkdit, the schema cache is loaded at
    version DS_BEHAVIOR_SCHEMA_REUSE because the actual forest version
    is not known and loading at this level doesn't hurt anythinhg and
    prevents unnecessary and bothersome events. During boot, the
    forest version is read from the DIT.

    SCCacheSchemaInit paritially initialized the ATTCACHE entries in
    the attribute hash tables (id, syntax, and colid) and they are in
    just the id and col hash tables. But this is enough info to allow
    searching the schemaNC. SCCacheSchema2 is responsible for
    searching the schemaNC and filling in the rest of the info
    in the ATTCACHE entries. And allocating CLASSCACHE entries.

    If this isn't the first schema cache load at boot, then
    SCCacheSchema3 will delete the indexes and columns for attributes
    that don't have corresponding entries in the schemaNC and will
    add missing indexes and columns for attributes in the schemaNC.
    The expensive index creation is delayed until the second
    cache load after boot (approximately 5 minutes after boot)
    so that the AD comes online more quickly and isn't delayed
    for what could be hours.

    Suggested Enhancements
    1) Reduce the number of full hash scans if possible.

Arguments:

    None.

Return Value:

    !0 - failed; caller is responsible for freeing pTHS->CurrSchemaPtr
    with SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

    0 - Okay

--*/
{
    THSTATE *pTHS = pTHStls;
    int err = 0;

    // Most errors are reported via pTHS->errCode (or will be soon, I hope)
    THClearErrors();

    // There seems to be a path during installation that might call
    // this function w/o having called SCCacheSchemaInit; or is at
    // least pretending not to have called SCCacheSchemaInit by
    // setting iSCstage to 0. Need to resolve this confused
    // code path and document when and how the schema should be
    // reloaded.
    if ((iSCstage == 0) && (err = SCCacheSchemaInit())) {
        return err;
    }

    // Version remains in effect for the life of the cache even if
    // forest's version changes mid-load. Changing the forest version
    // triggers an immediate cache load so the two versions will not
    // be out of sync for long. Also, new incompatible features will
    // not be enabled until both the schema cache and the gAnchor
    // have versions >= DS_BEHAVIOR_SCHEMA_REUSE.
    pTHS->CurrSchemaPtr->ForestBehaviorVersion = scGetForestBehaviorVersion();

    err = scPagedSearch(pTHS,
                        L"CN=Attribute-Schema,",
                        (pTHS->UpdateDITStructure) ? NUMATTATT : RECALCSCHNUMATTATT,
                        (pTHS->UpdateDITStructure) ? AttributeSelList : RecalcSchAttributeSelList,
                        SCResizeAttHash,
                        scPagedSearchAtt);
    if (err) {
        return err;
    }

    err = scPagedSearch(pTHS,
                        L"CN=Class-Schema,",
                        (pTHS->UpdateDITStructure) ? NUMCLASSATT: RECALCSCHNUMCLASSATT,
                        (pTHS->UpdateDITStructure) ? ClassSelList : RecalcSchClassSelList,
                        SCResizeClsHash,
                        scPagedSearchCls);
    if (err) {
        return err;
    }


    // Fill in the copy of schemaInfo attribute on schema container.
    // DRA will use it now, and who knows who else will later

    if (err = scFillInSchemaInfo(pTHS)) {
        // Failed to read the schema info
        DPRINT1(0, "Failed to read in schemaInfo during schema cache load: %d\n", err);
        return err;
    }

    // Load the prefix map from the schema object, if any
    // The prefix table will be realloced in InitPrefixTable2
    // if necessary

    if (err = InitPrefixTable2(pTHS->CurrSchemaPtr->PrefixTable.pPrefixEntry,
                               pTHS->CurrSchemaPtr->PREFIXCOUNT)) {
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_PREFIX_LOAD_FAILED,
                 szInsertHex(err),
                 0, 0);
        return err;
    }

    scInitWellKnownAttids();

    // ORDER IS IMPORTANT
    //
    // 1) Resurrect defunct rdnattids.
    // 2) Defunct colliding attributes and classes
    // 3) Collapse defunct attributes out of the mays/musts
    scFixRdnAttId(pTHS);    // must preceed scFixCollisions
    scFixCollisions(pTHS);  // must preceed scFixMayMust
    scFixMayMust(pTHS);

    // WARNING - the schema's behavior version may have been
    // artificially raised for the initial boot schema load.
    // This means the schema runs in BETA3 mode for a few minutes
    // after boot. This is okay because LocalAdd will not create
    // intids until after the second cache load when the forest's
    // behavior version is known.

    ++iSCstage;
    return(0);
}

ATTCACHE*
scAddAtt(
        THSTATE *pTHS,
        ENTINF *pEI
        )
/*++
  Add a single attribute definition to the schema cache, given the data
  from the DMD object.

  N.B. The routines SCBuildACEntry and scAddAtt work in parallel, with
       SCBuildACEntry taking a positioned database record as input and
       SCAddAtt taking an ENTINF.  They both produce an ATTCACHE as output,
       and any changes made to one routine's processing must be made to
       the other's as well.

--*/
{
    ATTRTYP aid = INVALID_ATT, Extaid = INVALID_ATT;           // This is an invalid attribute id.
    ATTCACHE *pAC;
    ULONG i;
    int fNoJetCol = FALSE;
    unsigned syntax;
    char szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int  lenIndexName;

    // Look for both attids, the attributeId and the msDS-IntId
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_ATTRIBUTE_ID) {
            // found the attribute id, save the value.
            Extaid = *(ATTRTYP*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            if (aid != INVALID_ATT) {
                break;
            }
        } else if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_INTID) {
            // found the internal id, save the value.
            aid = *(ATTRTYP*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            if (Extaid != INVALID_ATT) {
                break;
            }
        }
    }

    // No msDS-IntId, use attributeId
    if(aid == INVALID_ATT) {
        aid = Extaid;
    }

    if(Extaid == INVALID_ATT) {
        // Did not find the attribute id.
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_MISSING_ATT_ID, 0, 0, 0);
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_MISSING_REQUIRED_ATT);
        return NULL;
    }

    pAC = SCGetAttById(pTHS, aid);
    if (!pAC) {
        fNoJetCol = TRUE;
        if (SCCalloc(&pAC, 1, sizeof(ATTCACHE))) {
            return NULL;
        }
    } else if (pAC->name) {
        DPRINT4(0, "Dup intid %08x, Extid %08x. Dup with %s, Extid %08x)\n",
                aid, Extaid, pAC->name, pAC->Extid);
        if (!(pTHS->UpdateDITStructure)) {
            if (pAC->id <= LAST_MAPPED_ATT) {
                // dup attributeId
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_DUP_OID);
            } else {
                // dup msDS-IntId
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_DUP_MSDS_INTID);
            }
            return NULL;
        }   // else
            // Oddly enough, the existing code will simply reuse an
            // existing cache entry during a non-validation schema reload
            // if the attributeId (now msDS-IntId) matches. This means
            // the fields are overwritten and the entry rehashed. Surely
            // this is a bug! Or is it compensating for some odd interim
            // case during install or pre-w2k DCs? At any rate, the new
            // code will decide the attribute collides and will mark
            // "them" as defunct.
    }
    pAC->id = aid;
    pAC->Extid = Extaid;
    pAC->bExtendedChars = TRUE; /* a popular default setting */

    // Now walk the attrblock and add the appropriate fields to the AC
    for(i=0;i< pEI->AttrBlock.attrCount;i++) {
        ATTRVAL * pAVal = pEI->AttrBlock.pAttr[i].AttrVal.pAVal;

        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_SYSTEM_ONLY:
            pAC->bSystemOnly = *(ULONG*)pAVal->pVal;
            break;
        case ATT_IS_SINGLE_VALUED:
            pAC->isSingleValued = *(BOOL*)pAVal->pVal;
            break;
        case ATT_RANGE_LOWER:
            pAC->rangeLower = *(ULONG*)pAVal->pVal;
            pAC->rangeLowerPresent = TRUE;
            break;
        case ATT_RANGE_UPPER:
            pAC->rangeUpper = *(ULONG*)pAVal->pVal;
            pAC->rangeUpperPresent = TRUE;
            break;
        case ATT_LDAP_DISPLAY_NAME:
            if (SCCalloc(&pAC->name, 1, pAVal->valLen+1)) {
                return NULL;
            }

            pAC->nameLen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pAVal->pVal,
                    (pAVal->valLen /
                     sizeof(wchar_t)),
                    pAC->name,
                    pAVal->valLen,
                    NULL,
                    NULL);

            pAC->name[pAC->nameLen] = '\0';

            break;
        case ATT_ATTRIBUTE_SYNTAX:
            syntax = 0xFF & *(unsigned*)pAVal->pVal;
            if (fNoJetCol) {
                pAC->syntax = (0xFF) & syntax;
            }
            else if ((0xFF & syntax) != pAC->syntax) {
                DPRINT1(0, "mismatched syntax on attribute %u\n", aid);
            }
            break;
        case ATT_OM_SYNTAX:
            pAC->OMsyntax = *(int*)pAVal->pVal;
            break;
        case ATT_OM_OBJECT_CLASS:
            if (SCCalloc(&pAC->OMObjClass.elements, 1, pAVal->valLen)) {
                return NULL;
            }
            pAC->OMObjClass.length = pAVal->valLen;
            memcpy(pAC->OMObjClass.elements,
                   pAVal->pVal,
                   pAVal->valLen);
            break;
        case ATT_MAPI_ID:
            pAC->ulMapiID= *(ULONG*)pAVal->pVal;
            break;
        case ATT_LINK_ID:
            pAC->ulLinkID= *(ULONG*)pAVal->pVal;
            break;
        case ATT_ATTRIBUTE_ID:
        case ATT_MS_DS_INTID:
            break;
        case ATT_SEARCH_FLAGS:
            pAC->fSearchFlags = *(DWORD*)pAVal->pVal;
            break;
        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            memcpy(&pAC->propGuid, pAVal->pVal, sizeof(pAC->propGuid));
            Assert(pAVal->valLen == sizeof(pAC->propGuid));
            break;
        case ATT_OBJECT_GUID:
            // Needed to choose a winner when rdnattids collide
            memcpy(&pAC->objectGuid, pAVal->pVal, sizeof(pAC->objectGuid));
            Assert(pAVal->valLen == sizeof(pAC->objectGuid));
            break;
        case ATT_ATTRIBUTE_SECURITY_GUID:
            // The GUID for the attributes property set used for security checks
            memcpy(&pAC->propSetGuid, pAVal->pVal, sizeof(pAC->propSetGuid));
            Assert(pAVal->valLen == sizeof(pAC->propSetGuid));
            break;
        case ATT_EXTENDED_CHARS_ALLOWED:
            pAC->bExtendedChars = (*(DWORD*)pAVal->pVal?1:0);
            break;
        case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
            if (*(DWORD*)pAVal->pVal)
            {
                pAC->bMemberOfPartialSet = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            pAC->bDefunct = (*(DWORD*)pAVal->pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_NOT_REPLICATED) {
                pAC->bIsNotReplicated = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER) {
                pAC->bMemberOfPartialSet = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_CONSTRUCTED) {
                pAC->bIsConstructed = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_OPERATIONAL) {
                pAC->bIsOperational = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pAC->bIsBaseSchObj = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_RDN) {
                pAC->bIsRdn = TRUE;
                pAC->bFlagIsRdn = TRUE;
            }
            break;
        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp),
                     0, 0);
        }
        THFreeEx(pTHS, pAVal->pVal);
        THFreeEx(pTHS, pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);

    // Backlinks should have their system flags set to indicate they are not
    // replicated.
    Assert(!FIsBacklink(pAC->ulLinkID) || pAC->bIsNotReplicated);

    // assign names of commonly used indexes when searching with
    // fSearchFlags fPDNTATTINDEX, fATTINDEX and fTUPLEINDEX
    if (pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX | fTUPLEINDEX)) {
        // set ATTINDEX
        if (pAC->fSearchFlags & fATTINDEX) {

            // this should be NULL
            Assert (pAC->pszIndex == NULL);

            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE, szIndexName, MAX_INDEX_NAME);
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszIndex, 1, lenIndexName)) {
                return NULL;
            }
            memcpy (pAC->pszIndex, szIndexName, lenIndexName);
        }

        // set PDNTATTINDEX
        if (pAC->fSearchFlags & fPDNTATTINDEX) {

            // this should be NULL
            Assert (pAC->pszPdntIndex == NULL);

            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));

            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszPdntIndex, 1, lenIndexName)) {
                return NULL;
            }
            memcpy (pAC->pszPdntIndex, szIndexName, lenIndexName);
        }

        // set TUPLEINDEX
        if (pAC->fSearchFlags & fTUPLEINDEX) {

            // this should be NULL
            Assert (pAC->pszTupleIndex == NULL);

            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));

            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszTupleIndex, 1, lenIndexName)) {
                return NULL;
            }
            memcpy (pAC->pszTupleIndex, szIndexName, lenIndexName);
        }
    }

    // Is this marked as ANR and indexed over the whole tree?
    if (((pAC->fSearchFlags & (fANR | fATTINDEX)) == (fANR | fATTINDEX)) &&
        (!pAC->bDefunct)) {
        // only add this as an ANR attr if the index actually exists or we will
        // end up walking the ancestry until it is created which may take a
        // very long time
        JET_INDEXID idx;
        if(JetGetTableIndexInfo(pTHS->pDB->JetSessID,
                              pTHS->pDB->JetObjTbl,
                              pAC->pszIndex,
                              &idx,
                              sizeof(idx),
                              JET_IdxInfoIndexId) == JET_errSuccess ) {
            SCAddANRid(aid);
        }
    }

    if ( SCAddAttSchema (pTHS, pAC, fNoJetCol, FALSE)) {
       // error adding  attcache to hash tables. Fatal
       // Who frees pAC?
       return NULL;
    }

    return pAC;
}

/*
 * Walk an ATTR structure and adds all the unsigned values into an array
 * puCount && pauVal are in/out parameters
 *
 * Return Value:
 *    0 on success
 *    non-0 on alloc failure
 */
int GetValList(ULONG * puCount, ULONG **pauVal, ATTR *pA)
{
    ULONG u;
    ATTRVAL *pAV;
    ULONG *pau;
    ULONG   StartCount= *puCount;
    ULONG*  const StartList = *pauVal;
    ULONG*  StartListTmp = StartList;
    ULONG   NewCount = (ULONG) pA->AttrVal.valCount;


    *puCount += NewCount;
    if (SCCalloc(&pau, 1, (*puCount)*sizeof(ULONG))) {
        *puCount = 0;
        *pauVal = NULL;
        return DSID(FILENO, __LINE__);
    }
    *pauVal = pau;

    for (u=0;u<StartCount;u++)
    {
        *pau++ = *StartListTmp++;
    }

    pAV = pA->AttrVal.pAVal;
    for (u=0; u<NewCount; u++) {
        *pau = *(ULONG*)pAV->pVal;
        ++pAV;
        ++pau;
    }

    SCFree((VOID **)&StartList);

    return 0;
}



/*
 * Helper routine to cache last default SD converted during classcache load,
 * so that we do not call the advapi functions all the time. Major perf
 * gain since most of the default SDs in the schema are same anyway
 *
 * Arguments:
 *    pTHS - pointer th thread state
 *    pStrSD - string SD to convert
 *    ppSDBuf - pointer to pointer to return converted SD
 *    pSDLen - pointer to return size of converted SD
 *
 * Return Value:
 *    TRUE if the conversion succeeds, FALSE otherwise
 *    Note: The function returns false only if the advapi call fails
 */

BOOL  CachedConvertStringSDToSDRootDomainW(
    THSTATE *pTHS,
    WCHAR   *pStrSD,
    PSECURITY_DESCRIPTOR *ppSDBuf,
    ULONG *pSDLen
)
{

    unsigned len;
    BOOL flag;
    CACHED_SD_INFO *pCachedSDInfo = (CACHED_SD_INFO *) pTHS->pCachedSDInfo;

    // If the first conversion, create the structure in the thread state
    if (pCachedSDInfo == NULL) {
       pTHS->pCachedSDInfo = pCachedSDInfo =
            (CACHED_SD_INFO *) THAllocEx( pTHS, sizeof(CACHED_SD_INFO));
    }

    len = wcslen(pStrSD);
    if ( (len == pCachedSDInfo->cCachedStringSDLen)
           && (0 == memcmp(pStrSD, pCachedSDInfo->pCachedStringSD, len*sizeof(WCHAR))) ) {
        // same as the cached SD
        flag = TRUE;
    }
    else {
        // not the same SD as last time
        if (pCachedSDInfo->pCachedSD) {
           // this is local alloc'ed by the advapi routine

           LocalFree(pCachedSDInfo->pCachedSD);
           pCachedSDInfo->pCachedSD = NULL;
           pCachedSDInfo->cCachedSDSize = 0;
        }
        if (pCachedSDInfo->pCachedStringSD) {
           THFreeEx(pTHS, pCachedSDInfo->pCachedStringSD);
           pCachedSDInfo->pCachedStringSD = NULL;
           pCachedSDInfo->cCachedStringSDLen = 0;
        }

        // make the advapi call to convert the string SD
        flag =  ConvertStringSDToSDRootDomainW( gpRootDomainSid,
                                                pStrSD,
                                                SDDL_REVISION_1,
                                                &(pCachedSDInfo->pCachedSD),
                                                &(pCachedSDInfo->cCachedSDSize) );
        if (flag) {
           // we succeeded, remember the arguments
           pCachedSDInfo->pCachedStringSD = (WCHAR *) THAllocEx(pTHS, len*sizeof(WCHAR));
           memcpy(pCachedSDInfo->pCachedStringSD, pStrSD, len*sizeof(WCHAR));
           pCachedSDInfo->cCachedStringSDLen = len;
        }
        else {
           // the conversion failed. Forget everything
           if (pCachedSDInfo->pCachedStringSD) {
              THFreeEx(pTHS, pCachedSDInfo->pCachedStringSD);
           }
           if (pCachedSDInfo->pCachedSD) {
              LocalFree(pCachedSDInfo->pCachedSD);
           }
           pCachedSDInfo->pCachedStringSD = NULL;
           pCachedSDInfo->cCachedStringSDLen = 0;
           pCachedSDInfo->pCachedSD = NULL;
           pCachedSDInfo->cCachedSDSize = 0;

           DPRINT(0,"Failed to convert default SD in CachedConvertStringSDToSDRootDomainW\n");

       }
    }

    if (flag) {
       // No matter how we got here, if flag is set then we want to copy
       // the cached SD.
       *ppSDBuf = THAllocEx(pTHS, pCachedSDInfo->cCachedSDSize);
       memcpy (*ppSDBuf, pCachedSDInfo->pCachedSD, pCachedSDInfo->cCachedSDSize);
       *pSDLen = pCachedSDInfo->cCachedSDSize;
    }

    return flag;
}

VOID
ModifyDefaultSDForNDNC(
    IN THSTATE * pTHS,
    IN PSECURITY_DESCRIPTOR pSDIn,
    IN ULONG cbSDIn,
    IN PSID pDomainSID,
    IN DSNAME *pObject,
    OUT PSECURITY_DESCRIPTOR * ppSDOut,  // THAlloc'd
    OUT ULONG * pcbSDOut
    )
{

    PACL    pAcl = NULL;
    DWORD   i                     = 0;
    DWORD   AceCount              = 0;
    DWORD   Index                 = 0;
    DWORD   Ignore                = 0;
    PVOID   Ace                   = NULL;
    GUID  * ObjectTypeInAce       = NULL;
    BOOL    bAceApplicable        = FALSE;
    SID   * SidInAce              = NULL;
    NT4SID  SidToSearch;
    DWORD   err                   = 0;
    NTSTATUS NtStatus;
    PSID   pEnterpriseControllersSid = NULL;
    SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;
    ACCESS_MASK AccessMask;

    *ppSDOut = THAllocEx(pTHS, cbSDIn);
    *pcbSDOut = cbSDIn;
    memcpy(*ppSDOut, pSDIn, cbSDIn);

    __try {
	pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSDIn);
	if (pAcl==NULL) {
	    // the default ACL has been modified to full control!
	    // NULL represents full control - there is no reason to
	    // add any ACE's when all access we could add are already allowed
	    // - unless of course this is an error - assume it's not, but warn the user!
	    err = 0;

	    LogEvent(DS_EVENT_CAT_SCHEMA,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_SCHEMA_CLASS_DEFAULT_SD_MISSING,
		     NULL, NULL, NULL);
	    __leave;
	}

	AceCount = pAcl->AceCount;

	for (i = 0, Ace = FirstAce(pAcl);
	     (i < AceCount);
	     i++, Ace = NextAce(Ace)) {
	    if (((PACE_HEADER) Ace)->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) {
		ObjectTypeInAce = RtlObjectAceObjectType(Ace);
		SidInAce = RtlObjectAceSid(Ace);
		if (!ObjectTypeInAce) {
		    continue;
		}


		SampBuildNT4FullSid(pDomainSID,
				    DOMAIN_GROUP_RID_CONTROLLERS,
				    &SidToSearch);

		if (RtlpIsEqualGuid(ObjectTypeInAce, &RIGHT_DS_REPL_GET_CHANGES_ALL) &&
		    EqualSid(SidInAce, &SidToSearch)) {
		    // we've got our man!
		    // delete this ace and add an identical one with ED instead of DD.
		    NtStatus = RtlAllocateAndInitializeSid( &ntAuthority,
							    1,
							    SECURITY_ENTERPRISE_CONTROLLERS_RID,
							    0, 0, 0, 0, 0, 0, 0,
							    &pEnterpriseControllersSid );

		    if ( NtStatus != ERROR_SUCCESS )
			{
			err = RtlNtStatusToDosError(NtStatus);
			LogEvent(DS_EVENT_CAT_SCHEMA,
				 DS_EVENT_SEV_ALWAYS,
				 DIRLOG_SCHEMA_CLASS_EDC_SID_FAILURE,
				 szInsertWin32Msg(err), err, szInsertDN(pObject));
			__leave;
		    }

		    AccessMask = ((PKNOWN_OBJECT_ACE)Ace)->Mask;

		    // delete first.  Since the SID for Enterprise Domain controllers is smaller than
		    // the sid for Domain domain controllers, we won't need to increase the space allocation
		    // for the ACL in the security descriptor.
		    if (!DeleteAce(RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) *ppSDOut), i)) {
			err = GetLastError();
			Assert(!"Wasn't able to delete ACE for NDNC!");
			// error!  Log, then continue, not fatal
			LogEvent(DS_EVENT_CAT_SCHEMA,
				 DS_EVENT_SEV_ALWAYS,
				 DIRLOG_SCHEMA_CLASS_DDC_REMOVE_FAILURE,
				 szInsertWin32Msg(err), err, szInsertDN(pObject));

			err = ERROR_SUCCESS; // continue...
		    }

		    if (!AddAccessAllowedObjectAce(
			RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) *ppSDOut),
			ACL_REVISION_DS,
			CONTAINER_INHERIT_ACE,
			AccessMask,
			ObjectTypeInAce,
			NULL,
			pEnterpriseControllersSid)) {
			Assert(!"Wasn't able to add new ACE for NDNC!");
			err = GetLastError();
			LogEvent(DS_EVENT_CAT_SCHEMA,
				 DS_EVENT_SEV_MINIMAL,
				 DIRLOG_SCHEMA_CLASS_EDC_ACE_CREATE_FAILURE,
				 szInsertWin32Msg(err), err, szInsertDN(pObject));
			__leave;
		    }
		    err = ERROR_SUCCESS;
		    __leave;
		}
	    }
	}
	err = ERROR_OBJECT_NOT_FOUND;
    }
    __finally {
	if (err!=ERROR_SUCCESS) {
	    LogEvent(DS_EVENT_CAT_SCHEMA,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_SCHEMA_CLASS_DEFAULT_MOD_FAILED,
		     szInsertWin32Msg(err), szInsertUL(err), szInsertDN(pObject));
	}
    }
}

DWORD
SCGetDefaultSD(
    IN  THSTATE *          pTHS,
    IN  CLASSCACHE *       pCC,
    IN  PSID               pDomainSid,
    IN  BOOL               fIsNDNC,
    IN  DSNAME           * pObject,
    OUT PSECURITY_DESCRIPTOR *  ppSD,  // THAlloc'd
    OUT ULONG *            pcbSD
    )
{
    PSECURITY_DESCRIPTOR     pSDTemp = NULL;
    ULONG                    cbSDTemp = 0;
    ULONG                    ulErr;

    // Sid should be provided or not, not partially provided ;)
    Assert(pDomainSid == NULL ||
           IsValidSid(pDomainSid));
    // Check and NULL out parameters.
    Assert(ppSD && *ppSD == NULL);
    Assert(pcbSD && *pcbSD == 0);
    *ppSD = NULL;
    *pcbSD = 0;

    // Either were using the provided domain SID, OR  we're using our
    // default domain SID.
    Assert(!pDomainSid || gAnchor.pDomainDN);

    // This is invalid only once during install.
    Assert(DsaIsInstalling() || gAnchor.pDomainDN->SidLen > 0);

    if(pDomainSid == NULL ||
       (IsValidSid(&gAnchor.pDomainDN->Sid) &&
        IsValidSid(pDomainSid) &&
        RtlEqualSid(&gAnchor.pDomainDN->Sid, pDomainSid))){

        // The SID is that of the DCs domain SID or there is no SID
        // provided so just returned the cached value.

	if (fIsNDNC) {
	    ModifyDefaultSDForNDNC(
		pTHS,
		pCC->pSD,
		pCC->SDLen,
		pDomainSid,
                pObject,
		ppSD,
		pcbSD
		);
	}
	else {
	    *ppSD = pCC->pSD;
	    *pcbSD = pCC->SDLen;
	}

    } else {

        // This is the interesting case, the SID of the domain here is
        // not that of the default domain.

        // Get the String Default Security Descriptor and cache it if
        // we don't have it already.
        if(!pCC->pStrSD){
            Assert(!"This should never happen, all the String SDs are loaded at schema init.\n");
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_CODE_INCONSISTENCY, ERROR_INVALID_PARAMETER);
            return(pTHS->errCode);
        }
        Assert(pCC->pStrSD);

        // This is a special version of ConvertStringSDToSD() that takes a domain
        // argument too.
        if(!ConvertStringSDToSDDomainW(pDomainSid, NULL, pCC->pStrSD, SDDL_REVISION_1,
                                       &pSDTemp, &cbSDTemp)){
            // NOTE: Out of memory doesn't return an error code.
            ulErr = GetLastError();
#if DBG
            if(ulErr != ERROR_NOT_ENOUGH_MEMORY){
                DPRINT1(0,"Default SD conversion failed, error %x\n", ulErr);
                Assert(!"Default security descriptor conversion failed, and we're not out of "
                        "memory why?  If the string SD was bad, someone should talk to the "
                        "schema folks about why they've got a bad string SD in a schema definition.");
            }
#endif
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_STRING_SD_CONVERSION_FAILED, ulErr);
            return(pTHS->errCode);
        }

        __try {
            // ConvertStringSDToSDDomain returns a self-relative SD
            Assert(RtlValidRelativeSecurityDescriptor(pSDTemp, cbSDTemp, 0));

            // allocate and copy into thread allocated memory, so it disappears
            // after the add operation.  If we're looking at an NDNC, modify the
	    // security descriptor since the default is wrong for that object.
	    if (fIsNDNC) {
		ModifyDefaultSDForNDNC(
		    pTHS,
		    pSDTemp,
		    cbSDTemp,
		    pDomainSid,
                    pObject,
		    ppSD,
		    pcbSD
		    );
	    } else {
		*ppSD = THAllocEx(pTHS, cbSDTemp);
		*pcbSD = cbSDTemp;
		memcpy(*ppSD, pSDTemp, cbSDTemp);
	    }
        } __finally {
            LocalFree(pSDTemp);
        }
    }

    Assert(!pTHS->errCode);
    return(pTHS->errCode);
}



/*
 * Add a single class definition to the schema cache, given the data
 * from the DMD object.
 *
 * N.B. This routine works in parallel with SCBuildCCEntry.  scAddClass
 *      takes the input description as an ENTINF, while SCBuildCCEntry
 *      takes the input as a positioned record in the DIT.  Any changes
 *      made to one routine must be made to the other.
 */
CLASSCACHE*
scAddClass(THSTATE *pTHS,
           ENTINF *pEI)
{
    CLASSCACHE *pCC;
    ULONG       i;
    ULONG       err;

    /* allocate a classcache object */
    if (SCCalloc(&pCC, 1, sizeof(CLASSCACHE))) {
        return NULL;
    }

    // Now walk the attrblock and add the appropriate fields to the CC
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_DEFAULT_SECURITY_DESCRIPTOR:
          {

            // A default security descriptor.  We need to copy this value to
            // long term memory and save the size.
            // But this is a string. We first need to convert. It
            // is a wide-char string now, but we need to null-terminate
            // it for the security conversion. Yikes! This means I
            // have to realloc for that one extra char!

            UCHAR *sdBuf = NULL;

            pCC->cbStrSD = pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen + sizeof(WCHAR);
            if (SCCalloc(&pCC->pStrSD, 1, pCC->cbStrSD)) {
                pCC->cbStrSD = 0;
                return(NULL);
            } else {
                memcpy(pCC->pStrSD,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen);
                pCC->pStrSD[(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen)/sizeof(WCHAR)] = L'\0';
            }

            // Hammer the default SD on cached classes when running as
            // dsamain.exe w/security disabled and unit tests enabled.
            DEFAULT_SD_FOR_EXE(pTHS, pCC)

            if (!CachedConvertStringSDToSDRootDomainW
                 (
                   pTHS,
                   pCC->pStrSD,
                  (PSECURITY_DESCRIPTOR*) &sdBuf,
                  &(pCC->SDLen)
                  )) {
                // Failed to convert.

                //
                // If we're running because of mkdit or any other exe type app,
                // like dsatest or the semantic checker then this is ok.
                //

                if ( gfRunningAsExe ) {
                    // We're running under mkdit or some such.  Of course that
                    // didn't work.  Just skip it.
                    pCC->pSD = NULL;
                    pCC->SDLen = 0;
                }
                else {
                    err = GetLastError();
                    pCC->pSD = NULL;
                    pCC->SDLen = 0;
                    LogEvent8(DS_EVENT_CAT_SCHEMA,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_SCHEMA_SD_CONVERSION_FAILED,
                              szInsertWC(pCC->pStrSD),
                              szInsertWC(pEI->pName->StringName),
                              szInsertInt(err),
                              szInsertWin32Msg(err),
                              NULL, NULL, NULL, NULL );
                    // if heuristics reg key says to ignore bad default SDs
                    // and go on, do so
                    if (gulIgnoreBadDefaultSD) {
                       continue;
                    }

                    // otherwise, raise error and return
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_STRING_SD_CONVERSION_FAILED, err);
                    DPRINT1(0,"Default SD conversion failed, error %x\n",err);
                    Assert(!"Default security descriptor conversion failed");
                    return NULL;
                }
            }
            else {
                // Converted successfully

                if (SCCalloc(&pCC->pSD, 1, pCC->SDLen)) {
                    if (NULL!=sdBuf) {
                        THFreeEx(pTHS, sdBuf);
                        sdBuf = NULL;
                    }
                    return NULL;
                }
                else {
                    memcpy(pCC->pSD, sdBuf, pCC->SDLen);
                }

                if (NULL!=sdBuf) {
                    THFreeEx(pTHS, sdBuf);
                    sdBuf = NULL;
                }

            }

        }

           break;
        case ATT_RDN_ATT_ID:
            // This is only true for attributes created before whistler
            // beta3 and base schema attributes. The real RdnIntId is
            // finalized in scFixRdnAttId and scFixCollisions after
            // the rdn attrs are resurrected and collisions resolved
            pCC->RdnExtId = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            pCC->RdnIntId = pCC->RdnExtId;
            pCC->RDNAttIdPresent = TRUE;
            break;
        case ATT_LDAP_DISPLAY_NAME:
            if (SCCalloc(&pCC->name, 1, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen+1)) {
                return NULL;
            }
            pCC->nameLen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                    (pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen  /
                     sizeof(wchar_t)),
                    pCC->name,
                    pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen,
                    NULL,
                    NULL);

            pCC->name[pCC->nameLen] =  '\0';
            break;
        case ATT_SYSTEM_ONLY:
            pCC->bSystemOnly =
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_DEFAULT_HIDING_VALUE:
            pCC->bHideFromAB =
                *(BOOL*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_GOVERNS_ID:
            pCC->ClassId = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;

        case ATT_SYSTEM_MAY_CONTAIN:
        case ATT_MAY_CONTAIN:
            if ( GetValList(&pCC->MayCount, &(pCC->pMayAtts),
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if ( GetValList(&pCC->MyMayCount, &(pCC->pMyMayAtts),
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            break;

        case ATT_SYSTEM_MUST_CONTAIN:
        case ATT_MUST_CONTAIN:
            if ( GetValList(&pCC->MustCount, &pCC->pMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if ( GetValList(&pCC->MyMustCount, &pCC->pMyMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            break;
        case ATT_SUB_CLASS_OF:
            if ( GetValList(&pCC->SubClassCount, &pCC->pSubClassOf,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if(pCC->SubClassCount > 1)
                    pCC->bUsesMultInherit = 1;

            // ATT_SUB_CLASS_OF is single-valued, so there will be only
            // one value stored in the dit
            pCC->MySubClass = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_OBJECT_CLASS_CATEGORY:
            pCC->ClassCategory=
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_DEFAULT_OBJECT_CATEGORY:

            if (SCCalloc(&pCC->pDefaultObjCategory, 1, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen)) {
                return NULL;
            }
            memcpy(pCC->pDefaultObjCategory,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen);
            break;

        case ATT_SYSTEM_AUXILIARY_CLASS:
        case ATT_AUXILIARY_CLASS:
            if ( GetValList(&pCC->AuxClassCount, &pCC->pAuxClass,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            break;
        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            memcpy(&pCC->propGuid,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->propGuid));
            Assert(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen ==
                   sizeof(pCC->propGuid));
            break;

        case ATT_OBJECT_GUID:
            // Used to choose a winner when OIDs collide
            memcpy(&pCC->objectGuid,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->objectGuid));
            Assert(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen ==
                   sizeof(pCC->objectGuid));
            break;

        case ATT_SYSTEM_POSS_SUPERIORS:
        case ATT_POSS_SUPERIORS:
            if ( GetValList(&pCC->PossSupCount, &pCC->pPossSup,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if ( GetValList(&(pCC->MyPossSupCount), &(pCC->pMyPossSup),
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            break;
        case ATT_IS_DEFUNCT:
            pCC->bDefunct =
                (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pCC->bIsBaseSchObj = TRUE;
            }
            break;

        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp), 0, 0);
        }
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal);
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);

    if (SCAddClassSchema (pTHS, pCC)) {
      // error adding classcache to hash tables. Fatal
      return NULL;
    }

    return pCC;
}


DWORD scFillInSchemaInfo(THSTATE *pTHS)
{
    DBPOS *pDB=NULL;
    DWORD err=0;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    ULONG cLen;
    UCHAR *pBuf;
    SCHEMAPTR *pSchemaPtr = (SCHEMAPTR *) pTHS->CurrSchemaPtr;

    DBOpen2(TRUE, &pDB);
    __try {
       // Schema cache is loaded and hence gAnchor.pDMD is defined at
       // this point

       if (gAnchor.pDMD == NULL) {
              DPRINT(0, "Couldn't find DMD name/address to load\n");
              err = DSID(FILENO, __LINE__);
              __leave;
          }

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen2 returns non-NULL pDB or throws an exception
      if( err = DBFindDSName(pDB, gAnchor.pDMD) ) {
        DPRINT(0, "Cannot find DMD in dit\n");
        __leave;
      }

      ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
      if (ac==NULL) {
          // messed up schema
          DPRINT(0, "scFillInSchemaInfo: Cannot retrive attcache for schema info\n");
          err = ERROR_DS_MISSING_EXPECTED_ATT;
           __leave;
       }
       // Read the Schema Info
       err = DBGetAttVal_AC(pDB, 1, ac, DBGETATTVAL_fREALLOC,
                            0, &cLen, (UCHAR **) &pBuf);
       switch (err) {
            case DB_ERR_NO_VALUE:
               // copy the default info
               memcpy(pSchemaPtr->SchemaInfo, INVALID_SCHEMA_INFO, SCHEMA_INFO_LENGTH);
               err = 0;
               break;
            case 0:
               // success! we got the value in pBuf
               Assert(cLen == SCHEMA_INFO_LENGTH);
               memcpy(pSchemaPtr->SchemaInfo, pBuf, SCHEMA_INFO_LENGTH);
               break;
            default:
               // Some other error!
               __leave;
        } /* switch */
    }
    __finally {
        if (0 == err) {
            fCommit = TRUE;
        }
        DBClose(pDB,fCommit);
    }

    return err;
}




/*
 * Create indexes synchronously.
 * Parameter pItem points to the request (see sccacheschema3).
 *
 * This function can be called directly from sccacheschema3
 * when the schema cache is loaded first time after boot,
 * or from SCIndexCreationThread() to create indices async.
 *
 */
void
CreateIndices (INDEX_CREATION_REQUEST * pItem)
{
    int err, dwErr;
    ATTR_TO_INDEX *pAttr, *pTmp;
    THSTATE * pTHS = pTHStls;           // Just for speed.
    DBPOS * pDB = NULL;
    BOOL fMissing;
    BOOL fMissingANR;
    CHAR szIndexName [MAX_INDEX_NAME];      //used to create cached index names


    if (!pItem) {
        return;
    }

    pAttr = pItem->pAttrs;

    while (pAttr) {

        if (eServiceShutdown)
        {
            //
            // The system is shutting down.
            //
            return;
        }

        //
        // check if the index is already built
        //

        fMissing = FALSE;
        fMissingANR = FALSE;
        dwErr = 0;

        __try {
            DBOpen2(FALSE, &pDB);

            __try{
                if(pAttr->fIndexMask & fATTINDEX) {
                    // needs a normal index
                    Assert (pAttr->pAC->pszIndex != NULL);
                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAttr->pAC->pszIndex     )) {
                        LogEvent8(DS_EVENT_CAT_SCHEMA,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_SCHEMA_INDEX_NEEDED,
                                  szInsertSz(pAttr->pAC->name),
                                  szInsertSz(pAttr->pAC->pszIndex),
                                  szInsertJetErrCode(err),
                                  szInsertJetErrMsg(err),
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

                        fMissing = TRUE;
                        fMissingANR = fMissingANR || (pAttr->pAC->fSearchFlags & fANR);
                    }
                }
                if(pAttr->fIndexMask & fTUPLEINDEX) {
                    // needs a tuple index
                    Assert (pAttr->pAC->pszTupleIndex != NULL);
                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAttr->pAC->pszTupleIndex     )) {
                        LogEvent8(DS_EVENT_CAT_SCHEMA,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_SCHEMA_INDEX_NEEDED,
                                  szInsertSz(pAttr->pAC->name),
                                  szInsertSz(pAttr->pAC->pszTupleIndex),
                                  szInsertJetErrCode(err),
                                  szInsertJetErrMsg(err),
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

                        fMissing = TRUE;
                    }
                }
                if(pAttr->fIndexMask & fPDNTATTINDEX) {

                    ULONG j;

                    // needs a PDNT index
                    Assert (pAttr->pAC->pszPdntIndex != NULL);

                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAttr->pAC->pszPdntIndex      )) {
                        LogEvent8(DS_EVENT_CAT_SCHEMA,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_SCHEMA_INDEX_NEEDED,
                                  szInsertSz(pAttr->pAC->name),
                                  szInsertSz(pAttr->pAC->pszPdntIndex),
                                  szInsertJetErrCode(err),
                                  szInsertJetErrMsg(err),
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

                        fMissing = TRUE;
                    }

                    for(j=1; j<=gAnchor.ulNumLangs; j++) {
                        DBGetIndexName (pAttr->pAC,
                                        fPDNTATTINDEX,
                                        gAnchor.pulLangs[j],
                                        szIndexName, sizeof (szIndexName));

                        if(err=JetSetCurrentIndex(pDB->JetSessID,
                                                  pDB->JetObjTbl,
                                                  szIndexName      )) {
                            LogEvent8(DS_EVENT_CAT_SCHEMA,
                                      DS_EVENT_SEV_ALWAYS,
                                      DIRLOG_SCHEMA_INDEX_NEEDED,
                                      szInsertSz(pAttr->pAC->name),
                                      szInsertSz(szIndexName),
                                      szInsertJetErrCode(err),
                                      szInsertJetErrMsg(err),
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
                            fMissing = TRUE;
                        }
                    }
                }
            }
            __finally{
                // close the DBPOS,
                // as later DBAddColIndex need to work at level 0
                DBClose(pDB,TRUE);
                pDB = NULL;

            }

            if (!fMissing) {
                // The index could have already been created,
                // Don't do it again.
                DPRINT1(1, "Index creation for %s is skipped, because the index exists.\n", pAttr->pAC->name);
                goto nextItem;
            }


            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_SCHEMA_CREATING_INDEX,
                     szInsertUL(pAttr->pAC->id),
                     pAttr->pAC->name,
                     0);

            err = DBAddColIndex(pAttr->pAC,
                                pAttr->fIndexMask,
                                JET_bitIndexIgnoreAnyNull);

            if(err) {
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_SCHEMA_CREATE_INDEX_FAILED,
                          szInsertUL(pAttr->pAC->id),
                          szInsertSz(pAttr->pAC->name),
                          szInsertJetErrCode(err),
                          szInsertJetErrMsg(err),
                          NULL,
                          NULL,
                          NULL,
                          NULL );

                // schedule a retry
                if (DsaIsRunning()) {
                   SCSignalSchemaUpdateLazy();
                }
            }
            else {

                LogEvent(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_SCHEMA_INDEX_CREATED,
                         szInsertUL(pAttr->pAC->id),
                         szInsertSz(pAttr->pAC->name),
                         0);
            }

        }
        __except(HandleMostExceptions(dwErr = GetExceptionCode()))
        {
            DPRINT1(0,"NTDS CreateIndices: Exception %d\n",dwErr);
        }

        if ((fMissingANR || dwErr) && DsaIsRunning()) {
            // schedule a retry
            SCSignalSchemaUpdateLazy();
        }

nextItem:
        pTmp = pAttr;
        pAttr = pAttr->pNext;
        SCFreeAttcache(&pTmp->pAC);
        SCFree(&pTmp);
    }
    SCFree(&pItem);
}

/*
 * Create the indices asynchronously.
 * This function will pass the request to SCIndexCreationThread
 * to create the indices, if SCIndexCreationThread is running;
 * and will begin the thread otherwise.
 *
 * Note that currently the sole caller of this function is
 * SCCacheSchema3.  If this is changed in the future,
 * the mutual exclusion mechanism need to change.
 *
 */

BOOL AsyncCreateIndices(INDEX_CREATION_REQUEST * pItem)
{

    HANDLE hThread;
    unsigned id;

    EnterCriticalSection(&csIndexCreation);

    // Note that we don't care much about the order of the items,
    // and stack is the simplest.
    pItem->pNext = gpIndexToCreateList;
    gpIndexToCreateList = pItem;

    LeaveCriticalSection(&csIndexCreation);


    if(!gfIndexThreadRunning){
        gfIndexThreadRunning = TRUE;
        hThread = (HANDLE) _beginthreadex(NULL,
                                          0,
                                          SCIndexCreationThread,
                                          NULL,
                                          0,
                                          &id);
        if (!hThread) {
            // unable to start the thread
            // Let's try again later.
            gfIndexThreadRunning = FALSE;
            if (DsaIsRunning()) {
                SCSignalSchemaUpdateLazy();
            }
            return FALSE;
        }


    }

    return TRUE;

}

/*
 * Index Creation Thread.
 *
 * Once the thread is started, it checks all the requests
 * in gpIndexToCreateList, and call CreateIndices to create
 * the indices.  When the gpIndexToCreateList is empty, the
 * thread will quit.
 *
 */

ULONG SCIndexCreationThread (PVOID pv)
{
    INDEX_CREATION_REQUEST *pCurr;
    THSTATE * pTHS;
    BOOL bRunning = gfIndexThreadRunning;


    DPRINT(2, "SCIndexCreationThread begins\n");

    pTHS=InitTHSTATE(CALLERTYPE_INTERNAL);

    if(!pTHS) {
        // Can't get the thread state,
        // signal schema reload
        if (DsaIsRunning()) {
           SCSignalSchemaUpdateLazy();
        }
        DPRINT(0,"SCIndexCreationThread cannot initialize THSTATE, and quits.\n");
        return 0;
    }

    while(!eServiceShutdown && bRunning){

        EnterCriticalSection(&csIndexCreation);

        if(gpIndexToCreateList){
            pCurr = gpIndexToCreateList;
            gpIndexToCreateList = pCurr->pNext;
        }
        else {
            // the list is empty. let's quit
            bRunning = gfIndexThreadRunning = FALSE;
        }
        LeaveCriticalSection(&csIndexCreation);

        if (bRunning) {

            CreateIndices(pCurr);
        }

    }

    free_thread_state();

    DPRINT(2, "SCIndexCreationThread exits\n");

    return 0;
}

/*
 * Make a copy of the ATTCACHE
 */

DWORD SCCopyAttcache(THSTATE * pTHS, ATTCACHE *pAC, ATTCACHE **ppACDup )
{
    if (scDupStruct(pTHS, pAC, ppACDup, sizeof(ATTCACHE))
            || scDupString(pTHS, pAC->name, &(*ppACDup)->name)
            || scDupString(pTHS, pAC->pszPdntIndex, &(*ppACDup)->pszPdntIndex)
            || scDupStruct(pTHS, pAC->pidxPdntIndex, &(*ppACDup)->pidxPdntIndex, sizeof(*pAC->pidxPdntIndex))
            || scDupString(pTHS, pAC->pszIndex, &(*ppACDup)->pszIndex)
            || scDupStruct(pTHS, pAC->pidxIndex, &(*ppACDup)->pidxIndex, sizeof(*pAC->pidxIndex))
            || scDupString(pTHS, pAC->pszTupleIndex, &(*ppACDup)->pszTupleIndex)
            || scDupStruct(pTHS, pAC->pidxTupleIndex, &(*ppACDup)->pidxTupleIndex, sizeof(*pAC->pidxTupleIndex))
            || scDupStruct(pTHS, pAC->OMObjClass.elements, &(*ppACDup)->OMObjClass.elements, pAC->OMObjClass.length))
    {
        return pTHS->errCode;
    }
    return 0;
}


/*
* Helper macros to indicate if we want cleanup or not, and if we
* want to create all indices or just selected ones.
*/

#define NO_CLEANUP  (gFirstCacheLoadAfterBoot || !DsaIsRunning())
#define DO_CLEANUP (!gFirstCacheLoadAfterBoot && DsaIsRunning())
#define CREATE_SELECTED_INDICES  (gFirstCacheLoadAfterBoot || !DsaIsRunning())
#define CREATE_ALL_INDICES (!gFirstCacheLoadAfterBoot && DsaIsRunning())


/*
* Compute transitive closure of inherited schema charactistics, and
* delete unused JET indices and columns
*
* If this is called as part of the first cache load after boot, we
* will skip most of these. Specifically, we will only verify if
* certain indices we rely on are there, and if not, create them.
* All else will be done by an async cache update later
*/
int SCCacheSchema3()
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR
    ULONG i;
    ATTCACHE * pAC;
    CHAR szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int  lenIndexName;
    DWORD *pNewIndices=NULL;
    JET_ERR err;
    ULONG exceptErr=0;
    JET_SESID jsid;
    JET_DBID jdbid;
    JET_INDEXLIST jil;
    DBPOS *pDB=NULL;
    BOOL fColDeleted = FALSE;
    INDEX_CREATION_REQUEST *pItem = NULL;
    ATTR_TO_INDEX *pAttr = NULL;


    /* This function is called from two places: LoadSchemaInfo during
     * boot/install/mkdit cache load, and from SCUpdateSchemaHelper
     * during async or blocking cache update. In the latter case,
     * we come in with no transaction open, but we need a dbpos
     * in searching for indices etc. So open a dbpos and close before
     * calling AsyncCreateIndices so that a transaction is not held in the
     * normal case when indices are built, which can potentially take
     * long (the main reason we come in without an open transaction,
     * so that we can close it inside SCCacheSchema3 wherever we want).
     * In the former case, we have a transaction open already (since
     * schema cache load is just one of many things inside the transaction,
     * but the extra DBOpen doesn't hurt much (compared to the cache load
     * time). The max transaction time here is not very important, since
     * no other client is doing anything (so no version store problem)
     * unless this is over.
     * Note that all we use is pDB->JetSessId and pDB->JetObjTbl. While
     * JetSessId is easy te get also from the thstate (thats what DBOpen
     * does too), getting JetObjTbl is slightly more complex (see DBOpen2
     * code). We could have duplicated it here, but this seems cleaner
     */
    DBOpen2(FALSE, &pDB);

    __try {  /* except */
     __try { /* finally */

        /* Quiz JET to find a table that describes the indices */
        jsid = pTHS->JetCache.sesid;
        jdbid = pTHS->JetCache.dbid;

        /* Check if we need to do cleanup this time around */

        if ( DO_CLEANUP ) {

            if (!JetGetIndexInfo(jsid,jdbid,SZDATATABLE,0,&jil,sizeof(jil),
                JET_IdxInfoList)) {
                /* We have the table we need.  We just blow off reclamation of
                 * indices if the previous call failed.
                 *
                 * Ok, now walk the table and extract info for each index.  Whenever
                 * we find an index that looks like it is created from an attribute
                 * (name starts with INDEX) put it in the list of index names to
                 * check on later.
                 */

                /* NOTE: the use of oldaid is to avoid dups in the index names.
                 * someday, if we can figure out how to get jet to skip the
                 * dups, we will get rid of the check.
                 */

                 JET_TABLEID jtid;
                 JET_RETRIEVECOLUMN ajrc[1];
                 char achIndexName[JET_cbNameMost];
                 char oldIndexName[JET_cbNameMost];
                 ULONG aid, oldaid=-1;
                 ULONG indexMask;
                 DWORD numValidIndexes = 0;

                 oldIndexName[0]=0;

                 memset(ajrc, 0, sizeof(ajrc));
                 ajrc[0].columnid = jil.columnidindexname;
                 ajrc[0].pvData = achIndexName;
                 ajrc[0].cbData = sizeof(achIndexName);
                 ajrc[0].itagSequence = 1;

                 jtid = jil.tableid;

                 JetMove(jsid, jtid, JET_MoveFirst, 0);

                 do {
                     // Check for service shutdown once every iteration
                     if (eServiceShutdown) {
                         _leave;
                     }

                     memset(achIndexName, 0, sizeof(achIndexName));
                     JetRetrieveColumns(jsid, jtid, ajrc, 1);
                     if(strcmp(achIndexName,oldIndexName)==0) {
                       /* this is the same index as last time */
                       continue;
                     }
                     else {
                       strcpy(oldIndexName,achIndexName);
                     }

                     if (!strncmp(achIndexName,
                                  SZLCLINDEXPREFIX,
                                  sizeof(SZLCLINDEXPREFIX)-1)) {
                         DWORD dwLanguage, j, fFound=FALSE;
                         /* This is a localized index. Pluck the language id off
                          * the end and see if we should keep the index.
                          */

                         if(1 != sscanf(&achIndexName[strlen(achIndexName)-7],
                                        "%lx",&dwLanguage)) {
                            exceptErr = DSID(FILENO, __LINE__);
                            _leave;
                         }

                         for(j=1; !fFound && j<=gAnchor.ulNumLangs; j++) {
                             if(gAnchor.pulLangs[j] == dwLanguage)
                                 fFound = TRUE;
                         }

                         if(!fFound) {
                            /* This lang wasn't in the list, so kill it */
                            err = JetDeleteIndex(pDB->JetSessID,
                                                 pDB->JetObjTbl,
                                                 achIndexName);
                            switch(err) {
                            case JET_errSuccess:
                                LogEvent(DS_EVENT_CAT_SCHEMA,
                                         DS_EVENT_SEV_MINIMAL,
                                         DIRLOG_SCHEMA_DELETED_LOCALIZED_INDEX,
                                         szInsertSz(achIndexName), 0, 0);
                                break;

                            default:
                                LogEvent(DS_EVENT_CAT_SCHEMA,
                                         DS_EVENT_SEV_MINIMAL,
                                         DIRLOG_SCHEMA_DELETE_LOCALIZED_INDEX_FAIL,
                                         szInsertSz(achIndexName),
                                         szInsertInt(err),
                                         szInsertJetErrMsg(err));
                                break;
                            }
                         }
                        continue;
                    }

                    if (strncmp(achIndexName,
                                SZATTINDEXPREFIX,
                                sizeof(SZATTINDEXPREFIX)-1)) {
                        /* not an att column */
                        continue;
                    }

                    /* ok, this index is based on an attribute.  Look up the attribute
                     * and make sure it needs this index.  If it doesn't, kill the
                     * index.
                    */
                    if(achIndexName[sizeof(SZATTINDEXPREFIX)-1] == 'P') {
                        indexMask = fPDNTATTINDEX;
                        aid = strtoul(&achIndexName[sizeof(SZATTINDEXPREFIX)+sizeof("P_") - 2], NULL, 16);
                    }
                    else if (achIndexName[sizeof(SZATTINDEXPREFIX)-1] == 'L') {
                        DWORD dwLanguage, j, fFound=FALSE, tmpid;
                        char tmpStr[10];

                        DPRINT1 (1, "Testing index %s\n", achIndexName);

                        memcpy (tmpStr, &achIndexName[sizeof(SZATTINDEXPREFIX)+sizeof("LP_")-2], 8);
                        tmpStr[8]=0;

                        tmpid = strtoul(tmpStr, NULL, 16);

                        DPRINT1 (1, "Found localized index for att 0x%x\n", tmpid);

                        if ( !(pAC = SCGetAttById(pTHS, tmpid)) ||
                             !(pAC->fSearchFlags & fPDNTATTINDEX) ) {
                            fFound = FALSE;
                        }
                        else {
                             /* This is a localized index. Pluck the language id off
                             * the end and see if we should keep the index.
                             */

                            if(1 != sscanf(&achIndexName[strlen(achIndexName)-3],
                                           "%lx",&dwLanguage)){
                                exceptErr = DSID(FILENO, __LINE__);
                                _leave;
                            }

                            DPRINT1 (1, "Found localized index for lang %d\n", dwLanguage);

                            for(j=1; !fFound && j<=gAnchor.ulNumLangs; j++) {
                                if(gAnchor.pulLangs[j] == dwLanguage)
                                    fFound = TRUE;
                            }
                        }

                        if(!fFound) {

                            DPRINT1 (1, "Removing index %s\n", achIndexName);
                           /* This lang wasn't in the list, so kill it */
                           err = JetDeleteIndex(pDB->JetSessID,
                                                pDB->JetObjTbl,
                                                achIndexName);
                           switch(err) {
                           case JET_errSuccess:
                               LogEvent(DS_EVENT_CAT_SCHEMA,
                                        DS_EVENT_SEV_MINIMAL,
                                        DIRLOG_SCHEMA_DELETED_LOCALIZED_INDEX,
                                        szInsertSz(achIndexName), 0, 0);
                               break;

                           default:
                               LogEvent(DS_EVENT_CAT_SCHEMA,
                                        DS_EVENT_SEV_MINIMAL,
                                        DIRLOG_SCHEMA_DELETE_LOCALIZED_INDEX_FAIL,
                                        szInsertSz(achIndexName),
                                        szInsertInt(err),
                                        szInsertJetErrMsg(err));
                               break;
                           }
                       }
                       continue;
                    }
                    else if(achIndexName[sizeof(SZATTINDEXPREFIX)-1] == 'T') {
                        indexMask = fTUPLEINDEX;
                        aid = strtoul(&achIndexName[sizeof(SZATTINDEXPREFIX)+sizeof("T_") - 2], NULL, 16);
                    }
                    else {
                        indexMask = fATTINDEX;
                        aid = strtoul(&achIndexName[sizeof(SZATTINDEXPREFIX)-1], NULL, 16);
                    }

                    if((aid !=oldaid) &&           // Not the one we just did   and
                        (!(pAC = SCGetAttById(pTHS, aid)) || // doesn't have an attribute or
                        !(pAC->fSearchFlags & indexMask))) {  // attribute is not
                                                              // indexed anymore

                        // ok, we think this needs to die, but let's make sure
                        // by looking through the list of INDICES THAT MUST NOT DIE

                        char *attname = "?";

                        if(pAC && pAC->name)
                            attname = pAC->name;

                        oldaid = aid;

                        // We never need to keep substring indexes.
                        if( (fTUPLEINDEX == indexMask) || !AttInIndicesToKeep(aid)) {

                            // Yeah, kill it.
                            err = DBDeleteColIndex(aid,indexMask);

                            switch(err) {
                            case JET_errSuccess:
                                LogEvent(DS_EVENT_CAT_SCHEMA,
                                         DS_EVENT_SEV_ALWAYS,
                                         ((fTUPLEINDEX == indexMask) ?
                                            DIRLOG_SCHEMA_DELETED_TUPLE_INDEX :
                                            DIRLOG_SCHEMA_DELETED_INDEX),
                                         szInsertSz(attname), szInsertUL(aid), 0);
                                DPRINT3(0, "Deleted index '%s' for attname = %s attid = %d\n",
                                        achIndexName, attname, aid);
                                break;

                            default:
                                LogEvent8(DS_EVENT_CAT_SCHEMA,
                                          DS_EVENT_SEV_ALWAYS,
                                          ((fTUPLEINDEX == indexMask) ?
                                             DIRLOG_SCHEMA_DELETE_TUPLE_INDEX_FAIL :
                                             DIRLOG_SCHEMA_DELETE_INDEX_FAIL),
                                          szInsertSz(attname),
                                          szInsertUL(aid),
                                          szInsertInt(err),
                                          szInsertJetErrMsg(err),
                                          NULL, NULL, NULL, NULL);
                                DPRINT4(0, "Failed to delete index '%s' attname = %s attid = %d err = %d\n",
                                        achIndexName, attname, aid, err);
                                break;
                            }
                            continue;
                        }
                    }

                    numValidIndexes++;

               } while (JetMove(jsid, jtid, JET_MoveNext, JET_bitMoveKeyNE) == 0);

               JetCloseTable(jsid, jtid);


               // we read the number of MaxTables only once
               if (gulMaxTables == 0) {
                   if (GetConfigParam(
                               DB_MAX_OPEN_TABLES,
                               &gulMaxTables,
                               sizeof(gulMaxTables))) {
                       gulMaxTables = 500;
                   }
               }

               // the number of total tables is the number of indexes in
               // the data table plus 100 to account for all the tables
               // + the indexes in the various tables + other
               numValidIndexes += 100;

               // we are only interested in increasing the number of MaxTables
               // we don't handle decreasing this number
               if (gulMaxTables < numValidIndexes) {

                   DPRINT1 (0, "Writing max open tables to registry: %d\n", numValidIndexes);

                   if (SetConfigParam (DB_MAX_OPEN_TABLES,
                                       REG_DWORD,
                                       &numValidIndexes,
                                       sizeof(numValidIndexes))) {

                       DPRINT1 (0, "Error writing max open tables to registry: %d\n", numValidIndexes);
                   }
                   else {
                       gulMaxTables = numValidIndexes;
                   }
               }
            }
        } /* DoCleanupAndCreateAllIndices */


        // Before removing unused columns and creating indices for attributes
        // that needs one but doesn't have any, make sure the searchFlag entry
        // in the attcache for each attribute in the IndicesToKeep table has
        // the correct value for the type of indices they must have. Otherwise
        // set it to the correct value so that (1) if by chance they do not have
        // the indices, it will be created in the next part and (2) searches using
        // this schema cache later will see the correct searchFlag value for
        // the indices irrespective of whether the user changes it or not

        // Do not check the last entry in the table, which is just a sentinel
        // for searches

        for (i=0; i<cIndicesToKeep-1; i++) {

            DWORD bitsToOR = 0;

            // get the attcache
            pAC = SCGetAttById(pTHS, IndicesToKeep[i].attrType);

            // these attributes must always be there in the schema
            if (!pAC) {
                // something wrong, but not fatal
                DPRINT1(0,"Cannot find attcache entry for %d\n", IndicesToKeep[i].attrType);
                continue;
            }

            // ok, got the attcache. Check the search flag value
            // In particular, check if all index bits that are supposed
            // to be there are there or not; if not, add them to searchFlags

            bitsToOR = IndicesToKeep[i].indexType & INDEX_BITS_MASK;


            if ( bitsToOR  != (pAC->fSearchFlags & INDEX_BITS_MASK) ) {

                // they are different, just bit-OR all the bits in
                // the table just in case some are missing

                pAC->fSearchFlags |= bitsToOR;


                // since we deliberately change the
                // searchFlags, we have to set the index names too

                // set ATTINDEX
                if ((pAC->fSearchFlags & fATTINDEX) && (!pAC->pszIndex)) {

                    DBGetIndexName (pAC,
                                    fATTINDEX,
                                    DS_DEFAULT_LOCALE,
                                    szIndexName, sizeof (szIndexName));
                    lenIndexName = strlen (szIndexName) + 1;
                    if (SCCalloc(&pAC->pszIndex, 1, lenIndexName)) {
                        exceptErr = DSID(FILENO, __LINE__);
                        _leave;
                    }
                    memcpy (pAC->pszIndex, szIndexName, lenIndexName);
                }

                // set PDNTATTINDEX
                if ((pAC->fSearchFlags & fPDNTATTINDEX) &&
                                              (!pAC->pszPdntIndex)) {

                    DBGetIndexName (pAC,
                                    fPDNTATTINDEX,
                                    DS_DEFAULT_LOCALE,
                                    szIndexName, sizeof (szIndexName));
                    lenIndexName = strlen (szIndexName) + 1;
                    if (SCCalloc(&pAC->pszPdntIndex, 1, lenIndexName)) {
                        exceptErr = DSID(FILENO, __LINE__);
                        _leave;
                    }
                    memcpy (pAC->pszPdntIndex, szIndexName, lenIndexName);
                }
            }

        }


        /* remove unused columns and make list of indices to create */
        for (i=0; i<ATTCOUNT; i++) {
            pAC = (ATTCACHE*)(ahcId[i].pVal);
            if (pAC == FREE_ENTRY) {
                continue;
            }

            if (eServiceShutdown)
            {
                _leave;
            }

            if ( (ahcId[i].pVal && !(pAC->name))
                     // temporary cleanup code since we allowed creation of
                     // columns for these also in mkdit code. Fixed with this.
                     // Take this condition off after B3 RC1
                     || (pAC && pAC->jColid && (pAC->bIsConstructed || pAC->ulLinkID)) ) {
                /* looks like dead att */
                /* cleanup if asked for */
                if (NO_CLEANUP) {
                    // we want to defer cleanup
                    continue;
                }

                if (ahcId[i].pVal && !(pAC->name)) {
                    err = JET_errColumnInUse;
                }
                else {
                    err = DBDeleteCol(pAC->id, pAC->syntax);
                }

                switch(err) {
                case JET_errSuccess:
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_SCHEMA_DELETED_COLUMN,
                        szInsertUL(pAC->jColid), szInsertUL(pAC->id), 0);

                    // remember that we deleted at least one column this time
                    fColDeleted = TRUE;

                    break;
                case JET_errColumnInUse:
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_SCHEMA_DELETED_COLUMN_IN_USE,
                        szInsertUL(pAC->jColid), szInsertUL(pAC->id), 0);
                    break;

                default:
                    LogEvent8(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
                        szInsertUL(pAC->jColid),
                        szInsertUL(pAC->id),
                        szInsertInt(err),
                        szInsertJetErrMsg(err),
                        NULL, NULL, NULL, NULL);
                    break;
                }

            }
            else if(pAC && pAC->fSearchFlags &&
                        !(pAC->bIsConstructed) && !(pAC->ulLinkID) ) {

                DWORD fMissing = FALSE;
                DWORD MissingIndexes = 0;

                // This needs an index, does it have one?  This is done here
                // rather than at the time we add the column (scaddatt) so
                // that we can batch a list of new indices needed.

                // If we want to create just selected indices this
                // time around, check if this is one of those, else
                // just continue with the next one

                if ( CREATE_SELECTED_INDICES  &&
                    !AttInIndicesToKeep(pAC->id) ) {
                    // we don't need to create this one now even
                    // if it is missing
                    continue;
                }

                if(pAC->fSearchFlags & fATTINDEX) {
                    // needs a normal index
                    Assert (pAC->pszIndex != NULL);
                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAC->pszIndex     )) {
                        DPRINT2(0,"Need to create index %s (%d)\n", pAC->pszIndex, err);
                        fMissing = TRUE;
                        MissingIndexes |= fATTINDEX;
                    }
                }
                if(pAC->fSearchFlags & fTUPLEINDEX) {
                    // needs a tuple index
                    Assert (pAC->pszTupleIndex != NULL);
                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAC->pszTupleIndex     )) {
                        DPRINT2(0,"Need to create index %s (%d)\n", pAC->pszTupleIndex, err);
                        fMissing = TRUE;
                        MissingIndexes |= fTUPLEINDEX;

                    }

                }
                if(pAC->fSearchFlags & fPDNTATTINDEX) {

                    ULONG j;

                    // needs a PDNT index
                    Assert (pAC->pszPdntIndex != NULL);

                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAC->pszPdntIndex      )) {
                        DPRINT2(0,"Need to create index %s (%d)\n", pAC->pszPdntIndex, err);
                        fMissing = TRUE;
                        MissingIndexes |= fPDNTATTINDEX;
                    }

                    for(j=1; j<=gAnchor.ulNumLangs; j++) {
                        DBGetIndexName (pAC,
                                        fPDNTATTINDEX,
                                        gAnchor.pulLangs[j],
                                        szIndexName, sizeof (szIndexName));

                        if(err=JetSetCurrentIndex(pDB->JetSessID,
                                                  pDB->JetObjTbl,
                                                  szIndexName      )) {
                            DPRINT2(0,"Need to create index %s (%d)\n", szIndexName, err);
                            fMissing = TRUE;
                            MissingIndexes |= fPDNTATTINDEX;
                        }
                    }
                }

                if(fMissing) {

                    if(!pItem) {
                        if (SCCalloc(&pItem, 1, sizeof(INDEX_CREATION_REQUEST))) {
                            exceptErr = DSID(FILENO, __LINE__);
                            _leave;
                        }
                    }
                    if (SCCalloc(&pAttr, 1, sizeof(ATTR_TO_INDEX))){
                        exceptErr = DSID(FILENO, __LINE__);
                        _leave;
                    }
                    pAttr->fIndexMask = MissingIndexes;
                    if (SCCopyAttcache(pTHS, pAC, &(pAttr->pAC))){
                        exceptErr = DSID(FILENO, __LINE__);
                        _leave;
                    }

                    pAttr->pNext = pItem->pAttrs;
                    pItem->pAttrs = pAttr;
                    pAttr = NULL;

                }
            }
        }

     } /* try-finally */
     __finally {
          DBClose(pDB, FALSE);
     }
    } /* try-except */
    __except (HandleMostExceptions(exceptErr=GetExceptionCode())) {
        DPRINT1(0,"NTDS SCCacheSchema3: Exception %d\n",exceptErr);
    }


    if (eServiceShutdown) {
        return 0;
    }


    if (exceptErr) {
        if (pItem) {
            // free the pItem first
            ATTR_TO_INDEX *pTmp;
            pAttr=pItem->pAttrs;
            while (pAttr) {
                pTmp = pAttr;
                pAttr = pAttr->pNext;
                SCFreeAttcache(&pTmp->pAC);
                SCFree(&pTmp);
            }
            SCFree(&pItem);
        }

        // don't proceed on an exception
       return exceptErr;
    }

    /* Compute transitive closure on all classes */
    if ( ComputeCacheClassTransitiveClosure(FALSE) ) {
        // Error
        DPRINT(0,"SCCacheSchema3: Error closing classes\n");
        return DSID(FILENO, __LINE__);
    }

    if (pItem) {
        // If the index is rebuilt the first time after boot
        // Let's wait until it finishes. Note that only those
        // in the indicesToKeep wiil be checked when the
        // schema cache is rebuilt the first time, all the
        // other uncreated indices are created 5 mins after boot.
        if (gFirstCacheLoadAfterBoot||gfRunningAsMkdit||DsaIsInstalling()) {
            CreateIndices(pItem);
        }
        else {
            AsyncCreateIndices(pItem);
        }
    }

    // if we deleted a column, schedule a lazy cache update so that
    // any stale entries read from the deleted columns are flushed
    if (fColDeleted && DsaIsRunning()) {
       SCSignalSchemaUpdateLazy();
    }

    return (0);
}


int
ComputeCacheClassTransitiveClosure(BOOL fForce)

/*++
    Compute inherited mays/musts/poss-sups for all classes

    Return Value:
       0 on success
       non-0 on error
--*/

{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR
    ULONG i, j;
    ULONG *pul;
    int err = 0;
    CLASSCACHE *pCC;

    // if fForce is TRUE, mark all classes as not-closed first to force
    // the closure to be rebuilt
    if (fForce) {
       for (i=0; i<CLSCOUNT; i++) {
           if (ahcClass[i].pVal && ahcClass[i].pVal != FREE_ENTRY) {
               pCC = (CLASSCACHE*)(ahcClass[i].pVal);
               pCC->bClosed = 0;
               pCC->bClosureInProgress = 0;
           }
       }
    }


    /* Compute transitive closure on all classes */
    for (i=0; i<CLSCOUNT; i++) {
        if (ahcClass[i].pVal && ahcClass[i].pVal != FREE_ENTRY) {

            // Closing the class may take some time.
            // Check for service shutdown
            if (eServiceShutdown) {
                return 0;
            }

            pCC = (CLASSCACHE*)(ahcClass[i].pVal);
            err = scCloseClass(pTHS, pCC);
            if (err) {
               // Error closing class. Treat as fatal, since lots of things may
               // not work in an unpredictable manner
               DPRINT1(0, "Error closing class %s\n", pCC->name);
               LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_SCHEMA_CLOSURE_FAILURE,
                    szInsertUL(pCC->ClassId), szInsertSz(pCC->name), 0);
               return err;
            }
        }
    }

    if (fForce) {

       CLASSCACHE *pCCSup, *pCCSupTemp;

       // forcing everything to be rebuilt may have caused duplicates in
       // the subclassoflist, which are not removed by scCloseClass.
       // Instead of removing duplicates by sorting and such, which will
       // change the order of the values, rebuild these values from the
       // chain of direct superclasses. We seem to maintain the order in
       // many places in code (note the order here affects the order in which
       // objectClass values are wriiten in SetClassInheritance)


       for (i=0; i<CLSCOUNT; i++) {
           if (ahcClass[i].pVal && ahcClass[i].pVal != FREE_ENTRY) {
               pCC = (CLASSCACHE*)(ahcClass[i].pVal);
               // don't do for top, which is special and needs nothing
               if (pCC->ClassId == CLASS_TOP) {
                  continue;
               }
               j = 0;
               pCCSup = pCC;
               do {
                  pCC->pSubClassOf[j++] = pCCSup->MySubClass;
                  pCCSupTemp = pCCSup;
                  pCCSup = SCGetClassById(pTHS, pCCSup->MySubClass);
                  if (pCCSup == NULL) {
                     DPRINT1(0, "Cannot find classcache for %d\n", pCCSupTemp->MySubClass);
                     Assert(FALSE);
                     return ERROR_DS_OBJ_CLASS_NOT_DEFINED;
                  }
               }
               while ( (pCCSup->ClassId != CLASS_TOP) && (j <= pCC->SubClassCount));

               //j cannot be greater than exisiting subClassCount
               if (j > pCC->SubClassCount) {
                   Assert(FALSE);
                   return ERROR_DS_OPERATIONS_ERROR;
               }
               pCC->SubClassCount = j;
           } /* if (ahcClass[i].pVal) */
      } /* for */

    }  /* if fForce */

    return 0;

}

int
scCloseSuperClassHelper (
        CLASSCACHE *pCC,
        CLASSCACHE *pCCSup
        )
/*++
    Helper routine that does bulk of the work of inheriting from a
    superclass (class in subclassof list) pointed to by pCCSup

    Returns 0 on success, non-0 on error
--*/
{
    // If we don't have a default SD, grab the parents.
    if(!pCC->pSD) {
        pCC->SDLen = pCCSup->SDLen;

        if(pCCSup->SDLen) {
           // The parent has a default SD.
           if (SCCalloc(&pCC->pSD, 1, pCCSup->SDLen)) {
               return DSID(FILENO, __LINE__);
           }
           pCC->SDLen = pCCSup->SDLen;
           memcpy(pCC->pSD, pCCSup->pSD, pCC->SDLen);
        }
    }
    if(!pCC->pStrSD) {

        if(pCCSup->pStrSD) {

            // The parent has a default SD.
            if (SCCalloc(&pCC->pStrSD, 1, pCCSup->cbStrSD)) {
                return DSID(FILENO, __LINE__);
            }
            pCC->cbStrSD = pCCSup->cbStrSD;
            memcpy(pCC->pStrSD, pCCSup->pStrSD, pCCSup->cbStrSD);
        }
    }

    pCC->bUsesMultInherit |= pCCSup->bUsesMultInherit;
    /* Do verification of rules for inheritance */
    switch(pCC->ClassCategory) {
         case DS_88_CLASS:
         case DS_STRUCTURAL_CLASS:
            if(pCC->bUsesMultInherit)  {
                /* Structural class with multiple inheritance, a no-no */
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_SCHEMA_STRUCTURAL_WITH_MULT_INHERIT,
                          szInsertUL(pCC->ClassId), pCC->name,
                          szInsertUL(pCCSup->ClassId),
                          pCCSup->name, 0, 0, NULL, NULL);
            }
            break;

          case DS_ABSTRACT_CLASS:
            if(pCCSup->ClassCategory != DS_ABSTRACT_CLASS) {
                /* Abstract can only inherit from abstract */
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_SCHEMA_ABSTRACT_INHERIT_NON_ABSTRACT,
                         szInsertUL(pCC->ClassId), pCC->name,
                         szInsertUL(pCCSup->ClassId),
                         pCCSup->name, 0, 0, NULL, NULL);

            }
            break;

          case DS_AUXILIARY_CLASS:
            if(pCCSup->ClassCategory == DS_STRUCTURAL_CLASS) {
                /* Auxiliary can not inherit from structural */
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_SCHEMA_AUXILIARY_INHERIT_STRUCTURAL,
                         szInsertUL(pCC->ClassId), pCC->name,
                         szInsertUL(pCCSup->ClassId),
                         pCCSup->name, 0, 0, NULL, NULL);
            }
            break;
    }

    /* set class hierarchy, but not for top */
    if (pCC->ClassId != CLASS_TOP) {
         if (pCCSup->SubClassCount) {
              int cNew = pCC->SubClassCount + pCCSup->SubClassCount;
              if (pCCSup->SubClassCount) {
                    if (SCRealloc(&pCC->pSubClassOf, cNew*sizeof(ULONG))) {
                        return DSID(FILENO, __LINE__);
                    }
                    memcpy(&pCC->pSubClassOf[pCC->SubClassCount],
                        pCCSup->pSubClassOf,
                        pCCSup->SubClassCount*sizeof(ULONG));
                    pCC->SubClassCount = cNew;
               }
         }
    }
    else {
         /* this is top, mark it as subclass of none */
         /* as a hack, keep the one element array around for those who */
         /* believe in one trip for loops */
         pCC->SubClassCount = 0;
    }

    if (pCC != pCCSup) {        /* don't do this for top! */
         /* Inherit RDN Att id, if not specified */
         if (!pCC->RDNAttIdPresent) {
              pCC->RDNAttIdPresent = pCCSup->RDNAttIdPresent;
              pCC->RdnExtId = pCCSup->RdnExtId;
              pCC->RdnIntId = pCCSup->RdnIntId;
         }

         /* inherit must atts */
         if (pCC->MustCount == 0) {
              pCC->MustCount = pCCSup->MustCount;
              if (SCCalloc(&pCC->pMustAtts, 1, pCC->MustCount * sizeof(ULONG))) {
                  return DSID(FILENO, __LINE__);
              }
               memcpy(pCC->pMustAtts, pCCSup->pMustAtts,
                      pCC->MustCount * sizeof(ULONG));
          }
          else if (pCCSup->MustCount != 0) {
               if (SCRealloc(&pCC->pMustAtts,
                       (pCC->MustCount + pCCSup->MustCount) * sizeof(ULONG))) {
                   return DSID(FILENO, __LINE__);
                }
                memcpy(pCC->pMustAtts + pCC->MustCount, pCCSup->pMustAtts,
                       pCCSup->MustCount * sizeof(ULONG));
                pCC->MustCount += pCCSup->MustCount;
          }

          /* inherit may atts */
          if (pCC->MayCount == 0) {
               pCC->MayCount = pCCSup->MayCount;
               if (SCCalloc(&pCC->pMayAtts, 1, pCC->MayCount * sizeof(ULONG))) {
                   return DSID(FILENO, __LINE__);
               }
                memcpy(pCC->pMayAtts, pCCSup->pMayAtts,
                       pCC->MayCount * sizeof(ULONG));
          }
          else if (pCCSup->MayCount != 0) {
                if (SCRealloc(&pCC->pMayAtts,
                        (pCC->MayCount + pCCSup->MayCount) * sizeof(ULONG))) {
                    return DSID(FILENO, __LINE__);
                }
                memcpy(pCC->pMayAtts + pCC->MayCount, pCCSup->pMayAtts,
                       pCCSup->MayCount * sizeof(ULONG));
                pCC->MayCount += pCCSup->MayCount;
          }

          /* inherit poss-superiors */
          if (pCC->PossSupCount == 0) {
                pCC->PossSupCount = pCCSup->PossSupCount;
                if (SCCalloc(&pCC->pPossSup, 1, pCC->PossSupCount * sizeof(ULONG))) {
                    return DSID(FILENO, __LINE__);
                }
                memcpy(pCC->pPossSup, pCCSup->pPossSup,
                       pCC->PossSupCount * sizeof(ULONG));
           }
           else if (pCCSup->PossSupCount != 0) {
                if (SCRealloc(&pCC->pPossSup,
                        (pCC->PossSupCount + pCCSup->PossSupCount) * sizeof(ULONG))) {
                    return DSID(FILENO, __LINE__);
                }
                memcpy(pCC->pPossSup + pCC->PossSupCount, pCCSup->pPossSup,
                       pCCSup->PossSupCount * sizeof(ULONG));
                pCC->PossSupCount += pCCSup->PossSupCount;
           }
    }

    return 0;
}

int
scCloseAuxClassHelper (
        CLASSCACHE *pCC,
        CLASSCACHE *pCCAux
        )
/*++
    Helper routine that does bulk of the work of inheriting from a
    aux class (class in auxclassof list) pointed to by pCCAux

    Returns 0 on success, non-0 on error
--*/
{
    DWORD sMayCount   ;
    DWORD sMustCount  ;
    ATTRTYP* sMayList ;
    ATTRTYP* sMustList;

    if((pCCAux->ClassCategory != DS_AUXILIARY_CLASS) &&
          (pCCAux->ClassCategory != DS_88_CLASS)  ) {
           /* Illegal aux class */
           LogEvent8(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_SCHEMA_NOT_AUX,
                     szInsertUL(pCC->ClassId), szInsertSz(pCC->name),
                     szInsertUL(pCCAux->ClassId), szInsertSz(pCCAux->name),
                     0,0, NULL, NULL);
           // don't inherit from this one, but let inheritance continue
           // from other classes
           return 0;
     }

     sMayCount = pCC->MayCount;
     sMustCount= pCC->MustCount;
     sMayList  = pCC->pMayAtts;
     sMustList = pCC->pMustAtts;

     pCC->MayCount +=pCCAux->MayCount;
     pCC->MustCount+=pCCAux->MustCount;

     if (SCCalloc(&pCC->pMayAtts, pCC->MayCount ,sizeof(ATTRTYP))
         || SCCalloc(&pCC->pMustAtts, pCC->MustCount,sizeof(ATTRTYP))) {
          return DSID(FILENO, __LINE__);
     }

     CopyMemory(pCC->pMayAtts ,sMayList ,sMayCount *sizeof(ATTRTYP));
     CopyMemory(pCC->pMustAtts,sMustList,sMustCount*sizeof(ATTRTYP));

     CopyMemory(&(pCC->pMayAtts[sMayCount])  ,pCCAux->pMayAtts ,pCCAux->MayCount *sizeof(ATTRTYP));
     CopyMemory(&(pCC->pMustAtts[sMustCount]),pCCAux->pMustAtts,pCCAux->MustCount*sizeof(ATTRTYP));

     SCFree(&sMayList);
     SCFree(&sMustList);

     return 0;
}


void scLogEvent(
     ULONG cat,
     ULONG sev,
     MessageId msg,
     ULONG arg1,
     char *arg2,
     ULONG arg3
     )
/*++
     Wrapper around LogEvent() so as to not bloat the stack size of
     scCloseClass, which is recursive
--*/
{
     LogEvent( cat, sev, msg,
               szInsertUL(arg1),
               szInsertSz(arg2),
               szInsertUL(arg3)
             );
}

int
scCloseClass (
        THSTATE *pTHS,
        CLASSCACHE *pCC
        )
/*++
   Compute the transitive closure of the properties of a class, including
   its list of must have and may have attributes, and the class hierarchy.

   Return Value:
      0 on success
      non-0 on error (right now, errors only on allo failures)
--*/
{
    int i,j,k, err = 0;
    int iSubClass,cSubClass;
    int iAuxClass,cAuxClass;
    ATTCACHE *pAC;
    ULONG * pul;
    ULONG * pul2;

    if (pCC->bClosed) {
        return 0;
    }
    if (pCC->bClosureInProgress) {
        if (pCC->ClassId != CLASS_TOP) {
            /* don't whine if TOP */
            scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_CIRCULAR_INHERIT,
                  pCC->ClassId, pCC->name, 0);
        }
        return 0;
    }

    pCC->bClosureInProgress = 1;

    cSubClass = pCC->SubClassCount;
    for (iSubClass=0; iSubClass<cSubClass; iSubClass++) {
        CLASSCACHE *pCCSup;

        /* find the super class and make sure it's closed */
        pCCSup = SCGetClassById(pTHS, pCC->pSubClassOf[iSubClass]);
        if (NULL == pCCSup) {
            /* Couldn't find superclass in cache */
            scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_SCHEMA_INVALID_SUPER,
                  pCC->ClassId, pCC->name,
                  pCC->pSubClassOf[iSubClass]);
            continue;
        }
        if ( err = scCloseClass(pTHS, pCCSup)) {
           DPRINT1(0,"SCCloseClass: Error closing sup class %s\n", pCCSup->name);
           scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_SCHEMA_CLOSURE_FAILURE,
                  pCCSup->ClassId, pCCSup->name, 0);
           return err;
        }

        if (err = scCloseSuperClassHelper(pCC, pCCSup)) {
           return err;
        }

    }


    cAuxClass = pCC->AuxClassCount;
    for (iAuxClass=0; iAuxClass<cAuxClass; iAuxClass++) {
        CLASSCACHE *pCCAux;

        /* find the auxiliary class and make sure it's closed */
        pCCAux = SCGetClassById(pTHS, pCC->pAuxClass[iAuxClass]);
        if (NULL == pCCAux) {
            /* Couldn't find aux class in cache */
            scLogEvent(DS_EVENT_CAT_SCHEMA,
                       DS_EVENT_SEV_MINIMAL,
                       DIRLOG_SCHEMA_INVALID_AUX,
                       pCC->ClassId, pCC->name,
                       pCC->pAuxClass[iAuxClass]);
            continue;
        }
        // if class-ids are same, same class, so no point closing it.
        // Actually, closing the class w.r.to itself makes the alloc/realloc/copy
        // code in scCloseAuxClassHelper quite complex to ensure that we do
        // not write past allocated buffers. Other than that, there is no harm
        // really as this operation only adds the same may/musts to the list
        // again which gets removed during duplicate removal.
        // On another note, the reason we have to do this in spite of the
        // bClosureInProgress bit setting (that is there mainly for this purpose)
        // is that that mechanism can detect circular inherit when all the
        // classcaches are obtained from the same cache. However, we often
        // build a cache from the dit, and then close it against the schema cache,
        // so on the first scCloseClass call, the classcache on which the bit is
        // set is not the same as the classcache for the same class in the cache.


        if (pCC->ClassId == pCCAux->ClassId) {
           DPRINT1(0,"Direct circular inherit in class %s\n", pCC->name);
           scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_CIRCULAR_INHERIT,
                  pCC->ClassId, pCC->name, 0);
           continue;
        }

        if ( err = scCloseClass(pTHS, pCCAux)) {
           DPRINT1(0, "scCloseClass: Error closing aux class %s\n", pCCAux->name);
           scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_SCHEMA_CLOSURE_FAILURE,
                  pCCAux->ClassId, pCCAux->name, 0);
           return err;
        }

        if (err = scCloseAuxClassHelper(pCC,pCCAux)) {
            return err;
        }

    } //for (iAuxClass=0; iAuxClass<cAuxClass; iAuxClass++)



    /* sort, verify, and trim the attributes, if any */
    if (!(pAC = SCGetAttById(pTHS, pCC->RdnIntId))) {
        scLogEvent(DS_EVENT_CAT_SCHEMA,
              DS_EVENT_SEV_MINIMAL,
              DIRLOG_SCHEMA_INVALID_RDN,
              pCC->ClassId, pCC->name, pCC->RdnIntId);
    }

    // Remove Duplicates
    if (pCC->MustCount) {
        if(pCC->MyMustCount) {
            // I had some native musts (not inherited)
            qsort(pCC->pMyMustAtts,
                  pCC->MyMustCount,
                  sizeof(ULONG),
                  CompareAttrtyp);
        }

        qsort(pCC->pMustAtts, pCC->MustCount, sizeof(ULONG), CompareAttrtyp);

        for (i=0, j=0, pul=pCC->pMustAtts;
             i<(int)pCC->MustCount;
             j++) {

            pul[j] = pul[i];

            while( i<(int)pCC->MustCount && (pul[i] == pul[j]))
                i++;

        }

        pCC->MustCount = j;

    }

    // Remove Duplicates
    if (pCC->MayCount) {
        if(pCC->MyMayCount) {
            // I had some native mays (not inherited)
            qsort(pCC->pMyMayAtts,
                  pCC->MyMayCount,
                  sizeof(ULONG),
                  CompareAttrtyp);
        }

        qsort(pCC->pMayAtts, pCC->MayCount, sizeof(ULONG), CompareAttrtyp);

        for (i=0, j=0, pul=pCC->pMayAtts;
             i<(int)pCC->MayCount;
             j++) {

            pul[j] = pul[i];


            while( i<(int)pCC->MayCount && (pul[i] == pul[j]))
                i++;
        }

        pCC->MayCount = j;

    }

    // Remove Duplicates
    if (pCC->PossSupCount) {
        if(pCC->MyPossSupCount) {
            // I had some native mays (not inherited)
            qsort(pCC->pMyPossSup,
                  pCC->MyPossSupCount,
                  sizeof(ULONG),
                  CompareAttrtyp);
        }

        qsort(pCC->pPossSup, pCC->PossSupCount, sizeof(ULONG), CompareAttrtyp);

        for (i=0, j=0, pul=pCC->pPossSup;
             i<(int)pCC->PossSupCount;
             j++) {

            pul[j] = pul[i];


            while( i<(int)pCC->PossSupCount && (pul[i] == pul[j]))
                i++;
        }

        pCC->PossSupCount = j;

    }

    // Finally, trim out any may haves that are also must haves.
    if (pCC->MustCount && pCC->MayCount) {
        BOOL fChanged = FALSE;

        pul=pCC->pMustAtts;
        pul2 = pCC->pMayAtts;
        for(i=0,j=0;i < (int)pCC->MustCount;i++) {
            while ((j < (int)pCC->MayCount) && (pul[i] > pul2[j])) {
                j++;
            }
            if(j >= (int)pCC->MayCount)
                break;

            if(pul[i] == pul2[j]) {
                // This attribute is both a may and must.  Trim it
                memcpy(&pul2[j],
                       &pul2[j+1],
                       (pCC->MayCount -1 - j)*sizeof(ULONG));
                pCC->MayCount--;
                fChanged = TRUE;
            }
        }
        if(fChanged) {
            if (SCRealloc(&pCC->pMayAtts, pCC->MayCount * sizeof(ULONG))) {
                return DSID(FILENO, __LINE__);
            }
        }
    }

    pCC->bClosed = 1;
    pCC->bClosureInProgress = 0;

    return 0;
}



/////////////////////////////////////////////////////////////////////////
// Function to either free global schema cache memory immediately, or
// reschedule it for delayed freeing depending certain conditions.
//
// Conditions for immediate freeing: Either fImmediate is TRUE in
//                                   the SCHEMARELEASE structure passed
//                                   in  or if the RefCount of
//                                   the schema cache is 0
//
// Arguments: buffer -- ptr to a SCHEMARELEASE structure
//            ppvNext - parameter for next schedule
//            pTimeNext - time of next reschedule
////////////////////////////////////////////////////////////////////////

void
DelayedFreeSchema(
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
    SCHEMARELEASE *ptr = (SCHEMARELEASE *) buffer;
    SCHEMAPTR *pSchemaPtr = ptr->pSchema;
    BOOL fImmediate = ptr->fImmediate;

    if ( (!fImmediate) && (pSchemaPtr->RefCount != 0)) {
      // Some thread still referring to this, so reschedule for
      // checking after another hour
      // Increment cTimesRescheduled to note how many times the task
      // has been rescheduled. Can be used to free after some
      // large no. of reschedules if necessary

      (ptr->cTimesRescheduled)++;
      (*ppvNext) = buffer;
      (*pcSecsUntilNextIteration) = gdwDelayedMemFreeSec;
    } else {
      // either immediate freeing is requested during install or
      // no thread referring to this cache so free immediately

        SCFreeSchemaPtr(&pSchemaPtr);
        SCFree(&ptr);
    }
}


/*
 * Unload the entire schema, all attributes and classes.
 */
void SCUnloadSchema(BOOL fUpdate)
{

    ULONG i;
    DWORD j=1;
    SCHEMARELEASE *ptr;


    if (iSCstage == 0) {
        // This means the schema cache is trying to be unloaded when it
        // hasn't even been created.  This is ok since during initialization
        // is it possible to be in the shutdown path without having created
        // a schema cache.
        CurrSchemaPtr = 0;
        return;
    }

    {

        // enqueue the schema cache pointer for
        // delayed freeing if necessary.


        if (SCCalloc(&ptr, 1, sizeof(SCHEMARELEASE))) {
            return;
        }
        ptr->pSchema = CurrSchemaPtr;
        ptr->cTimesRescheduled = 1;

        if (DsaIsInstalling()) {

            ptr->fImmediate = TRUE;

            // free memory immediately
            DelayedFreeSchema(ptr, NULL, NULL);
        }
        else {
            ptr->fImmediate = FALSE;
            // insert in task q for delayed freeing
            // Ref count first checked after one minute
            InsertInTaskQueue(TQ_DelayedFreeSchema, ptr, 60);
        }

        if (!fUpdate) {
           // This is not an unload due to schema update

            CurrSchemaPtr=0;

            iSCstage = 0;
        }

    }
}


/*
 * Update a classcache in the cache.  Used when the DMD object representing
 * the class is modified while the DS is running.
 * NOTE - To avoid leaving the classcache structure in an inconsistent state
 * or freeing pointers in an unsafe manner, we construct an entire new
 * classcache and then replace the hash table entries.
 */
int SCModClassSchema (THSTATE *pTHS, ATTRTYP ClassId)
{
    DECLARESCHEMAPTR

    CLASSCACHE * pCCold, *pCCnew;
    int err;
    ULONG i;

    pCCold = SCGetClassById(pTHS, ClassId);
    if (NULL == pCCold) {
        return TRUE;    // Caller reports error
    }

    // Update values from database. Cache entry is already indexed by
    // the hash tables since it's an existing entry.

    // The schema is being modified on the parent during dcpromo. This
    // may cause a defunct class to supercede an active class. This
    // should be okay because replication will still update instances
    // correctly. If this appears to be a problem, then compare the
    // active entry in ahcClass (pCCOld) with the dup entries in
    // ahcClassAll and, if needed, supercede the active entry
    err = SCBuildCCEntry (pCCold, &pCCnew);
    if (err) {
        return(err);
    }

	/* touch up the hash tables */
	for (i=0; i<CLSCOUNT; i++) {
	    if (ahcClass[i].pVal == pCCold) {
		ahcClass[i].pVal = pCCnew;
		break;
	    }
	}
	for (i=0; i<CLSCOUNT; i++) {
	    if (ahcClassName[i].pVal == pCCold) {
		ahcClassName[i].pVal = pCCnew;
		break;
	    }
	}
	for (i=0; i<CLSCOUNT; i++) {
	    if (ahcClassAll[i].pVal == pCCold) {
		ahcClassAll[i].pVal = pCCnew;
		break;
	    }
	}

    SCFreeClasscache(&pCCold);

    return(err);
}

int
SCModAttSchema (
        THSTATE *pTHS,
        ATTRTYP attrid
        )
/*
 * Update an attcache in the cache.  Used when the DMD object representing
 * the class is modified while the DS is running.
 * NOTE - To avoid leaving the attcache structure in an inconsistent state
 * or freeing pointers in an unsafe manner, we construct an entire new
 * attcache and then replace the hash table entries.
 */
{
    DECLARESCHEMAPTR

    ATTCACHE *pACold, *pACnew;
    int err;
    ULONG i;

    /* Look up existing entry by id */

    if (NULL == (pACold = SCGetAttById(pTHS, attrid))) {
        return TRUE;    /* Caller reports error */
    }

    /* Update values from database. Cache entry is already indexed by */
    /* the hash tables since it's an existing entry. */

    err = SCBuildACEntry (pACold, &pACnew);
    if (err) {
        return(err);
    }

	/* touch up the hash tables */
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcId[i].pVal == pACold) {
		ahcId[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcExtId[i].pVal == pACold) {
		ahcExtId[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcCol[i].pVal == pACold) {
		ahcCol[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcMapi[i].pVal == pACold) {
		ahcMapi[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcLink[i].pVal == pACold) {
		ahcLink[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcName[i].pVal == pACold) {
		ahcName[i].pVal = pACnew;
		break;
	    }
	}

    SCFreeAttcache(&pACold);

    return err;
}

int
SCBuildACEntry (
        ATTCACHE *pACold,
        ATTCACHE **ppACnew
        )
// This routine allocates and fills in the fields in the ATTCACHE structure by
// reading the attributes from the database. If an already existing ATTCACHE
// structure is also given, the database columnid from the existing ATTCACHE is
// copied to the new attcache.
//
// N.B. The routines SCBuildACEntry and scAddAtt work in parallel, with
//      SCBuildACEntry taking a positioned database record as input and
//      SCAddAtt taking an ENTINF.  They both produce an ATTCACHE as output,
//      and any changes made to one routine's processing must be made to
//      the other's as well.
//
// Return Value:
//    0 on success
//    non-0 on error
//
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE     *pAC, *ppACs[NUMATTATT];
    DWORD        i, cOutAtts;
    ATTR         *pAttr;
    BOOL         fFoundID, fFoundExtID, fFoundAttSyntax, fFoundName, fMallocFailed;
    BOOL         fFoundBadAttSyntax = FALSE;

    char         szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int          lenIndexName;


    if (SCCalloc(ppACnew, 1, sizeof(ATTCACHE))) {
       return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
    }

    pAC = (*ppACnew);                      // Speed hack

    pAC->bExtendedChars = TRUE; /* a popular default setting */
    fMallocFailed = fFoundID = fFoundExtID = fFoundAttSyntax = fFoundName = FALSE;

    // Get the attcache pointer for all the attributes we are interested
    for(i=0;i<NUMATTATT;i++) {
        ppACs[i] = SCGetAttById(pTHS, AttributeSelList[i].attrTyp);
    }

    // Get the attributes
    DBGetMultipleAtts(pTHS->pDB, NUMATTATT, &ppACs[0], NULL, NULL,
                      &cOutAtts, &pAttr, DBGETMULTIPLEATTS_fGETVALS, 0);

    // Reset the jet column id.
    if(pACold)
        pAC->jColid = pACold->jColid;

    for(i=0;i<cOutAtts && !fMallocFailed;i++) {
        PUCHAR pVal=pAttr[i].AttrVal.pAVal->pVal;
        DWORD  valLen =pAttr[i].AttrVal.pAVal->valLen;
        switch(pAttr[i].attrTyp) {
        case ATT_ATTRIBUTE_ID:
            pAC->Extid = *(SYNTAX_OBJECT_ID *)pVal;
            fFoundExtID = TRUE;
            break;
        case ATT_MS_DS_INTID:
            pAC->id = *(SYNTAX_OBJECT_ID *)pVal;
            fFoundID = TRUE;
            break;
        case ATT_ATTRIBUTE_SYNTAX:
            pAC->syntax = (UCHAR) (0xFF & *(SYNTAX_INTEGER *)pVal);
            fFoundAttSyntax = TRUE;
            // if this is done as part of a originating attribute add operation,
            // verify that the prefix is correct. The suffix will be
            // verified in the syntax mismatch test

            if ( (pTHS->SchemaUpdate == eSchemaAttAdd
                  || pTHS->SchemaUpdate == eSchemaAttUndefunct)
                    && !pTHS->fDRA && !DsaIsInstalling() ) {
               if ( ((0xFFFF0000 & *(SYNTAX_INTEGER *)pVal) >> 16) != _dsP_attrSyntaxPrefIndex) {
                   // top 16 bits don't match the index. mismatch
                   fFoundBadAttSyntax = TRUE;
               }
            }
            break;
        case  ATT_LDAP_DISPLAY_NAME:
            // The admin display name read from the DB is currently in raw
            // (Unicode) format.  Single-byte it.
            pAC->nameLen = valLen;
            if (SCCalloc(&pAC->name, 1, valLen + 1)) {
                fMallocFailed = TRUE;
            }
            else {
                pAC->nameLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,
                        (LPCWSTR)pVal,
                        (valLen/sizeof(wchar_t)),
                        pAC->name,
                        valLen,
                        NULL,
                        NULL);

                pAC->name[pAC->nameLen]= '\0';
                fFoundName=TRUE;
            }
            break;
        case ATT_IS_SINGLE_VALUED:
            pAC->isSingleValued = *(SYNTAX_BOOLEAN *)pVal;
            break;
        case  ATT_SEARCH_FLAGS:
            pAC->fSearchFlags = *(SYNTAX_INTEGER *)pVal;
            break;
        case  ATT_SYSTEM_ONLY:
            pAC->bSystemOnly = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_RANGE_LOWER:
            pAC->rangeLowerPresent = TRUE;
            pAC->rangeLower = *(SYNTAX_INTEGER *)pVal;
            break;
        case  ATT_RANGE_UPPER:
            pAC->rangeUpperPresent = TRUE;
            pAC->rangeUpper = *(SYNTAX_INTEGER *)pVal;
            break;
        case  ATT_MAPI_ID:
            pAC->ulMapiID = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_LINK_ID:
            pAC->ulLinkID = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_OM_SYNTAX:
            pAC->OMsyntax = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_OM_OBJECT_CLASS:
            pAC->OMObjClass.length = valLen;
            if (SCCalloc(&pAC->OMObjClass.elements, 1, valLen)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy(pAC->OMObjClass.elements, (UCHAR *)pVal, valLen);
            break;
        case ATT_EXTENDED_CHARS_ALLOWED:
            pAC->bExtendedChars =(*(SYNTAX_BOOLEAN*)pVal?1:0);
            break;
        case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
            if (*(SYNTAX_BOOLEAN*)pVal)
            {
                pAC->bMemberOfPartialSet = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            pAC->bDefunct =(*(SYNTAX_BOOLEAN*)pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pVal & FLAG_ATTR_NOT_REPLICATED) {
                pAC->bIsNotReplicated = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER) {
                pAC->bMemberOfPartialSet = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_IS_CONSTRUCTED) {
                pAC->bIsConstructed = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_IS_OPERATIONAL) {
                pAC->bIsOperational = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pAC->bIsBaseSchObj = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_IS_RDN) {
                pAC->bIsRdn = TRUE;
                pAC->bFlagIsRdn = TRUE;
            }
            break;

        case ATT_OBJECT_GUID:
            // Needed to choose a winner when OIDs collide
            memcpy(&pAC->objectGuid, pVal, sizeof(pAC->objectGuid));
            Assert(valLen == sizeof(pAC->objectGuid));
            break;

        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pAttr[i].attrTyp), 0, 0);
            break;
        }
    }
    if (!fFoundID) {
        fFoundID = fFoundExtID;
        pAC->id = pAC->Extid;
    }

    if(fMallocFailed || !fFoundID || !fFoundAttSyntax || !fFoundName) {
        SCFreeAttcache(&pAC);

        if(fMallocFailed) {
            return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
        }
        else if(!fFoundID) {
            DPRINT(2,"Couldn't retrieve the schema's attribute id\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_ATT_SCHEMA_REQ_ID,
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_ATT_SCHEMA_REQ_ID);
        }
        else if(!fFoundAttSyntax) {
            DPRINT(2,"Couldn't retrieve the schema's attribute syntax\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_ATT_SCHEMA_REQ_SYNTAX,
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL,
                     NULL);
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               ERROR_DS_ATT_SCHEMA_REQ_SYNTAX);
        }
        else {
            DPRINT(2,"Couldn't retrieve the schema's attribute name\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_MISSING_EXPECTED_ATT,
                     szInsertUL(ATT_LDAP_DISPLAY_NAME),
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL);
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               ERROR_DS_MISSING_EXPECTED_ATT);
        }
    }

    if (fFoundBadAttSyntax) {
        // found bad attribute syntax in the course of a new attribute add
        // this is a schema validation error, user has input a bad syntax.
        // Note that at this point, we have pAC->name to log, or else we would
        // have returned above when fFoundName was found to be False.
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_VALIDATION_FAILED,
                 szInsertSz(pAC->name),
                 szInsertInt(ERROR_DS_BAD_ATT_SCHEMA_SYNTAX),
                 szInsertWin32Msg(ERROR_DS_BAD_ATT_SCHEMA_SYNTAX));
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_BAD_ATT_SCHEMA_SYNTAX);
    }

    // assign names of commonly used indexes when searching with
    // fSearchFlags fPDNTATTINDEX, fATTINDEX and fTUPLEINDEX
    if ( pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX | fTUPLEINDEX) ) {
        // set ATTINDEX
        if (pAC->fSearchFlags & fATTINDEX) {

            // this should be NULL
            Assert (pAC->pszIndex == NULL);

            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszIndex, 1, lenIndexName)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy (pAC->pszIndex, szIndexName, lenIndexName);
        }

        // set TUPLEINDEX
        if (pAC->fSearchFlags & fTUPLEINDEX) {

            // this should be NULL
            Assert (pAC->pszTupleIndex == NULL);

            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszTupleIndex, 1, lenIndexName)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy (pAC->pszTupleIndex, szIndexName, lenIndexName);
        }

        // set PDNTATTINDEX
        if (!fMallocFailed  && (pAC->fSearchFlags & fPDNTATTINDEX)) {

            // this should be NULL
            Assert (pAC->pszPdntIndex == NULL);

            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszPdntIndex, 1, lenIndexName)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy (pAC->pszPdntIndex, szIndexName, lenIndexName);
        }
    }
    if(fMallocFailed) {
        SCFreeAttcache(&pAC);
        return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
    }


    // Backlinks should have their system flags set to indicate they are not
    // replicated.
    Assert(!FIsBacklink(pAC->ulLinkID) || pAC->bIsNotReplicated);

    return 0;

}/*SCBuildACEntry*/


/*
 * Add a single class definition to the schema cache, given the data
 * from the DMD object.
 *
 * N.B. This routine works in parallel with SCAddClass.  scAddClass
 *      takes the input description as an ENTINF, while SCBuildCCEntry
 *      takes the input as a positioned record in the DIT.  Any changes
 *      made to one routine must be made to the other.
 */
int
SCBuildCCEntry (
        CLASSCACHE *pCCold,
        CLASSCACHE **ppCCnew
        )

// This routine allocates and fills in the fields in a CLASSCACHE structure by
// reading the attributes from the database. If the fields are not in the
// database, they are defaulted to 0s and NULLs.  An already existing CLASSCACHE
// structure may also be specified, and in the future some attributes may be
// copied from the old structure to the new, but that is not currently
// necessary.
//
// Return Value:
//    0 on success
//    non-0 on error
//
{
    THSTATE      *pTHS=pTHStls;
    ATTCACHE     *ppACs[NUMCLASSATT];
    CLASSCACHE   *pCC;
    DWORD        i, j, cOutAtts, numValues;
    ATTR         *pAttr;
    BOOL         fFoundGovernsID, fFoundSubclass, fFoundName, fMallocFailed;

    if (SCCalloc(ppCCnew, 1, sizeof(CLASSCACHE))) {
       return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
    }
    pCC = (*ppCCnew);

    fMallocFailed = fFoundGovernsID = fFoundSubclass = fFoundName = FALSE;

    // Get the attcache pointer for all the attributes we are interested
    for(i=0;i<NUMCLASSATT;i++) {
        ppACs[i] = SCGetAttById(pTHS, ClassSelList[i].attrTyp);
    }

    // Get the attributes
    DBGetMultipleAtts(pTHS->pDB, NUMCLASSATT, &ppACs[0], NULL, NULL,
                      &cOutAtts, &pAttr, DBGETMULTIPLEATTS_fGETVALS, 0);


    for(i=0;i<cOutAtts && !fMallocFailed ;i++) {
        ATTRVAL *pAVal = pAttr[i].AttrVal.pAVal;

        switch(pAttr[i].attrTyp) {
        case ATT_DEFAULT_SECURITY_DESCRIPTOR:
            // A default security descriptor.  We need to copy this value to
            // long term memory and save the size.
            // But this is a string. We first need to convert. It
            // is a wide-char string now, but we need to null-terminate
            // it for the security conversion. Yikes! This means I
            // have to realloc for that one extra char!

           {

            UCHAR *sdBuf = NULL;
            ULONG  err = 0;

            pCC->cbStrSD = pAttr[i].AttrVal.pAVal->valLen + sizeof(WCHAR);
            if (SCCalloc(&pCC->pStrSD, 1, pCC->cbStrSD)) {
                pCC->cbStrSD = 0;
                fMallocFailed = TRUE;
                break;
            } else {
                memcpy(pCC->pStrSD,
                       pAttr[i].AttrVal.pAVal->pVal,
                       pAttr[i].AttrVal.pAVal->valLen);
                pCC->pStrSD[(pAttr[i].AttrVal.pAVal->valLen)/sizeof(WCHAR)] = L'\0';
            }

            // Hammer the default SD on cached classes when running as
            // dsamain.exe w/security disabled and unit tests enabled.
            DEFAULT_SD_FOR_EXE(pTHS, pCC)

            if (!ConvertStringSDToSDRootDomainW
                 (
                   gpRootDomainSid,
                   pCC->pStrSD,
                   SDDL_REVISION_1,
                   (PSECURITY_DESCRIPTOR*) &sdBuf,
                   &(pCC->SDLen)
                 )) {
                err = GetLastError();
                DPRINT1(0,"SCBuildCCEntry: Default security descriptor conversion failed, error %x\n",err);
                return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     ERROR_DS_SEC_DESC_INVALID, err);
            }

            // Converted successfully

            if (SCCalloc(&pCC->pSD, 1, pCC->SDLen)) {
                fMallocFailed = TRUE;
            }
            else {
                memcpy(pCC->pSD, sdBuf, pCC->SDLen);
            }

            if (NULL!=sdBuf)
            {
                LocalFree(sdBuf);
                sdBuf = NULL;

            }

           }

            break;

        case ATT_OBJECT_CLASS_CATEGORY:
            pCC->ClassCategory=*(ULONG*)pAVal->pVal;
            break;
        case ATT_DEFAULT_OBJECT_CATEGORY:
            if (SCCalloc(&pCC->pDefaultObjCategory, 1, pAVal->valLen)) {
               fMallocFailed = TRUE;
            }
            else {
              memcpy(pCC->pDefaultObjCategory,
                     pAVal->pVal, pAVal->valLen);
            }
            break;
        case ATT_SYSTEM_AUXILIARY_CLASS:
        case ATT_AUXILIARY_CLASS:
            if (GetValList(&(pCC->AuxClassCount), &(pCC->pAuxClass), &pAttr[i])) {
                fMallocFailed = TRUE;
            }
            break;
        case ATT_SYSTEM_ONLY:
            pCC->bSystemOnly = *(SYNTAX_INTEGER *)pAVal->pVal;
            break;

        case ATT_DEFAULT_HIDING_VALUE:
            pCC->bHideFromAB = *(SYNTAX_BOOLEAN *)pAVal->pVal;
            break;

        case ATT_GOVERNS_ID:
            pCC->ClassId = *(SYNTAX_OBJECT_ID *)pAVal->pVal;
            fFoundGovernsID = TRUE;
            break;

        case ATT_LDAP_DISPLAY_NAME:
            // The admin display name read from the DB is currently in raw
            // (Unicode) format.  Single-byte it.
            pCC->nameLen = pAVal->valLen;
            if (SCCalloc(&pCC->name, 1, pAVal->valLen+1)) {
                fMallocFailed = TRUE;
            }
            else {
                pCC->nameLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,
                        (LPCWSTR)pAVal->pVal,
                        (pAVal->valLen/
                         sizeof(wchar_t)),
                        pCC->name,
                        pAVal->valLen,
                        NULL,
                        NULL);

                pCC->name[pCC->nameLen] = '\0';

                fFoundName=TRUE;
            }
            break;

        case ATT_RDN_ATT_ID:
            // Cannot be a normal cache load -- it uses scAddClass.
            //
            // During install, this entry is added directly into the
            // schema cache. This means RdnIntId is incorrect. That
            // should be okay because the schema cache is reloaded
            // again after the schemaNC replicates in and before
            // the other NCs are replicated. This means a replicating
            // schema object cannot depend on a replicated class; which
            // is true today for other reasons.
            //
            // During validation cache loads, this entry is built
            // as a temporary data structure and the real entry in
            // the validation cache is used for checks. So its
            // okay RdnIntId is incorrect.
            pCC->RDNAttIdPresent = TRUE;
            pCC->RdnExtId = *(SYNTAX_OBJECT_ID *)pAVal->pVal;
            pCC->RdnIntId = pCC->RdnExtId;
            break;

        case ATT_SUB_CLASS_OF:
            // Find what classes this class is a subclass of.
            if(!pAttr[i].AttrVal.valCount)
                break;
            fFoundSubclass = TRUE;
            pCC->SubClassCount = pAttr[i].AttrVal.valCount;
            if (SCCalloc(&pCC->pSubClassOf, 1, pAttr[i].AttrVal.valCount*sizeof(ULONG))) {
                fMallocFailed = TRUE;
            }
            else {
                for(j=0;j<pAttr[i].AttrVal.valCount;j++) {
                    pCC->pSubClassOf[j] =
                        *(SYNTAX_OBJECT_ID *)pAVal[j].pVal;

                }
            }
            // ATT_SUB_CLASS_OF is single-valued, so there will be only
            // one value stored in the dit
            pCC->MySubClass = *(SYNTAX_OBJECT_ID *)pAVal->pVal;
            break;

        case ATT_SYSTEM_MUST_CONTAIN:
        case ATT_MUST_CONTAIN:
            // Get the list of mandatory attributes for this class.
            if (GetValList(&(pCC->MustCount), &(pCC->pMustAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                // Replicating schemaNC cannot depend on parent's schema.
                ValListToIntIdList(pTHS, &pCC->MustCount, &pCC->pMustAtts);
            }

            if (GetValList(&(pCC->MyMustCount), &(pCC->pMyMustAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                // Replicating schemaNC cannot depend on parent's schema.
                ValListToIntIdList(pTHS, &pCC->MyMustCount, &pCC->pMyMustAtts);
            }

            break;

        case ATT_SYSTEM_MAY_CONTAIN:
        case ATT_MAY_CONTAIN:
            if (GetValList(&(pCC->MayCount), &(pCC->pMayAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                // Replicating schemaNC cannot depend on parent's schema.
                ValListToIntIdList(pTHS, &pCC->MayCount, &pCC->pMayAtts);
            }

            if (GetValList(&(pCC->MyMayCount), &(pCC->pMyMayAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                ValListToIntIdList(pTHS, &pCC->MyMayCount, &pCC->pMyMayAtts);
            }
            break;

        case ATT_OBJECT_GUID:
            // Needed to choose winner if OIDs collide
            memcpy(&pCC->objectGuid,
                   pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->objectGuid));
            Assert(pAttr[i].AttrVal.pAVal->valLen ==
                   sizeof(pCC->objectGuid));
            break;


        case ATT_SYSTEM_POSS_SUPERIORS:
        case ATT_POSS_SUPERIORS:
            // Get the list of possible superiors for this class.
            if (GetValList(&(pCC->PossSupCount), &(pCC->pPossSup), &pAttr[i])) {
               fMallocFailed = TRUE;
           }
           if (GetValList(&(pCC->MyPossSupCount), &(pCC->pMyPossSup), &pAttr[i])) {
               fMallocFailed = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            pCC->bDefunct =(*(SYNTAX_BOOLEAN*)pAVal->pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pCC->bIsBaseSchObj = TRUE;
            }
            break;

        default:
            break;
        }
    }

    if(fMallocFailed || !fFoundSubclass || !fFoundGovernsID  || !fFoundName) {
        SCFreeClasscache(&pCC);
        if (fMallocFailed) {
            return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
        }

        if(!fFoundSubclass) {
            LogUnhandledError(0);
            Assert (FALSE);
        }

        if(!fFoundGovernsID) {
            DPRINT(2,"Couldn't retrieve the objects class\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_GOVERNSID_MISSING,
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR,ERROR_DS_GOVERNSID_MISSING);
        }

        if(!fFoundName) {
            DPRINT(2,"Couldn't retrieve the schema's class name\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_MISSING_EXPECTED_ATT,
                     szInsertUL(ATT_LDAP_DISPLAY_NAME),
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               ERROR_DS_MISSING_EXPECTED_ATT);
        }
    }

    pCC->bClosed = FALSE;

    if (pTHS->SchemaUpdate==eSchemaClsMod)
    {
        //
        // We want to insure that there is no Circular Dependency
        // with the class inheritence
        //
        CLASSCACHE* pCC1;
        ULONG k;

        pCC1 = SCGetClassById(pTHS, pCC->pSubClassOf[0]);
        if (pCC1) {
            for (k=0;k<pCC1->SubClassCount;k++)
            {
                if (pCC1->pSubClassOf[k]==pCC->ClassId)
                {
                    return SetSvcError(SV_PROBLEM_DIR_ERROR,ERROR_DS_MISSING_EXPECTED_ATT);
                }
            }
        }
        // The check for circular dependency is impossible if the parent
        // class has not yet replicated in. An event log warning will be
        // issued by scCloseClass().
        else if (!pTHS->fDRA) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,ERROR_DS_MISSING_EXPECTED_ATT);
        }
    }

    // Visit all superior classes to get all the may and must contain
    // attributes for this class.
    if (scCloseClass(pTHS, pCC)) {
       DPRINT1(0, "SCBuildCCEntry: Error closing class %s\n", pCC->name);
       return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_CANT_CACHE_CLASS);
    }

    return 0;
}


int
SCAddClassSchema (
        IN THSTATE *pTHS,
        IN CLASSCACHE *pCC
        )
/*
 * Insert a classcache into the hash tables.
 */
{
    DECLARESCHEMAPTR
    ULONG i,start;
    CLASSCACHE *pCCDup;
    ATTCACHE *pACDup;
    BOOL bWonOid;
    USHORT DebugLevel = (pTHS->UpdateDITStructure) ? DS_EVENT_SEV_ALWAYS
                                                   : DS_EVENT_SEV_MINIMAL;

    // Hash table for all classes
    start=i=SChash(pCC->ClassId,CLSCOUNT);
    do {
        if (ahcClassAll[i].pVal==NULL || (ahcClassAll[i].pVal== FREE_ENTRY))
        {
            break;
        }
        i=(i+1)%CLSCOUNT;

        if (i==start)
        {
            // can't happen -- The cache is over-allocated to prevent this case
            Assert(!"Schema Cache is Full");
        }

    } while(start!=i);
    ahcClassAll[i].hKey = pCC->ClassId;
    ahcClassAll[i].pVal = pCC;

    // Replication and divergent schemas can result in multiple
    // active classes claiming the same OID. Choose a winner
    // amoung the active classes. Colliding classes are all
    // treated as if they were defunct. The user must choose
    // a winner by officially defuncting the loser.
    //
    // Replication, delete, and rename depend on having an
    // owner for every governsId. Choose a winner amoung the
    // defunct classes.
    if (pCCDup = SCGetClassById(pTHS, pCC->ClassId)) {
        if (pCC->bDefunct && !pCCDup->bDefunct) {
            bWonOid = FALSE;
        } else if (!pCC->bDefunct && pCCDup->bDefunct) {
            scUnhashCls(pTHS, pCCDup, SC_UNHASH_LOST_OID);
            bWonOid = TRUE;
        } else {
            if (0 < memcmp(&pCC->objectGuid,
                           &pCCDup->objectGuid,
                           sizeof(pCC->objectGuid))) {
                scUnhashCls(pTHS, pCCDup, SC_UNHASH_LOST_OID);
                bWonOid = TRUE;
            } else {
                bWonOid = FALSE;
            }
            if (!pCC->bDefunct && !pCCDup->bDefunct) {
                DPRINT5(DebugLevel, "Class %s (%x) %s GovernsId to Class %s (%x)\n",
                        pCC->name, pCC->ClassId,
                        (bWonOid) ? "WON" : "LOST",
                        pCCDup->name, pCCDup->ClassId);
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                          DebugLevel,
                          DIRLOG_SCHEMA_DUP_GOVERNSID,
                          szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                          szInsertSz(pCCDup->name), NULL,
                          NULL, NULL, NULL, NULL);
                pCCDup->bDupOID = TRUE;
                pCC->bDupOID = TRUE;
            }
        }
    } else {
        bWonOid = TRUE;
    }

    // Defunct or not, this class won the OID
    if (bWonOid) {
        start=i=SChash(pCC->ClassId,CLSCOUNT);
        do {
            if (ahcClass[i].pVal==NULL || (ahcClass[i].pVal== FREE_ENTRY))
            {
                break;
            }
            i=(i+1)%CLSCOUNT;

            if (i==start)
            {
                // can't happen -- The cache is over-allocated to prevent this case
                Assert(!"Schema Cache is Full");
            }

        }while(start!=i);

        ahcClass[i].hKey = pCC->ClassId;
        ahcClass[i].pVal = pCC;
    }

    // Once the forest version is raised to DS_BEHAVIOR_SCHEMA_REUSE,
    // defunct classes won't own their schemaIdGuid or their LDN.
    if (pCC->bDefunct && ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr)) {
        DPRINT2(DS_EVENT_SEV_MINIMAL, "Ignoring defunct class %s (%x)\n",
                pCC->name, pCC->ClassId);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_IGNORE_DEFUNCT,
                  szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                  szInsertHex(0), NULL, NULL, NULL, NULL, NULL);
        return 0;
    }

    // Does ClassId collide with an attribute's attributeId?
    // Collisions can occur during an originating write, during out-of-order
    // replication, and because of divergent schemas.
    if ((pACDup = SCGetAttByExtId(pTHS, pCC->ClassId))
        && (!pACDup->bDefunct || pACDup->bIsRdn)) {
        DPRINT5(DebugLevel, "Class %s (%x) duplicates ExtId for Attr %s (%x, %x)\n",
                pCC->name, pCC->ClassId, pACDup->name, pACDup->id, pACDup->Extid);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DebugLevel,
                  DIRLOG_SCHEMA_DUP_GOVERNSID_ATTRIBUTEID,
                  szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                  szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                  NULL, NULL, NULL);
        pACDup->bDupOID = TRUE;
        pCC->bDupOID = TRUE;
    }

    if (!fNullUuid(&pCC->propGuid)) {
        // add this to the schemaIdGuid hash table
        if (pCCDup = SCGetClassByPropGuid(pTHS, pCC)) {
            DPRINT4(DebugLevel, "Class %s (%x) duplicates PropGuid for Class %s (%x)\n",
                    pCC->name, pCC->ClassId, pCCDup->name, pCCDup->ClassId);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_SCHEMAIDGUID_CLASS,
                      szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                      szInsertSz(pCCDup->name), szInsertHex(pCCDup->ClassId),
                      NULL, NULL, NULL, NULL);
            pCCDup->bDupPropGuid = TRUE;
            pCC->bDupPropGuid = TRUE;
        }

       for (i=SCGuidHash(pCC->propGuid, CLSCOUNT);
            ahcClsSchemaGuid[i] && (ahcClsSchemaGuid[i] != FREE_ENTRY);
            i=(i+1)%CLSCOUNT) {
       }
       ahcClsSchemaGuid[i] = pCC;
    }

    if (pCC->name) {
        /* if this class has a name, add it to the name cache */

        if (pCCDup = SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
            DPRINT4(DebugLevel, "Class %s (%x) duplicates LDN for Class %s (%x)\n",
                    pCC->name, pCC->ClassId, pCCDup->name, pCCDup->ClassId);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_CLASS_CLASS,
                      szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                      szInsertSz(pCCDup->name), szInsertHex(pCCDup->ClassId),
                      NULL, NULL, NULL, NULL);
            pCCDup->bDupLDN = TRUE;
            pCC->bDupLDN = TRUE;
        }
        if (pACDup = SCGetAttByName(pTHS, pCC->nameLen, pCC->name)) {
            DPRINT5(DebugLevel, "Class %s (%x) duplicates LDN for Attr %s (%x, %x)\n",
                    pCC->name, pCC->ClassId, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_CLASS_ATTRIBUTE,
                      szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL, NULL);
            pACDup->bDupLDN = TRUE;
            pCC->bDupLDN = TRUE;
        }
        start=i=SCNameHash(pCC->nameLen, pCC->name, CLSCOUNT);
        do
        {
            if (ahcClassName[i].pVal==NULL || (ahcClassName[i].pVal== FREE_ENTRY))
            {
                break;
            }
            i=(i+1)%CLSCOUNT;


            if (i==start)
            {
                // can't happen -- The cache is over-allocated to prevent this case
                Assert(!"Schema Cache is Full");
            }
        }while(start!=i);

        ahcClassName[i].length = pCC->nameLen;
        ahcClassName[i].value = pCC->name;
        ahcClassName[i].pVal = pCC;
    }

    return 0;
}


/*
 * Insert an attcache into the hash tables, and create a JET column if
 * needed.
 */
int
SCAddAttSchema(
    IN THSTATE *pTHS,
    IN ATTCACHE *pAC,
    IN BOOL fNoJetCol,
    IN BOOL fFixingRdn
    )
{
    DECLARESCHEMAPTR

    ULONG i;
    int err;
    ATTRTYP aid;
    ATTRTYP Extid;
    ATTCACHE *pACDup;
    CLASSCACHE *pCCDup;
    USHORT DebugLevel = (pTHS->UpdateDITStructure) ? DS_EVENT_SEV_ALWAYS
                                                   : DS_EVENT_SEV_MINIMAL;

    aid = pAC->id;
    Extid = pAC->Extid;

    // fFixingRdns will only be set when this attribute is being added
    // a second time by scFixRdnAttIds. The second call "resurrects"
    // defuncted or colliding attributes used as rdns.
    if (!fFixingRdn) {
        //
        // Hash in the id, column id, and linkId tables
        //

        // Fill in hash entry normally filled in when scanning jet columns
        if (fNoJetCol) {
            // IntId
            for (i=SChash(aid,ATTCOUNT);
                 ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
            }
            ahcId[i].hKey = aid;
            ahcId[i].pVal = pAC;
        }

        // Create column if needed and add to column hash
        if (fNoJetCol
            && !pAC->ulLinkID
            && !pAC->bIsConstructed
            && pTHS->UpdateDITStructure) {
            /* it's not a link, not constructed att, so must be new and needs a jet column */
            /* create JET col */
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_SCHEMA_CREATING_COLUMN,
                     szInsertUL(Extid), szInsertSz(pAC->name), 0);

            // DBAddCol creates a column for pAC. If needed, DBAddCol will
            // also create an empty index for pAC. An empty index is created
            // because there is no need to scan the rows in the database
            // looking for keys that aren't there.
            err = DBAddCol(pAC);
            if (err) {
                /* Couldn't add column */
                LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_SCHEMA_COLUMN_ADD_FAILED,
                    szInsertUL(Extid), szInsertSz(pAC->name), szInsertUL(err));

                // Remove the attcache from all hash tables (since it may
                // have already been added to the name table etc. by code
                // above. Reset pAC->jColid, since the table freeing
                // routine checks that to see if it needs to free the
                // atcache from the colId table (this is done for safety,
                // since the call to DBAddCol may have changed this)
                pAC->jColid = 0;
                scUnhashAtt(pTHS, pAC, SC_UNHASH_ALL);
                SCFreeAttcache(&pAC);
                return (err);
            }

            /* new column added */
            LogEvent(DS_EVENT_CAT_SCHEMA,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_SCHEMA_COLUMN_ADDED,
                szInsertUL(pAC->jColid), szInsertSz(pAC->name), szInsertUL(Extid));

            // jColid
            for (i=SChash(pAC->jColid,ATTCOUNT);
                    ahcCol[i].pVal && (ahcCol[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
            }
            ahcCol[i].hKey = pAC->jColid;
            ahcCol[i].pVal = pAC;
        }

        // Need to fill in the hints
        if (pAC->pszIndex) {
            DBGetIndexHint(pAC->pszIndex, &pAC->pidxIndex);
        }
        if (pAC->pszPdntIndex) {
            DBGetIndexHint(pAC->pszPdntIndex, &pAC->pidxPdntIndex);
        }
        if (pAC->pszTupleIndex) {
            DBGetIndexHint(pAC->pszTupleIndex, &pAC->pidxTupleIndex);
        }

        // Link Id table
        if (pAC->ulLinkID) {
            /* if this att is a link or backlink, add it to link cache */
            for (i=SChash(pAC->ulLinkID, ATTCOUNT);
                    ahcLink[i].pVal && (ahcLink[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcLink[i].hKey = pAC->ulLinkID;
            ahcLink[i].pVal = pAC;
        }
    }

    // Defunct attributes do not own their OID, LDN, SchemaIdGuid, or MapiId
    //     Unless the attribute is used as an rdn
    //     Unless the forest version is pre-schema-reuse
    if (pAC->bDefunct
        && !pAC->bIsRdn
        && ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr)) {
        DPRINT3(DS_EVENT_SEV_MINIMAL, "Ignoring defunct attribute %s (%x, %x)\n",
                pAC->name, pAC->id, pAC->Extid);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_IGNORE_DEFUNCT,
                  szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                  NULL, NULL, NULL, NULL, NULL);
        return 0;
    }

    //
    // ahcExtid
    //

    // Collisions can occur during an originating write, during out-of-order
    // replication, and because of divergent schemas. The colliding
    // attributes are treated as if defunct except when used as an
    // rdnattid of any class, live or defunct, or when FLAG_ATTR_IS_RDN
    // is set in ATT_SYSTEM_FLAGS.
    if (pACDup = SCGetAttByExtId(pTHS, pAC->Extid)) {
        DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates Extid for Attr %s (%x, %x)\n",
                pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DebugLevel,
                  DIRLOG_SCHEMA_DUP_ATTRIBUTEID,
                  szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                  szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                  NULL, NULL);
        pACDup->bDupOID = TRUE;
        pAC->bDupOID = TRUE;
    }
    for (i=SChash(Extid,ATTCOUNT);
        ahcExtId[i].pVal && (ahcExtId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
    }
    ahcExtId[i].hKey = Extid;
    ahcExtId[i].pVal = pAC;

    // Collisions can occur during an originating write, during out-of-order
    // replication, when resurrecting a defunct attribute used as an
    // RdnAttid, and because of divergent schemas. The colliding
    // class is treated as it were defunct and the attribute is treated
    // as if it were defunct except when the attribute is used as an
    // rdnattid of any class, live or defunct, or when FLAG_ATTR_IS_RDN
    // is set in ATT_SYSTEM_FLAGS. See scFixRdnAttId and scFixCollisions.
    //
    // Does an active ClassId collide with this attribute's attributeId?
    //
    // Don't bother checking unless the attribute is being resurrected
    // as an rdnattid. Otherwise, the class hash tables are empty
    // because they are loaded after the attribute hash tables.
    if (fFixingRdn
        && (pCCDup = SCGetClassById(pTHS, pAC->Extid))
        && !pCCDup->bDefunct) {
        DPRINT5(DebugLevel, "Class %s (%x) duplicates ExtId for Attr %s (%x, %x)\n",
                pCCDup->name, pCCDup->ClassId, pAC->name, pAC->id, pAC->Extid);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DebugLevel,
                  DIRLOG_SCHEMA_DUP_GOVERNSID_ATTRIBUTEID,
                  szInsertSz(pCCDup->name), szInsertHex(pCCDup->ClassId),
                  szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                  NULL, NULL, NULL);
        pCCDup->bDupOID = TRUE;
        pAC->bDupOID = TRUE;
    }

    //
    // ahcAttSchemaGuid
    //

    if (!fNullUuid(&pAC->propGuid)) {
       //  add this to the schemaIdGuid hash table.
       //
       // Don't bother checking the class hash, no classes are loaded.
       // SCAddClassSchema will check for dups against the attributes, later.
        if (pACDup = SCGetAttByPropGuid(pTHS, pAC)) {
            DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates PropGuid for Attr %s (%x, %x)\n",
                    pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_SCHEMAIDGUID_ATTRIBUTE,
                      szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL);
            pACDup->bDupPropGuid = TRUE;
            pAC->bDupPropGuid = TRUE;
        }
        for (i=SCGuidHash(pAC->propGuid, ATTCOUNT);
             ahcAttSchemaGuid[i] && (ahcAttSchemaGuid[i] != FREE_ENTRY);
             i=(i+1)%ATTCOUNT) {
        }
        ahcAttSchemaGuid[i] = pAC;
    }

    //
    // ahcMapi
    //
    if (pAC->ulMapiID) {
        /* if this att is MAPI visible, add it to MAPI cache */
        if (pACDup = SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
            DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates MapiID for Attr %s (%x, %x)\n",
                    pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_MAPIID,
                      szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL);
            pACDup->bDupMapiID = TRUE;
            pAC->bDupMapiID = TRUE;
        }
        for (i=SChash(pAC->ulMapiID, ATTCOUNT);
             ahcMapi[i].pVal && (ahcMapi[i].pVal!= FREE_ENTRY);
             i=(i+1)%ATTCOUNT) {
        }
        ahcMapi[i].hKey = pAC->ulMapiID;
        ahcMapi[i].pVal = pAC;
    }

    //
    // ahcName
    //
    if (pAC->name) {
        // if this att has a name, add it to the name cache

        // check for dup names
        if (pACDup = SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
            DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates LDN for Attr %s (%x, %x)\n",
                    pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_ATTRIBUTE,
                      szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL);
            pACDup->bDupLDN = TRUE;
            pAC->bDupLDN = TRUE;
        }
        // Don't bother checking unless the attribute is being resurrected
        // as an rdnattid. Otherwise, the class hash tables are empty
        // because they are loaded after the attribute hash tables.
        if (fFixingRdn
            && (pCCDup = SCGetClassByName(pTHS, pAC->nameLen, pAC->name))
            && !pCCDup->bDefunct) {
            DPRINT5(DebugLevel, "Class %s (%x) duplicates LDN for Attr %s (%x, %x)\n",
                    pCCDup->name, pCCDup->ClassId, pAC->name, pAC->id, pAC->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_CLASS_ATTRIBUTE,
                      szInsertSz(pCCDup->name), szInsertHex(pCCDup->ClassId),
                      szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                      NULL, NULL, NULL);
            pCCDup->bDupLDN = TRUE;
            pAC->bDupLDN = TRUE;
        }
#if DBG
{
        ULONG CheckForFreeEntry;
        for (i=SCNameHash(pAC->nameLen, pAC->name, ATTCOUNT), CheckForFreeEntry = i;
                    ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            if ( i+1 == CheckForFreeEntry ) {
                Assert(!"No free entries!");
            }

        }
}
#else
        for (i=SCNameHash(pAC->nameLen, pAC->name, ATTCOUNT);
                    ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
        }
#endif

        ahcName[i].length = pAC->nameLen;
        ahcName[i].value = pAC->name;
        ahcName[i].pVal = pAC;
    }

    return 0;
}

/*
 * Remove an attribute from the schema cache
 */
int SCDelAttSchema(THSTATE *pTHS,
                   ATTRTYP attrid)
{
    ATTCACHE *pAC;

    // Find cache entry

    if (!(pAC = SCGetAttById(pTHS, attrid))) {
        Assert (FALSE);
        return !0;
    }

    scUnhashAtt (pTHS, pAC, SC_UNHASH_ALL);
    SCFreeAttcache(&pAC);

    return 0;
}


/*
 * Remove a class from the schema cache
 */
int SCDelClassSchema(ATTRTYP ClassId)
{
    THSTATE *pTHS=pTHStls;
    CLASSCACHE *pCC;

    // Find cache entry

    if (!(pCC = SCGetClassById(pTHS, ClassId))) {
        Assert (FALSE);
        return !0;
    }

    scUnhashCls (pTHS, pCC, SC_UNHASH_ALL);
    SCFreeClasscache(&pCC);

    return 0;
}

int
SCEnumMapiProps(
        unsigned * pcProps,
        ATTCACHE ***ppACBuf
        )
/*
 * Enumerate all MAPI accessible properties (attributes).
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cProps = 0;
    ATTCACHE ** pACBuf;
    ULONG i;

    pACBuf = THAllocEx(pTHS, ATTCOUNT*sizeof(void*));

    for (i=0; i<ATTCOUNT; i++) {
        if (ahcMapi[i].pVal && (ahcMapi[i].pVal != FREE_ENTRY)) {
            pACBuf[cProps] = (ATTCACHE*)(ahcMapi[i].pVal);
            ++cProps;
        }
    }

    *ppACBuf = THReAllocEx(pTHS, pACBuf, cProps * sizeof(void *));
    *pcProps = cProps;

    return(0);
}

int
SCEnumNamedAtts(
        unsigned * pcAtts,
        ATTCACHE ***ppACBuf
        )
/*
 * Enumerate all attributes that have names.
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cAtts = 0;
    ATTCACHE ** pACBuf, * pAC;
    ULONG i;

    pACBuf = THAllocEx(pTHS, ATTCOUNT*sizeof(void*));

    for (i=0; i<ATTCOUNT; i++) {
        if ((pAC = ahcName[i].pVal)
            && (pAC != FREE_ENTRY)
            // Hide defunct attrs in schema-reuse forests
            && (!pAC->bDefunct || !ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr))) {
            pACBuf[cAtts] = (ATTCACHE*)(ahcName[i].pVal);
            ++cAtts;
        }
    }

    *pcAtts = cAtts;
    *ppACBuf = THReAllocEx(pTHS, pACBuf,cAtts*sizeof(void *));

    return(0);
}

int
SCEnumNamedClasses(
        unsigned * pcClasses,
        CLASSCACHE ***ppCCBuf
        )
/*
 * Enumerate all classes that have names.
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cClasses = 0;
    CLASSCACHE ** pCCBuf;
    ULONG i;

    pCCBuf = THAllocEx(pTHS, CLSCOUNT*sizeof(void*));

    for (i=0; i<CLSCOUNT; i++) {
        if (ahcClassName[i].pVal && (ahcClassName[i].pVal != FREE_ENTRY)) {
            pCCBuf[cClasses] = (CLASSCACHE*)(ahcClassName[i].pVal);
            ++cClasses;
        }
    }

    // pCCBuf may have been over-allocated. Shrink to fit.
    //
    // PERFHINT - pCCBuf may be invariant for a given schema cache.
    // If this proves to be true, consider saving pCCBuf in CurrSchemaPtr
    // for future calls to this function.
    *pcClasses = cClasses;
    *ppCCBuf = THReAllocEx(pTHS, pCCBuf,cClasses * sizeof(void *));

    return(0);
}

int
SCEnumNamedAuxClasses(
        unsigned * pcClasses,
        CLASSCACHE ***ppCCBuf
        )
/*
 * Enumerate all the aux classes that have names.
 * Note that the class 88 is not counted.
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cClasses = 0;
    CLASSCACHE ** pCCBuf;
    ULONG i;

    pCCBuf = THAllocEx(pTHS, CLSCOUNT*sizeof(void*));

    for (i=0; i<CLSCOUNT; i++) {
        if (ahcClassName[i].pVal &&
            (ahcClassName[i].pVal != FREE_ENTRY) &&
            ( (((CLASSCACHE*)(ahcClassName[i].pVal))->ClassCategory) == DS_AUXILIARY_CLASS)){
                    pCCBuf[cClasses] = (CLASSCACHE*)(ahcClassName[i].pVal);
                    ++cClasses;
        }
    }

    // pCCBuf may have been over-allocated. Shrink to fit.
    //
    // PERFHINT - pCCBuf may be invariant for a given schema cache.
    // If this proves to be true, consider saving pCCBuf in CurrSchemaPtr
    // for future calls to this function.
    *pcClasses = cClasses;
    *ppCCBuf = THReAllocEx(pTHS, pCCBuf,cClasses * sizeof(void *));

    return(0);
}



void
SCAddANRid (
        DWORD aid
        )
/*
 * Add the given ID to the list of IDs to ANR on.  Trim dups, allocate
 * more space as necessary.
 *
 */
{
    SCHEMAPTR *pSchema = (SCHEMAPTR *)pTHStls->CurrSchemaPtr;
    DWORD i;

    if(!pSchema->caANRids) {
        /* First time in.  Alloc some space */
        if (SCCalloc(&pSchema->pANRids, 1, 50*sizeof(DWORD))) {
            /* no memory? */
            return;
        }
        pSchema->caANRids=50;
        pSchema->cANRids=0;
    }

    for(i=0;i<pSchema->cANRids;i++)
        if(pSchema->pANRids[i] == aid)
            /* Already here. */
            return;

    if(pSchema->caANRids == pSchema->cANRids) {
        /* Need more space */
        if (SCRealloc(&pSchema->pANRids, 2*pSchema->caANRids*sizeof(DWORD))) {
            /* no memory? */
            return;
        }
        pSchema->caANRids *= 2;
    }

    pSchema->pANRids[pSchema->cANRids] = aid;
    pSchema->cANRids++;
}

/*
 * Return the number of IDs to ANR on, and fill in the variable
 * given to us with a pointer to the first id to ANR on.
 */
DWORD SCGetANRids(LPDWORD * IDs)
{
    SCHEMAPTR *pSchema = (SCHEMAPTR *)pTHStls->CurrSchemaPtr;

    *IDs = pSchema->pANRids;

    return pSchema->cANRids;
}

//-----------------------------------------------------------------------
//
// Function Name:            SCCanUpdateSchema
//
// Routine Description:
//
//    Checks to see if Schema Update should be allowed
//    Allow Schema Change if this DSA is the FSMO Role
//    Owner and the system is running.
//
// Arguments:
//    pTHS - THSTATE pointer
//
// Return Value:
//
//    BOOL             TRUE if Schema Update is allowed
//
//-----------------------------------------------------------------------
BOOL
SCCanUpdateSchema(THSTATE *pTHS)
{
    ULONG schemaupdateallowed=0;
    int err=0;
    DSNAME *pOwner;
    ULONG len, dntSave;
    DBPOS *pDB;
    BOOL roleOwner=FALSE, regKeyPresent=FALSE;

    if (pTHS->fDRA) {
	return TRUE;
    }

    if ( DsaIsRunning() )
    {
           Assert(pTHS->pDB);
           // save currency
           dntSave = pTHS->pDB->DNT;
           __try {
               err = DBFindDSName(pTHS->pDB, gAnchor.pDMD);
               if (err) {
                   __leave;
               }

               err = DBGetAttVal(pTHS->pDB,
                                 1,
                                 ATT_FSMO_ROLE_OWNER,
                                 0,
                                 0,
                                 &len,
                                 (UCHAR **)&pOwner);
               if (err) {
                   __leave;
               }

               // check if this DSA is the FSMO Role Owner

               if (!NameMatched(pOwner,gAnchor.pDSADN) ||
                   !IsFSMOSelfOwnershipValid( gAnchor.pDMD )) {
                    __leave;
               }

               // Schema update is allowed
               schemaupdateallowed = 1;

          } /* try */
          __finally {

            // restore currency
            DBFindDNT(pTHS->pDB, dntSave);
          }
    }
    else
    {
        //
        // We are installing
        //
        schemaupdateallowed=1;
    }

    return schemaupdateallowed!=0;
} // End CanUpdateSchema

int
SCLegalChildrenOfClass(
    ULONG       parentClass,            // IN
    ULONG       *pcLegalChildren,       // OUT
    CLASSCACHE  ***ppLegalChildren)     // OUT

/*++

Routine Description:

    Determines the set of classes which can be instantiated as children
    of the class identified by parentClass.  Assumes the caller has
    a valid thread state.

Arguments:

    parentClass - Class id of the parent under which a child is desired.

    pcLegalChildren - pointer to count of legal children.

    ppLegalChildren - pointer to array of CLASSCACHE pointers representing
        legal children.

Return Value:

    0 on success, !0 otherwise.
    May throw an exception - eg: THAllocEx is used.

--*/

{
    THSTATE *pTHS=pTHStls;
    int         err;
    unsigned    i, j, k;
    CLASSCACHE  *pParentClassCC;
    CLASSCACHE  *pCC;
    unsigned    cAllCC;
    CLASSCACHE  **ppAllCC;
    BOOL        fIsLegalChild;

    Assert(NULL != pTHS);

    pParentClassCC = SCGetClassById(pTHS, parentClass);

    if ( NULL == pParentClassCC )
        return(ERROR_DS_INTERNAL_FAILURE);

    err = SCEnumNamedClasses(&cAllCC, &ppAllCC);

    if ( 0 != err )
        return(err);

    // The legal children classes are those which have parentClass or a class
    // which parentClass derives from, in their pPossSup array.  Consider the
    // class hierarchy Top-A-B-C-D and the parentClass of interest is B.
    // Clearly any class which claims B as a possible superior should be
    // returned.  An instance of class B is as good as or better than an
    // instance of class A.  Thus any class which required A as a possible
    // superior implicitly should be satisfied with B as a possible superior.
    // So we need to return the classes which list the classes B is derived from
    // as possible superiors.
    // Note that we close the possible superiors list of each classcache.  For
    // example, assume E is the superclass of F.  Further, in the directory, E
    // lists A as a possilbe superior and F lists C.  In the classcache
    // structure, the cache element for E lists A as a possible superior and the
    // element for F lists A and C.  Thus, if B were the class of interest, we
    // will (with no extra work) return E (because it lists A as a possible
    // superor, and A is a superclass of B) and F (because it also lists A
    // because it inherited this from E).

    *pcLegalChildren = 0;
    *ppLegalChildren = (CLASSCACHE**)THAllocEx(pTHS, sizeof(CLASSCACHE*) * cAllCC);

    // check each class
    for (i = 0; i < cAllCC; i++) {
        pCC = ppAllCC[i];
        // Filter out system-only and defunct classes as an external client
        // can't create one of them. Also filter out any abstract or auxiliary
        // classes since these cannot be instantiated anyway.
        if (pCC->bDefunct ||
            pCC->bSystemOnly ||
            pCC->ClassCategory == DS_ABSTRACT_CLASS ||
            pCC->ClassCategory == DS_AUXILIARY_CLASS)
        {
            continue;
        }
        // check if pCC has parentClass or any of its superclasses as a superior.
        fIsLegalChild = FALSE;
        // check every possSuperior of pCC
        for (j = 0; j < pCC->PossSupCount; j++) {
            // is parentClass our superior?
            if (pCC->pPossSup[j] == parentClass) {
                fIsLegalChild = TRUE;
            }
            else {
                // check superclasses of pParentClassCC
                for (k = 0; k < pParentClassCC->SubClassCount; k++) {
                    // is this superclass one of pCC's superiours?
                    if (pCC->pPossSup[j] == pParentClassCC->pSubClassOf[k]) {
                        fIsLegalChild = TRUE;
                        break;
                    }
                }
            }
            if (fIsLegalChild) {
                // We found a poss superior.
                // It's either parentClass or one of its superclasses
                break;
            }
        }
        if (fIsLegalChild) {
            (*ppLegalChildren)[(*pcLegalChildren)++] = pCC;
        }
    }

    THFreeEx(pTHS, ppAllCC);

    return(0);
}

int
SCLegalChildrenOfName(
    DSNAME      *pDSName,               // IN
    DWORD       flags,                  // IN
    ULONG       *pcLegalChildren,       // OUT
    CLASSCACHE  ***ppLegalChildren)     // OUT

/*++

Routine Description:

    Determines the set of classes which can be instantiated as children
    of the object identified by pDSName.  Assumes the caller has
    a valid thread state, but not necessarily an open database.  This
    version of the procedure is intended for callers outside the core
    who are constructing a virtual attribute.

Arguments:

    pDSName - DSNAME of object under which a child is desired.

    SecurityFilter - Boolean which indicates whether to filter results by
        actual rights caller has in the parent container.

    pcLegalChildren - pointer to count of legal children.

    ppLegalChildren - pointer to array of CLASSCACHE pointers representing
        legal children.

Return Value:

    0 on success, !0 otherwise.
    Will not throw an exception.
    Will not set pTHStls->errCode.

--*/

{
    THSTATE *pTHS=pTHStls;
    int                  retVal = 1;
    DBPOS                *pDB;
    ULONG                ClassId;
    ULONG                cCandidates;
    CLASSCACHE           **rCandidates;
    CLASSCACHE           *pCC;
    ULONG                len;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    BOOL                 fSDIsGlobalSDRef;
    ULONG                i;

    Assert(NULL != pTHS);

    *pcLegalChildren = 0;
    *ppLegalChildren = NULL;

    DBOpen(&pDB);

    __try
    {
        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        retVal = DBFindDSName(pDB, pDSName);

        if ( 0 != retVal )
            __leave;

        retVal = DBGetSingleValue(
                pDB,                                    // DBPos
                flags == SC_CHILDREN_USE_GOVERNS_ID ?   // which attribute
                    ATT_GOVERNS_ID : ATT_OBJECT_CLASS,
                &ClassId,                               // output buffer
                sizeof(ClassId),                        // buffer size
                &len);                                  // output buffer size

        if ( 0 != retVal )
            __leave;

        retVal = SCLegalChildrenOfClass(ClassId,
                                        &cCandidates,
                                        &rCandidates);
        if ( 0 != retVal )
            __leave;

        if(flags == SC_CHILDREN_USE_SECURITY) {
            // Get the Security Descriptor and the SID
            retVal = DBGetObjectSecurityInfo(
                    pDB,                    // DBPOS
                    pDB->DNT,               // current DNT
                    &len,                   // SD length
                    &pNTSD,                 // SD ptr
                    NULL,                   // not interested in obj class
                    pDSName,                // DN of the object (GUID and SID will be filled)
                    NULL,                   // not interested in obj flag
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef);     // is SD a global reference?

            if( 0 != retVal )
                __leave;

            // Filter result by determining what the caller really has a right
            // to create under the parent.
            // get the class pointer
            pCC = SCGetClassById(pTHS, ClassId);
            // Apply the security
            // No auditing because this is a "test" access check, no actual
            // create_child operation is being performed. The access has been
            // already audited as READ_PROPERTY on the constructed attribute.
            CheckSecurityClassCacheArray(pTHS,
                                         RIGHT_DS_CREATE_CHILD,
                                         pNTSD,
                                         pDSName,
                                         cCandidates,
                                         rCandidates,
                                         pCC,
                                         CHECK_PERMISSIONS_WITHOUT_AUDITING
                                         );

            // OK, we've Nulled out any elements in the rCandidates array
            // which we don't have add children rights to.
        }

        // allocate the return list
        *ppLegalChildren = THAllocEx(pTHS, cCandidates * sizeof(CLASSCACHE *));


        // Filter out classes that we decided to be illegal to to
        // security problems. Abstract, auxiliary, system-only and
        // defunct classes were already filtered out by
        // SCLegalChildrenOfClass().
        for ( i = 0; i < cCandidates; i++ ) {
            if(rCandidates[i] == NULL) {
                continue;
            }

            // Finally a class the caller can add!

            (*ppLegalChildren)[(*pcLegalChildren)++] = rCandidates[i];
        }
    }
    __finally
    {
        if ( AbnormalTermination() )
            retVal = 1;

        // Committing read-only transaction is faster than aborting it.
        DBClose(pDB, TRUE);

        if (pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
    }

    return(retVal);
}


int
SCLegalAttrsOfName(
    DSNAME      *pDSName,           // IN
    BOOL        SecurityFilter,     // IN
    ULONG       *pcLegalAttrs,      // OUT
    ATTCACHE    ***ppLegalAttrs)    // OUT

/*++

Routine Description:

    Determines the set of attributes which can be modified
    on the object identified by pDSName.  Assumes the caller has
    a valid thread state, but not necessarily an open database.  This
    version of the procedure is intended for callers outside the core
    who are constructing a virtual attribute.

Arguments:

    pDSName - DSNAME of object under which a child is desired.

    SecurityFilter - Boolean which indicates whether to filter results by
        actual rights caller has on the pDSName object.

    pcLegalAttrs - pointer to count of legal attributes.

    ppLegalAttrs - pointer to array of ATTCACHE pointers representing
        writeable attrs.

Return Value:

    0 on success, !0 otherwise.
    Will not throw an exception.
    Will not set pTHStls->errCode.

--*/

{
    THSTATE *pTHS=pTHStls;
    int                  retVal = 1;
    DBPOS                *pDB;
    ULONG                *pClassId;
    ULONG                cCandidates;
    ULONG                *rCandidates=NULL;
    ATTCACHE             **rpCandidatesAC;
    CLASSCACHE           **pAuxCls=NULL;
    ULONG                cAllocs, cAuxCls;
    CLASSCACHE           *pCC, *pCCAux;
    ATTCACHE             *pAC;
    ULONG                len;
    ULONG                i, j, tmp, err;
    BOOL                 found;
    ATTRTYP              *pTemp;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    DSNAME              *pDNImproved=NULL;
    BOOL                fSDIsGlobalSDRef = TRUE;
    Assert(NULL != pTHS);

    *pcLegalAttrs = 0;
    *ppLegalAttrs = NULL;

    DBOpen(&pDB);

    __try
    {
        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        retVal = DBFindDSName(pDB, pDSName);

        if ( 0 != retVal )
            leave;

        pAC = SCGetAttById(pTHS,ATT_OBJECT_CLASS);

        // Get the Security Descriptor and the SID
        retVal = DBGetObjectSecurityInfo(
                    pTHS->pDB,              // DBPOS
                    pTHS->pDB->DNT,         // current DNT
                    &len,                   // SD length
                    &pNTSD,                 // SD ptr
                    &pCC,                    // obj class
                    pDSName,                // DN of the object (GUID and SID will be filled)
                    NULL,                   // not interested in obj flag
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef);     // is SD a global reference?

        if( 0 != retVal ){
            __leave;
        }


        // pAuxCls will stores the dynamic aux classes of the
        // of the object.  The initial size of the buffer is set to 8.

        cAllocs = 8;
        cAuxCls = 0;
        pAuxCls = (CLASSCACHE **) THAllocEx(pTHS, cAllocs * sizeof(CLASSCACHE*));

        cCandidates = pCC->MustCount + pCC->MayCount;

        pTemp = THAllocEx(pTHS, sizeof(ATTRTYP));

        // look for the aux classes in the objectClass

        err = 0;

        for (i=1;!err;i++) {

            err = DBGetAttVal_AC(pDB,
                                 i,
                                 pAC,
                                 DBGETATTVAL_fCONSTANT,
                                 sizeof(ATTRTYP),
                                 &len,
                                 (UCHAR **)&pTemp);

            switch (err) {
               case DB_ERR_NO_VALUE:
                    break;

               case 0:

                    pCCAux = SCGetClassById(pTHS, *pTemp);
                    if (!pCCAux) {
                        retVal = 1;
                        Assert(FALSE);
                        leave;

                    }

                    switch (pCCAux->ClassCategory) {
                    case  DS_88_CLASS:
                        // this class could belong to the inheritance hierachy.
                        if(FindMoreSpecificClass(pCC, pCCAux)){
                            continue;
                        }
                        break;

                    case DS_AUXILIARY_CLASS:
                        break;

                    case DS_STRUCTURAL_CLASS:
                    case DS_ABSTRACT_CLASS:
                    default:
                        // not aux class, skip
                        continue;
                        break;
                    }

                    // realloc the buffer if necessary
                    if (cAuxCls >= cAllocs) {
                        cAllocs *= 2;  //double the size
                        pAuxCls = THReAllocEx(pTHS,
                                              pAuxCls,
                                              sizeof (CLASSCACHE*) * (cAllocs));
                    }

                    pAuxCls[cAuxCls] = pCCAux;
                    cCandidates += pCCAux->MustCount + pCCAux->MayCount;
                    cAuxCls++;
                    break;

                default:
                    // other error
                    retVal = 1;
                    leave;

            }  /* switch */

        }


        // Construct array of candidate ATTCACHE pointers sans duplicates.

        rCandidates = (ULONG *) THAllocEx(pTHS, cCandidates * sizeof(ULONG));
        rpCandidatesAC = (ATTCACHE **)
            THAllocEx(pTHS, cCandidates * sizeof(ATTCACHE *));

        tmp = 0;
        for ( i = 0; i < pCC->MustCount; i++ )
            rCandidates[tmp++] = pCC->pMustAtts[i];
        for ( i = 0; i < pCC->MayCount; i++ )
            rCandidates[tmp++] = pCC->pMayAtts[i];

        for (i = 0; i<cAuxCls; i++) {
            for (j=0;j<pAuxCls[i]->MustCount;j++) {
                rCandidates[tmp++] = pAuxCls[i]->pMustAtts[j];
            }
            for (j=0;j<pAuxCls[i]->MayCount;j++) {
                rCandidates[tmp++] = pAuxCls[i]->pMayAtts[j];
            }
        }

        // Eliminate duplicates and map to ATTCACHE pointer.
        // PerfHint: we could qsort the list and do a linear
        // pass to get rid of dups.

        Assert(tmp == cCandidates);
        cCandidates = 0;

        for ( i = 0; i < tmp; i++ )
        {
            found = FALSE;

            for ( j = 0; j < i; j++ )
            {
                if ( rCandidates[i] == rCandidates[j] )
                {
                    found = TRUE;
                    break;
                }
            }

            if ( !found )
            {
                if (!(rpCandidatesAC[cCandidates++] =
                      SCGetAttById(pTHS, rCandidates[i]))) {
                    retVal = 1;
                    leave;
                }
            }
        }

        // cCandidates and rpCandidatesAC are now valid.

        if ( !SecurityFilter )
        {
            *pcLegalAttrs = cCandidates;
            *ppLegalAttrs = rpCandidatesAC;
            retVal = 0;
            leave;
        }
        else {
            // Apply the security
            CheckSecurityAttCacheArray(pTHS,
                                       RIGHT_DS_WRITE_PROPERTY,
                                       pNTSD,
                                       pDSName,
                                       pCC,
                                       pCC,
                                       cCandidates,
                                       rpCandidatesAC,
                                       CHECK_PERMISSIONS_WITHOUT_AUDITING,
                                       NULL,
                                       NULL
                                       );





            // Any properties we don't have rights to have been replaced
            // with a NULL in rgpAC.  Constructed attributes (except entryTTL)
            // and backlink attributes are not writable, let's screen them out too.
            // if TO_SKIP(x) is true, then x should be excluded from the result.

#define TO_SKIP(x) (!(x) ||                                                 \
       (FIsBacklink((x)->ulLinkID)) ||                                      \
       ((x)->bIsConstructed                                                 \
         && (x)->id != ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId))


            // Start by trimming off NULLS from the end of the list.
            while (cCandidates && TO_SKIP(rpCandidatesAC[cCandidates-1])) {
                cCandidates--;
            }


            // OK, if the list still has anything in it, then it ends with a
            // non-NULL element.

            for(i=0;i<cCandidates;i++) {

                if(TO_SKIP(rpCandidatesAC[i])){
                    // Found one we don't have rights to.  Trim it out of the
                    // list by grabbing the one from the end.
                    cCandidates--;
                    rpCandidatesAC[i] = rpCandidatesAC[cCandidates];

                    while (i < cCandidates && TO_SKIP(rpCandidatesAC[cCandidates-1])) {
                        cCandidates--;
                    }
                    // OK, if the list still has anything in it, then it ends
                    // with a non-NULL element.
                }
            }

#undef TO_SKIP

            // We've checked security and trimmed non-writable elements.
            *pcLegalAttrs = cCandidates;
            *ppLegalAttrs = rpCandidatesAC;
            retVal = 0;
            leave;
        }

        Assert("SecurityFilter for SCLegalAttrs not yet implemented!");

        retVal = 1;
    }
    __finally
    {
        if ( AbnormalTermination() )
            retVal = 1;

        // Committing read-only transaction is faster than aborting it.
        DBClose(pDB, TRUE);

        if(pAuxCls) {
            THFreeEx(pTHS,pAuxCls);
        }
        if (rCandidates) {
            THFreeEx(pTHS,rCandidates);
        }
        if (!fSDIsGlobalSDRef) {
            THFreeEx(pTHS,pNTSD);
        }

    }

    return(retVal);
}

DSTIME SchemaFsmoLease;
VOID
SCExtendSchemaFsmoLease()
/*++
Routine Description:
    Extend the schema fsmo lease.

    The schema fsmo cannot be transferred for a few seconds after
    it has been transfered or after a schema change (excluding
    replicated or system changes). This gives the schema admin a
    chance to change the schema before having the fsmo pulled away
    by a competing schema admin who also wants to make schema
    changes.

    The length of the lease can only be altered by setting the registry
    and rebooting. See dsamain.c, GetDSARegistryParameters().

Arguments:
    None.

Return Values:
    None.
--*/
{
    SchemaFsmoLease = DBTime();
} // End SCExtendSchemaFsmoLease

BOOL
SCExpiredSchemaFsmoLease()
/*++
Routine Description:
    Has the schema fsmo lease expired?

    The schema fsmo cannot be transferred for a few seconds after
    it has been transfered or after a schema change (excluding
    replicated or system changes). This gives the schema admin a
    chance to change the schema before having the fsmo pulled away
    by a competing schema admin who also wants to make schema
    changes.

    The length of the lease can only be altered by setting the registry
    and rebooting. See dsamain.c, GetDSARegistryParameters().

Arguments:
    None.

Return Values:
    TRUE - has expired
    FALSE - has not expired
--*/
{
    DSTIME  Now = DBTime();
    extern ULONG gulSchemaFsmoLeaseSecs;

    // the lease is ridiculous or has expired
    if (   SchemaFsmoLease > Now
        || (SchemaFsmoLease + gulSchemaFsmoLeaseSecs) <= Now) {
        return TRUE;
    }

    // the lease is still held
    return FALSE;
} // End SCExpiredSchemaFsmoLease

BOOL
SCSignalSchemaUpdateLazy()
/*++
Routine Description:
    Wakeup the async thread, SCSchemaUpdateThread, to refresh the
    schema cache in 5 minutes.

Arguments:
    None.

Return Values:
    TRUE on success
--*/
{
    SCHEMASTATS_INC(SigLazy);
    return SetEvent(evSchema);
} // End SignalSchemaUpdateLazy

BOOL
SCSignalSchemaUpdateImmediate()
/*++
Routine Description:
    Wakeup the async thread, SCSchemaUpdateThread, to refresh the
    schema cache, now, after boosting its priority to a normal
    priority.

Arguments:
    None.

Return Values:
    TRUE on success
--*/
{
    SCHEMASTATS_INC(SigNow);
    // First, increase the thread's priority
    if (hAsyncSchemaUpdateThread) {
        SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_NORMAL);
    }
    return SetEvent(evUpdNow);
} // End SignalSchemaUpdateLazy

BOOL
SCCacheIsStale(
    VOID
    )
/*++
Routine Description:
    The cache is deemed "stale" if the global count of schema changes
    does not match the saved value in the schema cache.

    WARNING: the count is not incremented for every change to the database
    that would alter the incore schema cache. Rather it seems to be a count
    of changes that might affect the replication subsystem. Hence the cache
    reload thread can't use the count to discover if the schema cache is
    already up-to-date. We need a schema-dirty bit to prevent
    reloading an already up-to-date cache.

Arguments:
    None.

Return Values:
    TRUE if the schema cache appears to be stale
    FALSE if the schema cache appears to be up-to-date
--*/
{
    BOOL Ret = FALSE;

    const PPLS ppls = GetPLS();
    SyncEnterRWLockAsReader( &ppls->rwlSchemaPtrUpdate );
    __try {
        if (!CurrSchemaPtr ||
            CurrSchemaPtr->lastChangeCached < gNoOfSchChangeSinceBoot) {
            Ret = TRUE;
        }
    } __finally {
        SyncLeaveRWLockAsReader( &ppls->rwlSchemaPtrUpdate );
    }
    return Ret;
} // End SCCacheIsStale

VOID
SCRefreshSchemaPtr(
    IN THSTATE *pTHS
    )
/*++
Routine Description:
    Replace the thread's schema pointer with the address of the current
    schema cache if:
        There is a current schema cache.
        The thread's schema cache pointer is not current.

    Decrement the ref count on the old schema cache and increment
    the ref count on the new schema cache. The old schema cache
    will be freed after its ref count hits 0.

Arguments:
    pTHS - thread state

Return Values:
    None.
--*/
{
    // Update the schema ptr in pTHS
    const PPLS ppls = GetPLS();
    SyncEnterRWLockAsReader( &ppls->rwlSchemaPtrUpdate );
    __try {
        // update iff one already exists
        if (CurrSchemaPtr && pTHS->CurrSchemaPtr != CurrSchemaPtr) {

            // release old schema ptr if present
            if (pTHS->CurrSchemaPtr) {
                InterlockedDecrement(&(((SCHEMAPTR *) (pTHS->CurrSchemaPtr))->RefCount));
            }

            // acquire new schema ptr
            pTHS->CurrSchemaPtr = CurrSchemaPtr;
            InterlockedIncrement(&(((SCHEMAPTR *) (pTHS->CurrSchemaPtr))->RefCount));
        }
    } __finally {
        SyncLeaveRWLockAsReader(&ppls->rwlSchemaPtrUpdate);
    }
} // End SCRefreshSchemaPtr

BOOL
SCReplReloadCache(
    IN THSTATE  *pTHS,
    IN DWORD    TimeoutInMs
    )
/*++
Routine Description:
    Reload the schema cache for the replication subsystem.
        If the cache is stale, reload it.
        If the thread's schema cache pointer is stale, refresh it.

    The cache is deemed "stale" if the global count of schema changes
    does not match the saved value in the schema cache. WARNING: the
    count is not incremented for every change to the database that would
    alter the incore schema cache. Rather it seems to be a count of
    changes that might affect the replication subsystem. Hence the cache
    reload thread can't use the count to discover if the schema cache is
    already up-to-date. We need a schema-dirty bit to prevent
    reloading an already up-to-date cache.

Arguments:
    pTHS - thread state
    TimeoutInMs - Wait at most this many milliseconds for the
        reload thread to finish if it is currently busy and then
        wait at most this many milliseconds for the reload thread
        to complete after being signaled

Return Values:
    FALSE if the reload thread could not be signaled.
    TRUE for all other cases.
--*/
{
    BOOL    IsStale;
    DWORD   waitret;
    HANDLE  wmo[] = { evUpdRepl, hServDoneEvent };

    // If the cache is stale (see above), wait for the cache-reload thread
    IsStale = SCCacheIsStale();
    if (IsStale) {
        waitret = WaitForMultipleObjects(2, wmo, FALSE, TimeoutInMs);
        IsStale = SCCacheIsStale();
    }

    // If the cache is stale (see above), signal the cache-reload thread and wait
    if (IsStale) {
        // kick the reload thread
        ResetEvent(evUpdRepl);
        if (!SCSignalSchemaUpdateImmediate()) {
            // could not signal the reload thread
            return FALSE;
        }
        // Wait for the reload thread to finish
        waitret = WaitForMultipleObjects(2, wmo, FALSE, TimeoutInMs);

        // Now throttle schema reloads by waiting half the timeout
        // period to avoid saturating the src and dst DCs while the
        // schema is being modified concurrently with replication.
        Sleep(TimeoutInMs >> 1);

        // Check again to see if the schema is stale
        IsStale = SCCacheIsStale();

        // Lots of schema changes going on; wait a bit more
        if (IsStale) {
            Sleep(TimeoutInMs >> 1);
        }
    }

    // If the cache is not stale (see above), refresh thread's schema ptr
    if (!IsStale && pTHS->CurrSchemaPtr != CurrSchemaPtr) {
        SCRefreshSchemaPtr(pTHS);
    }
    return TRUE;
} // End SCReplReloadCache

//-----------------------------------------------------------------------
//
// Function Name:            RecalcPrefixTable
//
// Routine Description:
//
//    Creates a new schemaptr, copies the thread's old schema pointer
//    to it, and then reloads the prefix table from the dit. So on
//    exit, the thread state's schema pointer points to basically the
//    schema cache pointed to by the calling thread's schema pointer,
//    only the prefix table part may be different (will contain prefixes
//    that are in the dit but not reflected in the calling thread's
//    schema cache)
//
// Arguments:
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
RecalcPrefixTable()
{
    THSTATE *pTHS = pTHStls;
    int err = 0;
    ULONG PREFIXCOUNT = 0;
    SCHEMAPTR *tSchemaPtr, *oldSchemaPtr;
    PrefixTableEntry *ptr;

    // Find the calling thread's schema pointer. We will borrow most
    // of the schema cache pointers from it.

    oldSchemaPtr = pTHS->CurrSchemaPtr;

    // Must not be null. This is only called from AssignIndex, which
    // should have a proper schema pointer
    Assert(oldSchemaPtr);

    // Create a new schema pointer to put in the thread state. Cannot
    // work with the same pointer (oldSChemaPtr) as we will reload
    // the prefix table part, which may be different

    if (SCCalloc(&pTHS->CurrSchemaPtr, 1, sizeof(SCHEMAPTR))) {
        return ERROR_DS_CANT_CACHE_ATT;
    }
    tSchemaPtr = pTHS->CurrSchemaPtr;

    // Copy all cache pointers from oldSchemaPtr. Note that since
    // the calling thread has ref-counted this cache, and since
    // this new cache being built/copied will be used only during the
    // lifetime of the calling thread, there is no fear of the cache
    // being freed during validation, and so no need to increment the
    // ref-count to indicate that the same thread is using this cache
    // twice (sort of)

    memcpy(tSchemaPtr, oldSchemaPtr, sizeof(SCHEMAPTR));

    // Now just reload the prefix part. The calling function (right now
    // only AssignIndex) is responsible for freeing this (Size allocated
    // is decided in same way as in SCCacheSchemaInit during normal cache
    // building).

    // if the DS is installing, there is the possibility that the old
    // PREFIXCOUNT is quite different from the default one, and as a
    // result we are going to do a lot of reallocations on the prefixtable.
    // this way we at least start with a larger number for prefixcount.
    if (DsaIsInstalling()) {
        PREFIXCOUNT = oldSchemaPtr->PREFIXCOUNT;
    }

    if (PREFIXCOUNT < START_PREFIXCOUNT) {
        PREFIXCOUNT = START_PREFIXCOUNT;
    }

    while ( (2*(CurrSchemaPtr->PrefixTable.PrefixCount + 25)) > PREFIXCOUNT) {
          PREFIXCOUNT += START_PREFIXCOUNT;
    }

    tSchemaPtr->PREFIXCOUNT = PREFIXCOUNT;

    if (SCCalloc(&tSchemaPtr->PrefixTable.pPrefixEntry, tSchemaPtr->PREFIXCOUNT, sizeof(PrefixTableEntry))) {
         return ERROR_DS_CANT_CACHE_ATT;
    }
    ptr = tSchemaPtr->PrefixTable.pPrefixEntry;

    if (err = InitPrefixTable(ptr, tSchemaPtr->PREFIXCOUNT)) {
          DPRINT1(0, "InitPrefixTable Failed in RecalcPrefixTable %d\n", err);
          // Free allocated memory
          SCFreePrefixTable(&ptr, tSchemaPtr->PREFIXCOUNT);
          return err;
    }

    if (err = InitPrefixTable2(ptr, tSchemaPtr->PREFIXCOUNT)) {
          DPRINT1(0, "InitPrefixTable2 Failed in RecalcPrefixTable %d\n", err);
          // Free allocated memory
          SCFreePrefixTable(&ptr, tSchemaPtr->PREFIXCOUNT);
          return err;
    }

    return 0;

}


//-----------------------------------------------------------------------
//
// Function Name:            RecalcSchema
//
// Routine Description:
//
//    Calculates the Schema Cache for the current thread from the DIT
//
// Arguments:
//    pTHS - THSTATE pointer
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
RecalcSchema(
             THSTATE *pTHS
)
{
    int err=0;
    BOOL    fDSA=pTHS->fDSA;


    __try {
        // Boost Async update thread's priority just in case
        // an async update is going on now, since there is a
        // critical section that is shared

        SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_NORMAL);

    _try
    {

        pTHS->fDSA=TRUE;
        pTHS->UpdateDITStructure=FALSE;

        //
        // Now do the most expensive set of operation in the DS.....
        //
        err = SCCacheSchemaInit ();
        if (err) {
            DPRINT1(0, "SCCacheSchemaInit: Error %d\n",err);
            _leave;

        }

        err = SCCacheSchema2();
        if (err)
        {
            DPRINT1(0, "SCCacheSchema2: Error %d\n",err);
            _leave;
        }

    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
    {
        DPRINT1(0, "NTDS RecalcSchema: Exception %d\n",err);
    }

    }
    __finally {
       // Restore priority of async schema update thread to low
       SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_BELOW_NORMAL);
    }

    if (err && pTHS->CurrSchemaPtr){
        SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
    }


    pTHS->fDSA=fDSA;

    return err;

} // End RecalcSchema


//-----------------------------------------------------------------------
//
// Function Name:            SCUpdateSchemaHelper
//
// Routine Description:
//
//    Helper function to update the Schema By calling the
//    Schema Init Code, and unloads the old cache. Called by
//    blocking and async schema cache update routines.
//
//
// Return Value:
//
//    int              Zero On Succeess, non-zero on error
//
//-----------------------------------------------------------------------
int SCUpdateSchemaHelper()
{

    int err = 0;
    THSTATE *pTHS = pTHStls;
    size_t iProc;

    __try {
        __try {
            err = SCCacheSchemaInit ();
            if (err) {
                DPRINT1(0,"NTDS SCCacheSchemaInit: Schema Update Failed. Error %d\n",err);
                _leave;
            }

            if (eServiceShutdown) {
                _leave;
            }

            // The cache load sees all changes until now (to be precise, there is
            //  a possibility of some schema change committing between this
            // and the opening of the transaction. But it is better to say we are
            // backdated (which will necessitate another cache update
            // wherever we check if the cache is uptodate with current changes) than
            // falsely say we are uptodate (which can cause inconsistencies)
            EnterCriticalSection(&csNoOfSchChangeUpdate);
            __try {
                ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->lastChangeCached = gNoOfSchChangeSinceBoot;
            }
            __finally {
                LeaveCriticalSection(&csNoOfSchChangeUpdate);
            }

            // This may add Jet columns
            SYNC_TRANS_WRITE();
            EnterCriticalSection(&csJetColumnUpdate);
            __try {
                 err = SCCacheSchema2();
             }
            __finally {
                 LeaveCriticalSection(&csJetColumnUpdate);
                 if (err && pTHS->errCode==0) {
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,ERROR_DS_SCHEMA_NOT_LOADED,err);
				 }
                 CLEAN_BEFORE_RETURN(pTHS->errCode);

            }

             if (err)
               {
                  DPRINT1(0,"NTDS SCCacheSchema2: Schema Update Failed. Error %d\n",err);

                  _leave;
               }

             if (eServiceShutdown) {
                 _leave;
             }

             // Should not have a dbpos here, since the one opened above
             // have been closed

             Assert(!pTHS->pDB);

             // This may delete unused Jet columns
             EnterCriticalSection(&csJetColumnUpdate);
             __try {
                 err = SCCacheSchema3() ;
              }
             __finally {
                 LeaveCriticalSection(&csJetColumnUpdate);
              }

             if (err) {
                 DPRINT1(0,"NTDS SCCacheSchema3: Schema Update Failed. Error%d\n",err);
                 _leave;
             }


            if (eServiceShutdown) {
                _leave;
            }

             //
             // Assign the Schema Ptr
             // But first enqueue the old schema cache for delayed freeing
             // Unload only if not installing, no need to unload during install

             // if this is called from the async thread, the thread's priority
             // may be low. Set it to normal to speed this part up, as this critical
             // section is also used to assign Schema Ptr during user thread
             // initialization. If this is called from the blockign thread,
             // which already has a normal priority, this has no effect. For
             // the async case, the thread priority will be set back
             // to below normal when the schema update is over

             SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
             for (iProc = 0; iProc < GetProcessorCount(); iProc++) {
                SyncEnterRWLockAsWriter(&GetSpecificPLS(iProc)->rwlSchemaPtrUpdate);
             }
             __try {
                 // Its odd that SCUnloadSchema handles the case of
                 // DsaIsInstalling() but this code never calls it
                 // unless DsaIsRunning()?
                 if (DsaIsRunning()) {
                   SCUnloadSchema(TRUE);
                 }
                 CurrSchemaPtr = pTHS->CurrSchemaPtr;
               }
             __finally {
                 for (iProc = 0; iProc < GetProcessorCount(); iProc++) {
                    SyncLeaveRWLockAsWriter(&GetSpecificPLS(iProc)->rwlSchemaPtrUpdate);
                 }
               }
             lastSchemaUpdateTime = DBTime();

         }
         __finally {
             if (err && pTHS->errCode==0) {
                 SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,ERROR_DS_SCHEMA_NOT_LOADED,err);
             }
         }
    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
      {
         DPRINT1(0,"NTDS SCUpdateSchemaHelper: Exception %d\n",err);
      }

    if (eServiceShutdown) {
        return 0;
    }

    if (err && pTHS->CurrSchemaPtr){
        // Free up the cache built so far
        SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
    }


    return err;

}





//-----------------------------------------------------------------------
//
// Function Name:            SCUpdateSchema
//
// Routine Description:
//
//    Updates the Schema By calling the Schema Init Code
//    Assumes being called by the async thread, so creates
//    and frees thread state
//
// Author: RajNath
// Date  : [3/7/1997]
//
// Arguments:
//
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
SCUpdateSchema(
    )
{
    int err = 0;
    SCHEMAPTR *oldSchemaPtr;
    THSTATE* pTHS;

    SCHEMASTATS_INC(Reload);

    // The replication thread should wait (See SCReplReloadCache()) for
    // the schema reload to finish
    ResetEvent(evUpdRepl);

    // prevent spurious reloads
    ResetEvent(evUpdNow);
    ResetEvent(evSchema);

    //
    // Create The global pTHStls for this thread
    //


    pTHS=InitTHSTATE(CALLERTYPE_INTERNAL);
    if(!pTHS) {
        return STATUS_NO_MEMORY;
    }

    __try {

        // Serialize schema cache updates

        EnterCriticalSection(&csSchemaCacheUpdate);

        __try
        {

            // Since InitTHSTATE will assign the current schemaptr
            // to pTHS->CurrSchemaPtr and increase its RefCount,
            // save the schema ptr to readjust RefCount at the end.
            // This is necessary since pTHS->CurrSchemaPtr will change
            // after this next cache load below

            oldSchemaPtr = (SCHEMAPTR *) (pTHS->CurrSchemaPtr);


            pTHS->fDSA=TRUE;
            pTHS->UpdateDITStructure=TRUE;


            // Call the helper routine to do the actual update
            err = SCUpdateSchemaHelper();
            if (err) {
              DPRINT1(0,"Async Schema Update Failed %d\n", err);
            }

        }
        __finally
        {

            LeaveCriticalSection(&csSchemaCacheUpdate);

            // Before freeing the thread state, check the schema ptr
            // If it is the same as the old schema ptr, then some error
            // occured in this routine and the new cache didn't get created
            // In this case, we need not do anything, since the call below
            // will decrement the RefCount of the old cache pointer (since
            // it was incremented in the InitTHSTATE cal). If however, the
            // thread's schema ptr is now different, then we need to
            // decrement the old schema ptr's RefCount, and also, increment
            // the new schema ptr's RefCount, since it will be decremented
            // by one in the free_thread_state call (since this was not
            // the schema cache that got incremented in the InitTHSTATE call)


            if ( pTHS->CurrSchemaPtr != oldSchemaPtr ) {
              if (oldSchemaPtr) {
                  InterlockedDecrement(&(oldSchemaPtr->RefCount));
              }
              if (pTHS->CurrSchemaPtr) {
               InterlockedIncrement(&(((SCHEMAPTR *) (pTHS->CurrSchemaPtr))->RefCount));
              }
            }

            free_thread_state();
        }
    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
    {

        DPRINT1(0,"NTDS SCUpdateSchema: Exception %d\n",err);
    }


    if (err)
    {
        DPRINT1(0,"NTDS: SCSchemaUpdateThread Failure %d\n",err);
    }

    return err;

} // End SCUpdateSchema


//-----------------------------------------------------------------------
//
// Function Name:            SCUpdateSchemaBlocking
//
// Routine Description:
//
//    Updates the Schema By calling the Schema Init Code
//    Assumes it is called by a thread with already initialized
//    thread state, so does not create/free thread state and saves
//    and restores currency etc. properly
//
//
//    Assumes no open transactions. Because of the possibility of
//    simultaneous blocking and async cache updates, it is important
//    that their transactions are effectively serialized to allow
//    database changes made by one such as column creation/deletion
//    etc. to be seen by th other immediately
//
// Arguments: None
//
//
// Return Value:
//
//    int              Zero On Succeess, non-zero on failure
//
//-----------------------------------------------------------------------
int
SCUpdateSchemaBlocking
(
)
{
    int err = 0;
    PVOID   pOutBuf;
    SCHEMAPTR *oldSchemaPtr;
    ULONG dntSave=0;
    BOOL fDSASave, updateDitStructureSave;
    THSTATE* pTHS = pTHStls;


    // Check that proper thread state is non-null

    Assert(pTHS);

    // Should not have open transaction
    Assert (!pTHS->pDB);

    __try {
        // Boost Async update thread's priority just in case
        // an async update is going on now, since we will be blocked
        // on that

        if (hAsyncSchemaUpdateThread) {
            SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_NORMAL);
        }

        // Serialize simultaneous cache updates

        EnterCriticalSection(&csSchemaCacheUpdate);

        __try
        {
            // Save schema pointer etc.

            oldSchemaPtr = (SCHEMAPTR *) (pTHS->CurrSchemaPtr);
            fDSASave = pTHS->fDSA;
            updateDitStructureSave = pTHS->UpdateDITStructure;


            // Prepare for cache update

            pTHS->fDSA=TRUE;
            pTHS->UpdateDITStructure=TRUE;


            // Call the helper routine to do the actual update
            err = SCUpdateSchemaHelper();

            if (err) {
              DPRINT1(0,"Blocking Schema Update Failed %d\n", err);
            }

        }
        __finally
        {
            LeaveCriticalSection(&csSchemaCacheUpdate);

            // Restore priority of async schema update thread to low
            if (hAsyncSchemaUpdateThread) {
                SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_BELOW_NORMAL);
            }

            // Restore schema pointer etc. (Restore schema ptr to the one this
            // thread started with to allow proper ref count update when
            // the thread exits)

            pTHS->CurrSchemaPtr = oldSchemaPtr;
            pTHS->fDSA = fDSASave;
            pTHS->UpdateDITStructure = updateDitStructureSave;

        }
    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
    {

        DPRINT1(0,"NTDS SCUpdateSchemaBlocking: Exception %d\n",err);
    }

    if (err) {
        DPRINT1(0,"NTDS: SCSchemaUpdateThread Failure %d\n",err);
    }
    else {
        // Updated successfully, log a message
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_CACHE_UPDATED,
                 0, 0, 0);
     }

    return err;

} // End SCUpdateSchemaBlocking





//-----------------------------------------------------------------------
//
// Function Name:            SCSchemaUpdateThread
//
// Routine Description:
//
//    Asynchronous Thread used for updating the Schema
//
// Author: RajNath
// Date  : [3/7/1997]
//
// Arguments:
//
//
// Return Value:
//
//    Does not return
//
//-----------------------------------------------------------------------
ULONG
SCSchemaUpdateThread(PVOID pv)
{

    HANDLE wmo[]={evSchema,evUpdNow,hServDoneEvent};
    HANDLE wmo1[]={evUpdNow,hServDoneEvent};
    DWORD  waitret, waitret1;
    ULONG  err = 0;
    ULONG  cRetry = 0;

    //
    // This Function is executed in a Thread. For performance reasons
    // we do not want to call SCUpdate Schema every time the Schema container
    // is touched but instead five minutes or when signaled.
    //

    // Users should not have to wait for this.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    if (evSchema == NULL || evUpdNow == NULL || evUpdRepl == NULL)
    {
        DPRINT1(0, "NTDS: SchemaUpdateThread Startup Failed. Error %d\n",GetLastError());
        return GetLastError();
    }

    while (!eServiceShutdown) {
        // The replication thread can continue (SCReplReloadCache())
        SetEvent(evUpdRepl);
        waitret = WaitForMultipleObjects(3,wmo,FALSE,INFINITE);

        switch ((waitret))
        {
            case WAIT_OBJECT_0:
            {
                //
                // Someone just updated the Schema Container and wants us to
                // Update the SchemaCache. Lets wait 5 minutes or Someone says
                // update now.
                //
                waitret1 = WaitForMultipleObjects(2,
                                                  wmo1,
                                                  FALSE,
                                                  gdwRecalcDelayMs);

                // No ned to check waitret1, since eServiceShutdown is
                // set before hServDoneEvent is signalled

                if (!eServiceShutdown) {
                   err = SCUpdateSchema();
                   if (err) {
                     // The update failed for some reason. Retry the
                     // cache update after some time. Log in the eventlog

                      cRetry++;
                      if (cRetry <= maxRetry) {
                          LogEvent(DS_EVENT_CAT_SCHEMA,
                                   DS_EVENT_SEV_ALWAYS,
                                   DIRLOG_SCHEMA_CACHE_UPDATE_RETRY,
                                   szInsertHex(err),
                                   szInsertUL(maxRetry),
                                   szInsertUL(cRetry));
                      }

                      if ( (cRetry > maxRetry)
                              || !SCSignalSchemaUpdateLazy() ) {

                        // Either already retried too many times, or cannot
                        // even signal a  schema update. Log an error,
                        // reset retry counter, and abort

                        cRetry = 0;

                        LogEvent(DS_EVENT_CAT_SCHEMA,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_SCHEMA_CACHE_UPDATE_FAILED, szInsertHex(err), 0, 0);
                     }
                   }
                   else {
                      // Cache update is successful. Reset retry counter
                      cRetry = 0;

                      // log a message
                      LogEvent(DS_EVENT_CAT_SCHEMA,
                               DS_EVENT_SEV_MINIMAL,
                               DIRLOG_SCHEMA_CACHE_UPDATED,
                               0, 0, 0);

                   }

                   // Set thread priority back to below normal. We set it
                   // to normal for a small part in SCUpdateSchemaHelper so
                   // as to not get starved out while inside a critical
                   // section that is also used by user threads
                   SetThreadPriority(GetCurrentThread(),
                                     THREAD_PRIORITY_BELOW_NORMAL);
                }
            }
            break;

            case WAIT_OBJECT_0+1:
            {
                //
                // Someone wants to update schema immediately
                //
                if (!eServiceShutdown) {
                   err = SCUpdateSchema();
                   if (err) {
                     // The update failed for some reason. Retry the
                     // cache update after some time. Log in eventlog

                      cRetry++;
                      if (cRetry <= maxRetry) {
                         LogEvent(DS_EVENT_CAT_SCHEMA,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_SCHEMA_CACHE_UPDATE_RETRY,
                                  szInsertHex(err),
                                  szInsertUL(maxRetry),
                                  szInsertUL(cRetry));
                      }

                      if ( (cRetry > maxRetry)
                              || !SCSignalSchemaUpdateLazy() ) {

                        // Either already retried too many times, or cannot
                        // even signal a  schema update. Log an error,
                        // reset retry counter, and abort

                        cRetry = 0;

                        LogEvent(DS_EVENT_CAT_SCHEMA,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SCHEMA_CACHE_UPDATE_FAILED,
                                 szInsertHex(err),
                                 0,
                                 0);
                     }
                   }
                   else {
                      // Cache update is successful. Reset retry counter
                      cRetry = 0;

                      // log a message
                      LogEvent(DS_EVENT_CAT_SCHEMA,
                               DS_EVENT_SEV_MINIMAL,
                               DIRLOG_SCHEMA_CACHE_UPDATED,
                               0, 0, 0);
                   }

                   // Set thread priority back to below normal. We set it
                   // to normal for a small part in SCUpdateSchemaHelper so
                   // as to not get starved out while inside a critical
                   // section that is also used by user threads
                   SetThreadPriority(GetCurrentThread(),
                                     THREAD_PRIORITY_BELOW_NORMAL);
                }
            }
            break;


            case WAIT_OBJECT_0+2:
            {
                //Service Shutdown:

                DPRINT(0,"Shutting down schema update thread\n");

                // Don't close the thread handle, because the main thread
                // is using it to track this thread's shutdown.
                return 0;
            }
            break;

            default:
            {
                //
                // Some Error Happened
                //
                DPRINT1(0,"NTDS: SCSchemaUpdateThread Failure %d\n",waitret);

            }
            break;


        }
    }

    //
    // Never Gets Here except on service shutdown
    //
    DPRINT(0,"Shutting down schema update thread \n");

    return 0;

} // End SCSchemaUpdateThread

DSTIME
SCGetSchemaTimeStamp (
        )
{
    return CurrSchemaPtr->sysTime;
}

DSNAME *
DsGetDefaultObjCategory(
    IN  ATTRTYP objClass
    )
/*++

Routine Description:

    Return the DSNAME of the default object category for the given object class.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS.

    This allows e.g. the KCC to construct DirSearch()s using ATT_OBJECT_CATEGORY
    filters.

Arguments:

    objClass (IN) - Object class of category of interest.

Return Values:

    (DSNAME *) The associated object category, or NULL if not found.

--*/
{
    THSTATE *    pTHS = pTHStls;
    CLASSCACHE * pCC;

    pCC = SCGetClassById(pTHS, objClass);
    if (NULL == pCC) {
        return NULL;
    }
    else {
        return pCC->pDefaultObjCategory;
    }
}


ATTCACHE **
SCGetTypeOrderedList(
    THSTATE *pTHS,
    IN CLASSCACHE *pCC
    )
/*++
    Routine Description:
        Given a classcache, return a list of ALL mays and musts sorted by attrtype.
        First time this is called for a class, the list is computed and
        hanged off the classcache structure; next time the earlier computed
        structure is returned. Of course if a schema cache load occurs for
        reason, the list is freed and recomputed again when it is asked for.
        The count of different types of atts (link, backlink, constructed,
        and column) is also cached for better searching in the calle if needed

    Arguments:
        pTHS - pointer to thread state to access schema cache
        pCC  - pointer to classcache

    Return value:
        pointer to list of attcaches on success (no. of elements on list
        = pCC->MayCount + pCC->MustCount, so not explicitly returned), NULL
        on failure (only failures possible now is failure to find an attribute
        in schema cache, which is catastrophic anyway, and allocation failure)
--*/
{
    ATTCACHE **rgpAC = NULL, **rgpACSaved;
    ULONG i, nAtts, cLink = 0, cBackLink = 0, cConstructed = 0, cCol = 0;

    // CLASSCACHEes are always intialized to 0, so if the pointer
    // is non-0, it must point to an already computed list
    if (pCC->ppAllAtts) {
       return pCC->ppAllAtts;
    }

    // not there, so compute it

    EnterCriticalSection(&csOrderClassCacheAtts);
    __try {
        if (pCC->ppAllAtts) {
           // someone else has computed it from the time we checked in
           // the read above. So just return it
           __leave;
        }

        // else, we need to compute and add it to the classcache

        if (SCCalloc((VOID **)&rgpAC, (pCC->MayCount + pCC->MustCount), sizeof(ATTCACHE *))) {
           __leave;
        }

        // first, just find and copy the attcaches
        nAtts = 0;
        for (i=0; i<pCC->MayCount; i++) {
           rgpAC[nAtts] = SCGetAttById(pTHS, (pCC->pMayAtts)[i]);
           if (!rgpAC[nAtts]) {
               DPRINT1(1,"SCGetColOrderedList: Couldn't find attcache for attribute 0x%x\n", (pCC->pMayAtts)[i]);
           } else {
               ++nAtts;
           }
        }

        for (i=0; i<pCC->MustCount; i++) {
           rgpAC[nAtts] = SCGetAttById(pTHS, (pCC->pMustAtts)[i]);
           if (!rgpAC[nAtts]) {
               DPRINT1(1,"SCGetColOrderedList: Couldn't find attcache for attribute 0x%x\n", (pCC->pMustAtts)[i]);
            } else {
                ++nAtts;
            }
        }

        // Count the different type of atts and store
        if (SCCalloc(&pCC->pAttTypeCounts, 1, sizeof(ATTTYPECOUNTS))) {
            SCFree((VOID **)&rgpAC);
            __leave;
        }

        for (i = 0; i < nAtts; i++) {
            if (FIsLink((rgpAC[i])->ulLinkID)) {
                (pCC->pAttTypeCounts)->cLinkAtts++;
            } else if (FIsBacklink((rgpAC[i])->ulLinkID)) {
                (pCC->pAttTypeCounts)->cBackLinkAtts++;
            } else if ((rgpAC[i])->bIsConstructed) {
                (pCC->pAttTypeCounts)->cConstructedAtts++;
            } else {
                (pCC->pAttTypeCounts)->cColumnAtts++;
            }
        }

        qsort(rgpAC,
              nAtts,
              sizeof(rgpAC[0]),
              CmpACByAttType);

        rgpACSaved = rgpAC;

        // add the pointer
        InterlockedExchangePointer((PVOID *)&(pCC->ppAllAtts), (PVOID)rgpAC);

        // Just a  doublecheck that the pointer assignment was fine, since this
        // is a new api  to ensure compatibility with 64 bit NT
        Assert(pCC->ppAllAtts == rgpACSaved);

     }
     __finally {
        LeaveCriticalSection(&csOrderClassCacheAtts);
     }

     return pCC->ppAllAtts;
}

typedef struct _AttMapping {
    ATTRTYP schemaAttrTyp;
    ATTRTYP tempAttrTyp;
    int     tempOMsyntax;

} AttMapping;


// Two flavor of attributes.
// default in BINARY so we explicitly specify XML
//
AttMapping xmlAttrs[] = {
// this table can be used to address translation to XML for attributes like ldapAdminLimits
//        ATT_LDAP_ADMIN_LIMITS,  ATT_LDAP_ADMIN_LIMITS_XML, OM_S_UNICODE_STRING,
        0,                      0};

// default in XML so we explicitly specify BINARY
//
AttMapping otherAttrs[] = {
    ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS,    ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS_BINARY,    OM_S_OCTET_STRING,
    ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS,   ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS_BINARY,   OM_S_OCTET_STRING,
    ATT_MS_DS_NC_REPL_CURSORS,              ATT_MS_DS_NC_REPL_CURSORS_BINARY,              OM_S_OCTET_STRING,
    ATT_MS_DS_REPL_ATTRIBUTE_META_DATA,     ATT_MS_DS_REPL_ATTRIBUTE_META_DATA_BINARY,     OM_S_OCTET_STRING,
    ATT_MS_DS_REPL_VALUE_META_DATA,         ATT_MS_DS_REPL_VALUE_META_DATA_BINARY,         OM_S_OCTET_STRING,
    0,                                      0, 0};

ATTCACHE* SCGetAttSpecialFlavor (THSTATE *pTHS, ATTCACHE *pAC, BOOL fXML)
{
    ATTCACHE *pNewAC;
    ATTRTYP   newID = 0;
    int       newOMsyntax = 0;
    SCHEMAEXT *pSchExt = (SCHEMAEXT *)pTHS->pExtSchemaPtr;
    DWORD i;

    // are we looking for the XML flavor (binary was the default).
    if (fXML) {
        for (i=0; xmlAttrs[i].schemaAttrTyp; i++) {
            if (pAC->id == xmlAttrs[i].schemaAttrTyp) {
                newID = xmlAttrs[i].tempAttrTyp;
                newOMsyntax = xmlAttrs[i].tempOMsyntax;
                break;
            }
        }
    }
    // so we are looking for the binary flavor (xml is the default).
    else {
        for (i=0; otherAttrs[i].schemaAttrTyp; i++) {
            if (pAC->id == otherAttrs[i].schemaAttrTyp) {
                newID = otherAttrs[i].tempAttrTyp;
                newOMsyntax = otherAttrs[i].tempOMsyntax;
                break;
            }
        }
    }

    if (!newID) {
        return NULL;
    }

    if (pSchExt != NULL) {
        for (i=0; i<pSchExt->cUsed; i++) {
            if (pSchExt->ppACs[i]->id == newID) {
                return pSchExt->ppACs[i];
            }
        }
    }
    else {
        pSchExt = THAllocEx (pTHS, sizeof (SCHEMAEXT));
        pSchExt->ppACs = THAllocEx(pTHS, sizeof (ATTCACHE *) * 16);
        pSchExt->cAlloced = 16;

        pTHS->pExtSchemaPtr = (PVOID)pSchExt;
    }

    if (pSchExt->cUsed == pSchExt->cAlloced) {
        pSchExt->cAlloced *= 2;
        pSchExt->ppACs = THReAllocEx(pTHS, pSchExt->ppACs, sizeof (ATTCACHE *) * pSchExt->cAlloced);
    }

    pNewAC = THAllocEx (pTHS, sizeof (ATTCACHE));
    memcpy (pNewAC, pAC, sizeof (ATTCACHE));
    pNewAC->id = newID;
    pNewAC->OMsyntax = newOMsyntax;
    pNewAC->aliasID = pAC->id;

    pSchExt->ppACs[pSchExt->cUsed++] = pNewAC;

    return pNewAC;
}

ATTRTYP
SCAutoIntId(
    THSTATE     *pTHS
    )
/*++
Routine Description:

    Automatically generate an intid.

Arguments:
    pTHS - thread state that addresses a schema cache. The schema
           cache may be built by RecalcSchema. The private schema
           cache includes the uncommitted changes (add/mod/del) for ac.

Return Values:
    next IntId or INVALID_ATT if none available
--*/
{
    DWORD   i;
    ULONG   ulRange, ulBase;

    // calculate using this thread's schema cache
    srand(GetTickCount());
    ulRange = MakeLinkBase(LAST_INTID_ATT - FIRST_INTID_ATT) + 1;
    ulBase = ((rand() << 15) ^ rand()) % ulRange;
    for (i = 0; i < ulRange; ++i, ulBase = ++ulBase % ulRange) {
        if (!SCGetAttById(pTHS, FIRST_INTID_ATT + ulBase)) {
            return FIRST_INTID_ATT + ulBase;
        }
    }

    return INVALID_ATT;
} // SCAutoIntId


int
scDupStruct(
    IN THSTATE  *pTHS,
    IN VOID     *pOldMem,
    OUT VOID    **ppNewMem,
    IN  DWORD   nBytes
    )
/*++

Routine Description:

    Make a copy of a struct

Arguments:

    pTHS - thread state
    pOldMem - memory to be dup'ed
    ppNewMem - new memory is allocated
    nBytes - size of struct

Return Value:

    pTHS->errCode

--*/
{
    if (NULL == pOldMem) {
        *ppNewMem = NULL;
    } else if (!SCCalloc(ppNewMem, 1, nBytes)) {
        memcpy(*ppNewMem, pOldMem, nBytes);
    }
    return pTHS->errCode;
}

int
scDupString(
    IN THSTATE  *pTHS,
    IN VOID     *pOldStr,
    OUT VOID    **ppNewStr
    )
/*++

Routine Description:

    Make a copy of a struct

Arguments:

    pTHS - thread state
    pOldStr - memory to be dup'ed
    ppNewStr - new memory is allocated

Return Value:

    pTHS->errCode

--*/
{
    if (NULL == pOldStr) {
        *ppNewStr = NULL;
    } else {
        scDupStruct(pTHS, pOldStr, ppNewStr, strlen(pOldStr) + 1);
    }
    return pTHS->errCode;
}

#if DBG && INCLUDE_UNIT_TESTS

// Below are some a unit test to check if the in memory schema cache is
// consistent with the one on disk. This code is duplicated from the SchemaInit* functions
//


CLASSCACHE* scAddClass_test(THSTATE *pTHS,
                       ENTINF *pEI,
                       int *mismatch,
                       SCHEMAPTR *CurrSchemaPtr
                       )
{
    CLASSCACHE *pCC, *pCCNew;
    ULONG       i;
    ULONG       err;
    ULONG aid;
    int SDLen;

    ULONG *pMayAtts, *pMyMayAtts,*pMustAtts, *pMyMustAtts;
    ULONG *pSubClassOf,*pAuxClass, *pPossSup, *pMyPossSup;

    ULONG *tpMayAtts, *tpMyMayAtts,*tpMustAtts, *tpMyMustAtts;
    ULONG *tpSubClassOf,*tpAuxClass, *tpPossSup, *tpMyPossSup;


    ULONG  MayCount, MyMayCount, MustCount, MyMustCount;
    ULONG  SubClassCount, AuxClassCount, PossSupCount, MyPossSupCount;

    ULONG CLSCOUNT     = ((SCHEMAPTR*)(CurrSchemaPtr))->CLSCOUNT;
    HASHCACHE*       ahcClass     = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcClass;

    pMayAtts = pMyMayAtts = pMustAtts = pMyMustAtts =
        pSubClassOf = pAuxClass = pPossSup = pMyPossSup = 0;

    MayCount = MyMayCount = MustCount = MyMustCount = SubClassCount =
        AuxClassCount = PossSupCount = MyPossSupCount = 0;

    *mismatch = 0;


    // Look for the clsid
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_GOVERNS_ID) {
            // found the attribute id, save the value.
            aid = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;  // go home.
        }
    }

    pCCNew = SCGetClassById(pTHS, aid);

    for (i=SChash(aid,CLSCOUNT);
         (ahcClass[i].pVal && (ahcClass[i].hKey != aid)); i=(i+1)%CLSCOUNT) {
        ;
    }

    pCC = ahcClass[i].pVal;


    if (!pCC || pCC->ClassId != aid)
    {
        DPRINT1 (0, "scAddClass_test: ERROR, class %d not found\n", aid);
        return NULL;
    }
    else {
        if (pCC->name) {
            DPRINT1 (0, "scAddClass_test: checking %s\n", pCC->name);
        }
    }


    // Now walk the attrblock and add the appropriate fields to the CC
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_DEFAULT_SECURITY_DESCRIPTOR:
          {

            // A default security descriptor.  We need to copy this value to
            // long term memory and save the size.
            // But this is a string. We first need to convert. It
            // is a wide-char string now, but we need to null-terminate
            // it for the security conversion. Yikes! This means I
            // have to realloc for that one extra char!

            UCHAR *sdBuf = NULL;
            WCHAR *strSD =
                THAllocEx(pTHS,pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen + 2);

            memcpy(strSD, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen);
            strSD[(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen)/sizeof(WCHAR)] = L'\0';

            if (!CachedConvertStringSDToSDRootDomainW
                 (
                   pTHS,
                   strSD,
                  (PSECURITY_DESCRIPTOR*) &sdBuf,
                   &SDLen
                  )) {
                // Failed to convert.

                    err = GetLastError();
                    LogEvent8(DS_EVENT_CAT_SCHEMA,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SCHEMA_SD_CONVERSION_FAILED,
                             szInsertWC(strSD),
                             szInsertWC(pEI->pName->StringName),
                             szInsertInt(err),
                             szInsertWin32Msg(err),
                             NULL, NULL, NULL, NULL );
                    // if heuristics reg key says to ignore bad default SDs
                    // and go on, do so
                    if (gulIgnoreBadDefaultSD) {
                        THFreeEx(pTHS,strSD);
                        continue;
                    }

                    // otherwise, raise error and return
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_STRING_SD_CONVERSION_FAILED, err);
                    DPRINT1(0,"Default SD conversion failed, error %x\n",err);
                    Assert(!"Default security descriptor conversion failed");
                    THFreeEx(pTHS,strSD);
                    return NULL;
            }
            else {
                // Converted successfully

                if (memcmp(pCC->pSD, sdBuf, pCC->SDLen) != 0) {

                    DPRINT1 (0, "scAddClass_test: ERROR, SD different for class %d\n", aid);
                    THFreeEx(pTHS, sdBuf);
                    *mismatch = 1;
                }

                if (NULL!=sdBuf) {
                    THFreeEx(pTHS, sdBuf);
                    sdBuf = NULL;
                }
            }
            THFreeEx(pTHS,strSD);
        }

           break;


        case ATT_RDN_ATT_ID:

            if ( (pCC->RdnExtId != *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) ||
                 (pCC->RDNAttIdPresent != TRUE ) ) {

                    DPRINT1 (0, "scAddClass_test: ERROR, ATT_RDN_ATT_ID different for class %d\n", aid);
                    *mismatch = 1;
            }
            break;


        case ATT_LDAP_DISPLAY_NAME:
            {
            DWORD name_size = pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen;
            char *name = THAllocEx(pTHS,name_size+1);
            int namelen;

            namelen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                    (pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen  /
                     sizeof(wchar_t)),
                    name,
                    name_size,
                    NULL,
                    NULL);

            if (_mbsncmp (name, pCC->name, namelen) != 0) {
                DPRINT1 (0, "scAddClass_test: ERROR, ldapDisplayName different for class %d\n", aid);
                *mismatch = 1;
            }

            THFreeEx(pTHS,name);
            }
            break;

        case ATT_SYSTEM_ONLY:
            if (pCC->bSystemOnly !=
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal ) {
                DPRINT1 (0, "scAddClass_test: ERROR, ATT_SYSTEM_ONLY different for class %d\n", aid);
                *mismatch = 1;
            }
            break;


        case ATT_DEFAULT_HIDING_VALUE:
            if (pCC->bHideFromAB != (unsigned)
                *(BOOL*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) {
                DPRINT1 (0, "scAddClass_test: ERROR, ATT_DEFAULT_HIDING_VALUE different for class %d\n", aid);
                *mismatch = 1;
            }
            break;


        case ATT_GOVERNS_ID:
            if (pCC->ClassId != *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) {
                DPRINT1 (0, "scAddClass_test: ERROR, ATT_GOVERNS_ID different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_SYSTEM_MAY_CONTAIN:
        case ATT_MAY_CONTAIN:

            if ( GetValList(&MayCount, &pMayAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if ( GetValList( &MyMayCount, &pMyMayAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if(MyMayCount) {
                qsort(pMyMayAtts,
                    MyMayCount,
                    sizeof(ULONG),
                    CompareAttrtyp);
            }

            if (memcmp (pCC->pMyMayAtts, pMyMayAtts, pCC->MyMayCount * sizeof (ULONG)) != 0)  {

                DPRINT1 (0, "scAddClass_test: ERROR, myMAYAttrs different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_SYSTEM_MUST_CONTAIN:
        case ATT_MUST_CONTAIN:


            if ( GetValList( &MustCount, &pMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if ( GetValList( &MyMustCount, &pMyMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if(MyMustCount) {
                qsort(pMyMustAtts,
                      MyMustCount,
                      sizeof(ULONG),
                      CompareAttrtyp);
            }

            if (memcmp (pCC->pMyMustAtts, pMyMustAtts, pCC->MyMustCount * sizeof (ULONG)) != 0 ) {

                DPRINT1 (0, "scAddClass_test: ERROR, myMUST*Attrs different for class %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SUB_CLASS_OF:

            if ( GetValList( &SubClassCount, &pSubClassOf,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            // first one in cache must be the direct superclass stored in dit
            // Also, the MySubClass field stores the direct superclass
            if ( (pCC->pSubClassOf[0] != pSubClassOf[0]) ||
                 (pCC->MySubClass != pSubClassOf[0]) ) {

                DPRINT1 (0, "scAddClass_test: ERROR, SUB_CLASS_OF different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_OBJECT_CLASS_CATEGORY:
            if (pCC->ClassCategory !=
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) {

                DPRINT1 (0, "scAddClass_test: ERROR, ATT_OBJECT_CLASS_CATEGORY different for class %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_DEFAULT_OBJECT_CATEGORY:
            {
                DWORD objCsize = pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen;

                if ( (memcmp(pCC->pDefaultObjCategory,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen) != 0 ) ||

                     (objCsize != DSNameSizeFromLen (pCC->pDefaultObjCategory->NameLen )) ) {

                    DPRINT1 (0, "scAddClass_test: ERROR, ATT_DEFAULT_OBJECT_CATEGORY different for class %d\n", aid);
                    *mismatch = 1;
                }

            }

            break;

        case ATT_SYSTEM_AUXILIARY_CLASS:
        case ATT_AUXILIARY_CLASS:
            if ( GetValList(&AuxClassCount, &pAuxClass,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if ( memcmp (pCC->pAuxClass, pAuxClass, pCC->AuxClassCount * sizeof (ULONG)) != 0)  {

                DPRINT1 (0, "scAddClass_test: ERROR, AUXILIARY_CLASS different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            if (memcmp(&pCC->propGuid,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->propGuid)) != 0) {

                DPRINT1 (0, "scAddClass_test: ERROR, SCHEMA_ID_GUID different for class %d\n", aid);
                *mismatch = 1;
            }
            break;


        case ATT_SYSTEM_POSS_SUPERIORS:
        case ATT_POSS_SUPERIORS:
            if ( GetValList(&PossSupCount, &pPossSup,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if ( GetValList(&MyPossSupCount, &pMyPossSup,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if(MyPossSupCount) {
                qsort(pMyPossSup,
                      MyPossSupCount,
                      sizeof(ULONG),
                      CompareAttrtyp);
            }

            if (memcmp (pCC->pMyPossSup, pMyPossSup, pCC->MyPossSupCount * sizeof (ULONG)) != 0)  {

                DPRINT1 (0, "scAddClass_test: ERROR, myPOSSSUP*Attrs different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_IS_DEFUNCT:
            if (pCC->bDefunct != (unsigned)
                (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal?1:0)) {

                DPRINT1 (0, "scAddClass_test: ERROR, ATT_IS_DEFUNCT different for class %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SYSTEM_FLAGS:
            if ( (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) &&
                pCC->bIsBaseSchObj != TRUE ) {

                DPRINT1 (0, "scAddClass_test: ERROR, ATT_SYSTEM_FLAGS different for class %d\n", aid);
                *mismatch = 1;

            }
            break;
        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp), 0, 0);
        }
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal);
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);


    SCFree(&pMayAtts);
    SCFree(&pMyMayAtts);
    SCFree(&pMustAtts);
    SCFree(&pMyMustAtts);
    SCFree(&pSubClassOf);
    SCFree(&pAuxClass);
    SCFree(&pPossSup);
    SCFree(&pMyPossSup);


    if (pCCNew) {
        if (pCC->pMayAtts && memcmp (pCC->pMayAtts, pCCNew->pMayAtts, pCC->MayCount * sizeof (ULONG)) != 0)  {

            DPRINT1 (0, "scAddClass_test: ERROR, MAYAttrs different for class %d\n", aid);
            *mismatch = 1;
        }

        if (pCC->pMustAtts && memcmp (pCC->pMustAtts, pCCNew->pMustAtts, pCC->MustCount * sizeof (ULONG)) != 0 ) {

            DPRINT1 (0, "scAddClass_test: ERROR, MUST*Attrs different for class %d\n", aid);
            *mismatch = 1;
        }

        if (pCC->pSubClassOf && memcmp (pCC->pSubClassOf, pCCNew->pSubClassOf, pCC->SubClassCount * sizeof (ULONG)) != 0) {

            DPRINT1 (0, "scAddClass_test: ERROR, SUB_CLASS_OF different for class %d\n", aid);
            *mismatch = 1;
        }

        if ( pCC->pAuxClass && memcmp (pCC->pAuxClass, pCCNew->pAuxClass, pCC->AuxClassCount * sizeof (ULONG)) != 0)  {

            DPRINT1 (0, "scAddClass_test: ERROR, AUXILIARY_CLASS different for class %d\n", aid);
            *mismatch = 1;
        }

        if (pCC->pPossSup && memcmp (pCC->pPossSup, pCCNew->pPossSup, pCC->PossSupCount * sizeof (ULONG)) != 0)  {

            DPRINT1 (0, "scAddClass_test: ERROR, POSSSUP*Attrs different for class %d\n", aid);
            *mismatch = 1;
        }
    }


    // ================================

    {
        HASHCACHESTRING* ahcClassName = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcClassName;

        if (pCC->name) {
            for (i=SCNameHash(pCC->nameLen,pCC->name,CLSCOUNT);
                   (ahcClassName[i].pVal &&
                   (ahcClassName[i].length != pCC->nameLen ||
                     _memicmp(ahcClassName[i].value,pCC->name,pCC->nameLen)));
                   i=(i+1)%CLSCOUNT) {
            }
            if (ahcClassName[i].pVal != pCC) {
                DPRINT1 (0, "scAddClass_test: ERROR, ahcClassName different for class %d\n", aid);
                *mismatch = 1;
            }

        }

    }

    return pCC;
}

ATTCACHE*
scAddAtt_test(
        THSTATE *pTHS,
        ENTINF *pEI,
        int *mismatch,
        SCHEMAPTR *CurrSchemaPtr
        )
{
    ATTRTYP aid=(ATTRTYP) -1;           // This is an invalid attribute id.
    ATTCACHE *pAC, *pACnew;
    ULONG i;
    int fNoJetCol = FALSE;
    unsigned syntax;
    char szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int  lenIndexName;
    ULONG ATTCOUNT     = ((SCHEMAPTR*)(CurrSchemaPtr))->ATTCOUNT;
    HASHCACHE*       ahcId  = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcId;   \


    *mismatch = 0;


    // Look for the attid
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_ATTRIBUTE_ID) {
            // found the attribute id, save the value.
            aid = *(ATTRTYP*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;  // go home.
        }
    }

    pACnew = SCGetAttById(pTHS, aid);

    for (i=SChash(aid,ATTCOUNT);
         (ahcId[i].pVal && (ahcId[i].hKey != aid)); i=(i+1)%ATTCOUNT) {
        ;
    }

    pAC = ahcId[i].pVal;


    if (!pAC || pAC->id != aid) {

        DPRINT1 (0, "scAddAtt_test: ERROR, attr %d not found\n", aid);
        return NULL;
    }
    else {
        if (pAC->name) {
            DPRINT1 (0, "scAddAtt_test: checking %s\n", pAC->name);
        }
    }


    // Now walk the attrblock and add the appropriate fields to the AC
    for(i=0;i< pEI->AttrBlock.attrCount;i++) {
        ATTRVAL * pAVal = pEI->AttrBlock.pAttr[i].AttrVal.pAVal;

        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_SYSTEM_ONLY:
            if (pAC->bSystemOnly != *(ULONG*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_SYSTEM_ONLY different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_IS_SINGLE_VALUED:
            if (pAC->isSingleValued != *(BOOL*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_IS_SINGLE_VALUED different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_RANGE_LOWER:
            if (pAC->rangeLower != *(ULONG*)pAVal->pVal ||
                pAC->rangeLowerPresent != TRUE ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_RANGE_LOWER different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_RANGE_UPPER:
            if (pAC->rangeUpper != *(ULONG*)pAVal->pVal ||
                pAC->rangeUpperPresent != TRUE ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_RANGE_UPPER different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_LDAP_DISPLAY_NAME:
            {
            char *name = THAllocEx(pTHS,pAVal->valLen+1);
            int nameLen;

            nameLen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pAVal->pVal,
                    (pAVal->valLen /
                     sizeof(wchar_t)),
                    name,
                    pAVal->valLen,
                    NULL,
                    NULL);

                if (_mbsncmp (name, pAC->name, nameLen) != 0) {
                    DPRINT1 (0, "scAddAtt_test: ERROR, ldapDisplayName different for class %d\n", aid);
                    *mismatch = 1;
                }
            THFreeEx(pTHS,name);
            }
            break;
        case ATT_ATTRIBUTE_SYNTAX:
            syntax = 0xFF & *(unsigned*)pAVal->pVal;

            if ( ((0xFF) & pAC->syntax) != ((0xFF) & syntax)) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATTRIBUTE_SYNTAX different. Attr: %d\n", aid);
                return NULL;
            }

            break;

        case ATT_OM_SYNTAX:
            if (pAC->OMsyntax != *(int*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, OM_SYNTAX different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_OM_OBJECT_CLASS:
            if (pAC->OMObjClass.length != pAVal->valLen ||
                memcmp(pAC->OMObjClass.elements,
                        pAVal->pVal,
                        pAVal->valLen) != 0) {

                DPRINT1 (0, "scAddAtt_test: ERROR, OM_OBJECT_CLASS different. Attr: %d\n", aid);
                *mismatch = 1;
            }

            break;
        case ATT_MAPI_ID:
            if (pAC->ulMapiID != *(ULONG*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, MAPI_ID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_LINK_ID:
            if (pAC->ulLinkID != *(ULONG*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, LINK_ID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_ATTRIBUTE_ID:
            break;
        case ATT_SEARCH_FLAGS:
            if (pAC->fSearchFlags != *(DWORD*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, SEARCH_FLAGS different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            if (memcmp(&pAC->propGuid, pAVal->pVal, sizeof(pAC->propGuid)) != 0) {
                DPRINT1 (0, "scAddAtt_test: ERROR, SCHEMA_ID_GUID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            Assert(pAVal->valLen == sizeof(pAC->propGuid));
            break;
        case ATT_ATTRIBUTE_SECURITY_GUID:
            // The GUID for the attributes property set used for security checks
            if (memcmp(&pAC->propSetGuid, pAVal->pVal, sizeof(pAC->propSetGuid)) !=0 ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATTRIBUTE_SECURITY_GUID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_EXTENDED_CHARS_ALLOWED:
            if (pAC->bExtendedChars != (unsigned) (*(DWORD*)pAVal->pVal?1:0)) {
                DPRINT1 (0, "scAddAtt_test: ERROR, EXTENDED_CHAR_ALLOWED different. Attr: %d\n", aid);
                *mismatch = 1;
            }

            break;
        case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
            if (*(DWORD*)pAVal->pVal)
            {
                pAC->bMemberOfPartialSet = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            if (pAC->bDefunct != (unsigned)(*(DWORD*)pAVal->pVal?1:0) ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, IS_DEFUNCT different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SYSTEM_FLAGS:
            if ( ((*(DWORD*)pAVal->pVal & FLAG_ATTR_NOT_REPLICATED) &&
                  pAC->bIsNotReplicated != TRUE )  ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER) &&
                  pAC->bMemberOfPartialSet != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_CONSTRUCTED) &&
                  pAC->bIsConstructed != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_OPERATIONAL) &&
                  pAC->bIsOperational != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_RDN) &&
                  pAC->bFlagIsRdn != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) &&
                  pAC->bIsBaseSchObj != TRUE) ) {

                DPRINT1 (0, "scAddAtt_test: ERROR, SYSTEM_FLAGS different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp),
                     0, 0);
        }
        THFreeEx(pTHS, pAVal->pVal);
        THFreeEx(pTHS, pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);

    // Backlinks should have their system flags set to indicate they are not
    // replicated.
    Assert(!FIsBacklink(pAC->ulLinkID) || pAC->bIsNotReplicated);

    // Is this marked as ANR and indexed over the whole tree?
    //if(((pAC->fSearchFlags & (fANR | fATTINDEX)) == (fANR | fATTINDEX)) &&
    //   (!pAC->bDefunct)) {
    //    SCAddANRid(aid);
    //}

    // assign names of commonly used indexes when searching with
    // fSearchFlags fPDNTATTINDEX, fATTINDEX and fTUPLEINDEX
    if (pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX | fTUPLEINDEX)) {
        // set ATTINDEX
        if (pAC->fSearchFlags & fATTINDEX) {
            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (memcmp (pAC->pszIndex, szIndexName, lenIndexName) != 0) {
                DPRINT1 (0, "scAddAtt_test: ERROR, pszIndex different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        // set TUPLEINDEX
        if (pAC->fSearchFlags & fTUPLEINDEX) {
            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (memcmp (pAC->pszTupleIndex, szIndexName, lenIndexName) != 0) {
                DPRINT1 (0, "scAddAtt_test: ERROR, pszTupleIndex different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        // set PDNTATTINDEX
        if (pAC->fSearchFlags & fPDNTATTINDEX) {
            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (memcmp (pAC->pszPdntIndex, szIndexName, lenIndexName) != 0 ){
                DPRINT1 (0, "scAddAtt_test: ERROR, pszIndex different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }
    }


    // =====================================================
    {
        HASHCACHE*       ahcId        = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcId;
        HASHCACHE*       ahcCol       = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcCol;
        HASHCACHE*       ahcMapi      = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcMapi;
        HASHCACHE*       ahcLink      = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcLink;
        HASHCACHESTRING* ahcName      = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcName;




        if (pAC->jColid) {
            for (i=SChash(pAC->jColid, ATTCOUNT);
                  (ahcCol[i].pVal && (ahcCol[i].hKey != pAC->jColid));
                  i=(i+1)%ATTCOUNT){
            }
            if (ahcCol[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcCol different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        // update ahcMapi
        //
        if (pAC->ulMapiID) {
            for (i=SChash(pAC->ulMapiID,ATTCOUNT);
                   (ahcMapi[i].pVal && (ahcMapi[i].hKey != pAC->ulMapiID));
                   i=(i+1)%ATTCOUNT){
            }
            if (ahcMapi[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcMapi different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        if (pAC->name) {
            /* if this att has a name, add it to the name cache */

            for (i=SCNameHash(pAC->nameLen,pAC->name,ATTCOUNT);
                   (ahcName[i].pVal &&
                   (ahcName[i].length != pAC->nameLen ||
                   _memicmp(ahcName[i].value,pAC->name,pAC->nameLen)));
                   i=(i+1)%ATTCOUNT) {
            }
            if (ahcName[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcName different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        if (pAC->ulLinkID) {
            for (i=SChash(pAC->ulLinkID,ATTCOUNT);
                   (ahcLink[i].pVal && (ahcLink[i].hKey != pAC->ulLinkID));
                   i=(i+1)%ATTCOUNT){
            }
            if (ahcLink[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcLink different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }
    }

    return pAC;
}

void
SCCheckCacheConsistency (void)
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR
    DECLAREPREFIXPTR

    SEARCHARG SearchArg;
    SEARCHRES *pSearchRes;
    COMMARG  *pCommArg;
    PRESTART pRestart;
    BOOL fMoreData;
    FILTER Filter;
    ULONG objClass;
    ENTINFSEL eiSel;
    ATTRBLOCK AttrTypBlock;
    ENTINFLIST * pEIL, *pEILtmp;
    ULONG i, cCurrAttCnt, cCurrClsCount;
    ATTCACHE*   ac;
    CLASSCACHE* cc;
    SCHEMAPTR *tSchemaPtr;
    PVOID ptr;
    PVOID pNew;
    DWORD cAllocatedAttrs = 0;
    PARTIAL_ATTR_VECTOR *pPartialAttrVec = NULL;
    int mismatch, mismatchcnt;
    int err=0;


    ULONG Len = gAnchor.pDMD->structLen + 32*sizeof(WCHAR);
    DSNAME *pDsName = THAllocEx(pTHS,Len);
    WCHAR *SchemaObjDN = THAllocEx(pTHS,(gAnchor.pDMD->NameLen + 32)*sizeof(WCHAR));

    Assert(VALID_THSTATE(pTHS));

    DBOpen2(TRUE, &pTHS->pDB);

    __try { /* finally */

        if ( RecalcSchema( pTHS ) ){
            DPRINT(0,"SCCheckCacheConsistency: Recalc Schema FAILED\n");
            return;
        }

        if ( ComputeCacheClassTransitiveClosure(FALSE) ) {
            // Error
            DPRINT(0,"SCCheckCacheConsistency: Error closing classes\n");
            return;
        }


        //build the object-category value to put in the filter
        i = 0;
        wcscpy(SchemaObjDN, L"CN=Attribute-Schema,");
        i += 20;  // size of cn=attribute-schema,"
        wcscpy(&SchemaObjDN[i], gAnchor.pDMD->StringName);
        // SchemaObjDN now contains DN of attribute-schema class
        memset(pDsName, 0, Len);
        pDsName->NameLen = wcslen(SchemaObjDN);
        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);
        wcscpy(pDsName->StringName, SchemaObjDN);

        // build selection
        eiSel.attSel = EN_ATTSET_LIST;
        eiSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

        // regular cache load
        eiSel.AttrTypBlock.attrCount = NUMATTATT;
        eiSel.AttrTypBlock.pAttr = AttributeSelList;

        // do the initial allocation for the partial set
        if (SCCalloc(&pPartialAttrVec, 1, PartialAttrVecV1SizeFromLen(DEFAULT_PARTIAL_ATTR_COUNT))) {
            return;
        }

        pPartialAttrVec->dwVersion = VERSION_V1;
        pPartialAttrVec->V1.cAttrs = 0;
        cAllocatedAttrs = DEFAULT_PARTIAL_ATTR_COUNT;


        fMoreData = TRUE;
        pRestart = NULL;
        cCurrAttCnt = 0;
        mismatchcnt = 0;

        while (fMoreData) {

            // Check for service shutdown, since the next call to SearchBody can
            // take some time

            scAcquireSearchParameters(pTHS, pDsName, &eiSel, &SearchArg, &Filter, &pSearchRes);

            // Set for paged search;
            pCommArg = &(SearchArg.CommArg);
            pCommArg->PagedResult.fPresent = TRUE;
            pCommArg->PagedResult.pRestart = pRestart;
            pCommArg->ulSizeLimit = 200;


            // Search for all attSchema objects
            SearchBody(pTHS, &SearchArg, pSearchRes,0);
            if (pTHS->errCode) {
                LogAndAlertEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_SCHEMA_SEARCH_FAILED, szInsertUL(1),
                    szInsertUL(pTHS->errCode), 0);
                SCFree(&pPartialAttrVec);
                return;
            }


            // Set fMoreData for next iteration
            if ( !( (pSearchRes->PagedResult.pRestart != NULL)
                        && (pSearchRes->PagedResult.fPresent)
                  ) ) {
                // No more data needs to be read. So no iterarions needed after this
                fMoreData = FALSE;
            }
            else {
                // more data. save off the restart to use in the next iteration.
                // Note that we will free this searchres, but the pRestart is not freed by that

                pRestart = pSearchRes->PagedResult.pRestart;
            }

            // Check if table sizes are still large enough.

            if ((pSearchRes->count + cCurrAttCnt) > ATTCOUNT) {

               // Attribute tables are too small. there is no way this
               // can happen at this time.

               DPRINT3(0,"SCCheckCacheConsistency: Error: Reallocing tables: %d, %d, %d\n", pSearchRes->count, ATTCOUNT, pTHS->UpdateDITStructure);
               return;
            }

            //  for each attrSchema, add to caches
            pEIL = &(pSearchRes->FirstEntInf);
            for (i=0; i<pSearchRes->count; i++) {

                if (!pEIL) {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_MINIMAL,
                        DIRLOG_SCHEMA_BOGUS_SEARCH, szInsertUL(1), szInsertUL(i),
                        szInsertUL(pSearchRes->count));
                    break;
                }
                ac = scAddAtt_test(pTHS, &pEIL->Entinf, &mismatch, CurrSchemaPtr);

                mismatchcnt += mismatch;
                cCurrAttCnt++;


                /*
                if (ac!=NULL) {

                    if (ac->bMemberOfPartialSet)
                    {
                        // this attribute is a member of partial set
                        if (cAllocatedAttrs <= pPartialAttrVec->V1.cAttrs)
                        {
                            // not enough room to add one more attribute - reallocate the partial attribute vector
                            cAllocatedAttrs += PARTIAL_ATTR_COUNT_INC;

                            pNew = realloc(pPartialAttrVec, PartialAttrVecV1SizeFromLen(cAllocatedAttrs));
                            if (!pNew)
                            {
                                free(pPartialAttrVec);
                                return;
                            }
                            pPartialAttrVec = (PARTIAL_ATTR_VECTOR *) pNew;
                        }

                        // there is enough space to add the attribute into the partial set - add it
                        GC_AddAttributeToPartialSet(pPartialAttrVec, ac->id);
                    }

                }
                */

                pEILtmp = pEIL;
                pEIL = pEIL->pNextEntInf;
                if (i > 0) {
                    THFreeEx(pTHS, pEILtmp);
                }
            }

           // free the searchres
           scReleaseSearchParameters(pTHS, &pSearchRes);

        }  /* while (fMoreData) */



        // ==========================================================================



        // regular cache load
        eiSel.AttrTypBlock.attrCount = NUMCLASSATT;
        eiSel.AttrTypBlock.pAttr = ClassSelList;

        //build the object-category value to put in the filter
        i = 0;
        wcscpy(SchemaObjDN, L"CN=Class-Schema,");
        i += 16; // length of "cn=class-schema,"
        wcscpy(&SchemaObjDN[i], gAnchor.pDMD->StringName);
        // SchemaObjDN now has the dn of class-schema class
        memset(pDsName, 0, Len);
        pDsName->NameLen = wcslen(SchemaObjDN);
        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);
        wcscpy(pDsName->StringName, SchemaObjDN);

        // Initialize search parameters
        scAcquireSearchParameters(pTHS, pDsName, &eiSel, &SearchArg, &Filter, &pSearchRes);

        pTHS->errCode = 0;
        cCurrClsCount = 0;

        // Search for all classSchema objects
        // This time do a non-paged search since (1) it is very complex and time-consuming
        // to handle necessary reallocations in the middle, and (2) no. of classes are quite
        // small anyway (and not expected to be very large either)

        SearchBody(pTHS, &SearchArg, pSearchRes,0);

        if (pTHS->errCode) {
            LogAndAlertEvent(DS_EVENT_CAT_SCHEMA,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_SCHEMA_SEARCH_FAILED, szInsertUL(2),
                szInsertUL(pTHS->errCode), 0);

            return;
        }

        //????????????

        if (pSearchRes->count > CLSCOUNT) {

          // Class hash tables too small. Realloc the old tables.
          // Can possibly come here only during install/boot
          // Since class hash tables are not used prior to this,
          // just free the old table and calloc again (which automatically
          // zero them out too

           DPRINT3(0,"SCCheckCacheConsistency: Error: Reallocing Class tables: %d, %d, %d\n", pSearchRes->count, CLSCOUNT, pTHS->UpdateDITStructure);

           return;
        }

        //  for each classSchema, read and add to cache
        pEIL = &(pSearchRes->FirstEntInf);
        if (!pEIL) {
            DPRINT(0,"Null pEIL from SearchBody\n");
        }


        for (i=0; i<pSearchRes->count; i++) {

            if (!pEIL) {
                LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_MINIMAL,
                    DIRLOG_SCHEMA_BOGUS_SEARCH, szInsertUL(2), szInsertUL(i),
                    szInsertUL(pSearchRes->count));
                break;
            }

            cc = scAddClass_test(pTHS, &pEIL->Entinf, &mismatch, CurrSchemaPtr);


            mismatchcnt += mismatch;
            cCurrClsCount++;

            pEILtmp = pEIL;
            pEIL = pEIL->pNextEntInf;
            if (i > 0) {
                THFreeEx(pTHS, pEILtmp);
            }
        }

    } /* try-finally */
    __finally {
          DBClose(pTHS->pDB, FALSE);
          THFreeEx(pTHS,pDsName);
          THFreeEx(pTHS,SchemaObjDN);
    }

    DPRINT1(0,"Schema Cache Consistency Check FINISHED. Mismatches %d\n", mismatchcnt);
}

// Not for general use. Set to 0 in all builds.
//
// Set to _DEBUG_SCHEMA_ALLOC_ to 1 for quick and dirty check
// to make sure schema loads aren't leaking memory. Doesn't take
// into account memory freed/alloced outside of scchk.c, scache.c,
// and oidconv.c. Don't enable except in privates. Not stable.

LONG SchemaAlloced;
LONG SchemaEntries;

#if _DEBUG_SCHEMA_ALLOC_

#include <dbghelp.h>

// Not for general use.
//
// Quick and dirty check to make sure schema loads aren't leaking memory.
// Doesn't take into account memory freed/alloced outside of scchk.c,
// scache.c, and oidconv.c. Don't enable except in privates. Not stable.
CRITICAL_SECTION csSchemaAlloc;
LONG SchemaDump;
BOOL SchemaFirst = TRUE;
HANDLE  hSchemaProcessHandle = NULL;

// header prepended to each memory allocation. Actual memory address
// returned to caller skips this header and rounds up to 16 byte boundary.
#define SCHEMA_STACK 4
#define SCHEMA_SKIP  2
struct SchemaAlloc {
    struct SchemaAlloc *This;
    struct SchemaAlloc *Next;
    struct SchemaAlloc *Prev;
    DWORD nBytes;
    ULONG_PTR  Stack[SCHEMA_STACK];
} SchemaAnchor = {
    &SchemaAnchor,
    &SchemaAnchor,
    &SchemaAnchor,
    0
};

#define SCHEMA_EXTRA    ((sizeof(struct SchemaAlloc) + 15) & ~15)

VOID
SchemaStackTrace(
    IN PULONG_PTR   Stack,
    IN ULONG        Depth,
    IN ULONG        Skip
    )
/*++

Routine Description:

    Trace the stack back up to Depth frames. The current frame is included.

Arguments:

    Stack   - Saves the "return PC" from each frame
    Depth   - Only this many frames

Return Value:

    None.

--*/
{
    HANDLE      ThreadToken;
    ULONG       WStatus;
    STACKFRAME  Frame;
    ULONG       i;
    CONTEXT     Context;
    ULONG       FrameAddr;

    if (Stack) {
        *Stack = 0;
    }

    if (!hSchemaProcessHandle) {
        return;
    }

    //
    // I don't know how to generate a stack for an alpha, yet. So, just
    // to get into the build, disable the stack trace on alphas.
    //
#if ALPHA
    return;
#elif IA64

    //
    // Need stack dump init for IA64.
    //

    return;

#else

    //
    // init
    //

    ZeroMemory(&Context, sizeof(Context));

    // no need to close this handle
    ThreadToken = GetCurrentThread();


    try { try {
        Context.ContextFlags = CONTEXT_FULL;
        if (!GetThreadContext(ThreadToken, &Context)) {
            DPRINT1(0, "Can't get context (error 0x%x)\n", GetLastError());
        }

        //
        // let's start clean
        //
        ZeroMemory(&Frame, sizeof(STACKFRAME));

        //
        // from  nt\private\windows\screg\winreg\server\stkwalk.c
        //
        Frame.AddrPC.Segment = 0;
        Frame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
        Frame.AddrFrame.Offset = Context.Ebp;
        Frame.AddrFrame.Mode = AddrModeFlat;

        Frame.AddrStack.Offset = Context.Esp;
        Frame.AddrStack.Mode = AddrModeFlat;

        Frame.AddrPC.Offset = (DWORD)Context.Eip;
#elif defined(_M_MRX000)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#elif defined(_M_ALPHA)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#endif

        for (i = 0; i < (Depth - 1 + Skip); ++i) {
            *Stack=0;
            if (!StackWalk(
                IMAGE_FILE_MACHINE_I386,  // DWORD                          MachineType
                hSchemaProcessHandle,        // HANDLE                         hProcess
                ThreadToken,              // HANDLE                         hThread
                &Frame,                   // LPSTACKFRAME                   StackFrame
                NULL, //(PVOID)&Context,          // PVOID                          ContextRecord
                NULL,                     // PREAD_PROCESS_MEMORY_ROUTINE   ReadMemoryRoutine
                SymFunctionTableAccess,   // PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine
                SymGetModuleBase,         // PGET_MODULE_BASE_ROUTINE       GetModuleBaseRoutine
                NULL)) {                  // PTRANSLATE_ADDRESS_ROUTINE     TranslateAddress

                WStatus = GetLastError();

                //DPRINT1_WS(0, "++ Can't get stack address for level %d;", i, WStatus);
                break;
            }
            if (!(*Stack = Frame.AddrReturn.Offset)) {
                break;
            }
            if (i < Skip) {
                continue;
            }
            ++Stack;
        }
    } except (HandleAllExceptions(GetExceptionCode())) {
        /* FALL THROUGH */
    } } finally {
      ;
    }
    return;
#endif
}


VOID
SCFree(
    IN OUT VOID **ppMem
    )
/*++

Routine Description:

    Free memory allocated with SCCalloc or SCRealloc.

Arguments:

Return Value:

    None.

--*/
{
    // Quick and dirty check to make sure schema loads aren't leaking memory.
    // Doesn't take into account memory freed/alloced outside of scchk.c,
    // scache.c, and oidconv.c. Don't enable except in privates. Not stable.
    struct SchemaAlloc *pSA;

    if (*ppMem) {
        // adjust to header
        pSA = (PVOID)((PCHAR)(*ppMem) - SCHEMA_EXTRA);
        Assert(pSA->This == pSA);
        EnterCriticalSection(&csSchemaAlloc);
        __try {
            // Remove from list
            pSA->Next->Prev = pSA->Prev;
            pSA->Prev->Next = pSA->Next;

            // Maintain bytes alloced
            SchemaAlloced -= pSA->nBytes;
            --SchemaEntries;
        } __finally {
            LeaveCriticalSection(&csSchemaAlloc);
        }
        free(pSA);
        *ppMem = NULL;
    }
}

int
SCReallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    realloc memory. Free with free(). On error, log an error but
    leave *ppMem unchanged.

Arguments:

    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of realloced memory. Free with SCFree().
    !0 - do not alter *ppMem and log an event

--*/
{
    // Quick and dirty check to make sure schema loads aren't leaking memory.
    // Doesn't take into account memory freed/alloced outside of scchk.c,
    // scache.c, and oidconv.c. Don't enable except in privates. Not stable.
    struct SchemaAlloc *pSA;
    PVOID p;

    // adjust to header
    pSA = (PVOID)((PCHAR)(*ppMem) - SCHEMA_EXTRA);
    Assert(pSA->This == pSA);

    // Remove from list
    EnterCriticalSection(&csSchemaAlloc);
    __try {
        pSA->Next->Prev = pSA->Prev;
        pSA->Prev->Next = pSA->Next;
        SchemaAlloced -= pSA->nBytes;
        --SchemaEntries;
    } __finally {
        LeaveCriticalSection(&csSchemaAlloc);
    }

    // realloc (including extra bytes)
    nBytes += SCHEMA_EXTRA;
    if (NULL != (p = realloc(pSA, nBytes))) {
        pSA = p;
    }
    // add back at head of list
    pSA->This = pSA;
    pSA->nBytes = nBytes;
    EnterCriticalSection(&csSchemaAlloc);
    __try {
        pSA->Next = SchemaAnchor.Next;
        pSA->Prev = &SchemaAnchor;
        pSA->Next->Prev = pSA;
        pSA->Prev->Next = pSA;
        SchemaAlloced += pSA->nBytes;
        ++SchemaEntries;
    } __finally {
        LeaveCriticalSection(&csSchemaAlloc);
    }

    if (!p) {
        // log an event and set error in thread state
        scMemoryPanic(nBytes);
        return 1;
    }

    // Return block past header
    *ppMem = (PCHAR)pSA + SCHEMA_EXTRA;
    return 0;
}


int
SCCallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nItems,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    malloc and clear memory. Free with free(). On error, log an event

Arguments:

    ppMem - address of address to return memory pointer
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of malloced, cleared memory. Free with SCFree().
    !0 - clear *ppMem and log an event

--*/
{
    // Quick and dirty check to make sure schema loads aren't leaking memory.
    // Doesn't take into account memory freed/alloced outside of scchk.c,
    // scache.c, and oidconv.c. Don't enable except in privates. Not stable.
    struct SchemaAlloc *pSA;

    // First time thru the DS is running single threaded (CYF).
    if (SchemaFirst) {
        if (InitializeCriticalSectionAndSpinCount(&csSchemaAlloc, 4000) != ERROR_SUCCESS) {
            DPRINT1(0, "Could not initialize csSchemaAlloc (error 0x%x)\n" ,GetLastError());
            return 1;
        }
        hSchemaProcessHandle = GetCurrentProcess();
        if (!SymInitialize(hSchemaProcessHandle, NULL, FALSE)) {
            DPRINT1(0, "Could not initialize symbol subsystem (imagehlp) (error 0x%x)\n" ,GetLastError());
            hSchemaProcessHandle = 0;
        }
        SchemaFirst = FALSE;
    }
    nBytes = (nBytes * nItems) + SCHEMA_EXTRA;
    pSA = malloc(nBytes);
    if (!pSA) {
        *ppMem = NULL;
        scMemoryPanic(nBytes);
        return 1;
    }
    memset(pSA, 0, nBytes);
    pSA->This = pSA;
    pSA->nBytes = nBytes;
    EnterCriticalSection(&csSchemaAlloc);
    __try {
        pSA->Next = SchemaAnchor.Next;
        pSA->Prev = &SchemaAnchor;
        pSA->Next->Prev = pSA;
        pSA->Prev->Next = pSA;
        SchemaAlloced += pSA->nBytes;
        ++SchemaEntries;
        SchemaStackTrace(pSA->Stack, SCHEMA_STACK, SCHEMA_SKIP);
        if (SchemaDump) {
            struct SchemaAlloc *p;
            DPRINT1(0, "SCCallocWrn: %d alloced\n", SchemaAlloced);
            for (p = SchemaAnchor.Prev;
                 p != &SchemaAnchor && SchemaDump;
                 p = p->Prev, --SchemaDump) {
                DPRINT2(0, "SCCallocWrn: %08x %6d\n", p->This, p->nBytes - SCHEMA_EXTRA);
                DPRINT4(0, "SCCallocWrn:     %08x %08x %08x %08x\n",
                        p->Stack[0], p->Stack[1], p->Stack[2], p->Stack[3]);

            }
            SchemaDump = 0;
        }
    } __finally {
        LeaveCriticalSection(&csSchemaAlloc);
    }

    *ppMem = (PCHAR)pSA + SCHEMA_EXTRA;
    return 0;
}
#endif _DEBUG_SCHEMA_ALLOC_

int
SCCheckSchemaCache(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:
    Verify that the global schema cache is self-consistent.

Arguments:
    pTHS - thread state
    pBuf - from GenericControl

Return Value:

    pTHS->errCode

--*/
{
    DECLARESCHEMAPTR
    DWORD nAttInId, i, nClsInAll;
    ATTCACHE *pAC, *pACtmp;
    CLASSCACHE *pCC, *pCCtmp;
    SCHEMAPTR *pSch = (SCHEMAPTR *)pTHS->CurrSchemaPtr;

    DPRINT2(0, "Schema/anchor version: %d/%d\n",
            pSch->ForestBehaviorVersion, gAnchor.ForestBehaviorVersion);

    // Id
    for (i = nAttInId = 0; i < ATTCOUNT; ++i) {
        pAC = ahcId[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        ++nAttInId;

        if (!pAC->name || (pAC->nameLen == 0)) {
            DPRINT2(0, "ERROR: Bad att name: (%x, %x)\n", pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
        if (pAC != SCGetAttById(pTHS, pAC->id)) {
            DPRINT3(0, "ERROR: Bad ahcid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
        if (pAC->bFlagIsRdn && !pAC->bIsRdn) {
            DPRINT3(0, "ERROR: Bad FlagIsRdn: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }

        if (!pAC->bDefunct
            || !ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            if (pAC != SCGetAttByExtId(pTHS, pAC->Extid)) {
                DPRINT3(0, "ERROR: Not in ahcExtid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC != SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
                DPRINT3(0, "ERROR: Not in ahcName: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC->ulMapiID && pAC != SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
                DPRINT3(0, "ERROR: Not in ahcMapi: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        } else if (!pAC->bIsRdn) {
            if (pAC == SCGetAttByExtId(pTHS, pAC->Extid)) {
                DPRINT3(0, "ERROR: Should not be in ahcExtid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC == SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
                DPRINT3(0, "ERROR: Should not be in ahcName: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC->ulMapiID && pAC == SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
                DPRINT3(0, "ERROR: Should not be in ahcMapi: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        } else {
            if (NULL == (pACtmp = SCGetAttByExtId(pTHS, pAC->Extid))
                || !pACtmp->bIsRdn
                || (pAC->bFlagIsRdn && !pACtmp->bFlagIsRdn)
                || (pAC->bFlagIsRdn == pACtmp->bFlagIsRdn
                    && (0 < memcmp(&pAC->objectGuid,
                                   &pACtmp->objectGuid,
                                   sizeof(pAC->objectGuid)))) ) {
                DPRINT5(0, "ERROR: Wrong rdn in ahcExtid: %s (%x, %x) (%p %p)\n", pAC->name, pAC->id, pAC->Extid, pAC, pACtmp);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (NULL == (pACtmp = SCGetAttByName(pTHS, pAC->nameLen, pAC->name))
                || !pACtmp->bIsRdn
                || (pAC->bFlagIsRdn && !pACtmp->bFlagIsRdn)
                || (pAC->bFlagIsRdn == pACtmp->bFlagIsRdn
                    && (0 < memcmp(&pAC->objectGuid,
                                   &pACtmp->objectGuid,
                                   sizeof(pAC->objectGuid)))) ) {
                DPRINT5(0, "ERROR: Wrong rdn in ahcName: %s (%x, %x) (%p %p)\n", pAC->name, pAC->id, pAC->Extid, pAC, pACtmp);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC->ulMapiID
                && (NULL == (pACtmp = SCGetAttByMapiId(pTHS, pAC->ulMapiID))
                    || !pACtmp->bIsRdn
                    || (pAC->bFlagIsRdn && !pACtmp->bFlagIsRdn)
                    || (pAC->bFlagIsRdn == pACtmp->bFlagIsRdn
                        && (0 < memcmp(&pAC->objectGuid,
                                       &pACtmp->objectGuid,
                                       sizeof(pAC->objectGuid))))) ) {
                DPRINT5(0, "ERROR: Wrong rdn in ahcMapi: %s (%x, %x) (%p %p)\n", pAC->name, pAC->id, pAC->Extid, pAC, pACtmp);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        }
        // pre-beta3 forests should not have intid
        if (pAC->id != pAC->Extid
            && !ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            DPRINT3(0, "ERROR: Bad intid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }
    if (pSch->nAttInDB != nAttInId) {
        DPRINT2(0, "ERROR: nAttInDB (%d) != nAttInId (%d)\n", CurrSchemaPtr->nAttInDB, nAttInId);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // ExtId
    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcExtId[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByExtId(pTHS, pAC->Extid)) {
            DPRINT3(0, "ERROR: Bad ahcExtid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
        if (pAC->bDefunct
            && !pAC->bIsRdn
            && ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            DPRINT3(0, "ERROR: Bad defunct: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // Name
    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcName[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
            DPRINT3(0, "ERROR: Bad ahcName: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // MapiID Hash
    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcMapi[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
            DPRINT3(0, "ERROR: Bad ahcMapi: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // ATT SchembIdGuid Hash
    if (ahcAttSchemaGuid) for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcAttSchemaGuid[i];
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByPropGuid(pTHS, pAC)) {
            DPRINT3(0, "ERROR: Bad ahcAttSchemaIdGuid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // ClassAll
    for (i = nClsInAll = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        ++nClsInAll;

        // bad LDN
        if (!pCC->name || (pCC->nameLen == 0)) {
            DPRINT1(0, "ERROR: Bad cls name: (%x)\n", pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }

        if (!pCC->bDefunct
            || !ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            if (pCC != SCGetClassById(pTHS, pCC->ClassId)) {
                DPRINT2(0, "ERROR: Not in ahcClass: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pCC != SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
                DPRINT2(0, "ERROR: Not in ahcClassName: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        } else {
            if (NULL == (pCCtmp = SCGetClassById(pTHS, pCC->ClassId))
                || (pCC->bDefunct == pCCtmp->bDefunct
                    && (0 < memcmp(&pCC->objectGuid,
                                   &pCCtmp->objectGuid,
                                   sizeof(pCC->objectGuid)))) ) {
                DPRINT2(0, "ERROR: Should not be in ahcClass: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pCC == SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
                DPRINT2(0, "ERROR: Should not be in ahcClassName: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        }
    }
    if (pSch->nClsInDB != nClsInAll) {
        DPRINT2(0, "ERROR: nClsInDB (%d) != nClsInAll (%d)\n", CurrSchemaPtr->nClsInDB, nClsInAll);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // Class
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClass[i].pVal;
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        if (pCC != SCGetClassById(pTHS, pCC->ClassId)) {
            DPRINT2(0, "ERROR: Bad ahcClass: %s (%x)\n", pCC->name, pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // ClassName
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassName[i].pVal;
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        if (pCC != SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
            DPRINT2(0, "ERROR: Bad ahcClassName: %s (%x)\n", pCC->name, pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // CLS SchembIdGuid Hash
    if (ahcClsSchemaGuid) for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClsSchemaGuid[i];
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        if (pCC != SCGetClassByPropGuid(pTHS, pCC)) {
            DPRINT2(0, "ERROR: Bad ahcClsSchemaIdGuid: %s (%x)\n", pCC->name, pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    if (pSch->ForestBehaviorVersion != gAnchor.ForestBehaviorVersion) {
        DPRINT2(0, "ERROR: Version mismatch: Schema %d != gAnchor %d\n",
                pSch->ForestBehaviorVersion, gAnchor.ForestBehaviorVersion);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    return 0;
}

int
SCCheckRdnOverrun(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:
    Check the new code rdn encoding code.

Arguments:
    pTHS - thread state
    pBuf - from GenericControl

Return Value:

    pTHS->errCode

--*/
{
    DWORD   ccOut, i;
    DWORD   Vals[4];
    OID     Oid;
    WCHAR   Out[MAX_RDN_KEY_SIZE + 1];
    ATTRTYP AttrTyp = 4294967295; // 0xFFFFFFFF
    CHAR    ExpBer[] = {0x4f, 0xA0, 0xFF, 0xFF, 0x7F, 0xA0, 0xFF, 0xFF, 0x7F };

    Oid.cVal = 1;
    Oid.Val = &AttrTyp;

    //
    // OidStructToString
    //

    // buffer too small
    ccOut = OidStructToString(&Oid, Out, 8);
    if (ccOut) {
        DPRINT(0, "ERROR: OidStructToString overrun not detected\n");
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // expect OID.4294967295
    memset(Out, 0, sizeof(Out));
    ccOut = OidStructToString(&Oid, Out, MAX_RDN_KEY_SIZE);
    if (ccOut != 14) {
        DPRINT2(0, "ERROR: OidStructToString bad conversion: %d != %d expected\n", ccOut, 14);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }
    if (0 != _wcsnicmp(L"OID.4294967295", Out, 14)) {
        DPRINT1(0, "ERROR: OidStructToString bad conversion: %ws != OID.4294967295 expected\n", Out);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    //
    // AttrTypeToIntIdString
    //

    // buffer too small
    ccOut = AttrTypeToIntIdString(AttrTyp, Out, 8);
    if (ccOut) {
        DPRINT(0, "ERROR: AttrTypeToIntIdString overrun not detected\n");
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // expect IID.4294967295
    memset(Out, 0, sizeof(Out));
    ccOut = AttrTypeToIntIdString(AttrTyp, Out, MAX_RDN_KEY_SIZE);
    if (ccOut != 14) {
        DPRINT2(0, "ERROR: AttrTypeToIntIdString bad conversion: %d != %d expected\n", ccOut, 14);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }
    if (0 != _wcsnicmp(L"IID.4294967295", Out, 14)) {
        DPRINT1(0, "ERROR: AttrTypeToIntIdString bad conversion: %ws != IID.4294967295 expected\n", Out);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // \x4f A0FFFF7F A0FFFF7F
    Oid.cVal = 4;
    Oid.Val = Vals;
    Oid.Val[0] = 0x1;
    Oid.Val[1] = 0x27;
    Oid.Val[2] = 0x41FFFFF;
    Oid.Val[3] = 0x41FFFFF;
    for (i = 0; i < 9; ++i) {
        ccOut = EncodeOID(&Oid, (PCHAR)Out, i);
        if (ccOut) {
            DPRINT(0, "ERROR: EncodeOID overrun not detected\n");
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }
    ccOut = EncodeOID(&Oid, (PCHAR)Out, 9);
    if (ccOut != 9) {
        DPRINT2(0, "ERROR: EncodeOID bad conversion: %d != %d expected\n", ccOut, 9);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }
    if (0 != memcmp(ExpBer, Out, 9)) {
        DPRINT(0, "ERROR: EncodeOID bad conversion\n");
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    return 0;
}

VOID
scDefaultSdForExe(
    IN THSTATE      *pTHS,
    IN CLASSCACHE   *pCC
    )
/*++

Routine Description:

    Hammer the default SD on cached classes when running as
    dsamain.exe w/security disabled. But be careful to keep
    the correct defaultSD when running as mkdit.exe to catch
    errors.

Arguments:

    pCC - fix up pCC's pStrSD and cbStrSD

Return Value:

    pTHS->errCode

--*/
{
    extern DWORD dwSkipSecurity;

    // everyone all access
#define _DEFAULT_SDDL_FOR_EXE_  L"O:WDG:WDD:(A;;GA;;;WD)"

    // Hammer the default SD on cached classes when running as
    // dsamain.exe w/security disabled. But be careful to keep
    // the correct defaultSD when running as mkdit.exe to catch
    // errors.
    if (dwSkipSecurity && gfRunningAsExe && !gfRunningAsMkdit) {
        SCFree(&pCC->pStrSD);
        pCC->cbStrSD = (wcslen(_DEFAULT_SDDL_FOR_EXE_) + 1) * sizeof(WCHAR);
        if (SCCalloc(&pCC->pStrSD, 1, pCC->cbStrSD)) {
            Assert(!"Could not DefaultSD for Unit Test");
        }
        memcpy(pCC->pStrSD, _DEFAULT_SDDL_FOR_EXE_, pCC->cbStrSD);
    }
}


int
SCCopySchema(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:

    Make a copy of the schema and then free it

Arguments:

    pTHS - thread state
    pBuf - ignored

Return Value:

    pTHS->errCode

--*/
{
    DWORD       i;
    DWORD CopyAtt = 0;
    DWORD CopyCls = 0;
    ATTCACHE    *pAC, *pACDup = NULL;
    CLASSCACHE  *pCC, *pCCDup = NULL;
    static DWORD CopyAttTot = 0;
    static DWORD CopyClsTot = 0;
    static DWORD CopyAttFail = 0;
    static DWORD CopyClsFail = 0;
    ULONG ATTCOUNT = pTHS->CurrSchemaPtr->ATTCOUNT;
    ULONG CLSCOUNT = pTHS->CurrSchemaPtr->CLSCOUNT;
    HASHCACHE *ahcId = pTHS->CurrSchemaPtr->ahcId;
    HASHCACHE *ahcClassAll = pTHS->CurrSchemaPtr->ahcClassAll;

    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcId[i].pVal;
        if (!pAC || pAC == FREE_ENTRY) {
            continue;
        }
        ++CopyAtt;
        ++CopyAttTot;
        if (scDupStruct(pTHS, pAC, &pACDup, sizeof(ATTCACHE))
            || scDupString(pTHS, pAC->name, &pACDup->name)
            || scDupString(pTHS, pAC->pszPdntIndex, &pACDup->pszPdntIndex)
            || scDupStruct(pTHS, pAC->pidxPdntIndex, &pACDup->pidxPdntIndex, sizeof(*pAC->pidxPdntIndex))
            || scDupString(pTHS, pAC->pszIndex, &pACDup->pszIndex)
            || scDupStruct(pTHS, pAC->pidxIndex, &pACDup->pidxIndex, sizeof(*pAC->pidxIndex))
            || scDupString(pTHS, pAC->pszTupleIndex, &pACDup->pszTupleIndex)
            || scDupStruct(pTHS, pAC->pidxTupleIndex, &pACDup->pidxTupleIndex, sizeof(*pAC->pidxTupleIndex))) {
                ++CopyAttFail;
        }
        SCFreeAttcache(&pACDup);
    }

    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }
        ++CopyCls;
        ++CopyClsTot;
        if (scDupStruct(pTHS, pCC, &pCCDup, sizeof(CLASSCACHE))
            || scDupString(pTHS, pCC->name, &pCCDup->name)
            || scDupStruct(pTHS, pCC->pSD, &pCCDup->pSD, pCC->SDLen)
            || (pCC->pDefaultObjCategory
                && scDupStruct(pTHS, pCC->pDefaultObjCategory, &pCCDup->pDefaultObjCategory, pCC->pDefaultObjCategory->structLen))
            || scDupStruct(pTHS, pCC->pSubClassOf, &pCCDup->pSubClassOf, pCC->SubClassCount * sizeof(ULONG))
            || scDupStruct(pTHS, pCC->pAuxClass, &pCCDup->pAuxClass, pCC->AuxClassCount * sizeof(ULONG))
            || scDupStruct(pTHS, pCC->pPossSup, &pCCDup->pPossSup, pCC->PossSupCount * sizeof(ULONG))
            || scDupStruct(pTHS, pCC->pMustAtts, &pCCDup->pMustAtts, pCC->MustCount * sizeof(ATTRTYP))
            || scDupStruct(pTHS, pCC->pMayAtts, &pCCDup->pMayAtts, pCC->MayCount * sizeof(ATTRTYP))
            // Clear these entries. They will be re-initialized at first request.
            || (pCCDup->ppAllAtts = NULL)
            || (pCCDup->pAttTypeCounts = 0)
            || scDupStruct(pTHS, pCC->pMyMustAtts, &pCCDup->pMyMustAtts, pCC->MyMustCount * sizeof(ATTRTYP))
            || scDupStruct(pTHS, pCC->pMyMayAtts, &pCCDup->pMyMayAtts, pCC->MyMayCount * sizeof(ATTRTYP))
            || scDupStruct(pTHS, pCC->pMyPossSup, &pCCDup->pMyPossSup, pCC->MyPossSupCount * sizeof(ULONG))) {
            ++CopyClsFail;
        }
        SCFreeClasscache(&pCCDup);
    }
    DPRINT3(0, "CopySchema: %d Att, %d AttTot, %d AttFail\n", CopyAtt, CopyAttTot, CopyAttFail);
    DPRINT3(0, "CopySchema: %d Cls, %d ClsTot, %d ClsFail\n", CopyCls, CopyClsTot, CopyClsFail);
    return pTHS->errCode;
}

int
SCSchemaPerf(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:

    Perf of schema hash tables

Arguments:

    pTHS - thread state
    pBuf - ignored

Return Value:

    pTHS->errCode

--*/
{
    DWORD       hi, i, nTries, nBad, nEnt, nTotTries;
    ATTCACHE    *pAC;
    CLASSCACHE  *pCC;
    ULONG ATTCOUNT = pTHS->CurrSchemaPtr->ATTCOUNT;
    HASHCACHE *ahcId = pTHS->CurrSchemaPtr->ahcId;

    for (hi = nEnt = nBad = nTotTries = 0; hi < ATTCOUNT; ++hi) {
        pAC = ahcId[hi].pVal;
        if (!pAC || pAC == FREE_ENTRY) {
            continue;
        }
        ++nEnt;

        for (i = SChash(pAC->id, ATTCOUNT), nTries = 0;
             ahcId[i].pVal && ahcId[i].pVal != pAC; i=(i+1)%ATTCOUNT) {
            ++nTries;
            if (nTries > 1) {
                if (ahcId[i].pVal != FREE_ENTRY) {
                    DPRINT2(0, "%x collides with %x\n", pAC->id, ((ATTCACHE *)ahcId[i].pVal)->id);
                } else {
                    DPRINT(0, "FREE_ENTRY\n");
                }
            }
        }
        nTotTries += nTries;
        if (ahcId[i].pVal != pAC) {
            DPRINT3(0, "Id Hash: Missing %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
        } else if (nTries) {
            if (nTries > 1) {
                DPRINT4(0, "Id Hash: %s (%x, %x), %d tries\n", pAC->name, pAC->id, pAC->Extid, nTries);
            }
            ++nBad;
        }
    }
    DPRINT4(0, "Id Hash: %d hash, %d ents, %d bad, %d Tries\n", ATTCOUNT, nEnt, nBad, nTotTries);
    return pTHS->errCode;
}

int
SCSchemaStats(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:

    Report schema alloc stats

Arguments:

    pTHS -
    pBuf - ignored

Return Value:

    pTHS->errCode

--*/
{
    DPRINT3(0, "%p: %d SchemaAlloced, %d SchemEntries\n",
            CurrSchemaPtr, SchemaAlloced, SchemaEntries);
    if (CurrSchemaPtr) {
        DPRINT2(0, "%d Schema Version, %d Forest Version\n",
                CurrSchemaPtr->ForestBehaviorVersion,
                gAnchor.ForestBehaviorVersion);
    } else {
        DPRINT(0, "No CurrSchemaPtr\n");
    }

    DPRINT3(0, "Name     : %6d %6d %4.2f\n",
           hashstat.nameLookups, hashstat.nameTries,
           (float)hashstat.nameTries/hashstat.nameLookups);

    DPRINT3(0, "ClassName: %6d %6d %4.2f\n",
           hashstat.classNameLookups, hashstat.classNameTries,
           (float)hashstat.classNameTries/hashstat.classNameLookups);

    DPRINT3(0, "id       : %6d %6d %4.2f\n",
           hashstat.idLookups, hashstat.idTries,
           (float)hashstat.idTries/hashstat.idLookups);

    DPRINT3(0, "Class    : %6d %6d %4.2f\n",
           hashstat.classLookups, hashstat.classTries,
           (float)hashstat.classTries/hashstat.classLookups);

    DPRINT3(0, "Col      : %6d %6d %4.2f\n",
           hashstat.colLookups, hashstat.colTries,
           (float)hashstat.colTries/hashstat.colLookups);

    DPRINT3(0, "Mapi     : %6d %6d %4.2f\n",
           hashstat.mapiLookups, hashstat.mapiTries,
           (float)hashstat.mapiTries/hashstat.mapiLookups);

    DPRINT3(0, "Link     : %6d %6d %4.2f\n",
           hashstat.linkLookups, hashstat.linkTries,
           (float)hashstat.linkTries/hashstat.linkLookups);

    DPRINT3(0, "Prop     : %6d %6d %4.2f\n",
           hashstat.PropLookups, hashstat.PropTries,
           (float)hashstat.PropTries/hashstat.PropLookups);

    DPRINT3(0, "ClassProp: %6d %6d %4.2f\n",
           hashstat.classPropLookups, hashstat.classPropTries,
           (float)hashstat.classPropTries/hashstat.classPropLookups);

    return pTHS->errCode;
}
#endif DBG && INCLUDE_UNIT_TESTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\secadmin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       
//
//--------------------------------------------------------------------------

/*++

Module Name:

    secadmin.c

Abstract:

    This module contains routines for implementing protection of administrative groups


Author:

    Murli Satagopan   (MURLIS)   6-Feb-99

Revision History:



--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <samsrvp.h>
// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"

// Filter and Attribute 
#include <filtypes.h>                   // header for filter type
#include <attids.h>                     // attribuet IDs 
#include <sddl.h>
#include <mappings.h>

#include <msaudite.h>


#include "debug.h"                      // standard debugging header
#define DEBSUB     "SECADMIN:"          // define the subsystem for debugging


#include <fileno.h>                     // used for THAlloEx, but I did not 
#define  FILENO FILENO_SECADMIN         // use it in this module





/*

    Theory of Operation



    NT4 and earlier releases of NT protected the users in Administrative groups by
    changing the ACL on the member as they were added to the group. NT5 cannot adopt
    this strategy as 

        1. NT5 supports nested groups ( NT4 did not have group nesting )
        2. NT5 supports universal groups which can have members in other domain domains
           and could themselves be members of groups in other domains.


    NT5 implements protection of administrative groups by a background daemon. This daemon
    first computes the set of memberships in transitive fashion of all administrative groups.
    It then walks the list of objects that it has and checks whether the security descriptor
    on them is a well known protected security descriptor. If the well known protected security
    descriptor is not set then this security descriptor is set on the object. This task is
    executed only on the PDC FSMO holder.

--*/


NTSTATUS
SampBuildAdministratorsSet(
    IN THSTATE *pTHS,
    IN ULONG CountOfBuiltinLocalGroups,
    IN PDSNAME *BuiltinLocalGroups,
    IN ULONG CountOfDomainLocalGroups,
    IN PDSNAME *DomainLocalGroups,
    IN ULONG CountOfDomainGlobalGroups,
    IN PDSNAME *DomainGlobalGroups,
    IN ULONG CountOfDomainUniversalGroups,
    IN PDSNAME *DomainUniversalGroups,
    IN DSNAME * EnterpriseAdminsDsName,
    IN DSNAME * SchemaAdminsDsName,
    OUT PULONG  pcCountOfMembers,
    OUT PDSNAME **prpMembers
    );


NTSTATUS
SampSearchWellKnownAccounts(
    IN THSTATE * pTHS,
    IN BOOLEAN fBuiltinDomain,
    OUT SEARCHRES *pSearchRes 
    );

NTSTATUS    
SampFilterWellKnownAccounts(
    IN THSTATE *pTHS,
    IN SEARCHRES *BuiltinDomainSearchRes,
    IN SEARCHRES *AccountDomainSearchRes,
    OUT ULONG *CountOfBuiltinLocalGroups,
    OUT PDSNAME **BuiltinLocalGroups,
    OUT ULONG *CountOfDomainLocalGroups,
    OUT PDSNAME **DomainLocalGroups,
    OUT ULONG *CountOfDomainGlobalGroups,
    OUT PDSNAME **DomainGlobalGroups,
    OUT ULONG *CountOfDomainUniversalGroups,
    OUT PDSNAME **DomainUniversalGroups,
    OUT ULONG *CountOfDomainUsers,
    OUT PDSNAME **DomainUsers,
    OUT ULONG *CountOfExclusiveGroups,
    OUT PDSNAME **ExclusiveGroups
    );



NTSTATUS
SampReadAdminSecurityDescriptor(
    PVOID *ProtectedSecurityDescriptor,
    PULONG ProtectedSecurityDescriptorLength                
    )

/*++

    Routine Description

    This routine reads the security descriptor off of the AdminSD object
    in the system container

    Also updates the security descriptor if necessary 

    Paramters

        ProtectedSecurityDescriptor
        ProtectedSecurityDescriptorLength

    Return Values

        STATUS_SUCCESS
        Other Error codes
--*/
{
    THSTATE     *pTHS = pTHStls;
    NTSTATUS    Status = STATUS_SUCCESS;
    READARG     ReadArg;
    READRES     *pReadRes;
    ENTINFSEL   EntInf;
    ATTR        SecurityDescriptorAttr;
    LONG        ObjectLen =0;
    DSNAME      *pSystemContainerDN = NULL;
    DSNAME      *pAdminSDHolderDN= NULL;
    DWORD       dwErr=0;
    NTSTATUS    IgnoreStatus;
    BOOL        Result;
    PACL        Sacl = NULL;
    BOOL        SaclPresent;
    BOOL        SaclDefaulted;
   

    //
    // Setup up the ENTINFSEL structure
    //

    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
    EntInf.AttrTypBlock.attrCount = 1;
    RtlZeroMemory(&SecurityDescriptorAttr,sizeof(ATTR));
    SecurityDescriptorAttr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    EntInf.AttrTypBlock.pAttr = &SecurityDescriptorAttr;

    //
    // Get the object name of the object that holds the security descriptor
    //

    ObjectLen = AppendRDN(
                    gAnchor.pDomainDN,
                    pSystemContainerDN,
                    0,
                    L"System",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(ObjectLen>0);


    pSystemContainerDN = THAlloc(ObjectLen);
    if (!pSystemContainerDN)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    dwErr        = AppendRDN(
                    gAnchor.pDomainDN,
                    pSystemContainerDN,
                    ObjectLen,
                    L"System",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(0==dwErr);
    if (0!=dwErr)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    ObjectLen    = AppendRDN(
                    pSystemContainerDN,
                    pAdminSDHolderDN,
                    0,
                    L"AdminSDHolder",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(ObjectLen>0);


    pAdminSDHolderDN = THAlloc(ObjectLen);
    
    if (!pAdminSDHolderDN)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    dwErr        = AppendRDN(
                    pSystemContainerDN,
                    pAdminSDHolderDN,
                    ObjectLen,
                    L"AdminSDHolder",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(0==dwErr);

    if (0!=dwErr)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // init ReadArg
    //

    RtlZeroMemory(&ReadArg, sizeof(READARG));


    //
    // Build the commarg structure
    //

    InitCommarg(&(ReadArg.CommArg));
    

    //
    // Setup the Read Arg Structure
    //

   

    ReadArg.pObject = pAdminSDHolderDN;
    ReadArg.pSel    = & EntInf;

    //
    // Read the security descriptor
    //

    dwErr = DirRead(&ReadArg,&pReadRes);

    if (0!=dwErr)
    {
        THClearErrors();
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    Assert(1==pReadRes->entry.AttrBlock.attrCount);
    Assert(ATT_NT_SECURITY_DESCRIPTOR == pReadRes->entry.AttrBlock.pAttr[0].attrTyp);

    *ProtectedSecurityDescriptorLength = pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;
    *ProtectedSecurityDescriptor = pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;


    //
    // get SACL's address
    //

    Result = GetSecurityDescriptorSacl((PSECURITY_DESCRIPTOR)*ProtectedSecurityDescriptor,
                                       &SaclPresent,
                                       &Sacl,
                                       &SaclDefaulted);

    if ( !Result || 
         !SaclPresent ||
         (NULL == Sacl) )
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Set SACL's revision value to ACL_REVISION_DS (4) 
    // 
    // why is that? 
    //     1. Once SACL's revision value becomes to ACL_REVISION_DS, 
    //        currently, there is no way (manually or through any api) 
    //        to bring it back to ACL_REVISION (2). However, you can always
    //        set SACL's revision value from ACL_REVISION to ACL_REVISION_DS
    // 
    //     2. During dcpromo time, some objects (group 1) will get ACL_REVISION_DS, 
    //        while others (say group2 ) get ACL_REVISION.
    //
    //     Due to above 2 facts, protecting admin groups task will keep trying to 
    //     modify group1's security descriptor to set the SACL revision to
    //     ACL_REVISION, and always fails silently. Thus causes the Win2000 PDC to
    //     Windows NT4 BDC replication constantly.
    //
    // So the solution to this problem is to force every admin protected object
    // has ACL_REVISION_DS as the SACL revision. To filfull the job, simple modify
    // adminSDHolder should be enought.
    // 

    if (ACL_REVISION_DS == Sacl->AclRevision)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        MODIFYARG   ModifyArg;
        MODIFYRES   *pModifyRes = NULL;
        ATTRVAL     SecurityDescriptorVal;

        Sacl->AclRevision = ACL_REVISION_DS; 

        RtlZeroMemory(&ModifyArg, sizeof(MODIFYARG));
        ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
        ModifyArg.FirstMod.AttrInf.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
        ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
        ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &SecurityDescriptorVal;
        SecurityDescriptorVal.valLen = *ProtectedSecurityDescriptorLength;
        SecurityDescriptorVal.pVal = *ProtectedSecurityDescriptor;
        ModifyArg.FirstMod.pNextMod = NULL;
        InitCommarg(&(ModifyArg.CommArg));
        ModifyArg.pObject = pAdminSDHolderDN;
        ModifyArg.count = 1;

        dwErr = DirModifyEntry(&ModifyArg, &pModifyRes); 

        if (0 != dwErr)
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    

Error:
    if (pSystemContainerDN) {
        THFreeEx(pTHS,pSystemContainerDN);
    }
    if (pAdminSDHolderDN) {
        THFreeEx(pTHS,pAdminSDHolderDN);
    }

    return(Status);
        
}




VOID
SampBuildNT4FullSid(
    IN NT4SID * DomainSid,
    IN ULONG    Rid,
    IN NT4SID * AccountSid
    )
{
    RtlCopyMemory(AccountSid,DomainSid,RtlLengthSid((PSID) DomainSid));
    (*(RtlSubAuthorityCountSid((PSID) AccountSid)))++;
     *(RtlSubAuthoritySid(
            (PSID) AccountSid,
            *RtlSubAuthorityCountSid((PSID)AccountSid)-1
             )) = Rid;
}


VOID
SampCheckAuditing(
    OUT BOOLEAN *fAuditingEnabled
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    POLICY_AUDIT_EVENTS_INFO    *pPolicy = NULL;

    // 
    // init return value
    //
    *fAuditingEnabled = FALSE;

    NtStatus = LsaIQueryInformationPolicyTrusted(
                    PolicyAuditEventsInformation,
                    (PLSAPR_POLICY_INFORMATION *) &pPolicy
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        // Failed to query audit information, 
        // continue without auditing turned on.
        return;
    }

    if ( pPolicy->AuditingMode &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement] &
                    POLICY_AUDIT_EVENT_SUCCESS) 
       ) 
    {
        *fAuditingEnabled = TRUE;
    }

    LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAuditEventsInformation,
                                      (PLSAPR_POLICY_INFORMATION) pPolicy);
    
    return;
}




NTSTATUS
SampUpdateSecurityDescriptor(
    DSNAME * pObject,
    PVOID    ProtectedSecurityDescriptor,
    ULONG    ProtectedSecurityDescriptorLength, 
    PUNICODE_STRING pAccountName, 
    PBOOLEAN    fSecurityDescriptorChanged
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    MODIFYARG   ModifyArg;
    ATTRMODLIST NextMod;
    ATTRVAL     SecurityDescriptorVal;
    ATTRVAL     AdminCountVal;
    ULONG       AdminCount=1;
    MODIFYRES   *pModifyRes=NULL;
    DWORD       err=0;

    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    ENTINFSEL   EntInf;
    PVOID       OldSD = NULL;
    ULONG       OldSDLength = 0;
    ULONG       i = 0;
    ATTR        Attr[2];

    // init return value

    *fSecurityDescriptorChanged = FALSE;
    RtlInitUnicodeString(pAccountName, NULL);

    //
    // Inialize the ReadArg
    // 
    RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    RtlZeroMemory(Attr, sizeof(ATTR) * 2);
    Attr[0].attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    Attr[1].attrTyp = ATT_SAM_ACCOUNT_NAME;

    EntInf.AttrTypBlock.attrCount = 2;
    EntInf.AttrTypBlock.pAttr = Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = pObject;

    InitCommarg(&(ReadArg.CommArg));

    //
    // Read this object's security descriptor
    // 
    err = DirRead(&ReadArg, &pReadRes);

    if (0!=err)
    {
        THClearErrors();
        return( STATUS_UNSUCCESSFUL );
    }

    //
    // It is not correct to assert as follows. All objects have SD's but not all
    // objects have sam account names -- specific examples are FPO's and non 
    // security principals that could be members of groups. The code below handles
    // the absence of these attributes. 
    //

    //Assert(2 == pReadRes->entry.AttrBlock.attrCount);

    for (i = 0; i < pReadRes->entry.AttrBlock.attrCount; i++)
    {
        if (ATT_NT_SECURITY_DESCRIPTOR == pReadRes->entry.AttrBlock.pAttr[i].attrTyp)
        {
            OldSDLength = pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].valLen;
            OldSD = pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
        }
        else if (ATT_SAM_ACCOUNT_NAME == pReadRes->entry.AttrBlock.pAttr[i].attrTyp)
        {
            pAccountName->Length = (USHORT) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].valLen;
            pAccountName->Buffer = (PWSTR) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
            pAccountName->MaximumLength = pAccountName->Length;
        }
        else
        {
            Assert(FALSE && "DirRead returns wrong Attribute\n");
        }
    }

    //
    // check whether the old security descriptor is the same value as
    // the one we are trying to set. If so, return success. 
    // By doing this optimization, we can reduce the Win2000 to NT4 
    // backup domain controller's replication overhead.
    // 

    if ((OldSDLength == ProtectedSecurityDescriptorLength) && 
        (RtlCompareMemory(OldSD, ProtectedSecurityDescriptor, OldSDLength) == 
         OldSDLength))
    {
        return( STATUS_SUCCESS );
    }
    
    //
    // Intialize the ModifyArg
    //
    
    RtlZeroMemory(&ModifyArg,sizeof(MODIFYARG));
    RtlZeroMemory(&NextMod,sizeof(ATTRMODLIST));
    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &SecurityDescriptorVal;
    SecurityDescriptorVal.valLen = ProtectedSecurityDescriptorLength;
    SecurityDescriptorVal.pVal = ProtectedSecurityDescriptor;
    AdminCountVal.valLen = sizeof(ULONG);
    AdminCountVal.pVal = (PUCHAR)&AdminCount;
    NextMod.choice =  AT_CHOICE_REPLACE_ATT;
    NextMod.AttrInf.attrTyp = ATT_ADMIN_COUNT;
    NextMod.AttrInf.AttrVal.valCount = 1;
    NextMod.AttrInf.AttrVal.pAVal = &AdminCountVal;
    ModifyArg.FirstMod.pNextMod = &NextMod;
    InitCommarg(&(ModifyArg.CommArg));
    ModifyArg.pObject = pObject;
    ModifyArg.count = 2;

    //
    // Write the new security descriptor and admin count. 
    //
    err = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (0!=err)
    {
        THClearErrors();
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        *fSecurityDescriptorChanged = TRUE;
    }

    return (Status);
}




NTSTATUS
SampSearchWellKnownAccounts(
    IN THSTATE * pTHS,
    IN BOOLEAN fBuiltinDomain,
    OUT SEARCHRES *pSearchRes 
    )
/*++
Routine Description

    This routine searches all well known accounts within a given domain. 
    Caller needs to indicate which domain to search. 

    Well Known Accounts - RID in range of 0 ~ 999
    
Parameters

    pTHS - thread state

    fBuiltinDomain - indicate which domain to search
    
    pSearchRes - return search result 

Return Values

    STATUS_SUCCESS
    Other Error Codes

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DSNAME      *BuiltinDomainDsName = NULL;
    ULONG       BuiltinDomainSid[] = {0x101,0x05000000,0x20};
    NT4SID      StartingSid;
    NT4SID      EndingSid;
    FILTER      Filter;
    COMMARG     * pCommArg = NULL;
    SEARCHARG   SearchArg;
    ENTINFSEL   EntInfSel;
    ATTR        AttrToRead;


    __try
    {

        //
        // Begin a transaction
        //

        DBOpen(&pTHS->pDB);


        //
        // init local varible
        // 

        if (fBuiltinDomain)
        {
            ULONG Size = 0;

            // BuiltinDomain object DSNAME
            Size = DSNameSizeFromLen( 0 ); 
            BuiltinDomainDsName = (DSNAME *) THAllocEx(pTHS, Size);
            BuiltinDomainDsName->structLen = Size; 
            BuiltinDomainDsName->SidLen = RtlLengthSid( (PSID) &BuiltinDomainSid);
            RtlCopySid(sizeof(BuiltinDomainDsName->Sid),
                       (PSID) &BuiltinDomainDsName->Sid, 
                       (PSID) &BuiltinDomainSid
                       );

            // build SID range based on builtin domain SID
            SampBuildNT4FullSid(&BuiltinDomainDsName->Sid, 0, &StartingSid);
            SampBuildNT4FullSid(&BuiltinDomainDsName->Sid, 999, &EndingSid); 
        }
        else
        {
            // build SID range based on current host account domain SID
            SampBuildNT4FullSid(&gAnchor.pDomainDN->Sid, 0, &StartingSid);
            SampBuildNT4FullSid(&gAnchor.pDomainDN->Sid, 999, &EndingSid);
        }


        //
        // set search index range, DomainSID + RID (0 to 999)
        // 

        NtStatus = SampSetIndexRanges(
                        SAM_SEARCH_SID,             // index type to use
                        RtlLengthSid(&StartingSid),
                        &StartingSid,
                        0,
                        NULL,
                        RtlLengthSid(&EndingSid),
                        &EndingSid,
                        0,
                        NULL,
                        (fBuiltinDomain ? FALSE : TRUE) // RootOfSearchIsNcHead 
                        );

        if ( !NT_SUCCESS(NtStatus) )
        {
            __leave;
        }


        //
        // build a Filter. this filter is very simple because we will mainly 
        // use SID index range to search 
        // 

        RtlZeroMemory(&Filter, sizeof(Filter));
        Filter.choice = FILTER_CHOICE_ITEM;
        Filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;
        Filter.pNextFilter = NULL;


        //
        // build attributes list to read (Group Type)
        //

        RtlZeroMemory(&AttrToRead, sizeof(AttrToRead));
        AttrToRead.attrTyp = ATT_GROUP_TYPE;
        AttrToRead.AttrVal.valCount = 0;
        AttrToRead.AttrVal.pAVal = NULL;

        RtlZeroMemory(&EntInfSel, sizeof(EntInfSel));
        EntInfSel.attSel = EN_ATTSET_LIST;
        EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
        EntInfSel.AttrTypBlock.attrCount = 1;
        EntInfSel.AttrTypBlock.pAttr = &AttrToRead;


        //
        // Build the SearchArg Structure
        // 

        RtlZeroMemory(&SearchArg, sizeof(SEARCHARG));
        if (fBuiltinDomain)
        {
            SearchArg.pObject = BuiltinDomainDsName;
        }
        else
        {
            SearchArg.pObject = gAnchor.pDomainDN;
        }
        SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
        SearchArg.bOneNC = TRUE;    // do not cross NC boundaries
        SearchArg.pFilter = &Filter;
        SearchArg.searchAliases = FALSE;    
        SearchArg.pSelection = &EntInfSel;
        SearchArg.pSelectionRange = NULL;


        //
        // Build the CommArg structure
        // 

        pCommArg = &(SearchArg.CommArg);
        InitCommarg( pCommArg );

        //
        // call DS search routine
        // 

        SearchBody(pTHS, &SearchArg, pSearchRes, 0);

        if (0 != pTHS->errCode)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

    }
    __finally
    {
        //
        // Commit the transaction, but keep the thread state
        //

        if (NULL!=pTHS->pDB)
        {        
            DBClose(pTHS->pDB,TRUE);
        }
    }


    return (NtStatus);
    
}






NTSTATUS
SampProtectAdministratorsList()
/*++

    Routine Description

    This routine  is the main loop for a back ground task that
    protects the members in any of the 4 pre defined administrative
    groups.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    NT4SID  EnterpriseAdminsSid;
    NT4SID  SchemaAdminsSid;
    PSID    SidsToLookup[2];
    PDSNAME * EnterpriseAndSchemaAdminsDsNames = NULL;
    PDSNAME * rpMembers = NULL;
    ULONG   CountOfMembers;
    PVOID   ProtectedSecurityDescriptor = NULL;
    ULONG   ProtectedSecurityDescriptorLength = 0;
    ULONG   i;
    ULONG   err=0;
    THSTATE * pTHS= pTHStls;
    DOMAIN_SERVER_ROLE ServerRole;
    UNICODE_STRING  DomainName;
    UNICODE_STRING  AccountName;
    BOOLEAN AuditingEnabled = FALSE;
    BOOLEAN fAdministratorsSecurityDescriptorChanged = FALSE;

    SEARCHRES   BuiltinDomainSearchRes;
    SEARCHRES   AccountDomainSearchRes;

    ULONG   CountOfBuiltinLocalGroups;
    ULONG   CountOfDomainLocalGroups;
    ULONG   CountOfDomainGlobalGroups;
    ULONG   CountOfDomainUniversalGroups;
    ULONG   CountOfDomainUsers;
    ULONG   CountOfExclusiveGroups;
    PDSNAME *BuiltinLocalGroups = NULL;
    PDSNAME *DomainLocalGroups = NULL;
    PDSNAME *DomainGlobalGroups = NULL;
    PDSNAME *DomainUniversalGroups = NULL;
    PDSNAME *DomainUsers = NULL;
    PDSNAME *ExclusiveGroups = NULL;

   

    __try
    {

        //
        // Are we the PDC ? ( Querying SAM is faster than
        // reading the DS as SAM keeps this cached in memory )
        //

        Status = SamIQueryServerRole2(
                    (PSID) &gAnchor.pDomainDN->Sid,
                    &ServerRole
                    );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        if (DomainServerRolePrimary!=ServerRole)
        {
            __leave;
        }

        //
        // Intialize
        //
        RtlInitUnicodeString(&DomainName, gAnchor.pDomainDN->StringName);


        //
        // Set fDSA in the thread state
        //

        pTHS->fDSA = TRUE;

        //
        // Build the SIDs/DSNames for administrative groups 
        //

    
        //
        // 1. Enterprise Admins
        //

        SampBuildNT4FullSid(
                    &gAnchor.pRootDomainDN->Sid,
                    DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    &EnterpriseAdminsSid
                    );

        //
        // 2. Schema Admins
        //

        SampBuildNT4FullSid(
                    &gAnchor.pRootDomainDN->Sid,
                    DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    &SchemaAdminsSid
                    );

        SidsToLookup[0] = &EnterpriseAdminsSid;
        SidsToLookup[1] = &SchemaAdminsSid;

        //
        // SID positioning in the core DS works only if the SID specified an object
        // in the same naming context as the domain that the DC is authoritative for.
        // This is not necessarily true for enterprise admins / schema admins. Therefore lookup the
        // GUID/ DSName on the G.C. A future performance optimization is do this lookup
        // just once after the boot and persist the guid.
        //

        err = SampVerifySids(
                    2,
                    (PSID *) SidsToLookup,
                    &EnterpriseAndSchemaAdminsDsNames
                    );

        if ((0 != err) || 
            (NULL == EnterpriseAndSchemaAdminsDsNames[0]) ||
            (NULL == EnterpriseAndSchemaAdminsDsNames[1]) )
        {
            __leave;
        }


        //
        // search all wellknown accounts in builtin domain 
        //

        RtlZeroMemory(&BuiltinDomainSearchRes, sizeof(BuiltinDomainSearchRes));
        Status = SampSearchWellKnownAccounts(
                    pTHS, 
                    TRUE,   // Search Builtin Domain
                    &BuiltinDomainSearchRes
                    );
        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // search all wellknown accounts in account domain 
        //

        RtlZeroMemory(&AccountDomainSearchRes, sizeof(AccountDomainSearchRes)); 
        Status = SampSearchWellKnownAccounts(
                    pTHS, 
                    FALSE,  // Search Account Domain
                    &AccountDomainSearchRes
                    );
        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // filter and group all wellknown accounts to four categories
        // 1. builtin local groups 
        // 2. account domain local groups
        // 3. account domain global groups
        // 4. account domain universal groups
        // 5. account domain users  
        //

        Status = SampFilterWellKnownAccounts(
                    pTHS,
                    &BuiltinDomainSearchRes,
                    &AccountDomainSearchRes,
                    &CountOfBuiltinLocalGroups,
                    &BuiltinLocalGroups,
                    &CountOfDomainLocalGroups,
                    &DomainLocalGroups,
                    &CountOfDomainGlobalGroups,
                    &DomainGlobalGroups,
                    &CountOfDomainUniversalGroups,
                    &DomainUniversalGroups,
                    &CountOfDomainUsers,
                    &DomainUsers,
                    &CountOfExclusiveGroups,
                    &ExclusiveGroups
                    );
        if (!NT_SUCCESS(Status))
        {
            __leave;
        }



        //
        // Get the list of DS Names, Directly or transitively a member
        // of this list
        //


        Status = SampBuildAdministratorsSet(
                    pTHS,
                    CountOfBuiltinLocalGroups,
                    BuiltinLocalGroups,
                    CountOfDomainLocalGroups,
                    DomainLocalGroups,
                    CountOfDomainGlobalGroups,
                    DomainGlobalGroups,
                    CountOfDomainUniversalGroups,
                    DomainUniversalGroups,
                    EnterpriseAndSchemaAdminsDsNames[0], // enterprise admins
                    EnterpriseAndSchemaAdminsDsNames[1], // schema admins
                    &CountOfMembers,
                    &rpMembers
                    );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }

        //
        // Retrieve the security Descriptor that will be used for
        // protecting the admin accounts
        //
      

        Status = SampReadAdminSecurityDescriptor(
                    &ProtectedSecurityDescriptor,
                    &ProtectedSecurityDescriptorLength
                    );
        if (!NT_SUCCESS(Status))
        {
            __leave;
        }

        //
        // check whether Account Management Auditing is enabled or not.
        // 

        SampCheckAuditing(&AuditingEnabled);
                   
        //
        // The list is now ready, walk through and update the ACL
        //           

        for (i=0;i<CountOfMembers;i++)
        {
            
            NT4SID      DomainSid;
            ULONG       Rid;
            BOOLEAN     fSecurityDescriptorChanged = FALSE;

            //
            // We do not have to write anything if the member is not in the
            // same domain as this DC is authoritative for. If we are not
            // authoritative for this domain then skip.
            //

            if (0==rpMembers[i]->SidLen)
            {
                //
                // Do not need to touch non security principals
                //

                continue ;
            }

            SampSplitNT4SID(&rpMembers[i]->Sid,&DomainSid,&Rid);
            


            if (!RtlEqualSid((PSID) &DomainSid, &gAnchor.pDomainDN->Sid))
            {
                //
                // Not from our domain, skip and try the next entry
                //

                continue;
            }

            Status = SampUpdateSecurityDescriptor(
                        rpMembers[i],
                        ProtectedSecurityDescriptor,
                        ProtectedSecurityDescriptorLength,
                        &AccountName, 
                        &fSecurityDescriptorChanged
                        );

            if (NT_SUCCESS(Status) && !fSecurityDescriptorChanged)
            {
                //
                // this account's security descriptor has not been changed 
                // 
                continue;
            }

            //
            // EventLog the ACL reset
            // 

            if (AuditingEnabled)
            {
                LsaIAuditSamEvent(
                    Status,                         // Passed Status 
                    SE_AUDITID_SECURE_ADMIN_GROUP,  // Audit ID 
                    &DomainSid,                     // Domain SID 
                    NULL,                           // Aditional Info 
                    NULL,                           // Member Rid (not used) 
                    NULL,                           // Member Sid (not used) 
                    &AccountName,                   // Account Name 
                    &DomainName,                    // Domain Name 
                    &Rid,                           // Account Rid 
                    NULL,                           // privileges
                    NULL                            // extended info
                    );
            }

            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_SUCCESS;
                continue;
            }     
          
        }

        //
        // Protect all Builtin Local Groups
        //

        for (i = 0; i < CountOfBuiltinLocalGroups; i++)
        {
            BOOLEAN     fSecurityDescriptorChanged = FALSE;

            Status = SampUpdateSecurityDescriptor(
                        BuiltinLocalGroups[i],
                        ProtectedSecurityDescriptor,
                        ProtectedSecurityDescriptorLength,
                        &AccountName, 
                        &fSecurityDescriptorChanged
                        );
        }

        //
        // Protect all well known Account Domain Users 
        //
        for (i = 0; i < CountOfDomainUsers; i++)
        {
            BOOLEAN     fSecurityDescriptorChanged = FALSE;

            Status = SampUpdateSecurityDescriptor(
                        DomainUsers[i],
                        ProtectedSecurityDescriptor,
                        ProtectedSecurityDescriptorLength,
                        &AccountName, 
                        &fSecurityDescriptorChanged
                        );
        }

        //
        // Protect all exclusive groups
        // 
        for (i = 0; i < CountOfExclusiveGroups; i++)
        {
            BOOLEAN     fSecurityDescriptorChanged = FALSE;

            Status = SampUpdateSecurityDescriptor(
                        ExclusiveGroups[i],
                        ProtectedSecurityDescriptor,
                        ProtectedSecurityDescriptorLength,
                        &AccountName, 
                        &fSecurityDescriptorChanged
                        );
        }



    }
    __finally
    {

       
    }

    return(Status);
    
}

VOID
ProtectAdminGroups(
    VOID *  pV,
    VOID ** ppVNext,
    DWORD * pcSecsUntilNextIteration
    )
{

    __try {

        SampProtectAdministratorsList();

    } __finally {
        // Execute every hour
        *pcSecsUntilNextIteration = 3600;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\scchk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scchk.c
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------
//
// Abstract:
//
//   Contains the routines for validating Schema Updates
//
//
// Author:
//
//    Rajivendra Nath (RajNath) 4/7/1997
//
// Revision History:
//
//-----------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <prefix.h>         
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>           // HandleMostExceptions

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>

#include <filtypes.h>           // For FILTER_CHOICE_??? and
                                // FI_CHOICE_???
#include <dsconfig.h>
#include "permit.h"

#include <dsutil.h>

#include "debug.h"              // standard debugging header
#define DEBSUB "SCCHK:"                // define the subsystem for debugging

// DRA headers
#include "drautil.h"
#include "drameta.h"

#include <samsrvp.h>

#include "drserr.h"


#include <fileno.h>
#define  FILENO FILENO_SCCHK

#include <schash.c>  // for hash function definitions


// Known syntax-om_syntax pairs from schema.ini

Syntax_Pair KnownSyntaxPair[] =
{
 {SYNTAX_DISTNAME_TYPE,               OM_S_OBJECT},
 {SYNTAX_OBJECT_ID_TYPE,              OM_S_OBJECT_IDENTIFIER_STRING},
 {SYNTAX_CASE_STRING_TYPE,            OM_S_GENERAL_STRING},
 {SYNTAX_NOCASE_STRING_TYPE,          OM_S_TELETEX_STRING},
 {SYNTAX_PRINT_CASE_STRING_TYPE,      OM_S_IA5_STRING},
 {SYNTAX_PRINT_CASE_STRING_TYPE,      OM_S_PRINTABLE_STRING},
 {SYNTAX_NUMERIC_STRING_TYPE,         OM_S_NUMERIC_STRING},
 {SYNTAX_DISTNAME_BINARY_TYPE,        OM_S_OBJECT},
 {SYNTAX_BOOLEAN_TYPE,                OM_S_BOOLEAN},
 {SYNTAX_INTEGER_TYPE,                OM_S_INTEGER},
 {SYNTAX_INTEGER_TYPE,                OM_S_ENUMERATION},
 {SYNTAX_OCTET_STRING_TYPE,           OM_S_OBJECT},
 {SYNTAX_OCTET_STRING_TYPE,           OM_S_OCTET_STRING},
 {SYNTAX_TIME_TYPE,                   OM_S_UTC_TIME_STRING},
 {SYNTAX_TIME_TYPE,                   OM_S_GENERALISED_TIME_STRING},
 {SYNTAX_UNICODE_TYPE,                OM_S_UNICODE_STRING},
 {SYNTAX_ADDRESS_TYPE,                OM_S_OBJECT},
 {SYNTAX_DISTNAME_STRING_TYPE,        OM_S_OBJECT},
 {SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, OM_S_OBJECT_SECURITY_DESCRIPTOR},
 {SYNTAX_I8_TYPE,                     OM_S_I8},
 {SYNTAX_SID_TYPE,                    OM_S_OCTET_STRING},
};

ULONG SyntaxPairTableLength = sizeof(KnownSyntaxPair)/sizeof(KnownSyntaxPair[0]);

// Helper function from mdupdate.c
extern  BOOL IsMember(ATTRTYP aType, 
                      int arrayCount, 
                      ATTRTYP *pAttArray);

// class closing function from scache.c
extern  int scCloseClass(THSTATE *pTHS,
                         CLASSCACHE *pCC);


// Logging functions in case a schema conflict is detected between
// an exisiting object and a replicated-in schema object

#define CURRENT_VERSION 1

// defines to distinguish if a classcache or an attcache is passed to common
// conflict handling routines

#define PTR_TYPE_ATTCACHE   0
#define PTR_TYPE_CLASSCACHE 1

VOID
LogConflict(
    THSTATE *pTHS,
    VOID *pConflictingCache,
    char *pConflictingWith,
    MessageId midEvent,
    ULONG version,
    DWORD WinErr
);

int
ValidateSchemaAtt
(
    THSTATE *pTHS,
    ATTCACHE* ac        
);

int
AutoLinkId
(
    THSTATE *pTHS,
    ATTCACHE* ac,
    ULONG acDnt
);


int
ValidateSchemaCls
(
    THSTATE *pTHS,
    CLASSCACHE* cc
);

int
DRAValidateSchemaAtt
(
    THSTATE *pTHS,
    ATTCACHE* ac        
);


int
DRAValidateSchemaCls
(
    THSTATE *pTHS,
    CLASSCACHE* cc
);

int
ValidAttAddOp
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


int
ValidAttModOp
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


int
ValidAttDelOp
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
InvalidClsOrAttLdapDisplayName
(
    UCHAR *name,
    ULONG nameLen
);

BOOL
DupAttRdn
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


BOOL
DupAttOid
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


BOOL
DupAttMapiid
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
DupAttLinkid
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
InvalidBackLinkAtt
(
    THSTATE *pTHS,
    ATTCACHE* ac
);   

BOOL
InvalidLinkAttSyntax
(
    THSTATE *pTHS,
    ATTCACHE* ac
);

BOOL
DupAttLdapDisplayName
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
DupAttSchemaGuidId
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


BOOL
SemanticAttTest
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
SyntaxMatchTest
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
OmObjClassTest
(
    ATTCACHE* ac 
);

BOOL
SearchFlagTest
(
    ATTCACHE* ac
);

BOOL
GCReplicationTest
(
    ATTCACHE* ac
);

BOOL
AttInMustHave
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
AttInRdnAttId(
    IN THSTATE  *pTHS,
    IN ATTCACHE *pAC
);

BOOL
AttInMayHave
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);



int
ValidClsAddOp
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


int
ValidClsModOp
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


int
ValidClsDelOp
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
DupClsRdn
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
DupClsOid
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
DupClsLdapDisplayName
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
DupClsSchemaGuidId
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsMayHaveExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsMustHaveExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsAuxClassExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsPossSupExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsSubClassExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
ClsMayMustPossSafeModifyTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc
);

BOOL
RdnAttIdSyntaxTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
IsRdnSyntaxTest(
    THSTATE *pTHS,
    ATTCACHE* ac
);

BOOL
ClsInPossSuperior
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsInSubClassOf
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsInAuxClass
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);



//-----------------------------------------------------------------------
//
// Function Name:            ValidSchemaUpdate
//
// Routine Description:
//
//    Checks to see if the Schema Update is Valid 
//
// Author: RajNath  
// Date  : [4/7/1997]
// 
// Arguments:
//
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidSchemaUpdate()
{
    THSTATE *pTHS=pTHStls;
    int err;
    SCHEMAPTR* oldptr=pTHS->CurrSchemaPtr;

    if ( DsaIsInstalling() ) {
      // installing
      return (0);
    }

#ifdef INCLUDE_UNIT_TESTS
{
    extern DWORD dwUnitTestSchema;
    if (dwUnitTestSchema == 1) {
        SCFreeClasscache((CLASSCACHE **)&pTHS->pClassPtr);
        return 0;
    }
}
#endif INCLUDE_UNIT_TESTS
    
    _try
    {
    
        switch (pTHS->SchemaUpdate)
        {
            case eSchemaClsAdd:
            case eSchemaClsMod:
            case eSchemaClsDel:
            {
                CLASSCACHE* cc = NULL;

                err = SCBuildCCEntry ( NULL,&cc); //creates a new ClassCache
                if (err)
                {
                    DPRINT1(0,"NTDS ValidSchemaUpdate: Failed. Error%d\n",err);
                    // THSTATE error code is already set in SCBuildCCEntry
                    Assert(pTHS->errCode);
                    __leave;
                }

                // Since there is no error, must have a classcache.
                // (Even in the delete case, since it is positioned on 
                // the deleted object)
                Assert(cc);

                if (pTHS->fDRA) {
                    // Do a limited set of checks against the existing schema cache
                    // to see that this will not cause any inconsistencies
                    err = DRAValidateSchemaCls(pTHS, cc);
                    if (err) {
                       DPRINT1(0,"NTDS DRAValidateSchemaClass: Failed. Error %d\n",err);

                       // Already logged
                       // Set special error code and thread state flag
                       pTHS->fSchemaConflict = TRUE;
                       err = ERROR_DS_DRA_SCHEMA_CONFLICT;
                       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     err, err);
                    }
                    else {
                       // Even if there is no error, fail if the thread state
                       // indicates a conflict happened for this packet 
                       // earlier, so that we don't commit change
                       if (pTHS->fSchemaConflict) {
                           err = ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT;
                           SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                         err, err);
                        }
                    }
 
                    SCFreeClasscache(&cc);
                    __leave;
                }
                // Otherwise (originating write), build validation cache and test
                err = RecalcSchema(pTHS);
                if (err)
                {
                    SCFreeClasscache(&cc);
                    DPRINT1(0,"RecalcSchema() Error %08x\n", err);
                    // Use the pTHS->pErrInfo returned by RecalcSchema 
                    // because it may be more informative than "unwilling
                    // to perform" (couldn't be worse!). Unfortunately, the
                    // functions called by RecalSchema don't always return
                    // pErrInfo and so we are stuck with "unwilling to
                    // perform" in some cases.
                    if (err != (int)pTHS->errCode || !pTHS->pErrInfo) {
                        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                      ERROR_DS_RECALCSCHEMA_FAILED,err); 
                    }
                    __leave;
                }

                err = ValidateSchemaCls(pTHS, cc);
                if (err)
                {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_MINIMAL,
                            DIRLOG_SCHEMA_VALIDATION_FAILED, 
                            szInsertSz(cc->name),
                            szInsertUL(err),
                            szInsertWin32Msg(err));
                    
                    SCFreeClasscache(&cc);
                    SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
                    DPRINT1(0,"NTDS ValidateSchemaClass: Failed. Error %d\n",err);

                    // err is a dir-error

                    SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                  err, err);
                    __leave;
                }
    
                SCFreeClasscache(&cc);
                SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
    
            }
            break;

    
            case eSchemaAttAdd:
            case eSchemaAttMod:
            case eSchemaAttDel:
            case eSchemaAttUndefunct:
            {
    
                ATTCACHE* ac = NULL;
                ULONG acDnt = pTHS->pDB->DNT; // for AutoLinkId


                err = SCBuildACEntry ( NULL,&ac); //creates a new AttrCache
                if (err)
                {
                    DPRINT1(0, "NTDS ValidSchemaUpdate: Failed. Error %d\n",err);
                    // THSTATE error code is already set in SCBuildCCEntry
                    Assert(pTHS->errCode);
                    __leave;
                }
                // Since there is no error, must have an attcache
                // (Even in the delete case, since it is positioned on 
                // the deleted object)
                Assert(ac);
    
                if (pTHS->fDRA) {
                    // Do a limited set of checks against the existing schema cache
                    // to see that this will not cause any inconsistencies
                    err = DRAValidateSchemaAtt(pTHS, ac);
                    if (err) {
                       DPRINT1(0,"NTDS DRAValidateSchemaAtt: Failed. Error %d\n",err);

                       // Already logged
                       // Set special error code and thread state flag
                       pTHS->fSchemaConflict = TRUE;
                       err = ERROR_DS_DRA_SCHEMA_CONFLICT;
                       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     err, err);
                    }
                    else {
                       // Even if there is no error, fail if the thread state
                       // indicates a conflict happened for this packet
                       // earlier, so that we don't commit change
                       if (pTHS->fSchemaConflict) {
                           err = ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT;
                           SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                         err, err);
                        }
                    }
                    SCFreeAttcache(&ac);
                    __leave;
                }
                // Otherwise (originating write), build validation cache and test
                err = RecalcSchema(pTHS);
                if (err)
                {
                    SCFreeAttcache(&ac);
                    DPRINT1(0,"RecalcSchema() Error %08x\n", err);
                    // Use the pTHS->pErrInfo returned by RecalcSchema 
                    // because it may be more informative than "unwilling
                    // to perform" (couldn't be worse!). Unfortunately, the
                    // functions called by RecalSchema don't always return
                    // pErrInfo and so we are stuck with "unwilling to
                    // perform" in some cases.
                    if (err != (int)pTHS->errCode || !pTHS->pErrInfo) {
                        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                      ERROR_DS_RECALCSCHEMA_FAILED, err);
                    }
                    __leave;
                }

                // If needed, automatically generate a linkid
                err = AutoLinkId(pTHS, ac, acDnt);
                if (err) {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_MINIMAL,
                            DIRLOG_AUTO_LINK_ID_FAILED,
                            szInsertSz(ac->name), szInsertInt(err), szInsertThStateErrMsg());
                    DPRINT2(0,"NTDS AutoLinkId(%s): Error %08x\n", ac->name, err);
                    SCFreeAttcache(&ac);
                    SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
                    // AutoLinkId called SetSvcErrorEx
                    Assert(pTHS->errCode);
                    __leave;
                }
                err = ValidateSchemaAtt(pTHS, ac);
                if (err)
                {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_MINIMAL,
                            DIRLOG_SCHEMA_VALIDATION_FAILED,
                            szInsertSz(ac->name),
                            szInsertUL(err),
                            szInsertWin32Msg(err));

                    SCFreeAttcache(&ac);
                    SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
                    DPRINT1(0,"NTDS ValidateSchemaAtt: Failed. Error %d\n",err);

                    // err is a dir-error
                    SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                  err, err); 
                    __leave;
                }
    
               
                SCFreeAttcache(&ac);
                SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
            }
            break;
    
        }
    }__finally
    {
        pTHS->CurrSchemaPtr=oldptr;

        // free pTHS->pClassPtr if there. This is malloc'ed memory
        SCFreeClasscache((CLASSCACHE **)&pTHS->pClassPtr);
    }

    Assert(err == 0 || pTHS->errCode != 0);
    return err;

} // End ValidSchemaUpdate

int
ValidateSchemaAtt(
    THSTATE *pTHS,
    ATTCACHE* ac    
    )
/*++

Routine Description:

    Verify that the altered schema attribute, ac, is valid and consistent
    with respect to the current schema in the database.
    
Arguments:

    pTHS - thread state that addresses a private schema cache built
           by RecalcSchema. The private schema cache includes the
           uncommitted changes (add/mod/del) for ac.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the attribute from the database
           or by reading the contents prior to an uncommitted delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    int err=0;
    ATTCACHE* pac;

    //
    // Get the attribute in the private Schema Cache... (from RecalcSchema)
    //
    pac = SCGetAttById(pTHS, ac->id);

    switch (pTHS->SchemaUpdate)
    {
        case eSchemaAttAdd:
        case eSchemaAttUndefunct:
        {
            if (pac) {
                return ValidAttAddOp(pTHS, pac);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaAttMod:
        {
            if (pac) {
                return ValidAttModOp(pTHS, pac);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaAttDel:
        {
            // pac will be NULL because we just deleted the attrib.
            return ValidAttDelOp(pTHS, ac);
        }
        break;

    }


    return err;
} // End ValidateSchemaAtt

int
AutoLinkId(
    THSTATE     *pTHS,
    ATTCACHE    *ac,
    ULONG       acDnt
    )
/*++
Routine Description:
    Caveats: Runs in the current transaction.
             Resets currency.

    Automatically generate a linkid when the user specifies a special,
    reserved linkid value.  The only interoperability issue with existing
    schemas is that a user cannot define a backlink for an existing
    forward link whose id is RESERVED_AUTO_LINK_ID. Considered not a problem
    because 1) microsoft has not allocated linkid -2 to anyone and
    2) practically and by convention, forward links and back links
    are created at the same time. If a user did generate this unsupported
    config, then the user must create a new link/backlink pair and fix
    up the affected objects.

    The ldap head cooperates in this venture by translating the ldapDisplayName
    or OID for a LinkId attribute into the corresponding schema cache entry
    and:
         1) If the schema cache entry is for ATT_LINK_ID, then the caller's
         linkid is set to RESERVED_AUTO_LINK_ID. Later, underlying code
         automatically generates a linkid in the range
         MIN_RESERVED_AUTO_LINK_ID to MAX_RESERVED_AUTO_LINK_ID.

         2) If the schema cache entry is for a for an existing forward link,
         then the caller's linkid is set to the corresponding backlink value.

         3) Otherwise, the caller's linkid is set to RESERVED_AUTO_NO_LINK_ID
         and later, underlying code generates a ERROR_DS_BACKLINK_WITHOUT_LINK
         error.

    An error ERROR_DS_RESERVED_LINK_ID is returned if the user specifies
    linkid in the reserved range MIN... to MAX... The range reserves 1G-2
    linkids. Should be enough. At whistler, less than 200 linkids are in use.
    Existing schemas, or schemas modified on W2K DCs, may use linkids in
    this range without affecting the functionality except as noted above.
    
Arguments:
    pTHS - thread state that addresses a private schema cache built
           by RecalcSchema. The private schema cache includes the
           uncommitted changes (add/mod/del) for ac.

    ac   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the attribute from the database
           or by reading the contents prior to an uncommitted delete.

    acDnt - DNT from pTHS->pDB that was used to create ac

Return Values:
    0 on success.
    !0 otherwise.
--*/
{
    DWORD               dwErr, i;
    ATTCACHE            *pAC, *pACSearch;
    ULONG               ulLinkId, ulRange, ulBase;
    extern SCHEMAPTR    *CurrSchemaPtr;
    LONG                ATTCOUNT = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ATTCOUNT;
    HASHCACHE           *ahcLink = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcLink;

    // Replication should not be using this code path! Automatically
    // generating link ids is designed for originating adds. If this
    // has changed, then the design of AutoLinkIds should be reviewed.
    //
    // This function is expected to be called from ValidSchemaUpdate().
    // When replicating in schema changes, ValidSchemaUpdate() should be
    // using the code path that calls DRAValidateSchemaAtt() and not 
    // the code path that calls ValidateSchemaAtt().
    Assert(!pTHS->fDRA);

    // must be using a private schema cache (RecalcSchema)
    Assert(pTHS->CurrSchemaPtr != CurrSchemaPtr)

    // not a link or else not a forward link
    if (!FIsLink(ac->ulLinkID)) {
        return 0;
    }

    // Don't assign a linkid when deleting or modifying because we don't
    // want to alter an existing linkid even if the linkid is the special
    // RESERVED_AUTO_LINK_ID. It may exist in poorly behaved enterprises
    // because the value, RESERVED_AUTO_LINK_ID, was not reserved until
    // whistler.
    if (   pTHS->SchemaUpdate == eSchemaAttDel
        || pTHS->SchemaUpdate == eSchemaAttMod
        || pTHS->SchemaUpdate == eSchemaAttUndefunct)  {
        return 0;
    }

    // Check if the caller is trying to add a linkid that is within the
    // reserved range of automatically generated linkids (excluding
    // the special values RESERVED_AUTO_LINK_ID and RESERVED_AUTO_NO_LINK_ID
    // which are handled later).
    if (ac->ulLinkID >= MIN_RESERVED_AUTO_LINK_ID 
        && ac->ulLinkID <= MAX_RESERVED_AUTO_LINK_ID) {
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             ERROR_DS_RESERVED_LINK_ID, ERROR_DS_RESERVED_LINK_ID); 
    }
    
    // Don't assign a linkid because the linkid is not the special
    // "assign a linkid" value (RESERVED_AUTO_LINK_ID).
    if (ac->ulLinkID != RESERVED_AUTO_LINK_ID) {
        return 0;
    }

    // Locate the next available linkid in the reserved range.
    // Begin searching at a random linkid in the range to avoid scaling
    // problems when sequentially searching the range. Starting at the
    // currently allocated maximum linkid is not an option because
    // poorly behaved enterprises may have already created linkid
    // MAX_RESERVED_AUTO_LINK_ID, creating the illusion that all linkids
    // have been used.
    srand(GetTickCount());
    ulRange = MakeLinkBase(MAX_RESERVED_AUTO_LINK_ID - MIN_RESERVED_AUTO_LINK_ID);
    ulBase = MakeLinkBase((((rand() << 16) ^ rand()) % ulRange));
    for (i = 0; i < ulRange; ++i, ulBase = ++ulBase % ulRange) {
        pACSearch = SCGetAttByLinkId(pTHS, 
                                     MIN_RESERVED_AUTO_LINK_ID + MakeLinkId(ulBase));
        if (!pACSearch) {
            break;
        }
    }

    // no available linkids (all 1 billion - 3 are taken!)
    if (pACSearch) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY, 
                             ERROR_DS_LINK_ID_NOT_AVAILABLE, 
                             ERROR_DS_LINK_ID_NOT_AVAILABLE);
    }
    // Found an unused linkid. Adjust the cache's linkid hash.
    // Be careful to locate the entry for our pAC because there
    // may be duplicate entries for RESERVED_AUTO_LINK_ID.
    ulLinkId = MIN_RESERVED_AUTO_LINK_ID + MakeLinkId(ulBase);
    pAC = SCGetAttById(pTHS, ac->id);
    Assert(pAC);
    // remove from linkid hash
    for (i = SChash(RESERVED_AUTO_LINK_ID, ATTCOUNT);
         (ahcLink[i].pVal 
          && (ahcLink[i].pVal != FREE_ENTRY)
          && (ahcLink[i].hKey != RESERVED_AUTO_LINK_ID) 
          && (ahcLink[i].pVal != pAC));
         i = (i + 1) % ATTCOUNT);
    Assert(ahcLink[i].pVal == pAC);
    ahcLink[i].pVal = FREE_ENTRY;
    ahcLink[i].hKey = 0;

    // add to linkid hash w/auto-generated linkid
    for (i=SChash(ulLinkId, ATTCOUNT);
         ahcLink[i].pVal && (ahcLink[i].pVal != FREE_ENTRY);
         i=(i+1)%ATTCOUNT);
    Assert(!ahcLink[i].hKey);
    ahcLink[i].pVal = pAC;
    ahcLink[i].hKey = ulLinkId;

    // Update the private cache, the free-floating entry, and the database.
    pAC->ulLinkID = ulLinkId;
    ac->ulLinkID = ulLinkId;
    DBFindDNT(pTHS->pDB, acDnt);
    if (DBRemAtt(pTHS->pDB, ATT_LINK_ID) == DB_ERR_SYSERROR) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY,
                             ERROR_DS_DATABASE_ERROR, DB_ERR_SYSERROR);
    }
    if (   (dwErr = DBAddAtt(pTHS->pDB, ATT_LINK_ID, SYNTAX_INTEGER_TYPE))
        || (dwErr = DBAddAttVal(pTHS->pDB, ATT_LINK_ID,
                                sizeof(SYNTAX_INTEGER), &ulLinkId))) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_DATABASE_ERROR, dwErr);
    }
    DBUpdateRec(pTHS->pDB);

    return 0;
} // AutoLinkId

int
DRAValidateSchemaAtt(
    THSTATE *pTHS,
    ATTCACHE* ac    
    )
/*++

Routine Description:

    Verify that the altered, newly replicated-in schema attribute, ac, is
    valid and consistent with respect to the current schema cache. Only
    called if pTHS->fDRA is true.
    
Arguments:

    pTHS - thread state that addresses the current schema cache.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the attribute from the database.
           NULL if schema update is a delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    int err=0;
    ATTCACHE *pTempAC;
    CLASSCACHE *pTempCC;


    // No true deletes are allowed, but just in case some internal dumbo did 
    // this on replicated enterprise, check for it
    if ( !ac ) {
       // possible only for true deletes
       Assert(pTHS->SchemaUpdate==eSchemaAttDel);
       return 0;
    }
    
    // For any change, add/modify/defunct, following test should pass
    if (pTempCC = SCGetClassById(pTHS, ac->id)) {
        // exists a class with same IntId
        LogConflict(pTHS, pTempCC, ac->name, DIRLOG_SCHEMA_CLASS_CONFLICT,
                    CURRENT_VERSION, ERROR_DS_DUP_OID);
        return ERROR_DS_DUP_OID;
    }

    // Now switch on change type
    switch (pTHS->SchemaUpdate) {
        case eSchemaAttAdd:
        case eSchemaAttUndefunct:

            if (pTempAC = SCGetAttById(pTHS, ac->id)) {
                // exists an att with same internal id (msDS-IntId)
                err = ERROR_DS_DUP_OID;
                break;
            }
            if (pTempAC = SCGetAttByLinkId(pTHS, ac->ulLinkID)) {
                // exists an att with same linkID
                err = ERROR_DS_DUP_LINK_ID;
                break;
            }
            // Duplicate LDNs and MapiIDs are handled by defuncting
            // the colliding attributes during the schema cache
            // load. A user can choose a winner by setting the
            // loser's isDefunct to TRUE.
            break;
       case eSchemaAttMod:
            // Duplicate LDNs and MapiIDs are handled by defuncting
            // the colliding attributes during the schema cache
            // load. A user can choose a winner by setting the
            // loser's isDefunct to TRUE.
            break;
       case eSchemaAttDel:
            // This is currently making defunct. Nothing to check here
            break;
    } /* switch */                

    if (err) {
        // some error, doesn't matter what, there is a conflict
        Assert(pTempAC);
        LogConflict(pTHS, pTempAC, ac->name, DIRLOG_SCHEMA_ATT_CONFLICT,
                    CURRENT_VERSION, err);
        return err;
    }

    return 0;
} // End DRAValidateSchemaAtt

int
ValidateSchemaCls(
    THSTATE *pTHS,
    CLASSCACHE* cc
    )
/*++

Routine Description:

    Verify that the altered schema class, cc, is valid and consistent
    with respect to the current schema in the database.
    
Arguments:

    pTHS - thread state that addresses a private schema cache built
           by RecalcSchema. The private schema cache includes the
           uncommitted changes (add/mod/del) for cc.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the class from the database
           or by reading the contents prior to an uncommitted delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    DECLARESCHEMAPTR
    int err=0;
    DWORD i;
    CLASSCACHE* pcc;

    //
    // Locate the class in the private Schema Cache... (from RecalcSchema)
    //
    // Be careful because the ClassId is no longer unique! Locate the
    // class by objectGuid.
    for (i=SChash(cc->ClassId,CLSCOUNT); pcc = ahcClassAll[i].pVal; i=(i+1)%CLSCOUNT) {
        if (pcc == FREE_ENTRY) {
            continue;
        }
        if (!memcmp(&pcc->objectGuid, &cc->objectGuid, sizeof(cc->objectGuid))) {
            break;
        }
    }

    // Note that pcc is not closed, since we don't close the recalc cache
    // We will close pcc only if we need to use the inherited atts, currently
    // only in one place (ClsMayMustPossSafeModifyTest) during class modify

    switch (pTHS->SchemaUpdate)
    {
        case eSchemaClsAdd:
        {
            if (pcc) {
                return ValidClsAddOp(pTHS, pcc);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaClsMod:
        {
            if (pcc) {
                return ValidClsModOp(pTHS, pcc);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaClsDel:
        {
            // pcc will be null since we have deleted it...
            return ValidClsDelOp(pTHS, cc);
        }
        break;

    }


    return err;
} // End ValidateSchemaCls

int
DRAValidateSchemaCls(
    THSTATE *pTHS,
    CLASSCACHE* cc
    )
/*++

Routine Description:

    Verify that the altered, newly replicated-in schema class, cc, is valid
    and consistent with respect to the current schema cache. Only called
    if pTHS->fDRA is true.
    
Arguments:

    pTHS - thread state that addresses the current schema cache.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the class from the database.
           NULL if schema update is a delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    ATTCACHE *pTempAC;

    // No true deletes are allowed, but just in case some internal dumbo did
    // this on replicated enterprise, check for it
    if ( !cc ) {
       // possible only for true deletes
       Assert(pTHS->SchemaUpdate==eSchemaClsDel);
       return 0;
    }

    // For any change, add/modify/defunct, following test should pass

    if (pTempAC = SCGetAttById(pTHS, cc->ClassId)) {
        // exists an att with same internal id (msDS-IntId) as the governsId
        LogConflict(pTHS, pTempAC, cc->name, DIRLOG_SCHEMA_ATT_CONFLICT,
                    CURRENT_VERSION, ERROR_DS_DUP_OID);
        return ERROR_DS_DUP_OID;
    }

    // Duplicate governsIds and ldapDisplayNames are handled by
    // defuncting the colliding classes and attributes during the
    // schema cache load. A user can choose a winner by setting
    // the loser's isDefunct to TRUE. Nothing else to check.

    return 0;
}

//-----------------------------------------------------------------------
//
// Function Name:            ValidAttAddOp
//
// Routine Description:
//
//    Validates Whether the Operation on Att Schema Object is Valid or Not
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac               
//                 
//
// Return Value:
//
//    int              0 On Succeess
//
//-----------------------------------------------------------------------
int
ValidAttAddOp(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    if (DupAttRdn(pTHS, ac))
    {
        return ERROR_DS_DUP_RDN;
    } 
    
    if (DupAttOid(pTHS, ac))
    {
        return ERROR_DS_DUP_OID;
    } 
    
    if (DupAttMapiid(pTHS, ac))
    {
        return ERROR_DS_DUP_MAPI_ID;
    } 

    if (DupAttLinkid(pTHS, ac))
    {
        return DS_ERR_DUP_LINK_ID;
    } 

    if (InvalidBackLinkAtt(pTHS, ac))
    {
        return ERROR_DS_BACKLINK_WITHOUT_LINK;
    } 

    if (InvalidLinkAttSyntax(pTHS, ac))
    {
        return ERROR_DS_WRONG_LINKED_ATT_SYNTAX;
    } 

    if (DupAttSchemaGuidId(pTHS, ac))
    {
        return ERROR_DS_DUP_SCHEMA_ID_GUID;
    } 

    if (InvalidClsOrAttLdapDisplayName(ac->name, ac->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }

    if (DupAttLdapDisplayName(pTHS, ac))
    {
        return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
    } 

    if (SemanticAttTest(pTHS, ac))
    {
        return ERROR_DS_SEMANTIC_ATT_TEST;
    } 

    if (SyntaxMatchTest(pTHS, ac))
    {
        return ERROR_DS_SYNTAX_MISMATCH;
    }

    if (OmObjClassTest(ac))
    {
        return ERROR_DS_WRONG_OM_OBJ_CLASS;
    }

    if (SearchFlagTest(ac))
    {
        return ERROR_DS_INVALID_SEARCH_FLAG;
    }

    if (IsRdnSyntaxTest(pTHS, ac))
    {
        return ERROR_DS_BAD_RDN_ATT_ID_SYNTAX; 
    }

    return 0;

} // End ValidAttAddOp


//-----------------------------------------------------------------------
//
// Function Name:            ValidAttModOp
//
// Routine Description:
//
//    Validates Whether the Operation on Att Schema Object is Valid or Not
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac               
//                 
//
// Return Value:
//
//    int              0 On Succeess
//
//-----------------------------------------------------------------------
int
ValidAttModOp(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // No mods of constructed atts are allowed unless the special
    // registry flag is set
    if (ac->bIsConstructed && !gAnchor.fSchemaUpgradeInProgress) {
        return ERROR_DS_CONSTRUCTED_ATT_MOD;
    }


    if (InvalidClsOrAttLdapDisplayName(ac->name, ac->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }
    
    // Check modifications to defunct atts at resurrection,
    // not during modification. Use old protocol if pre-schema-reuse
    // forest
    if (!ac->bDefunct || !ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
        if (DupAttLdapDisplayName(pTHS, ac))
        {
            return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
        } 
    }

    if (SemanticAttTest(pTHS, ac))
    {
        return ERROR_DS_SEMANTIC_ATT_TEST;
    } 

    if (SearchFlagTest(ac))
    {
        return ERROR_DS_INVALID_SEARCH_FLAG;
    }

    if (GCReplicationTest(ac))
    {
        return ERROR_DS_CANT_ADD_TO_GC;
    }

    if (IsRdnSyntaxTest(pTHS, ac))
    {
        return ERROR_DS_BAD_RDN_ATT_ID_SYNTAX; 
    }


    return 0;
}


//-----------------------------------------------------------------------
//
// Function Name:            ValidAttDelOp
//
// Routine Description:
//
//    Validates Whether the Operation on Att Schema Object is Valid or Not
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac               
//                 
//
// Return Value:
//
//    int              0 On Succeess
//
//-----------------------------------------------------------------------
int
ValidAttDelOp(
    THSTATE *pTHS,
    ATTCACHE* ac 
)

{
    if (AttInMustHave(pTHS, ac))
    {
        return ERROR_DS_EXISTS_IN_MUST_HAVE;
    } 


    if (AttInMayHave(pTHS, ac))
    {
        return ERROR_DS_EXISTS_IN_MAY_HAVE;
    } 

    // Disallow defuncting attributes used as rdnattids in live classes
    // Note this case must be handled in schema reload because the
    // attribute may have been defuncted prior to whistler beta3.
    // But thats okay because attributes used as rdnattid are
    // resurrected during the reload so marking them defunct just
    // means they may be purged later. They can't be reused.
    if (ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)
        && AttInRdnAttId(pTHS, ac)) {
        return ERROR_DS_EXISTS_IN_RDNATTID;
    }

    return 0;

}
//-----------------------------------------------------------------------
//
// Function Name:            ValidClsAddOp
//
// Routine Description:
//
//    Validates whether the Operation on Schema Object is Valid or not
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidClsAddOp(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{

    if (DupClsRdn(pTHS, cc))
    {
        return ERROR_DS_DUP_RDN;
    } 
    
    if (DupClsOid(pTHS, cc))
    {
        return ERROR_DS_DUP_OID;
    } 
    
    if (DupClsSchemaGuidId(pTHS, cc))
    {
        return ERROR_DS_DUP_SCHEMA_ID_GUID;
    } 

    if (InvalidClsOrAttLdapDisplayName(cc->name, cc->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }

    if (DupClsLdapDisplayName(pTHS, cc))
    {
        return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
    } 

    if (ClsMayHaveExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_NONEXISTENT_MAY_HAVE; 
    }
    
    if (ClsMustHaveExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_NONEXISTENT_MUST_HAVE; 
    }
    
    if (ClsAuxClassExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_AUX_CLS_TEST_FAIL; 
    }
    
    if (ClsPossSupExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_NONEXISTENT_POSS_SUP; 
    }
    
    if (ClsSubClassExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_SUB_CLS_TEST_FAIL; 
    }

    if (RdnAttIdSyntaxTest(pTHS, cc))
    {    
        return ERROR_DS_BAD_RDN_ATT_ID_SYNTAX; 
    }

    return 0;
} // End ValidClsAddOp


//-----------------------------------------------------------------------
//
// Function Name:            ValidClsModOp
//
// Routine Description:
//
//    Validates whether the Operation on Schema Object is Valid or not
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidClsModOp(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    if (InvalidClsOrAttLdapDisplayName(cc->name, cc->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }

    // Check modifications to defunct classes at resurrection,
    // not during modification on schema-reuse forests.
    if (!cc->bDefunct || !ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
        if (DupClsLdapDisplayName(pTHS, cc))
        {
            return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
        } 

        if (ClsMayHaveExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_NONEXISTENT_MAY_HAVE; 
        }
        
        if (ClsMustHaveExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_NONEXISTENT_MUST_HAVE; 
        }
        
        if (ClsAuxClassExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_AUX_CLS_TEST_FAIL; 
        }
        
        if (ClsPossSupExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_NONEXISTENT_POSS_SUP;
        }

        if (ClsMayMustPossSafeModifyTest(pTHS, cc))
        {
            return ERROR_DS_NONSAFE_SCHEMA_CHANGE;
        }    
    }

    return 0;
} // End ValidClsModOp


//-----------------------------------------------------------------------
//
// Function Name:            ValidClsDelOp
//
// Routine Description:
//
//    Validates whether the Operation on Schema Object is Valid or not
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidClsDelOp(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    if (ClsInAuxClass(pTHS, cc))
    {
        return ERROR_DS_EXISTS_IN_AUX_CLS;
    }

    if (ClsInSubClassOf(pTHS, cc))
    {
        return ERROR_DS_EXISTS_IN_SUB_CLS;
    }

    if (ClsInPossSuperior(pTHS, cc))
    {
        return ERROR_DS_EXISTS_IN_POSS_SUP;
    }


    return 0;
} // End ValidClsDelOp

//-----------------------------------------------------------------------
//
// Function Name:            DupAttRdn
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttRdn(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Already been performed... This is a NOOP
    return 0;
} // End DupAttRdn



//-----------------------------------------------------------------------
//
// Function Name:            DupAttOid
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttOid(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupOID;
} // End DupAttOid


//-----------------------------------------------------------------------
//
// Function Name:            DupAttMapiid
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttMapiid(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupMapiID;
} // End DupAttMapiid



//-----------------------------------------------------------------------
//
// Function Name:            DupAttLinkid
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate Link Id
//
// Author: RajNath
// Date  : [4/8/1997]
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttLinkid(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    DECLARESCHEMAPTR
    ULONG i;

    if (ac->ulLinkID==0)
    {
        return FALSE;
    }

    for (i=0;i<ATTCOUNT;i++)
    {
        ATTCACHE* nc;

        //
        // Nothing in this slot
        //
        if (ahcId[i].pVal==NULL || ahcId[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (ATTCACHE*)ahcId[i].pVal;


        //
        // Its the same cache structure being examined
        //
        if (nc==ac)
        {
            continue;
        }

        if (nc->ulLinkID == ac->ulLinkID)
        {
            return TRUE;
        }

    }

    return FALSE;
} // End DupAttLinkid

//-----------------------------------------------------------------------
//
// Function Name:            InvalidBackLinkAtt
//
// Routine Description:
//
//    Checks the Att Schema to see if it is a backlink with no forward link
//
// Author: ArobindG
// Date  : [7/28/1998]
//
// Arguments:
//
//    THSTATE* pTHS
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
InvalidBackLinkAtt(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    // backlinks must have a corresponding forward link.
    // backlink cannot be the reserved linkid, RESERVED_AUTO_NO_LINK_ID.
    // See AutoLinkId for more info about automatically assigned linkids
    // and interoperability issues with RESERVED_AUTO_NO_LINK_ID.
    if (   FIsBacklink(ac->ulLinkID)
        && (   !SCGetAttByLinkId(pTHS, MakeLinkId(MakeLinkBase(ac->ulLinkID)))
            || ac->ulLinkID == RESERVED_AUTO_NO_LINK_ID) ) {
        return TRUE;
    }

     return FALSE;
}


//-----------------------------------------------------------------------
//
// Function Name:            InvalidLinkAttSyntax
//
// Routine Description:
//
//    If it is a linked att, check that it has correct syntax
//
// Author: ArobindG
// Date  : [2/16/1998]
//
// Arguments:
//
//    THSTATE* pTHS
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
InvalidLinkAttSyntax(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
     
     if (ac->ulLinkID) {
         if (FIsBacklink(ac->ulLinkID)) {
            // backlinks must be of syntax SYNTAX_DISTNAME_TYPE
            if (ac->syntax != SYNTAX_DISTNAME_TYPE) {
               return TRUE;
            }
         }
         else {
            // forward link. Can be one of the following
            if ( (ac->syntax != SYNTAX_DISTNAME_TYPE) &&
                   (ac->syntax != SYNTAX_DISTNAME_BINARY_TYPE) &&
                     (ac->syntax != SYNTAX_DISTNAME_STRING_TYPE) ) {
                return TRUE;
            }
         }
     }

     return FALSE;
}





//-----------------------------------------------------------------------
//
// Function Name:            DupAttSchemaGuidId
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate Schema ID Guid
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttSchemaGuidId(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupPropGuid;
} // End DupAttSchemaGuidId


//-----------------------------------------------------------------------
//
// Function Name:            InvalidClsOrAttLdapDisplayName
//
// Routine Description:
//
//    Checks the given name for invalid ldap display name
//
// Author: ArobindG
// Date  : [7/15/1998]
//
// Arguments:
//
//    name - pointer to null-terminated UTF-8 name
//    nameLen - no. of bytes in the name (not including the null)
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//------------------------------------------------------------------

BOOL
InvalidClsOrAttLdapDisplayName(
    UCHAR *name,
    ULONG nameLen
)
{
    ULONG i;
    int c;

    // Must have a ldapDisplayName and, by RFC 2251 s4.1.4, must begin
    // with a letter and must only contain ASCII letters, digit characters
    // and hyphens.

    if (nameLen == 0) {
       return TRUE;
    }

    // non-zero length, so name must be non-null

    Assert(name);

    // Check for hardcoded codes since the C runtime one is locale dependent
    // and behaves strangely for some codes with value > 127
    // NOTE: The name passed in is UTF-8, so can be more than one byte per 
    // actual character. However, it is sufficient to check each byte directly
    // against the ascii code since UTF-8 guarantees that (1) the ascii
    // codes 0x00 to 0x7f are encoded in one byte with the same value, and
    // (2) no other encoding has a byte between 0x00 and 0x7f (all have highest
    // bit set (see rfc 2279)

    // first character must be a letter
    c = (int) name[0];
    if (  ! ( (c >= 'A' && c <= 'Z')
               || (c >= 'a' && c <= 'z') 
            ) 
       ) {
        return TRUE;
    }


    // Other characters must be alphanumeric or -
    for (i = 1; i < nameLen; i++) {
       c = (int) name[i];
       if ( ! ( (c >= 'A' && c <= 'Z')
                  || (c >= 'a' && c <= 'z')
                  || (c >= '0' && c <= '9')
                  || (c == '-') 
              )
          ) {
           return TRUE;
       }
    }

    // ok, all valid characters
   
    return FALSE;
}

    
//-----------------------------------------------------------------------
//
// Function Name:            DupAttLdapDisplayName
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate Ldap-Display-Name
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttLdapDisplayName(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupLDN;
} // End DupAttLdapDisplayName



//-----------------------------------------------------------------------
//
// Function Name:            SemanticAttTest
//
// Routine Description:
//
//    Checks the Att Schema for Semantic Correctness
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------

BOOL
SemanticAttTest(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    int i;
    int ret;
    
    if (ac->rangeLowerPresent && ac->rangeUpperPresent)
    {
        switch (ac->syntax)  {
           case SYNTAX_INTEGER_TYPE:
              // compare signed
              if ( ((SYNTAX_INTEGER) ac->rangeLower) >
                       ((SYNTAX_INTEGER) ac->rangeUpper) ) {
                   return TRUE;
              }
              break;
           default:
               // all other cases, compare unsigned
             
               if (ac->rangeLower>ac->rangeUpper)
               {
                   return TRUE;
               }
         }
    }


    return FALSE;
} // End SemanticAttTest

//-----------------------------------------------------------------------
//
// Function Name:           SyntaxMatchTest
//
// Routine Description:
//
//    Tests if the attribute syntax and the om syntax match
//
// Author: Arobindg
// Date  : [6/9/1997]
//
// Arguments:
//
//    CLASSCACHE* cc
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
SyntaxMatchTest(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    ULONG i;


    for (i = 0; i < SyntaxPairTableLength; i++) {
       if ( (KnownSyntaxPair[i].attSyntax == ac->syntax)
               && (KnownSyntaxPair[i].omSyntax == (OM_syntax) ac->OMsyntax)) {

          // syntaxes match

          break;
        }
    }
    if (i == SyntaxPairTableLength) {
        // syntaxes did not match with any pair
        return TRUE;
    }

    return FALSE;
         
} // End SyntaxMatchTest


//-----------------------------------------------------------------------
//
// Function Name:           OmObjClassTest
//
// Routine Description:
//
//    Tests if the OM-object-class is correct for a object-syntaxed att
//
// Author: Arobindg
// Date  : [5/19/1998]
//
// Arguments:
//
//    ATTCACHE *ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------

BOOL
OmObjClassTest(
    ATTCACHE* ac
)
{
    ULONG valLen = 0, valLenBackup = 0;
    PVOID pTemp = NULL, pBackup = NULL;

    if (ac->OMsyntax != OM_S_OBJECT) {
       // not an object-syntaxed attribute, nothing to do
       // if the attribute-syntax says it is an object but om-syntax
       // is wrong, it will be caught by the SyntaxMatchTest

       return FALSE;
    }

    // ok, we have an object-syntaxed attribute
    // Find what its correct om-object-class should be based on
    // attribute syntax

    switch(ac->syntax) {
        case SYNTAX_DISTNAME_TYPE :
             // DS-DN
             valLen = _om_obj_cls_ds_dn_len;
             pTemp  = _om_obj_cls_ds_dn;
             break;
        case SYNTAX_ADDRESS_TYPE :
             // Presentation-Address
             valLen = _om_obj_cls_presentation_addr_len;
             pTemp  = _om_obj_cls_presentation_addr;
             break;
        case SYNTAX_OCTET_STRING_TYPE :
             // Replica-Link
             valLen = _om_obj_cls_replica_link_len;
             pTemp  = _om_obj_cls_replica_link;
             break;
        case SYNTAX_DISTNAME_STRING_TYPE :
             // Access-Point or DN-String. 
             // We will first check the more common Access-Point
             valLen = _om_obj_cls_access_point_len;
             pTemp  = _om_obj_cls_access_point;
             valLenBackup = _om_obj_cls_dn_string_len;
             pBackup = _om_obj_cls_dn_string;
             break;
        case SYNTAX_DISTNAME_BINARY_TYPE :
             // OR-Name or DN-Binary. 
             // We will first check the more common OR-Name
             valLen = _om_obj_cls_or_name_len;
             pTemp  = _om_obj_cls_or_name;
             valLenBackup = _om_obj_cls_dn_binary_len;
             pBackup = _om_obj_cls_dn_binary;
             break;
        default :
             // Attribute-syntax and OM-syntax do not match,
             // since the above are the only matching attribute
             // syntaxes corresponding to OM_S_OBJECT om-syntax.
             // This should have been already detected by the
             // SyntaxMatchTest which is called before this,
             // but fail this anyway.
             return TRUE;
     }

      // check that the given om-object-class is correct
      // Note that if no om-object-class is specified, 
      // ac->OMObjClass is all 0

      if ( (valLen != ac->OMObjClass.length) ||
             (memcmp(ac->OMObjClass.elements, pTemp, valLen) != 0) ) {

          // om-object-classes do not match

          // Check if the syntax is dn-binary or dn-string
          // if so, there is one more possibility
          if ( (ac->syntax == SYNTAX_DISTNAME_BINARY_TYPE)
               || (ac->syntax == SYNTAX_DISTNAME_STRING_TYPE) ) {
              // check against the backup

              if ( (valLenBackup == ac->OMObjClass.length) &&
                    (memcmp(ac->OMObjClass.elements, pBackup, valLenBackup) == 0) ) {
                 // matched
                 return FALSE;
               }
           }

          return TRUE;
      }

      return FALSE;

}  // End OmObjClassTest


//-----------------------------------------------------------------------
//
// Function Name:           SearchFlagTest
//
// Routine Description:
//
//    Tests if the ANR bit is set, the syntax is either unicode or teletex
//
// Author: Arobindg
// Date  : [10/20/1998]
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
SearchFlagTest(
    ATTCACHE* ac
)
{

    if ( ac->fSearchFlags & fANR ) {

       // ANR is set. Check the syntax

       switch (ac->syntax) {
          case SYNTAX_UNICODE_TYPE:
          case SYNTAX_CASE_STRING_TYPE:
          case SYNTAX_NOCASE_STRING_TYPE:
          case SYNTAX_PRINT_CASE_STRING_TYPE:
              // these are allowed
              break;
          default:
              // bad syntax
              return TRUE;
        }
    }
    if ((ac->fSearchFlags & fTUPLEINDEX) && (SYNTAX_UNICODE_TYPE != ac->syntax)) {
        return TRUE;
    }

    return FALSE;

} // End SearchFlagTest

//-----------------------------------------------------------------------
//
// Function Name:          GCReplicationTest 
//
// Routine Description:
//
//    Some attributes, like password etc. are protected from being
//    replicated to GCs for security reasons
//
// Author: Arobindg
// Date  : [05/27/1999]
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
GCReplicationTest(
    ATTCACHE* ac
)
{
    if (DBIsSecretData(ac->id)) {
        // protected att, fail if member of partial att set (none of these
        // are replicated to GCs in the base schema)

        if (ac->bMemberOfPartialSet) {
           return TRUE;
        }
    }

    return FALSE;

} // End GCReplicationTest

             

//-----------------------------------------------------------------------
//
// Function Name:            DupClsRdn
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate RDN
//
// Arguments:
//
//    CLASSCACHE cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsRdn(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i, FoundRdn, FoundFlagRdn;
    ATTCACHE *pAC;

    // There may be one active attr and several defunct ones that
    // claim the same OID. If so, don't allow them to be used as
    // an rdnattid unless FLAG_ATTR_IS_RDN is set to TRUE in one
    // of the attributes.

    // Count the matching attrs
    for (i = FoundRdn = FoundFlagRdn = 0; i < ATTCOUNT; ++i) {
        pAC = ahcId[i].pVal;
        if (!pAC || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC->Extid == cc->RdnExtId) {
            ++FoundRdn;
            if (pAC->bFlagIsRdn) {
                ++FoundFlagRdn;
            }
        }
    }

    // No attrs for RdnExtId were found. So no dups.
    if (!FoundRdn) {
        return FALSE;
    }

    // Only one attr claims the RdnExtId. That's okay.
    if (FoundRdn == 1) {
        return FALSE;
    }

    // Only one attr claiming RdnExtId has FLAG_ATTR_IS_RDN set. That's okay.
    if (FoundFlagRdn == 1) {
        return FALSE;
    }

    // Too many attrs claim RdnExtId. Error.
    return TRUE;

} // End DupClsRdn



//-----------------------------------------------------------------------
//
// Function Name:            DupClsOid
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsOid(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    // Detected during the validation cache load
    return cc->bDupOID;
} // End DupClsOid


//-----------------------------------------------------------------------
//
// Function Name:            DupClsSchemaGuidId
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsSchemaGuidId(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    // Detected during the validation cache load
    return cc->bDupPropGuid;
} // End DupClsSchemaGuidId



//-----------------------------------------------------------------------
//
// Function Name:            DupClsLdapDisplayName
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate Ldap-Display-Name
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsLdapDisplayName(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    // Detected during the validation cache load
    return cc->bDupLDN;
} // End DupClsLdapDisplayName



//-----------------------------------------------------------------------
//
// Function Name:            ClsMayHaveExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsMayHaveExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pMyMayAtts;
    ULONG  count=cc->MyMayCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        ATTCACHE* ac;
        if (!(ac = SCGetAttById(pTHS, list[i])))
        {
            return TRUE;
        }

        // Ok, the attribute is there. Check that it is not a
        // a deleted attribute
        if (ac->bDefunct) {
           return TRUE;
        }

    }


    return FALSE;
} // End ClsMayHaveExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsMustHaveExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsMustHaveExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pMyMustAtts;
    ULONG  count=cc->MyMustCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        ATTCACHE* ac;
        if (!(ac = SCGetAttById(pTHS, list[i])))
        {
            return TRUE;
        }

        // Ok, the attribute is there. Check that it is not a
        // a deleted attribute. Also, no constucted 
        // attributes should be part of must have

        if (ac->bDefunct || ac->bIsConstructed ) {
           return TRUE;
        }
    }


    return FALSE;
} // End ClsMustHaveExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsAuxClassExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//    Also checks if an aux class has the correct obj class category
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsAuxClassExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pAuxClass;
    ULONG  count=cc->AuxClassCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        CLASSCACHE* pcc;
        if (!(pcc = SCGetClassById(pTHS, list[i])))
        {
            return TRUE;
        }

        // Check that the class is not already deleted
        if (pcc->bDefunct) {
           return TRUE;
        }

        // Check that we are not trying to add the same class as 
        // its aux class
        if (cc->ClassId == pcc->ClassId)
        {
            return TRUE;
        }
        // Check that the class category is correct
        if ( (pcc->ClassCategory != DS_AUXILIARY_CLASS) &&
                (pcc->ClassCategory != DS_88_CLASS) ) {
           return TRUE;
        }
    }


    return FALSE;
} // End ClsAuxClassExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsPossSupExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//    Also checks if the class category of a poss sup is correct
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsPossSupExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pMyPossSup;
    ULONG  count=cc->MyPossSupCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        CLASSCACHE* pcc;
        if (!(pcc = SCGetClassById(pTHS, list[i])))
        {
            return TRUE;
        }

        // See if class is already deleted
        if (pcc->bDefunct) {
           return TRUE;
        }
    }


    return FALSE;
} // End ClsPossSupExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsSubClassExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//    Also checks for various other restrictions depending on object
//    class category
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsSubClassExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pSubClassOf;
    ULONG  count=cc->SubClassCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        CLASSCACHE* pcc;
        if (!(pcc = SCGetClassById(pTHS, list[i])))
        {
            return TRUE;
        }

        // See if the class is already deleted
        if (pcc->bDefunct) {
          return TRUE;
        }

        // Check that we are not trying to add the same class as
        // its own sub class
        if (cc->ClassId == pcc->ClassId)
        {
            return TRUE;
        }

        // Abstract class can only inherit from abstract
        if ( (cc->ClassCategory == DS_ABSTRACT_CLASS) &&
                (pcc->ClassCategory != DS_ABSTRACT_CLASS) ) {
            return TRUE;
        }
        // Aux class cannot be a subclass of structural class
        // or vice-versa
        if ( ((cc->ClassCategory == DS_AUXILIARY_CLASS) &&
                (pcc->ClassCategory == DS_STRUCTURAL_CLASS))  ||
                  ((cc->ClassCategory == DS_STRUCTURAL_CLASS) && 
                     (pcc->ClassCategory == DS_AUXILIARY_CLASS)) ) {
            return TRUE;
        }
    }


    return FALSE;
} // End ClsSubClassExistenceTest

//-----------------------------------------------------------------------
//
// Function Name:            ClsMayMustPossSafeModifyTest
//
// Routine Description:
//
//    Tests if the change attempted during a class
//    modify will result in adding a new must-contain or 
//    deleting a may-contain, must-contain, or Poss-sup from the 
//    class, either directly or through inheritance
//
// Author: ArobindG
// Date  : [10/7/1998]
//
// Arguments:
//
//    THSTTAE*    pTHS
//    CLASSCACHE* cc
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsMayMustPossSafeModifyTest(
    THSTATE *pTHS,
    CLASSCACHE* cc
)
{
    ULONG i;
    CLASSCACHE *pccOld;
    ATTCACHE *pAC;

    if (pTHS->pClassPtr == NULL) {
       // no old copy to check with.
       return FALSE;
    }

    // some change is there
    pccOld = (CLASSCACHE *) pTHS->pClassPtr;

    // pccOld is already closed by SCBuildCCEntry. It may have been closed
    // with a slightly older cache (the cache when the modify thread started),
    // but that doesn't matter for the checks below, since we know that
    // the next schema change since then must have passed these tests, and 
    // so even if it is missing from the cache, it doesn't affect testing
    // of the next one and so on. Note that this argument wouldn't have
    // held if we have tried to stop deletions only, since you could have added
    // a mayContain and deleted it and not noticed it if the cache pccOld
    // was closed with didn't have the addition itself. For mustContains, we 
    // stop both addition/deletion, so whatever the set you start with
    // is the set you alwys have. For mayContains/PossSups, we allow
    // both additons and deletions, so we don't care to check anything.
    // for Top, we allow only addition of backlinks, but we also allow
    // deletion of mayContains, so it is again not a problem.

    // If later we disallow deletion again (but still allow addition), 
    // be very careful about closing pccOld. Basically, you want to close 
    // pccOld with all the previous changes minus the current one. But 
    // RecalcSchema already has the current change also. So you cannot 
    // close against it since the current changes may filter into pccOld 
    // through inheritance in some cases, and not give you a true comparison. 
    // So you will somehow need to get to info on what is being changed in 
    // this call and use that.

    // Close the passed-in class cc. It is not closed since we
    // don't call scCloseClass on the recalc cache. This is the only
    // place we need inherited atts, so close it here rather than
    // do it for every  thing. 

    Assert(cc->bClosed == 0);
    cc->bClosed = 0;
    if (scCloseClass(pTHS, cc)) {
       DPRINT1(0, "ClsAuxClassSafeModfyTest: Error closing class %s\n", cc->name);
       return TRUE;
    }


    // Now check to see that cc doesn't have any new must-contains
    // or isn't missing any must-contain when compared to pcc

    // First, all must-contains in the new class defn. must be there
    // in the old one too
    for (i=0; i<cc->MustCount; i++) {
       if (!IsMember(cc->pMustAtts[i], pccOld->MustCount, pccOld->pMustAtts)) {
           return TRUE;
       }
    }

    // ok, so all must-contains that are there now were there before
    // Check that nothing got deleted. A simple check of the count will do this now
    if (cc->MustCount != pccOld->MustCount) {
        return TRUE;
    }

    // For TOP, make sure that no new mayContains that are not backlinks got 
    // added. Rest are all blocked in mdmod.c anyway

    if (cc->ClassId == CLASS_TOP) {
        for (i=0; i<cc->MayCount; i++) {
           if (!IsMember(cc->pMayAtts[i], pccOld->MayCount, pccOld->pMayAtts)) {
               // new att. Make sure it is backlink
               pAC = SCGetAttById(pTHS, cc->pMayAtts[i]);
               if (!pAC || !FIsBacklink(pAC->ulLinkID)) {
                  // can't get the attcache, or not a backlink.
                  return TRUE;
               }
           }
        }
        // nothing else to do for TOP
        return FALSE;
     }

    return FALSE;
}

//-----------------------------------------------------------------------
//
// Function Name:           RdnAttIdSyntaxTest
//
// Routine Description:
//
//    Tests if the RDN-Att-Id of the class is there, and if it is,
//    if it has the proper syntax
//
// Author: Arobindg
// Date  : [6/9/1997]
//
// Arguments:
//
//    CLASSCACHE* cc
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
RdnAttIdSyntaxTest(
    THSTATE *pTHS,
    CLASSCACHE* cc
)
{
    ATTCACHE *pac, *pRDN;

    if ( !(cc->RDNAttIdPresent) ) {
      // No RDN Att Id to check
      return FALSE;
    }

    // Get the attcache for the RDN-Att-Id attribute
    if (!(pac = SCGetAttByExtId(pTHS, cc->RdnExtId))) {
        return TRUE;
    }

    // Check if the RDN-Att-Id is not deleted
    if (pac->bDefunct) {
       return TRUE;
    }


    // Get the attcache for RDN
    if (!(pRDN = SCGetAttById(pTHS, ATT_RDN))) {
        return TRUE;
    }
    
    // Check that the syntaxes match
    if (pac->syntax != pRDN->syntax) {
        return TRUE;
    }
   
    return FALSE;
} // End RdnAttIdSyntaxTest

//-----------------------------------------------------------------------
//
// Function Name:           IsRdnSyntaxTest
//
// Routine Description:
//
//    Tests if the attr has the correct syntax to be an rdn if the
//    systemFlag, FLAG_ATTR_IS_RDN, is set, or the attribute is used
//    as the rdnattid of any class, live or defunct.
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
IsRdnSyntaxTest(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    ATTCACHE *pRDN;

    // Not used as an rdn; no problem
    if (!ac->bIsRdn) {
        return FALSE;
    }

    // Get the attcache for RDN
    if (!(pRDN = SCGetAttById(pTHS, ATT_RDN))) {
        return TRUE;
    }
    
    // Check that the syntaxes match
    if (ac->syntax != pRDN->syntax) {
        return TRUE;
    }
   
    return FALSE;
} // End IsRdnSyntaxTest

//-----------------------------------------------------------------------
//
// Function Name:            ClsInAuxClass
//
// Routine Description:
//
//    Tests if the Supplied class appears as an Aux. Class of some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsInAuxClass(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=cc->ClassId;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        //
        // Its the same cache structure being examined
        // 
        if (nc==cc)
        {
            continue;
        }

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pAuxClass;
        cnt =nc->AuxClassCount;

        for (j=0;j<cnt;j++)
        {
            if (list[j]==id)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End ClsInAuxClass


//-----------------------------------------------------------------------
//
// Function Name:            ClsInSubClassOf
//
// Routine Description:
//
//    Tests if the Supplied class appears as an ClsInSubClassOf Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsInSubClassOf(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=cc->ClassId;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        //
        // Its the same cache structure being examined
        // 
        if (nc==cc)
        {
            continue;
        }

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pSubClassOf;
        cnt =nc->SubClassCount;

        for (j=0;j<cnt;j++)
        {
            if (list[j]==id)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End ClsInAuxClass



//-----------------------------------------------------------------------
//
// Function Name:            ClsInPossSuperior
//
// Routine Description:
//
//    Tests if the Supplied class appears as an PossSuperior Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsInPossSuperior(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=cc->ClassId;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        //
        // Its the same cache structure being examined
        // 
        if (nc==cc)
        {
            continue;
        }

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pMyPossSup;
        cnt =nc->MyPossSupCount;

        for (j=0;j<cnt;j++)
        {
            if (list[j]==id)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End ClsInPossSuperior



//-----------------------------------------------------------------------
//
// Function Name:            AttInMayHave
//
// Routine Description:
//
//    Tests if the Supplied Attr appears as a MayHave Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
AttInMayHave(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=ac->id;
    ULONG Extid=ac->Extid;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        // if it is a deleted class, no need to check it

        if (nc->bDefunct) {
           continue;
        }

        list=nc->pMyMayAtts;
        cnt =nc->MyMayCount;

        for (j=0;j<cnt;j++)
        {
            // test both ids
            if (list[j]==id || list[j]==Extid)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End AttInMayHave


//-----------------------------------------------------------------------
//
// Function Name:            AttInMustHave
//
// Routine Description:
//
//    Tests if the Supplied Attr appears as a MustHave Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
AttInMustHave(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=ac->id;
    ULONG Extid=ac->Extid;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pMyMustAtts;
        cnt =nc->MyMustCount;

        for (j=0;j<cnt;j++)
        {
            // test both ids
            if (list[j]==id || list[j]==Extid)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End AttInMustHave

BOOL
AttInRdnAttId(
    IN THSTATE  *pTHS,
    IN ATTCACHE *pAC
)
/*++
Routine Description
    Tests if the Supplied Attr appears as a RdnAttId of an active Class

Paramters
    pTHS
    pAC

Return
    BOOL True   On Test Failed
--*/
{
    DECLARESCHEMAPTR
    ULONG       i, Extid=pAC->Extid;
    CLASSCACHE  *pCC;

    for (i=0; i<CLSCOUNT; i++) {
        // An attribute used as an rdnattid of defunct classes can
        // be defuncted (but not reused). Check that every active
        // class claiming this attribute as an rdnattid is defunct.
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY) {
            continue;
        }

        pCC = (CLASSCACHE *)ahcClass[i].pVal;
        if (pCC->bDefunct) {
            continue;
        }
        if (pCC->RDNAttIdPresent && (pCC->RdnExtId == Extid)) {
            return TRUE;
        }
    }

    return FALSE;
} // End AttInRdnAttId

//////////////////////////////////////////////////////////////////
// Routine Description:
//     Free all allocated memory in a schema cache
//
// Arguments: Schema Pointer pointer to the schema cache
//
// Return Value: None
/////////////////////////////////////////////////////////////////
// Frees an attcache structure

void SCFreeAttcache(ATTCACHE **ppac)
{
    ATTCACHE *pac = *ppac;

    if (!pac) {
        return;
    }

    SCFree(&pac->name);
    SCFree(&pac->pszIndex);
    SCFree(&pac->pszPdntIndex);
    SCFree(&pac->pszTupleIndex);
    SCFree(&pac->pidxPdntIndex);
    SCFree(&pac->pidxIndex);
    SCFree(&pac->pidxTupleIndex);
    SCFree(&pac->OMObjClass.elements);
    SCFree(ppac);
}

// Frees a classcache structure

void SCFreeClasscache(CLASSCACHE **ppcc)
{
    CLASSCACHE *pcc = *ppcc;

    if (!pcc) {
        return;
    }

    SCFree(&pcc->name);
    SCFree(&pcc->pSD);
    SCFree(&pcc->pStrSD);
    SCFree(&pcc->pSubClassOf);
    SCFree(&pcc->pAuxClass);
    SCFree(&pcc->pMyMustAtts);
    SCFree(&pcc->pMustAtts);
    SCFree(&pcc->pMyMayAtts);
    SCFree(&pcc->pMayAtts);
    SCFree(&pcc->pMyPossSup);
    SCFree(&pcc->pPossSup);
    SCFree(&pcc->pDefaultObjCategory);
    SCFree((VOID **)&pcc->ppAllAtts);
    SCFree(&pcc->pAttTypeCounts);
    SCFree(ppcc);
}

// Frees the prefix table

void SCFreePrefixTable(PrefixTableEntry **ppPrefixTable, ULONG PREFIXCOUNT)
{
    ULONG i;

    if (*ppPrefixTable) for (i=0; i<PREFIXCOUNT; i++) {
        SCFree(&(*ppPrefixTable)[i].prefix.elements);
    }
    SCFree(ppPrefixTable);
}

void SCFreeSchemaPtr(
    IN SCHEMAPTR    **ppSch
)
{
    ULONG            i;
    SCHEMAPTR       *pSch;
    ULONG            ATTCOUNT;
    ULONG            CLSCOUNT;
    HASHCACHE*       ahcId;
    HASHCACHE*       ahcExtId;
    HASHCACHE*       ahcCol;
    HASHCACHE*       ahcMapi;
    HASHCACHE*       ahcLink;
    HASHCACHESTRING* ahcName;
    HASHCACHE*       ahcClass;
    HASHCACHESTRING* ahcClassName;
    HASHCACHE*       ahcClassAll;
    ATTCACHE**       ahcAttSchemaGuid;
    CLASSCACHE**     ahcClsSchemaGuid;
    ULONG            PREFIXCOUNT;
    PrefixTableEntry* PrefixTable;
    extern SCHEMAPTR *CurrSchemaPtr;

    if (NULL == (pSch = *ppSch)) {
        return;
    }

    ATTCOUNT     = pSch->ATTCOUNT;
    CLSCOUNT     = pSch->CLSCOUNT;
    ahcId        = pSch->ahcId;
    ahcExtId     = pSch->ahcExtId;
    ahcCol       = pSch->ahcCol;
    ahcMapi      = pSch->ahcMapi;
    ahcLink      = pSch->ahcLink;
    ahcName      = pSch->ahcName;
    ahcClass     = pSch->ahcClass;
    ahcClassName = pSch->ahcClassName;
    ahcClassAll  = pSch->ahcClassAll;
    ahcAttSchemaGuid = pSch->ahcAttSchemaGuid;
    ahcClsSchemaGuid = pSch->ahcClsSchemaGuid;
    PREFIXCOUNT  = pSch->PREFIXCOUNT; 
    PrefixTable = pSch->PrefixTable.pPrefixEntry;

    if (ahcId) for (i=0; i< ATTCOUNT; i++) {
       if(ahcId[i].pVal && (ahcId[i].pVal!=FREE_ENTRY)) {
            SCFreeAttcache((ATTCACHE **)&ahcId[i].pVal);
       };
    }

    if (ahcClassAll) for (i=0; i< CLSCOUNT; i++) {
       if(ahcClassAll[i].pVal && (ahcClassAll[i].pVal!=FREE_ENTRY)) {
           SCFreeClasscache((CLASSCACHE **)&ahcClassAll[i].pVal);
       };
    }

    SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

    // Free the partial attribute vector
    SCFree(&pSch->pPartialAttrVec);

    // Free the ANRids
    SCFree(&pSch->pANRids);

    // free the ditContentRules
    if (pSch->pDitContentRules) {
        ATTRVALBLOCK *pAttrVal = pSch->pDitContentRules;

        if (pAttrVal->pAVal) {
            for (i=0; i<pAttrVal->valCount; i++) {
                SCFree(&pAttrVal->pAVal[i].pVal);
            }
            SCFree(&pAttrVal->pAVal);
        }
        SCFree(&pSch->pDitContentRules);
    }

    // Free the Cache tables themselves

    SCFree(&ahcId);
    SCFree(&ahcExtId);
    SCFree(&ahcName);
    SCFree(&ahcCol);
    SCFree(&ahcMapi);
    SCFree(&ahcLink);
    SCFree(&ahcClass);
    SCFree(&ahcClassName);
    SCFree(&ahcClassAll);

    // The following two are allocated only on validation cache
    // building, so check before you free (they are null if not
    // alloc'ed)
    SCFree((VOID **)&ahcAttSchemaGuid);
    SCFree((VOID **)&ahcClsSchemaGuid);

    // Finally, free the schema pointer itself
    SCFree(&pSch);

    // Must be a failure during boot or install. At any rate,
    // keep the global schema cache pointer correct.
    if (*ppSch == CurrSchemaPtr) {
        CurrSchemaPtr = NULL;
    }
    *ppSch = NULL;
}

// Defintions and helper function to get the object-guid of
// an attribute/class schema object given its attributeId/governsId
// respectively

ATTR SelList[] = {
    { ATT_OBJECT_GUID, {0, NULL}},
    { ATT_OBJ_DIST_NAME, {0, NULL}},
    { ATT_WHEN_CHANGED, {0, NULL}}
};
#define NUMATT sizeof(SelList)/sizeof(ATTR)


int
SearchForConflictingObj(
    IN THSTATE *pTHS,
    IN ATTRTYP attId,
    IN ULONG value,
    IN OUT GUID *pGuid,
    IN OUT DSTIME *pChangeTime,
    OUT DSNAME **ppDN
)
/*++
    Routine Description:
        Get the DN, object-guid, and the value of the whenChanged attribute
        on an attribute-schema/class-schema object,
        to put in the conflict log. Since schema conflicts will be very
        rare, the extra search cost during logging is acceptable

    Arguments:
        pTHS - thread state
        attId - ATT_ATTRIBUTE_ID or ATT_GOVERNS_ID
        value - attributeId/governsId of the attribute/class
        pGuid - pre-allocated space to return guid in
        pChangeTime - Value of whenChanged on the object
        ppDN - Return allocated DN. Free with THFreeEx.

    Return value:
        0 on success, non-0 on error
--*/
{
    SEARCHARG SearchArg;
    SEARCHRES *pSearchRes;
    COMMARG  *pCommArg;
    FILTER Filter;
    ENTINFSEL eiSel;
    ENTINFLIST *pEIL;
    ENTINF *pEI;
    ATTRVAL *pAVal;
    ULONG i, j;
    DSTIME TempTime[2];
    GUID  TempGuid[2]; 
    DSNAME *pTempDN[2];

    // Initalize return param
    *ppDN = NULL;

    // will hold the dns
    pTempDN[0] = NULL;
    pTempDN[1] = NULL;

    // allocate space for search res
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    if (pSearchRes == NULL) {
       MemoryPanic(sizeof(SEARCHRES));
       return 1;
    }
    memset(pSearchRes, 0, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;   //Initialize to Default

    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    eiSel.AttrTypBlock.attrCount = NUMATT;
    eiSel.AttrTypBlock.pAttr = SelList;

    // build filter
    memset(&Filter, 0, sizeof(FILTER));
    Filter.pNextFilter = (FILTER FAR *)NULL;
    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = attId;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (unsigned char *) &value;

    // build search argument
    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = gAnchor.pDMD;
    SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &eiSel;

    // Build Commarg
    InitCommarg(&(SearchArg.CommArg));

    // Search for all attSchema objects
    SearchBody(pTHS, &SearchArg, pSearchRes,0);
    if (pTHS->errCode) {
       DPRINT1(0,"Search for Guid failed %d\n", pTHS->errCode);
       return 2;
    }

    // ok, search succeded. If we have just one object, take the guid.
    // If we have more, which is possible if the object being added created
    // a duplicate OID (won't be there finally because this transaction
    // will fail, but since we are in the middle of it, we still see it),
    // take the one with the lower when-changed value. In any case cannot
    // be more than two, and must b at least 1

    Assert( (pSearchRes->count == 1) || (pSearchRes->count == 2) );

    if ((pSearchRes->count == 0) || (pSearchRes->count > 2)) {
       return 3;
    }

    pEIL = &(pSearchRes->FirstEntInf);        
    Assert(pEIL);
    for (i=0; i<pSearchRes->count; i++) {
        pEI = &pEIL->Entinf;
        Assert(pEI);
        for(j=0;j<pEI->AttrBlock.attrCount;j++) {  
            pAVal = pEI->AttrBlock.pAttr[j].AttrVal.pAVal;
            Assert(pAVal);
            switch(pEI->AttrBlock.pAttr[j].attrTyp) {
              case ATT_OBJECT_GUID:
                memcpy(&(TempGuid[i]), pAVal->pVal, sizeof(GUID));
                break;
              case ATT_WHEN_CHANGED:
                memcpy(&(TempTime[i]), pAVal->pVal, sizeof(DSTIME));
                break;
              case ATT_OBJ_DIST_NAME:
                pTempDN[i] = (DSNAME *)THAllocEx(pTHS, pAVal->valLen);
                memcpy(pTempDN[i], pAVal->pVal, pAVal->valLen);
                break;
            }
        }
        // should have found all three atts
        Assert(j == 3);
        pEIL = pEIL->pNextEntInf;
    }

    if ( (pSearchRes->count == 1) || (TempTime[0] < TempTime[1])) {
        // either only one object found, or the first one is the one we want
        memcpy(pGuid, &(TempGuid[0]), sizeof(GUID));
        (*pChangeTime) = TempTime[0];
        *ppDN = pTempDN[0];
        pTempDN[0] = NULL;
    }
    else {
        memcpy(pGuid, &(TempGuid[1]), sizeof(GUID));
        (*pChangeTime) = TempTime[1];
        *ppDN = pTempDN[1];
        pTempDN[1] = NULL;
    }

    // Free up potentially allocated memory. THFreeEx is okay w/freeing NULL.
    THFreeEx(pTHS, pTempDN[0]);
    THFreeEx(pTHS, pTempDN[1]);

    return 0;
}
   

VOID 
LogConflict(
    THSTATE *pTHS,
    VOID *pConflictingCache,
    char *pConflictingWith,
    MessageId midEvent,
    ULONG version,
    DWORD WinErr
)
/*++
    Routine Description:
        Function to log schema conflicts between replicated-in schema objects
        and exisiting schema objects. Such conflicts can happen only in the
        case of bad FSMO whacking

    Arguments:
        pTHS - thread state
        pConflictingCache - Attcache/Classcache of the conflicting att/class
                            in this DC
        pConflictingWith - name of the conflicting replicated-in schema object
        midEvent - Att conflict or Class conflict
        version - Currently 1, kept for future expansions
        WinErr - A winerror code for type of conflict

    Return value:
        None
--*/
{
    VOID *pvData;
    ULONG cbData;
    ATTCACHE *pAC;
    CLASSCACHE *pCC;
    ATT_CONFLICT_DATA *pAttData;
    CLS_CONFLICT_DATA *pClsData;
    DSTIME changeTime = 0;
    CHAR szTime[SZDSTIME_LEN];
    DSNAME *pDN = NULL;
    int err;


    switch (midEvent) {
       case DIRLOG_SCHEMA_ATT_CONFLICT: 
           cbData = sizeof(ATT_CONFLICT_DATA);
           pvData = THAllocEx(pTHS,cbData);
           pAC = (ATTCACHE *) pConflictingCache;
           Assert(pAC);
           pAttData = (ATT_CONFLICT_DATA *) pvData;
           pAttData->Version = version;
           pAttData->AttID = pAC->id;
           pAttData->AttSyntax = pAC->syntax;
           err = SearchForConflictingObj(pTHS, ATT_ATTRIBUTE_ID, pAC->id, &(pAttData->Guid), &changeTime, &pDN);
           if (err) {
              DPRINT1(0,"Cannot retrive dn/object-guid/time for conflicting schema object, %d\n", err);
           }
           break;
       case DIRLOG_SCHEMA_CLASS_CONFLICT: 
           cbData = sizeof(CLS_CONFLICT_DATA);
           pvData = THAllocEx(pTHS,cbData);
           pCC = (CLASSCACHE *) pConflictingCache;
           Assert(pCC);
           pClsData = (CLS_CONFLICT_DATA *) pvData;
           pClsData->Version = version;
           pClsData->ClsID = pCC->ClassId;
           err = SearchForConflictingObj(pTHS, ATT_GOVERNS_ID, pCC->ClassId, &(pClsData->Guid), &changeTime, &pDN);
           if (err) {
              DPRINT1(0,"Cannot retrive dn/object-guid/time for conflicting schema object, %d\n", err);
           }
           break;
       default:
           // unknown type
           return;
    } /* switch */

    // duplicate ldapdisplaynames are logged differently

    LogEvent8WithData(DS_EVENT_CAT_SCHEMA,
                      DS_EVENT_SEV_ALWAYS,
                      midEvent,
                      szInsertSz(pConflictingWith),
                      szInsertDN(pDN),
                      szInsertWin32Msg(WinErr),
                      szInsertDSTIME(changeTime, szTime),
                      szInsertWin32ErrCode(WinErr),
                      NULL, NULL, NULL, 
                      cbData, pvData);

    THFreeEx(pTHS,pvData);
    THFreeEx(pTHS, pDN);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\schash.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       schash.c
//
//--------------------------------------------------------------------------
//
// Abstract:
//
//   Contains hash functions used by schema cache code
//
// NOTE: This file is NOT to be compiled. This is created here
// so that we do not have to redefine the functions in both
// scache.c and scchk.c (and worry about keeping them the same 
// later), but just include this file. Since these are inline 
// static functions, extern declarations generate compiler errors. 
// These are not put in  the include directory since these are 
// code and not really just definitions 
//
//----------------------------------------------------------------------------

// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x in SChash. SChash
// is called much more frequently than SCName/GuidHash.
//
// If you change schash.c, you must touch scchk.c and scache.c
// so that they get rebuilt because they include schash.c

static __inline ULONG SChash(ULONG hkey, ULONG count)
{
    // count must be a PowerOf2
    return((hkey << 3) & (count - 1));
}

static __inline ULONG SCGuidHash(GUID hkey, ULONG count)
{
   // We just cast each byte of the 16-byte guid to an ulong,
   // and add them all up (so max value is (255 X 16), then
   // hash this sum as usual

   PUCHAR pVal = (PUCHAR) &hkey;
   ULONG i, val=0;

   for (i=0; i<sizeof(GUID); i++) {
       val += (*pVal);
       pVal++;
   }
    // pseudo-random
   return (val % (count - 1));
}

static __inline ULONG SCNameHash(ULONG size, PUCHAR pVal, ULONG count)
{
    ULONG val=0;
    while(size--) {
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        // val += (*pVal | 0x20);
        val = ((val << 7) - val) + (*pVal | 0x20);
        pVal++;
    }
    // pseudo-random
    return (val % (count - 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\syncp.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    syncp.h

Abstract:

    This module defines the private data structures for the synchronization
    library.

Author:

    Andrew E. Goodsell (andygo) 21-Jun-2001

Revision History:

--*/

#ifndef _SYNCP_
#define _SYNCP_




#endif  //  _SYNCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\sync.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sync.c

Abstract:

    This module contains the implemenation of the synchronization library.
    This library is designed to address the special needs of a high performance
    SMP server application.  Each synchronization primitive is designed with
    the following goals in mind:

    -  Mutual Exclusion, Progress, Bounded Waiting, and First Come First Served

        All primitives are designed to respect the traditional rules of
        synchronization.  No cheating or starvation is used to enhance
        performance in any way.
    
    -  Minimum overhead

        All methods are optimized to most efficiently handle the non-contention
        case.  The algorithms employed never add serialization of their own to
        the application.  Analytical support tools (deadlock detection,
        ownership information, and statistical data) are usually sacrificed for
        increased performance.
    
    -  Minimum resource consumption [NYI]

        The primitives have a very small memory footprint and use no external
        memory blocks or kernel resources.  This allows the number of objects
        in use to be limited only by available virtual memory.  This also gives
        the application the freedom to place the primitives with the data they
        protect for maximum cache locality.

    -  No out of resource conditions [NYI]

        The library will never fail the creation or use of a primitive due to
        low resources.  No special exception handling or error handling is
        required in these cases.

Author:

    Andrew E. Goodsell (andygo) 21-Jun-2001

Revision History:

    21-Jun-2001     andygo

        Implementation based on technology from \nt\ds\ese98\export\sync.hxx
        and \nt\ds\ese98\src\sync\sync.cxx

        HACK:  Only rw lock and binary lock are implemented so far and both use
        kernel semaphores.  This is to facilitate testing the impact that these
        locks will have on our performance.  If they do well then the semaphore
        primitive and all its required infrastructure will also be implemented.
        NOTE:  this hack means that an OOM exception can be thrown on create
        just as is done for InitializeCriticalSection.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include "sync.h"
#include "syncp.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB     "SYNC:"              // define the subsystem for debugging

#include <fileno.h>
#define FILENO FILENO_SYNC


//  Utilities

__inline
VOID
SyncpPause(
    )
{
#if defined( _M_IX86 )

    __asm rep nop

#else  //  !_M_IX86
#endif  //  _M_IX86
}

#define SYNC_FOREVER for ( ; ; SyncpPause() )


//  Binary Lock

VOID SyncpBLUpdateQuiescedOwnerCountAsGroup1(
    IN OUT  PSYNC_BINARY_LOCK   pbl,
    IN      const DWORD         cOwnerQuiescedDelta
    )
{
    DWORD cOwnerQuiescedBI;
    DWORD cOwnerQuiescedAI;
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  update the quiesced owner count using the provided delta

    cOwnerQuiescedBI = InterlockedExchangeAdd( &pbl->cOwnerQuiesced, cOwnerQuiescedDelta );
    cOwnerQuiescedAI = cOwnerQuiescedBI + cOwnerQuiescedDelta;

    //  our update resulted in a zero quiesced owner count

    if ( !cOwnerQuiescedAI ) {
        
        //  we must release the waiters for Group 2 because we removed the last
        //  quiesced owner count

        //  try forever until we successfully change the lock state

        SYNC_FOREVER {
            
            //  read the current state of the control word as our expected before image

            dwControlWordBIExpected = pbl->dwControlWord;

            //  compute the after image of the control word such that we jump from state
            //  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

            dwControlWordAI =   (DWORD)( dwControlWordBIExpected &
                                ( ( ( (LONG_PTR)( (long)( ( dwControlWordBIExpected + 0xFFFF7FFF ) << 16 ) ) >> 31 ) &
                                0xFFFF0000 ) ^ 0x8000FFFF ) );

            //  attempt to perform the transacted state transition on the control word

            dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded

            } else {
            
                //  we're done

                break;
            }
        }

        //  we just jumped from state 5 to state 3

        if ( dwControlWordBI & 0x00007FFF ) {
            
            //  update the quiesced owner count with the owner count that we displaced
            //  from the control word
            //
            //  NOTE:  we do not have to worry about releasing any more waiters because
            //  either this context owns one of the owner counts or at least one context
            //  that owns an owner count are currently blocked on the semaphore

            const DWORD cOwnerQuiescedDelta = ( dwControlWordBI & 0x7FFF0000 ) >> 16;
            InterlockedExchangeAdd( &pbl->cOwnerQuiesced, cOwnerQuiescedDelta );
        }

        //  release the waiters for Group 2 that we removed from the lock state

        ReleaseSemaphore( pbl->hsemGroup2, ( dwControlWordBI & 0x7FFF0000 ) >> 16, NULL );
    }
}

VOID SyncpBLUpdateQuiescedOwnerCountAsGroup2(
    IN OUT  PSYNC_BINARY_LOCK   pbl,
    IN      const DWORD         cOwnerQuiescedDelta
    )
{
    DWORD cOwnerQuiescedBI;
    DWORD cOwnerQuiescedAI;
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  update the quiesced owner count using the provided delta

    cOwnerQuiescedBI = InterlockedExchangeAdd( &pbl->cOwnerQuiesced, cOwnerQuiescedDelta );
    cOwnerQuiescedAI = cOwnerQuiescedBI + cOwnerQuiescedDelta;

    //  our update resulted in a zero quiesced owner count

    if ( !cOwnerQuiescedAI ) {
        
        //  we must release the waiters for Group 1 because we removed the last
        //  quiesced owner count

        //  try forever until we successfully change the lock state

        SYNC_FOREVER {
            
            //  read the current state of the control word as our expected before image

            dwControlWordBIExpected = pbl->dwControlWord;

            //  compute the after image of the control word such that we jump from state
            //  state 3 to state 2 or from state 5 to state 4, whichever is appropriate

            dwControlWordAI =   (DWORD)( dwControlWordBIExpected &
                                ( ( ( (LONG_PTR)( (long)( dwControlWordBIExpected + 0x7FFF0000 ) ) >> 31 ) &
                                0x0000FFFF ) ^ 0xFFFF8000 ) );

            //  attempt to perform the transacted state transition on the control word

            dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded

            } else {
            
                //  we're done

                break;
            }
        }

        //  we just jumped from state 5 to state 4

        if ( dwControlWordBI & 0x7FFF0000 ) {
            
            //  update the quiesced owner count with the owner count that we displaced
            //  from the control word
            //
            //  NOTE:  we do not have to worry about releasing any more waiters because
            //  either this context owns one of the owner counts or at least one context
            //  that owns an owner count are currently blocked on the semaphore

            const DWORD cOwnerQuiescedDelta = dwControlWordBI & 0x00007FFF;
            InterlockedExchangeAdd( &pbl->cOwnerQuiesced, cOwnerQuiescedDelta );
        }

        //  release the waiters for Group 1 that we removed from the lock state

        ReleaseSemaphore( pbl->hsemGroup1, dwControlWordBI & 0x00007FFF, NULL );
    }
}

VOID SyncpBLEnterAsGroup1(
    IN OUT  PSYNC_BINARY_LOCK   pbl,
    IN      const DWORD         dwControlWordBI
    )
{
    //  we just jumped from state 1 to state 3

    if ( ( dwControlWordBI & 0x80008000 ) == 0x00008000 ) {
        
        //  update the quiesced owner count with the owner count that we displaced from
        //  the control word, possibly releasing waiters.  we update the count as if we
        //  were a member of Group 2 as members of Group 1 can be released

        SyncpBLUpdateQuiescedOwnerCountAsGroup2( pbl, ( dwControlWordBI & 0x7FFF0000 ) >> 16 );
    }

    //  wait for ownership of the lock on our semaphore

    WaitForSingleObject( pbl->hsemGroup1, INFINITE );
}

VOID SyncpBLEnterAsGroup2(
    IN OUT  PSYNC_BINARY_LOCK   pbl,
    IN      const DWORD         dwControlWordBI
    )
{
    //  we just jumped from state 2 to state 4

    if ( ( dwControlWordBI & 0x80008000 ) == 0x80000000 ) {
        
        //  update the quiesced owner count with the owner count that we displaced from
        //  the control word, possibly releasing waiters.  we update the count as if we
        //  were a member of Group 1 as members of Group 2 can be released

        SyncpBLUpdateQuiescedOwnerCountAsGroup1( pbl, dwControlWordBI & 0x00007FFF );
    }

    //  wait for ownership of the lock on our semaphore

    WaitForSingleObject( pbl->hsemGroup2, INFINITE );
}

VOID SyncCreateBinaryLock(
    OUT     PSYNC_BINARY_LOCK   pbl
    )
{
    memset( pbl, 0, sizeof( SYNC_BINARY_LOCK ) );

    pbl->hsemGroup1 = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL );
    pbl->hsemGroup2 = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL );

    if ( !pbl->hsemGroup1 || !pbl->hsemGroup2 ) {
        if ( pbl->hsemGroup1 ) {
            CloseHandle( pbl->hsemGroup1 );
            pbl->hsemGroup1 = NULL;
        }
        if ( pbl->hsemGroup2 ) {
            CloseHandle( pbl->hsemGroup2 );
            pbl->hsemGroup2 = NULL;
        }
        RaiseException( STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL );
    }
}

VOID SyncDestroyBinaryLock(
    IN      PSYNC_BINARY_LOCK   pbl
    )
{
    if ( pbl->hsemGroup1 ) {
        CloseHandle( pbl->hsemGroup1 );
        pbl->hsemGroup1 = NULL;
    }
    if ( pbl->hsemGroup2 ) {
        CloseHandle( pbl->hsemGroup2 );
        pbl->hsemGroup2 = NULL;
    }
}

VOID SyncEnterBinaryLockAsGroup1(
    IN OUT  PSYNC_BINARY_LOCK   pbl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
    
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = pbl->dwControlWord;

        //  compute the after image of the control word by performing the global
        //  transform for the Enter1 state transition

        dwControlWordAI =   (DWORD)( ( ( dwControlWordBIExpected & ( ( (LONG_PTR)( (long)( dwControlWordBIExpected ) ) >> 31 ) |
                            0x0000FFFF ) ) | 0x80000000 ) + 0x00000001 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed or Group 1 was quiesced from ownership

        if ( ( dwControlWordBI ^ dwControlWordBIExpected ) | ( dwControlWordBI & 0x00008000 ) ) {
            
            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded but Group 1 was quiesced from ownership

            } else {
            
                //  wait to own the lock as a member of Group 1

                SyncpBLEnterAsGroup1( pbl, dwControlWordBI );

                //  we now own the lock, so we're done

                break;
            }

        //  the transaction succeeded and Group 1 was not quiesced from ownership

        } else {
        
            //  we now own the lock, so we're done

            break;
        }
    }
}

BOOL SyncTryEnterBinaryLockAsGroup1(
    IN OUT  PSYNC_BINARY_LOCK   pbl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = pbl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  Group 1 ownership is not quiesced

        dwControlWordBIExpected = dwControlWordBIExpected & 0xFFFF7FFF;

        //  compute the after image of the control word by performing the global
        //  transform for the Enter1 state transition

        dwControlWordAI =   (DWORD)( ( ( dwControlWordBIExpected & ( ( (LONG_PTR)( (long)( dwControlWordBIExpected ) ) >> 31 ) |
                            0x0000FFFF ) ) | 0x80000000 ) + 0x00000001 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because Group 1 ownership is quiesced

            if ( dwControlWordBI & 0x00008000 ) {
                
                //  return failure

                return FALSE;

            //  the transaction failed because another context changed the control word

            } else {
            
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
        
            //  return success

            return TRUE;
        }
    }
}

VOID SyncLeaveBinaryLockAsGroup1(
    IN OUT  PSYNC_BINARY_LOCK   pbl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
    
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = pbl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  Group 1 ownership is not quiesced

        dwControlWordBIExpected = dwControlWordBIExpected & 0xFFFF7FFF;

        //  compute the after image of the control word by performing the transform that
        //  will take us either from state 2 to state 0 or state 2 to state 2

        dwControlWordAI = dwControlWordBIExpected + 0xFFFFFFFF;
        dwControlWordAI = dwControlWordAI - ( ( ( dwControlWordAI + 0xFFFFFFFF ) << 16 ) & 0x80000000 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because Group 1 ownership is quiesced

            if ( dwControlWordBI & 0x00008000 ) {
                
                //  leave the lock as a quiesced owner

                SyncpBLUpdateQuiescedOwnerCountAsGroup1( pbl, 0xFFFFFFFF );

                //  we're done

                break;

            //  the transaction failed because another context changed the control word

            } else {
                
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
            
            // we're done

            break;
        }
    }
}

VOID SyncEnterBinaryLockAsGroup2(
    IN OUT  PSYNC_BINARY_LOCK   pbl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = pbl->dwControlWord;

        //  compute the after image of the control word by performing the global
        //  transform for the Enter2 state transition

        dwControlWordAI =   (DWORD)( ( ( dwControlWordBIExpected & ( ( (LONG_PTR)( (long)( dwControlWordBIExpected << 16 ) ) >> 31 ) |
                            0xFFFF0000 ) ) | 0x00008000 ) + 0x00010000 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed or Group 2 was quiesced from ownership

        if ( ( dwControlWordBI ^ dwControlWordBIExpected ) | ( dwControlWordBI & 0x80000000 ) ) {
            
            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded but Group 2 was quiesced from ownership

            } else {
                
                //  wait to own the lock as a member of Group 2

                SyncpBLEnterAsGroup2( pbl, dwControlWordBI );

                //  we now own the lock, so we're done

                break;
            }

        //  the transaction succeeded and Group 2 was not quiesced from ownership

        } else {
        
            //  we now own the lock, so we're done

            break;
        }
    }
}

BOOL SyncTryEnterBinaryLockAsGroup2(
    IN OUT  PSYNC_BINARY_LOCK   pbl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = pbl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  Group 2 ownership is not quiesced

        dwControlWordBIExpected = dwControlWordBIExpected & 0x7FFFFFFF;

        //  compute the after image of the control word by performing the global
        //  transform for the Enter2 state transition

        dwControlWordAI =   (DWORD)( ( ( dwControlWordBIExpected & ( ( (LONG_PTR)( (long)( dwControlWordBIExpected << 16 ) ) >> 31 ) |
                            0xFFFF0000 ) ) | 0x00008000 ) + 0x00010000 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because Group 2 ownership is quiesced

            if ( dwControlWordBI & 0x80000000 ) {
                
                //  return failure

                return FALSE;

            //  the transaction failed because another context changed the control word

            } else {
            
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
        
            //  return success

            return TRUE;
        }
    }
}

VOID SyncLeaveBinaryLockAsGroup2(
    IN OUT  PSYNC_BINARY_LOCK   pbl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = pbl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  Group 2 ownership is not quiesced

        dwControlWordBIExpected = dwControlWordBIExpected & 0x7FFFFFFF;

        //  compute the after image of the control word by performing the transform that
        //  will take us either from state 1 to state 0 or state 1 to state 1

        dwControlWordAI = dwControlWordBIExpected + 0xFFFF0000;
        dwControlWordAI = dwControlWordAI - ( ( ( dwControlWordAI + 0xFFFF0000 ) >> 16 ) & 0x00008000 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &pbl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because Group 2 ownership is quiesced

            if ( dwControlWordBI & 0x80000000 ) {
                
                //  leave the lock as a quiesced owner

                SyncpBLUpdateQuiescedOwnerCountAsGroup2( pbl, 0xFFFFFFFF );

                //  we're done

                break;

            //  the transaction failed because another context changed the control word

            } else {
            
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
        
            // we're done

            break;
        }
    }
}



//  Reader / Writer Lock

VOID SyncpRWLUpdateQuiescedOwnerCountAsWriter(
    IN OUT  PSYNC_RW_LOCK       prwl,
    IN      const DWORD         cOwnerQuiescedDelta
    )
{
    DWORD cOwnerQuiescedBI;
    DWORD cOwnerQuiescedAI;
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  update the quiesced owner count using the provided delta

    cOwnerQuiescedBI = InterlockedExchangeAdd( &prwl->cOwnerQuiesced, cOwnerQuiescedDelta );
    cOwnerQuiescedAI = cOwnerQuiescedBI + cOwnerQuiescedDelta;

    //  our update resulted in a zero quiesced owner count

    if ( !cOwnerQuiescedAI ) {
        
        //  we must release the waiting readers because we removed the last
        //  quiesced owner count

        //  try forever until we successfully change the lock state

        SYNC_FOREVER {
            
            //  read the current state of the control word as our expected before image

            dwControlWordBIExpected = prwl->dwControlWord;

            //  compute the after image of the control word such that we jump from state
            //  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

            dwControlWordAI =   (DWORD)( dwControlWordBIExpected &
                                ( ( ( (LONG_PTR)( (long)( ( dwControlWordBIExpected + 0xFFFF7FFF ) << 16 ) ) >> 31 ) &
                                0xFFFF0000 ) ^ 0x8000FFFF ) );

            //  attempt to perform the transacted state transition on the control word

            dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded

            } else {
            
                //  we're done

                break;
            }
        }

        //  we just jumped from state 5 to state 3

        if ( dwControlWordBI & 0x00007FFF ) {
            
            //  update the quiesced owner count with the owner count that we displaced
            //  from the control word
            //
            //  NOTE:  we do not have to worry about releasing any more waiters because
            //  either this context owns one of the owner counts or at least one context
            //  that owns an owner count are currently blocked on the semaphore

            const DWORD cOwnerQuiescedDelta = ( dwControlWordBI & 0x7FFF0000 ) >> 16;
            InterlockedExchangeAdd( &prwl->cOwnerQuiesced, cOwnerQuiescedDelta );
        }

        //  release the waiting readers that we removed from the lock state

        ReleaseSemaphore( prwl->hsemReader, ( dwControlWordBI & 0x7FFF0000 ) >> 16, NULL );
    }
}

VOID SyncpRWLUpdateQuiescedOwnerCountAsReader(
    IN OUT  PSYNC_RW_LOCK       prwl,
    IN      const DWORD         cOwnerQuiescedDelta
    )
{
    DWORD cOwnerQuiescedBI;
    DWORD cOwnerQuiescedAI;
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  update the quiesced owner count using the provided delta

    cOwnerQuiescedBI = InterlockedExchangeAdd( &prwl->cOwnerQuiesced, cOwnerQuiescedDelta );
    cOwnerQuiescedAI = cOwnerQuiescedBI + cOwnerQuiescedDelta;

    //  our update resulted in a zero quiesced owner count

    if ( !cOwnerQuiescedAI ) {
        
        //  we must release a waiting writer because we removed the last
        //  quiesced owner count

        //  try forever until we successfully change the lock state

        SYNC_FOREVER {
            
            //  read the current state of the control word as our expected before image

            dwControlWordBIExpected = prwl->dwControlWord;

            //  compute the after image of the control word such that we jump from state
            //  state 3 to state 2, from state 5 to state 4, or from state 5 to state 5,
            //  whichever is appropriate

            dwControlWordAI =   dwControlWordBIExpected +
                                ( ( dwControlWordBIExpected & 0x7FFF0000 ) ? 0xFFFFFFFF : 0xFFFF8000 );

            //  attempt to perform the transacted state transition on the control word

            dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded

            } else {
            
                //  we're done

                break;
            }
        }

        //  we just jumped from state 5 to state 4 or from state 5 to state 5

        if ( dwControlWordBI & 0x7FFF0000 ) {
            
            //  update the quiesced owner count with the owner count that we displaced
            //  from the control word
            //
            //  NOTE:  we do not have to worry about releasing any more waiters because
            //  either this context owns one of the owner counts or at least one context
            //  that owns an owner count are currently blocked on the semaphore

            const DWORD cOwnerQuiescedDelta = 1;
            InterlockedExchangeAdd( &prwl->cOwnerQuiesced, cOwnerQuiescedDelta );
        }

        //  release the waiting writer that we removed from the lock state

        ReleaseSemaphore( prwl->hsemWriter, 1, NULL );
    }
}

VOID SyncpRWLEnterAsWriter(
    IN OUT  PSYNC_RW_LOCK       prwl,
    IN      const DWORD         dwControlWordBI
    )
{
    //  we just jumped from state 1 to state 3

    if ( ( dwControlWordBI & 0x80008000 ) == 0x00008000 ) {
        
        //  update the quiesced owner count with the owner count that we displaced from
        //  the control word, possibly releasing a waiter.  we update the count as if we
        //  were a reader as a writer can be released

        SyncpRWLUpdateQuiescedOwnerCountAsReader( prwl, ( dwControlWordBI & 0x7FFF0000 ) >> 16 );
    }

    //  wait for ownership of the lock on our semaphore

    WaitForSingleObject( prwl->hsemWriter, INFINITE );
}

VOID SyncpRWLEnterAsReader(
    IN OUT  PSYNC_RW_LOCK       prwl,
    IN      const DWORD         dwControlWordBI
    )
{
    //  we just jumped from state 2 to state 4 or from state 2 to state 5

    if ( ( dwControlWordBI & 0x80008000 ) == 0x80000000 ) {
        
        //  update the quiesced owner count with the owner count that we displaced from
        //  the control word, possibly releasing waiters.  we update the count as if we
        //  were a writer as readers can be released

        SyncpRWLUpdateQuiescedOwnerCountAsWriter( prwl, 0x00000001 );
    }

    //  wait for ownership of the lock on our semaphore

    WaitForSingleObject( prwl->hsemReader, INFINITE );
}

VOID SyncCreateRWLock(
    OUT     PSYNC_RW_LOCK       prwl
    )
{
    memset( prwl, 0, sizeof( SYNC_BINARY_LOCK ) );

    prwl->hsemWriter    = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL );
    prwl->hsemReader    = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL );

    if ( !prwl->hsemWriter || !prwl->hsemReader ) {
        if ( prwl->hsemWriter ) {
            CloseHandle( prwl->hsemWriter );
            prwl->hsemWriter = NULL;
        }
        if ( prwl->hsemReader ) {
            CloseHandle( prwl->hsemReader );
            prwl->hsemReader = NULL;
        }
        RaiseException( STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL );
    }
}

VOID SyncDestroyRWLock(
    IN      PSYNC_RW_LOCK       prwl
    )
{
    if ( prwl->hsemWriter ) {
        CloseHandle( prwl->hsemWriter );
        prwl->hsemWriter = NULL;
    }
    if ( prwl->hsemReader ) {
        CloseHandle( prwl->hsemReader );
        prwl->hsemReader = NULL;
    }
}

VOID SyncEnterRWLockAsWriter(
    IN OUT  PSYNC_RW_LOCK       prwl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = prwl->dwControlWord;

        //  compute the after image of the control word by performing the global
        //  transform for the EnterAsWriter state transition

        dwControlWordAI =   (DWORD)( ( ( dwControlWordBIExpected & ( ( (LONG_PTR)( (long)( dwControlWordBIExpected ) ) >> 31 ) |
                            0x0000FFFF ) ) | 0x80000000 ) + 0x00000001 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed or writers are quiesced from ownership or a
        //  writer already owns the lock

        if ( ( dwControlWordBI ^ dwControlWordBIExpected ) | ( dwControlWordBI & 0x0000FFFF ) ) {
            
            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded but writers are quiesced from ownership
            //  or a writer already owns the lock

            } else {
            
                //  wait to own the lock as a writer

                SyncpRWLEnterAsWriter( prwl, dwControlWordBI );

                //  we now own the lock, so we're done

                break;
            }

        //  the transaction succeeded and writers were not quiesced from ownership
        //  and a writer did not already own the lock

        } else {
        
            //  we now own the lock, so we're done

            break;
        }
    }
}

BOOL SyncTryEnterRWLockAsWriter(
    IN OUT  PSYNC_RW_LOCK       prwl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = prwl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  writers were not quiesced from ownership and another writer doesn't already
        //  own the lock

        dwControlWordBIExpected = dwControlWordBIExpected & 0xFFFF0000;

        //  compute the after image of the control word by performing the global
        //  transform for the EnterAsWriter state transition

        dwControlWordAI =   (DWORD)( ( ( dwControlWordBIExpected & ( ( (LONG_PTR)( (long)( dwControlWordBIExpected ) ) >> 31 ) |
                            0x0000FFFF ) ) | 0x80000000 ) + 0x00000001 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because writers were quiesced from ownership
            //  or another writer already owns the lock

            if ( dwControlWordBI & 0x0000FFFF ) {
                
                //  return failure

                return FALSE;

            //  the transaction failed because another context changed the control word

            } else {
            
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
        
            // return success

            return TRUE;
        }
    }
}

VOID SyncLeaveRWLockAsWriter(
    IN OUT  PSYNC_RW_LOCK       prwl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = prwl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  writers were not quiesced from ownership

        dwControlWordBIExpected = dwControlWordBIExpected & 0xFFFF7FFF;

        //  compute the after image of the control word by performing the transform that
        //  will take us either from state 2 to state 0 or state 2 to state 2

        dwControlWordAI = dwControlWordBIExpected + 0xFFFFFFFF;
        dwControlWordAI = dwControlWordAI - ( ( ( dwControlWordAI + 0xFFFFFFFF ) << 16 ) & 0x80000000 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because writers were quiesced from ownership

            if ( dwControlWordBI & 0x00008000 ) {
                
                //  leave the lock as a quiesced owner

                SyncpRWLUpdateQuiescedOwnerCountAsWriter( prwl, 0xFFFFFFFF );

                //  we're done

                break;

            //  the transaction failed because another context changed the control word

            } else {
            
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
        
            //  there were other writers waiting for ownership of the lock

            if ( dwControlWordAI & 0x00007FFF ) {
                
                //  release the next writer into ownership of the lock

                ReleaseSemaphore( prwl->hsemWriter, 1, NULL );
            }
            
            // we're done

            break;
        }
    }
}

VOID SyncEnterRWLockAsReader(
    IN OUT  PSYNC_RW_LOCK       prwl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = prwl->dwControlWord;

        //  compute the after image of the control word by performing the global
        //  transform for the EnterAsReader state transition

        dwControlWordAI =   ( dwControlWordBIExpected & 0xFFFF7FFF ) +
                            (   ( dwControlWordBIExpected & 0x80008000 ) == 0x80000000 ?
                                    0x00017FFF :
                                    0x00018000 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed or readers were quiesced from ownership

        if ( ( dwControlWordBI ^ dwControlWordBIExpected ) | ( dwControlWordBI & 0x80000000 ) ) {
            
            //  the transaction failed because another context changed the control word

            if ( dwControlWordBI != dwControlWordBIExpected ) {
                
                //  try again

                continue;

            //  the transaction succeeded but readers were quiesced from ownership

            } else {

                //  wait to own the lock as a reader

                SyncpRWLEnterAsReader( prwl, dwControlWordBI );

                //  we now own the lock, so we're done

                break;
            }

        //  the transaction succeeded and readers were not quiesced from ownership

        } else {
        
            //  we now own the lock, so we're done

            break;
        }
    }
}

BOOL SyncTryEnterRWLockAsReader(
    IN OUT  PSYNC_RW_LOCK       prwl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = prwl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  readers were not quiesced from ownership

        dwControlWordBIExpected = dwControlWordBIExpected & 0x7FFFFFFF;

        //  compute the after image of the control word by performing the global
        //  transform for the EnterAsReader state transition

        dwControlWordAI =   ( dwControlWordBIExpected & 0xFFFF7FFF ) +
                            (   ( dwControlWordBIExpected & 0x80008000 ) == 0x80000000 ?
                                    0x00017FFF :
                                    0x00018000 );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because readers were quiesced from ownership

            if ( dwControlWordBI & 0x80000000 ) {
                
                //  return failure

                return FALSE;

            //  the transaction failed because another context changed the control word

            } else {
            
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
        
            // return success

            return TRUE;
        }
    }
}

VOID SyncLeaveRWLockAsReader(
    IN OUT  PSYNC_RW_LOCK       prwl
    )
{
    DWORD dwControlWordBIExpected;
    DWORD dwControlWordAI;
    DWORD dwControlWordBI;
    
    //  try forever until we successfully change the lock state

    SYNC_FOREVER {
        
        //  read the current state of the control word as our expected before image

        dwControlWordBIExpected = prwl->dwControlWord;

        //  change the expected before image so that the transaction will only work if
        //  readers were not quiesced from ownership

        dwControlWordBIExpected = dwControlWordBIExpected & 0x7FFFFFFF;

        //  compute the after image of the control word by performing the transform that
        //  will take us either from state 1 to state 0 or state 1 to state 1

        dwControlWordAI =   (DWORD)( dwControlWordBIExpected + 0xFFFF0000 +
                            ( ( (LONG_PTR)( (long)( dwControlWordBIExpected + 0xFFFE0000 ) ) >> 31 ) & 0xFFFF8000 ) );

        //  attempt to perform the transacted state transition on the control word

        dwControlWordBI = InterlockedCompareExchange( &prwl->dwControlWord, dwControlWordAI, dwControlWordBIExpected );

        //  the transaction failed

        if ( dwControlWordBI != dwControlWordBIExpected ) {
            
            //  the transaction failed because readers were quiesced from ownership

            if ( dwControlWordBI & 0x80000000 ) {
                
                //  leave the lock as a quiesced owner

                SyncpRWLUpdateQuiescedOwnerCountAsReader( prwl, 0xFFFFFFFF );

                //  we're done

                break;

            //  the transaction failed because another context changed the control word

            } else {
            
                //  try again

                continue;
            }

        //  the transaction succeeded

        } else {
        
            // we're done

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\standardizesd.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 2002
//
//  File:       StandardizeSD.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include "seopaque.h"
//
// Macro definition to make ACL traversal to work.
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

int __cdecl
pfnAceCompare(
    const void *ptr1,
    const void *ptr2
    )
/*++

Routine Description:

    This routine compares two ACEs based on very simple criteria. The criteria may
    be changed during development.

    This function should NEVER be changed once we ship!!

    Note that the simple brute force comparison function works the best given
    the size of our input.

Arguments:

    ptr1 - Pointer to a PACE_HEADER structure.

    ptr2 - Pointer to a PACE_HEADER structure.

Return Value:
    -1 is ACE1 is "smaller" than ACE2
    1 is ACE2 is "smaller" than ACE1
    0 if they are equal
    
--*/
{
    PACE_HEADER pAce1 = *(PACE_HEADER *) ptr1;
    PACE_HEADER pAce2 = *(PACE_HEADER *) ptr2;


    //
    // Smaller ACE wins
    //

    if (pAce1->AceSize > pAce2->AceSize) {
        return -1;
    }

    if (pAce1->AceSize < pAce2->AceSize) {
        return 1;
    }

    //
    // The ACEs are equal in size. Use memcmp to decide who wins.
    //

    return memcmp(pAce1, pAce2, pAce1->AceSize);
}

        
VOID
StandardizeAcl(
    IN PACL pAcl, 
    IN PVOID pOriginalAcl,
    IN ULONG ExplicitAceCnt,
    IN ULONG ExplicitAclSize,
    IN OUT PACL pTempAcl, 
    IN OUT PUCHAR pNewAcl, 
    OUT PULONG pAclSizeSaved
    )

/*++

Routine Description:

    This routine takes an ACL as its input, sorts it in a known order defined by 
    pfnAceCompare function and removes duplicates, if any. It will be called iff
    the number of explicit ACEs in the ACL part is more than one. This routine is
    a worker routine for both DACLs as well as SACLs. It is called not more than
    once for the SACL; not more than twice for the DACL - once for Deny part and
    once for Allow part.

Arguments:

    pAcl - Pointer to the header of the new ACL.

    pOriginalAcl - Pointer to the beginning of the original ACEs.

    ExplicitAceCnt - The number of explicit ACEs we are going to deal with in 
        this pass.
    
    ExplicitAclSize - The size required to hold the explicit part in this pass.

    pTempAcl - Pointer to the memory allocated to work on the ACL for sorting.
    
    pNewAcl - Where the sorted ACEs should be put.
        
    pAclSizeSaved - To return the space saved in the ACL by removing duplicate
        ACEs.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/
{
    PVOID *ppPointerArray = (PVOID *) (((PUCHAR) pTempAcl) + PtrAlignSize(ExplicitAclSize));
    PACE_HEADER pAce = NULL;
    ULONG j = 0;

    //
    // Copy the explicit ACEs into temporary space.
    //

    RtlCopyMemory(pTempAcl, pOriginalAcl, ExplicitAclSize);

    pAce = (PACE_HEADER) pTempAcl;

    //
    // The array for sorting starts where the explicit part of the ACL ends.
    //

    *ppPointerArray = ((PUCHAR) pTempAcl) + ExplicitAclSize;

    //
    // Initialize the array with pointers to ACEs in the temporary part.
    //

    for (j = 0; j < ExplicitAceCnt; pAce = (PACE_HEADER) NextAce(pAce), j++) {
        ppPointerArray[j] = pAce;
    }

    //
    // Sort the given part of the ACL.
    //

    qsort(ppPointerArray, ExplicitAceCnt, sizeof(PVOID), pfnAceCompare);

    //
    // Now copy the ACL from temp memory into the existing space.
    // We start by copying the fisrt ACE and then loop thru the rest.
    //

    RtlCopyMemory(pNewAcl, ppPointerArray[0], ((PACE_HEADER) ppPointerArray[0])->AceSize);
    pNewAcl += ((PACE_HEADER) ppPointerArray[0])->AceSize;

    //
    // Loop thru rest of the ACEs.
    //

    for (j = 1; j < ExplicitAceCnt; j++) {

        //
        // This is where we remove duplicates.
        //

        if (0 == pfnAceCompare(&ppPointerArray[j-1], &ppPointerArray[j])) {

            //
            // The two ACEs are equal. There is no need to copy this one.
            // Change the AceCount and AceSize in the original ACL.
            //

            pAcl->AceCount--;
            pAcl->AclSize -= ((PACE_HEADER) ppPointerArray[j])->AceSize;


            //
            // Record that we have saved space for this ACE.
            //

            *pAclSizeSaved += ((PACE_HEADER) ppPointerArray[j])->AceSize;
            
        } else {

            //
            // Copy the ACE into its place.
            //

            RtlCopyMemory(pNewAcl, ppPointerArray[j], ((PACE_HEADER) ppPointerArray[j])->AceSize);
            pNewAcl += ((PACE_HEADER) ppPointerArray[j])->AceSize;
        }
    }
}

VOID
StandardizeDacl(
    IN PACL pAcl, 
    IN ULONG ExplicitDenyAceCnt,
    IN ULONG ExplicitDenyAclSize,
    IN ULONG ExplicitAceCnt,
    IN ULONG ExplicitAclSize,
    IN OUT PACL pTempAcl, 
    IN OUT PUCHAR pNewAcl, 
    OUT PULONG pAclSizeSaved
    )
/*++

Routine Description:

    This routine takes a DACL as its input, sorts it in a known order defined by 
    pfnAceCompare function and removes duplicates, if any. It will be called iff
    the number of explicit ACEs in the DACL is more than one.

Arguments:

    pAcl - Pointer to the DACL.

    ExplicitDenyAceCnt - The number of explicit deny ACEs in the DACL.
    
    ExplicitDenyAclSize - The size required to hold the explicit deny part of the DACL.

    ExplicitAceCnt - The number of explicit ACEs in the DACL.
    
    ExplicitAclSize - The size required to hold the explicit part of the DACL.

    pTempAcl - Pointer to the memory allocated to work on the ACL for sorting.
    
    pNewAcl- Where the new ACL should start. For DACLs, the new ACL will be
        shifted shifted up by the space saved on the SACL.
        
    pAclSizeSaved - To return the space saved in the DACL by removing duplicate
        ACEs.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/
{

    //
    // Save the ACL header. This may be needed later for copying the inherited 
    // ACEs.
    //
    ACL LocalAcl = *pAcl;

    // 
    // Copy the old ACL header into the new one. These two pointers will be 
    // different when we have saved space on the SACL.
    //

    if ((PACL)pNewAcl != pAcl) {
        *((PACL) pNewAcl) = LocalAcl;
    }

    //
    // Sort and removed duplicates from the Explicit Deny ACEs in the DACL.
    //

    if (ExplicitDenyAceCnt > 0 && ((PACL)pNewAcl != pAcl || ExplicitDenyAceCnt > 1)) {
        StandardizeAcl(
            (PACL) pNewAcl, 
            ((PUCHAR) pAcl) + sizeof(ACL), 
            ExplicitDenyAceCnt, 
            ExplicitDenyAclSize, 
            pTempAcl,
            ((PUCHAR) pNewAcl) + sizeof(ACL), 
            pAclSizeSaved
            );
    }

    //
    // Sort and removed duplicates from the Explicit Allow ACEs in the DACL.
    //

    if ((ExplicitAceCnt - ExplicitDenyAceCnt) > 0) {
        StandardizeAcl(
            (PACL) pNewAcl, 
            ((PUCHAR) pAcl) + sizeof(ACL) + ExplicitDenyAclSize,
            ExplicitAceCnt - ExplicitDenyAceCnt, 
            ExplicitAclSize - ExplicitDenyAclSize, 
            pTempAcl,
            ((PUCHAR) pNewAcl) + sizeof(ACL) + ExplicitDenyAclSize - *pAclSizeSaved, 
            pAclSizeSaved
            );
    } 

    //
    // If we removed any duplicates, then copy the inherited ACEs as well.
    // Also, copy them if pNewAcl is at a different location from the original pAcl
    //

    if (((PACL)pNewAcl != pAcl || 0 != *pAclSizeSaved) && (0 != (LocalAcl.AclSize - (ExplicitAclSize + sizeof(ACL))))) {
        RtlMoveMemory(
            ((PUCHAR) pNewAcl) + ExplicitAclSize + sizeof(ACL) - *pAclSizeSaved,
            ((PUCHAR) pAcl) + ExplicitAclSize + sizeof(ACL),
            LocalAcl.AclSize - (ExplicitAclSize + sizeof(ACL))
            );
    }
}

VOID
StandardizeSacl(
    IN PACL pAcl,     
    IN ULONG ExplicitAceCnt,
    IN ULONG ExplicitAclSize,
    IN OUT PACL pTempAcl, 
    IN OUT PUCHAR pNewAcl, 
    OUT PULONG pAclSizeSaved
    )
/*++

Routine Description:

    This routine takes a SACL as its input, sorts it in a known order defined by 
    pfnAceCompare function and removes duplicates, if any. It will be called iff
    the number of explicit ACEs in the SACL is more than one.

Arguments:

    pAcl - Pointer to the SACL.

    ExplicitAceCnt - The number of explicit ACEs in the SACL.
    
    ExplicitAclSize - The size required to hold the explicit part of the SACL.

    pTempAcl - Pointer to the memory allocated to work on the ACL for sorting.
    
    pNewAcl- Where the new ACL should start. For SACLs, the new ACL would always
        be at the same place as the original one.
        
    pAclSizeSaved - To return the space saved in the SACL by removing duplicate
        ACEs.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/
{

    //
    // Save the ACL header. This may be needed later for copying the inherited 
    // ACEs.
    //

    ACL LocalAcl = *pAcl;

    //
    // Sort and removed duplicates from the Explicit ACEs in the SACL.
    //

    StandardizeAcl(
        pAcl, 
        ((PUCHAR) pAcl) + sizeof(ACL), 
        ExplicitAceCnt, 
        ExplicitAclSize, 
        pTempAcl, 
        ((PUCHAR) pNewAcl) + sizeof(ACL), 
        pAclSizeSaved
        );

    //
    // If we removed any duplicates, then copy the inherited ACEs as well.
    //

    if ((0 != *pAclSizeSaved) && (0 != (LocalAcl.AclSize - (ExplicitAclSize + sizeof(ACL))))) {
        RtlMoveMemory(
            ((PUCHAR) pNewAcl) + ExplicitAclSize + sizeof(ACL) - *pAclSizeSaved,
            ((PUCHAR) pAcl) + ExplicitAclSize + sizeof(ACL),
            LocalAcl.AclSize - (ExplicitAclSize + sizeof(ACL))
            );
    }
                             

}

BOOL
ComputeAclInfo(
    IN PACL pAcl,
    OUT PULONG pExplicitDenyAceCnt,
    OUT PULONG pExplicitDenyAclSize,
    OUT PULONG pExplicitAceCnt,
    OUT PULONG pExplicitAclSize
    )
/*++

Routine Description:

    This routine takes an ACL as its input and returns information about the explicit 
    part of the ACL.

Arguments:

    pAcl - Pointer to the ACL.

    pExplicitDenyAceCnt - To return the number of Explicit Deny ACEs. This value
        is ignored by the SACL routine.
    
    pExplicitDenyAclSize - To return the size required to hold the Deny ACEs. This
        value is ignored by the SACL routine.
        
    pExplicitAceCnt - To return the total number of explicit ACEs in the ACL.
    
    pExplicitAclSize - To return the size required to hold all the explicit ACEs
        in the ACL.
        

Note: DACLs are expected to be in canonical form. We do not look at the part 
      beyond the first inherited ACE. We know that explicit ACEs will not exist
      after we ahve seen the first inherited one since this is a result from the
      Create/SetPrivateObject* API.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/
{
    USHORT      j;
    USHORT      AceCnt;
    PACE_HEADER pAce;

    *pExplicitAceCnt = 0;
    *pExplicitAclSize = 0;
    *pExplicitDenyAclSize = 0;
    *pExplicitDenyAceCnt = 0;

    //
    // Handle the trivial case.
    //

    if ((NULL == pAcl) || (0 == pAcl->AceCount))
    {
        return TRUE;
    }

    AceCnt = pAcl->AceCount;

    pAce = (PACE_HEADER) FirstAce(pAcl);

    //
    // Loop thru the non-Allow ACEs. 
    //

    for (j = 0; j < AceCnt; pAce = (PACE_HEADER) NextAce(pAce), j++) {

        //
        // This is the first inherited ACE. Our work is done.
        //

        if (0 != (pAce->AceFlags & INHERITED_ACE)) {
            *pExplicitAceCnt = *pExplicitDenyAceCnt = j;
            return TRUE;
        }

        //
        // Break when the first ALLOW ACE is seen. This condition will never be 
        // TRUE for SACLs.
        //

        if ((ACCESS_ALLOWED_ACE_TYPE == pAce->AceType) ||
            (ACCESS_ALLOWED_OBJECT_ACE_TYPE == pAce->AceType)) {
            break;
        }

        //
        // Record that we have seen this ACE.
        //

        *pExplicitAclSize += pAce->AceSize;
        *pExplicitDenyAclSize += pAce->AceSize;

    }

    //
    // We have looked at all the non-Allow ACEs.
    //

    *pExplicitDenyAceCnt = j;

    //
    // Note that we can never enter this loop for a SACL.
    //

    for (; j < AceCnt; pAce = (PACE_HEADER) NextAce(pAce), j++) {
        //
        // This is the first inherited ACE. Our work is done.
        //

        if (0 != (pAce->AceFlags & INHERITED_ACE)) {
            *pExplicitAceCnt = j;
            return TRUE;
        }

        if ((ACCESS_DENIED_ACE_TYPE == pAce->AceType) ||
            (ACCESS_DENIED_OBJECT_ACE_TYPE == pAce->AceType)) {
            //
            // This DACL is in non-canonical form. We will return an error that
            // is distinct from others.
            //

            SetLastError(ERROR_INVALID_SECURITY_DESCR);

            return FALSE;
        }

        *pExplicitAclSize += pAce->AceSize;

    }

    //
    // If we got here, all the ACEs are explicit ACEs. Record that and return.
    //

    *pExplicitAceCnt = j;

    return TRUE;
}


BOOL
StandardizeSecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PDWORD pDaclSizeSaved,
    OUT PDWORD pSaclSizeSaved
    )
/*++

Routine Description:

    This routine takes a Security Descriptor as its input and standardizes the ACLS,
    if present. Standardizing involves sorting and removing duplicates from the 
    explicit part of the ACLs. It will also rearrange the other fields in the
    security descriptor if any space has been saved by removing duplicates ACEs.

Arguments:

    SecurityDescriptor - Input to the function. This must be a result of 
        CreatePrivateObjectSecurity* and in NT canonical form.

    pDaclSizeSaved - To return the space saved by deleting duplicate explicit ACEs
        from the DACL. The DACL must be in NT canonical form.

    pSaclSizeSaved - To return the space saved by deleting duplicate explicit ACEs
        from the SACL.
    

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

    Errors returned from this function should only be used for debugging purposes.
    One should never get any errors back unless the Security Descriptor is not
    in NT-canonical form.

    Even in case of errors, the security descriptor is always good to be set on
    the object.

--*/
{

    PACL pDacl = NULL;
    PACL pSacl = NULL;
    PACL pTempAcl = NULL;
    PSID pOwner = NULL;
    PSID pGroup = NULL;
    BOOL bDoDacl = FALSE;
    BOOL bDoSacl = FALSE;
    BOOL bIgnore = FALSE;
    ULONG MaxAclSize = 0;
    ULONG MaxAceCount = 0;

    ULONG DaclExplicitDenyAclSize = 0;
    ULONG DaclExplicitDenyAceCnt = 0;
    ULONG DaclExplicitAclSize = 0;
    ULONG DaclExplicitAceCnt = 0;

    ULONG IgnoreSaclExplicitAclSize = 0;
    ULONG IgnoreSaclExplicitAceCnt = 0;
    ULONG SaclExplicitAclSize = 0;
    ULONG SaclExplicitAceCnt = 0;

    PISECURITY_DESCRIPTOR_RELATIVE pLocalSD = (PISECURITY_DESCRIPTOR_RELATIVE) SecurityDescriptor;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize variables. These will usually be ZERO.
    //

    *pDaclSizeSaved = 0;
    *pSaclSizeSaved = 0;

    //
    // Note that the error checks below should never return any errors. They are
    // merely making sure that there is no bug in the caller code.
    //

    //
    // Allow only self relative security descriptors
    //

    if ((pLocalSD->Control & SE_SELF_RELATIVE) == 0) {
        ASSERT(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Get the fields from Security Descriptor.
    //

    if (!GetSecurityDescriptorDacl(pLocalSD, &bIgnore, &pDacl, &bIgnore)) {
        ASSERT(FALSE);
        return FALSE;
    }

    if (!GetSecurityDescriptorSacl(pLocalSD, &bIgnore, &pSacl, &bIgnore)) {
        ASSERT(FALSE);
        return FALSE;
    }

    if (!GetSecurityDescriptorOwner(pLocalSD, &pOwner, &bIgnore)) {
        ASSERT(FALSE);
        return FALSE;
    }

    if (!GetSecurityDescriptorGroup(pLocalSD, &pGroup, &bIgnore)) {
        ASSERT(FALSE);
        return FALSE;
    }

    //
    // NULL owner and group sids are not allowed.
    // The owner field should appear before the group.
    //

    if (!pOwner || !pGroup || ((PUCHAR) pGroup <= (PUCHAR) pOwner)) {
        ASSERT(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Verify that our assumptions are valid.
    //

    if (pSacl != NULL) {
        if (pDacl != NULL) {

            //
            // Make sure that the SACL appears before the DACL.
            //

            if ((PUCHAR) pDacl <= (PUCHAR) pSacl) {
                ASSERT(FALSE);
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            //
            // Make sure that the DACL appears before the OWNER.
            //

            if ((PUCHAR) pOwner <= (PUCHAR) pDacl) {
                ASSERT(FALSE);
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
        } else {
            //
            // Make sure that the SACL appears before the OWNER.
            //

            if ((PUCHAR) pOwner <= (PUCHAR) pSacl) {
                ASSERT(FALSE);
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
        }
    } else if (pDacl != NULL ) {

        //
        // There is no SACL. We now have to check wrt DACL.
        //
        
        //
        // Make sure that the DACL appears before the OWNER.
        //

        if ((PUCHAR) pOwner <= (PUCHAR) pDacl) {
            ASSERT(FALSE);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

    }

    //
    // For the non-trivial case, compute the DACL information.
    //

    if ((pDacl != NULL) && (pDacl->AceCount > 1)) {

        if (!ComputeAclInfo(pDacl,
                           &DaclExplicitDenyAceCnt, &DaclExplicitDenyAclSize, 
                           &DaclExplicitAceCnt, &DaclExplicitAclSize)) {

            //
            // This is the only case in which we fail because we do not want
            // to handle the given input which is in non-canonical form.
            //
            return FALSE;
        }

        //
        // We need to do work if the number of explicit ACEs is more than one.
        //

        if (DaclExplicitAceCnt > 1) {
            bDoDacl = TRUE;
        }
        MaxAclSize = DaclExplicitAclSize;
        MaxAceCount = DaclExplicitAceCnt;
    }

    //
    // For the non-trivial case, compute the SACL information.
    //

    if ((pSacl != NULL) && (pSacl->AceCount > 1)) {
        if (!ComputeAclInfo(pSacl, 
                           &IgnoreSaclExplicitAceCnt, &IgnoreSaclExplicitAclSize, 
                           &SaclExplicitAceCnt, &SaclExplicitAclSize)) {

            //
            // This can never happen for a valid SACL.
            //

            ASSERT(FALSE);
            return FALSE;
        }

        //
        // We need to do work if the number of explicit ACEs is more than one.
        //

        if (SaclExplicitAceCnt > 1) {
            bDoSacl = TRUE;

            //
            // Set the Size and Count fields is the SACL is bigger than the DACL.
            //

            if (MaxAclSize < SaclExplicitAclSize) {
                MaxAclSize = SaclExplicitAclSize;
            }
            if (MaxAceCount < SaclExplicitAceCnt) {
                MaxAceCount = SaclExplicitAceCnt;
            }
        }
    }

    if (MaxAceCount <= 1) {

        //
        // There is nothing to do here. We do not have more than one explcit 
        // ACEs in the ACLs given to us.                                                        
        //

        return TRUE;
    }

    //
    // Allocate space needed for temporary manipulation of ACL subparts. We need
    // space to hold the ACEs themselves and pointers to them.
    //

    pTempAcl = (PACL) RtlAllocateHeap(RtlProcessHeap(), 0, (PtrAlignSize(MaxAclSize) + (MaxAceCount*sizeof(PACE_HEADER))));

    if (!pTempAcl) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    //
    // If SACL has more than one explicit ACE, sort and remove duplicates.
    // pSaclSizeSaved will be non-ZERO if any duplicates are found and deleted.
    //

    if (bDoSacl) {
        StandardizeSacl(
            pSacl, 
            SaclExplicitAceCnt, 
            SaclExplicitAclSize, 
            pTempAcl, 
            (PUCHAR) pSacl, 
            pSaclSizeSaved
            );
    }

    //
    // If SACL has more than one explicit ACE, sort and remove duplicates.
    // pSaclSizeSaved will be non-ZERO if any duplicates are found and deleted.
    //

    if (bDoDacl || *pSaclSizeSaved != 0) {
        StandardizeDacl(
            pDacl, 
            DaclExplicitDenyAceCnt, 
            DaclExplicitDenyAclSize, 
            DaclExplicitAceCnt, 
            DaclExplicitAclSize,
            pTempAcl, 
            ((PUCHAR) pDacl) - *pSaclSizeSaved,  // The DACL has to be shifted if we saved any space on the SACL.
            pDaclSizeSaved
            );

        if (*pSaclSizeSaved) {
            pLocalSD->Dacl -= *pSaclSizeSaved;
        }
    }

    //
    // If we saved any space on the DACL and/OR SACL, rearrange the owner and
    // the group fields.
    //

    if ((*pSaclSizeSaved + *pDaclSizeSaved) != 0) {

        //
        // Rearrange the owner first. We have already checked that the owner
        // appears before the group.
        //

        RtlMoveMemory(
            ((PUCHAR) pOwner) - (*pSaclSizeSaved + *pDaclSizeSaved),
            pOwner,
            RtlLengthSid(pOwner)
            );

        pLocalSD->Owner -= (*pSaclSizeSaved + *pDaclSizeSaved);

        //
        // Now rearrange the group.
        //

        RtlMoveMemory(
            ((PUCHAR) pGroup) - (*pSaclSizeSaved + *pDaclSizeSaved),
            pGroup,
            RtlLengthSid(pGroup)
            );

        pLocalSD->Group -= (*pSaclSizeSaved + *pDaclSizeSaved);
    }

    if (pTempAcl) {
        RtlFreeHeap(RtlProcessHeap(), 0, pTempAcl);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\drs_client.c ===
#include <NTDSpch.h>
#pragma  hdrstop
#include <drs_w.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\dcinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dcinfo.c

Abstract:

    Implementation of DsGetDomainControllerInfo API and helper functions.

Author:

    DaveStr     02-Jun-98

Environment:

    User Mode - Win32

Revision History:


--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <crt\stdlib.h>     // wcstol, wcstoul
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <util.h>           // OFFSET macro
#include <dststlog.h>       // DSLOG
#include <dsutil.h>

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsGetDomainControllerInfoW                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsGetDomainControllerInfoW(
    HANDLE                          hDs,            // in
    LPCWSTR                         DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo        // out
    )
{
    DRS_MSG_DCINFOREQ       infoReq;
    DRS_MSG_DCINFOREPLY     infoReply;
    DWORD                   dwOutVersion = 0;
    DWORD                   dwErr;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif

    if (    !hDs 
         || !DomainName 
         || !pcOut 
         || !ppInfo  )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    switch ( InfoLevel )
    {
    case 1:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V1) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case 2:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V2) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case DS_DCINFO_LEVEL_FFFFFFFF:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_VFFFFFFFF) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    default:

        return(ERROR_INVALID_PARAMETER);
        break;
    }

    *pcOut = 0;
    *ppInfo = NULL;

    __try
    {
        memset(&infoReq, 0, sizeof(infoReq));
        memset(&infoReply, 0, sizeof(infoReply));

        infoReq.V1.Domain = (WCHAR *) DomainName;
        infoReq.V1.InfoLevel = InfoLevel;

        dwErr = _IDL_DRSDomainControllerInfo(
                        ((BindState *) hDs)->hDrs,
                        1,                              // dwInVersion
                        &infoReq,
                        &dwOutVersion,
                        &infoReply);

        // See drs.idl for how infoReq.V1.InfoLevel and dwOutVersion
        // are correlated (near definition for DRS_MSG_DCINFOREPLY).

        if ( 0 == dwErr )
        {
            if ( dwOutVersion != InfoLevel )
            {
                dwErr = ERROR_DS_INTERNAL_FAILURE;
            }
            else
            {
                // Since all versions of DRS_MSG_DCINFOREPLY_V* have the
                // same two fields in the same two places, we can use
                // the V1 version in all InfoLevel cases. 

                *pcOut = infoReply.V1.cItems;
                *ppInfo = infoReply.V1.rItems;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        
	dwErr = RpcExceptionCode(); 
	HandleClientRpcException(dwErr, &hDs);

    }

    MAP_SECURITY_PACKAGE_ERROR(dwErr);

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsGetDomainControllerInfo]"));
    DSLOG((0,"[DN=%ws][LV=%u][ST=%u][ET=%u][ER=%u][-]\n",
           DomainName, InfoLevel, startTime, GetTickCount(), dwErr))
        
    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsGetDomainControllerInfoA                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsGetDomainControllerInfoA(
    HANDLE                          hDs,            // in
    LPCSTR                          DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo        // out
    )
{
    DWORD                           dwErr = ERROR_INVALID_PARAMETER;
    WCHAR                           *pwszDomainName = NULL;
    DWORD                           i;
    CHAR                            *pszTmp;
    DS_DOMAIN_CONTROLLER_INFO_1W    *pInfoV1;
    DS_DOMAIN_CONTROLLER_INFO_2W    *pInfoV2;
    DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW    *pInfoVFFFFFFFF;

    if (    !hDs
         || !DomainName 
         || !pcOut 
         || !ppInfo  )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    switch ( InfoLevel )
    {
    case 1:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V1) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case 2:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V2) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case DS_DCINFO_LEVEL_FFFFFFFF:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_VFFFFFFFF) ) {

            return(ERROR_NOT_SUPPORTED);
        }
        break;

    default:

        return(ERROR_INVALID_PARAMETER);
        break;
    }

    *pcOut = 0;
    *ppInfo = NULL;

    if (    !DomainName
         || (dwErr = AllocConvertWide(DomainName, &pwszDomainName))
         || (dwErr = DsGetDomainControllerInfoW(hDs, 
                                                pwszDomainName, 
                                                InfoLevel, 
                                                pcOut, 
                                                ppInfo)) )
    {

        goto Cleanup;
    }

    // Convert all string values from WCHAR to ASCII.  We overwrite the WCHAR
    // buffer with the ASCII data knowing that (sizeof(WCHAR) < sizeof(CHAR)).

    for ( i = 0; i < *pcOut; i++ )
    {
        switch ( InfoLevel )
        {
        case 1:

            pInfoV1 = & ((DS_DOMAIN_CONTROLLER_INFO_1W *) (*ppInfo))[i];

            if ( pInfoV1->NetbiosName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->NetbiosName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->NetbiosName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV1->DnsHostName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->DnsHostName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->DnsHostName, pszTmp);
                LocalFree(pszTmp);
            }
            
            if ( pInfoV1->SiteName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->SiteName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->SiteName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV1->ComputerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->ComputerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->ComputerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV1->ServerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->ServerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->ServerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            break;

        case 2:

            pInfoV2 = & ((DS_DOMAIN_CONTROLLER_INFO_2W *) (*ppInfo))[i];

            if ( pInfoV2->NetbiosName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->NetbiosName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->NetbiosName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->DnsHostName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->DnsHostName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->DnsHostName, pszTmp);
                LocalFree(pszTmp);
            }
            
            if ( pInfoV2->SiteName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->SiteName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->SiteName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->SiteObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->SiteObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->SiteObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->ComputerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->ComputerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->ComputerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->ServerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->ServerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->ServerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->NtdsDsaObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->NtdsDsaObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->NtdsDsaObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            break;

        case 0xFFFFFFFF:

            pInfoVFFFFFFFF = & ((DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW *) (*ppInfo))[i];

            if ( pInfoVFFFFFFFF->UserName ) {
                if ( dwErr = AllocConvertNarrow(pInfoVFFFFFFFF->UserName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoVFFFFFFFF->UserName, pszTmp);
                LocalFree(pszTmp);
            }

            break;

        }
    }

Cleanup:

    if ( pwszDomainName )
        LocalFree(pwszDomainName);

    if ( dwErr && *pcOut && *ppInfo )
        DsFreeDomainControllerInfoW(InfoLevel, *pcOut, *ppInfo);

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeDomainControllerInfoW                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeDomainControllerInfoW(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo          // in
    )
{
    DWORD                           i;
    DS_DOMAIN_CONTROLLER_INFO_1W    *pInfoV1;
    DS_DOMAIN_CONTROLLER_INFO_2W    *pInfoV2;
    DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW    *pInfoVFFFFFFFF;

    if ( cInfo && pInfo )
    {
        switch ( InfoLevel )
        {
        case 1:

            pInfoV1 = & ((DS_DOMAIN_CONTROLLER_INFO_1W *) (pInfo))[0];

            for ( i = 0; i < cInfo; i++ )
            {
                MIDL_user_free(pInfoV1[i].NetbiosName);
                MIDL_user_free(pInfoV1[i].DnsHostName);
                MIDL_user_free(pInfoV1[i].SiteName);
                MIDL_user_free(pInfoV1[i].ComputerObjectName);
                MIDL_user_free(pInfoV1[i].ServerObjectName);
            }

            MIDL_user_free(pInfo);
            break;

        case 2:

            pInfoV2 = & ((DS_DOMAIN_CONTROLLER_INFO_2W *) (pInfo))[0];

            for ( i = 0; i < cInfo; i++ )
            {
                MIDL_user_free(pInfoV2[i].NetbiosName);
                MIDL_user_free(pInfoV2[i].DnsHostName);
                MIDL_user_free(pInfoV2[i].SiteName);
                MIDL_user_free(pInfoV2[i].SiteObjectName);
                MIDL_user_free(pInfoV2[i].ComputerObjectName);
                MIDL_user_free(pInfoV2[i].ServerObjectName);
                MIDL_user_free(pInfoV2[i].NtdsDsaObjectName);
            }

            MIDL_user_free(pInfo);
            break;

       case 0xFFFFFFFF:

            pInfoVFFFFFFFF = & ((DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW *) (pInfo))[0];

            for ( i = 0; i < cInfo; i++ )
            {
                MIDL_user_free(pInfoVFFFFFFFF[i].UserName);
            }

            MIDL_user_free(pInfo);
            break;
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeDomainControllerInfoA                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeDomainControllerInfoA(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo          // in
    )
{
    DsFreeDomainControllerInfoW(InfoLevel, cInfo, pInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\xdommove.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       xDomMove.c
//
//--------------------------------------------------------------------------

/*++

Module Name:

    xDomMove.c

Abstract:

    This module implements various items relevant to cross domain move.

Author:

    Dave Straube (davestr) 8/7/98

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // DSNAME manipulation routines
#include <dsatools.h>                   // Memory, etc.
#include <objids.h>                     // ATT_* definitions
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <filtypes.h>                   // filter types
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dsexcept.h>                   // exception handlers
#include <debug.h>                      // Assert()
#include <xdommove.h>                   // This file's prototypes
#include <winsock.h>                    // host <--> net long conversions

#include <fileno.h>
#define  FILENO FILENO_XDOMMOVE

DWORD
GetProxyType(
    SYNTAX_DISTNAME_BINARY          *pProxy)
{
    ULONG netLong;

    PROXY_SANITY_CHECK(pProxy);
    netLong = * PROXY_DWORD_ADDR(pProxy, PROXY_TYPE_OFFSET);
    return(ntohl(netLong));
}

DWORD
GetProxyTypeInternal(
    DWORD                           cBytes,
    INTERNAL_SYNTAX_DISTNAME_STRING *pProxy)
{
    ULONG netLong;

    INTERNAL_PROXY_SANITY_CHECK(cBytes, pProxy);
    netLong = ((DWORD *) pProxy->data.byteVal)[PROXY_TYPE_OFFSET];
    return(ntohl(netLong));
}

DWORD
GetProxyEpoch(
    SYNTAX_DISTNAME_BINARY          *pProxy)
{
    ULONG netLong;

    PROXY_SANITY_CHECK(pProxy);
    netLong = * PROXY_DWORD_ADDR(pProxy, PROXY_EPOCH_OFFSET);
    return(ntohl(netLong));
}

DWORD
GetProxyEpochInternal(
    DWORD                           cBytes,
    INTERNAL_SYNTAX_DISTNAME_STRING *pProxy)
{
    ULONG netLong;

    INTERNAL_PROXY_SANITY_CHECK(cBytes, pProxy);
    netLong = ((DWORD *) pProxy->data.byteVal)[PROXY_EPOCH_OFFSET];
    return(ntohl(netLong));
}

// Following throw exceptions and returns THAllocEx'd memory.

VOID
MakeProxy(
    THSTATE                         *pTHS,
    DSNAME                          *pName,
    DWORD                           type,
    DWORD                           epoch,
    ULONG                           *pcBytes,
    SYNTAX_DISTNAME_BINARY          **ppProxy)
{
    Assert(VALID_THSTATE(pTHS));
    Assert(type < PROXY_TYPE_UNKNOWN);

    *pcBytes = PADDEDNAMESIZE(pName) + PROXY_BLOB_SIZE;
    *ppProxy = (SYNTAX_DISTNAME_BINARY *) THAllocEx(pTHS, *pcBytes);
    memcpy(&(*ppProxy)->Name, pName, pName->structLen);
    (DATAPTR(*ppProxy))->structLen = PROXY_BLOB_SIZE;
    * PROXY_DWORD_ADDR(*ppProxy, PROXY_TYPE_OFFSET) = htonl(type);
    * PROXY_DWORD_ADDR(*ppProxy, PROXY_EPOCH_OFFSET) = htonl(epoch);
    PROXY_SANITY_CHECK(*ppProxy);
}

VOID
MakeProxyKeyInternal(
    DWORD                           DNT,
    DWORD                           type,
    DWORD                           *pcBytes,
    VOID                            *buff)
{
    DWORD *key = (DWORD *) buff;

    Assert(type < PROXY_TYPE_UNKNOWN);
    Assert(*pcBytes >= (3 * sizeof(DWORD)));

    // Construct an INTERNAL_SYNTAX_DISTNAME_STRING value with all
    // but the epoch number on the end.  See also ExtIntDistString().

    key[0] = DNT;
    key[1] = PROXY_BLOB_SIZE;
    key[2] = htonl(type);
    *pcBytes = 3 * sizeof(DWORD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\bind.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bind.h

Abstract:

    Definitions for client side state which is automatically managed
    by the client stubs so that API users don't have to manage any
    connection state.  Currently the only connection state is the context
    handle.  Clients are returned a handle (pointer) to a BindState struct 
    rather than an RPC handle for the server directly. 

Author:

    DaveStr     10-May-97

Environment:

    User Mode - Win32

Revision History:

    DaveStr     20-Oct-97
        Removed dependency on MAPI STAT struct.

--*/

#ifndef __BIND_H__
#define __BIND_H__

#define NTDSAPI_SIGNATURE "ntdsapi"

typedef struct _BindState 
{
    BYTE            signature[8];       // NTDSAPI_SIGNATURE
    DRS_HANDLE      hDrs;               // DRS interface RPC context handle
    PDRS_EXTENSIONS pServerExtensions;  // server side DRS extensions 
    // 
    // DO NOT CHANGE THE ORDER OF OR INSERT ANYTHING ABOVE THIS POINT!!!!
    // 
    // This will produce a binary incompatibility in repadmin/dcdiag, such
    // that dcdiag/repadmin might corrupt memory trying to treat the new
    // structure as the old structure.
    //
    DWORD           bServerNotReachable; // server may be not be reachable
    // Following field must be last one in struct and is used to track
    // who a person is bound to so we can divine the destination from 
    // later ntdsapi.dll calls which pass an active BindState.
    WCHAR           bindAddr[1];        // binding address
} BindState;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\cracknam.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cracknam.c

Abstract:

    Implementation of DsCrackNames API and helper functions.

Author:

    DaveStr     09-Aug-96

Environment:

    User Mode - Win32

Revision History:

    DaveStr     20-Oct-97
        Beta2 changes - UPN, DS_NAME_FLAG_SYNTACTICAL_ONLY, move to drs.idl.

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <crt\stdlib.h>     // wcstol, wcstoul
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <ntdsa.h>          // GetRDNInfo
#include <scache.h>         // req'd for mdlocal.h
#include <dbglobal.h>       // req'd for mdlocal.h
#include <mdglobal.h>       // req'd for mdlocal.h
#include <mdlocal.h>        // CountNameParts
#include <attids.h>         // ATT_DOMAIN_COMPONENT
#include <ntdsapip.h>       // private ntdsapi defines
#include <sddl.h>           // SDDL_* definitions
#include <dststlog.h>
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include <util.h>


// the following macro is borrowed from seopaque.h
#define PtrAlignSize(Size)  \
    (((ULONG)(Size) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1))


typedef struct _RdnValue
{
    WCHAR           val[MAX_RDN_SIZE];
    ULONG           len;

} RdnValue;

typedef DWORD (*SyntacticCrackFunc)(
    DS_NAME_FLAGS           flags,          // in
    DS_NAME_FORMAT          formatOffered,  // in
    DS_NAME_FORMAT          formatDesired,  // in
    LPCWSTR                 pName,          // in
    DS_NAME_RESULT_ITEMW    *pItem,         // out
    WCHAR                   **ppLastSlash); // out
    
BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End);

BOOL
IsFPO(
    RdnValue        *pRdn,
    ATTRTYP         type);

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// NumCanonicalDelimiter                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD 
NumCanonicalDelimiter(
    LPCWSTR     pName           // in
    )
/*++

    Returns the count of DS_CANONICAL_NAME delimiters (L'/') in the input.

--*/
{
    WCHAR   *p;
    DWORD   cDelim = 0;

    for (p = (WCHAR *)pName; *p; ++p)
    {
        if ( L'/' == *p || L'\\' == *p)
        {
            cDelim++;
        }
    }

    return(cDelim);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CanonicalRdnConcat                                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID 
CanonicalRdnConcat(
    WCHAR       *pwszDst,   // in
    RdnValue    *pRdnVal    // out
    )
/*++

Routine Description:

    Concatenates an RdnValue to a DS_CANONICAL_NAME escaping embedded '/'
    characters as "\/" if required.  The server side unescapes these when
    cracking from DS_CANONICAL_NAME.

Arguments:

    pwszDst - NULL terminated destination string.

    pRdnVal - RdnValue to concatenate.

Return Value:

    None.

--*/
{
    DWORD   i;
    
    // Advance to end of pwszDst;

    pwszDst += wcslen(pwszDst);

    for ( i = 0; i < pRdnVal->len; i++ )
    {
        if ( L'/' == pRdnVal->val[i] || L'\\' == pRdnVal->val[i])
        {
            *pwszDst++ = L'\\';
        }

        *pwszDst++ = pRdnVal->val[i];
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticFqdnItemToCanonicalW                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD 
SyntacticFqdnItemToCanonicalW(
    DS_NAME_FLAGS           flags,          // in
    DS_NAME_FORMAT          formatOffered,  // in
    DS_NAME_FORMAT          formatDesired,  // in
    LPCWSTR                 pName,          // in
    DS_NAME_RESULT_ITEMW    *pItem,         // out
    WCHAR                   **ppLastSlash   // out
    )
/*++

Routine Description:

    Parses a purported DN and syntactically converts it into
    DS_CANONICAL_NAME format.

    See also: 

    ftp://ds.internic.net/internet-drafts/draft-ietf-asid-ldap-domains-02.txt

Arguments:

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies the DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    pName - purported FQDN input name.

    pItem - pointer to output data structure.

    ppLastSlash - pointer to pointer to location of last '/' in output name.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/

{
    int         i;
    DWORD       cBytes, cBytes1;
    DWORD       dwErr;
    int         cParts;
    int         firstDomainPart = 0;   //initialized to avoid C4701
    int         cDomainParts;
    int         cDomainRelativeParts;
    RdnValue    *pTmpRdn;
    RdnValue    *rRdnValues = NULL;
    ATTRTYP     type;
    DWORD       lastType;
    DWORD       len;
    DSNAME      *pTmp;
    DSNAME      *pDSName;
    DSNAME      *scratch;
    BYTE        *ptr;
    DWORD       ret = NO_ERROR;

    // Allocate some DSNAME buffers.

    cBytes = DSNameSizeFromLen(wcslen(pName));
    
    ptr = LocalAlloc(LPTR,2*PtrAlignSize(cBytes));
    if (!ptr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pDSName = (DSNAME *)ptr;
    scratch = (DSNAME *)(ptr+PtrAlignSize(cBytes));


    // Init scratch buffer with purported FQDN.

    memset(pDSName, 0, cBytes);
    pDSName->structLen = cBytes;
    pDSName->NameLen = wcslen(pName);
    wcscpy(pDSName->StringName, pName);

    // Sanity check the purported FQDN.

    if ( 0 != CountNameParts(pDSName, (unsigned *) &cParts) )
    {
        pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
        goto bye;
    }

    // Allocate return buffers.  We're conservative and say that
    // output name can't be more than the length in bytes of the DSNAME
    // which holds the input name plus N extra characters for escaped
    // canonical delimiters.

    pItem->pDomain = (WCHAR *) MIDL_user_allocate(cBytes);
    cBytes1 = cBytes + (sizeof(WCHAR) * NumCanonicalDelimiter(pName));
    pItem->pName = (WCHAR *) MIDL_user_allocate(cBytes1);

    if ( ( NULL == pItem->pDomain ) || ( NULL == pItem->pName ) )
    {
        // Caller is expected to clean up allocations on error.
        ret = ERROR_NOT_ENOUGH_MEMORY;
        goto bye;
    }

    memset(pItem->pDomain, 0, cBytes);
    memset(pItem->pName, 0, cBytes1);

    // Strip off the intra-domain name components leaf to root
    // putting them in a linked list. 

    lastType = ATT_ORGANIZATION_NAME;  // anything but ATT_DOMAIN_COMPONENT
    cDomainParts = 0;
    cDomainRelativeParts = 0;
    rRdnValues = (RdnValue *) LocalAlloc(NONZEROLPTR,cParts * sizeof(RdnValue));
    if (!rRdnValues) {
        ret = ERROR_NOT_ENOUGH_MEMORY;
        goto bye;
    }

    for ( i = 0; i < cParts; i++ )
    {
        pTmpRdn = &rRdnValues[i];

        dwErr = GetRDNInfoExternal(pDSName, pTmpRdn->val, &pTmpRdn->len, &type);

        // Ignore unknown rdntypes. We really only care about a
        // few well-known types that allow us to distinguish the
        // domain part of the canonical name. All other RDNs are
        // non-domain parts.
        if ((dwErr == ERROR_DS_NAME_TYPE_UNKNOWN)
            && (0 == (dwErr = GetRDNInfoExternal(pDSName, pTmpRdn->val, &pTmpRdn->len, NULL)))) {
            type = -1;
        }

        if (    (0 != dwErr)
             || (    (0 == i) 
                  && !(DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC & flags)
                  && IsFPO(pTmpRdn, type) ) )
        {
            pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
            goto bye;
        }

        // Following logic needs to handle two special cases:
        //
        // 1) Case of old style DC= name with O=Internet at the end.
        //    Eg: CN=xxx,OU=yyy,DC=foo,DC=bar,DC=com,O=internet
        // 
        // 2) Case of object which has DC= naming within the domain, but
        //    separated from domain root by at least one non-DC= component.
        //    Eg: DC=xxx,OU=yyy,DC=foo,DC=bar,DC=com

        if (    ( ATT_ORGANIZATION_NAME == type )
             && ( i == (cParts - 1) )
             && ( cDomainParts >= 1 )
             && ( 8 == pTmpRdn->len )
             // To avoid pulling in more 'C' runtimes we just compare
             // the eight characters directly.
             && ( (L'i' == pTmpRdn->val[0]) || (L'I' == pTmpRdn->val[0]) )
             && ( (L'n' == pTmpRdn->val[1]) || (L'N' == pTmpRdn->val[1]) )
             && ( (L't' == pTmpRdn->val[2]) || (L'T' == pTmpRdn->val[2]) )
             && ( (L'e' == pTmpRdn->val[3]) || (L'E' == pTmpRdn->val[3]) )
             && ( (L'r' == pTmpRdn->val[4]) || (L'R' == pTmpRdn->val[4]) )
             && ( (L'n' == pTmpRdn->val[5]) || (L'N' == pTmpRdn->val[5]) )
             && ( (L'e' == pTmpRdn->val[6]) || (L'E' == pTmpRdn->val[6]) )
             && ( (L't' == pTmpRdn->val[7]) || (L'T' == pTmpRdn->val[7]) ) )
        {
            // This is an old style DC= name with O=Internet on the
            // end - just skip this component and exit the loop.

            cParts--;
            break;
        }
        else if (    (ATT_DOMAIN_COMPONENT == type)
                  && (ATT_DOMAIN_COMPONENT != lastType) )
        {
            // Start of a new DC= subsequence.
            firstDomainPart = i;
            cDomainParts = 1;
        }
        else if (    (ATT_DOMAIN_COMPONENT == type)
                  && (ATT_DOMAIN_COMPONENT == lastType) )
        {
            // In the middle of a DC= subsequence.
            cDomainParts++;
        }
        else if (    (ATT_DOMAIN_COMPONENT != type)
                  && (ATT_DOMAIN_COMPONENT == lastType) )
        {
            // End of a DC= subsequence - assign DC= subsequence counts
            // to the domain relative part of the name.
            cDomainRelativeParts += cDomainParts;
            cDomainParts = 0;
            cDomainRelativeParts++;
        }
        else
        {
            // In the middle of a non-DC= subsequence.
            cDomainRelativeParts++;
        }

        lastType = type;

        // Trim the DSNAME by one so we can call GetRDNInfo on the next piece
        // on next pass through the loop.

        dwErr = TrimDSNameBy(pDSName, 1, scratch);

        if ( 0 != dwErr )
        {
            pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
            goto bye;
        }

        pTmp = pDSName;
        pDSName = scratch;
        scratch = pTmp;
    }

    if ( 0 == cDomainParts )
    {
        // No DC= component in the purported FQDN - therefore can't parse.

        pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
        goto bye;
    }

    // All components of the DN are now in rRdnValues[] in the following
    // order (for example): DC=xxx,OU=yyy,DC=foo,DC=bar,DC=com
    // Items firstDomainPart through cParts-1 represent the DNS domain name
    // in desired leaf to root order.  Items firstDomainPart-1 down to 0
    // represent the domain relative name components in root to leaf order.

    for ( i = firstDomainPart; i < cParts; i++ )
    {
        if ( i > firstDomainPart )
        {
            wcscat(pItem->pDomain, L".");
            wcscat(pItem->pName, L".");
        }

        wcsncat(pItem->pDomain, rRdnValues[i].val, rRdnValues[i].len);
        wcsncat(pItem->pName, rRdnValues[i].val, rRdnValues[i].len);
    }

    // Remember that we always want a '/' after the DNS domain name, even if
    // there are no domain relative components.

    if ( 0 == cDomainRelativeParts )
    {
        *ppLastSlash = &(pItem->pName[wcslen(pItem->pName)]);
        wcscat(pItem->pName, L"/");
        pItem->status = DS_NAME_NO_ERROR;
        goto bye;
    }

    // Now the domain relative parts.

    for ( i = (firstDomainPart-1); i >= 0; i-- )
    {
        if ( 0 == i )
        {
            *ppLastSlash = &(pItem->pName[wcslen(pItem->pName)]);
        }

        wcscat(pItem->pName, L"/");
        CanonicalRdnConcat(pItem->pName, &rRdnValues[i]);
    }

    pItem->status = DS_NAME_NO_ERROR;

bye:
    LocalFree(ptr);
    if (rRdnValues) {
        LocalFree(rRdnValues);
    }
    return(ret);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticCanonicalItemToFqdnW                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD 
SyntacticCanonicalItemToFqdnW(
    DS_NAME_FLAGS           flags,          // in
    DS_NAME_FORMAT          formatOffered,  // in
    DS_NAME_FORMAT          formatDesired,  // in
    LPCWSTR                 pName,          // in
    DS_NAME_RESULT_ITEMW    *pItem,         // out
    WCHAR                   **ppLastSlash   // out
    )
/*++

Routine Description:

    Parses a purported canonical name and syntactically converts it into
    DS_FQDN_1779_NAME format.  However, we really only can do this for
    domain names in canonical form - i.e. end in '/' or '\n' in the case
    of CANONICAL_EX.

    See also: 

    ftp://ds.internic.net/internet-drafts/draft-ietf-asid-ldap-domains-02.txt

Arguments:

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies the DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    pName - purported canonical input name.

    pItem - pointer to output data structure.

    ppLastSlash - pointer to pointer to location of last '/' in output name.
        Not used.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/
{
    DWORD   cChar = wcslen(pName);
    DWORD   i, j, cPieces;
    DWORD   cBytesName, cBytesDomain;

    if (    // Must have at least one char followed by '/' or '\n'
            (cChar < 2)
            // Test format offered
         || (    (DS_CANONICAL_NAME != formatOffered) 
              && (DS_CANONICAL_NAME_EX != formatOffered))
            // Test format desired
         || (DS_FQDN_1779_NAME != formatDesired)
            // Regular canonical needs '/' at end
         || (    (DS_CANONICAL_NAME == formatOffered) 
              && (L'/' != pName[cChar-1]))
            // Extended canonical needs '\n' at end
         || (    (DS_CANONICAL_NAME_EX == formatOffered) 
              && (L'\n' != pName[cChar-1]))
            // Canonical name can't start with '.'
         || (L'.' == *pName)
            // Don't be fooled by escaped '/' at end - i.e. "\/"
         || ( (L'/' == pName[cChar-1] ) && (L'\\' == pName[cChar-2]) ) )
    {
        pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
        return(NO_ERROR);
    }

    // Strip trailing delimiter.

    cChar -= 1;

    // Strip trailing '.' as we don't want that in the DN.

    if ( L'.' == pName[cChar-1] )
    {
        cChar -= 1;
    }

    // Count components.

    for ( i = 1, cPieces = 1; i < cChar; i++ )
    {
        if ( L'.' == pName[i] )
        {
            cPieces += 1;
        }
    }

    // Allocate return buffers.

    cBytesDomain = (cChar + 1) * sizeof(WCHAR);
    cBytesName = (cChar + 1 + (cPieces * 4)) * sizeof(WCHAR);
    pItem->pDomain = (WCHAR *) MIDL_user_allocate(cBytesDomain);
    pItem->pName = (WCHAR *) MIDL_user_allocate(cBytesName);

    if ( ( NULL == pItem->pDomain ) || ( NULL == pItem->pName ) )
    {
        // Caller is expected to clean up allocations on error.
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Construct return data.

    memcpy(pItem->pDomain, pName, cBytesDomain);
    pItem->pDomain[(cBytesDomain / sizeof(WCHAR)) - 1] = L'\0';

    for ( i = 0, j = 0; i < cChar; i++ )
    {
        if ( L'.' == pName[i] )
        {
            pItem->pName[j++] = L',';
        }

        if ( (0 == i) || (L'.' == pName[i]) )
        {
            pItem->pName[j++] = L'D';
            pItem->pName[j++] = L'C';
            pItem->pName[j++] = L'=';
        }

        if ( L'.' != pName[i] )
        {
            pItem->pName[j++] = pName[i];
        }
    }

    pItem->pName[j] = L'\0';

    pItem->status = DS_NAME_NO_ERROR;
    return(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticCrackPossible                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

BOOL
SyntacticCrackPossible(
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    SyntacticCrackFunc  *pfn                // out - optional
    )
/*++

Description:

    Returns FALSE if syntactic cracking is definitely NOT possible.
    Returns TRUE if syntactic cracking might be possible - but with 
        no guarantee that it is.  In this case, also returns a function
        pointer indicating the function to use for syntactic cracking.

--*/

{
    // We can crack syntactically from CANONICAL to FQDN if the CANONICAL
    // name has only domain components.  eg: foo.bar.com/

    if (    (    (DS_CANONICAL_NAME == formatOffered)
              || (DS_CANONICAL_NAME_EX == formatOffered) )
         && (DS_FQDN_1779_NAME == formatDesired) )
    {
        if ( pfn )
        {
            *pfn = SyntacticCanonicalItemToFqdnW;
        }

        return(TRUE);
    }
    
    // We can crack syntactically from FQDN to both CANONICAL forms.
    // So return FALSE of the output format is anything other than CANONICAL
    // as we have no other combinations we can crack syntactially.
    // Make no test on input format as SyntacticFqdnItemToCanonicalW will
    // either parse the item as DS_FQDN_1779_NAME or else return 
    // DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING.

    if (    ( DS_CANONICAL_NAME != formatDesired )
         && ( DS_CANONICAL_NAME_EX != formatDesired ) )
    {
        return(FALSE);
    }

    if ( pfn )
    {
        *pfn = SyntacticFqdnItemToCanonicalW;
    }

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticMappingW                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
SyntacticMappingW(
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult           // out
    )
/*++

Routine Description:

    Perform a purely syntactic mapping without going on the wire.  
    Intended usage is for the UI which wishes to display "tool tips" 
    when the cursor rests on members of a list box, for example, 
    without going across the wire for each one.  This routine does a 
    syntactic mapping using various assumptions about the ubiquity 
    of DC= naming.  The only syntactic mapping supported is from 
    DS_FQDN_1779_NAME to DS_CANONICAL_NAME(_EX).

Arguments:

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies the DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input/output name count.

    rpNames - arry of input name WCHAR pointers.

    ppResult - pointer to pointer of DS_NAME_RESULTW block.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/

{
    DWORD               cBytes;
    DWORD               i;
    WCHAR               *pLastSlash;
    DWORD               err;
    SyntacticCrackFunc  pSyntacticFunc;

    // Allocate and clear return data.

    cBytes = sizeof(DS_NAME_RESULTW);
    *ppResult = (PDS_NAME_RESULTW) MIDL_user_allocate(cBytes);

    if ( NULL == *ppResult )
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset(*ppResult, 0, cBytes);
    cBytes = cNames * sizeof(DS_NAME_RESULT_ITEMW);
    (*ppResult)->rItems = (PDS_NAME_RESULT_ITEMW) MIDL_user_allocate(cBytes);

    if ( NULL == (*ppResult)->rItems )
    {
        DsFreeNameResultW(*ppResult);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset((*ppResult)->rItems, 0, cBytes);

    // Initialize status for worst case.

    for ( i = 0; i < cNames; i++ )
    {
        (*ppResult)->rItems[i].status = 
                        DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
    }

    (*ppResult)->cItems = cNames;

    // Now that return data is allocated and initialized, bail if we
    // know a-priori that a syntactic crack is not possible.

    if ( !SyntacticCrackPossible(formatOffered, 
                                 formatDesired, 
                                 &pSyntacticFunc) )
    {
        return(NO_ERROR);
    }

    // Syntactical mapping is possible.

    for ( i = 0; i < cNames; i++ )
    {
        
        err = (*pSyntacticFunc)(
                            flags,
                            formatOffered,
                            formatDesired,
                            rpNames[i],
                            &(*ppResult)->rItems[i],
                            &pLastSlash);

        if ( NO_ERROR != err )
        {
            DsFreeNameResultW(*ppResult);
            return(err);
        }

        if (    (DS_CANONICAL_NAME_EX == formatDesired)
             && (DS_NAME_NO_ERROR == (*ppResult)->rItems[i].status) )
        {
            *pLastSlash = L'\n';
        }
    }

    return(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsCrackNamesW                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsCrackNamesW(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult           // out
    )
/*++

Routine Description:

    Cracks a bunch of names from one format to another.  See external
    prototype and definitions in ntdsapi.h

Arguments:

    hDS - Pointer to BindState for this session.

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input/output name count.

    rpNames - arry of input name WCHAR pointers.

    ppResult - pointer to pointer of DS_NAME_RESULTW block.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/

{
    DWORD                   dwErr = NO_ERROR;
    DWORD                   i;
    DWORD                   cBytes;
    DRS_MSG_CRACKREQ        crackReq;
    DRS_MSG_CRACKREPLY      crackReply;
    DWORD                   dwOutVersion;
    BOOL                    fRedoAtServer = FALSE;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif
    __try
    {
        // Sanity check arguments.

        if ( // Don't check anything which may be changed by server upgrade.
                (    (NULL == hDS) 
                  && !(flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) )
             || (0 == cNames)
             || (NULL == rpNames)
             || (NULL == ppResult)
             || (*ppResult && FALSE)
             || (    (flags & (  DS_NAME_FLAG_EVAL_AT_DC
                               | DS_NAME_FLAG_GCVERIFY))
                  && (flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) ) )
        {
            return(ERROR_INVALID_PARAMETER);
        }
    
        *ppResult = NULL;
    
        for ( i = 0; i < cNames; i++ )
        {
            if ( (NULL == rpNames[i]) ||
                 (0 == *rpNames[i]) )
            {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        // Go the no-wire route if explicitly requested.

        if ( flags & DS_NAME_FLAG_SYNTACTICAL_ONLY )
        {
            dwErr = SyntacticMappingW(
                                flags,
                                formatOffered,
                                formatDesired,
                                cNames,
                                rpNames,
                                ppResult);

            goto exit;
        }

        // If the offered and desired formats might support syntactic
        // cracking, then try that by default.  However, if syntactic
        // cracking fails with DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
        // (as might be in the case of FPOs or other unrecognized formats), 
        // then free the result and go across the wire for real.

        if (    SyntacticCrackPossible(formatOffered, formatDesired, NULL)
             && !(flags & DS_NAME_FLAG_EVAL_AT_DC) )
        {
            dwErr = SyntacticMappingW(
                                flags,
                                formatOffered,
                                formatDesired,
                                cNames,
                                rpNames,
                                ppResult);

            if ( NO_ERROR != dwErr )
            {
                goto exit;
            }

            // Check for occurrences of DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING.

            for ( i = 0; i < (*ppResult)->cItems; i++ )
            {
                if ( DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING ==
                                                (*ppResult)->rItems[i].status )
                {
                    fRedoAtServer = TRUE;
                    DsFreeNameResultW(*ppResult);
                    *ppResult = NULL;
                    break;
                }
            }

            if ( !fRedoAtServer )
            {
                goto exit;
            }
        }

        // We really need to go across the wire to crack the names.

        memset(&crackReq, 0, sizeof(crackReq));
        memset(&crackReply, 0, sizeof(crackReply));

        crackReq.V1.CodePage = GetACP();
        crackReq.V1.LocaleId = GetUserDefaultLCID();
        crackReq.V1.dwFlags = flags;
        crackReq.V1.formatOffered = formatOffered;
        crackReq.V1.formatDesired = formatDesired;
        crackReq.V1.cNames = cNames;
        crackReq.V1.rpNames = (WCHAR **) rpNames;

        RpcTryExcept
        {
            // Following call returns WIN32 errors, not DRAERR_* values.
            dwErr = _IDL_DRSCrackNames(
                            ((BindState *) hDS)->hDrs,
                            1,                              // dwInVersion
                            &crackReq,
                            &dwOutVersion,
                            &crackReply);
        }
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {

	    dwErr = RpcExceptionCode(); 
            HandleClientRpcException(dwErr, &hDS);

        }
        RpcEndExcept;

        if ( 0 == dwErr )
        {
            if ( 1 != dwOutVersion )
            {
                dwErr = RPC_S_INTERNAL_ERROR;
            }
            else
            {
                *ppResult = crackReply.V1.pResult;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( dwErr );

exit:

    if ( dwErr )
    {
        *ppResult = NULL;
    }

    // Note that in the syntactical only case, we don't have a valid hDS.
    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsCrackNames]"));
    DSLOG((0,"[PA=%ws][FL=0x%x][FO=0x%x]"
             "[FD=0x%x][PA=0x%x][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
            (flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) ? L"syntactic only"
                                        : ((BindState *) hDS)->bindAddr, 
            flags, formatOffered, formatDesired, cNames, rpNames[0], startTime,
            GetTickCount(), dwErr));
    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsCrackNamesA                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsCrackNamesA(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCSTR        *rpNames,           // in
    PDS_NAME_RESULTA    *ppResult           // out
    )
/*++

Routine Description:
Arguments:
Return Value:

    See DsCrackNamesW.

--*/

{
    DWORD           dwErr = NO_ERROR;
    WCHAR           **rpUnicodeNames = NULL;
    DS_NAME_RESULTW *pUnicodeResult = NULL;
    DWORD           i;
    ULONG           cb, cbDomain, cbName;
    NTSTATUS        status;
    WCHAR           *unicodeBuffer = NULL;
    ULONG           unicodeBufferSize = 0;
    int             cChar;

    __try
    {
        // Sanity check arguments.

        if ( // Don't check anything which may be changed by server upgrade.
             ( (NULL == hDS) && !(flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) ) ||
             (0 == cNames) ||
             (NULL == rpNames) ||
             (NULL == ppResult) ||
             (*ppResult && FALSE) )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        // Convert rpNames to UNICODE.

        cb = (ULONG) (cNames * sizeof(WCHAR *));
        rpUnicodeNames = (WCHAR **) LocalAlloc(LPTR, cb);

        if ( NULL == rpUnicodeNames )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        memset(rpUnicodeNames, 0, cb);

        for ( i = 0; i < cNames; i++ )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                rpNames[i],
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            rpUnicodeNames[i] = (WCHAR *) 
                        LocalAlloc(LPTR, (cChar + 1) * sizeof(WCHAR));

            if ( NULL == rpUnicodeNames[i] )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( 0 == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                rpNames[i],
                                -1,
                                rpUnicodeNames[i],
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        // Make the UNICODE call.

        dwErr = DsCrackNamesW(
                        hDS,
                        flags,
                        formatOffered,
                        formatDesired,
                        cNames,
                        rpUnicodeNames,
                        &pUnicodeResult);

        if ( NO_ERROR != dwErr )
        {
            goto Cleanup;
        }

        // Convert return data to ANSI.  Since UNICODE strings are twice the
        // length of ANSI strings and since the RPC return data is already
        // MIDL allocated, we convert in place without having to reallocate.

        unicodeBufferSize = 2048;
        unicodeBuffer = (WCHAR *) LocalAlloc(LPTR, unicodeBufferSize);

        if ( NULL == unicodeBuffer )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        for ( i = 0; i < pUnicodeResult->cItems; i++ )
        {
            // Note that DsCrackNamesW can return data even if
            // pUnicodeResult->rItems[i].status is non-zero.
            // Eg: DS_NAME_ERROR_DOMAIN_ONLY case.

            // Insure conversion buffer is big enough.

            if ( NULL != pUnicodeResult->rItems[i].pDomain )
            {
                cbDomain = sizeof(WCHAR) *
                           (wcslen(pUnicodeResult->rItems[i].pDomain) + 1);
            }
            else
            {
                cbDomain = 0;
            }

            if ( NULL != pUnicodeResult->rItems[i].pName )
            {
                cbName = sizeof(WCHAR) *
                         (wcslen(pUnicodeResult->rItems[i].pName) + 1);
            }
            else
            {
                cbName = 0;
            }

            cb = (cbName > cbDomain) ? cbName : cbDomain;

            if ( cb > unicodeBufferSize )
            {
                // Reallocate unicodeBuffer.

                LocalFree(unicodeBuffer);
                unicodeBufferSize = cb;
                unicodeBuffer = LocalAlloc(LPTR, unicodeBufferSize);

                if ( NULL == unicodeBuffer )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
            }

            // Convert domain name.

            if ( NULL != pUnicodeResult->rItems[i].pDomain )
            {
                wcscpy(unicodeBuffer, pUnicodeResult->rItems[i].pDomain);

                if ( 0 == WideCharToMultiByte(
                                    CP_ACP,
                                    0,                          // flags
                                    unicodeBuffer,
                                    -1,
                                    (LPSTR) pUnicodeResult->rItems[i].pDomain,
                                    cbDomain,
                                    NULL,                       // default char
                                    NULL) )                     // default used
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
            }

            // Convert object name.

            if ( NULL != pUnicodeResult->rItems[i].pName )
            {
                wcscpy(unicodeBuffer, pUnicodeResult->rItems[i].pName);

                if ( 0 == WideCharToMultiByte(
                                    CP_ACP,
                                    0,                          // flags
                                    unicodeBuffer,
                                    -1,
                                    (LPSTR) pUnicodeResult->rItems[i].pName,
                                    cbName,
                                    NULL,                       // default char
                                    NULL) )                     // default used
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
            }
        }

        if ( 0 == dwErr )
        {
            *ppResult = (DS_NAME_RESULTA *) pUnicodeResult;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        *ppResult = NULL;
    }

Cleanup:

    if ( NULL != rpUnicodeNames )
    {
        for ( i = 0; i < cNames; i++ )
        {
            LocalFree(rpUnicodeNames[i]);
        }

        LocalFree(rpUnicodeNames);
    }

    if ( NULL != unicodeBuffer )
    {
        LocalFree(unicodeBuffer);
    }

    if ( (0 != dwErr) && (NULL != pUnicodeResult) )
    {
        DsFreeNameResultW(pUnicodeResult);
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeNameResultW                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeNameResultW(
    DS_NAME_RESULTW *pResult

)

/*++

Routine Description:

    Releases data returned by DsCrackNamesW.

Arguments:

    pResult - DS_NAME_RESULTW as returned by DsCrackNamesW.

Return Value:

    None.

--*/

{
    DWORD i;

    if ( NULL != pResult )
    {
        if ( NULL != pResult->rItems )
        {
            for ( i = 0; i < pResult->cItems; i++ )
            {
                if ( NULL != pResult->rItems[i].pDomain )
                {
                    MIDL_user_free(pResult->rItems[i].pDomain);
                }

                if ( NULL != pResult->rItems[i].pName )
                {
                    MIDL_user_free(pResult->rItems[i].pName);
                }
            }

            MIDL_user_free(pResult->rItems);
        }

        MIDL_user_free(pResult);
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeNameResultA                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeNameResultA(
    DS_NAME_RESULTA *pResult
    )

/*++

Routine Description:
Arguments:
Return Value:

    See DsFreeNameResultW.

--*/

{
    DsFreeNameResultW((DS_NAME_RESULTW *) pResult);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// LocalConvertStringSidToSid                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// This routine is copied almost verbatim from windows\base\advapi\sddl.c
// because the string SID conversion routines are not available on win95.
// Once they become available, we should use the public routines in sddl.h.

BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_NONE_MAPPED indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;
    WCHAR Stub = 0, *StubPtr = NULL;
    ULONG Index;

    if (    (wcslen(StringSid) < 2)
         || ((*StringSid != L'S') && (*StringSid != L's'))
         || (*(StringSid + 1) != L'-') ) {

        SetLastError( ERROR_NONE_MAPPED );
        return( FALSE );
    }

    Curr = StringSid + 2;

    Revision = ( UCHAR )wcstol( Curr, &CurrEnd, 10 );

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );

    if ( Next && ((Next - Curr) == 6) ) {

        for ( Index = 0; Index < 6; Index++ ) {

            IDAuth.Value[Index] = (UCHAR)Next[Index];
        }

        Curr +=6;

    } else {

         ULONG Auto = wcstoul( Curr, &CurrEnd, 10 );
         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         IDAuth.Value[5] = ( UCHAR )Auto & 0xF;
         IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
         IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
         IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
         Curr = CurrEnd;
    }

    //
    // Now, count the number of sub auths
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //
    while ( Next ) {

        Next++;

        if ( *Next == L'-' ) {

            //
            // We've found one!
            //
            Subs++;

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' || *Next == SDDL_ACE_ENDC ) {

            if ( *( Next - 1 ) == L'-' ) {

                Next--;
            }

            *End = Next;
            Subs++;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            *End = Next;
            Subs++;
            break;

        } else {

            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == 'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We'll also need to temporarily truncate the string to this length so
                // we don't accidentally include the character in one of the conversions
                //
                Stub = *Next;
                StubPtr = Next;
                *StubPtr = UNICODE_NULL;
                *End = Next;
                Subs++;
                break;
            }

        }
    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, 10 );
                    Curr = CurrEnd + 1;
                }
            }

        } else {

            Err = ERROR_NONE_MAPPED;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            memcpy( &( ISid->IdentifierAuthority ), &IDAuth,
                           sizeof( SID_IDENTIFIER_AUTHORITY ) );
            memcpy( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) );
        }
    }

    LocalFree( SubAuth );

    //
    // Restore any character we may have stubbed out
    //
    if ( StubPtr ) {

        *StubPtr = Stub;
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}
                         
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// IsFPO                                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

BOOL
IsFPO(
    RdnValue        *pRdn,
    ATTRTYP         type
    )
/*++

  Routine Description:

    Determines if a particular RdnValue is a string SID or not.  This is
    imperfect as an FPO may have been renamed to a non-string-SID RDN, or
    there can exist a non-FPO whose RDN is a string SID.  But it is the 
    best we can do during a syntactic map.  The server side does the
    right thing when we are not restricted to purely syntactical mapping.

  Parameters:

    pRdn - pointer to RdnValue to check.

    type - ATTRTYP of the RDN.

  Return Values:

--*/
{
    SID     *pSid;
    WCHAR   *pEnd;

    // The RDN-Att-ID for foreign security principals is Common-Name.
    // String SIDs are less than MAX_RDN_SIZE in length, therefore we can
    // use that as a quick sanity check, and also as an assurance that we
    // can NULL terminate the RDN within the provided buffer.

    if ( (ATT_COMMON_NAME != type) || (pRdn->len >= MAX_RDN_SIZE) )
    {
        return(FALSE);
    }

    pRdn->val[pRdn->len] = L'\0';

    if ( LocalConvertStringSidToSid(pRdn->val, &pSid, &pEnd) )
    {
        if ( pEnd == &pRdn->val[pRdn->len] )
        {
            LocalFree(pSid);
            return(TRUE);
        }

        LocalFree(pSid);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\bind.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Implementation of ntdsapi.dll bind routines.

Author:

    DaveStr     24-Aug-96

Environment:

    User Mode - Win32

Revision History:

    wlees 9-Feb-98  Add support for credentials
--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <drs_w.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions
#include <stdio.h>          // for printf during debugging!
#include <dststlog.h>       // DSLOG
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#define SECURITY_WIN32 1
#include <sspi.h>
#include <winsock.h>
#include <process.h>
#include <winldap.h>
#include <winber.h>

#include "util.h"           // ntdsapi internal utility functions
#include "dsdebug.h"        // debug utility functions

//
// For DPRINT...
//
#define DEBSUB  "NTDSAPI_BIND:"

DEFINE_DSLOG;

#ifdef INCLUDE_UNIT_TESTS

#define DSA_CONFIG_SECTION      "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
#define DSBIND_PROTSEQW L"DsBind ProtSeq"
#define DSBIND_ENDPOINTW L"DsBind Endpoint"

//
// I had to steal this from dscommon because they define DPRINT differently than this
// code does.  If it wasn't only for unit test code, I'd probably have done 
// something about it.  
//

DWORD
GetConfigParamAllocW(
    IN  PWCHAR  parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize)
/*++

Routine Description:

    Reads a value out of the DSA_CONFIG_SECTION of the registry, and 
    returns a newly allocated buffer containing the value.
    
    This version of GetConfigParamAlloc uses the the wide character version
    of RegQueryValueExW.
    
Parameters

    parameter - The name of the value to read.

    value     - Used to pass back a pointer to the newly allocated buffer 
                containing the value that was read.  The buffer must be freed
                with free().
                
    pdwSize   - Used to pass back the size of the buffer allocated.

Return values:

    0 if all went well, otherwise a Win32 error code.

++*/
{

    DWORD err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%S\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) {
         
        DPRINT2( 1, " ** [%S] key not found. Status = %d\n",
            DSA_CONFIG_SECTION, err );
        return err;
    }
        
    //
    // Find out how big the buffer needs to be.
    //
    if (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) NULL, pdwSize)) {

        DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

        goto cleanup;
    }
    
    *value = malloc(*pdwSize);
    if (!*value) {
        DPRINT1( 1, " ** GetConfigParamAlloc failed to allocate %d bytes.\n", *pdwSize );
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) *value, pdwSize)) {

            DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
                DSA_CONFIG_SECTION, parameter, err );
            free(*value); *value = NULL;

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"%S\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }

cleanup:
    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}
#endif



DWORD
NtdsapiGetBinding(
    LPCWSTR             pwszAddress,
    RPC_BINDING_HANDLE  *phRpc,
    RPC_IF_HANDLE       clientIfHandle
    )
/*++

  Description:

    We used to call the ASCII-only routines in _clw to get an RPC binding
    to the server - but this is insufficient for internationalized server
    names.  Noting that a DS client needs tcp/ip connectivity if it is ever
    to do something more than what's in ntdsapi.dll (a likely requirement)
    then it is sufficient that DsBind* restrict itself to tcp/ip as well.
  Arguments:

    pwszAddress - Address to bind to.

    phRpc - Pointer to binding handle updated on return.

  Return Value:

    RPC error code, 0 on success

--*/
{
    DWORD   dwErr = 0;
    WCHAR   *pwszStringBinding = NULL;
    LPWSTR pszProtSeq = TCP_PROTSEQW;
    LPWSTR pszEndpoint = NULL;

    LPWSTR pszTempProtSeq = NULL;
    LPWSTR pszTempEndpoint = NULL;
    DWORD dw = 0;

    #ifdef INCLUDE_UNIT_TESTS
    //
    // Attempt to read the protseq and endpoint from the registry
    //

    if (!GetConfigParamAllocW(DSBIND_PROTSEQW, &pszTempProtSeq, &dw)) {
	DPRINT1(0,"UNIT_TEST:  Using alternate ProtSeq for DSBIND - %S\n", pszTempProtSeq);
	pszProtSeq = pszTempProtSeq;
    }

    if (!GetConfigParamAllocW(DSBIND_ENDPOINTW, &pszTempEndpoint, &dw)) {
	DPRINT1(0,"UNIT_TEST:  Using alternate Endpoint for DSBIND - %S\n", pszTempEndpoint);
	pszEndpoint = pszTempEndpoint;
    }
    #endif

    *phRpc = NULL;

    if ( 0 == wcsncmp(pwszAddress, L"\\\\", 2) )
    {
        pwszAddress += 2;
    }

    RpcTryExcept
    {
        dwErr = RpcStringBindingComposeW(
                                        NULL,
                                        pszProtSeq,
                                        (WCHAR *) pwszAddress,
                                        pszEndpoint,
                                        NULL,
                                        &pwszStringBinding);

        if ( RPC_S_OK == dwErr )
        {
            dwErr = RpcBindingFromStringBindingW(pwszStringBinding, phRpc);

            if ( RPC_S_OK == dwErr )
            {
                DPRINT(0, "RpcEpResolveBinding:\n");
                DPRINT1(0, "    pwszAddress : %ws\n", pwszAddress);
                dwErr = RpcEpResolveBinding(
                                        *phRpc,
                                        clientIfHandle);
                DPRINT1(0, "RpcEpResolveBinding ==> 0x%x\n", dwErr);
            }
        }
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        dwErr = RpcExceptionCode();
        DPRINT1(0, "RpcEpResolveBinding Exception ==> 0x%x\n", dwErr);
    }
    RpcEndExcept;

    if ( pwszStringBinding )
    {
        RpcStringFreeW(&pwszStringBinding);
    }

    if ( dwErr && *phRpc )
    {
        RpcBindingFree(phRpc);
    }

    #ifdef INCLUDE_UNIT_TESTS 
    if (pszTempProtSeq) {
	free(pszTempProtSeq);
    }
    if (pszTempEndpoint) {
	free(pszTempEndpoint);
    }
    #endif

    return(dwErr);
}

DWORD
NtdsapiBindingSetAuthInfoExW(
    RPC_BINDING_HANDLE          hRpc,
    WCHAR                       *pwszSpn,
    ULONG                       AuthnLevel,
    ULONG                       AuthnSvc,
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity,
    ULONG                       AuthSvc,
    RPC_SECURITY_QOS            *pQos
    )
/*++

  Description:

    Private version of RpcBindingSetAuthInfoExW which calls the A version
    on win9x since 'W' version is not supported there.

  Arguments:

    Same as for RpcBindingSetAuthInfoExW.

  Return Values:

    WIN32 error code

--*/
{
    DWORD   dwErr = RPC_S_OK;
    CHAR    *pszSpn = NULL;

    RpcTryExcept
    {
#ifdef WIN95

        dwErr = AllocConvertNarrow(pwszSpn, &pszSpn);

        if ( ERROR_SUCCESS == dwErr )
        {
            // Sorry, but the 'Ex' version is not supported on WIN95,
            // so we just punt on the entire QOS stuff.

            dwErr = RpcBindingSetAuthInfoA(hRpc, pszSpn, AuthnLevel,
                                           AuthnSvc, AuthIdentity, AuthSvc);
        }
#else
        dwErr = RpcBindingSetAuthInfoExW(hRpc, pwszSpn, AuthnLevel,
                                         AuthnSvc, AuthIdentity,
                                         AuthSvc, pQos);
#endif
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        dwErr = RpcExceptionCode();
    }
    RpcEndExcept;

    if ( pszSpn) LocalFree(&pszSpn);

    return(dwErr);
}

BOOL
IsIpAddr(
    LPCWSTR pwsz
    )
/*++
    Simple test for whether a string is an IP address or not. We'd like
    to test for (INADDR_NONE != inet_addr(ipAddr)) but this seems to
    take long to execute - maybe it goes off machine.  So we simply
    check for length, occurrences of '.' and test all characters.
--*/
{
    DWORD   cChar = wcslen(pwsz);
    DWORD   cDot = 0;
    WCHAR   c;

    if ( cChar <= 15 )
    {
        while ( c = *(pwsz++) )
        {
            if ( iswdigit(c) )
            {
                continue;
            }
            else if ( L'.' == c )
            {
                cDot++;
            }
            else
            {
                return(FALSE);
            }
        }

        if ( 3 == cDot )
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

DWORD
SetUpMutualAuthAndEncryption(
    RPC_BINDING_HANDLE          hRpc,
    LPCWSTR                     DomainControllerName,
    LPCWSTR                     DnsDomainName,
    DOMAIN_CONTROLLER_INFOW     *pDcInfo,
    ULONG                       AuthnSvc,
    ULONG                       AuthnLevel,
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity,
    LPCWSTR                     ServicePrincipalName,
    ULONG                       ImpersonationType
    )
/*++

  Description:

    Sets up mutual authentication between client and service.

  Arguments:

    hRpc - Valid RPC binding handle to server.

    DomainControllerName - Same as for DsBind* - may be NULL.

    DnsDomainName - Same as for DsBind* - may be NULL.

    pDcInfo - DOMAIN_CONTROLLER_INFOW pointer in case original DsBind*
        arguments required us to find a DC for them.

    AuthnSvc - Specification of which authentication service is desired.

    AuthIdentity - Client credentials - may be NULL.

    ServicePrincipalName - SPN to use or NULL.

    ImpersonationType - IMPERSONATE or DELEGATE
    
    AuthnLevel - the authentication protection level needed (e.g. RPC_C_PROTECT_LEVEL_PKT_PRIVACY)
                 if not specified (0), the default (RPC_C_PROTECT_LEVEL_PKT_PRIVACY) is used.

  Return Values:

    Either RPC or WIN32 error code, 0 on success.

--*/
{
    DWORD               dwErr, dwErr1, cChar;
    LPCWSTR             pwszService = NULL;
    LPCWSTR             pwszInstance = NULL;
    WCHAR               *pwszTmpService = NULL;
    WCHAR               *pwszTmpInstance = NULL;
    WCHAR               *svcClass = L"LDAP";
    WCHAR               *pwszSpn = NULL;
    ULONG               AuthnLevel1;
    ULONG               AuthnSvc1;
    RPC_SECURITY_QOS    qos, qos1;

    // Mutual authentication via SPNs only makes sense if you can construct
    // the server's SPN a-priori.  For true security, you need to take this
    // literally.  For example, you can't generate SPN components by doing
    // lookups in DNS, or calling DsGetDcName which in turn calls DNS or other
    // components.  The reason is that any of those other components may be
    // compromised and work in concert with a destination server to spoof you.
    // Thus we construct SPNs strictly from the client's original DsBind args.

#if WIN95 || WINNT4
    // Mutual auth not supported on WIN95 or WINNT4 yet, and there are
    // negotiate problems as well.
    AuthnSvc = RPC_C_AUTHN_WINNT;
#endif

    if (AuthnLevel == 0) {
        AuthnLevel = RPC_C_PROTECT_LEVEL_PKT_PRIVACY;
    }

    if ( (RPC_C_AUTHN_WINNT != AuthnSvc) && !ServicePrincipalName )
    {
        // Test for each combination of original DsBind* arguments.

        if ( DomainControllerName && DnsDomainName )
        {
            // Caller gave all components needed to construct full 3-part SPN.
            pwszInstance = DomainControllerName;
            pwszService = DnsDomainName;
        }
        else if ( DomainControllerName && !DnsDomainName )
        {
            // Construct SPN of form: LDAP/ntdsdc4.ntdev.microsoft.com
            pwszInstance = DomainControllerName;
            pwszService = DomainControllerName;
        }
        else if ( !DomainControllerName && DnsDomainName )
        {
            // In this case DsBind* called DsGetDcName and pDcInfo is valid
            // and PaulLe says it is OK to use its DomainControllerName
            // to construct a full 3-part SPN.
            pwszInstance = pDcInfo->DomainControllerName;
            pwszService = DnsDomainName;
        }
        else
        {
            // Caller gave all NULL arguments which meant we were to find
            // a GC and also means they have no mutual auth requirements.
            // Construct SPN of form GC/host/forest.
            pwszInstance = pDcInfo->DomainControllerName;
            pwszService = pDcInfo->DnsForestName;
            svcClass = L"GC";
        }

        // Skip past leading "\\" if present.  This is not circumventing
        // a client who has passed NetBIOS names mistakenly but rather
        // helping the client which has passed args as returned by
        // DsGetDcName which prepends "\\" even when DS_RETURN_DNS_NAME
        // was requested.

        if (0 == wcsncmp(pwszInstance, L"\\\\", 2)) pwszInstance += 2;
        if (0 == wcsncmp(pwszService, L"\\\\", 2)) pwszService += 2;

        // Strip trailing '.' if it exists.  We do this as we know
        // the server side registers dot-less names only.  We can't whack
        // in place as the input args are const.

        cChar = wcslen(pwszInstance);
        if ( L'.' == pwszInstance[cChar - 1] )
        {
            pwszTmpInstance = (WCHAR *) alloca(cChar * sizeof(WCHAR));
            memcpy(pwszTmpInstance, pwszInstance, cChar * sizeof(WCHAR));
            pwszTmpInstance[cChar - 1] = L'\0';
            pwszInstance = (LPCWSTR) pwszTmpInstance;
        }

        cChar = wcslen(pwszService);
        if ( L'.' == pwszService[cChar - 1] )
        {
            pwszTmpService = (WCHAR *) alloca(cChar * sizeof(WCHAR));
            memcpy(pwszTmpService, pwszService, cChar * sizeof(WCHAR));
            pwszTmpService[cChar - 1] = L'\0';
            pwszService = (LPCWSTR) pwszTmpService;
        }

        // Check for IP addresses which can not be used for mutual auth.

        if ( IsIpAddr(pwszInstance) )
        {
#ifndef WIN95
//          STARTUPINFOW startupInfo;
//          GetStartupInfoW(&startupInfo);
//          DbgPrint("Warning - %ws trying mutual auth to IP addr: %ws\n",
//                   startupInfo.lpTitle, pwszInstance);
#endif
            DPRINT(0, "Attempt mutual auth with IP address.\n");
            goto MakeSPN;
        }

        // Check for NetBIOS names which can not be used for mutual auth.
        // 2/20/99 - Security run times check some global setting and either
        // fail mutual auth or quietly ignore the request.  So we can just
        // pass the args through unchanged, however we check so as to
        // generate warnings.

        if (    (    pwszInstance
                  && !wcschr(pwszInstance, L'.'))
             || (    pwszService
                  && !wcschr(pwszService, L'.')) )
        {
#ifndef WIN95
//          STARTUPINFOW startupInfo;
//          GetStartupInfoW(&startupInfo);
//          DbgPrint("Warning - %ws trying mutual auth to NB addr: %ws:%ws\n",
//                   startupInfo.lpTitle, pwszInstance, pwszService);
#endif
            DPRINT(0, "Attempt mutual auth with NetBIOS name.\n");
        }
    }

    // Now make the SPN.

MakeSPN:

    if ( RPC_C_AUTHN_WINNT == AuthnSvc )
    {
        pwszSpn = SERVER_PRINCIPAL_NAMEW;
    }
    else if ( ServicePrincipalName )
    {
        pwszSpn = (WCHAR *) ServicePrincipalName;
    }
    else
    {
        cChar = 0;
        dwErr = DsMakeSpnW(svcClass, pwszService, pwszInstance, 0,
                           NULL, &cChar, NULL);

        if ( dwErr && (ERROR_BUFFER_OVERFLOW != dwErr) )
        {
            DPRINT1(0, "DsMakeSpnW ==> 0x%x\n", dwErr);
            return(dwErr);
        }

        if ( !(pwszSpn = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * cChar)) )
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        dwErr = DsMakeSpnW(svcClass, pwszService, pwszInstance, 0,
                           NULL, &cChar, pwszSpn);

        if ( dwErr )
        {
            DPRINT1(0, "DsMakeSpnW ==> 0x%x\n", dwErr);
            LocalFree(pwszSpn);
            return(dwErr);
        }
    }

    RpcTryExcept
    {
        qos.Version = RPC_C_SECURITY_QOS_VERSION;
        qos.Capabilities = ((RPC_C_AUTHN_WINNT == AuthnSvc) || (AuthnSvc == RPC_C_AUTHN_NONE))
                                ? RPC_C_QOS_CAPABILITIES_DEFAULT
                                : RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        qos.ImpersonationType = (RPC_C_AUTHN_WINNT == AuthnSvc)
                                ? RPC_C_IMP_LEVEL_DEFAULT
                                : ImpersonationType;

        DPRINT(0, "Authentication Info:\n");
        DPRINT1(0, "    SPN                ==> %ws\n", pwszSpn);
        DPRINT1(0, "    AuthnLevel         ==> %s\n",
            RPC_C_PROTECT_LEVEL_DEFAULT == AuthnLevel
                ? "RPC_C_PROTECT_LEVEL_DEFAULT"
                : (RPC_C_PROTECT_LEVEL_PKT_PRIVACY ==  AuthnLevel)
                    ? "RPC_C_PROTECT_LEVEL_PKT_PRIVACY"
                    : (RPC_C_AUTHN_LEVEL_NONE == AuthnLevel) 
                        ? "RPC_C_AUTHN_LEVEL_NONE"
                        : "???");
        DPRINT1(0, "    AuthnSvc           ==> %s\n",
            RPC_C_AUTHN_WINNT == AuthnSvc
                ? "RPC_C_AUTHN_WINNT"
                : RPC_C_AUTHN_GSS_NEGOTIATE == AuthnSvc
                    ? "RPC_C_AUTHN_GSS_NEGOTIATE"
                    : (RPC_C_AUTHN_GSS_KERBEROS == AuthnSvc)
                    ? "RPC_C_AUTHN_GSS_KERBEROS"
                    : (RPC_C_AUTHN_NONE == AuthnSvc)
                        ? "RPC_C_AUTHN_NONE"
                        : "???");
        DPRINT1(0, "    qos.Capabilities   ==> %s\n",
            RPC_C_QOS_CAPABILITIES_DEFAULT == qos.Capabilities
                ? "RPC_C_QOS_CAPABILITIES_DEFAULT"
                : "RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH");
        DPRINT1(0, "    qos.ImpersonationType   ==> %s\n",
            (RPC_C_IMP_LEVEL_DEFAULT == qos.ImpersonationType)
                ? "RPC_C_IMP_LEVEL_DEFAULT"
                : (RPC_C_IMP_LEVEL_IMPERSONATE == qos.ImpersonationType)
                      ? "RPC_C_IMP_LEVEL_IMPERSONATE"
                      : (RPC_C_IMP_LEVEL_DELEGATE == qos.ImpersonationType)
                            ? "RPC_C_IMP_LEVEL_DELEGATE"
                            : (RPC_C_IMP_LEVEL_ANONYMOUS == qos.ImpersonationType)
                                ? "RPC_C_IMP_LEVEL_ANONYMOUS"
                                : "???");

        dwErr = NtdsapiBindingSetAuthInfoExW(
                                hRpc,
                                pwszSpn,
                                AuthnLevel,
                                AuthnSvc,
                                AuthIdentity,
                                0,
                                &qos);
        DPRINT1(0, "NtdsapiBindingSetAuthInfoExW ==> 0x%x\n", dwErr);

#if DBG
#ifndef WIN95
        if ( !dwErr )
        {
            dwErr1 = RpcBindingInqAuthInfoExW(
                                hRpc,
                                NULL,
                                &AuthnLevel1,
                                &AuthnSvc1,
                                NULL,
                                NULL,
                                RPC_C_SECURITY_QOS_VERSION,
                                &qos1);
            DPRINT1(0, "RpcBindingInqAuthInfoExW ==> 0x%x\n", dwErr1);

            if ( !dwErr1 )
            {
                DPRINT2(0, "\tCapabilities:        %d ==> %d\n",
                    qos.Capabilities, qos1.Capabilities);
                DPRINT2(0, "\tIdentityTracking:    %d ==> %d\n",
                    qos.IdentityTracking, qos1.IdentityTracking);
                DPRINT2(0, "\tImpersonationType:   %d ==> %d\n",
                    qos.ImpersonationType, qos1.ImpersonationType);
                DPRINT2(0, "\tAuthnSvc:            %d ==> %d\n",
                    AuthnSvc, AuthnSvc1);
                DPRINT2(0, "\tAuthnLevel:          %d ==> %d\n",
                    AuthnLevel, AuthnLevel1);
            }
        }
#endif
#endif
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        dwErr = RpcExceptionCode();
        DPRINT1(0, "NtdsapiBindingSetAuthInfoExW Exception ==> 0x%x\n", dwErr);
    }
    RpcEndExcept;

    if (    pwszSpn
         && (RPC_C_AUTHN_WINNT != AuthnSvc)
         && (pwszSpn != ServicePrincipalName) )
    {
        LocalFree(pwszSpn);
    }

    return(dwErr);
}

DWORD
DsBindA(
    IN  LPCSTR  DomainControllerName,
    IN  LPCSTR  DnsDomainName,
    OUT HANDLE  *phDS
    )

/*++

Routine Description:

    Public wrapper for cred-less version of DsBindWithCredA.
    Default process credentials are used.
    See below.

Arguments:

    DomainControllerName -
    DnsDomainName -
    phDS -

Return Value:

    DWORD -

--*/

{
    return DsBindWithCredA( DomainControllerName,
                            DnsDomainName,
                            NULL, // credentials
                            phDS );
} /* DsBindA */


DWORD
DsBindW(
    LPCWSTR DomainControllerName,
    LPCWSTR DnsDomainName,
    HANDLE  *phDS
    )

/*++

Routine Description:

    Public wrapper for cred-less version of DsBindWithCredW
    Default process credentials are used.
    See below.

Arguments:

    DomainControllerName -
    DnsDomainName -
    phDS -

Return Value:

    DWORD -

--*/

{
    return DsBindWithCredW( DomainControllerName,
                            DnsDomainName,
                            NULL, // credentials
                            phDS );
} /* DsBindW */

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithSpnExW                                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// Dup this definition from sdk\inc\crt\wchar.h since there it is
// within a #ifdef __cplusplus sentinel which we don't trigger..

const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
{
    for ( ; 0 < _N; ++_S, --_N )
        if ( *_S == _C )
            return(_S);
    return (0);
}

BOOL
IsServerUnavailableError(
    DWORD   dwErr
    )
{
    // This list of error codes blessed by MazharM on 4/20/99.

    switch ( dwErr )
    {
    case RPC_S_SERVER_UNAVAILABLE:      // can't get there from here
    case EPT_S_NOT_REGISTERED:          // demoted or in DS repair mode
    case RPC_S_UNKNOWN_IF:              // demoted or in DS repair mode
    case RPC_S_INTERFACE_NOT_FOUND:     // demoted or in DS repair mode
    case RPC_S_COMM_FAILURE:            // can't get there from here
        return(TRUE);
    }

    return(FALSE);
}

DWORD
DsBindWithSpnExW(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  LPCWSTR ServicePrincipalName,
    IN  DWORD   BindFlags,
    OUT HANDLE  *phDS
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials, and possible options
    from flags.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL.

    ServicePrincipalName - SPN to use during mutual auth or NULL.
    
    BindFlags - These are the flags to signal DsBind() how it should work.
        See ntdsapi.h for valid NTDSAPI_BIND_* flags.  All bits should
        be zero that are not used.

        IMPORTANT - IF YOU INTRODUCE NEW BINDING FLAGS, make sure you
        also goto bind-postxp.c and decide how you want to treat those 
        new flags in the case of a client who doesn't have access to
        the new bind function.  Currently, it will fail.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.

Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/

{
    DWORD                   dwErr;
    DOMAIN_CONTROLLER_INFOW *pDcInfo = NULL;
    RPC_BINDING_HANDLE      hRpc;
    GUID                    guid = NtdsapiClientGuid;
    LPCWSTR                 pBindingAddress;
    ULONG                   flags;
    DRS_HANDLE              hDrs;
    PDRS_EXTENSIONS         pServerExtensions;
    ULONG                   AuthnSvc;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif
    DRS_EXTENSIONS_INT      ClientExtensions = {0};

    // We perform special semantics for explicit credentials whose
    // username has an "@" in it.  The assumption is that "@" is rare in
    // legacy user names, thus existence of an "@" probably means a UPN
    // has been presented.  The security subsystem makes the distinction
    // between a NULL domain and the empty string ("") domain.  For reasons
    // only the security people understand, the NULL domain can not be
    // used to authenticate UPNs.  And unfortunately few of the apps which
    // pass in explicit credentials can be expected to know this, much less
    // whether the user name field is a UPN or not.  So if the user name
    // contains "@" and the domain field is NULL, we substitute the empty
    // string for the NULL domain.  If this fails with ERROR_ACCESS_DENIED
    // and the user name is <= 20 chars, than it might indeed be a legacy
    // user name with an "@" in it, and we retry once with the NULL domain
    // again.

    DWORD                       cNullDomainRetries = 0;
    DWORD                       cUnavailableRetries = 0;
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo;
    PWCHAR                      emptyStringAorW = L"";
    BOOL                        fNullDomainRetryWarranted = FALSE;
    ULONG                       ImpersonationType;

    // Pass process ID to server.  Used to help track DRS handle leaks.
    ClientExtensions.cb = sizeof(DRS_EXTENSIONS_INT) - sizeof(DWORD);
    ClientExtensions.pid = _getpid();

    __try
    {
        // All fields of SEC_WINNT_AUTH_IDENTITY are in the same place in A and W
        // versions so assign temp variable at the same time we test for NULL.

        if (    (pAuthInfo = (PSEC_WINNT_AUTH_IDENTITY_W) AuthIdentity)
                && !pAuthInfo->Domain )
        {
            if (    (    (SEC_WINNT_AUTH_IDENTITY_UNICODE & pAuthInfo->Flags)
                         && wmemchr(pAuthInfo->User, L'@',
                                    pAuthInfo->UserLength) )
                    || (    (SEC_WINNT_AUTH_IDENTITY_ANSI & pAuthInfo->Flags)
                            && memchr((PCHAR) pAuthInfo->User, '@',
                                      pAuthInfo->UserLength) ) ) 
            {
                pAuthInfo->Domain = emptyStringAorW;
                pAuthInfo->DomainLength = 0;
                fNullDomainRetryWarranted = TRUE;
                DPRINT(0, "NULL domain for name with '@' in it\n");
            }
        }

        DsBindRetry:

        dwErr = NO_ERROR;
        hRpc = NULL;
        pBindingAddress = NULL;
        flags = ( DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME );
        hDrs = NULL;
        pServerExtensions = NULL;

        // Sanity check arguments.

        if ( NULL == phDS )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        *phDS = NULL;

        if ( NULL != DomainControllerName )
        {
            pBindingAddress = DomainControllerName;
        } 
        else 
        {
            // Find a DC to talk to.

            if ( NULL == DnsDomainName )
            {
                flags |= DS_GC_SERVER_REQUIRED;
            }

            if ( 1 == cUnavailableRetries )
            {
                flags |= DS_FORCE_REDISCOVERY;
            }


            if (NULL == pDcInfo)
            {
                RpcTryExcept
                {
                    DPRINT(0, "DsGetDcNameW:\n");
                    DPRINT1(0, "    flags        : %08x\n", flags);
                    DPRINT1(0, "    ComputerName : %ws\n", NULL);
                    DPRINT1(0, "    DnsDomainName: %ws\n", DnsDomainName);
                    dwErr = DsGetDcNameW(
                                        NULL,                       // computer name
                                        DnsDomainName,              // DNS domain name
                                        NULL,                       // domain guid
                                        NULL,                       // site guid
                                        flags,
                                        &pDcInfo);
                }
                RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
                {
                    dwErr = RpcExceptionCode();
                }
                RpcEndExcept;

                DPRINT1(0, "DsGetDcNameW ==> 0x%x\n", dwErr);

                if ( NO_ERROR != dwErr )
                {
                    return(dwErr);
                }
            }
            pBindingAddress = pDcInfo->DomainControllerName;
        }

        DPRINT(0, "NtdsapiGetBinding:\n");
        DPRINT1(0, "    pBindingAddress: %ws\n", pBindingAddress);
        dwErr = NtdsapiGetBinding(pBindingAddress, &hRpc, _drsuapi_ClientIfHandle);
        DPRINT1(0, "NtdsapiGetBinding ==> 0x%x\n", dwErr);

        if ( 0 == dwErr ) 
        {
            if ( NULL != hRpc ) 
            {
                // Sometimes, it helps to force kerberos when debugging
                // AuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;
                AuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE; 

                ImpersonationType = (BindFlags & NTDSAPI_BIND_ALLOW_DELEGATION) ?  
                                        RPC_C_IMP_LEVEL_DELEGATE : 
                                        RPC_C_IMP_LEVEL_IMPERSONATE;;
                ImpersonateRetry:
                // Make sure to pass caller's original DomainControllerName
                // and DnsDomainName - not something we derived else we are
                // circumventing caller's control of mutual authentication.
                dwErr = SetUpMutualAuthAndEncryption(
                                                    hRpc,
                                                    DomainControllerName,
                                                    DnsDomainName,
                                                    pDcInfo,
                                                    AuthnSvc,
                                                    RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                                                    AuthIdentity,
                                                    ServicePrincipalName,
                                                    ImpersonationType);
                if ( RPC_S_OK == dwErr )
                {

                    RpcTryExcept
                    {
                        dwErr = _IDL_DRSBind(
                                            hRpc,
                                            &guid,
                                            (DRS_EXTENSIONS *) &ClientExtensions,
                                            &pServerExtensions,
                                            &hDrs);
                        DPRINT1(0, "IDL_DRSBind ==> 0x%x\n", dwErr);
                        MAP_SECURITY_PACKAGE_ERROR( dwErr );
                        DPRINT1(0, "IDL_DRSBind ==> (mapped) 0x%x\n", dwErr);
                    }
                    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
                    {

                        dwErr = RpcExceptionCode();
                        // DBG only
                        DPRINT_RPC_EXTENDED_ERROR(dwErr);

                        DPRINT1(0, "IDL_DRSBind exception ==> 0x%x\n", dwErr);
                        MAP_SECURITY_PACKAGE_ERROR( dwErr );
                        DPRINT1(0, "IDL_DRSBind exception ==> (mapped) 0x%x\n", dwErr);   
                    }
                    RpcEndExcept;
                }
                // The target DC doesn't support delegation; retry with
                // simple impersonation. WARN: DsAddSidHistory may fail
                // with ACCESS_DENIED when using this binding-with-impersonation
                // if the caller passes in NULL creds. NULL creds tells
                // DsAddSidHistory to use the caller's creds. DsAddSidHistory
                // then fails because the DstDc is unable to delegate the
                // caller's creds to the SrcDc because IMPERSONATE is
                // used instead of DELEGATE in this binding. However, the
                // call succeeds if the client is running on the DstDc
                // and the DomainControllerName is the NetBIOS name of the
                // DstDc (forces LRPC). Alternatively, Delegation could
                // be enabled at the DstDc.
                if (   SEC_E_SECURITY_QOS_FAILED == dwErr
                       && RPC_C_IMP_LEVEL_DELEGATE == ImpersonationType) {
                    ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
                    goto ImpersonateRetry;
                }

                RpcBindingFree(&hRpc);
            }
            else
            {
                dwErr = RPC_S_NO_BINDINGS;
            }
        }

        if ( !dwErr )
        {
            *phDS = LocalAlloc(LPTR,
                               sizeof(BindState) +
                               sizeof(WCHAR) * (wcslen(pBindingAddress) + 1));

            if ( NULL == *phDS )
            {
                if ( NULL != pServerExtensions )
                {
                    MIDL_user_free(pServerExtensions);
                }

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                memset(*phDS, 0, sizeof(BindState));
                strcpy(((BindState *) *phDS)->signature, NTDSAPI_SIGNATURE);
                ((BindState *) *phDS)->hDrs = hDrs;
                ((BindState *) *phDS)->pServerExtensions = pServerExtensions;
                wcscpy(((BindState *) *phDS)->bindAddr, pBindingAddress);

            }
        }

        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsBind]"));
        DSLOG((0,"[SV=%ws][DN=%ws][PA=%s][ST=%u][ET=%u][ER=%u][-]\n",
               DomainControllerName
               ? DomainControllerName
               : L"NULL",
               DnsDomainName
               ? DnsDomainName
               : L"NULL",
               pBindingAddress, startTime, GetTickCount(), dwErr))


        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
            pDcInfo = NULL;
        }

        // Force rediscovery if we found the server for caller, the server
        // was obviously unavailable, and its our first time through.

        if (    (NULL == DomainControllerName)
                && (0 == cUnavailableRetries)
                && (IsServerUnavailableError(dwErr)) )
        {
            DPRINT(0, "Retrying DsGetDcName with DS_FORCE_REDISCOVERY\n");
            cUnavailableRetries++;
            goto DsBindRetry;
        }

        // Test for NULL domain handling conditions.
        if ( fNullDomainRetryWarranted )
        {
            // We're going to retry or return to caller.  Either way,
            // we need to restore the NULL domain pointer.
            pAuthInfo->Domain = NULL;

            if (    (0 == cNullDomainRetries++)
                    && (ERROR_ACCESS_DENIED == dwErr)
                    && (pAuthInfo->UserLength <= 20) )
            {
                DPRINT(0, "Retrying with NULL domain\n");
                goto DsBindRetry;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = GetExceptionCode();
        DPRINT1(0, "DsBindWithSpnExW() Exception ==> %08x\n", dwErr);
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try
    {
        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithSpnW                                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithSpnW(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  LPCWSTR ServicePrincipalName,
    OUT HANDLE  *phDS
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL.

    ServicePrincipalName - SPN to use during mutual auth or NULL.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.

Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/

{
    return(DsBindWithSpnExW(DomainControllerName, 
                            DnsDomainName, 
                            AuthIdentity, 
                            ServicePrincipalName, 
                            NTDSAPI_BIND_ALLOW_DELEGATION, 
                            phDS));

}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithSpnExA                                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithSpnExA(
    LPCSTR  DomainControllerName,
    LPCSTR  DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPCSTR  ServicePrincipalName,
    DWORD   BindFlags,
    HANDLE  *phDS
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials, and possible options
    from flags.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL

    ServicePrincipalName - SPN to use during mutual auth or NULL.

    BindFlags - These are the flags to signal DsBind() how it should work.
        See ntdsapi.h for valid NTDSAPI_BIND_* flags.  All bits should
        be zero that are not used.
        
    phDS - Pointer to HANDLE which is filled in with BindState address    
        on success.

Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/
{
    DWORD           dwErr = NO_ERROR;
    WCHAR           *pwszAddress = NULL;
    WCHAR           *pwszDomain = NULL;
    WCHAR           *pwszSpn = NULL;
    int             cChar;

    __try
    {
        // Sanity check arguments.

        if ( NULL == phDS )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        *phDS = NULL;

        if ( NULL != DomainControllerName )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DomainControllerName,
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            pwszAddress = (WCHAR *)
                            LocalAlloc(LPTR, sizeof(WCHAR) * (cChar + 1));

            if ( NULL == pwszAddress )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( FALSE == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DomainControllerName,
                                -1,
                                pwszAddress,
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if ( NULL != DnsDomainName )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DnsDomainName,
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            pwszDomain = (WCHAR *)
                            LocalAlloc(LPTR, sizeof(WCHAR) * (cChar + 1));

            if ( NULL == pwszDomain )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( FALSE == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DnsDomainName,
                                -1,
                                pwszDomain,
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if ( NULL != ServicePrincipalName )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                ServicePrincipalName,
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            pwszSpn = (WCHAR *)
                            LocalAlloc(LPTR, sizeof(WCHAR) * (cChar + 1));

            if ( NULL == pwszSpn )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( FALSE == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                ServicePrincipalName,
                                -1,
                                pwszSpn,
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        dwErr = DsBindWithSpnExW(
                    pwszAddress,
                    pwszDomain,
                    AuthIdentity,
                    pwszSpn,
                    BindFlags,
                    phDS);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

Cleanup:

    if ( NULL != pwszAddress )
    {
        LocalFree(pwszAddress);
    }

    if ( NULL != pwszDomain )
    {
        LocalFree(pwszDomain);
    }

    if ( NULL != pwszSpn )
    {
        LocalFree(pwszSpn);
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithSpnA                                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithSpnA(
    LPCSTR  DomainControllerName,
    LPCSTR  DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPCSTR  ServicePrincipalName,
    HANDLE  *phDS
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL

    ServicePrincipalName - SPN to use during mutual auth or NULL.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.

Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/
{
    return(DsBindWithSpnExA(DomainControllerName,
                            DnsDomainName,
                            AuthIdentity,
                            ServicePrincipalName,
                            NTDSAPI_BIND_ALLOW_DELEGATION,
                            phDS));

}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithCredW                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithCredW(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    OUT HANDLE  *phDS
    )
{
    return(DsBindWithSpnW(DomainControllerName, DnsDomainName,
                          AuthIdentity, NULL, phDS));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithCredA                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithCredA(
    LPCSTR  DomainControllerName,
    LPCSTR  DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    HANDLE  *phDS
    )
{
    return(DsBindWithSpnA(DomainControllerName, DnsDomainName,
                          AuthIdentity, NULL, phDS));
}



//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsUnBindW                                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsUnBindW(
    HANDLE  *phDS
    )

/*++

Routine Description:

    Ends an RPC session with the DS.

Arguments:

    phDS - pointer to BindState returned by DsBind(A/W).

Return Value:

    NO_ERROR

--*/

{
    BindState *pState = NULL;

#if DBG
    __try
    {
        // Catch all those people passing a handle instead of
        // pointer to handle.

        if ( !strncmp(((BindState *) phDS)->signature,
                      NTDSAPI_SIGNATURE,
                      strlen(NTDSAPI_SIGNATURE) + 1) )
        {
#ifndef WIN95
            DbgPrint("Process 0x%x passing handle, not &handle to DsUnBind\n",
                     GetCurrentProcessId());
#else
            NULL;
#endif
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        NULL;
    }
#endif

    __try
    {
        pState = (BindState *) *phDS;

        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsUnbind]"));
        DSLOG((0,"[PA=%s][-]\n", pState->bindAddr))

        if ( NULL != pState )
        {
            if ( NULL != pState->pServerExtensions )
            {
                MIDL_user_free(pState->pServerExtensions);
            }

            __try
            {
                // If the server may not be reachable, don't bother
                // attempting the unbind at the server. An unreachable
                // server may take many 10's of seconds to timeout
                // and we wouldn't want to punish correctly behaving
                // apps that are attempting an unbind after a failing
                // server call; eg, DsCrackNames.
                //
                // The server-side RPC will eventually issue a
                // callback to our server code that will effectivly
                // unbind at the server.
                if (!pState->bServerNotReachable) {
                    _IDL_DRSUnbind(&pState->hDrs);
                    pState->hDrs = NULL;
                }
            }
            __finally
            {
                if ( pState->hDrs && (* (VOID **) pState->hDrs) )
                {
                    RpcSsDestroyClientContext(&pState->hDrs);
                }

                LocalFree(pState);
            }
            *phDS = NULL;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        NULL;
    }

    return(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsUnBindA                                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsUnBindA(
    HANDLE  *phDS
    )

/*++

Routine Description:

    Ends an RPC session with the DS.

Arguments:

    phDS - pointer to BindState returned by DsBind(A/W).

Return Value:

    NO_ERROR

--*/

{
    return(DsUnBindW(phDS));
}


NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsW(
    LPCWSTR User,
    LPCWSTR Domain,
    LPCWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )

/*++

Routine Description:

Create a credential structure for use of DsBindWithCred.

A credential structure can apparently self-describe either Ascii or Unicode.
For simplicity, we only create the Unicode version.

Arguments:

    User -
    Domain -
    Password -
    ppAuthIdentity - pointer to pointer, to receive pointer to cred

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    PSEC_WINNT_AUTH_IDENTITY_W pCred = NULL;

    // Validate
    if (pAuthIdentity == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    // User wanted NULL credentials
    if ( (User == NULL) && (Domain == NULL) && (Password == NULL) ) {
        *pAuthIdentity = NULL;
        return ERROR_SUCCESS;
    }

    // Otherwise, must have supplied a username
    if (User == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the credential block

    // Result is zero'd, which simplifies cleanup in later failures
    pCred = LocalAlloc( LPTR, sizeof( SEC_WINNT_AUTH_IDENTITY_W ) );
    if (pCred == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // User parameter
    pCred->UserLength = wcslen( User );
    pCred->User = (LPWSTR) LocalAlloc( LPTR,
                               ( pCred->UserLength + 1 ) * sizeof(WCHAR) );

    if (pCred->User == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pCred->User, User );

    // Domain parameter
    if (Domain) {
        pCred->DomainLength = wcslen( Domain );
        pCred->Domain = (LPWSTR) LocalAlloc( LPTR,
                                   ( pCred->DomainLength + 1 ) * sizeof(WCHAR) );

        if (pCred->Domain == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy( pCred->Domain, Domain );
    }

    // Password parameter
    if (Password) {
        pCred->PasswordLength = wcslen( Password );
        pCred->Password = (LPWSTR) LocalAlloc( LPTR,
                                   ( pCred->PasswordLength + 1 ) * sizeof(WCHAR) );

        if (pCred->Password == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy( pCred->Password, Password );
    }

    // Flags
    pCred->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    *pAuthIdentity = (RPC_AUTH_IDENTITY_HANDLE) pCred;
    pCred = NULL; // Don't cleanup since we've given it to the user

    status = ERROR_SUCCESS;

cleanup:

    if (pCred != NULL) {
        // Rely on fact that this routine can clean up partial structures
        DsFreePasswordCredentials( (RPC_AUTH_IDENTITY_HANDLE) pCred );
    }

    return status;
} /* DsMakePasswordCredentialsW */


NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsA(
    LPCSTR User,
    LPCSTR Domain,
    LPCSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )

/*++

Routine Description:

    Ascii wrapper for DsMakeCredentials. Convert all parameters to Wide
    and call DsMakeCredentialsW.  See above.

Arguments:

    User -
    Domain -
    Password -
    ppAuthIdentity -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR userW = NULL, domainW = NULL, passwordW = NULL;

    status = AllocConvertWide( User, &userW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    status = AllocConvertWide( Domain, &domainW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = AllocConvertWide( Password, &passwordW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Do it!
    status = DsMakePasswordCredentialsW(
        userW, domainW, passwordW, pAuthIdentity );

cleanup:
    if (userW != NULL) {
        SecureZeroMemory(userW, wcslen(userW) * sizeof(WCHAR));
        LocalFree( userW );
    }
    if (domainW != NULL) {
        SecureZeroMemory(domainW, wcslen(domainW) * sizeof(WCHAR));
        LocalFree( domainW );
    }
    if (passwordW != NULL) {
        SecureZeroMemory(passwordW, wcslen(passwordW) * sizeof(WCHAR));
        LocalFree( passwordW );
    }

    return status;
} /* DsMakeCredentialsA */


NTDSAPI
VOID
WINAPI
DsFreePasswordCredentials(
    RPC_AUTH_IDENTITY_HANDLE pAuthIdentity
    )

/*++

Routine Description:

   Free a credential structure.
   This routine can clean up partially allocated structures.

Arguments:

    pAuthIdentity -

Return Value:

    WINAPI -

--*/

{
    PSEC_WINNT_AUTH_IDENTITY_W pCred =
        (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIdentity;

    if (pCred == NULL) {
        return;
    }

    if (pCred->User) {
        Assert(pCred->UserLength == wcslen(pCred->User));
        SecureZeroMemory(pCred->User, pCred->UserLength * sizeof(WCHAR));
        LocalFree( pCred->User );
    }
    if (pCred->Domain) {
        Assert(pCred->DomainLength == wcslen(pCred->Domain));
        SecureZeroMemory(pCred->Domain, pCred->DomainLength * sizeof(WCHAR));
        LocalFree( pCred->Domain );
    }
    if (pCred->Password) {
        Assert(pCred->PasswordLength == wcslen(pCred->Password));
        SecureZeroMemory(pCred->Password, pCred->PasswordLength * sizeof(WCHAR));
        LocalFree( pCred->Password );
    }

    LocalFree( pCred );
} /* DsFreeCredentials */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\bind-postxp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Implementation of ntdsapi.dll bind routines.

Author:

    DaveStr     24-Aug-96

Environment:

    User Mode - Win32

Revision History:

    wlees 9-Feb-98  Add support for credentials
--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <drs_w.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions
#include <stdio.h>          // for printf during debugging!
#include <dststlog.h>       // DSLOG
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#define SECURITY_WIN32 1
#include <sspi.h>
#include <winsock.h>
#include <process.h>
#include <winldap.h>
#include <winber.h>

#include "util.h"           // ntdsapi internal utility functions
#define FILENO   FILENO_NTDSAPI_BIND_POSTXP
#include "dsdebug.h"        // debug utility functions

#if DBG
#include <stdio.h>          // printf for debugging
#endif

//
// For DPRINT...
//
#define DEBSUB  "NTDSAPI_BIND:"

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithSpnExW                                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

typedef DWORD (*DSBINDWITHSPNEXW)(LPCWSTR , LPCWSTR, RPC_AUTH_IDENTITY_HANDLE, LPCWSTR, DWORD, HANDLE*);
typedef DWORD (*DSBINDWITHSPNEXA)(LPCSTR , LPCSTR, RPC_AUTH_IDENTITY_HANDLE, LPCSTR, DWORD, HANDLE*);
                  
#ifdef _NTDSAPI_POSTXP_ASLIB_
DWORD
DsBindWithSpnExW(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  LPCWSTR ServicePrincipalName,
    IN  DWORD   BindFlags,
    OUT HANDLE  *phDS
    )

/*++

Routine Description:

    This is the post Win XP stub for repadmin/dcdiag, note this isn't 
    the real DsBindWithSpnExW(), because the bind routines make use
    of knowledge of the order of all the fields in BindState structure,
    and if we propogate that knowledge here, we'll forever freeze 
    how the BindState can be treated.  So in an effort to avoid this
    we don't propogate any knoweldge past the top 3 fields of the
    bind state to the postxp library.

    For more information see the real DsBindWithSpnExW() in bind.c

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials, and possible options
    from flags.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL.

    ServicePrincipalName - SPN to use during mutual auth or NULL.
    
    BindFlags - These are the flags to signal DsBind() how it should work.
        See ntdsapi.h for valid NTDSAPI_BIND_* flags.  All bits should
        be zero that are not used.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.

Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/

{
    // See if the real ntdsapi routine exists, if so use it.
    HMODULE hNtdsapiDll = NULL;
    VOID * pvFunc = NULL;
    DWORD err;

    hNtdsapiDll = NtdsapiLoadLibraryHelper(L"ntdsapi.dll");
    if (hNtdsapiDll) {
        pvFunc = GetProcAddress(hNtdsapiDll, "DsBindWithSpnExW");
        if (pvFunc) {
            err = ((DSBINDWITHSPNEXW)pvFunc)(DomainControllerName, DnsDomainName, AuthIdentity,
                                             ServicePrincipalName, BindFlags, phDS);
            FreeLibrary(hNtdsapiDll);
            return(err);
        } 
        FreeLibrary(hNtdsapiDll);
    }
    // else fall through and try a lesser api ...

    if (0 == (BindFlags & ~NTDSAPI_BIND_ALLOW_DELEGATION)) {
        // If the only bind flag set is to disallow delegation, we'll
        // just allow it to go through w/ delegation. This will just
        // be a pecularity of the postxp library.
        return(DsBindWithSpnW(DomainControllerName,
                      DnsDomainName,
                      AuthIdentity, 
                      ServicePrincipalName,
                      phDS));
    }

    return(ERROR_NOT_SUPPORTED);
}

DWORD
DsBindWithSpnExA(
    LPCSTR  DomainControllerName,
    LPCSTR  DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPCSTR  ServicePrincipalName,
    DWORD   BindFlags,
    HANDLE  *phDS
    )
{
        // See if the real ntdsapi routine exists, if so use it.
    HMODULE hNtdsapiDll = NULL;
    VOID * pvFunc = NULL;
    DWORD err;

    hNtdsapiDll = NtdsapiLoadLibraryHelper(L"ntdsapi.dll");
    if (hNtdsapiDll) {
        pvFunc = GetProcAddress(hNtdsapiDll, "DsBindWithSpnExA");
        if (pvFunc) {
            err = ((DSBINDWITHSPNEXA)pvFunc)(DomainControllerName, DnsDomainName, AuthIdentity,
                                             ServicePrincipalName, BindFlags, phDS);
            FreeLibrary(hNtdsapiDll);
            return(err);
        } 
        FreeLibrary(hNtdsapiDll);
    }
    // else fall through and try a lesser api ...

    if (0 == (BindFlags & ~NTDSAPI_BIND_ALLOW_DELEGATION)) {
        // If the only bind flag set is to disallow delegation, we'll
        // just allow it to go through w/ delegation. This will just
        // be a pecularity of the postxp library.
        return(DsBindWithSpnA(DomainControllerName,
                      DnsDomainName,
                      AuthIdentity, 
                      ServicePrincipalName,
                      phDS));
    }

    return(ERROR_NOT_SUPPORTED);
}

#endif

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindingSetTimeout                                                  //
//                                                                      //
// DsBindingSetTimeout allows the caller to specify a timeout value     //
// which will be honored by all RPC calls using the specified binding   //
// handle. RPC calls which take longer the timeout value are canceled.  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindingSetTimeout(
    HANDLE      hDS,
    ULONG       cTimeoutSecs
    )
{
    DRS_HANDLE          hDrs;
    RPC_BINDING_HANDLE  hRpc;
    DWORD               err;
    ULONG               cTimeoutMsec;

    // Check parameters
    if( NULL==hDS ) {
        err = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    hDrs = ((BindState *) hDS)->hDrs;
    
    // Get the binding handle. This handle should not be freed.
    err = RpcSsGetContextBinding( hDrs, &hRpc );
    if( RPC_S_OK!=err ) {
        goto Cleanup;
    }

    // Convert from seconds to milliseconds, avoiding overflow
    cTimeoutMsec = 1000*cTimeoutSecs;
    if( cTimeoutSecs>0 && cTimeoutMsec<cTimeoutSecs ) {
        cTimeoutMsec = ~((ULONG) 0);          // infinity
    }
    
    err = RpcBindingSetOption( hRpc, RPC_C_OPT_CALL_TIMEOUT, cTimeoutMsec );
    if( RPC_S_OK==err ) {
        err = ERROR_SUCCESS;
    }
    
Cleanup:

    return err;
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// GetOneValueFromLDAPResults                                           //
//                                                                      //
// This is a helper function for DsBindToISTGW(). In order to locate an //
// ISTG we must make several LDAP queries which we expect to return     //
// exactly one value for exactly one attribute. This function helps to  //
// extract that single value from the LDAP results message.             //
//                                                                      //
// Notes:                                                               //
// If a failure occurs, an error code is returned and *ppwszValue will  //
// be NULL. If the returned string is not NULL, it must be freed with   //
// LocalFree.                                                           //
//                                                                      //
// The error code is a Win32 error code, not an LDAP error code.        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
DWORD
GetOneValueFromLDAPResults(
    LDAP           *ld,
    LDAPMessage    *lm,
    PWSTR          *ppwszValue
    )
{
    LDAPMessage    *le = NULL;
    PWCHAR          pwszAttrName=NULL, *rgwszValues=NULL;
    PWSTR           pwszResult=NULL;
    DWORD           dwValueLen, err=ERROR_SUCCESS;
    BerElement     *ptr;

    *ppwszValue = NULL;

    // Grab the object
    le = ldap_first_entry( ld, lm );
    if( NULL==le ) {
        err = LdapGetLastError();
        if( !err ) {
            err = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        } else {
            err = LdapMapErrorToWin32(err);
        }
        goto Cleanup;
    }

    // Grab the attribute
    pwszAttrName = ldap_first_attributeW( ld, le, &ptr );
    if( NULL==pwszAttrName ) {
        err = LdapGetLastError();
        if( !err ) {
            err = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        } else {
            err = LdapMapErrorToWin32(err);
        }
        goto Cleanup;
    }
    if( ptr ) ber_free(ptr, 0);

    // Grab the value
    rgwszValues = ldap_get_valuesW( ld, le, pwszAttrName );
    if( NULL==rgwszValues || NULL==rgwszValues[0] ) {
        err = LdapGetLastError();
        if( !err ) {
            err = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        } else {
            err = LdapMapErrorToWin32(err);
        }
        goto Cleanup;
    }
    Assert( NULL==rgwszValues[1] && "At most one value should be returned" );

    // Copy the value into a new buffer
    dwValueLen = wcslen( rgwszValues[0] );
    pwszResult = (PWSTR) LocalAlloc(LPTR, sizeof(WCHAR)*(dwValueLen + 1));
    if( NULL==pwszResult ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    wcscpy( pwszResult, rgwszValues[0] );

    // Note: Caller must free the result with LocalFree
    *ppwszValue = pwszResult;

Cleanup:
    
    // Note: le will be freed when lm is freed by the caller
    if( pwszAttrName ) ldap_memfreeW( pwszAttrName );
    if( rgwszValues ) ldap_value_freeW( rgwszValues );

    return err;
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindToISTGW                                                        //
//                                                                      //
// DsBindToISTG will attempt to find a domain controller in the domain  //
// of the local computer. It will then determine the holder of the      //
// Inter-Site Topology Generator (ISTG) role in the domain controller's //
// site. Finally it binds to the ISTG role-holder and returns a binding //
// handle.                                                              //
//                                                                      //
// The purpose of this function is to try to find a server which        //
// supports the DsQuerySitesByCost API.                                 //
//                                                                      //
// Notes:                                                               //
//                                                                      //
// SiteName may be NULL, in which case the site of the nearest machine, //
// as determined by DsGetDcName, is used.                               //
//                                                                      //
// The current credentials are used when binding to the LDAP server.    //
// There is currently no way to specify alternate credentials.          //
//                                                                      //
// The binding handle should be released with DsUnBind.                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
DWORD
DsBindToISTGW(
    IN  LPCWSTR SiteName,
    OUT HANDLE  *phDS
    )
{
    PDOMAIN_CONTROLLER_INFOW    pdcInfo=NULL;
    LDAP*                       ld=NULL;
    LDAPMessage*                lm=NULL;
    PWSTR                       pwszConfigDN=NULL, pwszSearchBase=NULL;
    PWSTR                       pwszISTGDN=NULL, pwszServerDN=NULL;
    PWSTR                       pwszISTGDNSName=NULL;
    PWCHAR                      pwszDCName=NULL;
    DWORD                       len, err;
    ULONG                       ulOptions;

    // Constants
    const WCHAR                 BACKSLASH = L'\\';
    const PWSTR                 ROOTDSE = L"";
    const PWSTR                 NO_FILTER = L"(objectClass=*)";
    const PWSTR                 SITE_SETTINGS = L"CN=NTDS Site Settings,CN=";
    const PWSTR                 SITES = L",CN=Sites,";

    PWSTR                       rgszRootAttrs[] = {
                                    L"configurationNamingContext",
                                    NULL };
    PWSTR                       rgszISTGAttrs[] = {
                                    L"interSiteTopologyGenerator",
                                    NULL };
    PWSTR                       rgszDNSAttrs[] = {
                                    L"dNSHostName",
                                    NULL };

    // Find an arbitrary DC
    // Note: We do not force rediscovery here.
    err = DsGetDcNameW( NULL, NULL, NULL, NULL,
        DS_DIRECTORY_SERVICE_REQUIRED, &pdcInfo );
    if( err ) {
        goto Cleanup;
    }
    if( NULL==pdcInfo->DomainControllerName ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    pwszDCName = pdcInfo->DomainControllerName;

    // The first characters of pwszDCName should be the unnecessary '\\'
    if( BACKSLASH!=pwszDCName[0] || BACKSLASH!=pwszDCName[1] ) {
        err = ERROR_INVALID_NETNAME;
        goto Cleanup;
    } else {
        // Remove the backslashes
        pwszDCName += 2;
    }

    // Check parameters
    if( NULL==SiteName ) {
        // If no site name was provided, use the site of the DC
        // we connected to via LDAP
        SiteName = pdcInfo->DcSiteName;
    }
    if( NULL==phDS ) {
        err = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    
    // Setup an LDAP session handle
    ld = ldap_initW( pwszDCName, LDAP_PORT );
    if( NULL==ld ) {
        err = LdapGetLastError();
        err = LdapMapErrorToWin32(err);
        goto Cleanup;
    }
    // Use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    ldap_set_optionW( ld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    // Bind to the LDAP server
    err = ldap_bind_s( ld, NULL, NULL, LDAP_AUTH_NEGOTIATE );
    if( err ) {
        err = LdapMapErrorToWin32(err);
        goto Cleanup;
    }

    // Via LDAP, search for the DN of the Configuration NC
    err = ldap_search_sW( ld, ROOTDSE, LDAP_SCOPE_BASE, NO_FILTER,
        rgszRootAttrs, FALSE, &lm );
    if( err ) {
        err = LdapMapErrorToWin32(err);
        goto Cleanup;
    }

    // Extract the DN from the search results and free them
    err = GetOneValueFromLDAPResults( ld, lm, &pwszConfigDN );
    if( ERROR_SUCCESS!=err ) {
        goto Cleanup;
    }
    ldap_msgfree( lm );
    lm = NULL;

    // Create a string containing the DN for the site's settings
    len = wcslen(SITE_SETTINGS) + wcslen(SiteName)
        + wcslen(SITES) + wcslen(pwszConfigDN) + 1;
    pwszSearchBase = LocalAlloc( LPTR, len*sizeof(WCHAR) );
    if( NULL==pwszSearchBase ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    wsprintfW( pwszSearchBase, L"%s%s%s%s", SITE_SETTINGS,
        SiteName, SITES, pwszConfigDN );

    // Via LDAP, search the site settings for the DN of the ISTG
    err = ldap_search_sW( ld, pwszSearchBase, LDAP_SCOPE_BASE,
        NO_FILTER, rgszISTGAttrs, FALSE, &lm );
    if( err ) {
        err = LdapMapErrorToWin32(err);
        goto Cleanup;
    }

    // Extract the DN from the search results and free them
    err = GetOneValueFromLDAPResults( ld, lm, &pwszISTGDN );
    if( ERROR_SUCCESS!=err ) {
        goto Cleanup;
    }
    ldap_msgfree( lm );
    lm = NULL;

    // Currently pwszISTGDN contains the DN of the ISTG's NTDS Settings
    // object. Strip off the last RDN to obtain the DN of the server object.
    pwszServerDN = wcschr( pwszISTGDN, L',' );
    if( NULL==pwszServerDN ) {
        err = ERROR_DS_BAD_NAME_SYNTAX;
    }
    pwszServerDN++;
    
    // Via LDAP, search the server object for its DNS name
    err = ldap_search_sW( ld, pwszServerDN, LDAP_SCOPE_BASE,
        NO_FILTER, rgszDNSAttrs, FALSE, &lm );
    if( err ) {
        err = LdapMapErrorToWin32(err);
        goto Cleanup;
    }

    // Extract the DNS name from the search results and free them
    err = GetOneValueFromLDAPResults( ld, lm, &pwszISTGDNSName );
    if( ERROR_SUCCESS!=err ) {
        goto Cleanup;
    }
    ldap_msgfree( lm );
    lm = NULL;
    
    err = DsBindW( pwszISTGDNSName, NULL, phDS );

Cleanup:

    if( pwszISTGDNSName ) LocalFree( pwszISTGDNSName );
    if( pwszISTGDN ) LocalFree( pwszISTGDN );
    if( pwszSearchBase ) LocalFree( pwszSearchBase );
    if( pwszConfigDN ) LocalFree( pwszConfigDN );
    if( pdcInfo ) NetApiBufferFree( pdcInfo );
    if( lm ) ldap_msgfree( lm );
    if( ld ) ldap_unbind_s( ld );

    return err;
}


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindToISTGA                                                        //
//                                                                      //
// ASCII wrapper for DsBindToISTGW.                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindToISTGA(
    IN  LPCSTR  pszSiteName,
    OUT HANDLE  *phDS
    )
{
    DWORD       dwErr = NO_ERROR;
    WCHAR       *pwszSiteName = NULL;
    int         cChar;

    __try
    {
        // Sanity check arguments.
        if( NULL==phDS ) {
            dwErr = ERROR_INVALID_PARAMETER;
            __leave;
        }
        *phDS = NULL;

        // Convert site name to Unicode
        dwErr = AllocConvertWide( pszSiteName, &pwszSiteName );
        if( ERROR_SUCCESS!=dwErr ) {
            __leave;
        }

        // Call Unicode API
        dwErr = DsBindToISTGW(
                    pwszSiteName,
                    phDS);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    // Cleanup code
    if( NULL!=pwszSiteName ) {
        LocalFree(pwszSiteName);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\addsid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    addsid.c

Abstract:

    Implementation of DsAddSidHistory.

Author:

    DaveStr     09-Mar-99

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <rpc.h>            // RPC defines
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <util.h>           // AllocConvertWide()
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR()
#include <dststlog.h>       // DSLOG

#include "dsdebug.h"        // debug utility functions

//
// For DPRINT...
//
#define DEBSUB  "NTDSAPI_ADDSID"

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryW(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in
    LPCWSTR                 SrcDomain,              // in - DNS or NetBIOS
    LPCWSTR                 SrcPrincipal,           // in - SAM account name
    LPCWSTR                 SrcDomainController,    // in, optional - NetBIOS
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domai
    LPCWSTR                 DstDomain,              // in - DNS or NetBIOS
    LPCWSTR                 DstPrincipal            // in - SAM account name
    )

/*++

Routine Description:

    Adds the SID and SID History from SrcPrincipal to the SID History
    of DstPrincipal.

    WARN: DsAddSidHistory may fail with ACCESS_DENIED if SrcDomainCreds
    are NULL and the binding, hDs, used IMPERSONATE instead of DELEGATE.
    To get this call to work, the user must enable Delegation at the
    destination DC or run this call on the DstDc while specifying
    the DstDc's NetBIOS name when binding (forces LRPC).
    
Arguments:
    hDs - From DsBindxxx
    Flags - must be 0
    SrcDomain - NT4 - NetBIOS name
                NT5 - DNS name
    SrcPrincipal - name of account principal with SIDs to copy
    SrcDomainController - OPTIONAL NT4 - NetBIOS name
                          OPTIONAL NT5 - DNS name
    SrcDomainCreds - OPTIONAL address of a SEC_WINNT_AUTH_IDENTITY_W
    DstDomain - NetBIOS or DNS name of the destination domain of DstPrincipal
    DstPrincipal - name of account principal to receive copied SIDs

Return Value:

    0 on success.  WIN32 error code.

--*/
{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DRS_MSG_ADDSIDREQ           req;
    DRS_MSG_ADDSIDREPLY         reply;
    SEC_WINNT_AUTH_IDENTITY_W   *pSec;
    WCHAR                       *pwszUser = NULL;
    WCHAR                       *pwszDomain = NULL;
    WCHAR                       *pwszPassword = NULL;
    DWORD                       cbScratch;
    CHAR                        *pszScratch = NULL;
    DWORD                       dwOutVersion = 0;
#if DBG
    DWORD                       startTime = 0;
#endif

    pSec = (SEC_WINNT_AUTH_IDENTITY_W *) SrcDomainCreds;

    if (    !hDs
         || !SrcDomain
         || !SrcPrincipal
         || (   (pSec)
             && (    !pSec->User
                  || !pSec->UserLength
                  || !pSec->Domain
                  || !pSec->DomainLength
                  || !pSec->Password
                  || (    !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
                       && !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE))))
         || !DstDomain
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    __try {

        // require strong encryption if creds are being passed
        if (SrcDomainCreds) {
            memset(&req, 0, sizeof(req));
            memset(&reply, 0, sizeof(reply));

            // Check if the connection is secure enough for addsid.
            // At this time, this means the connection is local or,
            // if remote, is using encryption keys that are at least
            // 128bits in length.
            req.V1.Flags = DS_ADDSID_FLAG_PRIVATE_CHK_SECURE;
            RpcTryExcept {
                dwErr = _IDL_DRSAddSidHistory(((BindState *) hDs)->hDrs,
                                             1, &req, &dwOutVersion, &reply);
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) ) {
		  
		  dwErr = RpcExceptionCode(); 
		  HandleClientRpcException(dwErr, &hDs);
		 
            } RpcEndExcept;

	    MAP_SECURITY_PACKAGE_ERROR(dwErr);
            
	    DPRINT1(0, "IDL_DRSAddSidHistory check secure ==> %08x\n", dwErr);

            if ( !dwErr ) {
                if ( 1 != dwOutVersion ) {
                    dwErr = RPC_S_INTERNAL_ERROR;
                } else {
                    dwErr = reply.V1.dwWin32Error;
                }
            }
            DPRINT1(0, "IDL_DRSAddSidHistory check secure reply ==> %08x\n", dwErr);

            if (dwErr) {
                __leave;
            }
        }

        memset(&req, 0, sizeof(req));
        memset(&reply, 0, sizeof(reply));

        req.V1.Flags = Flags;
        req.V1.SrcDomain = (WCHAR *) SrcDomain;
        req.V1.SrcPrincipal = (WCHAR *) SrcPrincipal;
        req.V1.SrcDomainController = (WCHAR *) SrcDomainController;
        req.V1.DstDomain = (WCHAR *) DstDomain;
        req.V1.DstPrincipal = (WCHAR *) DstPrincipal;

        // UNICODE creds; accept as is
        if ( pSec && (pSec->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) ) {
            req.V1.SrcCredsUserLength = pSec->UserLength;
            req.V1.SrcCredsUser = pSec->User;
            req.V1.SrcCredsDomainLength = pSec->DomainLength;
            req.V1.SrcCredsDomain = pSec->Domain;
            req.V1.SrcCredsPasswordLength = pSec->PasswordLength;
            req.V1.SrcCredsPassword = pSec->Password;
        }
        // ANSI creds; convert to UNICODE
        if ( pSec && (pSec->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) ) {
            // Allocate scratch buffer guaranteed to be big enough.
            cbScratch = pSec->UserLength + 1;
            cbScratch += pSec->DomainLength;
            cbScratch += pSec->PasswordLength;

            if ( NULL == (pszScratch = LocalAlloc(LPTR, cbScratch)) ) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }

            req.V1.SrcCredsUserLength = pSec->UserLength;
            memset(pszScratch, 0, cbScratch);
            memcpy(pszScratch, pSec->User, pSec->UserLength);
            if ( dwErr = AllocConvertWide(pszScratch, &pwszUser) ) {
                __leave;
            }
            req.V1.SrcCredsUser = pwszUser;

            req.V1.SrcCredsDomainLength = pSec->DomainLength;
            memset(pszScratch, 0, cbScratch);
            memcpy(pszScratch, pSec->Domain, pSec->DomainLength);
            if ( dwErr = AllocConvertWide(pszScratch, &pwszDomain) ) {
                __leave;
            }
            req.V1.SrcCredsDomain = pwszDomain;

            req.V1.SrcCredsPasswordLength = pSec->PasswordLength;
            memset(pszScratch, 0, cbScratch);
            memcpy(pszScratch, pSec->Password, pSec->PasswordLength);
            if ( dwErr = AllocConvertWide(pszScratch, &pwszPassword) ) {
                __leave;
            }
            req.V1.SrcCredsPassword = pwszPassword;
        }
        DPRINT(0, "IDL_DRSAddSidHistory:\n");
        DPRINT1(0, "    Flags                 : %08x\n", req.V1.Flags);
        DPRINT1(0, "    SrcDomain             : %ws\n", req.V1.SrcDomain);
        DPRINT1(0, "    SrcPrincipal          : %ws\n", req.V1.SrcPrincipal);
        DPRINT1(0, "    SrcDomainController   : %ws\n", req.V1.SrcDomainController);
        DPRINT1(0, "    DstDomain             : %ws\n", req.V1.DstDomain);
        DPRINT1(0, "    DstPrincipal          : %ws\n", req.V1.DstPrincipal);
        DPRINT1(0, "    SrcCredsUserLength    : %d\n", req.V1.SrcCredsUserLength);
        DPRINT1(0, "    SrcCredsUser          : %ws\n", req.V1.SrcCredsUser);
        DPRINT1(0, "    SrcCredsDomainLength  : %d\n", req.V1.SrcCredsDomainLength);
        DPRINT1(0, "    SrcCredsDomain        : %ws\n", req.V1.SrcCredsDomain);
        // Never in clear text...
        // DPRINT1(0, "    SrcCredsPasswordLength: %d\n", req.V1.SrcCredsPasswordLength);
        // DPRINT1(0, "    SrcCredsPassword      : %ws\n", req.V1.SrcCredsPassword);

        RpcTryExcept {
            dwErr = _IDL_DRSAddSidHistory(((BindState *) hDs)->hDrs,
                                         1, &req, &dwOutVersion, &reply);
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) ) {
	      
	      dwErr = RpcExceptionCode(); 
	      HandleClientRpcException(dwErr, &hDs);

        } RpcEndExcept;

	MAP_SECURITY_PACKAGE_ERROR(dwErr);

        DPRINT2(0, "IDL_DRSAddSidHistory ==> %08x, %d\n", 
                dwErr, 
                dwOutVersion);

        if ( !dwErr ) {
            if ( 1 != dwOutVersion ) {
                dwErr = RPC_S_INTERNAL_ERROR;
            } else {
                dwErr = reply.V1.dwWin32Error;
            }
        }
        DPRINT1(0, "IDL_DRSAddSidHistory reply ==> %08x\n", dwErr);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsAddSidHistory]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=%ws][PA=%ws][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           SrcDomain, SrcPrincipal, 
           SrcDomainController ? SrcDomainController : L"NULL",
           DstDomain, DstPrincipal,
           startTime, GetTickCount(), dwErr))

    if ( pwszUser )     LocalFree(pwszUser);
    if ( pwszDomain )   LocalFree(pwszDomain);
    if ( pwszPassword ) LocalFree(pwszPassword);
    if ( pszScratch)    LocalFree(pszScratch);

    return(dwErr);
}

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryA(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in
    LPCSTR                  SrcDomain,              // in - DNS or NetBIOS
    LPCSTR                  SrcPrincipal,           // in - SAM account name
    LPCSTR                  SrcDomainController,    // in, optional - NetBIOS
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domai
    LPCSTR                  DstDomain,              // in - DNS or NetBIOS
    LPCSTR                  DstPrincipal            // in - SAM account name
    )

/*++

Routine Description:

    See DsAddSidHistoryW

--*/

{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    WCHAR                       *SrcDomainW = NULL;
    WCHAR                       *SrcPrincipalW = NULL;
    WCHAR                       *SrcDomainControllerW = NULL;
    WCHAR                       *DstDomainW = NULL;
    WCHAR                       *DstPrincipalW = NULL;
    SEC_WINNT_AUTH_IDENTITY_W   *pSec;
    
    pSec = (SEC_WINNT_AUTH_IDENTITY_W *) SrcDomainCreds;

    if (    !hDs
         || !SrcDomain
         || !SrcPrincipal
         || (   (pSec)
             && (    !pSec->User
                  || !pSec->UserLength
                  || !pSec->Domain
                  || !pSec->DomainLength
                  || !pSec->Password
                  || (    !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
                       && !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE))))
         || !DstDomain
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    if (    !(dwErr = AllocConvertWide(SrcDomain, 
                                      &SrcDomainW))
         && !(dwErr = AllocConvertWide(SrcPrincipal, 
                                      &SrcPrincipalW))
         && (    !SrcDomainController
              || !(dwErr = AllocConvertWide(SrcDomainController, 
                                            &SrcDomainControllerW)))
         && !(dwErr = AllocConvertWide(DstDomain, 
                                      &DstDomainW))
         && !(dwErr = AllocConvertWide(DstPrincipal, 
                                      &DstPrincipalW)) ) {
        dwErr = DsAddSidHistoryW(hDs, Flags, SrcDomainW, SrcPrincipalW,
                                 SrcDomainControllerW, SrcDomainCreds, 
                                 DstDomainW, DstPrincipalW);
    }

    if ( SrcDomainW )           LocalFree(SrcDomainW);
    if ( SrcPrincipalW )        LocalFree(SrcPrincipalW);
    if ( SrcDomainControllerW ) LocalFree(SrcDomainControllerW);
    if ( DstDomainW )           LocalFree(DstDomainW);
    if ( DstPrincipalW )        LocalFree(DstPrincipalW);

    return(dwErr);
}

NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityW(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCWSTR                 SrcPrincipal,           // in - distinguished name
    LPCWSTR                 DstPrincipal            // in - distinguished name
    )
{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DRS_MSG_ADDSIDREQ           req;
    DRS_MSG_ADDSIDREPLY         reply;
    DWORD                       dwOutVersion = 0;
#if DBG
    DWORD                       startTime = 0;
#endif

    if (    !hDs
         || !SrcPrincipal
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    __try {

        memset(&req, 0, sizeof(req));
        memset(&reply, 0, sizeof(reply));

        req.V1.Flags = (Flags | DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ);
        req.V1.SrcDomain = NULL;
        req.V1.SrcPrincipal = (WCHAR *) SrcPrincipal;
        req.V1.SrcDomainController = NULL;
        req.V1.DstDomain = NULL;
        req.V1.DstPrincipal = (WCHAR *) DstPrincipal;
        req.V1.SrcCredsUserLength = 0;
        req.V1.SrcCredsUser = NULL;
        req.V1.SrcCredsDomainLength = 0;
        req.V1.SrcCredsDomain = NULL;
        req.V1.SrcCredsPasswordLength = 0;
        req.V1.SrcCredsPassword = NULL;

        RpcTryExcept {
            dwErr = _IDL_DRSAddSidHistory(((BindState *) hDs)->hDrs,
                                         1, &req, &dwOutVersion, &reply);
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) ) {
            
	      dwErr = RpcExceptionCode(); 
	      HandleClientRpcException(dwErr, &hDs);

        } RpcEndExcept;

	MAP_SECURITY_PACKAGE_ERROR(dwErr);

        if ( !dwErr ) {
            if ( 1 != dwOutVersion ) {
                dwErr = RPC_S_INTERNAL_ERROR;
            } else {
                dwErr = reply.V1.dwWin32Error;
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsInheritSecurityIdentity]"));
    DSLOG((0,"[PA=%ws][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           SrcPrincipal, DstPrincipal,
           startTime, GetTickCount(), dwErr))

    return(dwErr);
}

NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityA(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCSTR                  SrcPrincipal,           // in - distinguished name
    LPCSTR                  DstPrincipal            // in - distinguished name
    )
{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    WCHAR                       *SrcPrincipalW = NULL;
    WCHAR                       *DstPrincipalW = NULL;
    
    if (    !hDs
         || !SrcPrincipal
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    if (    !(dwErr = AllocConvertWide(SrcPrincipal, 
                                      &SrcPrincipalW))
         && !(dwErr = AllocConvertWide(DstPrincipal, 
                                      &DstPrincipalW)) ) {
        dwErr = DsInheritSecurityIdentityW(hDs, Flags, 
                                           SrcPrincipalW, DstPrincipalW);
    }

    if ( SrcPrincipalW )        LocalFree(SrcPrincipalW);
    if ( DstPrincipalW )        LocalFree(DstPrincipalW);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\dsdebug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dsdebug.c

Abstract:

    Implementation of DsMakeQuotedRdn/DsMakeUnquotedRdn API and
    helper functions.

Author:

    Billy Fuller (billyf) 14-May-1999

Environment:

    User Mode - Win32

Notes:
    The debug layer is limited to CHK builds.

Revision History:

--*/

#define _NTDSAPI_       // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>        // RPC defines
#include <stdio.h>      // for printf
#include <stdlib.h>     // atol
#include <dststlog.h>   // DSLOG

#include "dsdebug.h"

#define DEBSUB  "NTDSAPI_DSDEBUG"

//
// CHK BUILDS ONLY!
//
#if DBG

//
// Flags controls user settable options such as debug output.
// The user can set the flags word with an environment variable
// (set _NTDSAPI_FLAGS=0x1) or with ntsd (ed dwNtDsApiFlags 0x1).
//
DWORD   gdwNtDsApiFlags;

//
// Level controls user settable output level.
// The user can set the level word with an environment variable
// (set _NTDSAPI_LEVEL=0x1) or with ntsd (ed dwNtDsApiLevel 0x1).
//
DWORD   gdwNtDsApiLevel;

//
// For various debug ops such as printing a line
//
CRITICAL_SECTION    DsDebugLock;

//
// ProcessId (for spew)
//
DWORD   DsDebugProcessId;

//
// Line for spew (spew is single threaded)
//
CHAR    DsDebugLine[512];

//
// Optional log file for spew (environment variable _NTDSAPI_LOG);
//
CHAR    DsDebugLog[MAX_PATH];
HANDLE  DsDebugHandle = INVALID_HANDLE_VALUE;

BOOL
DsDebugFormatLine(
    IN PCHAR    DebSub,
    IN UINT     LineNo,
    IN PCHAR    Line,
    IN ULONG    LineSize,
    IN PUCHAR   Format,
    IN va_list  argptr
    )
/*++
Routine Description:
    Format the line of debug output.

Arguments:
    Not documented.

Return Value:
    None.
--*/
{
    ULONG       LineUsed;
    SYSTEMTIME  SystemTime;
    BOOL        Ret = TRUE;

    //
    // Increment the line count here to prevent counting
    // the several DPRINTs that don't have a newline.
    //
    GetLocalTime(&SystemTime);
    if (_snprintf(Line, LineSize, "<%-15s %04x.%04x: %5u: %02d:%02d:%02d> ",
              (DebSub) ? DebSub : "NoName",
              DsDebugProcessId,
              GetCurrentThreadId(),
              LineNo,
              SystemTime.wHour,
              SystemTime.wMinute,
              SystemTime.wSecond) < 0) {
        Ret = FALSE;
    } else {
        LineUsed = strlen(Line);
        if (((LineUsed + 1) >= LineSize) ||
            (_vsnprintf(Line + LineUsed,
                       LineSize - LineUsed,
                       Format,
                       argptr) < 0)) {
            Ret = FALSE;
        }
    }
    return Ret;
}

VOID
DsDebugPrint(
    IN DWORD   Level,
    IN PUCHAR  Format,
    IN PCHAR   DebSub,
    IN UINT    LineNo,
    IN ...
    )
/*++
Routine Description:
    Format and print a line of output.

Arguments:
    Format  - printf format
    DebSub  - module name
    LineNo  - file's line number

Return Value:
    None.
--*/
{
    DWORD           BytesWritten;
    va_list         arglist;

    //
    // Not important enough, ignore;
    //
    if (Level > gdwNtDsApiLevel) {
        return;
    }

    //
    // No output requested; ignore
    //
    if ((gdwNtDsApiFlags & NTDSAPI_FLAGS_ANY_OUT) == 0) {
        return;
    }

    //
    // Print the line
    //
    va_start(arglist, LineNo);
    __try {
        __try {
            EnterCriticalSection(&DsDebugLock);
            if (DsDebugFormatLine(DebSub,
                                  LineNo,
                                  DsDebugLine,
                                  sizeof(DsDebugLine),
                                  Format,
                                  arglist)) {
                //
                // Print a line
                //
                if (gdwNtDsApiFlags & NTDSAPI_FLAGS_PRINT) {
                    printf("%s", DsDebugLine);
                }

#ifndef WIN95
                //
                // Spew a line
                //
                if (gdwNtDsApiFlags & NTDSAPI_FLAGS_SPEW) {
                    DbgPrint(DsDebugLine);
                }
#endif !WIN95

                //
                // Log a line
                //
                if (gdwNtDsApiFlags & NTDSAPI_FLAGS_LOG) {
                    if (DsDebugLog[0] != '\0' &&
                        DsDebugHandle == INVALID_HANDLE_VALUE) {
                        //
                        // Try to open the file once.
                        //
                        DsDebugHandle = CreateFileA(DsDebugLog,
                                                    GENERIC_WRITE|GENERIC_WRITE,
                                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                    NULL,
                                                    OPEN_ALWAYS,
                                                    FILE_ATTRIBUTE_NORMAL,
                                                    NULL);
                        //
                        // DON'T RETRY!
                        //
                        if (DsDebugHandle == INVALID_HANDLE_VALUE) {
                            DsDebugLog[0] = '\0';
                        }
                    }
                    if (DsDebugHandle != INVALID_HANDLE_VALUE) {
                        //
                        // Weak attempt at multi-process access
                        //
                        SetFilePointer(DsDebugHandle,
                                       0,
                                       NULL,
                                       FILE_END);
                        //
                        // Not much we can do if this doesn't work
                        //
                        if (!WriteFile(DsDebugHandle,
                                       DsDebugLine,
                                       strlen(DsDebugLine),
                                       &BytesWritten,
                                       NULL)) {
                            //
                            // DON'T RETRY!
                            //
                            CloseHandle(DsDebugHandle);
                            DsDebugHandle = INVALID_HANDLE_VALUE;
                            DsDebugLog[0] = '\0';
                        }
                    }
                }
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            // trap AVs so the caller is not affected
        }
    } __finally {
        LeaveCriticalSection(&DsDebugLock);
    }
    va_end(arglist);
}

VOID
InitDsDebug(
     VOID
     )
/*++

 Routine Description:

   Initialize the DsDebug subsystem at ntdsapi.dll load.

 Arguments:

   None.

 Return Value:

    None.
--*/
{
    DWORD   nChars;

    //
    // For various debug ops such as printing a line
    //
    InitializeCriticalSection(&DsDebugLock);

    //
    // For messages
    //
    DsDebugProcessId = GetCurrentProcessId();

    //
    // No Log file
    //
    DsDebugLog[0] = '\0';

    //
    // read environment variables
    //
    __try {
        //
        // User settable flags (or with ntsd.exe command -- ed gdwNtDsApiLevel 0x1)
        //
        nChars = GetEnvironmentVariableA("_NTDSAPI_LEVEL",
                                         DsDebugLine,
                                         sizeof(DsDebugLine));
        if (nChars && nChars < sizeof(DsDebugLine)) {
            gdwNtDsApiLevel = strtoul(DsDebugLine, NULL, 0);
        }

        //
        // User settable flags (or with ntsd.exe command -- ed gdwNtDsApiFlags 0x1)
        //
        nChars = GetEnvironmentVariableA("_NTDSAPI_FLAGS",
                                         DsDebugLine,
                                         sizeof(DsDebugLine));
        if (nChars && nChars < sizeof(DsDebugLine)) {
            gdwNtDsApiFlags = strtoul(DsDebugLine, NULL, 0);
        }

        //
        // User settable log file (cannot be set with ntsd.exe!)
        //
        nChars = GetEnvironmentVariableA("_NTDSAPI_LOG",
                                         DsDebugLine,
                                         sizeof(DsDebugLine));
        if (nChars != 0 && nChars < sizeof(DsDebugLine)) {
            nChars = ExpandEnvironmentStringsA(DsDebugLine,
                                               DsDebugLog,
                                               sizeof(DsDebugLog));
            if (nChars == 0 || nChars > sizeof(DsDebugLog)) {
                DsDebugLog[0] = '\0';
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    DPRINT1(0, "gdwNtDsApiLevel ==> %08x\n", gdwNtDsApiLevel);
    DPRINT1(0, "gdwNtDsApiFlags ==> %08x\n", gdwNtDsApiFlags);
    DPRINT1(0, "DsDebugLog ==> %s\n", DsDebugLog);
}

VOID
TerminateDsDebug(
     VOID
     )
/*++

 Routine Description:

   Uninitialize the DsDebug subsystem at ntdsapi.dll unload.

 Arguments:

   None.

 Return Value:

    None.
--*/
{
    DeleteCriticalSection(&DsDebugLock);
    if (DsDebugHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(DsDebugHandle);
    }
}

VOID
DsDebugPrintRpcExtendedError(
    IN DWORD    dwErr
    )
/*++
Routine Description:
    Dump the rpc extended error info.

Arguments:
    dwErr - from rpc call

Return Value:
    None.
--*/
{
    LONG    i;
    BOOL    Result;
    RPC_ERROR_ENUM_HANDLE   EnumHandle;
    RPC_EXTENDED_ERROR_INFO ErrorInfo;
    ULONG MAX_COMPONENTS = 8;
    PCHAR aComponents[9] = {
	"Unknown",              // 0
	"Application",          // 1
	"RPC Runtime",          // 2
	"Security Provider",    // 3
	"NPFS",                 // 4
	"RDR",                  // 5
	"NMP",                  // 6
	"IO",                   // 7
	"Winsock",              // 8
    };

    // No error
    if (RPC_S_OK == dwErr) {
        return;
    }

    //
    // No output requested; ignore
    //
    if ((gdwNtDsApiFlags & NTDSAPI_FLAGS_ANY_OUT) == 0) {
        return;
    }

    DPRINT1(0, "RPC_EXTENDED: Original status: 0x%x\n", dwErr);

    // Start enumeration
    dwErr = RpcErrorStartEnumeration(&EnumHandle);
    if (RPC_S_OK != dwErr) {
        // No extended error
        if (dwErr == RPC_S_ENTRY_NOT_FOUND) {
            return;
        }
        // error getting extended error
        DPRINT1(0, "RpcErrorStartEnumeration() ==> 0x%x\n", dwErr);
        return;
    }

    while (RPC_S_OK == dwErr) {
        // Get next record
        memset(&ErrorInfo, 0, sizeof(ErrorInfo));
        ErrorInfo.Version = RPC_EEINFO_VERSION;
        ErrorInfo.NumberOfParameters = MaxNumberOfEEInfoParams;
        dwErr = RpcErrorGetNextRecord(&EnumHandle, FALSE, &ErrorInfo);
        if (RPC_S_OK != dwErr) {
            if (dwErr != RPC_S_ENTRY_NOT_FOUND) {
                // error getting next extended error
                DPRINT1(0, "RpcErrorGetNextRecord() ==> 0x%x\n", dwErr);
            }
            break;
        }

        // Dump it with findstr tag RPC EXTENDED
        DPRINT1(0, "RPC_EXTENDED: Box      : %ws\n", ErrorInfo.ComputerName);
        DPRINT1(0, "RPC_EXTENDED: ProcessId: %d\n", ErrorInfo.ProcessID);
        DPRINT2(0, "RPC_EXTENDED: Component: %d (%s)\n", 
                ErrorInfo.GeneratingComponent,
                (ErrorInfo.GeneratingComponent <= MAX_COMPONENTS)
                    ? aComponents[ErrorInfo.GeneratingComponent]
                    : "Unknown");
        DPRINT1(0, "RPC_EXTENDED: Status   : %d\n", ErrorInfo.Status);
        DPRINT1(0, "RPC_EXTENDED: Location : %d\n", (int)ErrorInfo.DetectionLocation);
	DPRINT1(0, "RPC_EXTENDED: Flags    : 0x%x\n", ErrorInfo.Flags);

        DPRINT7(0, "RPC_EXTENDED: System Time is: %d/%d/%d %d:%d:%d:%d\n", 
                    ErrorInfo.u.SystemTime.wMonth,
                    ErrorInfo.u.SystemTime.wDay,
                    ErrorInfo.u.SystemTime.wYear,
                    ErrorInfo.u.SystemTime.wHour,
                    ErrorInfo.u.SystemTime.wMinute,
                    ErrorInfo.u.SystemTime.wSecond,
                    ErrorInfo.u.SystemTime.wMilliseconds);

        DPRINT1(0, "RPC_EXTENDED: nParams  : %d\n", ErrorInfo.NumberOfParameters);
        for (i = 0; i < ErrorInfo.NumberOfParameters; ++i) {
            switch(ErrorInfo.Parameters[i].ParameterType) {
            case eeptAnsiString:
                DPRINT1(0, "RPC_EXTENDED: Ansi string   : %s\n", 
                    ErrorInfo.Parameters[i].u.AnsiString);
                break;

            case eeptUnicodeString:
                DPRINT1(0, "RPC_EXTENDED: Unicode string: %ws\n", 
                    ErrorInfo.Parameters[i].u.UnicodeString);
                break;

            case eeptLongVal:
                DPRINT2(0, "RPC_EXTENDED: Long val      : 0x%x (%d)\n", 
                    ErrorInfo.Parameters[i].u.LVal,
                    ErrorInfo.Parameters[i].u.LVal);
                break;

            case eeptShortVal:
                DPRINT2(0, "RPC_EXTENDED: Short val     : 0x%x (%d)\n", 
                    (int)ErrorInfo.Parameters[i].u.SVal,
                    (int)ErrorInfo.Parameters[i].u.SVal);
                break;

            case eeptPointerVal:
                DPRINT1(0, "RPC_EXTENDED: Pointer val   : 0x%x\n", 
                    (ULONG)ErrorInfo.Parameters[i].u.PVal);
                break;

            case eeptNone:
                DPRINT(0, "RPC_EXTENDED: Truncated\n");
                break;

            default:
                DPRINT2(0, "RPC_EXTENDED: Invalid type  : 0x%x (%d)\n", 
                    ErrorInfo.Parameters[i].ParameterType,
                    ErrorInfo.Parameters[i].ParameterType);
            }
        }
    }
    RpcErrorEndEnumeration(&EnumHandle);
}
//
// CHK BUILDS ONLY!
//
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\ntdsmidl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       allocc.c
//
//--------------------------------------------------------------------------

/*
File: allocc.c

Description:
    
    Routines to handle allocation and deallocation for the client
    side RPC.
    
    Note: the RPC system allows the different MIDL_user_allocate()
    routines on the client and server sides. The DSA uses a
    special implementation of these routines. The client
    side is a simple malloc/free combination. The server side
    uses the THAlloc*() routines.
*/

#pragma warning( disable:4114)  // "same type qualifier used more than once"
#include <NTDSpch.h>
#pragma hdrstop
#pragma warning( default:4114)

#include <memory.h>

#include "dsaalloc.h"

#ifdef DEBUG
/* gAllocated keeps track of the number of times that
the MIDL allocater is called. It is intended to help spot memory leaks.
*/

volatile int gAllocated = 0;
#endif

/*
MIDL_user_allocate

On the server stub side, called by the stub to allocate space for [in]
parameters. Upon return from the called proceedure, the stub will
call MIDL_user_free to deallocate this memory.

The server stub also presumes that this routine is called to allocate
memory for [out] parameters. Upon return from the called proceedure, the
stub will call MIDL_user_free to deallocate [out] parameters.
*/

void* __RPC_USER MIDL_user_allocate( size_t bytes )
{
    void*   ret;
    
    /* Keep track of the number of times the
    allocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated++;
#endif

    ret = malloc( (size_t) bytes );
    if ( ret == NULL ) {
        return( ret );
    } else {
        /* Zero out the memory */
        memset( ret, 0, (size_t) bytes );
    }
    
    /* Normal return */
    
    return( ret );
}


void __RPC_USER MIDL_user_free( void* memory )
{
    /* Keep track of the number of times the
    deallocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated--;
#endif
    free( memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\dsrsa.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dsrsa.c

ABSTRACT:

    Syncs a specified server with all others in its site, using transitive replication
    as necessary.

DETAILS:

CREATED:

    06/30/98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    12/11/98    Will Lees (wlees)
      1. Allow to work for synchronous (RPC-based) intersite connections
      2. Implement a "push mode" to force a change out to all servers

Suggestions for future enhancements:
o Add support for mail-based replicas. Perhaps these could be allowed as "leaf nodes" at the last,
  most distant phase of replication?
o Abstract the list handling into a class.  Right now some of the list handling is embedded in
  the body of the code.  Not the mention the fact that the lists are unusual: the list always has
  an allocated but uninitialized element hanging at the end.
o Abstract the binary tree routines into a class.

QUESTIONS
o Can threads get stuck if an exception is thrown?
o NameMatched doesn't impose an ordering on DNs; could this lead to problems?

--*/

#define _NTDSAPI_

#if !WIN95 && !WINNT4
    #include <process.h>
    #include <nt.h>
    #include <ntrtl.h>
    #include <ntdspch.h>
    #include <winerror.h>
    #include <ntdsa.h>
    #include <winldap.h>
    #include <w32topl.h>
    #include <drs.h>
    #include <bind.h>
    #include "util.h"
    #include "minmax.h"

// Debugging stuff.  Note order is important, just want the Assert() from debug.h, but not the DPRINTs, because
//   we have our own DPRINTs in dsrsa.h
    #include <debug.h>
    #define DEBSUB     "DSRSA:"           // define the subsystem for debugging
    #undef DPRINT
    #undef DPRINT1
    #undef DPRINT2
    #include "dsrsa.h"

    #include <fileno.h>
    #define FILENO  FILENO_NTDSAPI_DSRSA

    #if DBG
DWORD gdwDsRSADbgLevel = 0;
    #endif

// 38 = (32 GUID numerals + 4 hyhens + 1 dot + 6 chars + 1 dot + 1 null terminator)
    #define ADDITIONAL_BYTES_FOR_GUID_DNS	45

    #define DsRSAChkErr(x) { DWORD _dwWin32Err = (x); if (NO_ERROR != _dwWin32Err) DsRSAException (_dwWin32Err); }

    #define DsRSAChkLdap(x) { DWORD _dwLDAPErr = (x); if (NO_ERROR != _dwLDAPErr) DsRSAException (LdapMapErrorToWin32 (_dwLDAPErr)); }

    #define DsRSAFree(heap,lpMem) HeapFree (heap, 0L, lpMem)

    #define DsRSAHeapCreate(pHeap) \
	((*(pHeap) = HeapCreate (0L, 0L, 0L)) == NULL ? GetLastError () : NO_ERROR)

    #define DsRSAHeapDestroy(heap) \
	(HeapDestroy (heap) == FALSE ? GetLastError () : NO_ERROR)

    #define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

    #define SITES_PREFIX L"CN=Sites,"
    #define IP_PREFIX L"CN=IP,"
    #define IP_PREFIX_LEN  (ARRAY_SIZE(IP_PREFIX) - 1)
    #define DEFAULT_PAGED_SEARCH_PAGE_SIZE          (1000)

// All exceptions generated by DsReplicaSyncAll will have exception code DS_RSAI_EXCEPTION.
// The win32 error responsible for the exception is stored as the first argument.

VOID
DsRSAException (
    DWORD           dwWin32Err
    ) {
    UINT_PTR err = dwWin32Err;

    RaiseException (DS_RSAI_EXCEPTION,
        EXCEPTION_NONCONTINUABLE,
        1,
        &err);
}

// This is just a wrapper that allocates memory from a private heap.

LPVOID
DsRSAAlloc (
    HANDLE          heap,
    DWORD           dwBytes
    ) {
    LPVOID          pMem;

    if( (pMem = HeapAlloc (heap, 0L, dwBytes)) == NULL )
        DsRSAException (GetLastError ());

    return pMem;
}

// Inserts an element into a list and returns a pointer to the next (empty)
// location in the list.
// Note that the style of list used in this module is for the last element to be allocated
// but not initialized.

PDS_RSAI_LIST
DsRSAListInsert (
    HANDLE          heap,
    PDS_RSAI_LIST   pList,
    ULONG_PTR       ulpData
    ) {
    pList->ulpItem = ulpData;
    pList->next = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
    pList->next->next = NULL;
    return(pList->next);
}

// Destroys a list.
// Note that the pItem in each element is NOT deallocated. Caller must dispose.

VOID
DsRSAListDestroy (
    HANDLE          heap,
    PDS_RSAI_LIST       pList
    ) {

    PDS_RSAI_LIST       plistTemp;

    while( pList != NULL ) {
        plistTemp = pList->next;
        DsRSAFree (heap, pList);
        pList = plistTemp;
    }
}

// Converts a unicode string to an ANSI string, allocating a buffer of
// appropriate size.

LPSTR
DsRSAAllocToANSI (
    HANDLE          heap,
    LPWSTR          pszW
    ) {

    LPSTR           pszA;
    ULONG           ulBufSize;

    if( pszW == NULL ) {
        pszA = NULL;
    }
    else {
        ulBufSize = (wcslen (pszW) + 1) * sizeof (CHAR);
        pszA = (LPSTR) DsRSAAlloc (heap, ulBufSize);
        WideCharToMultiByte (
            CP_ACP,
            0L,
            pszW,
            -1,
            pszA,
            ulBufSize,
            NULL,
            NULL);
    }
    return(pszA);
}

// Perform unicode -> ANSI conversion for callback updates.

BOOL
DsRSAIssueANSIUpdate (
    HANDLE          heap,
    BOOL (__stdcall *       pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_UPDATEW  pUpdateW
    ) {

    DS_REPSYNCALL_ERRINFOA  errorA;
    DS_REPSYNCALL_SYNCA     syncA;
    DS_REPSYNCALL_UPDATEA   updateA;
    BOOL            bReturn;

    if( pUpdateW->pSync == NULL ) {
        updateA.pSync = NULL;
    }
    else {
        syncA.pszSrcId = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszSrcId);
        syncA.pszDstId = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszDstId);
        syncA.pszNC = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszNC);
        syncA.pguidSrc = pUpdateW->pSync->pguidSrc;
        syncA.pguidDst = pUpdateW->pSync->pguidDst;
        updateA.pSync = &syncA;
    }
    if( pUpdateW->pErrInfo == NULL ) {
        updateA.pErrInfo = NULL;
    }
    else {
        errorA.pszSvrId = DsRSAAllocToANSI (heap, pUpdateW->pErrInfo->pszSvrId);
        errorA.error = pUpdateW->pErrInfo->error;
        errorA.dwWin32Err = pUpdateW->pErrInfo->dwWin32Err;
        errorA.pszSrcId = DsRSAAllocToANSI (heap, pUpdateW->pErrInfo->pszSrcId);
        updateA.pErrInfo = &errorA;
    }
    updateA.event = pUpdateW->event;

    bReturn = pFnCallBackA (pCallbackData, &updateA);

    if( updateA.pSync ) {
        if( syncA.pszSrcId ) DsRSAFree (heap, syncA.pszSrcId);
        if( syncA.pszDstId ) DsRSAFree (heap, syncA.pszDstId);
        if( syncA.pszNC ) DsRSAFree (heap, syncA.pszNC);
    }
    if( updateA.pErrInfo ) {
        if( errorA.pszSvrId ) DsRSAFree (heap, errorA.pszSvrId);
        if( errorA.pszSrcId ) DsRSAFree (heap, errorA.pszSrcId);
    }

    return bReturn;
}

// Send out an update using the callback function in pMainInfo.

VOID
DsRSAIssueUpdate (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    DS_REPSYNCALL_EVENT     event,
    PDS_REPSYNCALL_ERRINFOW pErrInfo,
    PDS_REPSYNCALL_SYNCW    pSync
    ) {

    DS_REPSYNCALL_UPDATEW   update;
    BOOL            bContinueExecution;

    update.event = event;
    update.pErrInfo = pErrInfo;
    update.pSync = pSync;
    bContinueExecution = TRUE;
    if( pMainInfo->pFnCallBackA ) {
        bContinueExecution = DsRSAIssueANSIUpdate (heap, pMainInfo->pFnCallBackA, pMainInfo->pCallbackData, &update);
    }
    if( pMainInfo->pFnCallBackW ) {
        bContinueExecution = pMainInfo->pFnCallBackW (pMainInfo->pCallbackData, &update);
    }
    if( !bContinueExecution ) {
        DsRSAException (ERROR_CANCELLED);               // Zap!
    }
}

// A wrapper that simplifies issuing updates of syncs.

VOID
DsRSAIssueUpdateSync (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    DS_REPSYNCALL_EVENT     event,
    PDS_RSAI_SVRINFO            pSrcSvrInfo,
    PDS_RSAI_SVRINFO            pDstSvrInfo
    ) {

    DS_REPSYNCALL_SYNCW     sync;

    sync.pszSrcId = pSrcSvrInfo->pszMsgId;
    sync.pszDstId = pDstSvrInfo->pszMsgId;
    sync.pszNC = pMainInfo->pdsnameNameContext->StringName;
    sync.pguidSrc = &(pSrcSvrInfo->guid);
    sync.pguidDst = &(pDstSvrInfo->guid);

    DsRSAIssueUpdate (heap, pMainInfo, event, NULL, &sync);
}

// When a nonfatal error occurs, this routine reports it to the callback function
// and inserts it to the error list maintained in pMainInfo.

VOID
DsRSADoError (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    LPWSTR          pszSvrId,
    DS_REPSYNCALL_ERROR     error,
    DWORD           dwWin32Err,
    LPWSTR          pszSrcId
    ) {

    PDS_REPSYNCALL_ERRINFOW pErrInfo;

    pErrInfo = DsRSAAlloc (heap, sizeof (DS_REPSYNCALL_ERRINFOW));
    pErrInfo->pszSvrId = pszSvrId;
    pErrInfo->error = error;
    pErrInfo->dwWin32Err = dwWin32Err;
    pErrInfo->pszSrcId = pszSrcId;
    DsRSAIssueUpdate (heap, pMainInfo, DS_REPSYNCALL_EVENT_ERROR, pErrInfo, NULL);
    pMainInfo->plistNextError = DsRSAListInsert (heap, pMainInfo->plistNextError, (ULONG_PTR) pErrInfo);
}

// Destroys a list of errors.

VOID
DsRSAErrListDestroy (
    HANDLE          heap,
    PDS_RSAI_LIST       plistFirstError
    ) {

    PDS_RSAI_LIST       plistNextError;

    for( plistNextError = plistFirstError;
         plistNextError->next != NULL;
         plistNextError = plistNextError->next ) {
        DsRSAFree (heap, (LPVOID) plistNextError->ulpItem);
    }
    DsRSAListDestroy (heap, plistFirstError);
}

PDSNAME
DsRSAAllocBuildDsname (
    HANDLE          heap,
    LPCWSTR                      pszDn
    ) {

    PDSNAME         pdsnameLocal;
    PDSNAME         pdsnameHeap;

    pdsnameLocal = pdsnameHeap = NULL;

    __try {

        DsRSAChkErr (AllocBuildDsname (pszDn, &pdsnameLocal));

        // Note that if pszDN is NULL, AllocBuildDsname succeeds and sets
        // pdsnameLocal to NULL, in which case pdsnameHeap remains NULL.

        if (NULL != pdsnameLocal) {
            pdsnameHeap = DsRSAAlloc (heap, pdsnameLocal->structLen);
            memcpy (pdsnameHeap, pdsnameLocal, pdsnameLocal->structLen);
        }
    } __finally {

        if( pdsnameLocal != NULL ) LocalFree (pdsnameLocal);

    }

    return pdsnameHeap;
}

// Compares two DNs.  Returns 0 if they are the same, < 0 if Dn1 < Dn2, and > 0 if Dn1 > Dn2.

INT
DsRSADnCmp (
    PDSNAME         pDsname1,
    PDSNAME         pDsname2
    ) {

    INT             iCmp;

    // if (NameMatched (pDsname1, pDsname2)) iCmp = 0;
    // else

    iCmp = _wcsicmp (pDsname1->StringName, pDsname2->StringName);

    return iCmp;
}

// DS_RSAI_SVMAP is a mapping between servers and vertices, stored as a binary
// search tree.  This routine updates the root node of a tree.

VOID
DsRSASvMapUpdate (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    if( pSvMap != NULL ) {
        pSvMap->vertex = vertex;
        if( pSvMap->pDsname != NULL ) {
            DsRSAFree (heap, pSvMap->pDsname);
        }
        if( pDsname == NULL ) {
            pSvMap->pDsname = NULL;
        }
        else {
            pSvMap->pDsname = pDsname;
        }
    }
}

// Creates a new tree, assigning the specified attributes to the root node.

PDS_RSAI_SVMAP
DsRSASvMapCreate (
    HANDLE          heap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    PDS_RSAI_SVMAP      pSvMap;

    pSvMap = (PDS_RSAI_SVMAP) DsRSAAlloc (heap, sizeof (DS_RSAI_SVMAP));
    pSvMap->left = NULL;
    pSvMap->right = NULL;
    pSvMap->pDsname = NULL;
    DsRSASvMapUpdate (heap, pSvMap, pDsname, vertex);

    return pSvMap;
}

// Inserts a server-vertex pair into an SvMap tree.

PDS_RSAI_SVMAP
DsRSASvMapInsert (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    PDS_RSAI_SVMAP      psvmapTemp = pSvMap;
    INT             iCmp;

    if( pSvMap == NULL ) {
        pSvMap = DsRSASvMapCreate (heap, pDsname, vertex);
    }

    else {
        while( psvmapTemp != NULL ) {
            iCmp = DsRSADnCmp (pDsname, psvmapTemp->pDsname);
            if( iCmp == 0 ) {
                DsRSASvMapUpdate (heap, pSvMap, pDsname, vertex);
                break;
            }
            if( iCmp < 0 ) {
                if( psvmapTemp->left == NULL ) {
                    psvmapTemp->left = DsRSASvMapCreate (heap, pDsname, vertex);
                    break;
                }
                else {
                    psvmapTemp = psvmapTemp->left;
                }
            }
            else {
                if( psvmapTemp->right == NULL ) {
                    psvmapTemp->right = DsRSASvMapCreate (heap, pDsname, vertex);
                    break;
                }
                else {
                    psvmapTemp = psvmapTemp->right;
                }
            }
        }
    }

    return pSvMap;
}

// Returns the vertex that has been associated with a given Dn.

TOPL_VERTEX
DsRSASvMapGetVertex (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    LPWSTR          pszDn
    ) {

    TOPL_VERTEX         vertex = NULL;
    PDSNAME         pDsname;
    INT             iCmp;

    pDsname = DsRSAAllocBuildDsname (heap, pszDn);

    while( pSvMap != NULL ) {
        iCmp = DsRSADnCmp (pDsname, pSvMap->pDsname);
        if( iCmp == 0 ) {
            vertex = pSvMap->vertex;
            break;
        }
        if( iCmp < 0 ) {
            pSvMap = pSvMap->left;
        }
        else {
            pSvMap = pSvMap->right;
        }
    }

    DsRSAFree (heap, pDsname);

    return vertex;
}

// Frees an SvMap tree.  Free the elements recursively.

VOID
DsRSASvMapDestroy (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap
    ) {

    if( pSvMap != NULL ) {
        DsRSAFree (heap, pSvMap->pDsname);
        DsRSASvMapDestroy (heap, pSvMap->left);
        DsRSASvMapDestroy (heap, pSvMap->right);
        DsRSAFree (heap, pSvMap);
    }
}

// This converts a root domain and a GUID to a GUID DNS.  The return
// value should be freed with DsRSAFree ().

LPWSTR
DsRSAAllocGuidDNS (
    HANDLE          heap,
    LPWSTR          pszRootDomain,
    GUID *          pGuid
    ) {

    LPWSTR          pszGuidDNS;

    pszGuidDNS = (LPWSTR) DsRSAAlloc (heap, (wcslen (pszRootDomain) + ADDITIONAL_BYTES_FOR_GUID_DNS) * sizeof (WCHAR));
    swprintf (pszGuidDNS, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x._msdcs.%s",
        pGuid->Data1,
        pGuid->Data2,
        pGuid->Data3,
        pGuid->Data4[0],
        pGuid->Data4[1],
        pGuid->Data4[2],
        pGuid->Data4[3],
        pGuid->Data4[4],
        pGuid->Data4[5],
        pGuid->Data4[6],
        pGuid->Data4[7],
        pszRootDomain);
    return pszGuidDNS;
}

// Builds the topology.

VOID
DsRSABuildTopology (
    HANDLE          heap,
    LDAP *          hld,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO *     ppToplInfo
    ) {

    LPWSTR          ppszNtdsDsaSearch [] = {    L"msDS-HasMasterNCs", L"hasMasterNCs", 
        L"objectGUID",
        NULL};

    LPWSTR          ppszConnectionSearch [] = { L"transportType",
        L"fromServer",
        NULL};

    LPWSTR          pszNtdsDsaSearchTemplate =
        L"(&(objectCategory=ntdsDsa)(|(msDS-HasMasterNCs=%s)(hasMasterNCs=%s)(hasPartialReplicaNCs=%s)))";

    LPWSTR          pszNtdsConnSearchTemplate =
        L"(&(objectCategory=nTDSConnection)(enabledConnection=TRUE))";

    HANDLE          hDS = NULL;
    DWORD           dwWin32Err;

    PDS_NAME_RESULTW        pResult = NULL;                 // For CrackNames
    PDSNAME         pDsname;
    PDSNAME         pdsnameHome;
    PDSNAME         pdsnameServer;

    LDAPMessage *       pldmRootResults = NULL;
    LDAPMessage *       pldmRootEntry = NULL;
    LPWSTR *            ppszConfigurationNC = NULL;
    LPWSTR *            ppszServiceName = NULL;
    LPWSTR *            ppszRootDNC = NULL;

    LPWSTR          pszNtdsDsaSearchFilter;
    LDAPSearch *        pDsaSearch = NULL;
    LDAPMessage *       pldmNtdsDsaResults = NULL;
    LDAPMessage *       pldmNtdsDsaEntry = NULL;
    LPWSTR *            ppszMasterNCs = NULL;
    struct berval **        ppbvObjectGUID = NULL;
    LPWSTR          pszServerDn = NULL;
    LPWSTR          pszServerTempDn = NULL;
    LPWSTR          pszSitesContainerDn = NULL;

    LDAPSearch *        pConnSearch = NULL;
    LDAPMessage *       pldmConnectionResults = NULL;
    LDAPMessage *       pldmConnectionEntry = NULL;
    LPWSTR *            ppszConnectionFrom = NULL;
    LPWSTR *            ppszTransportType = NULL;

    PDS_RSAI_SVMAP      pSvMapDnToVertex = NULL;
    PDS_RSAI_LIST       plistFirstServer;
    PDS_RSAI_LIST       plistNextServer;
    PDS_RSAI_SVRINFO        pSvrInfo;
    LPWSTR          pszGuidDNS;
    LONG            lNCAt;

    TOPL_VERTEX         vertex;
    TOPL_VERTEX         vHere;
    TOPL_VERTEX         vThere;
    TOPL_EDGE           edge;
    DWORD               dwThisId;
    ULONG               ul;
    INT                 iCmp;

    DWORD               dwLdapErr;
    DWORD               dwInnerLdapErr;
    ULONG               ulTotalEstimate = 0;
    ULONG               ulInnerTotalEstimate = 0;

    __try {

        // Set up the topology.
        *ppToplInfo = (PDS_RSAI_TOPLINFO) DsRSAAlloc (heap, sizeof (DS_RSAI_TOPLINFO));
        (*ppToplInfo)->toplGraph = NULL;

        // Create a list that will be used to store the servers.
        plistFirstServer = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
        plistFirstServer->next = NULL;
        plistNextServer = plistFirstServer;

        DsRSAChkLdap (ldap_search_sW (
            hld,
            NULL,
            LDAP_SCOPE_BASE,
            L"(objectCategory=*)",
            NULL,
            0,
            &pldmRootResults));

        if ((NULL == (pldmRootEntry = ldap_first_entry(hld, pldmRootResults)))
            || (NULL == (ppszConfigurationNC
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"configurationNamingContext")))
            || (NULL == (ppszServiceName
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"dsServiceName")))
            || (NULL == (ppszRootDNC
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"rootDomainNamingContext")))) {
            DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
        }

        DPRINT1( 3, "Home = %ws\n", ppszServiceName[0] );
        pdsnameHome = DsRSAAllocBuildDsname (heap, ppszServiceName[0]);

        // If the NC is NULL, default to the configuration NC
        if( pMainInfo->pdsnameNameContext == NULL ) {
            pMainInfo->pdsnameNameContext = DsRSAAllocBuildDsname (heap, ppszConfigurationNC[0]);
        }

        (*ppToplInfo)->toplGraph = ToplGraphCreate ();
        (*ppToplInfo)->vHome = NULL;

        // We use DsCrackNamesW to convert the Root Domain NC to the Root Domain Name
        // (e.g. DC=nttest,DC=microsoft,DC=com => nttest.microsoft.com)

        DsRSAChkErr (DsCrackNamesW (
            NULL,
            DS_NAME_FLAG_SYNTACTICAL_ONLY,
            DS_FQDN_1779_NAME,
            DS_CANONICAL_NAME_EX,
            1,
            ppszRootDNC,
            &pResult));

        (*ppToplInfo)->pszRootDomain = DsRSAAlloc (heap, (wcslen (pResult->rItems[0].pDomain) + 1) * sizeof (WCHAR));
        wcscpy ((*ppToplInfo)->pszRootDomain, pResult->rItems[0].pDomain);

        // *******************************************************************************************

        if( pMainInfo->ulFlags & DS_REPSYNCALL_CROSS_SITE_BOUNDARIES ) {
            // Form the Sites container dn from the sites prefix and the configuration NC DN

            pszSitesContainerDn = DsRSAAlloc( heap, sizeof( SITES_PREFIX ) + ((wcslen( ppszConfigurationNC[0] ) + 1) * sizeof( WCHAR )) );
            wcscpy( pszSitesContainerDn, SITES_PREFIX );
            wcscat( pszSitesContainerDn, ppszConfigurationNC[0] );
        }
        else {
            PDSNAME pdsnameTrimmed;
            // ppszServiceName[0] is the DN of the home server's NTDS Settings object.
            // This object is the grandchild of the Servers container, so we use TrimDSNameBy
            // to shorten its DN.
            pdsnameTrimmed = (PDSNAME) DsRSAAlloc (heap, pdsnameHome->structLen);
            TrimDSNameBy (pdsnameHome, 2, pdsnameTrimmed);

            pszSitesContainerDn = DsRSAAlloc( heap, (wcslen( pdsnameTrimmed->StringName ) + 1) * sizeof(WCHAR) );
            wcscpy( pszSitesContainerDn,  pdsnameTrimmed->StringName );
        }

        DPRINT1( 2, "Sites container = %ws\n", pszSitesContainerDn );

        // Now perform the main search to get all applicable servers.  We want references
        // to the servers' NTDS Settings objects.  Note that, because of the filter, on those
        // servers holding the desired NC (either writable or read-only) are included.
        pszNtdsDsaSearchFilter = DsRSAAlloc (heap, (wcslen (pszNtdsDsaSearchTemplate) +
                                     3 * wcslen (pMainInfo->pdsnameNameContext->StringName) + 1) * sizeof (WCHAR));
        swprintf (pszNtdsDsaSearchFilter, pszNtdsDsaSearchTemplate,
            pMainInfo->pdsnameNameContext->StringName,
            pMainInfo->pdsnameNameContext->StringName,
            pMainInfo->pdsnameNameContext->StringName);
	
        DPRINT1( 2, "Search filter = %ws\n", pszNtdsDsaSearchFilter );

        pDsaSearch = ldap_search_init_pageW(hld,
					pszSitesContainerDn,
					LDAP_SCOPE_SUBTREE,
					pszNtdsDsaSearchFilter,
					ppszNtdsDsaSearch,
					FALSE, NULL, NULL, 0, 0, NULL);
	if(pDsaSearch == NULL){
	    DsRSAChkLdap(LdapGetLastError());
	}

	DsRSAFree (heap, pszNtdsDsaSearchFilter);
        DsRSAFree (heap, pszSitesContainerDn);	

        // *******************************************************************************************

        // Cycle through the applicable servers and add them into the plistNextServer list.

        dwThisId = 0L;      // Start the IDs at 0
		
	dwLdapErr = ldap_get_next_page_s(hld,
					 pDsaSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmNtdsDsaResults);

        while(dwLdapErr == LDAP_SUCCESS){

            pldmNtdsDsaEntry = ldap_first_entry (hld, pldmNtdsDsaResults);
	    while( pldmNtdsDsaEntry != NULL ) {
		
                pszServerDn = ldap_get_dnW (hld, pldmNtdsDsaEntry);     // The server's DN

                DPRINT1( 3, "ServerDn = %ws\n", pszServerDn );

                // Create a DS_RSAI_SVRINFO structure for this server.
		pSvrInfo = (PDS_RSAI_SVRINFO) DsRSAAlloc (heap, sizeof (DS_RSAI_SVRINFO));
		pSvrInfo->dwId = dwThisId;

                // Cache the Dn in the pSvrInfo structure
                pSvrInfo->pszSvrDn = (LPWSTR) DsRSAAlloc (heap, (wcslen(pszServerDn) + 1)  * sizeof(WCHAR));
                wcscpy(pSvrInfo->pszSvrDn, pszServerDn);

                // Check if this server is a master for this NC (otherwise it is partial)
		pSvrInfo->bIsMaster = FALSE;
		ppszMasterNCs = ldap_get_valuesW (hld, pldmNtdsDsaEntry, L"msDS-HasMasterNCs");
        if (ppszMasterNCs == NULL) {
            // Fail over to deprecated value.
            ppszMasterNCs = ldap_get_valuesW (hld, pldmNtdsDsaEntry, L"hasMasterNCs");
        }
		for( lNCAt = 0;
		    ppszMasterNCs && ppszMasterNCs[lNCAt];
		    lNCAt++ ) {
		    pDsname = DsRSAAllocBuildDsname (heap, ppszMasterNCs[lNCAt]);
		    iCmp = DsRSADnCmp (pDsname, pMainInfo->pdsnameNameContext);
		    DsRSAFree (heap, pDsname);
		    if( 0 == iCmp ) {
			pSvrInfo->bIsMaster = TRUE;
			break;
		    }
		}
		ldap_value_freeW (ppszMasterNCs);
		ppszMasterNCs = NULL;

		// Get this server's GUID and store a copy in pSvrInfo.
		ppbvObjectGUID = ldap_get_values_lenW (hld, pldmNtdsDsaEntry, L"objectGUID");
                if (NULL == ppbvObjectGUID) {
                    DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                }
		memcpy ((LPVOID) &pSvrInfo->guid, (LPVOID) ppbvObjectGUID[0]->bv_val, ppbvObjectGUID[0]->bv_len);

		// Get this server's GUID DNS.
		pszGuidDNS = DsRSAAllocGuidDNS (heap, (*ppToplInfo)->pszRootDomain, (GUID *) ppbvObjectGUID[0]->bv_val);
		// Create the string in pSvrInfo that will be used to identify this server when reporting errors.
		if( pMainInfo->ulFlags & DS_REPSYNCALL_ID_SERVERS_BY_DN ) {
		    pSvrInfo->pszMsgId = (LPWSTR) DsRSAAlloc (heap, (wcslen (pszServerDn) + 1) * sizeof (WCHAR));
		    wcscpy (pSvrInfo->pszMsgId, pszServerDn);
		}
		else {
		    pSvrInfo->pszMsgId = pszGuidDNS;        // (pszGuidDNS has already been allocated)
		}

		// Check if this server is responding.
		if( (pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ||
		    ((dwWin32Err = DsBindWithCredW (pszGuidDNS, NULL, hRpcai, &hDS)) == NO_ERROR) ) {
                    DPRINT1( 4, "Server %ws is responding.\n", pszServerDn );
		    // Either we're supposed to skip the check, or the check was successful.  Add this
		    // server to the graph.
		    if( !(pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ) {
			DsUnBindW (&hDS);
		    }
		    vertex = ToplVertexCreate ();
		    ToplVertexSetId (vertex, dwThisId);
		    ToplGraphAddVertex ((*ppToplInfo)->toplGraph, vertex, vertex);
		    // Is this the home server?
		    pdsnameServer = DsRSAAllocBuildDsname (heap, pszServerDn);
		    if( 0 == DsRSADnCmp (pdsnameServer, pdsnameHome) ) {
			(*ppToplInfo)->vHome = vertex;
		    }

		    // Insert this server-vertex pair into the SvMap.
		    pSvMapDnToVertex = DsRSASvMapInsert (heap, pSvMapDnToVertex, pdsnameServer, vertex);
		    pSvrInfo->bIsInGraph = TRUE;
		}
		else {
		    // The check was unsuccessful.  Do not add this server to the graph.
		    hDS = NULL;
		    if( !(pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ) {
			DsRSADoError (heap, pMainInfo, pSvrInfo->pszMsgId, DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER, dwWin32Err, NULL);
		    }
		    pSvrInfo->bIsInGraph = FALSE;
		}

		// If pSvrInfo->pszMsgId points to the GUID DNS then we don't need to free it.
		if( pMainInfo->ulFlags & DS_REPSYNCALL_ID_SERVERS_BY_DN ) {
		    DsRSAFree (heap, pszGuidDNS);
		}

		// Insert this pSvrInfo structure into the list of servers.
		plistNextServer = DsRSAListInsert (heap, plistNextServer, (ULONG_PTR) pSvrInfo);

		ldap_value_free_len (ppbvObjectGUID);
		ppbvObjectGUID = NULL;

		ldap_memfreeW (pszServerDn);
		pszServerDn = NULL;

		dwThisId++;
		pldmNtdsDsaEntry = ldap_next_entry (hld, pldmNtdsDsaEntry);

	    }  // while( pldmNtdsDsaEntry != NULL )

	    ldap_msgfree(pldmNtdsDsaResults);
	    pldmNtdsDsaResults = NULL;

	    dwLdapErr = ldap_get_next_page_s(hld,
					     pDsaSearch,
					     0,
					     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					     &ulTotalEstimate,
					     &pldmNtdsDsaResults);

	} // while there is not error from the next paged search result set.
	
	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    DsRSAChkLdap(dwLdapErr);
	}
        dwLdapErr = ldap_search_abandon_page(hld, pDsaSearch);
	pDsaSearch = NULL; // subtlty here, need to set NULL, before calling DsRSAChkLdap()
	DsRSAChkLdap(dwLdapErr);

        // Store the total number of servers (including servers that were not added to the graph.)
        DPRINT1( 2, "Servers found = %d\n", dwThisId );
        (*ppToplInfo)->ulSize = (ULONG) dwThisId;
        if (!dwThisId) {
            // No servers found during search - abort
            DsRSAException (ERROR_DS_CANT_FIND_EXPECTED_NC);
        }

	// Convert the DS_RSAI_SVRINFO list into an array.
        (*ppToplInfo)->servers = (PDS_RSAI_SVRINFO *) DsRSAAlloc (heap, dwThisId * sizeof (PDS_RSAI_SVRINFO));
        plistNextServer = plistFirstServer;
        for( ul = 0; plistNextServer->next != NULL; ul++ ) {
            (*ppToplInfo)->servers[ul] = (PDS_RSAI_SVRINFO) plistNextServer->ulpItem;
            plistNextServer = plistNextServer->next;
        }
        DsRSAListDestroy (heap, plistFirstServer);

        // *******************************************************************************************

        // Now add the connections between servers (graph edges.)

        // Code.Improvement: It would be better to do a single subtree search for ntdsaConnection
        //    objects once, instead of issuing one search for each ntdsa object, as is done below
        //    in the inner loop and ldap_search_init_pageW().

        for(ul = 0; ul < (*ppToplInfo)->ulSize; ul++){

            pszServerTempDn = (*ppToplInfo)->servers[ul]->pszSvrDn;

            vHere = DsRSASvMapGetVertex (heap, pSvMapDnToVertex, pszServerTempDn);

            // We only analyze this server if both:
	    // (a) vHere is alive (that is, DsRSASvMapGetVertex did not return NULL);
	    // (b) if DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY is set, then vHere is home
            //     (i.e. either DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY is clear or vHere is home.)
            if( vHere != NULL && (     !(pMainInfo->ulFlags & DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY)
                                       ||  (vHere == (*ppToplInfo)->vHome)) ) {

                // Get all connections directed into this server.
                // The filter enforces only enabled connections
		
                pConnSearch = ldap_search_init_pageW(hld,
                                                     pszServerTempDn,
                                                     LDAP_SCOPE_ONELEVEL,
                                                     pszNtdsConnSearchTemplate,
                                                     ppszConnectionSearch,
                                                     FALSE, NULL, NULL, 0, 0, NULL);
                if(pConnSearch == NULL){
                    DsRSAChkLdap(LdapGetLastError());
                }

                dwInnerLdapErr = ldap_get_next_page_s(hld,
                                                      pConnSearch,
                                                      0,
                                                      DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                                      &ulInnerTotalEstimate,
                                                      &pldmConnectionResults);

                // Cycle through those connections, adding edges to the graph.
                while(dwInnerLdapErr == LDAP_SUCCESS){

                    pldmConnectionEntry = ldap_first_entry (hld, pldmConnectionResults);

                    while( pldmConnectionEntry != NULL ) {

                        ppszTransportType = ldap_get_valuesW (hld, pldmConnectionEntry, L"transportType");
                        if( (ppszTransportType == NULL) ||
                            (_wcsnicmp( ppszTransportType[0], IP_PREFIX, IP_PREFIX_LEN ) == 0) ) {

                            ppszConnectionFrom = ldap_get_valuesW (hld, pldmConnectionEntry, L"fromServer");
                            if (NULL == ppszConnectionFrom) {
                                DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                            }

                            // Determine which vertex the connection comes from.
                            vThere = DsRSASvMapGetVertex (heap, pSvMapDnToVertex, ppszConnectionFrom[0]);
                            // We only add this connection if both:
                            // (a) vThere is alive (that is, DsRSASvMapGetVertex did not return NULL);
                            // (b) either vHere is a partialReplica or vThere is a master for this NC.
                            if( vThere != NULL &&
                                ( !(*ppToplInfo)->servers[ToplVertexGetId (vHere )]->bIsMaster ||
                                  (*ppToplInfo)->servers[ToplVertexGetId (vThere)]->bIsMaster) ) {
                                edge = ToplEdgeCreate ();
                                ToplEdgeSetToVertex (edge, vHere);
                                ToplEdgeSetFromVertex (edge, vThere);
                                ToplEdgeAssociate (edge);
                                // Dump edges
                                DPRINT2( 3, "to:%ws <-- from:%ws\n",
                                         pszServerTempDn, ppszConnectionFrom[0] );
                            }
			}
                        if( ppszTransportType ) {
                            ldap_value_freeW (ppszTransportType);
                            ppszTransportType = NULL;
                        }
                        ldap_value_freeW (ppszConnectionFrom);
                        ppszConnectionFrom = NULL;
                        pldmConnectionEntry = ldap_next_entry (hld, pldmConnectionEntry);
                    } // end INNER while (pldmConnectionEntry != NULL)

                    ldap_msgfree (pldmConnectionResults);
                    pldmConnectionResults = NULL;
		
                    dwInnerLdapErr = ldap_get_next_page_s(hld,
                                                          pConnSearch,
                                                          0,
                                                          DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                                          &ulInnerTotalEstimate,
                                                          &pldmConnectionResults);
                } // end INNER page search while loop
                if(dwInnerLdapErr != LDAP_NO_RESULTS_RETURNED){
                    DsRSAChkLdap(dwInnerLdapErr);
                }

                dwInnerLdapErr = ldap_search_abandon_page(hld, pConnSearch);
                pConnSearch = NULL; // subtlty here, need to set NULL, before calling DsRSAChkLdap()
                DsRSAChkLdap(dwInnerLdapErr);

                pldmConnectionResults = NULL;
            } // end if( vHere != ....)

        } // end for each DC get the connections ...


    } __finally {

	if( pDsaSearch )
	    ldap_search_abandon_page(hld, pDsaSearch);
	if( pConnSearch )
	    ldap_search_abandon_page(hld, pConnSearch);
	if( ppszConnectionFrom )
            ldap_value_freeW (ppszConnectionFrom);
        if( pldmConnectionResults )
            ldap_msgfree (pldmConnectionResults);
        if( hDS )
            DsUnBindW (&hDS);
        if( ppszMasterNCs )
            ldap_value_freeW (ppszMasterNCs);
        if( ppbvObjectGUID )
            ldap_value_free_len (ppbvObjectGUID);
        if( pszServerDn )
            ldap_memfreeW (pszServerDn);
        if( pResult )
            DsFreeNameResultW (pResult);
        if( pldmNtdsDsaResults )
            ldap_msgfree (pldmNtdsDsaResults);
        if( ppszRootDNC )
            ldap_value_freeW (ppszRootDNC);
        if( ppszServiceName )
            ldap_value_freeW (ppszServiceName);
        if( ppszConfigurationNC )
            ldap_value_freeW (ppszConfigurationNC);
        if( pldmRootResults )
            ldap_msgfree (pldmRootResults);
        if( pSvMapDnToVertex )
            DsRSASvMapDestroy (heap, pSvMapDnToVertex);

    }

}


VOID
DsRSAToplGraphDestroy (
    TOPL_GRAPH          toplGraph
    ) {

    TOPL_ITERATOR       iter;
    TOPL_VERTEX         vertex;
    DWORD           dwInEdges;
    DWORD           dw;

    // ToplGraphFree doesn't destroy edges, so we must do that manually.
    iter = ToplIterCreate ();
    if( iter != NULL ) {
        ToplGraphSetVertexIter (toplGraph, iter);
        while( (vertex = (TOPL_VERTEX) ToplIterGetObject (iter)) != NULL ) {
            dwInEdges = ToplVertexNumberOfInEdges (vertex);
            for( dw = 0; dw < dwInEdges; dw++ ) {
                ToplEdgeFree (ToplVertexGetInEdge (vertex, dw));
            }
            ToplIterAdvance (iter);
        }
        ToplIterFree (iter);
    }               // If iter is NULL there's not a whole lot we can do.

    ToplGraphFree (toplGraph, TRUE);        // Free the graph & vertices
}

// This cleans the DS_RSAI_TOPLINFO structure returned by DsRSABuildTopology ().

VOID
DsRSAToplInfoDestroy (
    HANDLE          heap,
    PDS_RSAI_TOPLINFO       pToplInfo
    ) {

    ULONG           ul;

    DsRSAToplGraphDestroy (pToplInfo->toplGraph);
    for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
        DsRSAFree (heap, pToplInfo->servers[ul]->pszMsgId);
        DsRSAFree (heap, pToplInfo->servers[ul]->pszSvrDn);
        DsRSAFree (heap, pToplInfo->servers[ul]);
    }
    DsRSAFree (heap, pToplInfo->servers);
    DsRSAFree (heap, pToplInfo->pszRootDomain);
    DsRSAFree (heap, pToplInfo);

}

/*
 * This routine executes a breadth-first algorithm.  It assigns two properties to each
 * vertex in a directed graph:
 * (a) The length of the shortest path from that vertex to a stated home vertex;
 * (b) The next vertex along that path.
 *
 * The algorithm works as follows.  DsRSAToplAssignDistances identifies only those
 * vertices of distance lMaxDepth from the home vertex.  In order for
 * DsRSAToplAssignDistances to function correctly at lMaxDepth = n, it must already
 * have been called with lMaxDepth = n-1.  It traverses the paths identified by its
 * previous iteration(s) to guarantee that the distances it finds are minimal.
 * For example, if DsRSAToplAssignDistances finds an unidentified vertex with
 * lMaxDepth = 5, it can be guaranteed that no path of length 4 exists from that
 * vertex home, since the vertex was not discovered by any previous iteration.
 * DsRSAToplAssignDistances returns TRUE if new vertices were found, indicating that
 * another iteration may be necessary in order to completely assign distances.
 *
 *	BOOL DsRSAToplAssignDistances (
 *	    IN OUT	PLONG		alDistances,	// Array that stores the min distances
 *	    IN OUT	PDWORD		adwOtherEnds,	// Array that stores the target vertices
 *	    IN		TOPL_VERTEX	vHere,		// The home node
 *	    IN		LONG		lMaxDepth,	// See description above
 *	    IN		LONG		lThisDepth	// The current depth of the search
 *	    )
 */

BOOL
DsRSAToplAssignDistances (
    PLONG           alDistances,
    PDWORD          adwOtherEnds,
    TOPL_VERTEX         vHere,
    LONG            lMaxDepth,
    LONG            lThisDepth,
    ULONG                       ulFlags
    ) {

    BOOL            bAltered;
    DWORD           dwEdges;
    DWORD           dwThisId;
    DWORD           dwNextId;
    DWORD           dw;
    PVERTEX                     vertex;

    bAltered = FALSE;
    if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
        dwEdges = ToplVertexNumberOfOutEdges (vHere);
    }
    else {
        dwEdges = ToplVertexNumberOfInEdges (vHere);
    }
    dwThisId = ToplVertexGetId (vHere);

    if( lThisDepth == lMaxDepth-1 ) {
        // We're almost at lMaxDepth.  This means all currently unidentified vertices directed into
        // vHere should be assigned distance lMaxDepth.
        for( dw = 0; dw < dwEdges; dw++ ) {  // Cycle through all in-edges
            // Get the id of the vertex corresponding to this in-edge
            if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                vertex = ToplEdgeGetToVertex (ToplVertexGetOutEdge (vHere, dw));
            }
            else {
                vertex = ToplEdgeGetFromVertex (ToplVertexGetInEdge (vHere, dw));
            }
            dwNextId = ToplVertexGetId (vertex);
            if( alDistances [dwNextId] == -1 ) {     // Not yet identified
                bAltered = TRUE;            // A new vertex has now been discovered
                alDistances [dwNextId] = lMaxDepth; // Assign this vertex distance lMaxDepth
                adwOtherEnds [dwNextId] = dwThisId; // The vertex's target is vHere (source for push)
            }
        }
    }
    else {
        // We haven't reached lMaxDepth yet.  Recursively penetrate further into the graph.  That is,
        // scan through the list of vertices directed into vHere.  For each such vertex, if that
        // vertex's target is vHere, call DsRSAToplAssignDistances with that vertex as home and
        // lThisDepth incremented by 1.  This way we will reach each vertex exactly once in our search
        // and still preserve distance minimality.
        for( dw = 0; dw < dwEdges; dw++ ) {
            if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                vertex = ToplEdgeGetToVertex (ToplVertexGetOutEdge (vHere, dw));
            }
            else {
                vertex = ToplEdgeGetFromVertex (ToplVertexGetInEdge (vHere, dw));
            }
            dwNextId = ToplVertexGetId ( vertex );
            if( dwThisId == adwOtherEnds [dwNextId] )
                bAltered |= DsRSAToplAssignDistances (alDistances,
                                adwOtherEnds,
                                vertex,
                                lMaxDepth,
                                lThisDepth + 1L,
                                ulFlags);
        }
    }
    return bAltered;
}

// Analyze the topology generated by DsRSABuildTopology and construct a set of replications that will
// bring pToplInfo->vHome completely up-to-date.

VOID
DsRSAAnalyzeTopology (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST **     papReps
    ) {

    PLONG           alDistances = NULL;
    PDWORD          adwOtherEnds = NULL;
    LONG            lDepth;
    LONG            lMaxDistance;
    ULONG           ul;
    LONG            l;
    PDS_RSAI_REPLIST *      apreplistPoss = NULL;

    *papReps = NULL;
    lMaxDistance = 0L;

    __try {
        alDistances = (LONG *) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof (LONG));
        adwOtherEnds = (DWORD *) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof (DWORD));

        // Initially all servers are flagged as unreachable (distance = -1).
        for( ul = 0; ul < pToplInfo->ulSize; ul++ )
            alDistances[ul] = -1L;
        alDistances[ToplVertexGetId (pToplInfo->vHome)] = 0L;   // Home vertex has distance 0

        // Iteratively call DsRSAToplAssignDistances until FALSE is returned, incrementing lDepth each time.
        lDepth = 1L;
        while( DsRSAToplAssignDistances (alDistances, adwOtherEnds, pToplInfo->vHome, lDepth++, 0L, pMainInfo->ulFlags) );

        // Determine the maximum distance given by DsRSAToplAssignDistances.
        for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
            DPRINT2( 2, "alDistances[%d] = %d\n", ul, alDistances[ul] );
            DPRINT2( 2, "adwOtherEnds[%d] = %d\n", ul, adwOtherEnds[ul] );
            if( alDistances[ul] > lMaxDistance ) lMaxDistance = alDistances[ul];
        }
        DPRINT1( 2, "maxDistance = %d\n", lMaxDistance );

    #if DBG
        if( pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster )
            DPRINT( 2, "Home hosts a master replica for this NC.\n" );
        else
            DPRINT( 2, "Home hosts a partial replica for this NC.\n" );
    #endif

        // Compile a list of unreachable nodes.
        // If we're only syncing adjacent nodes, this is irrelevant since all available servers are reachable.
        
	// If we're pulling, then only the masters matter to us, and disconected
        // partials may be ignored.    

	// If we are pushing from a master, everyone should be connected to it to recieve changes, and nothing
	// should be ignored.  If we are pushing from a partial, everything could possibly be ignored.

        if( (!(pMainInfo->ulFlags & DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY))
	    &&
       	    ( (pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster) 
	      ||
	      (!(pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD))
	    )
	   ) {  
            for( ul = 0L; ul < pToplInfo->ulSize; ul++ ) { 
		if( (alDistances[ul] == -1L) 
		     && 
		     (pToplInfo->servers[ul]->bIsInGraph) 
		     &&
		    (   
		     ( (pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD) 
		       &&
		       (pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster)  
		     )
		     ||
		     ( (!(pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD)) 
		       &&  
		       (pToplInfo->servers[ul]->bIsMaster)  
		     )
		    )
		  ) {    
		    DsRSADoError (heap, pMainInfo, pToplInfo->servers[ul]->pszMsgId, DS_REPSYNCALL_SERVER_UNREACHABLE, NO_ERROR, NULL);
		}
	    }
	}
                // Now we generate the replication pattern.  The idea is as follows.
                // We return an array of (PDS_RSAI_REPLIST)s.  Each element of the array
                // corresponds to a list of replications that may be performed
                // asynchronously.  However, all replications in the first list must
                // be performed before any replications in the second, and so on.
                // Thus each list corresponds to a particular depth in the topology.
                //
                // If the depth is 3 (say), then array[0] will contain the list of
                // 3->2 replications, array[1] 2->1 replications, array[2] 1->0
                // replications and array[3] NULL.  Thus the actual replication
                // issuer need know nothing about the topology.

                // Allocate space for the array, and allocate space for an array of PDS_RSAI_REPLIST objects that
                // track the current location in each list.
        *papReps = (PDS_RSAI_REPLIST *) DsRSAAlloc (heap, (lMaxDistance + 1) * sizeof (PDS_RSAI_REPLIST));
        apreplistPoss = (PDS_RSAI_REPLIST *) DsRSAAlloc (heap, lMaxDistance * sizeof (PDS_RSAI_REPLIST));
        // Initialize each list.
        for( l = 0L; l < lMaxDistance; l++ ) {
            (*papReps)[l] = (PDS_RSAI_REPLIST) DsRSAAlloc (heap, sizeof (DS_RSAI_REPLIST));
            apreplistPoss[l] = (*papReps)[l];
        }
        (*papReps)[lMaxDistance] = NULL;

        // Transfer all the data into the list.
        for( ul = 0L; ul < pToplInfo->ulSize; ul++ ) {
            l = alDistances[ul];
            if( l != -1L && l != 0L ) {  // This node is reachable, and isn't the home vertex
                if( pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                    l--;                        // Convert distance (1 based) to index (0 based)
                    apreplistPoss[l]->dwIdSrc = adwOtherEnds[ul];
                    apreplistPoss[l]->dwIdDst = ul;
                }
                else {
                    l = lMaxDistance - l;   // We want the list in reverse order
                    apreplistPoss[l]->dwIdSrc = ul;
                    apreplistPoss[l]->dwIdDst = adwOtherEnds[ul];
                }
                apreplistPoss[l]->next = (PDS_RSAI_REPLIST) DsRSAAlloc (heap, sizeof (DS_RSAI_REPLIST));
                apreplistPoss[l] = apreplistPoss[l]->next;
            }
        }

        // Terminate each list
        for( l = 0; l < lMaxDistance; l++ )
            apreplistPoss[l]->next = NULL;
    }
    __finally {
        if( alDistances )
            DsRSAFree (heap, alDistances);
        if( adwOtherEnds )
            DsRSAFree (heap, adwOtherEnds);
        if( apreplistPoss )
            DsRSAFree (heap, apreplistPoss);
        // The apreplistPoss[i] correspond to part of the (*papReps)[i] lists
        // so we don't need to go through and delete them
        if( AbnormalTermination() ) {
            if( *papReps != NULL ) {
                DsRSAReplicationsFree( heap, *papReps );
                *papReps = NULL;
            }
        }
    }
}

// This destroys a set of replications as generated by DsRSAAnalyzeTopology ().

VOID
DsRSAReplicationsFree (
    HANDLE          heap,
    PDS_RSAI_REPLIST *      apReps
    ) {

    PDS_RSAI_REPLIST        preplistPos;
    PDS_RSAI_REPLIST        preplistTemp;
    LONG            l;

    l = 0;
    if( apReps != NULL )
        while( (preplistPos = apReps[l++]) != NULL )
            while( preplistPos != NULL ) {
                preplistTemp = preplistPos->next;
                DsRSAFree (heap, preplistPos);
                preplistPos = preplistTemp;
            }
}

// This dumps a set of replications as generated by DsRSAAnalyzeTopology ().
#if DBG
VOID
DsRSAReplicationsDump (
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps
    ) {

    PDS_RSAI_REPLIST        preplistPos;
    LONG            l;
    ULONG                       index;

    if( pToplInfo != NULL ) {
        DPRINT1( 1, "Servers: %d\n", pToplInfo->ulSize );
        for( index = 0; index < pToplInfo->ulSize; index++ ) {
            DPRINT2( 1, "\t[%d] =%ws", index, pToplInfo->servers[index]->pszMsgId );
            if( pToplInfo->servers[index]->bIsMaster ) {
                DPRINT( 1, " (master)\n" );
            }
            else {
                DPRINT( 1, " (partial)\n" );
            }
        }
    }
    if( apReps != NULL ) {
        DPRINT( 1, "Replication ordering dump:\n" );
        l = 0;
        while( (preplistPos = apReps[l++]) != NULL ) {
            DPRINT1( 1, "Level %d:\n", l );
            while( preplistPos->next != NULL ) {
                DPRINT2(1, "\tDest:%ws <-- Source:%ws\n",
                    pToplInfo->servers[preplistPos->dwIdDst]->pszMsgId,
                    pToplInfo->servers[preplistPos->dwIdSrc]->pszMsgId
                    );
                preplistPos = preplistPos->next;
            }
        }
    }
}
#endif

/*
 * The next few functions are involved with issuing the replications found with DsRSAAnalyzeTopology.
 * Multiple threads are used to permit replications to be issued asynchronously.  Events are used to
 * facilitate communication between threads.  (Also see dsrsa.h.)
 *
 */

// Sets this thread's state to threadState and waits for the primary thread to process that information.

VOID
DsRSASignalAndWait (
    PDS_RSAI_REPINFO        pRepInfo,
    DS_RSAI_THREAD_STATE    threadState
    ) {

    *pRepInfo->pThreadState = threadState;
    SetEvent (pRepInfo->hWaiting);
    WaitForSingleObject (pRepInfo->hReady, INFINITE);
    *pRepInfo->pThreadState = DS_RSAI_THREAD_ACTIVE;
}


// These are some defines for DsRSAIssueXXXXX functions();
#define INVALID_SERVER_INDEX  0xFFFFFFFF
#define MAX_SYNC_PARALLELISM 63

// The entry function of each auxiliary thread.  lpData should point to a DS_RSAI_REPINFO structure.
// This will issue a list of replications with the same destination server.

VOID
__cdecl
DsRSAIssueRep (
    LPVOID          lpData
    ) {
/*++

Routine Description:

    This routin will do a single destination sync.  It runs through the list of source syncs it has to
    do and signals the parent thread (in DsRSAIssueLevelOfReplications()) when finnished

Arguments:

    lpData - This is a little structure holding the destinations server to be syncd, and a list of source servers

Return Value:

--*/
    PDS_RSAI_REPINFO        pRepInfo = (PDS_RSAI_REPINFO) lpData;
    HANDLE          hDS;
    PDS_RSAI_LIST       plistPos;
    *pRepInfo->pdwWin32Err = DsBindWithCredW (pRepInfo->pszDstGuidDNS, NULL, pRepInfo->hRpcai, &hDS);
    if( *pRepInfo->pdwWin32Err != NO_ERROR ) {        // Problem binding!
        // Signal the primary thread that we could not bind to this server
        DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_BIND_ERROR);
    }
    else {

        // Iterate through each source server.
        plistPos = pRepInfo->plistSrcs;
        while( plistPos->next != NULL ) {
            // Update pRepInfo so that the primary thread knows which source server is being synced.
            *pRepInfo->pdwSyncAt = ((PDS_RSAI_SVRINFO) plistPos->ulpItem)->dwId;
            DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_BEGIN_SYNC);
            if( pRepInfo->bDoSync ) {
                // Perform the actual sync!
                *pRepInfo->pdwWin32Err = DsReplicaSyncW (hDS,
                                             pRepInfo->pdsnameNameContext->StringName,
                                             &((PDS_RSAI_SVRINFO) plistPos->ulpItem)->guid,
                                             DS_REPSYNC_FORCE);
                if( *pRepInfo->pdwWin32Err != NO_ERROR ) {
                    DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_SYNC_ERROR);
                }
                else {
                    DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_DONE_SYNC);       // The sync was successful.
                }
            }
            else {
                *pRepInfo->pdwWin32Err = ERROR_CANCELLED;               // The user chose not to sync.
                DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_SYNC_ERROR);       // (i.e. DS_REPSYNCALL_DO_NOT_SYNC set)
            }
            plistPos = plistPos->next;
        }
        DsUnBindW (&hDS);
    }

    // We're done!
    *pRepInfo->pThreadState = DS_RSAI_THREAD_FINISHED;
    SetEvent (pRepInfo->hWaiting);
    _endthread ();
}

// This issues a set of replications.
// The replications in the list apReps[i] may be issued asynchronously, but all
// replications in apReps[i] must be issued before any in apReps[i+1].

VOID
DsRSAIssueLevelOfReplications (
    HANDLE          heap,
    ULONG                       ulLevelSize,
    PULONG                      pulGlobalToLocal,
    PULONG                      pulLocalToGlobal,
    PDS_RSAI_REPLIST        preplistPos,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
    )
/*++

Routine Description:

    This routine will take do replications for ulLevelSize destinations, it uses the pulGlobalToLocal and
    pulLocalToGlobal to make the indirection happen that was needed to get around the fact that
    WaitForMultipleObject() can only wait on 64 objects.

Arguments:

    heap - a private heap
    ulLevelSize - The number of destination servers to sync in this level
    pulGlobalToLocal - an array of pToplInfo->ulSize, that maps an index in the array of apReps to an index in
       the arrays to be allocated in this routine for the worker thread.
    pulLocalToGlobal - an array of ulLevelSize, that maps an index from the arrays to be allocated in this routine
       to handle the different threads, and the value returned by WaitForMultipleObject to an array (global) index
       in apReps.
    pMainInfo - the main info for the thing
    pToplInfo - the topology info
    apReps - the different levels of replications that can happen in parrallel.  It is an array of linked lists
        that give all the replications to happen (Dst-Src Pairs)
    hRpcai - handle to the user credentials security structure

Return Value:

--*/
{
    PDS_RSAI_REPINFO        aRepInfo = NULL;
    PDS_RSAI_LIST *     aplistNextSrc = NULL;
    PDWORD          adwWin32Err = NULL;
    PDWORD          adwSyncAt = NULL;
    PDS_RSAI_THREAD_STATE   aThreadState = NULL;
    PHANDLE         ahWaiting = NULL;
    PHANDLE         ahReady = NULL;
    PBOOL           abFinished = NULL;
    BOOL            bAllFinished;

    DS_REPSYNCALL_UPDATEW   update;

    ULONG           ulDummy;
    ULONG           ulDstId;
    ULONG           ulRepNum;
    ULONG           ul;

    if( ulLevelSize == 0 ) {
        return;  // This means this function was called with 0 syncs for it to do in this run.
    }

    __try {

        aRepInfo = (PDS_RSAI_REPINFO) DsRSAAlloc (heap, ulLevelSize * sizeof (DS_RSAI_REPINFO));
        aplistNextSrc = (PDS_RSAI_LIST *) DsRSAAlloc (heap, ulLevelSize * sizeof (PDS_RSAI_LIST));
        ahWaiting = (PHANDLE) DsRSAAlloc (heap, ulLevelSize * sizeof (HANDLE));
        ahReady = (PHANDLE) DsRSAAlloc (heap, ulLevelSize * sizeof (HANDLE));
        adwWin32Err = (PULONG) DsRSAAlloc (heap, ulLevelSize * sizeof (ULONG));
        adwSyncAt = (PDWORD) DsRSAAlloc (heap, ulLevelSize * sizeof (DWORD));
        aThreadState = (PDS_RSAI_THREAD_STATE) DsRSAAlloc (heap, ulLevelSize * sizeof (DS_RSAI_THREAD_STATE));
        abFinished = (PBOOL) DsRSAAlloc (heap, ulLevelSize * sizeof (BOOL));

        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            ahReady[ulDstId] = NULL;
            ahWaiting[ulDstId] = NULL;
        }

        // Set up the aRepInfo[i] structures.  These are passed to the auxiliary threads and are used
        // for interthread communications.
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            aRepInfo[ulDstId].bDoSync = (pMainInfo->ulFlags & DS_REPSYNCALL_DO_NOT_SYNC ? FALSE : TRUE);
            aRepInfo[ulDstId].pdsnameNameContext = pMainInfo->pdsnameNameContext;
            aRepInfo[ulDstId].hRpcai = hRpcai;
            Assert(pulLocalToGlobal[ulDstId] != INVALID_SERVER_INDEX);
            aRepInfo[ulDstId].pszDstGuidDNS = DsRSAAllocGuidDNS (heap, pToplInfo->pszRootDomain,
                                                  &pToplInfo->servers[pulLocalToGlobal[ulDstId]]->guid);
            if( (ahReady[ulDstId] = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL ) {
                DsRSAException (GetLastError ());
            }
            aRepInfo[ulDstId].hReady = ahReady[ulDstId];
            if( (ahWaiting[ulDstId] = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL ) {
                DsRSAException (GetLastError ());
            }
            aRepInfo[ulDstId].hWaiting = ahWaiting[ulDstId];
            aRepInfo[ulDstId].pdwWin32Err = &(adwWin32Err[ulDstId]);
            aRepInfo[ulDstId].pdwSyncAt = &(adwSyncAt[ulDstId]);
            aRepInfo[ulDstId].pThreadState = &(aThreadState[ulDstId]);
        }

        // Initialization.
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            ResetEvent (ahWaiting[ulDstId]);        // Reset the events.
            ResetEvent (ahReady[ulDstId]);
            // Right now, no destination servers have been assigned any replications so they are all trivially finished.
            abFinished[ulDstId] = TRUE;
            // Initialize the lists of source servers.
            aRepInfo[ulDstId].plistSrcs = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
            aRepInfo[ulDstId].plistSrcs->next = NULL;
            aplistNextSrc[ulDstId] = aRepInfo[ulDstId].plistSrcs;
        }
        bAllFinished = TRUE;

        // Collate the replications at this iteration by server.  For each replication, add the SvrInfo structure
        // of the source server to the list that corresponds to the destination server's aRepInfo structure.
        while( preplistPos->next != NULL ) {
            if( pulGlobalToLocal[preplistPos->dwIdDst] != INVALID_SERVER_INDEX ) {
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->ulpItem = (ULONG_PTR) pToplInfo->servers[preplistPos->dwIdSrc];
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]] = aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next;
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next = NULL;
            } // end if one of the destinations we are doing in this invocation of the function.
            preplistPos = preplistPos->next;
        }

        // Issue each list of replications (i.e. create the threads.)
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            // If this server is the destination of some replications, create a thread.
            if( aRepInfo[ulDstId].plistSrcs->next != NULL ) {
                adwWin32Err[ulDstId] = ERROR_INTERNAL_ERROR;
                adwSyncAt[ulDstId] = INVALID_SERVER_INDEX;
                aThreadState[ulDstId] = DS_RSAI_THREAD_ACTIVE;
                abFinished[ulDstId] = FALSE;    // Now this destination server has replications, so it isn't finished.
                bAllFinished = FALSE;
                if( _beginthread (
                    DsRSAIssueRep,
                    0,
                    (LPVOID) (&aRepInfo[ulDstId])) == -1 ) {
                    DsRSAException (GetLastError ());
                }
            }
        }

        // Now continue waiting for the threads to send messages until all threads have finished.
        while( !bAllFinished ) {
            ulDstId = WaitForMultipleObjects (ulLevelSize,
                          ahWaiting,
                          FALSE,
                          INFINITE);
            if( ulDstId == WAIT_FAILED ) DsRSAException (GetLastError ());
            Assert(pulLocalToGlobal[ulDstId] != INVALID_SERVER_INDEX);
            // This is where the global to local redirections are about to get confusing, because adwSyncAt is actually another
            //   redirection vector like LocalToGlobal.
            switch( aThreadState[ulDstId] ) {
                case DS_RSAI_THREAD_ACTIVE:     // Thread is active; no action.
                    break;
                case DS_RSAI_THREAD_BEGIN_SYNC: // Sync begun; issue callback message.
                    DsRSAIssueUpdateSync (heap,
                        pMainInfo,
                        DS_REPSYNCALL_EVENT_SYNC_STARTED,
                        pToplInfo->servers[adwSyncAt[ulDstId]],
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]);
                    break;
                case DS_RSAI_THREAD_DONE_SYNC:  // Sync finished; issue callback message.
                    DsRSAIssueUpdateSync(heap,
                        pMainInfo,
                        DS_REPSYNCALL_EVENT_SYNC_COMPLETED,
                        pToplInfo->servers[adwSyncAt[ulDstId]],
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]);
                    break;
                case DS_RSAI_THREAD_SYNC_ERROR: // Error syncing.
                    DsRSADoError (heap,
                        pMainInfo,
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]->pszMsgId,
                        DS_REPSYNCALL_WIN32_ERROR_REPLICATING,
                        adwWin32Err[ulDstId],
                        pToplInfo->servers[adwSyncAt[ulDstId]]->pszMsgId);
                    break;
                case DS_RSAI_THREAD_BIND_ERROR: // Error binding.
                    // The source parameter is null here because we have not chosen a source yet.
                    // The adwSyncAt[] is not defined at this time.
                    DsRSADoError (heap,
                        pMainInfo,
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]->pszMsgId,
                        DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER,
                        adwWin32Err[ulDstId],
                        NULL);
                    break;
                case DS_RSAI_THREAD_FINISHED:   // Thread is finished.
                    abFinished[ulDstId] = TRUE;
                    bAllFinished = TRUE;
                    for( ul = 0;bAllFinished && (ul < ulLevelSize); ul++ )   // See if any threads are still unfinished.
                        bAllFinished &= abFinished[ul];
                    break;
                default:
                    break;
            }
            SetEvent (ahReady[ulDstId]);    // Notify the thread that we are done processing it.
        }

        // Initialization.

    } __finally {

        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {

            if( ahReady[ulDstId] != NULL ) CloseHandle (ahReady[ulDstId]);
            if( ahWaiting[ulDstId] != NULL ) CloseHandle (ahWaiting[ulDstId]);

            if( aRepInfo[ulDstId].pszDstGuidDNS != NULL ) DsRSAFree (heap, aRepInfo[ulDstId].pszDstGuidDNS);

            DsRSAListDestroy(heap, aRepInfo[ulDstId].plistSrcs);
        }

        if( abFinished != NULL )
            DsRSAFree (heap, abFinished);
        if( aThreadState != NULL )
            DsRSAFree (heap, aThreadState);
        if( adwSyncAt != NULL )
            DsRSAFree (heap, adwSyncAt);
        if( adwWin32Err != NULL )
            DsRSAFree (heap, adwWin32Err);
        if( ahReady != NULL )
            DsRSAFree (heap, ahReady);
        if( ahWaiting != NULL )
            DsRSAFree (heap, ahWaiting);
        if( aplistNextSrc != NULL )
            DsRSAFree (heap, aplistNextSrc);
        if( aRepInfo != NULL )
            DsRSAFree (heap, aRepInfo);
    }
}


// This issues a set of replications.
// The replications in the list apReps[i] may be issued asynchronously, but all
// replications in apReps[i] must be issued before any in apReps[i+1].

VOID
DsRSAIssueReplications (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
    )
/*++

Routine Description:

    This routine takes each level of destination replications that can happen in parallel and hands them to
    DsRSAIssueLevelOfReplications().  If there are more than ulMaxParallelism destinations, then it will spawn
    off ...IssueLevelOfRep.. early and continue on to finnish that level.

Arguments:

    heap - a private heap
    pMainInfo - the main info for the thing
    pToplInfo - the topology info
    apReps - the different levels of replications that can happen in parrallel.  It is an array of linked lists
        that give all the replications to happen (Dst-Src Pairs)
    hRpcai - the user credentials structure

Return Value:

--*/
{
    ULONG                       ulLevelSize;
    ULONG                       ulMaxParallelism;
    ULONG                       ul, ulTemp, ulRepNum;
    PDS_RSAI_REPLIST            preplistPos;
    // These 3 variables are to redirect for each call to DsRSAIssueLevelOfReplications(), the first two
    //   are reused for each call to ...IssueLevelOfRep..., and they must be reset after each call to it.
    // maps the global list of all servers to the temporary (local) list of servers for one sync level
    PULONG                      pulGlobalToLocal = NULL;
    // maps the temporary list of server back to the global list at any given sync level.
    PULONG                      pulLocalToGlobal = NULL;
    // maps the global list of all servers to the temporary list of servers for one sync level
    PBOOL                       pbDstServerWillBeSyncd = NULL;

    // Set the max parallelism to a reasonable maximum.
    ulMaxParallelism = min(MAXIMUM_WAIT_OBJECTS - 1, MAX_SYNC_PARALLELISM);
    // Uncomment this line to serialize all the Syncs
    //ulMaxParallelism = min(MAXIMUM_WAIT_OBJECTS - 1, 1);

    __try {

        pulGlobalToLocal = (PULONG) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof(ULONG));
        pbDstServerWillBeSyncd = (PBOOL) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof(BOOL));
        pulLocalToGlobal = (PULONG) DsRSAAlloc (heap, ulMaxParallelism * sizeof(ULONG));

        Assert(pulGlobalToLocal != NULL);
        Assert(pbDstServerWillBeSyncd != NULL);
        Assert(pulLocalToGlobal != NULL);

        for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
            pulGlobalToLocal[ul] = INVALID_SERVER_INDEX;
            pbDstServerWillBeSyncd[ul] = FALSE;
        }
        for( ul = 0; ul < ulMaxParallelism; ul++ ) {
            pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
        }

        ulRepNum = 0;
        while( preplistPos = apReps[ulRepNum] ) { // Do one level of syncs.

            ulLevelSize = 0;
            while( preplistPos->next != NULL ) { // process each element of the current preplistPos for level ulRepNum

                if( !pbDstServerWillBeSyncd[preplistPos->dwIdDst] ) {
                    pbDstServerWillBeSyncd[preplistPos->dwIdDst] = TRUE;
                    pulGlobalToLocal[preplistPos->dwIdDst] = ulLevelSize;
                    pulLocalToGlobal[ulLevelSize] = preplistPos->dwIdDst;
                    ulLevelSize++;
                }

                Assert(ulLevelSize != INVALID_SERVER_INDEX);

                if( ulLevelSize >= ulMaxParallelism ) {
                    // This is an exceptional case, rarely will there be 63 or more simultaneous
                    //   destination machines that can sync in parallel ... but just in case. :)
                    //   this little section will take care of the current ulMaxParallelism cases
                    //   and reset the counter and move on.

                    DsRSAIssueLevelOfReplications(heap,
                        ulLevelSize,
                        pulGlobalToLocal,
                        pulLocalToGlobal,
                        apReps[ulRepNum],
                        pMainInfo,
                        pToplInfo,
                        apReps,
                        hRpcai);

                    // Clean up - reset the arrays (technically this shouldn't be necessary)
                    for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                        if( pulLocalToGlobal[ul] != INVALID_SERVER_INDEX ) {
                            pulGlobalToLocal[pulLocalToGlobal[ul]] = INVALID_SERVER_INDEX;
                        }
                        pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
                    }
                    for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
                        Assert(pulGlobalToLocal[ul] == INVALID_SERVER_INDEX);
                    }
                    for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                        Assert(pulLocalToGlobal[ul] == INVALID_SERVER_INDEX);
                    }

                    ulLevelSize = 0;
                }
                preplistPos = preplistPos->next;


            } // end while processing one sync

            // The normal case is the above while loop will quit without reaching ulMaxParralelism
            //   destination machines.
            DsRSAIssueLevelOfReplications(heap,
                ulLevelSize,
                pulGlobalToLocal,
                pulLocalToGlobal,
                apReps[ulRepNum],
                pMainInfo,
                pToplInfo,
                apReps,
                hRpcai);

            // Clean up
            for( ul = 0; ul < ulLevelSize; ul++ ) {
                if( pulLocalToGlobal[ul] != INVALID_SERVER_INDEX ) {
                    Assert(pulGlobalToLocal[pulLocalToGlobal[ul]] != INVALID_SERVER_INDEX);
                    pulGlobalToLocal[pulLocalToGlobal[ul]] = INVALID_SERVER_INDEX;
                }
                pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
            }
            for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
                Assert(pulGlobalToLocal[ul] == INVALID_SERVER_INDEX);
            }
            for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                Assert(pulLocalToGlobal[ul] == INVALID_SERVER_INDEX);
            }

            ulRepNum++;

        } // end while doing whole level

    } __finally {

        if( pulLocalToGlobal != NULL )
            DsRSAFree (heap, pulLocalToGlobal);
        if( pbDstServerWillBeSyncd != NULL )
            DsRSAFree (heap, pbDstServerWillBeSyncd);
        if( pulGlobalToLocal != NULL )
            DsRSAFree (heap, pulGlobalToLocal);

    }
}

// Copy the error list, as an array, into one contiguous block of memory in the local heap.

VOID
DsRSABuildUnicodeErrorArray (
    PDS_RSAI_LIST       plistFirstError,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    PDS_REPSYNCALL_ERRINFOW perrinfoCur;
    PDS_RSAI_LIST       plistNextError;
    LPBYTE          lpMemPos, lpMemPosVar, lpMemBaseVar;
    ULONG           ulArraySize;
    ULONG           ulMemRequired;
    ULONG           ul;

    ulArraySize = ulMemRequired = 0L;

    // Compute the size of the array.
    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {
        ulArraySize++;
    }

    // Compute how much memory we'll need.
    // Complex structure looks like this:
    //    array of ulArraySize + 1 PDS_REPSYNCALL_ERRINFOA
    //    array of ulArraySize of DS_REPSYNCALL_ERRINFOA
    //    variable length string storage

    // For the pointers to array objects
    ulMemRequired += (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOW);
    // For the array objects themselves
    ulMemRequired += ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOW);

    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {       // For the strings
        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        ulMemRequired += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (WCHAR);
        if( perrinfoCur->pszSrcId != NULL ) {
            ulMemRequired += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (WCHAR);
        }
    }

    // *papErrInfo is the base of the array of pointers
    if( (*papErrInfo = LocalAlloc (LMEM_FIXED, ulMemRequired)) == NULL )
        DsRSAException (GetLastError ());

    // Base of the structures
    // lpMemPos - Current position moving forward in array of structures
    lpMemPos = (LPBYTE) (*papErrInfo) + (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOW);
    // lpMemBaseVar - Base of the variable length string storage
    // lpMemPosVar - Current position moving forward in variable storage
    lpMemBaseVar = lpMemPosVar = lpMemPos + ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOW);

    for( ul = 0L, plistNextError = plistFirstError;
        plistNextError->next != NULL;
        ul++, plistNextError = plistNextError->next ) {

        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;

        Assert( lpMemPos < lpMemBaseVar );
        Assert( ul < ulArraySize );
        (*papErrInfo)[ul] = (PDS_REPSYNCALL_ERRINFOW) lpMemPos;
        lpMemPos += sizeof (DS_REPSYNCALL_ERRINFOW);

        (*papErrInfo)[ul]->error = perrinfoCur->error;
        (*papErrInfo)[ul]->dwWin32Err = perrinfoCur->dwWin32Err;

        Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
        (*papErrInfo)[ul]->pszSvrId = (LPWSTR) lpMemPosVar;
        wcscpy ((*papErrInfo)[ul]->pszSvrId, perrinfoCur->pszSvrId);
        lpMemPosVar += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (WCHAR);

        if( perrinfoCur->pszSrcId != NULL ) {
            Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
            (*papErrInfo)[ul]->pszSrcId = (LPWSTR) lpMemPosVar;
            wcscpy ((*papErrInfo)[ul]->pszSrcId, perrinfoCur->pszSrcId);
            lpMemPosVar += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (WCHAR);
        }
        else {
            (*papErrInfo)[ul]->pszSrcId = NULL;
        }
    }
    (*papErrInfo)[ul] = NULL;               // Null terminator
}

VOID
DsRSABuildANSIErrorArray (
    HANDLE          heap,
    PDS_RSAI_LIST       plistFirstError,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    PDS_REPSYNCALL_ERRINFOW perrinfoCur;
    PDS_RSAI_LIST       plistNextError;
    LPBYTE          lpMemPos, lpMemPosVar, lpMemBaseVar;
    LPSTR           pszA;
    ULONG           ulArraySize;
    ULONG           ulMemRequired;
    ULONG           ul;

    ulArraySize = ulMemRequired = 0L;

    // Compute the size of the array.
    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {
        ulArraySize++;
    }

    // Compute how much memory we'll need.
    // Complex structure looks like this:
    //    array of ulArraySize + 1 PDS_REPSYNCALL_ERRINFOA
    //    array of ulArraySize of DS_REPSYNCALL_ERRINFOA
    //    variable length string storage

    // For the pointers to array objects
    ulMemRequired += (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOA);
    // For the array objects themselves
    ulMemRequired += ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOA);

    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {       // For the strings
        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        ulMemRequired += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (CHAR);
        if( perrinfoCur->pszSrcId != NULL ) {
            ulMemRequired += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (CHAR);
        }
    }

    // *papErrInfo is the base of the array of pointers
    if( (*papErrInfo = LocalAlloc (LMEM_FIXED, ulMemRequired)) == NULL ) {
        DsRSAException (GetLastError ());
    }

    // Base of structures
    // lpMemPos - Current position moving forward in array of structures
    lpMemPos = (LPBYTE) (*papErrInfo) + (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOA);
    // lpMemBaseVar - Base of variable length string storage
    // lpMemPosVar - Current position moving forward in variable storage

    lpMemBaseVar = lpMemPosVar =
        (lpMemPos + (ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOA)));

    for( ul = 0L, plistNextError = plistFirstError;
        plistNextError->next != NULL;
        ul++, plistNextError = plistNextError->next ) {

        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        Assert( lpMemPos < lpMemBaseVar );
        Assert( ul < ulArraySize );
        (*papErrInfo)[ul] = (PDS_REPSYNCALL_ERRINFOA) lpMemPos;
        lpMemPos += sizeof (DS_REPSYNCALL_ERRINFOA);

        (*papErrInfo)[ul]->error = perrinfoCur->error;
        (*papErrInfo)[ul]->dwWin32Err = perrinfoCur->dwWin32Err;

        Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
        (*papErrInfo)[ul]->pszSvrId = (LPSTR) lpMemPosVar;
        pszA = DsRSAAllocToANSI (heap, perrinfoCur->pszSvrId);
        //
        // PREFIX: PREFIX complains that pszA is never checked for NULL.
        // However, DsRSAAllocToAnsi will throw an exception if it is
        // unable to alloc the necessary memory.  The only other reason
        // that it might return NULL is if perrinfoCur->pszSvrId is NULL.
        // But perrinfoCur->pszSvrId can't be NULL because it comes from
        // papErrInfo which was alloced above.
        //
        Assert( strlen( pszA ) == wcslen( perrinfoCur->pszSvrId ) );
        strcpy ((*papErrInfo)[ul]->pszSvrId, pszA);
        DsRSAFree (heap, pszA);
        lpMemPosVar += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (CHAR);

        if( perrinfoCur->pszSrcId != NULL ) {
            Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
            (*papErrInfo)[ul]->pszSrcId = (LPSTR) lpMemPosVar;
            pszA = DsRSAAllocToANSI (heap, perrinfoCur->pszSrcId);
            Assert( strlen( pszA ) == wcslen( perrinfoCur->pszSrcId ) );
            strcpy ((*papErrInfo)[ul]->pszSrcId, pszA);
            DsRSAFree (heap, pszA);
            lpMemPosVar += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (CHAR);
        }
        else {
            (*papErrInfo)[ul]->pszSrcId = NULL;
        }
    }
    (*papErrInfo)[ul] = NULL;               // Null terminator
}

// This is the generic filter expression for the top level dsRRA
// exception handlers.

DWORD
DsRSAGetException (
    EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret) {
    DWORD dwException;
    ULONG_PTR * pExceptInfo;
    ULONG ulErrorCode;

    dwException = pExceptPtrs->ExceptionRecord->ExceptionCode;
    // If it's a DS_RSAI_EXCEPTION then handle it here
    if( dwException != DS_RSAI_EXCEPTION ) {
        *pret = 0;
        return EXCEPTION_CONTINUE_SEARCH;
    }
    pExceptInfo = pExceptPtrs->ExceptionRecord->ExceptionInformation;
    ulErrorCode = (ULONG)pExceptInfo[0];
    DPRINT1( 1, "Handling exception %d\n", ulErrorCode );
    *pret = ulErrorCode;
    return EXCEPTION_EXECUTE_HANDLER;
}

DWORD
DsReplicaSyncAllMain (
    HANDLE          hDS,
    LPCWSTR         pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBackW) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    BOOL (__stdcall *       pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfoW,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfoA
    ) {
    HANDLE          heap;
    LDAP *          hld;
    LPWSTR          lpSvr = NULL;
    RPC_AUTH_IDENTITY_HANDLE    hRpcai = NULL;
    DS_RSAI_MAININFO        mainInfo;
    PDS_RSAI_TOPLINFO       pTopl;
    PDS_RSAI_REPLIST *      apReps;
    PDS_RSAI_LIST       plistFirstError;
    DWORD           dwWin32Err;
    ULONG           ulOptions;

    heap = NULL;
    hld = NULL;
    pTopl = NULL;
    apReps = NULL;
    plistFirstError = NULL;
    dwWin32Err = NO_ERROR;


    if( hDS == NULL ) {
        // can't do anything w/out an opened handle
        return ERROR_INVALID_PARAMETER;
    }

    if( papErrInfoW != NULL ) {
        *papErrInfoW = NULL;        // Set the error structure to NULL -- no errors yet
    }
    if( papErrInfoA != NULL ) {
        *papErrInfoA = NULL;
    }

    __try {

        DsRSAChkErr (DsRSAHeapCreate (&heap));          // Create the heap
        plistFirstError = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
        plistFirstError->next = NULL;
        mainInfo.pdsnameNameContext = pszNameContext ? DsRSAAllocBuildDsname( heap, pszNameContext ) :
                                      NULL;
        mainInfo.ulFlags = ulFlags;
        mainInfo.pFnCallBackW = pFnCallBackW;
        mainInfo.pFnCallBackA = pFnCallBackA;
        mainInfo.pCallbackData = pCallbackData;
        mainInfo.plistNextError = plistFirstError;

        if ( ((BindState *) hDS)->bindAddr ) {
            // point to target svr
            lpSvr = ((BindState *) hDS)->bindAddr;
            // advance to skip leading backslashes.
            while(*lpSvr == '\\') {
                lpSvr++;
            }
        }
        if( (hld = ldap_initW (lpSvr, LDAP_PORT)) == NULL ) {
            DsRSAException (ERROR_DS_DRA_CONNECTION_FAILED);
        }
        if( ((BindState *) hDS)->hDrs == NULL ) {
            DsRSAException (ERROR_DS_DRA_CONNECTION_FAILED);
        }

        DsRSAChkErr ( RpcBindingInqAuthInfo (NDRCContextBinding ((NDR_CCONTEXT) ((BindState *) hDS)->hDrs),
            NULL, NULL, NULL, &hRpcai, NULL) );

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
        // Connect to the LDAP server and build the topology
        DsRSAChkLdap (ldap_bind_sW (hld, NULL, (LPWSTR) hRpcai, LDAP_AUTH_SSPI));

        DsRSABuildTopology (heap, hld, hRpcai, &mainInfo, &pTopl);
        ldap_unbind (hld);

        // Analyze topology and issue replications
        if( pTopl->vHome == NULL ) {
            DsRSAException (ERROR_DS_DRA_BAD_NC);       // The home server is not in this NC
        }
        DsRSAAnalyzeTopology (heap, &mainInfo, pTopl, &apReps);
    #if DBG
        DsRSAReplicationsDump (pTopl, apReps);
    #endif
        // If ABORT_IF_SERVER_UNAVAILABLE and there are any errors, then abort.
        if( (ulFlags & DS_REPSYNCALL_ABORT_IF_SERVER_UNAVAILABLE) && plistFirstError->next != NULL ) {
            DsRSAException (ERROR_CANCELLED);
        }

        DsRSAIssueReplications (heap, &mainInfo, pTopl, apReps, hRpcai);
        if( papErrInfoW != NULL && plistFirstError->next != NULL ) {
            DsRSABuildUnicodeErrorArray (plistFirstError, papErrInfoW);
        }
        if( papErrInfoA != NULL && plistFirstError->next != NULL ) {
            DsRSABuildANSIErrorArray (heap, plistFirstError, papErrInfoA);
        }

        // Cleanup
        DsRSAErrListDestroy (heap, plistFirstError);
        DsRSAReplicationsFree (heap, apReps);
        DsRSAToplInfoDestroy (heap, pTopl);
        DsRSAIssueUpdate (heap, &mainInfo, DS_REPSYNCALL_EVENT_FINISHED, NULL, NULL);
        DsRSAFree (heap, mainInfo.pdsnameNameContext);
        DsRSAHeapDestroy (heap);

    } __except( DsRSAGetException( GetExceptionInformation(), &dwWin32Err ) ) {
        // The topology is not on the heap so we must free it
        if( pTopl && pTopl->toplGraph ) DsRSAToplGraphDestroy (pTopl->toplGraph);
        // The error structure is allocated from the local heap so we must free it
        if( papErrInfoW != NULL && *papErrInfoW != NULL ) {
            LocalFree (*papErrInfoW);
        }
        if( papErrInfoA != NULL && *papErrInfoA != NULL ) {
            LocalFree (*papErrInfoA);
        }
        // We must free the ldap handle also
        if( hld ) {
            ldap_unbind (hld);
        }
        // And the heap . . .
        if( heap ) {
            DsRSAHeapDestroy (heap);
        }
    }

    return dwWin32Err;
}

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE          hDS,
    LPCWSTR                pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    return DsReplicaSyncAllMain (
        hDS,
        pszNameContext,
        ulFlags,
        pFnCallBack,
        NULL,
        pCallbackData,
        papErrInfo,
        NULL);
}

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE          hDS,
    LPCSTR                 pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    LPWSTR          pszNameContextW;
    DWORD           dwErr;

    pszNameContextW = NULL;
    dwErr = AllocConvertWide (pszNameContext, &pszNameContextW);

    if( dwErr == NO_ERROR ) {
        dwErr = DsReplicaSyncAllMain (
                    hDS,
                    pszNameContextW,
                    ulFlags,
                    NULL,
                    pFnCallBack,
                    pCallbackData,
                    NULL,
                    papErrInfo);

    }
    if( pszNameContextW != NULL ) {
        LocalFree (pszNameContextW);
    }

    return dwErr;
}
//
// -----
// NOT SUPPORTED IN WIN95
// -----
//
#else !WIN95 && !WINNT4
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
    #include <rpc.h>
    #include <drs.h>
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE                      hDS,
    LPCWSTR                pszNameContext,
    ULONG                       ulFlags,
    BOOL (__stdcall *           pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID                      pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    return ERROR_NOT_SUPPORTED;
}
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE                      hDS,
    LPCSTR                 pszNameContext,
    ULONG                       ulFlags,
    BOOL (__stdcall *           pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID                      pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    return ERROR_NOT_SUPPORTED;
}
#endif !WIN95 && !WINNT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\main.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    main.c

Abstract:

   DLL entry point

Author:

    Will Lees (wlees) 21-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#pragma hdrstop

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>            // RPC defines
#include <drs.h>            // DSNAME
#include "util.h"           // TerminateWinSock
#include "dsdebug.h"        // DsDebug Subsystem
#include "tlog.h"           // ds logging

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.
--*/
{
    BOOL  fReturn = TRUE;

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:
    {
        // Intialize DsLogEntry (functionality exists only in chk'ed builds)
        INITDSLOG();

        //
        // Initialize debug output (CHK builds only)
        // InitDsLog() MUST PRECEED THIS CALL!
        //
        INIT_DS_DEBUG();

        // don't call us back for thread creations/deaths
        DisableThreadLibraryCalls(hinstDll);
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        TerminateWinsockIfNeeded();

        //
        // Terminate debug output (CHK builds only)
        //
        TERMINATE_DS_DEBUG();

        // cleanup DsLogEntry (functionality exists only in chk'ed builds)
        TERMDSLOG();
        break;
    }
    default:
        break;
    }   /* switch */

    return ( fReturn);
}  /* DllLibMain() */

/* end main.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\dsdebug.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dsdebug.h

Abstract:

    debug definitions inside ntdsapi.dll

Author:

    Billy Fuller (billyf) 14-May-1999

Environment:

    User Mode - Win32

Notes:
    The debug layer is limited to CHK builds.

--*/

#ifndef __DS_DEBUG_H__
#define __DS_DEBUG_H__

//
// DEBUG ONLY
//
#if DBG

//
// DLL Initialization/Termination
//
#define INIT_DS_DEBUG()         InitDsDebug()
#define TERMINATE_DS_DEBUG()    TerminateDsDebug()

//
// Global debug info
//
extern DWORD gdwNtDsApiLevel;
extern DWORD gdwNtDsApiFlags;

//
// Flags
//
#define NTDSAPI_FLAGS_PRINT (0x00000001)
#define NTDSAPI_FLAGS_SPEW  (0x00000002)
#define NTDSAPI_FLAGS_LOG   (0x00000004)

#define NTDSAPI_FLAGS_ANY_OUT   (NTDSAPI_FLAGS_PRINT | \
                                 NTDSAPI_FLAGS_SPEW  | \
                                 NTDSAPI_FLAGS_LOG)

// print rpc extended error. Enable extended rpc errors by
//
#define DPRINT_RPC_EXTENDED_ERROR(_dwErr_) \
    DsDebugPrintRpcExtendedError(_dwErr_)

//
// Optional, guarded output
//
#define DPRINT(_Level, _Format) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__)

#define DPRINT1(_Level, _Format, _p1) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1)

#define DPRINT2(_Level, _Format, _p1, _p2) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2)

#define DPRINT3(_Level, _Format, _p1, _p2, _p3) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3)

#define DPRINT4(_Level, _Format, _p1, _p2, _p3, _p4) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4)

#define DPRINT5(_Level, _Format, _p1, _p2, _p3, _p4, _p5) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4, _p5)

#define DPRINT6(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4, _p5, _p6)

#define DPRINT7(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4, _p5, _p6, _p7)
    
//
// Forwards
//
VOID
InitDsDebug(
     VOID
     );
VOID
TerminateDsDebug(
     VOID
     );
VOID
DsDebugPrintRpcExtendedError(
    IN _dwErr_
    );
VOID
DsDebugPrint(
    IN DWORD    Level,
    IN PUCHAR   Format,
    IN PCHAR    DebSub,
    IN UINT     LineNo,
    IN ...
    );
#else DBG

//
// DEBUG NOT ENABLED!
//
#define INIT_DS_DEBUG()
#define TERMINATE_DS_DEBUG()
#define DPRINT_RPC_EXTENDED_ERROR(_dwErr_)
#define DPRINT(_Level, _Format)
#define DPRINT1(_Level, _Format, _p1)
#define DPRINT2(_Level, _Format, _p1, _p2)
#define DPRINT3(_Level, _Format, _p1, _p2, _p3)
#define DPRINT4(_Level, _Format, _p1, _p2, _p3, _p4)
#define DPRINT5(_Level, _Format, _p1, _p2, _p3, _p4, _p5)
#define DPRINT6(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6)
#define DPRINT7(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7)

#endif DBG

#if  DBG

extern void DoAssert( char *, char *, int );

#ifndef Assert
#define Assert( exp )   { if (!(exp)) DoAssert(#exp, __FILE__, __LINE__ ); }
#endif

#else

#ifndef Assert
#define Assert( exp )
#endif

#endif

#endif __DS_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\dsrsa.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dsrsa.h

ABSTRACT:

    Header file for dsrsa.c.

DETAILS:

CREATED:

    06/30/98	Aaron Siegel (t-asiege)

REVISION HISTORY:

--*/

#ifndef _DSRSA_H_
#define _DSRSA_H_

// Debugging support

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#if DBG
#define DPRINT( level, format ) if (gdwDsRSADbgLevel >= level) DbgPrint( format )
#define DPRINT1( level, format, arg1 ) if (gdwDsRSADbgLevel >= level) DbgPrint( format, arg1 )
#define DPRINT2( level, format, arg1, arg2 ) if (gdwDsRSADbgLevel >= level) DbgPrint( format, arg1, arg2 )
#else
#define DPRINT( level, format ) 
#define DPRINT1( level, format, arg1 ) 
#define DPRINT2( level, format, arg1, arg2 ) 
#endif

// This is the format of the exception
// Bits 31, 30    11 for severity of error
// Bit 29         1 for application
// Bit 28         0 reserved
// remaining high word = facility = 2
// low word = code in facility = 1
#define DS_RSAI_EXCEPTION	0xE0020001

// DS_REPSYNCALL_* refers to public datatypes / constants / structures.
// DS_RSAI_* refers to internal datatypes / constants / structures.  (RepSyncAll Internal)

typedef enum {

	DS_RSAI_THREAD_ACTIVE,			// Currently active
	DS_RSAI_THREAD_BEGIN_SYNC,		// About to perform a sync
	DS_RSAI_THREAD_DONE_SYNC,		// Just finished performing a sync
	DS_RSAI_THREAD_BIND_ERROR,		// Encountered a bind error
	DS_RSAI_THREAD_SYNC_ERROR,		// Encountered a sync error
	DS_RSAI_THREAD_FINISHED			// Finished

} DS_RSAI_THREAD_STATE, * PDS_RSAI_THREAD_STATE;

struct _DS_RSAI_LIST {
    struct _DS_RSAI_LIST *	next;
    ULONG_PTR			ulpItem;
} typedef DS_RSAI_LIST, * PDS_RSAI_LIST;

struct _DS_RSAI_SVMAP {
    struct _DS_RSAI_SVMAP *	left;
    struct _DS_RSAI_SVMAP *	right;
    PDSNAME			pDsname;
    TOPL_VERTEX			vertex;
} typedef DS_RSAI_SVMAP, * PDS_RSAI_SVMAP;

struct _DS_RSAI_REPLIST {
    struct _DS_RSAI_REPLIST *	next;
    DWORD			dwIdSrc;
    DWORD			dwIdDst;
} typedef DS_RSAI_REPLIST, * PDS_RSAI_REPLIST;

typedef struct {
    DWORD			dwId;
    GUID			guid;
    LPWSTR			pszMsgId;
    LPWSTR                      pszSvrDn;
    BOOL			bIsInGraph;
    BOOL			bIsMaster;
} DS_RSAI_SVRINFO, * PDS_RSAI_SVRINFO;

typedef struct {
    TOPL_GRAPH			toplGraph;
    TOPL_VERTEX			vHome;
    ULONG			ulSize;			// Number of servers; not necessarily number of nodes in topl
    LPWSTR			pszRootDomain;
    PDS_RSAI_SVRINFO *		servers;		// Array of SvrInfo structures
} DS_RSAI_TOPLINFO, * PDS_RSAI_TOPLINFO;

typedef struct {
    BOOL			bDoSync;		// TRUE if we should sync; false otherwise
    PDSNAME			pdsnameNameContext;	// The naming context.
    LPWSTR			pszDstGuidDNS;		// The destination server name.
    PDS_RSAI_LIST		plistSrcs;		// A list of source server SvrInfos.
    HANDLE			hReady;			// Event that is set if it's ok for the thread to act
    HANDLE			hWaiting;		// Event that the thread sets when it is waiting
    PDWORD			pdwWin32Err;		// Win32 error code
    PDWORD			pdwSyncAt;		// id of the server currently syncing from
    PDS_RSAI_THREAD_STATE	pThreadState;		// state of this thread
    RPC_AUTH_IDENTITY_HANDLE    hRpcai;                 // handle to the user credentials structure
} DS_RSAI_REPINFO, * PDS_RSAI_REPINFO;

typedef struct {
    PDSNAME			pdsnameNameContext;
    ULONG			ulFlags;
    BOOL (__stdcall *		pFnCallBackW) (LPVOID, PDS_REPSYNCALL_UPDATEW);
    BOOL (__stdcall *		pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA);
    LPVOID			pCallbackData;
    PDS_RSAI_LIST		plistNextError;
} DS_RSAI_MAININFO, * PDS_RSAI_MAININFO;

// Prototypes

VOID
DsRSAException (
    DWORD			dwWin32Err
    );

LPVOID
DsRSAAlloc (
    HANDLE			heap,
    DWORD			dwBytes
    );

PDS_RSAI_LIST
DsRSAListInsert (
    HANDLE          heap,
    PDS_RSAI_LIST   pList,
    ULONG_PTR       dwData
    );

VOID
DsRSAListDestroy (
    HANDLE			heap,
    PDS_RSAI_LIST		pList
    );

LPSTR
DsRSAAllocToANSI (
    HANDLE			heap,
    LPWSTR			pszW
    );

BOOL
DsRSAIssueANSIUpdate (
    HANDLE			heap,
    BOOL (__stdcall *		pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID			pCallbackData,
    PDS_REPSYNCALL_UPDATEW	pUpdateW
    );

VOID
DsRSAIssueUpdate (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    DS_REPSYNCALL_EVENT		event,
    PDS_REPSYNCALL_ERRINFOW	pErrInfo,
    PDS_REPSYNCALL_SYNCW	pSync
    );

VOID
DsRSAIssueUpdateSync (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    DS_REPSYNCALL_EVENT		event,
    PDS_RSAI_SVRINFO            pSrcSvrInfo,
    PDS_RSAI_SVRINFO            pDstSvrInfo
    );

VOID
DsRSADoError (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    LPWSTR			pszSvrId,
    DS_REPSYNCALL_ERROR		error,
    DWORD			dwWin32Err,
    LPWSTR			pszSrcId
    );

VOID
DsRSAErrListDestroy (
    HANDLE			heap,
    PDS_RSAI_LIST		plistFirstError
    );

VOID
DsRSASvMapUpdate (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap,
    PDSNAME			pDsname,
    TOPL_VERTEX			vertex
    );

PDS_RSAI_SVMAP
DsRSASvMapCreate (
    HANDLE			heap,
    PDSNAME			pDsname,
    TOPL_VERTEX			vertex
    );

PDS_RSAI_SVMAP
DsRSASvMapInsert (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap,
    PDSNAME			pDsname,
    TOPL_VERTEX			vertex
);

TOPL_VERTEX
DsRSASvMapGetVertex (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap,
    LPWSTR			pszDn
);

VOID
DsRSASvMapDestroy (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap
);

LPWSTR
DsRSADnStartAtNth (
    LPWSTR			pszDn,
    INT				iN
);

LPWSTR
DsRSAToGuidDNS (
    HANDLE			heap,
    LPWSTR			pszRootDomain,
    GUID *			pGuid
);

VOID
DsRSABuildTopology (
    HANDLE			heap,
    LDAP *			hld,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai,
    PDS_RSAI_MAININFO		pMainInfo,
    PDS_RSAI_TOPLINFO *		ppToplInfo
);

VOID
DsRSAToplInfoDestroy (
    HANDLE			heap,
    PDS_RSAI_TOPLINFO		pToplInfo
);

BOOL
DsRSAToplAssignDistances (
    PLONG			alDistances,
    PDWORD			adwTargets,
    TOPL_VERTEX			vHere,
    LONG			lMaxDepth,
    LONG			lThisDepth,
    ULONG                       ulFlags
);

VOID
DsRSAAnalyzeTopology (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    PDS_RSAI_TOPLINFO		pToplInfo,
    PDS_RSAI_REPLIST **		papReps
);

VOID
DsRSAReplicationsFree (
    HANDLE			heap,
    PDS_RSAI_REPLIST *		apReps
);

VOID
DsRSAWaitOnState (
    PDS_RSAI_THREAD_STATE	pThreadState
);

VOID __cdecl
DsRSAIssueRep (
    LPVOID			lpData
);

VOID
DsRSAIssueReplications (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    PDS_RSAI_TOPLINFO		pToplInfo,
    PDS_RSAI_REPLIST *		apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
);

VOID
DsRSABuildUnicodeErrorArray (
    PDS_RSAI_LIST		plistFirstError,
    PDS_REPSYNCALL_ERRINFOW **	papErrInfo
);

VOID
DsRSABuildANSIErrorArray (
    HANDLE			heap,
    PDS_RSAI_LIST		plistFirstError,
    PDS_REPSYNCALL_ERRINFOA **	papErrInfo
);

DWORD
DsReplicaSyncAllMain (
    HANDLE			hDS,
    LPCWSTR                     pszNameContext,
    ULONG			ulFlags,
    BOOL (__stdcall *		pFnCallBackW) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    BOOL (__stdcall *		pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID			pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **	papErrInfoW,
    PDS_REPSYNCALL_ERRINFOA **	papErrInfoA
);

#endif	// _DSRSA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\exscript.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    exscript.c

Abstract:

    Implementation of DsExecuteScript API and helper functions.

Author:

    MariosZ - Dec 2000

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <drs_w.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions
#include <stdio.h>          // for printf during debugging!
#include <dststlog.h>       // DSLOG
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#define SECURITY_WIN32 1
#include <sspi.h>
#include <winsock.h>
#include <process.h>

#define DEBSUB  "NTDSAPI_EXSCRIPT:"

#include "util.h"           // ntdsapi internal utility functions
#include "dsdebug.h"        // debug utility functions

#if !WIN95 && !WINNT4    

extern const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N);

extern DWORD
NtdsapiGetBinding(
    LPCWSTR             pwszAddress,
    RPC_BINDING_HANDLE  *phRpc,
    RPC_IF_HANDLE       clientIfHandle
    );

extern DWORD
SetUpMutualAuthAndEncryption(
    RPC_BINDING_HANDLE          hRpc,
    LPCWSTR                     DomainControllerName,
    LPCWSTR                     DnsDomainName,
    DOMAIN_CONTROLLER_INFOW     *pDcInfo,
    ULONG                       AuthnSvc,
    ULONG                       AuthnLevel,
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity,
    LPCWSTR                     ServicePrincipalName,
    ULONG                       ImpersonationType
    );

extern BOOL
IsServerUnavailableError(
    DWORD   dwErr
    );

DWORD
DsaopBindWithSpn(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    IN  LPCWSTR ServicePrincipalName,
    OUT RPC_BINDING_HANDLE  *phRpc
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL.

    ServicePrincipalName - SPN to use during mutual auth or NULL.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.
        
    AuthnSvc - Specification of which authentication service is desired.
        
    AuthnLevel - the authentication protection level needed (e.g. RPC_C_PROTECT_LEVEL_PKT_PRIVACY)
                 if not specified (0), the default (RPC_C_PROTECT_LEVEL_PKT_PRIVACY) is used.


Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/

{
    DWORD                   dwErr;
    DOMAIN_CONTROLLER_INFOW *pDcInfo = NULL;
    RPC_BINDING_HANDLE      hRpc;
    LPCWSTR                 pBindingAddress;
    ULONG                   flags;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif

    // We perform special semantics for explicit credentials whose
    // username has an "@" in it.  The assumption is that "@" is rare in
    // legacy user names, thus existence of an "@" probably means a UPN
    // has been presented.  The security subsystem makes the distinction
    // between a NULL domain and the empty string ("") domain.  For reasons
    // only the security people understand, the NULL domain can not be
    // used to authenticate UPNs.  And unfortunately few of the apps which
    // pass in explicit credentials can be expected to know this, much less
    // whether the user name field is a UPN or not.  So if the user name
    // contains "@" and the domain field is NULL, we substitute the empty
    // string for the NULL domain.  If this fails with ERROR_ACCESS_DENIED
    // and the user name is <= 20 chars, than it might indeed be a legacy
    // user name with an "@" in it, and we retry once with the NULL domain
    // again.

    DWORD                       cNullDomainRetries = 0;
    DWORD                       cUnavailableRetries = 0;
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo;
    PWCHAR                      emptyStringAorW = L"";
    BOOL                        fNullDomainRetryWarranted = FALSE;
    ULONG                       ImpersonationType;

    __try
    {
        // All fields of SEC_WINNT_AUTH_IDENTITY are in the same place in A and W
        // versions so assign temp variable at the same time we test for NULL.

        if (AuthnLevel == 0) {
            AuthnLevel = RPC_C_PROTECT_LEVEL_PKT_PRIVACY;
            DPRINT (0, "Using default AuthLevel: RPC_C_PROTECT_LEVEL_PKT_PRIVACY\n");
        }

        if (    (pAuthInfo = (PSEC_WINNT_AUTH_IDENTITY_W) AuthIdentity)
             && !pAuthInfo->Domain )
        {
            if (    (    (SEC_WINNT_AUTH_IDENTITY_UNICODE & pAuthInfo->Flags)
                      && wmemchr(pAuthInfo->User, L'@',
                                 pAuthInfo->UserLength) )
                 || (    (SEC_WINNT_AUTH_IDENTITY_ANSI & pAuthInfo->Flags)
                      && memchr((PCHAR) pAuthInfo->User, '@',
                                pAuthInfo->UserLength) ) )
            {
                    pAuthInfo->Domain = emptyStringAorW;
                    pAuthInfo->DomainLength = 0;
                    fNullDomainRetryWarranted = TRUE;
                    DPRINT(0, "NULL domain for name with '@' in it\n");
            }
        }

DsBindRetry:

        dwErr = NO_ERROR;
        hRpc = NULL;
        pBindingAddress = NULL;
        flags = ( DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME );

        // Sanity check arguments.

        if ( NULL == phRpc )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        *phRpc = NULL;

        if ( NULL != DomainControllerName )
        {
            pBindingAddress = DomainControllerName;
        }
        else
        {

            // Find a DC to talk to.

            if ( NULL == DnsDomainName )
            {
                flags |= DS_GC_SERVER_REQUIRED;
            }

            if ( 1 == cUnavailableRetries )
            {
                flags |= DS_FORCE_REDISCOVERY;
            }

            
            if (NULL == pDcInfo)
            {
                RpcTryExcept
                {
                    DPRINT(0, "DsGetDcNameW:\n");
                    DPRINT1(0, "    flags        : %08x\n", flags);
                    DPRINT1(0, "    ComputerName : %ws\n", NULL);
                    DPRINT1(0, "    DnsDomainName: %ws\n", DnsDomainName);
                    dwErr = DsGetDcNameW(
                                    NULL,                       // computer name
                                    DnsDomainName,              // DNS domain name
                                    NULL,                       // domain guid
                                    NULL,                       // site guid
                                    flags,
                                    &pDcInfo);
                }
                RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
                {
                    dwErr = RpcExceptionCode();
                }
                RpcEndExcept;

                DPRINT1(0, "DsGetDcNameW ==> 0x%x\n", dwErr);

                if ( NO_ERROR != dwErr )
                {
                    return(dwErr);
                }
            }
            pBindingAddress = pDcInfo->DomainControllerName;
        }


        DPRINT(0, "NtdsapiGetBinding:\n");
        DPRINT1(0, "    pBindingAddress: %ws\n", pBindingAddress);
        dwErr = NtdsapiGetBinding(pBindingAddress, &hRpc, _dsaop_ClientIfHandle);
        DPRINT1(0, "NtdsapiGetBinding ==> 0x%x\n", dwErr);

        if ( 0 == dwErr )
        {
            if ( NULL != hRpc )
            {

                // this binding used Impersonation. The DsBind starts with delegation
                if (AuthnSvc == RPC_C_AUTHN_NONE &&
                    AuthnLevel == RPC_C_PROTECT_LEVEL_NONE) {
                    ImpersonationType = RPC_C_IMP_LEVEL_ANONYMOUS;
                }
                else {
                    ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
                }
                
                // Make sure to pass caller's original DomainControllerName
                // and DnsDomainName - not something we derived else we are
                // circumventing caller's control of mutual authentication.
                dwErr = SetUpMutualAuthAndEncryption(
                                        hRpc,
                                        DomainControllerName,
                                        DnsDomainName,
                                        pDcInfo,
                                        AuthnSvc,
                                        AuthnLevel,
                                        AuthIdentity,
                                        ServicePrincipalName,
                                        ImpersonationType);
                
                if (dwErr) {
                    RpcBindingFree(&hRpc);
                }
            }
            else
            {
                dwErr = RPC_S_NO_BINDINGS;
            }
        }

        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsBind]"));
        DSLOG((0,"[SV=%ws][DN=%ws][PA=%s][ST=%u][ET=%u][ER=%u][-]\n",
               DomainControllerName
                    ? DomainControllerName
                    : L"NULL",
               DnsDomainName
                    ? DnsDomainName
                    : L"NULL",
               pBindingAddress, startTime, GetTickCount(), dwErr))


        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
            pDcInfo = NULL;
        }

        // Force rediscovery if we found the server for caller, the server
        // was obviously unavailable, and its our first time through.

        if (    (NULL == DomainControllerName)
             && (0 == cUnavailableRetries)
             && (IsServerUnavailableError(dwErr)) )
        {
            DPRINT(0, "Retrying DsGetDcName with DS_FORCE_REDISCOVERY\n");
            cUnavailableRetries++;
            goto DsBindRetry;
        }

        // Test for NULL domain handling conditions.
        if ( fNullDomainRetryWarranted )
        {
            // We're going to retry or return to caller.  Either way,
            // we need to restore the NULL domain pointer.
            pAuthInfo->Domain = NULL;

            if (    (0 == cNullDomainRetries++)
                 && (ERROR_ACCESS_DENIED == dwErr)
                 && (pAuthInfo->UserLength <= 20) )
            {
                DPRINT(0, "Retrying with NULL domain\n");
                goto DsBindRetry;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = GetExceptionCode();
        DPRINT1(0, "DsBindWithSpnW() Exception ==> %08x\n", dwErr);
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try
    {
        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
        }

        if (!dwErr) {
            *phRpc = hRpc;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    DPRINT1(0, "DsBindWithSpnW() ReturnCode ==> %08x\n", dwErr);

    return(dwErr);
}

DWORD
DsaopUnBind(
    RPC_BINDING_HANDLE  *phRpc
    )
{
    DWORD dwErr = 0;

    if ( NULL == phRpc )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
    {
        dwErr = RpcBindingFree(phRpc);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        dwErr = RpcExceptionCode();
        DPRINT1(0, "RpcEpResolveBinding Exception ==> 0x%x\n", dwErr);
    }
    RpcEndExcept;

    return dwErr;
}


DWORD
DsaopExecuteScript (
    IN  PVOID                  phAsync,
    IN  RPC_BINDING_HANDLE     hRpc,
    IN  DWORD                  cbPassword,
    IN  BYTE                  *pbPassword,
    OUT DWORD                 *dwOutVersion,
    OUT PVOID                  reply

    )
{
    DWORD dwErr = ERROR_SUCCESS;
    DSA_MSG_EXECUTE_SCRIPT_REQ           req;
    
    if (     !hRpc
          || !pbPassword
          || !reply ) {
         return(ERROR_INVALID_PARAMETER);
    }

    memset(&req, 0, sizeof(req));
    memset(reply, 0, sizeof(reply));

    req.V1.Flags = 0;
    req.V1.cbPassword = cbPassword;
    req.V1.pbPassword = pbPassword;


    RpcTryExcept
    {
        _IDL_DSAExecuteScript ((PRPC_ASYNC_STATE)phAsync, hRpc, 1, &req, dwOutVersion, (DSA_MSG_EXECUTE_SCRIPT_REPLY*)reply);

        DPRINT1 (0, "ExecuteScript: Error==> 0x%x\n", dwErr);

    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        dwErr = RpcExceptionCode();
        DPRINT1 (0, "ExecuteScript: Exception ==> 0x%x\n", dwErr);

    }
    RpcEndExcept;

    return dwErr;
}

DWORD
DsaopPrepareScript (
    IN  PVOID                        phAsync,
    IN  RPC_BINDING_HANDLE           hRpc,
    OUT DWORD                        *dwOutVersion,
    OUT PVOID                        reply
    )
{
    DWORD dwErr = 0;
    DSA_MSG_PREPARE_SCRIPT_REQ req;
    
    if (     !hRpc
          || !phAsync
          || !dwOutVersion
          || !reply  )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    memset(&req, 0, sizeof(req));
    
    RpcTryExcept
    {
        _IDL_DSAPrepareScript ((PRPC_ASYNC_STATE)phAsync, hRpc, 1, &req, dwOutVersion, (DSA_MSG_PREPARE_SCRIPT_REPLY*)reply);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        dwErr = RpcExceptionCode();
    }
    RpcEndExcept;

    return dwErr;
}


#else

DWORD
DsaopExecuteScript (
    IN  PVOID                  phAsync,
    IN  RPC_BINDING_HANDLE     hRpc,
    IN  DWORD                  cbPassword,
    IN  WCHAR                 *pbPassword,
    OUT DWORD                 *dwOutVersion,
    OUT PVOID                  reply

    )
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
DsaopPrepareScript (
    IN  PVOID                        phAsync,
    IN  RPC_BINDING_HANDLE           hRpc,
    OUT DWORD                        *dwOutVersion,
    OUT PVOID                        reply
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
DsaopUnBind(
    RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
DsaopBindWithSpn(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    IN  LPCWSTR ServicePrincipalName,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_NOT_SUPPORTED;
}
#endif


DWORD
DsaopBindWithCred(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return(DsaopBindWithSpn(DomainControllerName, 
                            DnsDomainName,
                            AuthIdentity, 
                            AuthnSvc,
                            AuthnLevel, 
                            NULL, 
                            phRpc));
}

DWORD
DsaopBind(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return DsaopBindWithCred( DomainControllerName,
                            DnsDomainName,
                            NULL, // credentials
                            AuthnSvc,
                            AuthnLevel,
                            phRpc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\rdn.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rdn.c

Abstract:

    Implementation of DsQuoteRdnValue/DsUnquoteRdnValue API and
    helper functions.

Author:

    BillyF     30-Apr-99

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_       // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>        // RPC defines
#include <drs.h>        // wire function prototypes
#include "util.h"       // ntdsapi private routines

#define DEBSUB  "NTDSAPI_RDN"


NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueA(
    IN     DWORD    cUnquotedRdnValueLength,
    IN     LPCCH    psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    OUT    LPCH     psQuotedRdnValue
    )
/*++

Description
Arguments:
Return Value:

    See DsQuoteRdnValueW()

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    DWORD   QuotedRdnValueLengthW;
    PWCHAR  QuotedRdnValueW = NULL;
    PWCHAR  UnquotedRdnValueW = NULL;

    __try {
        //
        // Verify Input
        //
        if ( (cUnquotedRdnValueLength == 0) ||
             (psUnquotedRdnValue == NULL) ||
             (pcQuotedRdnValueLength == NULL) ||
             ( (psQuotedRdnValue == NULL) && (*pcQuotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        //
        // Convert unquoted RDN into WCHAR
        //
        Status = AllocConvertWideBuffer(cUnquotedRdnValueLength,
                                        psUnquotedRdnValue,
                                        &UnquotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            __leave;
        }

        //
        // Allocate a WCHAR output buffer for the quoted RDN (if needed)
        //
        QuotedRdnValueLengthW = *pcQuotedRdnValueLength;
        if (QuotedRdnValueLengthW) {
            QuotedRdnValueW = LocalAlloc(LPTR,
                                    QuotedRdnValueLengthW * sizeof(WCHAR));
            if (QuotedRdnValueW == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
        }

        //
        // Call WCHAR version of DsQuoteRdnValue()
        //
        Status = DsQuoteRdnValueW(cUnquotedRdnValueLength,
                                  UnquotedRdnValueW,
                                  &QuotedRdnValueLengthW,
                                  QuotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            if (Status == ERROR_BUFFER_OVERFLOW) {
                //
                // return needed length
                //
                *pcQuotedRdnValueLength = QuotedRdnValueLengthW;
            }
            __leave;
        }

        //
        // Convert quoted RDN value into multi-byte
        //

        if (psQuotedRdnValue) {
            Number = WideCharToMultiByte(CP_ACP,
                                         0,
                                         QuotedRdnValueW,
                                         QuotedRdnValueLengthW,
                                         (LPSTR)psQuotedRdnValue,
                                         *pcQuotedRdnValueLength,
                                         NULL,
                                         NULL);
            if (Number == 0) {
                Status = ERROR_INVALID_PARAMETER;
                __leave;
            }
        }

        //
        // Return number of characters
        //
        *pcQuotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try {
        if (UnquotedRdnValueW != NULL) {
            LocalFree(UnquotedRdnValueW);
        }
        if (QuotedRdnValueW != NULL) {
            LocalFree(QuotedRdnValueW);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return Status;
}


NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueW(
    IN     DWORD    cUnquotedRdnValueLength,
    IN     LPCWCH   psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    OUT    LPWCH    psQuotedRdnValue
    )
/*++
    CHANGES TO THIS HEADER SHOULD BE RELFECTED IN NTDSAPI.H.

Description

    This client call converts an RDN value into a quoted RDN value if
    the RDN value contains characters that require quotes. The resultant
    RDN can be submitted as part of a DN to the DS using various APIs
    such as LDAP.

    No quotes are added if none are needed. In this case, the
    output RDN value will be the same as the input RDN value.

    Quotes are needed if:
        - There are leading or trailing spaces
        - There are special charcters (See ISSPECIAL()). The special
          chars are escaped.
        - There are embedded \0's (string terminators)

    The input and output RDN values are *NOT* NULL terminated.

    The changes made by this call can be undone by calling
    DsUnquoteRdnValue().

Arguments:

    cUnquotedRdnValueLength - The length of psUnquotedRdnValue in chars.

    psUnquotedRdnValue - Unquoted RDN value.

    pcQuotedRdnValueeLength - IN, maximum length of psQuotedRdnValue, in chars
                        OUT ERROR_SUCCESS, chars utilized in psQuotedRdnValue
                        OUT ERROR_BUFFER_OVERFLOW, chars needed in psQuotedRdnValue

    psQuotedRdnValue - The resultant and perhaps quoted RDN value

Return Value:
    ERROR_SUCCESS
        If quotes or escapes were needed, then psQuotedRdnValue contains
        the quoted, escaped version of psUnquotedRdnValue. Otherwise,
        psQuotedRdnValue contains a copy of psUnquotedRdnValue. In either
        case, pcQuotedRdnValueLength contains the space utilized, in chars.

    ERROR_BUFFER_OVERFLOW
        psQuotedRdnValueLength contains the space needed, in chars,
        to hold psQuotedRdnValue.

    ERROR_INVALID_PARAMETER
        Invalid parameter.

    ERROR_NOT_ENOUGH_MEMORY
        Allocation error.

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    __try {
        //
        // Verify Input
        //
        if ( (cUnquotedRdnValueLength == 0) ||
             (psUnquotedRdnValue == NULL) ||
             (pcQuotedRdnValueLength == NULL) ||
             ( (psQuotedRdnValue == NULL) && (*pcQuotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Convert unquoted RDN into quoted RDN (if quotes are needed)
        //
        Number = QuoteRDNValue(psUnquotedRdnValue,
                               cUnquotedRdnValueLength,
                               psQuotedRdnValue,
                               *pcQuotedRdnValueLength);
        if (Number == 0) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Output buffer is too small
        //
        if (Number > *pcQuotedRdnValueLength) {
            //
            // Return number of chars needed
            //
            *pcQuotedRdnValueLength = Number;
            Status = ERROR_BUFFER_OVERFLOW;
            __leave;
        }

        //
        // Return number of chars converted
        //
        *pcQuotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    return Status;
}


NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueA(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCCH    psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPCH     psUnquotedRdnValue
    )
/*++

Description
Arguments:
Return Value:

    See DsUnquoteRdnValueW()

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    DWORD   UnquotedRdnValueLengthW;
    PWCHAR  UnquotedRdnValueW = NULL;
    PWCHAR  QuotedRdnValueW = NULL;

    __try {
        //
        // Verify Input
        //
        if ( (cQuotedRdnValueLength == 0) ||
             (psQuotedRdnValue == NULL) ||
             (pcUnquotedRdnValueLength == NULL) ||
             ( (psUnquotedRdnValue == NULL) && (*pcUnquotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        //
        // Convert quoted RDN into WCHAR
        //
        Status = AllocConvertWideBuffer(cQuotedRdnValueLength,
                                        psQuotedRdnValue,
                                        &QuotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            __leave;
        }

        //
        // Allocate a WCHAR output buffer for the unquoted RDN (if needed)
        //
        UnquotedRdnValueLengthW = *pcUnquotedRdnValueLength;
        if (UnquotedRdnValueLengthW) {
            UnquotedRdnValueW = LocalAlloc(LPTR,
                                      UnquotedRdnValueLengthW * sizeof(WCHAR));
            if (UnquotedRdnValueW == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
        }

        //
        // Call WCHAR version of DsQuoteRdnValue()
        //
        Status = DsUnquoteRdnValueW(cQuotedRdnValueLength,
                                    QuotedRdnValueW,
                                    &UnquotedRdnValueLengthW,
                                    UnquotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            if (Status == ERROR_BUFFER_OVERFLOW) {
                // return needed length
                *pcUnquotedRdnValueLength = UnquotedRdnValueLengthW;
            }
            __leave;
        }

        //
        // Convert quoted RDN into multi-byte
        //

        if (psUnquotedRdnValue) {
            Number = WideCharToMultiByte(CP_ACP,
                                         0,
                                         UnquotedRdnValueW,
                                         UnquotedRdnValueLengthW,
                                         (LPSTR)psUnquotedRdnValue,
                                         *pcUnquotedRdnValueLength,
                                         NULL,
                                         NULL);
            if (Number == 0) {
                Status = ERROR_INVALID_PARAMETER;
                __leave;
            }
        }

        //
        // Return number of characters
        //
        *pcUnquotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try {
        if (QuotedRdnValueW != NULL) {
            LocalFree(QuotedRdnValueW);
        }
        if (UnquotedRdnValueW != NULL) {
            LocalFree(UnquotedRdnValueW);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return Status;
}


NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueW(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCWCH   psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPWCH    psUnquotedRdnValue
    )
/*++
    CHANGES TO THIS HEADER SHOULD BE RELFECTED IN NTDSAPI.H.

Description

    This client call converts a quoted RDN Value into an unquoted RDN
    Value. The resultant RDN value should *NOT* be submitted as part
    of a DN to the DS using various APIs such as LDAP.

    When psQuotedRdnValue is quoted:
        The leading and trailing quote are removed.

        Whitespace before the first quote is discarded.

        Whitespace trailing the last quote is discarded.

        Escapes are removed and the char following the escape is kept.

    The following actions are taken when psQuotedRdnValue is unquoted:

        Leading whitespace is discarded.

        Trailing whitespace is kept.

        Escaped non-special chars return an error.

        Unescaped special chars return an error.

        RDN values beginning with # (ignoring leading whitespace) are
        treated as a stringized BER value and converted accordingly.

        Escaped hex digits (\89) are converted into a binary byte (0x89).

        Escapes are removed from escaped special chars.

    The following actions are always taken:
        Escaped special chars are unescaped.

    The input and output RDN values are not NULL terminated.

Arguments:

    cQuotedRdnValueLength - The length of psQuotedRdnValue in chars.

    psQuotedRdnValue - RDN value that may be quoted and may be escaped.

    pcUnquotedRdnValueLength - IN, maximum length of psUnquotedRdnValue, in chars
                          OUT ERROR_SUCCESS, chars used in psUnquotedRdnValue
                          OUT ERROR_BUFFER_OVERFLOW, chars needed for psUnquotedRdnValue

    psUnquotedRdnValue - The resultant unquoted RDN value.

Return Value:
    ERROR_SUCCESS
        psUnquotedRdnValue contains the unquoted and unescaped version
        of psQuotedRdnValue. pcUnquotedRdnValueLength contains the space
        used, in chars.

    ERROR_BUFFER_OVERFLOW
        psUnquotedRdnValueLength contains the space needed, in chars,
        to hold psUnquotedRdnValue.

    ERROR_INVALID_PARAMETER
        Invalid parameter.

    ERROR_NOT_ENOUGH_MEMORY
        Allocation error.

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    WCHAR   Rdn[MAX_RDN_SIZE];

    __try {
        //
        // Verify Input
        //
        if ( (cQuotedRdnValueLength == 0) ||
             (psQuotedRdnValue == NULL) ||
             (pcUnquotedRdnValueLength == NULL) ||
             ( (psUnquotedRdnValue == NULL) && (*pcUnquotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Convert unquoted RDN into quoted RDN (if quotes are needed)
        //
        Number = UnquoteRDNValue(psQuotedRdnValue,
                                 cQuotedRdnValueLength,
                                 Rdn);
        if (Number == 0) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Output buffer is too small
        //
        if (Number > *pcUnquotedRdnValueLength) {
            //
            // Return number of chars needed
            //
            *pcUnquotedRdnValueLength = Number;
            Status = ERROR_BUFFER_OVERFLOW;
            __leave;
        }

        //
        // Return the number of chars converted and the converted RDN
        //
        if (psUnquotedRdnValue != NULL) {
            CopyMemory(psUnquotedRdnValue, Rdn, Number * sizeof(WCHAR));
        }
        *pcUnquotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    return Status;
}

NTDSAPI
DWORD
WINAPI
DsGetRdnW(
    IN OUT LPCWCH   *ppDN,
    IN OUT DWORD    *pcDN,
    OUT    LPCWCH   *ppKey,
    OUT    DWORD    *pcKey,
    OUT    LPCWCH   *ppVal,
    OUT    DWORD    *pcVal
    )
/*++
    CHANGES TO THIS HEADER SHOULD BE RELFECTED IN NTDSAPI.H.

Description

    This client call accepts a DN with quoted RDNs and returns the address
    and length, in chars, of the key and value for the first RDN in the DN.
    The RDN value returned is still quoted. Use DsUnquoteRdnValue to unquote
    the value for display.

    This client call also returns the address and length of the rest of the
    DN. A subsequent call using the returned DN address and length will
    return information about the next RDN.

    The following loop processes each RDN in pDN:
        ccDN = wcslen(pDN)
        while (ccDN) {
            error = DsGetRdn(&pDN,
                             &ccDN,
                             &pKey,
                             &ccKey,
                             &pVal,
                             &ccVal);
            if (error != ERROR_SUCCESS) {
                process error;
                return;
            }
            if (ccKey) {
                process pKey;
            }
            if (ccVal) {
                process pVal;
            }
        }

    For example, given the DN "cn=bob,dc=com", the first call to DsGetRdnW
    returns the addresses for ",dc=com", "cn", and "bob" with respective
    lengths of 7, 2, and 3. A subsequent call with ",dc=com" returns "",
    "dc", and "com" with respective lengths 0, 2, and 3.

Arguments:
    ppDN
        IN : *ppDN points to a DN
        OUT: *ppDN points to the rest of the DN following the first RDN
    pcDN
        IN : *pcDN is the count of chars in the input *ppDN, not including
             any terminating NULL
        OUT: *pcDN is the count of chars in the output *ppDN, not including
             any terminating NULL
    ppKey
        OUT: Undefined if *pcKey is 0. Otherwise, *ppKey points to the first
             key in the DN
    pcKey
        OUT: *pcKey is the count of chars in *ppKey.

    ppVal
        OUT: Undefined if *pcVal is 0. Otherwise, *ppVal points to the first
             value in the DN
    pcVal
        OUT: *pcVal is the count of chars in *ppVal

Return Value:
    ERROR_SUCCESS
        If *pccDN is not 0, then *ppDN points to the rest of the DN following
        the first RDN. If *pccDN is 0, then *ppDN is undefined.

        If *pccKey is not 0, then *ppKey points to the first key in DN. If
        *pccKey is 0, then *ppKey is undefined.

        If *pccVal is not 0, then *ppVal points to the first value in DN. If
        *pccVal is 0, then *ppVal is undefined.

    ERROR_DS_NAME_UNPARSEABLE
        The first RDN in *ppDN could not be parsed. All output parameters
        are undefined.

    Any other error
        All output parameters are undefined.

--*/
{
    DWORD   Status;

    __try {
        Status = GetRDN(ppDN,
                        pcDN,
                        ppKey,
                        pcKey,
                        ppVal,
                        pcVal);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    return Status;
}


NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnA(
    IN LPCSTR pszRDN,
    IN DWORD cchRDN,
    OUT OPTIONAL GUID *pGuid,
    OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
    )

/*++

Routine Description:

    See ntdsapi.w

Arguments:

    pszRDN - 
    cchRDN - 
    pGuid - 
    peDsMangleFor - 

Return Value:

    WINAPI - 

--*/

{
    BOOL fResult;
    DWORD status;
    LPWSTR pszRDNW = NULL;

    if ( (pszRDN == NULL) ||
         (cchRDN == 0) ) {
        return FALSE;
    }

    //
    // Convert unquoted RDN into WCHAR
    //
    status = AllocConvertWideBuffer( cchRDN, pszRDN, &pszRDNW );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Perform the function
    //
    fResult = DsCrackUnquotedMangledRdnW( pszRDNW, cchRDN, pGuid, peDsMangleFor );

    //
    // Cleanup
    //
    if (pszRDNW) {
        LocalFree( pszRDNW );
    }

    return fResult;
} /* DsCrackUnquotedMangledRdnA */


NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnW(
    IN LPCWSTR pszRDN,
    IN DWORD cchRDN,
    OUT OPTIONAL GUID *pGuid,
    OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
    )

/*++

Routine Description:

    See ntdsapi.w

Arguments:

    pszRDN - 
    cchRDN - 
    pGuid - 
    peDsMangleFor - 

Return Value:

    WINAPI - 

--*/

{
    GUID guidDummy;
    MANGLE_FOR peMangleFor;
    BOOL fResult;

    if ( (pszRDN == NULL) ||
         (cchRDN == 0) ) {
        return FALSE;
    }

    if (!pGuid) {
        pGuid = &guidDummy;
    }
    fResult = IsMangledRDN( (LPWSTR) pszRDN, cchRDN, pGuid, &peMangleFor );
    if (!fResult) {
        return FALSE;
    }

    // Convert out parameters
    if (peDsMangleFor) {
        switch (peMangleFor) {
        case MANGLE_OBJECT_RDN_FOR_DELETION:
            *peDsMangleFor = DS_MANGLE_OBJECT_RDN_FOR_DELETION;
            break;
        case MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
        case MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT:
            // The distinction between object and phantom conflicts is not preserved
            // out of IsMangledRDN. I felt it simpler for the external user not even
            // to be aware of the difference. I map both types to the same external
            // value.
            *peDsMangleFor = DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT;
            break;
        default:
            *peDsMangleFor = DS_MANGLE_UNKNOWN;
            break;
        }
    }

    return TRUE;
} /* DsCrackUnquotedMangledRdnW */


NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueA(
    LPCSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    )

/*++

Routine Description:

    See DsIsMangledRdnValueW

Arguments:

    pszRdn - 
    cRdn - 
    eDsMangleForDesired - 

Return Value:

    WINAPI - 

--*/

{
    BOOL fResult;
    DWORD status;
    LPWSTR pszRdnW = NULL;

    if ( (pszRdn == NULL) ||
         (cRdn == 0) ) {
        return FALSE;
    }

    //
    // Convert unquoted RDN into WCHAR
    //
    status = AllocConvertWideBuffer( cRdn, pszRdn, &pszRdnW );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Perform the function
    //
    fResult = DsIsMangledRdnValueW( pszRdnW, cRdn, eDsMangleForDesired );

    //
    // Cleanup
    //
    if (pszRdnW) {
        LocalFree( pszRdnW );
    }

    return fResult;

} /* DsIsMangledRdnValueA */


NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueW(
    LPCWSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    )

/*++

Routine Description:

    Determine if the given RDN is mangled, and of the given type

    The name may be quoted or unquoted.  This routine tries to unquote the value.  If
    the unquote operation fails, the routine proceeds to attempt the unmangle.

    A change was made in the default quoting behavior of DNs returned from the DS
    between Windows 2000 and Windows XP. This routine transparently handles RDNs with
    special characters in either form.

    The routine expects the value part of the RDN.

    If you have full DN, use IsDeletedDN below.

    To check for deleted name:
        DsIsMangledRdnValueW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_DELETION )
    To check for a conflicted name:
        DsIsMangledRdnValueW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_NAME_CONFLICT )

Arguments:

    pszRdn - 
    cRdn - 
    eDsMangleForDesired - 

Return Value:

    WINAPI - 

--*/

{
    DWORD status, cUnquoted = MAX_RDN_SIZE;
    WCHAR rgchUnquoted[MAX_RDN_SIZE];
    DS_MANGLE_FOR mangleType;

    if ( (pszRdn == NULL) ||
         (cRdn == 0) ) {
        return FALSE;
    }

    // Unquote the RDN. This is needed when receiving DNs from Whistler Beta 2
    // and later systems.  This may fail when passed RDNs from W2K systems which
    // contain unquoted special characters, especially in mangled names.
    // Because of the change in quoting behavior for mangled names, applications
    // need to be able to deal with both forms of names.
    status = DsUnquoteRdnValueW( cRdn,
                                 pszRdn,
                                 &cUnquoted,
                                 rgchUnquoted );
    if (!status) {
        // If the unquoting was successful, use the unquoted names instead
        pszRdn = rgchUnquoted;
        cRdn = cUnquoted;
    }

    // Unmangle
    return DsCrackUnquotedMangledRdnW( pszRdn, cRdn, NULL, &mangleType ) &&
        (mangleType == eDsMangleForDesired);

} /* DsIsMangledRdnValueW */


NTDSAPI
BOOL
WINAPI
DsIsMangledDnA(
    LPCSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    )

/*++

Routine Description:

    See DsIsMangledDnW()

Arguments:

    pszDn - 
    eDsMangleFor - 

Return Value:

    WINAPI - 

--*/

{
    BOOL fResult;
    DWORD status;
    LPWSTR pszDnW = NULL;

    if (pszDn == NULL) {
        return FALSE;
    }

    //
    // Convert unquoted RDN into WCHAR
    //
    status = AllocConvertWide( pszDn, &pszDnW );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Perform the function
    //
    fResult = DsIsMangledDnW( pszDnW, eDsMangleFor );

    //
    // Cleanup
    //
    if (pszDnW) {
        LocalFree( pszDnW );
    }

    return fResult;

} /* DsIsMangledDnA */


NTDSAPI
BOOL
WINAPI
DsIsMangledDnW(
    LPCWSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    )

/*++

Routine Description:

    Determine if the first RDN in this DN is a mangled name of given type

    The dn may be in quoted form as returned from DS functions.

    To check for deleted name:
        DsIsMangledDnW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_DELETION )
    To check for a conflicted name:
        DsIsMangledDnW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_NAME_CONFLICT )

Arguments:

    pszDn - Dn from which first RDN is taken. Null terminated.

    eDsMangleFor - Type of mangled name to check for

Return Value:

    WINAPI - 

--*/

{
    DWORD status;
    LPCWSTR pDN, pKey, pVal;
    DWORD cDN, cKey, cVal;

    if (pszDn == NULL) {
        return FALSE;
    }

    pDN = pszDn;
    cDN = wcslen(pszDn);
    if (cDN == 0) {
        return FALSE;
    }

    status = DsGetRdnW( &pDN, &cDN, &pKey, &cKey, &pVal, &cVal );
    if (status) {
        return FALSE;
    }

    return DsIsMangledRdnValueW( pVal, cVal, eDsMangleFor );
} /* DsIsMangledDnW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\remove.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    remove.c

Abstract:

    Implementation of ntdsapi.dll DsRemoveServer/Domain routines

Author:

    ColinBr     14-Jan-98

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <malloc.h>         // alloca()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions, MAP_SECURITY_STATUS
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include <dststlog.h>       // DSLOG
#include <util.h>

//
// Dll Entrypoints
//
DWORD
DsRemoveDsServerW(
    HANDLE  hDs,             // in
    LPWSTR  ServerDN,        // in
    LPWSTR  DomainDN,        // in,  optional
    BOOL   *fLastDcInDomain, // out, optional
    BOOL    fCommit          // in
    )
/*++

Routine Description:

    This routine removes all traces of a directory service agent from the 
    global area of the directory service (configuration container).  A 
    server dn is passed in; that server is not removed but the ntdsa object
    "underneath" that server is removed.  In addition, this function will 
    return whether the server deleted is the last dc in the domain, as 
    indicated by information on this ds.

Arguments:

    hDs            : a valid handle returned from DsBind
    
    ServerDN       : a null terminated string representing the string DN name
                     of a server object
                    
    DomainDN       : a null terminated string of a domain that is hosted by 
                     ServerDN
                    
    fLastDcInDomain: pointer to bool set on function success if ServerDN is the
                     last DC in the DomainDN
                                       
    fCommit        : boolean indicating the caller really wants to remove 
                     the server.  If false, this function will still check
                     the object's existence and fLastDcInDomain status

Return Value:

    A winerror, notably:
    
    ERROR_SUCCESS: 
    
    DS_ERR_CANT_DELETE_DSA_OBJ:  the ServerDN is the server that we currently
                                 bound to
    
    DS_ERR_NO_CROSSREF_FOR_NC:   can't find a crossref object for DomainDN

    ERROR_ACCESS_DENIED:         the caller doesn't have the correct permissions
                                 to delete the object    

--*/
{
    DWORD WinError;

    DRS_MSG_RMSVRREQ   RequestParam;
    DRS_MSG_RMSVRREPLY ReplyParam;
    DWORD              dwInVersion = 1;
    DWORD              dwOutVersion = 0;
    LPWSTR             NtdsServerDN = NULL;
#if DBG
    DWORD               startTime = GetTickCount();
#endif

    //
    // Parameter check
    //
    if ( NULL == hDs 
      || NULL == ServerDN 
      || 0    == wcslen( ServerDN ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First see if this function is exported
    //
    if ( !IS_DRS_REMOVEAPI_SUPPORTED( ((BindState *) hDs)->pServerExtensions ) )
    {
        return RPC_S_CANNOT_SUPPORT;
    }

    __try
    {

        RtlZeroMemory( &RequestParam, sizeof( RequestParam ) );
        RtlZeroMemory( &ReplyParam, sizeof( ReplyParam ) );


        //
        // Set up request
        //
        RequestParam.V1.ServerDN = ServerDN;
        RequestParam.V1.DomainDN = DomainDN;
        RequestParam.V1.fCommit  = fCommit;

        //
        // Call the server
        //
        WinError = _IDL_DRSRemoveDsServer( ((BindState *) hDs)->hDrs,
                                          dwInVersion,
                                         &RequestParam,
                                         &dwOutVersion,
                                         &ReplyParam );

        if ( ERROR_SUCCESS == WinError )
        {
            if ( 1 != dwOutVersion )
            {
                WinError = RPC_S_INVALID_VERS_OPTION;
            }
            else
            {
                //
                // Extract results
                //
                if ( fLastDcInDomain )
                {
                    *fLastDcInDomain = (BOOL)ReplyParam.V1.fLastDcInDomain;
                }

            }
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {

        WinError = RpcExceptionCode(); 
	HandleClientRpcException(WinError, &hDs);

    }

    MAP_SECURITY_PACKAGE_ERROR( WinError );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsRemoveDsServer]"));
    DSLOG((0,"[SV=%ws][DN=%ws][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           ServerDN, 
           DomainDN ? DomainDN : L"NULL", 
           fCommit, startTime, GetTickCount(), WinError))

    return( WinError );
}


DWORD
DsRemoveDsServerA(
    HANDLE  hDs,              // in
    LPSTR   ServerDN,         // in
    LPSTR   DomainDN,         // in,  optional
    BOOL   *fLastDcInDomain,  // out, optional
    BOOL    fCommit           // in
    )
/*++

Routine Description:

    This function is an ANSI wrapper for DsRemoveDsServerW.  

Arguments:

Return Value:

--*/
{
    DWORD WinError;
    ULONG Size, Length;

    LPWSTR wcServerDN = NULL;
    LPWSTR wcDomainDN = NULL;

    if ( ServerDN )
    {
        Length = MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      ServerDN,
                                      -1,   // calculate length of ServerDN
                                      NULL,
                                      0 );

        if ( Length > 0 )
        {

            Size = (Length + 1) * sizeof( WCHAR );
            wcServerDN = (LPWSTR) LocalAlloc( LPTR, Size );
            if (!wcServerDN) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
                        
            Length = MultiByteToWideChar( CP_ACP,
                                          MB_PRECOMPOSED,
                                          ServerDN,
                                          -1,  // calculate length of ServerDN
                                          wcServerDN,
                                          Length + 1 );
        }

        if ( 0 == Length )
        {
            WinError = GetLastError();
            goto Cleanup;
        }

    }


    if ( DomainDN )
    {
        Length = MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      DomainDN,
                                      -1,   // calculate length of DomainDN
                                      NULL,
                                      0 );

        if ( Length > 0 )
        {

            Size = (Length + 1) * sizeof( WCHAR );
            wcDomainDN = (LPWSTR) LocalAlloc( LPTR, Size );
            if (!wcDomainDN) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

        
            Length = MultiByteToWideChar( CP_ACP,
                                          MB_PRECOMPOSED,
                                          DomainDN,
                                          -1,  // calculate length of DomainDN
                                          wcDomainDN,
                                          Length + 1 );
        }

        if ( 0 == Length )
        {
            WinError = GetLastError();
            goto Cleanup;
        }

    }

    WinError =  DsRemoveDsServerW( hDs,
                                   wcServerDN,
                                   wcDomainDN,
                                   fLastDcInDomain,
                                   fCommit );

    
Cleanup:

    if (wcServerDN) {
        LocalFree(wcServerDN);
    }
    if (wcDomainDN) {
        LocalFree(wcDomainDN);
    }
    return WinError;
}

DWORD
DsRemoveDsDomainW(
    HANDLE  hDs,               // in
    LPWSTR  DomainDN           // in
    )
/*++

Routine Description:

    This routine removes all traces of the domain naming context specified
    by DomainDN from the global area of the directory service (configuration
    container). 

Arguments:

    hDs            : a valid handle returned from DsBind
    
    DomainDN       : a null terminated string of a domain to be removed
    
Return Value:

    DS_ERR_CANT_DELETE:          can't delete the domain object as there
                                 are still servers (dc's) that host that domain
                                 
--*/
{
    DWORD WinError;

    DRS_MSG_RMDMNREQ   RequestParam;
    DRS_MSG_RMDMNREPLY ReplyParam;
    DWORD              dwInVersion = 1;
    DWORD              dwOutVersion = 0;
#if DBG
    DWORD               startTime = GetTickCount();
#endif

    //
    // Parameter check
    //
    if ( (NULL == hDs) 
      || (NULL == DomainDN) 
      || (0    == wcslen( DomainDN )) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First see if this function is exported
    //
    if ( !IS_DRS_REMOVEAPI_SUPPORTED( ((BindState *) hDs)->pServerExtensions ) )
    {
        return RPC_S_CANNOT_SUPPORT;
    }


    __try
    {

        RtlZeroMemory( &RequestParam, sizeof( RequestParam ) );
        RtlZeroMemory( &ReplyParam, sizeof( ReplyParam ) );

        //
        // Set up request
        //
        RequestParam.V1.DomainDN = DomainDN;

        //
        // Call the server
        //
        WinError = _IDL_DRSRemoveDsDomain( ((BindState *) hDs)->hDrs,
                                           dwInVersion,
                                          &RequestParam,
                                          &dwOutVersion,
                                          &ReplyParam );

        if ( ERROR_SUCCESS != WinError )
        {
            if ( 1 != dwOutVersion )
            {
                WinError = RPC_S_INVALID_VERS_OPTION;
            }
            else
            {
                //
                // There are not out parameters in version 1
                //
                NOTHING;
            }
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
	WinError = RpcExceptionCode(); 
	HandleClientRpcException(WinError, &hDs); 
    }

    MAP_SECURITY_PACKAGE_ERROR( WinError );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsRemoveDsDomain]"));
    DSLOG((0,"[DN=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           DomainDN, startTime, GetTickCount(), WinError))

    return( WinError );
}

DWORD
DsRemoveDsDomainA(
    HANDLE  hDs,               // in
    LPSTR   DomainDN           // in
    )
/*++

Routine Description:

    This function is an ansi wrapper for DsRemoveDsDomainW.

Arguments:

Return Value:

--*/
{

    DWORD WinError;
    ULONG Size, Length;

    LPWSTR wcDomainDN = NULL;

    if ( (NULL == hDs) 
      || (NULL == DomainDN) 
      || (0    == strlen( DomainDN )) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Length = MultiByteToWideChar( CP_ACP,
                                  MB_PRECOMPOSED,
                                  DomainDN,
                                  -1,   // calculate length of DomainDN
                                  NULL,
                                  0 );

    if ( Length > 0 )
    {

        Size = (Length + 1) * sizeof( WCHAR );
        wcDomainDN = (LPWSTR) LocalAlloc( LPTR, Size );
        if (!wcDomainDN) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

    
        Length = MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      DomainDN,
                                      -1,  // calculate length of DomainDN
                                      wcDomainDN,
                                      Length + 1 );
    }

    if ( 0 == Length )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    WinError =  DsRemoveDsDomainW( hDs,
                                   wcDomainDN );

    
Cleanup:
    if (wcDomainDN) {
        LocalFree(wcDomainDN);
    }
    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\parsedn.c ===
/*++

Copyright (c) 1987-1997 Microsoft Corporation

Module Name:

    parsedn.c

Abstract:

    This file is a superset of ds\src\ntdsa\src\parsedn.c by virtue
    of #include of the aforementioned source file.  The idea is that
    the ntdsapi.dll client needs to do some client side DN parsing and
    we do not want to duplicate the code.  And build.exe won't find
    files any other place than in the directory being built or the
    immediate parent directory.

    This file additionally defines some no-op functions which otherwise
    would result in unresolved external references.

Author:

    Dave Straube    (davestr)   26-Oct-97

Revision History:

    Dave Straube    (davestr)   26-Oct-97
        Genesis  - #include of src\dsamain\src\parsedn.c and no-op DoAssert().

    Brett Shirley   (brettsh)   18-Jun-2001
        Modification to seperate library.  Moved this file and turned it into
        the parsedn.lib library.  See primary comment below.
--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <debug.h>
#include <strsafe.h>

//
// On 28-Jun-2001 the main part of this file was moved to util/parsedn/parsedn.c
// to provide a seperate statically linkeable library for the various string
// only DN parsing functions (like CountNameParts, NameMatched, TrimDSNameBy, 
// etc).
//
// This file was maintained, because the new library that was created has
// calls to DoAssert() that will need linking in the ntdsapi.dll.  This DoAssert
// satisfys that requirement.  Other binaries generally link to the DoAssert()
// in the dsdebug.lib library.
//

// Provide stubs for what would otherwise be unresolved externals.

void 
DoAssert(
    char    *szExp, 
    DWORD    dwDSID,
    char    *szFile)
{
    char    *msg;
    ULONG   cbMsg;
    char    *format = "\n*** Assertion failed: %s\n*** File: %s, line: %ld\n";
    HWND    hWindow;
    DWORD   hr;

#if DBG

    // Emit message at debugger and put up a message box.  Developer
    // can attach to client process before selecting 'OK' if he wants
    // to debug the problem.

#ifndef WIN95
    DbgPrint(format, szExp, szFile, (dwDSID & DSID_MASK_LINE));
    DbgBreakPoint();
#endif

    cbMsg = strlen(szExp) + strlen(szFile) + strlen(format) + 10;
    msg = LocalAlloc(NONZEROLPTR,cbMsg);
    if (msg) {
       hr = StringCbPrintf(msg, cbMsg, format, szExp, szFile, (dwDSID & DSID_MASK_LINE));
    }
    
    
    if ( NULL != (hWindow = GetFocus()) )
    {
        MessageBox(
            hWindow, 
            (!msg||hr)?"EMERGENCY DEBUG ASSERT, CHECK PARSEDN.C\n":msg, 
            "Assert in NTDSAPI.DLL", 
            MB_APPLMODAL | MB_DEFAULT_DESKTOP_ONLY | MB_OK | MB_SETFOREGROUND);
    }
    if (msg) {
        LocalFree(msg);
    }
        
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\schguid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    schguid.c

Abstract:

    Implementation of DsMapSchemaGuid APIs.

Author:

    DaveStr     19-May-98

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <util.h>           // OFFSET macro
#include <msrpc.h>          // DS RPC definitions
#include <stdio.h>          // sprintf, etc.
#include <ntdsapip.h>       // DS_LIST_* definitions

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Typedefs and such                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

typedef struct {
    VOID                *pDsNameResult;
    DS_SCHEMA_GUID_MAPW map[1];
} PrivateMapW;

#define PrivateMapFromMapW(p)                                           \
    ((PrivateMapW *) (((CHAR *) pMap) - OFFSET(PrivateMapW, map[0])))

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeSchemaGuidMap                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeSchemaGuidMapW(
    DS_SCHEMA_GUID_MAPW *pMap
    )
{
    PrivateMapW *pPrivateMap;
    
    if ( pMap )
    {
        pPrivateMap = PrivateMapFromMapW(pMap);
        DsFreeNameResultW(pPrivateMap->pDsNameResult);
        LocalFree(pPrivateMap);
    }
}

VOID
DsFreeSchemaGuidMapA(
    DS_SCHEMA_GUID_MAPA *pMap
    )
{
    DsFreeSchemaGuidMapW((DS_SCHEMA_GUID_MAPW *) pMap);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// PrivateGuidStatusToPublicGuidStatus                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
PrivateGuidStatusToPublicGuidStatus(
    DWORD   privateStatus,
    DWORD   *pPublicStatus
    )
{
    switch ( privateStatus )
    {
    case DS_NAME_ERROR_SCHEMA_GUID_ATTR:

        *pPublicStatus = DS_SCHEMA_GUID_ATTR;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_ATTR_SET:
    
        *pPublicStatus = DS_SCHEMA_GUID_ATTR_SET;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_CLASS:
    
        *pPublicStatus = DS_SCHEMA_GUID_CLASS;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_CONTROL_RIGHT:
    
        *pPublicStatus = DS_SCHEMA_GUID_CONTROL_RIGHT;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND:
    default:

        *pPublicStatus = DS_SCHEMA_GUID_NOT_FOUND;
        break;
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsMapSchemaGuidsCommon                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsMapSchemaGuidsCommon(
    BOOL                    fUnicode,       // in
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPW     **ppGuidMapW    // out
    )

/*++

  Routine Description:

    Common routine for DsMapSchemaGuids.

  Parameters:

    Same as DsMapSchemaGuids plus fUnicode flag.

  Return Values:

    Same as DsMapSchemaGuids.

--*/
{
    DWORD           i;
    PWCHAR          *rpNames = NULL;
    DWORD           dwErr = ERROR_SUCCESS;
    DS_NAME_RESULTW *pResultW = NULL;
    DWORD           cBytes;
    PrivateMapW     *pPrivateMapW = NULL;

    // Reject invalid parameters.

    if ( !hDs || !cGuids || !rGuids || !ppGuidMapW )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppGuidMapW = NULL;

    // String-ize the GUIDs.

    rpNames = (PWCHAR *) LocalAlloc(LPTR, cGuids * sizeof(PWCHAR));

    if ( !rpNames )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    for ( i = 0; i < cGuids; i++ )
    {
        rpNames[i] = (PWCHAR) LocalAlloc(LPTR, 40 * sizeof(WCHAR));

        if ( !rpNames[i] )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if ( fUnicode )
        {
            swprintf(
                rpNames[i],
                L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                rGuids[i].Data1,    rGuids[i].Data2,        rGuids[i].Data3,
                rGuids[i].Data4[0], rGuids[i].Data4[1],     rGuids[i].Data4[2],
                rGuids[i].Data4[3], rGuids[i].Data4[4],     rGuids[i].Data4[5],
                rGuids[i].Data4[6], rGuids[i].Data4[7]);
        }
        else
        {
            sprintf(
                (CHAR *) rpNames[i],
                "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                rGuids[i].Data1,    rGuids[i].Data2,        rGuids[i].Data3,
                rGuids[i].Data4[0], rGuids[i].Data4[1],     rGuids[i].Data4[2],
                rGuids[i].Data4[3], rGuids[i].Data4[4],     rGuids[i].Data4[5],
                rGuids[i].Data4[6], rGuids[i].Data4[7]);
        }
    }

    // Call DsCrackNames with the right private formatOffered value.
    
    if ( fUnicode )
    {
        dwErr = DsCrackNamesW(  hDs,
                                DS_NAME_NO_FLAGS,
                                DS_MAP_SCHEMA_GUID,
                                DS_DISPLAY_NAME,
                                cGuids,
                                rpNames,
                                &pResultW);
    }
    else
    {
        dwErr = DsCrackNamesA(  hDs,
                                DS_NAME_NO_FLAGS,
                                DS_MAP_SCHEMA_GUID,
                                DS_DISPLAY_NAME,
                                cGuids,
                                (PCHAR *) rpNames,
                                (PDS_NAME_RESULTA *) &pResultW);
    }

    if (    dwErr
         || (NULL == pResultW)
         || (0 == pResultW->cItems)
         || (NULL == pResultW->rItems) )
    {
        if ( !dwErr )
        {
            dwErr = ERROR_DS_OPERATIONS_ERROR;
        }

        goto ErrorExit;
    }

    // Morph DsCrackNames result into DS_SCHEMA_GUID_MAP.

    cBytes =   sizeof(PrivateMapW)
             + (cGuids * sizeof(DS_SCHEMA_GUID_MAPW));
    pPrivateMapW = (PrivateMapW *) LocalAlloc(LPTR, cBytes);

    if ( !pPrivateMapW )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    
    pPrivateMapW->pDsNameResult = pResultW;

    for ( i = 0; i < cGuids; i++ )
    {
        pPrivateMapW->map[i].guid = rGuids[i];
        PrivateGuidStatusToPublicGuidStatus(
                        pResultW->rItems[i].status,
                        &pPrivateMapW->map[i].guidType);
    
        if (    (DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND != 
                                            pPrivateMapW->map[i].guidType)
             && pResultW->rItems[i].pName )
        {
            pPrivateMapW->map[i].pName = pResultW->rItems[i].pName;
        }
    }

    // Now return address of DS_SCHEMA_GUID_MAP which DsFreeSchemaGuidMap
    // knows is an offset within PrivateMap.

    *ppGuidMapW = (DS_SCHEMA_GUID_MAPW *) &pPrivateMapW->map;

ErrorExit:

    if ( rpNames ) 
    {
        for ( i = 0; i < cGuids; i++ )
        {
            if ( rpNames[i] )
            {
                LocalFree(rpNames[i]);
            }
        }

        LocalFree(rpNames);
    }

    if ( dwErr && pResultW )
    {
        DsFreeNameResultW(pResultW);
    }

    if ( dwErr && pPrivateMapW )
    {
        LocalFree(pPrivateMapW);
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsMapSchemaGuids{A|W}                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsMapSchemaGuidsA(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPA     **ppGuidMap     // out
    )
{
    return( DsMapSchemaGuidsCommon( FALSE,
                                    hDs,
                                    cGuids,
                                    rGuids,
                                    (DS_SCHEMA_GUID_MAPW **) ppGuidMap));
}

DWORD
DsMapSchemaGuidsW(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPW     **ppGuidMap     // out
    )
{
    return( DsMapSchemaGuidsCommon( TRUE,
                                    hDs,
                                    cGuids,
                                    rGuids,
                                    ppGuidMap));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\siteinfo-postxp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    siteinfo.c

Abstract:

    Implementation of site/server/domain info APIs.

Author:

    DaveStr     06-Apr-98

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <rpc.h>            // RPC defines
#include <ntdsapi.h>        // CrackNam apis
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState

#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <msrpc.h>          // DS RPC definitions

#include <ntdsa.h>          // GetRDNInfo
#include <scache.h>         // req'd for mdlocal.h
#include <dbglobal.h>       // req'd for mdlocal.h
#include <mdglobal.h>       // req'd for mdlocal.h
#include <mdlocal.h>        // CountNameParts
#include <attids.h>         // ATT_DOMAIN_COMPONENT
#include <ntdsapip.h>       // DS_LIST_* definitions

#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include "util.h"           // HandleClientRpcException

#define FILENO   FILENO_NTDSAPI_SITEINFO_POSTXP
#include "dsdebug.h"

#if DBG
#include <stdio.h>          // printf for debugging
#endif

typedef DWORD (*DSQUERYSITESBYCOSTW)(HANDLE,LPWSTR,LPWSTR*,DWORD,DWORD,PDS_SITE_COST_INFO *);
typedef DWORD (*DSQUERYSITESBYCOSTA)(HANDLE,LPSTR, LPSTR*,DWORD,DWORD,PDS_SITE_COST_INFO *);
typedef VOID  (*DSQUERYSITESFREE)(PDS_SITE_COST_INFO);

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsQuerySitesByCostW                                                  //
//                                                                      //
// Description:                                                         //
//                                                                      //
// DsQuerySitesByCost uses the hDS binding handle to execute a query on //
// the bound domain controller. The query determines the shortest-path  //
// distance from pszFromSite to each of the sites specified in the      //
// rgszToSites array.                                                   //
//                                                                      //
// Parameters:                                                          //
//                                                                      //
//  hDS:            A binding handle obtained from a successful         //
//                  call to DsBindToISTG().                             //
//  pwszFromSite:   A string containing the RDN of a site.              //
//  rgwszToSites:   An array of strings each containing site RDNs.      //
//  cToSites:       The length of the array rgszToSites.                //
//  dwFlags:        Currently unused. For now, should be 0.             //
//  prgSiteInfo:    Upon successful completion, this array will         //
//                  contain either an error code or a cost for every    //
//                  entry in the ToSites array.                         //
//                                                                      //
// Preconditions:                                                       //
//                                                                      //
//  hDS should be a valid binding handle.                               //
//  pszFromSite should not be NULL.                                     //
//  rgszToSites should not be NULL and should not contain any NULL      //
//  strings.                                                            //
//  prgSiteInfo should be the address of a SiteInfo pointer, to be      //
//  filled in by this function.                                         //
//                                                                      //
// Postconditions:                                                      //
//                                                                      //
//  The prgSiteInfo array has the same length as the rgszToSites array. //
//  Furthermore, the elements of the array are in direct correspondence //
//  so that the i'th entry in the prgSiteInfo array gives the cost from //
//  pszFromSite to rgszToSites[i].                                      //
//                                                                      //
// Notes:                                                               //
//                                                                      //
//  Only Whistler RC1 DCs and higher support the server-side of this    //
//  API. DsBindToISTG() should be used to create the binding handle     //
//  in order to attempt to find a Whistler DC. Even if DsBindToISTG()   //
//  is used, it is possible that the server will not support the API    //
//  or refuse to execute the query if it does not believe it is an ISTG //
//                                                                      //
// Failures:                                                            //
//                                                                      //
//  Various RPC & DS errors. Numerous failure scenarios are enumerated  //
//  in the design document for this API.                                //
//                                                                      //
//  Individual error codes can also be returned for each entry in the   //
//  SiteInfo. This allows callers to determine why the cost could not   //
//  be returned for a particular site.                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsQuerySitesByCostW(
    HANDLE              hDS,            // in
    LPWSTR              pwszFromSite,   // in
    LPWSTR             *rgwszToSites,   // in
    DWORD               cToSites,       // in
    DWORD               dwFlags,        // in
    PDS_SITE_COST_INFO *prgSiteInfo     // out
    )
{
    DRS_MSG_QUERYSITESREQ   request;
    DRS_MSG_QUERYSITESREPLY reply;
    DWORD                   iSite, dwOutVersion, err=0;

#ifdef _NTDSAPI_POSTXP_ASLIB_
    {
        // See if the real ntdsapi routine exists, if so use it.
        HMODULE hNtdsapiDll = NULL;
        VOID * pvFunc = NULL;

        hNtdsapiDll = NtdsapiLoadLibraryHelper(L"ntdsapi.dll");
        if (hNtdsapiDll) {
            pvFunc = GetProcAddress(hNtdsapiDll, "DsQuerySitesByCostW");
            if (pvFunc) {
                err = ((DSQUERYSITESBYCOSTW)pvFunc)(hDS, pwszFromSite, rgwszToSites, cToSites, dwFlags, prgSiteInfo);
                FreeLibrary(hNtdsapiDll);
                return(err);
            } 
            FreeLibrary(hNtdsapiDll);
        }
        // else fall through and use the client side below ...
    }
#endif

    // Initialize the results
    *prgSiteInfo = NULL;

    // Initialize local variables
    memset( &request, 0, sizeof(request) );

    // Check parameters. These are checked server-side as well.
    if( NULL==hDS || NULL==pwszFromSite || NULL==rgwszToSites || cToSites<1 ) {
        err = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    for( iSite=0; iSite<cToSites; iSite++ ) {
        if( NULL==rgwszToSites[iSite] ) {
            err = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    // Check if the server supports QuerySites. If not bail out. There is a possibility
    // that the server will not support the call even if the extension bit is not
    // present (Whistler Beta 3 DCs, for example).
    if( !IS_DRS_QUERYSITESBYCOST_V1_SUPPORTED( ((BindState*)hDS)->pServerExtensions) ) {
        err = ERROR_CALL_NOT_IMPLEMENTED;
        goto Cleanup;
    }

    // Create the request structure
    request.V1.pwszFromSite = pwszFromSite;
    request.V1.cToSites = cToSites;
    request.V1.rgszToSites = rgwszToSites;
    request.V1.dwFlags = dwFlags;

    // Initialize the results. Must clear the reply structure here otherwise
    // RPC will assume that we have pre-allocated the structure for it.
    memset( &reply, 0, sizeof(DRS_MSG_QUERYSITESREPLY) );
    
    __try {
        
        err = _IDL_DRSQuerySitesByCost(
                    ((BindState*) hDS)->hDrs,
                    1,
                    &request,
                    &dwOutVersion,
                    &reply);

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        
        err = RpcExceptionCode();
        HandleClientRpcException(err, &hDS);
        
    }

    MAP_SECURITY_PACKAGE_ERROR( err );

    // On success, return results.
    if( ERROR_SUCCESS==err ) {
        *prgSiteInfo = (PDS_SITE_COST_INFO) reply.V1.rgCostInfo;
    }

Cleanup:

    // Note: The only part of the reply that allocated any memory was the
    // site info array. Since we're returning that information to the
    // caller anyways, we can just free it in DsQuerySitesFree().

    return err;
}


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsQuerySitesByCostA                                                  //
//                                                                      //
// ASCII wrapper for DsQuerySitesByCostA                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsQuerySitesByCostA(
    HANDLE              hDS,            // in
    LPSTR               pszFromSite,    // in
    LPSTR              *rgszToSites,    // in
    DWORD               cToSites,       // in
    DWORD               dwFlags,        // in
    PDS_SITE_COST_INFO *prgSiteInfo     // out
    )
{
    DWORD       dwErr=NO_ERROR, iSite;
    WCHAR       *pwszFromSite = NULL;
    LPWSTR      *rgwszToSites = NULL;
    int         cChar;

#ifdef _NTDSAPI_POSTXP_ASLIB_
    {
        // See if the real ntdsapi routine exists, if so use it.
        HMODULE hNtdsapiDll = NULL;
        VOID * pvFunc = NULL;
        DWORD err;

        hNtdsapiDll = NtdsapiLoadLibraryHelper(L"ntdsapi.dll");
        if (hNtdsapiDll) {
            pvFunc = GetProcAddress(hNtdsapiDll, "DsQuerySitesByCostA");
            if (pvFunc) {
                err = ((DSQUERYSITESBYCOSTA)pvFunc)(hDS, pszFromSite, rgszToSites, cToSites, dwFlags, prgSiteInfo);
                FreeLibrary(hNtdsapiDll);
                return(err);
            } 
            FreeLibrary(hNtdsapiDll);
        }
        // else fall through and use the client side below ...
    }
#endif

    __try
    {
        // Check parameters. These are checked server-side as well.
        if( NULL==hDS || NULL==pszFromSite || NULL==rgszToSites || cToSites<1 ) {
            dwErr = ERROR_INVALID_PARAMETER;
            __leave;
        }
        for( iSite=0; iSite<cToSites; iSite++ ) {
            if( NULL==rgszToSites[iSite] ) {
                dwErr = ERROR_INVALID_PARAMETER;
                __leave;
            }
        }
        *prgSiteInfo = NULL;

        // Convert From Site name to Unicode
        dwErr = AllocConvertWide( pszFromSite, &pwszFromSite );
        if( ERROR_SUCCESS!=dwErr ) {
            __leave;
        }

        // Allocate the array of Unicode To Site names
        rgwszToSites = LocalAlloc( LPTR, cToSites*sizeof(LPWSTR) );
        memset( rgwszToSites, 0, cToSites*sizeof(LPWSTR) );
        if( NULL==rgwszToSites ) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        // Convert the individual To Site names to Unicode
        for( iSite=0; iSite<cToSites; iSite++ ) {
            dwErr = AllocConvertWide( rgszToSites[iSite], &rgwszToSites[iSite] );
            if( ERROR_SUCCESS!=dwErr ) {
                __leave;
            }
        }

        // Call Unicode API
        dwErr = DsQuerySitesByCostW(
                    hDS,
                    pwszFromSite,
                    rgwszToSites,
                    cToSites,
                    dwFlags,
                    prgSiteInfo);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    // Cleanup code
    if( NULL!=rgwszToSites ) {
        for( iSite=0; iSite<cToSites; iSite++ ) {
            if( NULL!=rgwszToSites[iSite] ) {
                LocalFree( rgwszToSites[iSite] );
            }
        }
        LocalFree( rgwszToSites );
    }

    if( NULL!=pwszFromSite ) {
        LocalFree( pwszFromSite );
    }

    return(dwErr);
}


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsQuerySitesFree                                                     //
//                                                                      //
// Free the site info array returned from DsQuerySitesByCost.           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsQuerySitesFree(
    PDS_SITE_COST_INFO  rgSiteInfo
    )
{
#ifdef _NTDSAPI_POSTXP_ASLIB_
    {
        // See if the real ntdsapi routine exists, if so use it.
        HMODULE hNtdsapiDll = NULL;
        VOID * pvFunc = NULL;
        DWORD err;

        hNtdsapiDll = NtdsapiLoadLibraryHelper(L"ntdsapi.dll");
        if (hNtdsapiDll) {
            pvFunc = GetProcAddress(hNtdsapiDll, "DsQuerySitesFree");
            if (pvFunc) {
                ((DSQUERYSITESFREE)pvFunc)(rgSiteInfo);
                FreeLibrary(hNtdsapiDll);
                return;
            } 
            FreeLibrary(hNtdsapiDll);
        }
        // else fall through and use the client side below ...
    }
#endif
    
    if( NULL!=rgSiteInfo ) {
        MIDL_user_free( rgSiteInfo );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\tlog.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tlog.h

Abstract:

    Routines dealing with ds logging


Environment:

    User Mode - Win32

--*/

#ifndef __TLOG_H__
#define __TLOG_H__

// DsLogEntry is supported on chk'ed builds of w2k or greater
#if DBG && !WIN95 && !WINNT4

VOID InitDsLog(VOID);
VOID TermDsLog(VOID);
#define INITDSLOG() InitDsLog()
#define TERMDSLOG() TermDsLog()

#else DBG && !WIN95 && !WINNT4

#define INITDSLOG()
#define TERMDSLOG()

#endif DBG && !WIN95 && !WINNT4

#endif __TLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\util.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.c

Abstract:

   Common utility routines
   For internal use inside ntdsapi.dll
   DO NOT EXPOSE IN NTDSAPI.DEF

Author:

    Will Lees (wlees) 02-Feb-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock.h>
#include <winerror.h>
#include <rpc.h>            // RPC defines
#include <stdlib.h>         // atoi, itoa
#include <dsdebug.h>

#include <drs.h>            // wire function prototypes
#include <bind.h>           // BindState

#include <drserr.h>         // DRS error codes
#define DEFS_ONLY
#include <draatt.h>         // Dra option flags for replication
#undef DEFS_ONLY

#include "util.h"           // ntdsapi utility functions

#if DBG
#include <stdio.h>          // printf for debugging
#endif

/* External */

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

/* Static */

static LONG WinSockInitialized = FALSE;

/* Forward */ /* Generated by Emacs 19.34.1 on Wed Oct 07 16:18:49 1998 */

DWORD
InitializeWinsockIfNeeded(
    VOID
    );

VOID
TerminateWinsockIfNeeded(
    VOID
    );

DWORD
AllocConvertNarrow(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocConvertNarrowUTF8(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

static DWORD
allocConvertNarrowCodePage(
    IN DWORD CodePage,
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocConvertWide(
    IN LPCSTR StringA,
    OUT LPWSTR *pStringW
    );

DWORD
AllocConvertWideBuffer(
    IN  DWORD   LengthA,
    IN  PCCH    BufferA,
    OUT PWCHAR  *OutBufferW
    );

DWORD
AllocBuildDsname(
    IN LPCWSTR StringDn,
    OUT DSNAME **ppName
    );

DWORD
ConvertScheduleToReplTimes(
    PSCHEDULE pSchedule,
    REPLTIMES *pReplTimes
    );

/* End Forward */


DWORD
InitializeWinsockIfNeeded(
    VOID
    )

/*++

Routine Description:

Initialize winsock dll if not initialized already.
Moved here from dllEntry because of dll ordering problems.

Arguments:

    VOID -

Return Value:

    DWORD -

--*/

{
    WSADATA wsaData;
    DWORD status;
    LONG oldValue;

#ifndef WIN95
    // Compare the synchonization variable against FALSE
    // If it is FALSE, set it to TRUE and return FALSE
    // If it is TRUE, return TRUE
    oldValue = InterlockedCompareExchange(
        &WinSockInitialized,       // Destination
        TRUE,                      // Exchange
        FALSE                      // Comperand
        );

    // If already initialized, no need to call startup
    if (oldValue == TRUE) {
        return ERROR_SUCCESS;
    }
#else
    if (WinSockInitialized == FALSE) {
        WinSockInitialized = TRUE;
    } else {
        return ERROR_SUCCESS;
    }
#endif

    // Initialize winsock
    // Look for Winsock 1.1 because that is the default on win95
    status = WSAStartup(MAKEWORD(1,1),&wsaData);
    if (status != 0) {
#ifndef WIN95
        DbgPrint( "ntdsapi: WSAStartup failed %d\n", status );
#else
        NULL;
#endif
        // Clear initialized flag on failure
#ifndef WIN95
        InterlockedExchange(
            &WinSockInitialized,   // Target
            FALSE                   // Value
            );
#else
        WinSockInitialized = FALSE;
#endif
    }

    return status;
} /* InitializeWinsockIfNeeded */


VOID
TerminateWinsockIfNeeded(
    VOID
    )

/*++

Routine Description:

Terminate winsock dll if initialized.
Moved here from dllEntry because of dll ordering problems.

Arguments:

    VOID -

Return Value:

    DWORD -

--*/

{
    WSADATA wsaData;
    DWORD status;
    LONG oldValue;

#ifndef WIN95
    // Compare the synchonization variable against TRUE
    // If it is TRUE, set it to FALSE and return TRUE
    // If it is FALSE, return FALSE
    oldValue = InterlockedCompareExchange(
        &WinSockInitialized,       // Destination
        FALSE,                     // Exchange
        TRUE                       // Comperand
        );

    // If not initialized, no need to clean up
    if (oldValue == FALSE) {
        return;
    }
#else
    if (WinSockInitialized == TRUE) {
        WinSockInitialized = FALSE;
    } else {
        return;
    }
#endif

    // Cleanup winsock
    WSACleanup();

} /* TerminateWinsockIfNeeded */


DWORD
AllocConvertNarrow(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    )

/*++

Routine Description:

Helper routine to convert a wide string to a newly allocated narrow one

Arguments:

    StringW -
    pStringA -

Return Value:

    DWORD -

--*/

{
    return allocConvertNarrowCodePage( CP_ACP, StringW, pStringA );
}


DWORD
AllocConvertNarrowUTF8(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    )

/*++

Routine Description:

Helper routine to convert a wide string to a newly allocated narrow one

Arguments:

    StringW -
    pStringA -

Return Value:

    DWORD -

--*/

{
    return allocConvertNarrowCodePage( CP_UTF8, StringW, pStringA );
}


static DWORD
allocConvertNarrowCodePage(
    IN DWORD CodePage,
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    )

/*++

Routine Description:

Helper routine to convert a wide string to a newly allocated narrow one

Arguments:

    StringW -
    pStringA -

Return Value:

    DWORD -

--*/

{
    DWORD numberNarrowChars, numberConvertedChars, status;
    LPSTR stringA;

    if (pStringA == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (StringW == NULL) {
        *pStringA = NULL;
        return ERROR_SUCCESS;
    }

    // Get the needed length
    numberNarrowChars = WideCharToMultiByte(
        CodePage,
        0,
        StringW,              // input buffer
        -1,                   // null terminated
        NULL,                 // output buffer
        0,                    // output length
        NULL,                 // default char
        NULL                  // default used
        );

    if (numberNarrowChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the new buffer
    stringA = LocalAlloc( LPTR, (numberNarrowChars + 1) * sizeof( CHAR ) );
    if (stringA == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Do the conversion into the new buffer
    numberConvertedChars = WideCharToMultiByte(
        CodePage,
        0,
        StringW,         //input
        -1,
        stringA,         // output
        numberNarrowChars + 1,
        NULL,            // default char
        NULL             // default used
        );
    if (numberConvertedChars == 0) {
        LocalFree( stringA );
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *pStringA = stringA;

    return ERROR_SUCCESS;
} /* allocConvertNarrow */


DWORD
AllocConvertWide(
    IN LPCSTR StringA,
    OUT LPWSTR *pStringW
    )

/*++

Routine Description:

Helper routine to convert a narrow string to a newly allocated wide one

Arguments:

    StringA -
    pStringW -

Return Value:

    DWORD -

--*/

{
    DWORD numberWideChars, numberConvertedChars, status;
    LPWSTR stringW;

    if (pStringW == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (StringA == NULL) {
        *pStringW = NULL;
        return ERROR_SUCCESS;
    }

    // Get the needed length
    numberWideChars = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        StringA,
        -1,
        NULL,
        0);

    if (numberWideChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the new buffer
    stringW = LocalAlloc( LPTR, (numberWideChars + 1) * sizeof( WCHAR ) );
    if (stringW == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Do the conversion into the new buffer
    numberConvertedChars = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        StringA,
        -1,
        stringW,
        numberWideChars + 1);
    if (numberConvertedChars == 0) {
        LocalFree( stringW );
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *pStringW = stringW;

    return ERROR_SUCCESS;
} /* allocConvertWide */


DWORD
AllocConvertWideBuffer(
    IN  DWORD   LengthA,
    IN  PCCH    BufferA,
    OUT PWCHAR  *OutBufferW
    )

/*++

Routine Description:

    Converts narrow buffer to newly allocated wide one

Arguments:

    LengthA    - number of chars in BufferA
    BufferA    - Buffer of narrow chars
    OutBufferW - Address of buffer of wide chars

Return Value:

    Win32 Status

--*/
{
    DWORD   Status;
    DWORD   NumberWideChars;
    DWORD   ConvertedChars;
    PWCHAR  BufferW;

    //
    // no output buffer address; error
    //
    if (OutBufferW == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    *OutBufferW = NULL;

    //
    // No input buffer; return NULL
    //
    if (BufferA == NULL || LengthA == 0) {
        *OutBufferW = NULL;
        return ERROR_SUCCESS;
    }

    //
    // Get the needed length in chars
    //
    NumberWideChars = MultiByteToWideChar(CP_ACP,
                                          MB_PRECOMPOSED,
                                          BufferA,
                                          LengthA,
                                          NULL,
                                          0);

    if (NumberWideChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate the new buffer
    //
    BufferW = LocalAlloc(LPTR,
                         NumberWideChars * sizeof(WCHAR));
    if (BufferW == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Do the conversion into the new buffer
    //
    ConvertedChars = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         BufferA,
                                         LengthA,
                                         BufferW,
                                         NumberWideChars);
    if (ConvertedChars == 0) {
        LocalFree(BufferW);
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *OutBufferW = BufferW;

    return ERROR_SUCCESS;
} /* AllocConvertWideBuffer */


DWORD
AllocBuildDsname(
    IN LPCWSTR StringDn,
    OUT DSNAME **ppName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD length, dsnameBytes;
    DSNAME *pName;

    if (StringDn == NULL) {
        *ppName = NULL;
        return ERROR_SUCCESS;
    }

    length = wcslen( StringDn );
    dsnameBytes = DSNameSizeFromLen( length );

    pName = (DSNAME *) LocalAlloc( LPTR, dsnameBytes );
    if (pName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pName->NameLen = length;
    pName->structLen = dsnameBytes;
    wcscpy( pName->StringName, StringDn );

    *ppName = pName;

    return ERROR_SUCCESS;
}


DWORD
ConvertScheduleToReplTimes(
    PSCHEDULE pSchedule,
    REPLTIMES *pReplTimes
    )

/*++

Routine Description:

Convert a public SCHEDULE into a REPLTIMES structure.

The public schedule must be of INTERVAL type, and only contain one header.

The difference between the data in a public SCHEDULE and the data in a
REPLTIMES is that the former only uses 1 byte for each hour, with the high
nybble unused, while the latter encodes two hours in each byte.

Arguments:

    pSchedule -
    pReplTimes -

Return Value:

    DWORD -

--*/

{
    PUCHAR pData = (PUCHAR) (pSchedule + 1);  // point just after structure
    DWORD hour;

    if ( (pSchedule == NULL) ||
         (pReplTimes == NULL) ||
         (pSchedule->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES) ||
         (pSchedule->NumberOfSchedules != 1) ||
         (pSchedule->Schedules[0].Type != SCHEDULE_INTERVAL) ||
         (pSchedule->Schedules[0].Offset != sizeof( SCHEDULE ) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour += 2 ) {
        pReplTimes->rgTimes[hour/2] =
            (UCHAR) (((pData[hour + 1] & 0xf) << 4) | (pData[hour] & 0xf));
    }

    return ERROR_SUCCESS;
} /* ConvertScheduleToReplTimes */

VOID
HandleClientRpcException(
    DWORD    dwErr,
    HANDLE * phDs
    )
/*++
Routine Description:
    
    Procedure to handle client rpc exceptions in ntdsapi.dll on calls to
    an ntdsa.dll rpc interface.
    
Arguments:
    
    dwErr - returned from RpcExceptionCode inside an exception block.

Return Value:
    None.
    
Notes:
    
    GregJohn 6/12/01 - Eventually this function should be shared code with
    drsuapi.c so both client interfaces can share this logic(ie CHECK_RPC_SERVER_NOT_REACHABLE).  
    Also, we can put MAP_SECURITY_PACKAGE_ERROR in this function at that time.
--*/
{

    CHECK_RPC_SERVER_NOT_REACHABLE(*phDs, dwErr);
    DPRINT_RPC_EXTENDED_ERROR( dwErr ); 
}

#ifdef _NTDSAPI_POSTXP_ASLIB_

/*

Only, defined in ntdsapi_postxp_aslib.lib, because it's only needed there,
and I want to make sure that the actual ntdsapi.dll doesn't load this, because
if it were, you may be having a infinite circular recursion.  Basically, if
we're in the actual DLL, then you shouldn't need to call this function, because
any time you'd think of loading ntdsapi.dll you'd already be in the DLL.

*/

HMODULE 
NtdsapiLoadLibraryHelper(
    WCHAR * szDllName
    )
{
    HMODULE hDll = NULL;

    hDll = LoadLibraryW(szDllName);

    Assert(hDll || GetLastError());
    return hDll;    
}

#endif

/* end util.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\spn.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    spn.c

Abstract:

    Implementation of SPN API and helper functions.

    See \nt\public\specs\nt5\ds\spnapi.doc, by Paulle

    See comments in \nt\public\sdk\inc\ntdsapi.h

    Only one of the Spn Api's goes over the wire: DsWriteAccountSpn

    The Spn functions are spread out over a number of directories:

nt\public\sdk\inc\ntdsapi.h - api header file

ds\src\test\spn\testspn.c - unit test
ds\src\ntdsapi\spn.c - client side spn functions
ds\src\ntdsapi\drs_c.c - client stub

ds\src\dsamain\drsserv\drs_s.c - server stub
ds\src\dsamain\dra\ntdsapi.c - server rpc entry points for ntdsapi functions
ds\src\dsamain\dra\spnop.c - ntdsa core functions to do the work

    The APIs are:

    DsMakeSpn{A,W}
    DsGetSpn{A,W}
    DsFreeSpnArray{A,W}
    DSCrackSpn{A,W}
    DSWriteAccountSpn{A,W}

    DsClientMakeSpnForTargetServer{A,W}
    DsServerRegisterSpn{A,W}

Author:

    Wlees     19-Jan-1998

    The guts of DsServerRegisterSpn was written by RichardW

Environment:

    User Mode - Win32

Revision History:

    Aug 11, 1998  wlees  Added DsClientMakeSpnForTargetServer and
                         DsServerRegisterSpn

--*/

#define UNICODE 1

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <winsock.h>        // Use V1.1, since that is default on Win95
#include <rpc.h>            // RPC defines

#define SECURITY_WIN32      // Who should set this, and to what?
#include <security.h>       // GetComputerNameEx
#include <sspi.h>
#include <secext.h>
#include <lm.h>             // Netp functions

#include <stdlib.h>         // atoi, itoa

#include <dsgetdc.h>        // DsGetDcName()
#include <ntdsapi.h>        // CrackNam apis
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include <dststlog.h>       // DSLOG

#include "util.h"        // ntdsapi private routines

#include <dsdebug.h>
#include <stdio.h>          // printf for debugging

#include <fileno.h>
#define FILENO  FILENO_NTDSAPI_SPN

// Max size for a computer dist name

#define MAX_COMPUTER_DN 1024

// Max size for an IP address

#define MAX_IP_STRING 15

// Static

// Cannonical DNS names are recognized by their first component being a well-
// known constant.
// See Paulle for the RFC with the complete list
static LPWSTR WellKnownDnsPrefixes[] = {
    L"www.",
    L"ftp.",
    L"ldap."
};

#define NUMBER_ELEMENTS( A ) ( sizeof( A ) / sizeof( A[0] ) )

// Forward

static DWORD
allocBuildSpn(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCWSTR ServiceName,
    OUT LPWSTR *pSpn
    );

static BOOLEAN
isCanonicalDnsName(
    IN LPCWSTR DnsName
    );

DWORD
extractString(
    IN LPCWSTR Start,
    IN DWORD Length,
    IN DWORD *pSize,
    OUT LPWSTR Output
    );


NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
    )

/*++

Routine Description:

Convert arguments to wide and call DsClientMakeSpnForTargetServerW

Arguments:

    ServiceClass -
    ServerName -
    pcSpnLength -
    pszSpn -

Return Value:

    WINAPI -

--*/

{
    DWORD status, number, principalNameLength;
    LPWSTR serviceClassW = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR principalNameW = NULL;

    if ( (ServiceClass == NULL) ||
         (ServiceName == NULL) ||
         (pcSpnLength == NULL) ||
         ( (pszSpn == NULL) && (*pcSpnLength != 0) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = AllocConvertWide( ServiceName, &serviceNameW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    principalNameLength = *pcSpnLength;  // in characters
    if (principalNameLength) {
        principalNameW = LocalAlloc( LPTR,
                                     principalNameLength * sizeof( WCHAR ) );
        if (principalNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    status = DsClientMakeSpnForTargetServerW(
        serviceClassW,
        serviceNameW,
        &principalNameLength,
        principalNameW );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_BUFFER_OVERFLOW) {
            // return needed length
            *pcSpnLength = principalNameLength;
        }
        goto cleanup;
    }

    // Convert back to multi-byte
    number = WideCharToMultiByte(
        CP_ACP,
        0,                          // flags
        principalNameW,
        principalNameLength,        // length in characters
        (LPSTR) pszSpn,             // Caller's buffer
        *pcSpnLength,            // Caller's length
        NULL,                       // default char
        NULL                     // default used
        );
    if (number == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Return out parameter
    *pcSpnLength = number;

    status = ERROR_SUCCESS;

cleanup:

    if (serviceClassW != NULL) {
        LocalFree( serviceClassW );
    }

    if (serviceNameW != NULL) {
        LocalFree( serviceNameW );
    }

    if (principalNameW != NULL) {
        LocalFree( principalNameW );
    }

    return status;
} /* DsClientMakeSpnForTargetServerA */


NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
    )

/*++

Routine Description:

Constructs a Service Principal Name suitable to identify the desired server.
The service class and part of a dns hostname must be supplied.

This routine is a simplified wrapper to DsMakeSpn.
The ServiceName is made canonical by resolving through DNS.
Guid-based dns names are not supported.

The simplified SPN constructed looks like this:

ServiceClass / ServiceName / ServiceName

The instance name portion (2nd position) is always defaulted.  The port and
referrer fields are not used.

Arguments:

    ServiceClass - Class of service, defined by the service, can be any
        string unique to the service

    ServiceName - dns hostname, fully qualified or not
       Stringized IP address is also resolved if necessary

    pcSpnLength - IN, maximum length of buffer, in chars
                  OUT, space utilized, in chars, including terminator

    pszSpn - Buffer, atleast of length *pcSpnLength

Return Value:

    WINAPI -

--*/

{
    DWORD status, length;
    LPSTR serviceNameA = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR domainPart;
    struct hostent *pHostEntry = NULL;

    status = InitializeWinsockIfNeeded();
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if ( (NULL == ServiceClass) ||
         (NULL == ServiceName) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Treat netbios names like dns names, remove \\ prefix
    if (*ServiceName == L'\\') {
        ServiceName++;
        if (*ServiceName == L'\\') {
            ServiceName++;
        }
    }

    // Handle IP addresses too. Reverse to DNS.
    length = wcslen( ServiceName );
    if ( (length <= MAX_IP_STRING) && (iswdigit( *ServiceName )) ) {
        LONG ipAddress;

        status = AllocConvertNarrow( ServiceName, &serviceNameA );
        if (status) {
            goto cleanup;
        }

        ipAddress = inet_addr( serviceNameA );
        if (ipAddress != INADDR_NONE) {
            pHostEntry = gethostbyaddr( (char *)&ipAddress,sizeof( LONG ),AF_INET);
            if (pHostEntry) {
                status = AllocConvertWide( pHostEntry->h_name, &serviceNameW );
                if (status) {
                    goto cleanup;
                }
                ServiceName = serviceNameW;
            } else {
                // IP syntax was good, but could not be reverse translated
                status = ERROR_INCORRECT_ADDRESS;
                goto cleanup;
            }
        }
    }

    // Check for fully qualified DNS name.  If not, lookup in DNS
    domainPart = wcschr( ServiceName, L'.' );
    if (NULL == domainPart) {

        if (serviceNameA) {
            LocalFree( serviceNameA );
        }
        status = AllocConvertNarrow( ServiceName, &serviceNameA );
        if (status) {
            goto cleanup;
        }

        pHostEntry = gethostbyname( serviceNameA );
        if (pHostEntry) {
            if (serviceNameW) {
                LocalFree( serviceNameW );
            }

            status = AllocConvertWide( pHostEntry->h_name, &serviceNameW );
            if (status) {
                goto cleanup;
            }
            ServiceName = serviceNameW;

            domainPart = wcschr( ServiceName, L'.' );
        }
    }

    // Sanity check name
    if (NULL == domainPart) {
        status = ERROR_INVALID_DOMAINNAME;
        goto cleanup;
    }

    // Guid based names are not supported here
    // TODO: check for them

    status = DsMakeSpnW(
        ServiceClass,
        ServiceName,
        NULL,
        0,
        NULL,
        pcSpnLength,
        pszSpn );

cleanup:

    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (serviceNameA) {
        LocalFree( serviceNameA );
    }

    return status;

} /* DsMakeSpnForTargetServerW */


NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnA(
    DS_SPN_WRITE_OP Operation,
    IN LPCSTR ServiceClass,
    IN OPTIONAL LPCSTR UserObjectDN
    )

/*++

Routine Description:

   This function converts parameters to wide, and calls DsServerRegisterSpnW

Arguments:

    ServiceClass - unique string identifying service
    UserObjectDN - Optional, DN of user-class object to write SPN

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR serviceClassW = NULL;
    LPWSTR userObjectDNW = NULL;

    if (ServiceClass == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be NULL
    status = AllocConvertWide( UserObjectDN, &userObjectDNW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = DsServerRegisterSpnW(
        Operation,
        serviceClassW,
        userObjectDNW );

cleanup:

    if (serviceClassW != NULL) {
        LocalFree( serviceClassW );
    }

    if (userObjectDNW != NULL) {
        LocalFree( userObjectDNW );
    }

    return status;
} /* DsServerRegisterSpnA */


NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnW(
    DS_SPN_WRITE_OP Operation,
    IN LPCWSTR ServiceClass,
    IN OPTIONAL LPCWSTR UserObjectDN
    )

/*++

Routine Description:

Register Service Principal Names for a server application.

This routine does the following:
1. Enumerates a list of server SPNs using DsGetSpn and the provided class
2. Determines the domain of the current user context
3. Determines the DN of the current user context if not supplied
4. Locates a domain controller
5. Binds to the domain controller
6. Uses DsWriteAccountSpn to write the SPNs on the named object DN
7. Unbinds

Construct server SPNs for this service, and write them to the right object.

If the userObjectDn is specified, the SPN is written to that object.

Otherwise the Dn is defaulted, to the user object, then computer.

Now, bind to the DS, and register the name on the object for the
user this service is running as.  So, if we're running as local
system, we'll register it on the computer object itself.  If we're
running as a domain user, we'll add the SPN to the user's object.

Arguments:

    Operation - What should be done with the values: add, replace or delete
    ServiceClass - Unique string identifying service
    UserObjectDN - Optional, dn of object to write SPN to

Return Value:

    WINAPI -

--*/

{
    DWORD Status ;
    LPWSTR * SpnDns = NULL, * SpnNetBios = NULL ;
    DWORD SpnCountDns = 0, SpnCountNetBios = 0 ;
    DWORD i ;
    WCHAR SamName[ 48 ];
    DWORD NameSize ;
    PWSTR DN = NULL ;
    PDOMAIN_CONTROLLER_INFO DcInfo ;
    HANDLE hDs ;

    if (ServiceClass == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    Status = DsGetSpnW(
                    DS_SPN_DNS_HOST,
                    ServiceClass,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL,
                    &SpnCountDns,
                    &SpnDns );

    if ( Status != 0 )
    {
        return Status ;
    }

    Status = DsGetSpnW(
                    DS_SPN_NB_HOST,
                    ServiceClass,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL,
                    &SpnCountNetBios,
                    &SpnNetBios );

    if ( Status != 0 )
    {
        goto Register_Cleanup ;
    }

    // Determine the domain name

#if !WIN95 && !WINNT4
    NameSize = sizeof( SamName ) / sizeof( WCHAR );

    if ( GetUserNameEx( NameSamCompatible, SamName, &NameSize ) )
    {
        PWSTR Whack ;

        Whack = wcschr( SamName, L'\\' );
        if ( Whack )
        {
            *Whack = L'\0';
        }

    }
    else
    {
        Status = GetLastError() ;

        goto Register_Cleanup ;
    }
#else
    *SamName = L'\0';
#endif

    //
    // Get my full DN (we'll need that next):
    //

    if (NULL == UserObjectDN) {

#if !WIN95 && !WINNT4
        NameSize = 128 ;

        DN = LocalAlloc( 0, NameSize * sizeof( WCHAR ) );

        if ( !DN )
        {
            Status = GetLastError();

            goto Register_Cleanup ;
        }

        if ( !GetUserNameEx( NameFullyQualifiedDN, DN, &NameSize ) )
        {
            if ( GetLastError() == ERROR_MORE_DATA )
            {
                LocalFree( DN );

                DN = LocalAlloc( 0, NameSize * sizeof( WCHAR ) );

                if ( !DN )
                {
                    Status = GetLastError();

                    goto Register_Cleanup ;
                }

                if ( !GetUserNameEx( NameFullyQualifiedDN, DN, &NameSize ) )
                {
                    Status = GetLastError();

                    goto Register_Cleanup ;
                }
            }
            else
            {
                Status = GetLastError();

                goto Register_Cleanup;
            }

        }

        UserObjectDN = DN;
#else
        Status = ERROR_INVALID_PARAMETER;
        goto Register_Cleanup;
#endif
    }


    //
    // Bind to that DS:
    //

    Status = DsGetDcName(
                    NULL,
                    SamName,
                    NULL,
                    NULL,
                    DS_IS_FLAT_NAME |
                        DS_RETURN_DNS_NAME |
                        DS_DIRECTORY_SERVICE_REQUIRED,
                    &DcInfo );

    if ( Status != 0 )
    {
        goto Register_Cleanup ;
    }

    Status = DsBind( DcInfo->DomainControllerName,
                     NULL,
                     &hDs );

    NetApiBufferFree( DcInfo );

    if ( Status != 0 )
    {
        goto Register_Cleanup ;
    }

    //
    // Got a binding, ready to go now:
    //

    // Register Dns based spns
    Status = DsWriteAccountSpn(
                        hDs,
                        Operation,
                        UserObjectDN,
                        SpnCountDns,
                        SpnDns );

    if (Status == ERROR_SUCCESS) {

        // Register Netbios based spns
        Status = DsWriteAccountSpn(
            hDs,
            Operation,
            UserObjectDN,
            SpnCountNetBios,
            SpnNetBios );
    }

    DsUnBind( &hDs );


Register_Cleanup:

    DsFreeSpnArray( SpnCountDns, SpnDns );
    DsFreeSpnArray( SpnCountNetBios, SpnNetBios );

    if ( DN )
    {
        LocalFree( DN );
    }

    return Status ;
} /* DsServerRegisterSpnW */


NTDSAPI
DWORD
WINAPI
DsMakeSpnA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN LPCSTR InstanceName OPTIONAL,
    IN USHORT InstancePort,
    IN LPCSTR Referrer OPTIONAL,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
)

/*++

Routine Description:

    Convert arguments to wide and call DsMakeSpnW

    See DsMakeSpnW

Arguments:

    ServiceClass -
    ServiceName -
    InstanceName -
    InstancePort -
    Referrer -
    pcSpnLength -
    pszSPN -

pcSpnLength must be non-Null.  Needed length returned here.
if *pcSpnLength != 0, pszSpn must be non-NUll
pszSpn may be null. If non-null, some or all of name returned.

Return Value:

    WINAPI -

--*/

{
    DWORD status, number, principalNameLength;
    LPWSTR serviceClassW = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR instanceNameW = NULL;
    LPWSTR referrerW = NULL;
    LPWSTR principalNameW = NULL;

    if ( (ServiceClass == NULL) ||
         (ServiceName == NULL) ||
         (pcSpnLength == NULL) ||
         ( (pszSpn == NULL) && (*pcSpnLength != 0) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = AllocConvertWide( ServiceName, &serviceNameW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be NULL
    status = AllocConvertWide( InstanceName, &instanceNameW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be NULL
    status = AllocConvertWide( Referrer, &referrerW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    principalNameLength = *pcSpnLength;  // in characters
    if (principalNameLength) {
        principalNameW = LocalAlloc( LPTR,
                                     principalNameLength * sizeof( WCHAR ) );
        if (principalNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    status = DsMakeSpnW( serviceClassW,
                         serviceNameW,
                         instanceNameW,
                         InstancePort,
                         referrerW,
                         &principalNameLength,
                         principalNameW );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_BUFFER_OVERFLOW) {
            // return needed length
            *pcSpnLength = principalNameLength;
        }
        goto cleanup;
    }

    // If we get this far, pszSpn != NULL.
    // If (pszSpn==NULL)&&(*pcSpnLength!=0) we exit ERROR_INVALID_PARAMETER.
    // If (pszSpn==NULL)&&(*pcSpnLength==0) we goto cleanup with ERROR_BUFFER_OVERFLOW.
    Assert( pszSpn != NULL );

    // The checks at the top require that if pszSpn == NULL, *pcSpnLength == 0.
    // The description of WideCharToMultiByte says that if the sixth argument
    // is zero, the fifth argument is ignored.  Thus it is not necessary to screen
    // out pszSpn == NULL before calling this function.

    // Convert back to multi-byte
    number = WideCharToMultiByte(
        CP_ACP,
        0,                          // flags
        principalNameW,
        principalNameLength,        // length in characters
        (LPSTR) pszSpn,             // Caller's buffer
        *pcSpnLength,            // Caller's length
        NULL,                       // default char
        NULL                     // default used
        );
    if (number == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Return out parameter
    *pcSpnLength = number;

    status = ERROR_SUCCESS;

cleanup:

    if (serviceClassW != NULL) {
        LocalFree( serviceClassW );
    }

    if (serviceNameW != NULL) {
        LocalFree( serviceNameW );
    }

    if (instanceNameW != NULL) {
        LocalFree( instanceNameW );
    }

    if (referrerW != NULL) {
        LocalFree( referrerW );
    }

    if (principalNameW != NULL) {
        LocalFree( principalNameW );
    }

    return status;
} /* DsMakeSpnA */


NTDSAPI
DWORD
WINAPI
DsMakeSpnW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN LPCWSTR InstanceName OPTIONAL,
    IN USHORT InstancePort,
    IN LPCWSTR Referrer OPTIONAL,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
)

/*++

Routine Description:

    Client call to create SPN for a service to which it wants to mutually
    authenticate

    Construct a SPN of the form

        class/instance:port/service

    If instance is NULL, the service name is used
    The port is only appended if non-zero.
    If service is an IP address, use referrer address

    // NOTE - not enforced.:
    // If the service name is a DNS host name, or cannonical DNS service name,
       then instance must
    // be null.
    // If service name is Netbios machine name, instance must be NULL
    // If service name is a DN, then client must supply the instance name
    // If service name is a Netbios domain name, then the client must supply
       the instance name
    // Validate service class

    Note: pszSpn may be null, or pcSpnLength may be 0, to request the final
    buffer size in advance.
    pcSpnLength must be non-Null.  Needed length returned here.
    if *pcSpnLength != 0, pszSpn must be non-NUll
    pszSpn may be null. If non-null, some or all of name returned.

    If buffer is not large enough, ERROR_BUFFER_OVERFLOW is returned and the
    needed length is given in pcSpnLength (including the NULL terminator).

Arguments:

    IN LPCTSTR ServiceClass,
        // e.g. "http", "ftp", "ldap", GUID
    IN LPCTSTR ServiceName,
        // DNS or DN or IP;
        // assumes we can compute domain from service name
    IN LPCTSTR InstanceName OPTIONAL,
        // DNS name or IP address of host for instance of service
    IN USHORT InstancePort,
        // port number for instance (0 if default)
    IN LPCTSTR Referrer OPTIONAL,
        // DNS name of host that gave this referral
    IN OUT PULONG pcSpnLength,
        // in -- max length IN CHARS of principal name;
        // out -- actual
    OUT LPTSTR pszSPN
        // server principal name

Return Value:

    DWORD -

--*/

{
    DWORD status;
    LPCWSTR currentServiceName, currentInstanceName;
    WCHAR pszPort[8];
    LPWSTR Spn = NULL;
    USHORT ipA[4];

    if ( (ServiceClass == NULL) ||
         (ServiceName == NULL) ||
         (wcslen( ServiceName ) == 0) ||
         (wcslen( ServiceClass ) == 0) ||
         (wcschr( ServiceName, L'/' ) != NULL) ||
         (wcschr( ServiceClass, L'/' ) != NULL) ||
         (pcSpnLength == NULL) ||
         ( (pszSpn == NULL) && (*pcSpnLength != 0) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Part 1 - Use Service Class as is

    // Part 2 - Instance name, use service name if null

    if (InstanceName != NULL) {
        if ( (wcslen( InstanceName ) == 0) ||
             (wcschr( InstanceName, L'/' ) != NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        currentInstanceName = InstanceName;
    } else {
        currentInstanceName = ServiceName;
    }

    // Part 3 - Service name, if ip address, use referrer
    //
    // Use length to disqualify long names, since a guid-based dns name
    // looks like an IP address in the first 16 characters.
    // This API supports only standard, most common fully qualified
    // ip addresses as ServiceName: "%hu.%hu.%hu.%hu"
    //
    // Other forms aren't supported (such as not FQ, hex or octal
    // representations).
    // No range specifications are performed (i.e. 192929.3.2.1 is
    // isn't rejected).
    //
    // ToDo: IPv6 support.

    if (wcslen( ServiceName ) <= MAX_IP_STRING &&
        4 == swscanf(ServiceName,L"%hu.%hu.%hu.%hu",
                          &ipA[0], &ipA[1], &ipA[2], &ipA[3])) {
        if ( (Referrer == NULL) ||
             (wcslen( Referrer ) == 0) ||
             (wcschr( Referrer, L'/' ) != NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        // good ip address + referrer exists.
        currentServiceName = Referrer;
    } else {
        // not an ip address.
        currentServiceName = ServiceName;
    }

    // If Service Name == Instance Name, drop the service
    // This is for host-based SPNs, which look like <type>\dnshostname.
    // Because we can't tell the user's request for a host-based SPN
    // from a service-based SPN, we may construct a "a/b" form spn for
    // a non-host based service.

    if (_wcsicmp( currentInstanceName, currentServiceName ) == 0) {
        currentServiceName = NULL;
    }

    // Construct the spn in temporary memory

    status = allocBuildSpn( ServiceClass,
                            currentInstanceName,
                            InstancePort,
                            currentServiceName,
                            &Spn );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Copy out and truncate, as necessary
    if (*pcSpnLength >= wcslen( Spn ) + 1) {
        if (pszSpn) {
            wcscpy( pszSpn, Spn );
        }
    } else {
        status = ERROR_BUFFER_OVERFLOW;
    }
    *pcSpnLength = wcslen( Spn ) + 1;

cleanup:

    if (Spn) {
        LocalFree( Spn );
    }

    return status;

} /* DsMakeSpnW */


NTDSAPI
DWORD
WINAPI
DsGetSpnA(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPSTR **prpszSpn
    )

/*++

Routine Description:

    Convert arguments to wide and call DsGetSpnW

Arguments:

    eType -
    ServiceClass -
    ServiceName -
    InstancePort -
    cInstanceNames -
    pInstanceNames -
    pInstancePorts -
    pcSpn -
    prpszSPN -

Return Value:

    WINAPI -

--*/

{
    DWORD status, i, cSpn = 0;
    LPWSTR serviceClassW = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR *pInstanceNamesW = NULL;
    LPWSTR *pSpn = NULL;
    LPSTR *pSpnA = NULL;

    if ( (!pcSpn) || (!prpszSpn) ) {
        status = ERROR_INVALID_PARAMETER;
        return status;
    }

    //
    // Convert in
    //

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (ServiceName) {
        status = AllocConvertWide( ServiceName, &serviceNameW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (cInstanceNames) {
        if (pInstanceNames == NULL) {                  // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        pInstanceNamesW = LocalAlloc( LPTR, cInstanceNames * sizeof( LPWSTR ) );
        if (!pInstanceNamesW) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        for( i = 0; i < cInstanceNames; i++ ) {
            status = AllocConvertWide( pInstanceNames[i], &(pInstanceNamesW[i]) );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // Call the wide version of the routine
    //

    status = DsGetSpnW(
        ServiceType,
        serviceClassW,
        serviceNameW,
        InstancePort,
        cInstanceNames,
        pInstanceNamesW,
        pInstancePorts,
        &cSpn,
        &pSpn
        );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Convert out
    //

    if (cSpn) {
        pSpnA = LocalAlloc( LPTR, cSpn * sizeof( LPSTR ) );
        if (!pSpnA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        for( i = 0; i < cSpn; i++ ) {
            status = AllocConvertNarrow( pSpn[i], &(pSpnA[i]) );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    *pcSpn = cSpn;
    *prpszSpn = pSpnA;
    pSpnA = NULL; // don't cleanup

    status = ERROR_SUCCESS;
cleanup:
    if (serviceClassW) {
        LocalFree( serviceClassW );
    }
    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (pInstanceNamesW) {
        for( i = 0; i < cInstanceNames; i++ ) {
            LocalFree( pInstanceNamesW[i] );
        }
        LocalFree( pInstanceNamesW );
    }
    if (pSpn != NULL) {
        DsFreeSpnArrayW( cSpn, pSpn );
    }
    if (pSpnA != NULL) {
        // rely on ability to clean up partially allocated spn array
        DsFreeSpnArrayA( cSpn, pSpnA );
    }

    return status;
} /* DsGetSpnA */


NTDSAPI
DWORD
WINAPI
DsGetSpnW(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCWSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPWSTR **prpszSpn
    )

/*++

Routine Description:

    Construct an array of server SPNs.

    An Spn consists of the following:
           class/instance:port/servicename
    The instance and service name are constructed according to various substitution and
    default rules too numerous to list here.  See spnapi.doc

    If cInstances is non-zero, use those instance supplied.
    Otherwise, use a defaulted instance name, if possible.
    Othewise, use the hostname

    Feb 17, 1999 - DNS hostname aliases are no longer registered

Arguments:

    eType -
    ServiceClass -
    ServiceName -
    InstancePort -
    cInstanceNames -
    pInstanceNames -
    pInstancePorts -
    pcSpn -
    prpszSPN -

Return Value:

    WINAPI -

--*/

{
    DWORD status, i, cSpn = 0, length;
    LPCWSTR currentServiceName;
    LPWSTR *pSpnList = NULL, primaryDnsHostname = NULL;
    WCHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
    struct hostent *he;
    PDS_NAME_RESULTW pResult = NULL;
    LPWSTR currentInstanceName, aliasW;
    LPWSTR computerDn = NULL;
    WCHAR dummy;

    status = InitializeWinsockIfNeeded();
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if ( (ServiceClass == NULL) ||
         (wcslen(ServiceClass) == 0) ||
         (wcschr(ServiceClass, L'/') != NULL) ||
         ( (ServiceName != NULL) &&
           ( (wcslen(ServiceName) == 0) ||
             (wcschr( ServiceName, L'/' ) != NULL) ) ) ||
         (!pcSpn) ||
         (!prpszSpn)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

#if WIN95 || WINNT4
    // Get Dns hostname
    he = gethostbyname( "" );
    if (he == NULL) {
        status = WSAGetLastError();
        return status;
    }

    // Convert to unicode
    status = AllocConvertWide( he->h_name, &primaryDnsHostname );
    if (status != ERROR_SUCCESS) {
        return status;
    }
#else
    // Get the required length for the computer name ex
    length = 1;
    GetComputerNameExW( ComputerNameDnsFullyQualified, &dummy, &length );
    // Allocate it
    primaryDnsHostname = (LPWSTR) LocalAlloc( LPTR,
                                              (length+1) * sizeof( WCHAR ) );
    if (primaryDnsHostname == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    if (!GetComputerNameExW( ComputerNameDnsFullyQualified,
                             primaryDnsHostname, &length )) {
        status = GetLastError();
        goto cleanup;
    }
#endif

    // Get Netbios hostname

    length = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerName( computerName, &length )) {
        status = GetLastError();
        goto cleanup;
    }

    // Calculate the service name for all cases

    switch (ServiceType) {
    case DS_SPN_DNS_HOST:
        if (ServiceName != NULL) {                   // Should NOT be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        // Service name will follow instance name, which is primaryDnsHostname
        currentServiceName = NULL; // drop service name component
        break;
    case DS_SPN_DN_HOST:
        if (ServiceName != NULL) {                   // Should NOT be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
#if 0
// This code doesn't work on WIN95
        computerDn = (LPWSTR) LocalAlloc( LPTR,
                                          MAX_COMPUTER_DN * sizeof( WCHAR ) );
        if (computerDn == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        length = MAX_COMPUTER_DN;
        // This may fail on a non-DC
        if (!GetComputerObjectName( NameFullyQualifiedDN, computerDn, &length )) {
            status = GetLastError();
            goto cleanup;
        }
        currentServiceName = computerDn;
#endif

        currentServiceName = NULL; // drop service name component
        break;
    case DS_SPN_NB_HOST:
        if (ServiceName != NULL) {                // Should NOT be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        // Service name will follow instance name, which is computerName
        currentServiceName = NULL; // drop service name component
        break;
    case DS_SPN_DOMAIN:
        if (ServiceName == NULL) {                   // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        // If name is DN, convert to DNS
        if (wcschr( ServiceName, L'=' )) {
            LPWSTR slash;
            status = DsCrackNamesW(
                (HANDLE) (-1),
                DS_NAME_FLAG_SYNTACTICAL_ONLY,
                DS_FQDN_1779_NAME,
                DS_CANONICAL_NAME,
                1,
                &ServiceName,
                &pResult);
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }

            if ( (pResult == NULL) ||
                 (pResult->rItems == NULL) ||
                 (pResult->rItems[0].status != DS_NAME_NO_ERROR ) ) {
                status = ERROR_DS_BAD_NAME_SYNTAX;
                goto cleanup;
            }
            currentServiceName = pResult->rItems[0].pName;
            // Replace trailing / with \0
            slash = wcschr( currentServiceName, L'/' );
            if (slash) {
                *slash = L'\0';
            }
        } else {
            currentServiceName = ServiceName;
        }
        break;
    case DS_SPN_NB_DOMAIN:
        if (ServiceName == NULL) {                    // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        currentServiceName = ServiceName;
        break;
    case DS_SPN_SERVICE:
        if (ServiceName == NULL) {                   // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        currentServiceName = ServiceName;
        break;
    default:
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Calculate number of SPNs
    //

    if (cInstanceNames) {
        // Must be supplied
        if (pInstanceNames == NULL)
        {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        // Check supplied strings for validity
        for( i = 0; i < cInstanceNames; i++ ) {
            if ( (pInstanceNames[i] == NULL) ||
                 (wcslen( pInstanceNames[i] ) == 0) ||
                 (wcschr( pInstanceNames[i], L'/' ) != NULL) ) {
                status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
        }
        cSpn = cInstanceNames;
    } else if ( (ServiceType == DS_SPN_SERVICE) &&
                (isCanonicalDnsName( currentServiceName )) ) {
        cSpn = 1;
    } else if ( (ServiceType == DS_SPN_NB_HOST) ||
                (ServiceType == DS_SPN_NB_DOMAIN) ) {
        cSpn = 1;
    } else {
        cSpn = 1; // count primary
    }

    //
    // Allocate array for SPNs
    //

    pSpnList = (LPWSTR *) LocalAlloc( LPTR, cSpn * sizeof( LPWSTR ) );
    if (pSpnList == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Construct the SPNs
    //

    if (cInstanceNames) {

        for( i = 0; i < cInstanceNames; i++ ) {
            status = allocBuildSpn( ServiceClass,
                                    pInstanceNames[i],
                         (USHORT) (pInstancePorts ? pInstancePorts[i] : 0),
                                    currentServiceName,
                                    &pSpnList[i] );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }

    } else if ( (ServiceType == DS_SPN_SERVICE) &&
                (isCanonicalDnsName( currentServiceName )) ) {

        status = allocBuildSpn( ServiceClass,
                                currentServiceName,
                                InstancePort,
                                currentServiceName,
                                &pSpnList[0] );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else if ( (ServiceType == DS_SPN_NB_HOST) ||
                (ServiceType == DS_SPN_NB_DOMAIN) ) {

        status = allocBuildSpn( ServiceClass,
                                computerName,
                                InstancePort,
                                currentServiceName,
                                &pSpnList[0] );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {

        // Add primary
        status = allocBuildSpn( ServiceClass,
                                primaryDnsHostname,
                                InstancePort,
                                currentServiceName,
                                &pSpnList[0] );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    *pcSpn = cSpn;
    *prpszSpn = pSpnList;
    pSpnList = NULL; // do not clean up, given away to caller

    status = ERROR_SUCCESS;

cleanup:
    if (pSpnList) {
        // Rely on ability of this routine to clean up partial spn arrays
        DsFreeSpnArrayW( cSpn, pSpnList );
    }

    if (primaryDnsHostname) {
        LocalFree( primaryDnsHostname );
    }

    if (computerDn) {
        LocalFree( computerDn );
    }

    if (pResult) {
        DsFreeNameResult( pResult );
    }

    return status;

} /* DsGetSpnW */


NTDSAPI
void
WINAPI
DsFreeSpnArrayA(
    IN DWORD cSpn,
    OUT LPSTR *rpszSpn
    )

/*++

Routine Description:

See DsFreeSpnArrayW

Arguments:

    rpszSPN -

Return Value:

    WINAPI -

--*/

{
    DsFreeSpnArrayW( cSpn, (LPWSTR *)rpszSpn );

} /* DsFreeSpnArrayA */


NTDSAPI
void
WINAPI
DsFreeSpnArrayW(
    IN DWORD cSpn,
    OUT LPWSTR *rpszSpn
    )

/*++

Routine Description:

Free Spn Array
This routine is extra defensive by checking for null items.  It can be used
to clean up partially allocated spn arrays in event of errors in other
routines.

Arguments:

    rpszSPN -

Return Value:

    WINAPI -

--*/

{
    DWORD i;

    if (!rpszSpn) {
        return;
    }

    for( i = 0; i < cSpn; i++ ) {
        if (rpszSpn[i]) {
            LocalFree( rpszSpn[i] );
        }
    }

    LocalFree( rpszSpn );

} /* DsFreeSpnArrayW */


NTDSAPI
DWORD
WINAPI
DsCrackSpnA(
    IN LPCSTR pszSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    )
/*++

Routine Description:

Convert arguments to wide, and call DsCrackSpnW
See DsCrackSpnW

Arguments:

    pszSpn -
    pcServiceClass -
    ServiceClass -
    pcServiceName -
    ServiceName -
    pcInstanceName -
    InstanceName -
    pInstancePort -

Return Value:

    WINAPI -

--*/
{
    DWORD status, number;
    LPWSTR spnW = NULL;
    LPWSTR serviceClassW = NULL, serviceNameW = NULL, instanceNameW = NULL;

    status = ERROR_SUCCESS;

    // Convert In

    if (pszSpn) {
        status = AllocConvertWide( pszSpn, &spnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    // Allocate space for out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        serviceClassW = LocalAlloc( LPTR, (*pcServiceClass) * sizeof(WCHAR) );
        if (serviceClassW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        serviceNameW = LocalAlloc( LPTR, (*pcServiceName) * sizeof(WCHAR) );
        if (serviceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        instanceNameW = LocalAlloc( LPTR, (*pcInstanceName) * sizeof(WCHAR) );
        if (instanceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    // Perform the function

    status = DsCrackSpnW( spnW,
                          pcServiceClass, serviceClassW,
                          pcServiceName, serviceNameW,
                          pcInstanceName, instanceNameW,
                          pInstancePort );
    if (status != ERROR_SUCCESS) {
        // Note that on ERROR_BUFFER_OVERFLOW we abort immediately without
        // trying to determine which component actually failed
        goto cleanup;
    }

    // Convert out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceClassW,
            *pcServiceClass,        // length in characters
            (LPSTR) ServiceClass,             // Caller's buffer
            *pcServiceClass,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceNameW,
            *pcServiceName,        // length in characters
            (LPSTR) ServiceName,             // Caller's buffer
            *pcServiceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            instanceNameW,
            *pcInstanceName,        // length in characters
            (LPSTR) InstanceName,             // Caller's buffer
            *pcInstanceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    // Success!

cleanup:
    if (spnW) {
        LocalFree( spnW );
    }
    if (serviceClassW) {
        LocalFree( serviceClassW );
    }
    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (instanceNameW) {
        LocalFree( instanceNameW );
    }

    return status;
}


NTDSAPI
DWORD
WINAPI
DsCrackSpnW(
    IN LPCWSTR pszSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    )

/*++

Routine Description:

// DsCrackSpn() -- parse an SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece.
// Each length, buffer pair must be both present or both absent
//The InstancePort is 0 if not present.
//
// DWORD DsCrackSpn(
//  IN LPTSTR pszSPN,           // the SPN to parse
//  IN OUT PUSHORT pcServiceClass OPTIONAL,
//      input -- max length of ServiceClass;
//      output -- actual length
//   OUT LPCTSTR ServiceClass OPTIONAL, // the ServiceClass part of the SPN
//   IN OUT PUSHORT pcServiceName OPTIONAL,
//       input -- max length of ServiceName;
//       output -- actual length
//   OUT LPCTSTR ServiceName OPTIONAL,  // the ServiceName part of the SPN
//   IN OUT PUSHORT pcInstance OPTIONAL,
//        input -- max length of ServiceClass;
//        output -- actual length
//   OUT LPCTSTR InstanceName OPTIONAL,  // the InstanceName part of the SPN
//   OUT PUSHORT InstancePort OPTIONAL    // instance port
//
// Note: lengths are in characters; all string lengths include terminators
//
// We always return the needed length.  We only copy out the data if there is
// room for the data and the terminator.  If any of the three fields have
// insufficient space, buffer overflow will be returned.  To determine which
// one actually overflowed, you must compare the returned length with the
// supplied length.
//

Arguments:

    pszSpn - Input Spn
    pcServiceClass - pointer to dword, on input, max length,
                     on output current length
    ServiceClass - buffer, or zero
    pcServiceName - pointer to dword, on input, max length,
                    on output current length
    ServiceName - buffer, or zero
    pcInstanceName - pointer to dword, on input, max length,
                     on output current length
    InstanceNames - buffer, or zero
    pInstancePort - pointer to short, to receive port

Return Value:

    WINAPI -

--*/
{
    DWORD status, status1, length, classLength, instanceLength, serviceLength;
    LPCWSTR class, c1, port, p1, instance, p2, service, p3;

    // Reject empty

    if (pszSpn == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // Reject too small
    length = wcslen( pszSpn );
    if (length < 3 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Calculate length, extract components
    // Calculate positions of syntax components

    // Class component
    class = pszSpn;
    p1 = wcschr( pszSpn, L'/' );
    if (p1 == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    classLength = (ULONG)(p1 - class);

    instance = p1 + 1;
    c1 = wcschr( instance, L':' );
    port = c1 + 1;

    // service name part is optional
    p2 = wcschr( instance, L'/' );
    if (p2 != NULL) {
        instanceLength = (ULONG)((c1 ? c1 : p2) - instance);

        service = p2 + 1;
        serviceLength = wcslen( service );

        // Check for extra separators, which are not allowed
        p3 = wcschr( service, L'/' );
        if (p3 != NULL) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        service = NULL;
        serviceLength = 0;
        if (c1) {
            instanceLength = (ULONG) (c1 - instance);
        } else {
            instanceLength = wcslen( instance );
        }
    }

    status = ERROR_SUCCESS;

    // Service Class part

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        status1 = extractString( class, classLength, pcServiceClass, ServiceClass );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance name part

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        status1 = extractString( instance, instanceLength,pcInstanceName, InstanceName );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Service name part

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        if (p2) {
            status1 = extractString( service, serviceLength, pcServiceName, ServiceName);
        } else {
            // Return the instance name as the service name
            status1 = extractString( instance, instanceLength,
                                     pcServiceName, ServiceName );
        }
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance port part

    if ( pInstancePort ) {
        if (c1) {
            *pInstancePort = (USHORT)_wtoi( port );
        } else {
            *pInstancePort = 0;
        }
    }

    return status;

}


NTDSAPI
DWORD
WINAPI
DsCrackSpn2A(
    IN LPCSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    )
/*++

Routine Description:

Convert arguments to wide, and call DsCrackSpn2W
See DsCrackSpn2W

Arguments:

    pszSpn -
    cSpn -
    pcServiceClass -
    ServiceClass -
    pcServiceName -
    ServiceName -
    pcInstanceName -
    InstanceName -
    pInstancePort -

Return Value:

    WINAPI -

--*/
{
    DWORD status, number;
    LPWSTR spnW = NULL;
    LPWSTR serviceClassW = NULL, serviceNameW = NULL, instanceNameW = NULL;

    status = ERROR_SUCCESS;

    // Convert In

    if (pszSpn) {
        status = AllocConvertWideBuffer( cSpn, pszSpn, &spnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    // Allocate space for out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        serviceClassW = LocalAlloc( LPTR, (*pcServiceClass) * sizeof(WCHAR) );
        if (serviceClassW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        serviceNameW = LocalAlloc( LPTR, (*pcServiceName) * sizeof(WCHAR) );
        if (serviceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        instanceNameW = LocalAlloc( LPTR, (*pcInstanceName) * sizeof(WCHAR) );
        if (instanceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    // Perform the function

    status = DsCrackSpn2W( spnW,
                          cSpn,
                          pcServiceClass, serviceClassW,
                          pcServiceName, serviceNameW,
                          pcInstanceName, instanceNameW,
                          pInstancePort );
    if (status != ERROR_SUCCESS) {
        // Note that on ERROR_BUFFER_OVERFLOW we abort immediately without
        // trying to determine which component actually failed
        goto cleanup;
    }

    // Convert out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceClassW,
            *pcServiceClass,        // length in characters
            (LPSTR) ServiceClass,             // Caller's buffer
            *pcServiceClass,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceNameW,
            *pcServiceName,        // length in characters
            (LPSTR) ServiceName,             // Caller's buffer
            *pcServiceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            instanceNameW,
            *pcInstanceName,        // length in characters
            (LPSTR) InstanceName,             // Caller's buffer
            *pcInstanceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    // Success!

cleanup:
    if (spnW) {
        LocalFree( spnW );
    }
    if (serviceClassW) {
        LocalFree( serviceClassW );
    }
    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (instanceNameW) {
        LocalFree( instanceNameW );
    }

    return status;
}


NTDSAPI
DWORD
WINAPI
DsCrackSpn2W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    )
/*++

Routine Description:

// DsCrackSpn2() -- parse an SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// The length of the SPN string passed in is also provided. The string does
// not have to be NULL-terminated.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece.
// Each length, buffer pair must be both present or both absent
//The InstancePort is 0 if not present.
//
// DWORD DsCrackSpn(
//  IN LPTSTR pszSPN,           // the SPN to parse (does not have to be NULL-terminated)
//  IN DWORD cSpn,            // length of pszSPN
//  IN OUT PUSHORT pcServiceClass OPTIONAL,
//      input -- max length of ServiceClass;
//      output -- actual length
//   OUT LPCTSTR ServiceClass OPTIONAL, // the ServiceClass part of the SPN
//   IN OUT PUSHORT pcServiceName OPTIONAL,
//       input -- max length of ServiceName;
//       output -- actual length
//   OUT LPCTSTR ServiceName OPTIONAL,  // the ServiceName part of the SPN
//   IN OUT PUSHORT pcInstance OPTIONAL,
//        input -- max length of ServiceClass;
//        output -- actual length
//   OUT LPCTSTR InstanceName OPTIONAL,  // the InstanceName part of the SPN
//   OUT PUSHORT InstancePort OPTIONAL    // instance port
//
// Note: lengths are in characters; all string lengths include terminators
//
// We always return the needed length.  We only copy out the data if there is
// room for the data and the terminator.  If any of the three fields have
// insufficient space, buffer overflow will be returned.  To determine which
// one actually overflowed, you must compare the returned length with the
// supplied length.
//

Arguments:

    pszSpn - Input Spn
    cSpn - Length of pszSpn
    pcServiceClass - pointer to dword, on input, max length,
                     on output current length
    ServiceClass - buffer, or zero
    pcServiceName - pointer to dword, on input, max length,
                    on output current length
    ServiceName - buffer, or zero
    pcInstanceName - pointer to dword, on input, max length,
                     on output current length
    InstanceNames - buffer, or zero
    pInstancePort - pointer to short, to receive port

Return Value:

    WINAPI -

--*/
{
    DWORD status, status1, classLength, instanceLength, serviceLength;
    LPCWSTR class, c1, port, p1, instance, p2, service, p3;

    // Reject empty

    if (pszSpn == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // Reject too small
    if (cSpn < 3 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Calculate length, extract components
    // Calculate positions of syntax components

    // Class component
    class = pszSpn;
//  p1 = wcschr( pszSpn, L'/' );
    p1 = pszSpn;
    while ( p1 < pszSpn+cSpn ) {
        if ( *p1 == L'/' ) {
            break;
        }
        p1++;
    }
    if (p1 >= pszSpn+cSpn) {
        return ERROR_INVALID_PARAMETER;
    }
    classLength = (ULONG)(p1 - class);

    instance = p1 + 1;
//  c1 = wcschr( instance, L':' );
    c1 = instance;
    while (c1 < pszSpn + cSpn) {
        if (*c1 == L':') {
            break;
        }
        c1++;
    }
    if (c1 >= pszSpn+cSpn) {
        c1 = NULL;
    }
    port = c1 + 1;

    // service name part is optional
//  p2 = wcschr( instance, L'/' );
    p2 = instance;
    while (p2 < pszSpn+cSpn) {
        if (*p2 == L'/') {
            break;
        }
        p2++;
    }
    if (p2 >= pszSpn+cSpn) {
        p2 = NULL;
    }

    if (p2 != NULL) {
        instanceLength = (ULONG)((c1 ? c1 : p2) - instance);

        service = p2 + 1;
        serviceLength = cSpn - ( ULONG )(service - pszSpn); // wcslen( service );

        // Check for extra separators, which are not allowed
//      p3 = wcschr( service, L'/' );
        p3 = service;
        while (p3 < pszSpn+cSpn) {
            if (*p3 == L'/') {
                break;
            }
            p3++;
        }
        if (p3 >= pszSpn+cSpn) {
            p3 = NULL;
        }
        if (p3 != NULL) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        service = NULL;
        serviceLength = 0;
        if (c1) {
            instanceLength = (ULONG) (c1 - instance);
        } else {
            instanceLength = cSpn - ( ULONG )(instance - pszSpn); // wcslen( instance );
        }
    }

    status = ERROR_SUCCESS;

    // Service Class part

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        status1 = extractString( class, classLength, pcServiceClass, ServiceClass );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance name part

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        status1 = extractString( instance, instanceLength,pcInstanceName, InstanceName );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Service name part

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        if (p2) {
            status1 = extractString( service, serviceLength, pcServiceName, ServiceName);
        } else {
            // Return the instance name as the service name
            status1 = extractString( instance, instanceLength,
                                     pcServiceName, ServiceName );
        }
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance port part

    if ( pInstancePort ) {
        if (c1) {
//          *pInstancePort = (USHORT)_wtoi( port );
            *pInstancePort = 0;
            while (port < pszSpn+cSpn) {
                if ( iswdigit( *port )) {
                    *pInstancePort = *pInstancePort * 10 + (*port - L'0');
                } else {
                    break;
                }
                port++;
            }
            if ( port < pszSpn+cSpn && *port != L'/' ) {
                status = ERROR_INVALID_PARAMETER;
            }
        } else {
            *pInstancePort = 0;
        }
    }

    return status;

} /* DsCrackSpnW */

NTDSAPI
DWORD
WINAPI
DsCrackSpn3W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcHostName,
    OUT LPWSTR HostName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pPortNumber,
    IN OUT DWORD *pcDomainName,
    OUT LPWSTR DomainName,
    IN OUT DWORD *pcRealmName,
    OUT LPWSTR RealmName
    )
{
    DWORD status, status2;
    LPCWSTR host = NULL, instance = NULL, port = NULL, domain = NULL, realm = NULL;
    LPCWSTR p1, p2, p3, p4;
    DWORD hostLength = 0, instanceLength = 0, domainLength = 0, realmLength = 0, dwPort = 0;

    // Reject empty

    if ( pszSpn == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Reject too small
    if ( cSpn < 3 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Host name is required
    host = pszSpn;
    p1 = pszSpn;
    while ( p1 < pszSpn + cSpn ) {
        if ( *p1 == L'/' )
            break;
        p1++;
        hostLength++;
    }

    // reject no instance and no host
    // examples: "host" or "/instance"
    if ( p1 >= pszSpn + cSpn || hostLength == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // reject no instance
    // example: "host/"
    instance = p1 + 1;
    if ( instance >= pszSpn+cSpn ) {
        return ERROR_INVALID_PARAMETER;
    }

    // instance ends with ':' if port is next
    // or with '/' if domain name is next
    p2 = instance;
    while ( p2 < pszSpn + cSpn ) {
        if ( *p2 == L':' || *p2 == L'/' )
            break;
        p2++;
        instanceLength++;
    }

    // reject empty instance name
    // examples: "host/:123" or "host//domain"
    if ( instanceLength == 0 ) {
        return ERROR_INVALID_PARAMETER;
    } else if ( *p2 == L':' ) {
        port = p2 + 1;
    } else if ( *p2 == L'/' ) {
        domain = p2 + 1;
    } else {
        ASSERT( p2 >= pszSpn + cSpn );
    }

    // port number is optional, but should be well-formed
    if ( port != NULL ) {
        p3 = port;
        while ( p3 < pszSpn + cSpn ) {
            if ( iswdigit( *p3 )) {
                // port numbers are unsigned 16-bit quantities
                dwPort = dwPort * 10 + ( *p3 - L'0' );
                if ( dwPort > MAXUSHORT ) {
                   return ERROR_INVALID_PARAMETER;
                }
            } else {
                break;
            }
            p3++;
        }

        // reject empty or zero port numbers
        // examples: "host/instance:0" or "host/instance:/domain"
        if ( dwPort == 0 ) {
            return ERROR_INVALID_PARAMETER;
        }
        else if ( p3 < pszSpn + cSpn ) {
            // reject port numbers that are followed by
            // anything except a domain name
            // example: "host/instance:123abc"
            if ( *p3 != L'/' ) {
                return ERROR_INVALID_PARAMETER;
            }
            ASSERT( domain == NULL );
            domain = p3 + 1;
        }
    }

    // domain name is optional
    if ( domain != NULL ) {
        LPCWSTR last = NULL;
        p4 = domain;
        while ( p4 < pszSpn + cSpn ) {
            if ( *p4 == L'@' ) {
                last = p4;
            }
            p4++;
        }
        if ( last == NULL ) {
            domainLength = ( USHORT )( p4 - domain );
        } else {
            domainLength = ( USHORT )( last - domain );
        }

        // reject empty domain names
        // examples: "host/instance/" or "host/instance/@realm"
        if ( domainLength == 0 ) {
            return ERROR_INVALID_PARAMETER;
        // reject empty realm names
        // example: "host/instance/domain@"
        } else if ( last + 1 == pszSpn + cSpn ) {
            return ERROR_INVALID_PARAMETER;
        }

        if ( last != NULL ) {
            realm = last + 1;
            realmLength = cSpn - ( ULONG )( realm - pszSpn );
        }
    }

    status = ERROR_SUCCESS;

    // Host name part

    if ( pcHostName && HostName ) {
        status2 = extractString( host, hostLength, pcHostName, HostName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    // InstanceName name part

    if ( pcInstanceName && InstanceName ) {
        status2 = extractString( instance, instanceLength, pcInstanceName, InstanceName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    // Port part

    if ( pPortNumber ) {
        *pPortNumber = ( USHORT )dwPort;
    }

    // DomainName name part

    if ( pcDomainName && DomainName ) {
        status2 = extractString( domain, domainLength, pcDomainName, DomainName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    // RealmName name part

    if ( pcRealmName && RealmName ) {
        status2 = extractString( realm, realmLength, pcRealmName, RealmName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    return status;
}



NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnA(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR pszAccount,
    IN DWORD cSpn,
    IN LPCSTR *rpszSpn
    )

/*++

Routine Description:

Convert arguments to Unicode and call DsWriteAccountSpnW

Arguments:

    hDS - DS Rpc handle, from calling DsBind{A,W}
    Operation - Operation code
    pszAccount - DN of a computer object
    cSpn - Count of spns, may be zero for replace operation
    rpszSpn - Spn array

Return Value:

    WINAPI -

--*/

{
    DWORD status, i;
    LPWSTR accountW = NULL;
    LPWSTR *pSpnW = NULL;

    // Validate
    // cSpn may be 0 and pSpn may be null under some circumstances

    if ( (hDS == NULL ) ||
         (pszAccount == NULL) ||
         ( (cSpn == 0) != (rpszSpn == NULL) )
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Convert IN

    status = AllocConvertWide( pszAccount, &accountW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if ( (cSpn) && (rpszSpn) ) {
        pSpnW = (LPWSTR *) LocalAlloc( LPTR, cSpn * sizeof( LPWSTR ) );
        if (pSpnW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        for( i = 0; i < cSpn; i++ ) {
            status = AllocConvertWide( rpszSpn[i], &(pSpnW[i]) );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    // Call the wide version of the function

    status = DsWriteAccountSpnW( hDS, Operation, accountW, cSpn, pSpnW );

    // No other operations required

    // status already set, fall through
cleanup:
    if (accountW) {
        LocalFree( accountW );
    }

    if ( (cSpn) && (pSpnW) ) {
        for( i = 0; i < cSpn; i++ ) {
            if (pSpnW[i] != NULL) {
                LocalFree( pSpnW[i] );
            }
        }
        LocalFree( pSpnW );
    }

    return status;

} /* DsWriteAccountSpnA */


NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnW(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR pszAccount,
    IN DWORD cSpn,
    IN LPCWSTR *rpszSpn
    )

/*++

Routine Description:

Write SPNs to the Directory Service.  The are actually added to the Service-
Principal-Name attribute of a computer object.

The caller must have write access to the object and attribute in order for
this function to succeed.

cSpn is allowed to be zero when doing a replace, meaning "remove the
attribute".

There is a certain ambibuity regarding status when multiple SPNs are provided.
It appears the semantics of the core functions are that success is returned if
any complete successfully.  The modification is done "permissively", meaning
that soft errors are not returned, such as adding a value which already exists
is NOT an error.

Arguments:

    hDS - DS Rpc handle, from calling DsBind{A,W}
    Operation - Operation code
    pszAccount - DN of a computer object
    cSpn - Count of spns, may be zero for replace operation
    rpszSpn - Spn array

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_SPNREQ spnReq;
    DRS_MSG_SPNREPLY spnReply;
    DWORD status, i, dwOutVersion;
#if DBG
    DWORD startTime = GetTickCount();
#endif

    // Validate
    // cSpn may be 0 and pSpn may be null under some circumstances

    if ( (hDS == NULL ) ||
         (pszAccount == NULL) ||
         ( (cSpn == 0) != (rpszSpn == NULL) )
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Input parameters

    memset(&spnReq, 0, sizeof(spnReq));
    memset(&spnReply, 0, sizeof(spnReply));

    spnReq.V1.operation = Operation;
    spnReq.V1.pwszAccount = pszAccount;
    spnReq.V1.cSPN = cSpn;
    spnReq.V1.rpwszSPN = rpszSpn;

    status = ERROR_SUCCESS;

    // Call the server

    __try
    {
        // Following call returns WIN32 errors, not DRAERR_* values.
        status = _IDL_DRSWriteSPN(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &spnReq,
                        &dwOutVersion,
                        &spnReply);

        if ( 0 == status )
        {
            if ( 1 != dwOutVersion )
            {
                status = RPC_S_INTERNAL_ERROR;
            }
            else
            {
                status = spnReply.V1.retVal;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
         
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR( status );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsWriteAccountSpn]"));
    DSLOG((0,"[PA=%u][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           Operation, pszAccount, startTime, GetTickCount(), status))

    return status;

} /* DsWriteAccountSpnW */


DWORD
extractString(
    IN LPCWSTR Start,
    IN DWORD Length,
    IN OUT DWORD *pSize,
    OUT LPWSTR Output
    )

/*++

Routine Description:

Helper routine to write a counted substring to an output buffer, with length

If the supplied buffer length is not sufficient for the data and the
terminator, return the needed length and a status of overflow.
Arguments:

    Start - pointer to start of string
    Length - length, in characters
    pSize - pointer to dword, in max length, out curr length
    Output - output buffer, optional

Return Value:

    DWORD - status, ERROR_SUCCESS or ERROR_BUFFER_OVERFLOW

--*/

{
    DWORD available = *pSize;

    *pSize = Length + 1; // return needed length in all cases

    if (available <= Length) {
        return ERROR_BUFFER_OVERFLOW;
    }

    wcsncpy( Output, Start, Length );
    Output[Length] = L'\0';

    return ERROR_SUCCESS;
} /* extractString */


static DWORD
allocBuildSpn(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCWSTR ServiceName OPTIONAL,
    OUT LPWSTR *pSpn
    )

/*++

Routine Description:

Helper routine to construct a spn.  Given the components, allocate enough
space and construct the spn.

13-May-99, Paulle says:

Essentially, a poll was taken, to see whether there should be a trailing dot or
not. In favor of trailing dots was the general DNS conventions that "real"
FQDNs have "." at the end. Against seemed to be the preponderance of existing
code, such as gethostbyname(). So we decided that DNS names in SPNs wouldn't have
"." at the end, and that as a service the DsSpn API would remove them if present.

Arguments:

    ServiceClass -
    InstanceName -
    InstancePort -
    ServiceName -
    pSpn -

Return Value:

    DWORD -

--*/

{
    DWORD status, length;
    WCHAR numberBuffer[10];
    LPWSTR Spn = NULL, pwzPart;

    // Calculate length, including optional components

    length = wcslen( ServiceClass ) +
        wcslen( InstanceName ) + 2;
    if (ServiceName) {
        length += wcslen( ServiceName ) + 1;
    }

    if (InstancePort) {
        _itow(InstancePort, numberBuffer, 10);
        length += 1 + wcslen( numberBuffer );
    }

    // Allocate space

    Spn = LocalAlloc( LPTR, length * sizeof(WCHAR) );
    if (Spn == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        return status;
    }

    // Fill it in

    pwzPart = Spn;

    wcscpy( pwzPart, ServiceClass );
    pwzPart += wcslen( ServiceClass );
    wcscpy( pwzPart, L"/" );
    pwzPart++;
    wcscpy( pwzPart, InstanceName );
    pwzPart += wcslen( InstanceName );

    // If instance has a trailing dot
    pwzPart--;
    if (*pwzPart == L'.') {
        *pwzPart = L'\0';
    } else {
        pwzPart++;
    }

    if (InstancePort) {
        wcscpy( pwzPart, L":" );
        pwzPart++;
        wcscpy( pwzPart, numberBuffer );
        pwzPart += wcslen( numberBuffer );
    }

    if (ServiceName) {
        wcscpy( pwzPart, L"/" );
        pwzPart++;
        wcscpy( pwzPart, ServiceName );
        pwzPart += wcslen( ServiceName );

        // If ServiceName has a trailing dot, remove it
        pwzPart--;
        if (*pwzPart == L'.') {
            *pwzPart = L'\0';
        } else {
            pwzPart++;
        }
    }

    // Return value to caller
    *pSpn = Spn;

    return ERROR_SUCCESS;
} /* allocBuildSpn */


static BOOLEAN
isCanonicalDnsName(
    IN LPCWSTR DnsName
    )

/*++

Routine Description:

Check if a dns service name is "canonical".  Do this by looking for a well-
known prefix at the start of the name.

Arguments:

    DnsName -

Return Value:

    BOOLEAN -

--*/

{
    DWORD i;

    // PERFHINT SCALING: linear search. Use binary search someday

    for( i = 0; i < NUMBER_ELEMENTS( WellKnownDnsPrefixes ); i++ ) {
        if ( wcsstr( DnsName, WellKnownDnsPrefixes[i] ) == DnsName ) {
            return TRUE;
        }
    }

    return FALSE;
} /* isCanonicalDnsName */

/* end of spn.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\siteinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    siteinfo.c

Abstract:

    Implementation of site/server/domain info APIs.

Author:

    DaveStr     06-Apr-98

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <rpc.h>            // RPC defines
#include <ntdsapi.h>        // CrackNam apis
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState

#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <msrpc.h>          // DS RPC definitions

#include <ntdsa.h>          // GetRDNInfo
#include <scache.h>         // req'd for mdlocal.h
#include <dbglobal.h>       // req'd for mdlocal.h
#include <mdglobal.h>       // req'd for mdlocal.h
#include <mdlocal.h>        // CountNameParts
#include <attids.h>         // ATT_DOMAIN_COMPONENT
#include <ntdsapip.h>       // DS_LIST_* definitions

#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include "util.h"           // HandleClientRpcException

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListSites                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListSitesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppSites)       // out

/*++

  Routine Description:

    Lists sites in the enterprise.

  Parameters:

    hDS - Pointer to BindState for this session.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns sites
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    LPSTR dummy = "dummy";

    *ppSites = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SITES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppSites));
}
                            
DWORD
DsListSitesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppSites)       // out
{
    LPWSTR dummy = L"dummy";
    
    *ppSites = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SITES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppSites));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListServersInSite                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListServersInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers)     // out
/*++

  Routine Description:

    Lists servers in a site.

  Parameters:

    hDS - Pointer to BindState for this session.

    site - Name of site whose servers to list.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns servers
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    *ppServers = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SERVERS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            &site,
                            ppServers));
}

DWORD
DsListServersInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers)     // out
{
    *ppServers = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SERVERS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            &site,
                            ppServers));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListDomainsInSite                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListDomainsInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppDomains)     // out
/*++

  Routine Description:

    Lists domains in a site.

  Parameters:

    hDS - Pointer to BindState for this session.

    site - Name of site whose domains to list.  Use NULL for all
        domains in all sites.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns domains
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    CHAR *dummy = "dummyArg";

    *ppDomains = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            NULL == site  
                                ? DS_LIST_DOMAINS
                                : DS_LIST_DOMAINS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            NULL == site ? &dummy : &site,
                            ppDomains));
}

DWORD
DsListDomainsInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppDomains)     // out
{
    WCHAR *dummy = L"dummyArg";

    *ppDomains = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            NULL == site
                                ? DS_LIST_DOMAINS
                                : DS_LIST_DOMAINS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            NULL == site ? &dummy : &site,
                            ppDomains));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListServersForDomainInSite                                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListServersForDomainInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              domain,         // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers)     // out
/*++

  Routine Description:

    Lists servers for a domains in a site.

  Parameters:

    hDS - Pointer to BindState for this session.

    domain - Name of domains whose servers to list.

    site - Name of site whose servers to list.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns servers
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    LPCSTR  args[2] = { 0, 0 };
    DWORD   retVal;

    *ppServers = NULL;

    if ( NULL == domain )
    {
        args[0] = site;
        retVal = DsCrackNamesA( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_WITH_DCS_IN_SITE,
                                DS_FQDN_1779_NAME,
                                1,
                                args,
                                ppServers);
    }
    else
    {
        args[0] = domain;
        args[1] = site;
        retVal = DsCrackNamesA( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE,
                                DS_FQDN_1779_NAME,
                                2,
                                args,
                                ppServers);
    }

    return(retVal);
}

DWORD
DsListServersForDomainInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             domain,         // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers)     // out
{
    LPCWSTR args[2] = { 0, 0 };
    DWORD   retVal;

    *ppServers = NULL;

    if ( NULL == domain )
    {
        args[0] = site;
        retVal = DsCrackNamesW( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_WITH_DCS_IN_SITE,
                                DS_FQDN_1779_NAME,
                                1,
                                args,
                                ppServers);
    }
    else
    {
        args[0] = domain;
        args[1] = site;
        retVal = DsCrackNamesW( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE,
                                DS_FQDN_1779_NAME,
                                2,
                                args,
                                ppServers);
    }

    return(retVal);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListInfoForServer                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListInfoForServerA(
    HANDLE              hDs,            // in
    LPCSTR              server,         // in
    PDS_NAME_RESULTA    *ppInfo)        // out
/*++

  Routine Description:

    Lists misc. info for a server.

  Parameters:

    hDS - Pointer to BindState for this session.

    server - Name of server of interest.

    ppInfo - Pointer to PDS_NAME_RESULT which receives knowns info
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    *ppInfo = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_INFO_FOR_SERVER,
                            DS_FQDN_1779_NAME,
                            1,
                            &server,
                            ppInfo));
}

DWORD
DsListInfoForServerW(
    HANDLE              hDs,            // in
    LPCWSTR             server,         // in
    PDS_NAME_RESULTW    *ppInfo)        // out
{
    *ppInfo = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_INFO_FOR_SERVER,
                            DS_FQDN_1779_NAME,
                            1,
                            &server,
                            ppInfo));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListRoles                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListRolesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppRoles)       // out

/*++

  Routine Description:

    Lists the roles this server knows about.  Not the same as the
    roles this server owns - though that would be a subset.

  Parameters:

    hDS - Pointer to BindState for this session.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns roles
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    LPSTR dummy = "dummy";

    *ppRoles = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_ROLES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppRoles));
}
                            
DWORD
DsListRolesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppRoles)       // out
{
    LPWSTR dummy = L"dummy";
    
    *ppRoles = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_ROLES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppRoles));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\replica.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    replica.c

Abstract:

    This module implements the public interfaces to the replica routines:

    DsReplicaSync();
    DsReplicaAdd();
    DsReplicaDelete();
    DsReplicaModify();

Author:

    Will Lees (wlees) 30-Jan-1998

Environment:

Notes:

Revision History:

--*/

#define UNICODE 1

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <rpc.h>            // RPC defines
#include <stdlib.h>         // atoi, itoa


#include <dnsapi.h>         // for DnsValidateName_W

#include <ntdsapi.h>        // CrackNam apis
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState

#include <drserr.h>         // DRSERR_ codes

#include <dsaapi.h>         // DRS_UPDATE_* flags
#define INCLUDE_OPTION_TRANSLATION_TABLES
#include <draatt.h>         // Dra option flags for replication
#undef INCLUDE_OPTION_TRANSLATION_TABLES

#include <msrpc.h>          // DS RPC definitions
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include "util.h"           // ntdsapi utility functions
#include <dststlog.h>       // DSLOG

#include "dsdebug.h"

#if DBG
#include <stdio.h>          // printf for debugging
#endif

#include <fileno.h>
#define FILENO FILENO_NTDSAPI_REPLICA

/* Forward */

DWORD
translateOptions(
    DWORD PublicOptions,
    POPTION_TRANSLATION Table
    );

#define SZUUID_LEN ((2*sizeof(UUID)) + MAX_PATH +2)

/* End Forward */


NTDSAPI
DWORD
WINAPI
DsReplicaSyncA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Ascii version of ReplicaSync. Calls DsReplicaSyncW.

Arguments:

    hDS -
    NameContext -
    pUuidDsaSrc -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;

    status = AllocConvertWide( NameContext, &nameContextW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    status = DsReplicaSyncW( hDS, nameContextW, pUuidDsaSrc, Options );

    if (nameContextW != NULL) {
        LocalFree( nameContextW );
    }

    return status;
} /* DsReplicaSyncA */


NTDSAPI
DWORD
WINAPI
DsReplicaSyncW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Synchronize a naming context with one of its sources.

See comments on ntdsapi.h.

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    pUuidDsaSrc - uuid of one of its sources
    Options - flags which control operation

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPSYNC syncReq;
    DWORD status;
    DSNAME *pName = NULL;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (pUuidDsaSrc == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // Map public options to private dra options

    Options = translateOptions( Options, RepSyncOptionToDra );

    // Initialize Structure

    memset( &syncReq, 0, sizeof( syncReq ) );

    syncReq.V1.pNC = pName;
    syncReq.V1.uuidDsaSrc = *pUuidDsaSrc;
    // pszDsaSrc is Null
    syncReq.V1.ulOptions = Options;

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaSync(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &syncReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR( status );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaSync]"));
    DSLOG((0,"[PA=%ws][PA=%s][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           pUuidDsaSrc ? UuidToStr(pUuidDsaSrc, tmpUuid, sizeof(tmpUuid)/sizeof(tmpUuid[0])) : "NULL",
           Options,
           startTime, GetTickCount(), status))

    LocalFree( pName );

    return status;
} /* DsReplicaSyncW */


NTDSAPI
DWORD
WINAPI
DsReplicaAddA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR SourceDsaDn,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    )

/*++

Routine Description:

Ascii version of ReplicaAdd. Calls DsReplicaAddW.

Arguments:

    hDS -
    NameContext -
    SourceDsaDn -
    TransportDn -
    SourceDsaAddress -
    pSchedule -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;
    LPWSTR sourceDsaDnW = NULL;
    LPWSTR transportDnW = NULL;
    LPWSTR sourceDsaAddressW = NULL;

    if (NameContext) {
        status = AllocConvertWide( NameContext, &nameContextW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (SourceDsaDn) {
        status = AllocConvertWide( SourceDsaDn, &sourceDsaDnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (TransportDn) {
        status = AllocConvertWide( TransportDn, &transportDnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (SourceDsaAddress) {
        status = AllocConvertWide( SourceDsaAddress, &sourceDsaAddressW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaAddW( hDS,
                            nameContextW,
                            sourceDsaDnW,
                            transportDnW,
                            sourceDsaAddressW,
                            pSchedule,
                            Options );

cleanup:
    if (nameContextW) {
        LocalFree( nameContextW );
    }
    if (sourceDsaDnW) {
        LocalFree( sourceDsaDnW );
    }
    if (transportDnW) {
        LocalFree( transportDnW );
    }
    if (sourceDsaAddressW) {
        LocalFree( sourceDsaAddressW );
    }

    return status;
} /* DsReplicaAddA */


NTDSAPI			 
DWORD
WINAPI
DsReplicaAddW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR SourceDsaDn,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    )

/*++

Routine Description:

Add a source to a naming context.

See comments on this routine in ntdsapi.h

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    SourceDsaDn - dn of source's ntds-dsa (settings) object
    TransportDn - dn of transport to be used
    SourceDsaAddress - transport-specific address of source
    pSchedule - schedule when link is available
    Options - controls operation

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPADD addReq;
    DWORD status, version;
    DSNAME *pName = NULL, *pSource = NULL, *pTransport = NULL;
    LPSTR sourceDsaAddressA = NULL;
    REPLTIMES internalSchedule;
#if DBG
    DWORD  startTime = GetTickCount();
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (SourceDsaAddress == NULL) ||
         (wcslen( SourceDsaAddress ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (SourceDsaDn &&
          wcslen( SourceDsaDn ) == 0) ||
         (TransportDn &&
          wcslen( TransportDn ) == 0) ) {
        // prevent empty string processing.
        // (note: this matches return for A routines. see AllocConvertWide)
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext
    // Required
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be Null
    status = AllocBuildDsname( SourceDsaDn, &pSource );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be Null
    status = AllocBuildDsname( TransportDn, &pTransport );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // dsaSrc is in UTF8 multi-byte
    //   - Validate FQ dns name
    //   - Required
    status = DnsValidateName_W( SourceDsaAddress, DnsNameHostnameFull );
    if ( status == ERROR_INVALID_NAME ||
         NULL == wcschr(SourceDsaAddress, L'.') ) {
        // Note: all other possible error codes are valid
        // (see Dns_ValidateName_UTF for more)
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    status = AllocConvertNarrowUTF8( SourceDsaAddress, &sourceDsaAddressA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // pSchedule is optional
    if (pSchedule) {
        status = ConvertScheduleToReplTimes( pSchedule, &internalSchedule );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    // Map public options to private dra options

    Options = translateOptions( Options, RepAddOptionToDra );

    // Initialize the right version Structure
    // If new-style arguments are not present, use old style call.  Server
    // must support both.

    memset( &addReq, 0, sizeof( addReq ) );

    if ( (SourceDsaDn == NULL) && (TransportDn == NULL) ) {
        version = 1;
        addReq.V1.pNC = pName;
        addReq.V1.pszDsaSrc = sourceDsaAddressA;
        if (pSchedule) {   // may be null
            CopyMemory( &(addReq.V1.rtSchedule),
                        &internalSchedule, sizeof( REPLTIMES ) );
        }
        addReq.V1.ulOptions = Options;
    } else {
        version = 2;
        addReq.V2.pNC = pName;
        addReq.V2.pSourceDsaDN = pSource; // may be null
        addReq.V2.pTransportDN = pTransport; // may be null
        addReq.V2.pszSourceDsaAddress = sourceDsaAddressA;
        if (pSchedule) {   // may be null
            CopyMemory( &(addReq.V2.rtSchedule),
                        &internalSchedule, sizeof( REPLTIMES ) );
        }
        addReq.V2.ulOptions = Options;
    }

    // Check if requested version is supported

    if ( (2 == version) &&
       !IS_DRS_REPADD_V2_SUPPORTED(((BindState *) hDS)->pServerExtensions) ) {
        status = ERROR_NOT_SUPPORTED;
        goto cleanup;
    }

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaAdd(
                        ((BindState *) hDS)->hDrs,
                        version,                              // dwInVersion
                        &addReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaAdd]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=%ws][PA=%ws][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           SourceDsaDn ? SourceDsaDn : L"NULL",
           TransportDn ? TransportDn : L"NULL",
           SourceDsaAddress, Options,
           startTime, GetTickCount(), status))

    if (pName) {
        LocalFree( pName );
    }
    if (pSource) {
        LocalFree( pSource );
    }
    if (pTransport) {
        LocalFree( pTransport );
    }
    if (sourceDsaAddressA) {
        LocalFree( sourceDsaAddressA );
    }

    return status;
} /* DsReplicaAddW */


NTDSAPI
DWORD
WINAPI
DsReplicaDelA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Ascii version of ReplicaDel.  Calls ReplicaDelW().

Arguments:

    hDS -
    NameContext -
    DsaSrc -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL, dsaSrcW = NULL;

    if (NameContext) {
        status = AllocConvertWide( NameContext, &nameContextW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (DsaSrc) {
        status = AllocConvertWide( DsaSrc, &dsaSrcW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaDelW( hDS, nameContextW, dsaSrcW, Options );

cleanup:
    if (nameContextW) {
        LocalFree( nameContextW );
    }
    if (dsaSrcW) {
        LocalFree( dsaSrcW );
    }

    return status;
} /* DsReplicaDelA */


NTDSAPI
DWORD
WINAPI
DsReplicaDelW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Delete a source from a naming context.
Source is identified by the transport-specific address.

See comments in ntdsapi.h

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    DsaSrc - transport specific address of source
    Options -

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPDEL delReq;
    DWORD status;
    DSNAME *pName = NULL;
    LPSTR dsaSrcA = NULL;
#if DBG
    DWORD  startTime = GetTickCount();
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext

    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // dsaSrc is in UTF8 multi-byte

    status = AllocConvertNarrowUTF8( DsaSrc, &dsaSrcA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Map public options to private dra options

    Options = translateOptions( Options, RepDelOptionToDra );

    // Initialize Structure

    memset( &delReq, 0, sizeof( delReq ) );

    delReq.V1.pNC = pName;
    delReq.V1.pszDsaSrc = dsaSrcA;
    delReq.V1.ulOptions = Options;

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaDel(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &delReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaDel]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext, DsaSrc, Options,
           startTime, GetTickCount(), status))

    if (pName) {
        LocalFree( pName );
    }
    if (dsaSrcA) {
        LocalFree( dsaSrcA );
    }

    return status;
} /* DsReplicaDelW */


NTDSAPI
DWORD
WINAPI
DsReplicaModifyA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    )

/*++

Routine Description:

Ascii version of ReplicaModify.  Calls ReplicaModifyW().

Arguments:

    hDS -
    NameContext -
    pUuidSourceDsa -
    TransportDn -
    SourceDsaAddress -
    pSchedule -
    ReplicaFlags -
    ModifyFields -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;
    LPWSTR transportDnW = NULL;
    LPWSTR sourceDsaAddressW = NULL;

    if (NameContext) {
        status = AllocConvertWide( NameContext, &nameContextW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (SourceDsaAddress) {
        status = AllocConvertWide( SourceDsaAddress, &sourceDsaAddressW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (TransportDn) {
        status = AllocConvertWide( TransportDn, &transportDnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaModifyW( hDS,
                               nameContextW,
                               pUuidSourceDsa,
                               transportDnW,
                               sourceDsaAddressW,
                               pSchedule,
                               ReplicaFlags,
                               ModifyFields,
                               Options );

cleanup:
    if (nameContextW) {
        LocalFree( nameContextW );
    }
    if (transportDnW) {
        LocalFree( transportDnW );
    }
    if (sourceDsaAddressW) {
        LocalFree( sourceDsaAddressW );
    }

    return status;
} /* DsReplicaModifyA */


NTDSAPI
DWORD
WINAPI
DsReplicaModifyW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    )

/*++

Routine Description:

Modify a source of a naming context.

See comments in ntdsapi.h

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    pUuidSourceDsa - uuid of source dsa
    TransportDn - dn of transport, not supported at moment
    SourceDsaAddress - transport specific address of source
    pSchedule - schedule when link is up
    ReplicaFlags - new flags
    ModifyFields - Which field is to be modified
    Options - operation qualifiers

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPMOD modReq;
    DWORD status;
    DSNAME *pName = NULL, *pTransport = NULL;
    LPSTR sourceDsaAddressA = NULL;
    REPLTIMES internalSchedule;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (ModifyFields == 0) ||
         ( (pUuidSourceDsa == NULL) && (SourceDsaAddress == NULL) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (SourceDsaAddress &&
          wcslen( SourceDsaAddress ) == 0) ||
         (TransportDn &&
          wcslen( TransportDn ) == 0) ) {
        // prevent empty string processing.
        // (note: this matches return for A routines. see AllocConvertWide)
        return ERROR_INVALID_PARAMETER;
    }

    // Note, we cannot restrict which flags are set or cleared at this
    // level because we pass in the after-image of the flags. We cannot
    // distinguish between a flag that is already set (or clear) before
    // and a flag that is being changed by the user.

    // Construct a DSNAME for the NameContext
    // Required
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

#if 1
    // TransportDn is reserved for future use
    // Once happy w/ this should collapse param checkin on this
    // above.
    if (TransportDn != NULL) {
        status = ERROR_NOT_SUPPORTED;
        goto cleanup;
    }
#else
    // May be Null
    status = AllocBuildDsname( TransportDn, &pTransport );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }
#endif

    // Map public Replica Flags
    ReplicaFlags = translateOptions( ReplicaFlags, RepNbrOptionToDra );

    // dsaSrc is in UTF8 multi-byte
    // May be Null
    status = AllocConvertNarrowUTF8( SourceDsaAddress, &sourceDsaAddressA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // pSchedule is optional
    if (pSchedule) {
        status = ConvertScheduleToReplTimes( pSchedule, &internalSchedule );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }
    else if ( ModifyFields & DS_REPMOD_UPDATE_SCHEDULE ) {
        // but isn't if the update_sched option's on.
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Map public ModifyFields

    ModifyFields = translateOptions( ModifyFields, RepModFieldsToDra );


    // Map public options to private dra options

    Options = translateOptions( Options, RepModOptionToDra );




    // Initialize the right version Structure

    memset( &modReq, 0, sizeof( modReq ) );

    modReq.V1.pNC = pName;
    if (pUuidSourceDsa) {   // may be null
        CopyMemory( &(modReq.V1.uuidSourceDRA), pUuidSourceDsa, sizeof(UUID) );
    }
    modReq.V1.pszSourceDRA = sourceDsaAddressA;   // may be null
//    addReq.V2.pTransportDN = pTransport; // may be null
    if (pSchedule) {   // may be null
        CopyMemory( &(modReq.V1.rtSchedule),
                    &internalSchedule, sizeof( REPLTIMES ));
    }
    modReq.V1.ulReplicaFlags = ReplicaFlags;
    modReq.V1.ulModifyFields = ModifyFields;
    modReq.V1.ulOptions = Options;



    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaModify(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &modReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
       
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaModify]"));
    DSLOG((0,"[PA=%ws][PA=%s][PA=%ws][PA=%ws][PA=0x%x][PA=0x%x][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           pUuidSourceDsa ? UuidToStr(pUuidSourceDsa, tmpUuid, sizeof(tmpUuid)/sizeof(tmpUuid[0])) : "NULL",
           TransportDn ? TransportDn : L"NULL",
           SourceDsaAddress ? SourceDsaAddress : L"NULL",
           ReplicaFlags, ModifyFields, Options,
           startTime, GetTickCount(), status))

    if (pName) {
        LocalFree( pName );
    }
#if 0
    if (pTransport) {
        LocalFree( pTransport );
    }
#endif
    if (sourceDsaAddressA) {
        LocalFree( sourceDsaAddressA );
    }

    return status;
} /* DsReplicaModifyW */


NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    )

/*++

Routine Description:

Ascii version of ReplicaUpdateRefs. Calls DsReplicaUpdateRefsW.

Arguments:

    hDS -
    NameContext -
    pUuidDsaSrc -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL, dsaDestW = NULL;

    status = AllocConvertWide( NameContext, &nameContextW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if (DsaDest) {
        status = AllocConvertWide( DsaDest, &dsaDestW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaUpdateRefsW(
        hDS,
        nameContextW,
        dsaDestW,
        pUuidDsaDest,
        Options );

cleanup:

    if (dsaDestW != NULL) {
        LocalFree( dsaDestW );
    }

    if (nameContextW != NULL) {
        LocalFree( nameContextW );
    }

    return status;
} /* DsReplicaUpdateRefsA */


NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    )

/*++

Routine Description:

Add or remove a "replication to" reference for a destination from a source

See comments on ntdsapi.h.

Arguments:
    hDS - bind handle
    NameContext - dn of naming context
    DsaDest - transport-specific address of the destination
    pUuidDsaDest - uuid of one of its destination
    Options - flags which control operation

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_UPDREFS updRefs;
    DWORD status;
    DSNAME *pName = NULL;
    LPSTR dsaDestA = NULL;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (DsaDest == NULL) ||
         (wcslen( DsaDest ) == 0) ||
         (pUuidDsaDest == NULL) ||
         ( (Options & (DRS_ADD_REF|DRS_DEL_REF)) == 0 ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // dsaDest is in UTF8 multi-byte

    status = AllocConvertNarrowUTF8( DsaDest, &dsaDestA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Map public options to private dra options

    Options = translateOptions( Options, UpdRefOptionToDra );

    // Initialize Structure

    memset( &updRefs, 0, sizeof( updRefs ) );

    updRefs.V1.pNC = pName;
    updRefs.V1.pszDsaDest = dsaDestA;
    updRefs.V1.uuidDsaObjDest = *pUuidDsaDest;
    updRefs.V1.ulOptions = Options;

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSUpdateRefs(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &updRefs );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaUpdateRefs]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=%s][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           DsaDest,
           pUuidDsaDest ? UuidToStr(pUuidDsaDest, tmpUuid, sizeof(tmpUuid)/sizeof(tmpUuid[0])) : "NULL",
           Options,
           startTime, GetTickCount(), status))

    LocalFree( pName );

    if (dsaDestA) {
        LocalFree( dsaDestA );
    }

    return status;
} /* DsReplicaSyncW */


NTDSAPI
DWORD
WINAPI
DsReplicaConsistencyCheck(
    IN HANDLE        hDS,
    IN DS_KCC_TASKID TaskID,
    IN DWORD         dwFlags
    )
/*++

Routine Description:

    Force the KCC to run.

Arguments:

    hDS - DS handle returned by a prior call to DsBind*().

    TaskID - A DS_KCC_TASKID_*, as defined in ntdsapi.h.

    dwFlags - One or more DS_KCC_FLAG_* bits, as defined in ntdsapi.h.

Return Value:

    0 on success or Win32 error code on failure.

--*/
{
    DWORD               status;
    DRS_MSG_KCC_EXECUTE msg;
#if DBG
    DWORD  startTime = GetTickCount();
#endif

    if (NULL == hDS) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!IS_DRS_KCC_EXECUTE_V1_SUPPORTED(
            ((BindState *) hDS)->pServerExtensions)) {
        return ERROR_NOT_SUPPORTED;
    }

    // Construct request message.
    msg.V1.dwTaskID = TaskID;
    msg.V1.dwFlags  = dwFlags;

    // Call the server.
    __try {
        status = _IDL_DRSExecuteKCC(((BindState *) hDS)->hDrs, 1, &msg);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR(status);

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaConsistencyCheck]"));
    DSLOG((0,"[PA=0x%x][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           TaskID, dwFlags,
           startTime, GetTickCount(), status))

    return status;
} /* DsReplicaConsistencyCheck */


NTDSAPI
DWORD
WINAPI
DsReplicaGetInfoW(
    IN  HANDLE              hDS,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  LPCWSTR             pszObjectDN,
    IN  UUID *              puuidForSourceDsaObjGuid,
    OUT VOID **             ppInfo
    )
/*++

Routine Description:

    Retrieve replication information (e.g., last replication status with
    neighbors).

Arguments:

    hDS (IN) - DS handle returned by a prior call to DsBind*().

    InfoType (IN) - DS_REPL_INFO_TYPE (public) or DS_REPL_INFO_TYPEP (private)
        enum.

    puuidForSourceDsaObjGuid

Return Value:

    0 on success or Win32 error code on failure.

--*/
{
    return DsReplicaGetInfo2W(hDS,
                              InfoType,
                              pszObjectDN,
                              puuidForSourceDsaObjGuid,
                              NULL,
                              NULL,
                              0,
                              0,
                              ppInfo);
} /* DsReplicaGetInfo */


NTDSAPI
DWORD
WINAPI
DsReplicaGetInfo2W(
    IN  HANDLE              hDS,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  LPCWSTR             pszObjectDN OPTIONAL,
    IN  UUID *              puuidForSourceDsaObjGuid OPTIONAL,
    IN  LPCWSTR             pszAttributeName OPTIONAL,
    IN  LPCWSTR             pszValueDN OPTIONAL,
    IN  DWORD               dwFlags,
    IN  DWORD               dwEnumerationContext,
    OUT VOID **             ppInfo
    )
/*++

Routine Description:

    Retrieve replication information (e.g., last replication status with
    neighbors).

Arguments:

    hDS (IN) - DS handle returned by a prior call to DsBind*().

    InfoType (IN) - DS_REPL_INFO_TYPE (public) or DS_REPL_INFO_TYPEP (private)
        enum.

    pszObjectDN - Either the dn or the guid must be specified

    puuidForSourceDsaObjGuid - 

    pszAttributeName - Attribute name

    pszObjectDN - Particular dn from a set that is desired

    dwEnumerationContext - 0 first time, or previous value

    dwFlags - Not used

    ppInfo - Returned info

Return Value:

    WINAPI - 

--*/
{
    DWORD                   status;
    DRS_MSG_GETREPLINFO_REQ MsgIn = {0};
    DWORD                   dwInVersion;
    DWORD                   dwOutVersion;
    DRS_EXTENSIONS *        pExt = hDS ? ((BindState *) hDS)->pServerExtensions : NULL;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    if ((NULL == hDS)
        || (NULL == ppInfo)
        || (((ULONG) InfoType >= DS_REPL_INFO_TYPE_MAX)
            && ((ULONG) InfoType <= DS_REPL_INFO_TYPEP_MIN))) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pszObjectDN &&
         (wcslen( pszObjectDN ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pszAttributeName &&
         (wcslen( pszAttributeName ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pszValueDN &&
         (wcslen( pszValueDN ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Does server support this info type?
    switch (InfoType) {
    case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
    case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
        if (!IS_DRS_GET_REPL_INFO_KCC_DSA_FAILURES_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Win2k RC1 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_PENDING_OPS:
        if (!IS_DRS_GET_REPL_INFO_PENDING_SYNCS_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Win2k RC1 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
        if (!IS_DRS_GET_REPL_INFO_METADATA_FOR_ATTR_VALUE_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 1 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_CURSORS_2_FOR_NC:
        if (!IS_DRS_GET_REPL_INFO_CURSORS_2_FOR_NC_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;
    
    case DS_REPL_INFO_CURSORS_3_FOR_NC:
        if (!IS_DRS_GET_REPL_INFO_CURSORS_3_FOR_NC_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_METADATA_2_FOR_OBJ:
        if (!IS_DRS_GET_REPL_INFO_METADATA_2_FOR_OBJ_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;
    
    case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
        if (!IS_DRS_GET_REPL_INFO_METADATA_2_FOR_ATTR_VALUE_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    default:
        if (!IS_DRS_GET_REPL_INFO_SUPPORTED(pExt)) {
            // Server does not support this API.
            return ERROR_NOT_SUPPORTED;
        }
        break;
    }
    
    // Build our request.
    if ((NULL != pszAttributeName)
        || (NULL != pszValueDN)
        || (0 != dwFlags)
        || (0 != dwEnumerationContext)) {
        // Requires V2 message to describe request.
        dwInVersion = 2;
    
        MsgIn.V2.InfoType    = InfoType;
        MsgIn.V2.pszObjectDN = (LPWSTR) pszObjectDN;
    
        if (NULL != puuidForSourceDsaObjGuid) {
            MsgIn.V2.uuidSourceDsaObjGuid = *puuidForSourceDsaObjGuid;
        }
    
        MsgIn.V2.ulFlags = dwFlags;
        MsgIn.V2.pszAttributeName = (LPWSTR) pszAttributeName;
        MsgIn.V2.pszValueDN = (LPWSTR) pszValueDN;
        MsgIn.V2.dwEnumerationContext = dwEnumerationContext;
    } else {
        // Can describe with V1 request.
        dwInVersion = 1;
        
        MsgIn.V1.InfoType    = InfoType;
        MsgIn.V1.pszObjectDN = (LPWSTR) pszObjectDN;
    
        if (NULL != puuidForSourceDsaObjGuid) {
            MsgIn.V1.uuidSourceDsaObjGuid = *puuidForSourceDsaObjGuid;
        }
    }

    if ((2 == dwInVersion) && !IS_DRS_GET_REPL_INFO_REQ_V2_SUPPORTED(pExt)) {
        // Server does not support these extensions -- i.e., < Whistler Beta 1 DC.
        return ERROR_NOT_SUPPORTED;
    }

    // Call the server.
    *ppInfo = NULL;
    __try {
        status = _IDL_DRSGetReplInfo(((BindState *) hDS)->hDrs,
                                    dwInVersion,
                                    &MsgIn,
                                    &dwOutVersion,
                                    (DRS_MSG_GETREPLINFO_REPLY *) ppInfo);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
       
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR(status);

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaGetInfo2]"));
    DSLOG((0,"[PA=0x%x][PA=%ws][PA=%s][PA=%ws][PA=%ws][PA=0x%x][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           InfoType,
           pszObjectDN ? pszObjectDN : L"NULL",
           puuidForSourceDsaObjGuid ? UuidToStr(puuidForSourceDsaObjGuid, tmpUuid, sizeof(tmpUuid)/sizeof(tmpUuid[0])) : "NULL",
           pszAttributeName ? pszAttributeName : L"NULL",
           pszValueDN ? pszValueDN : L"NULL",
           dwFlags,
           dwEnumerationContext,
           startTime, GetTickCount(), status));

    return status;
} /* DsReplicaGetInfo2W */


NTDSAPI
VOID
WINAPI
DsReplicaFreeInfo(
    DS_REPL_INFO_TYPE   InfoType,
    VOID *              pInfo
    )
/*++

Routine Description:

    Free a structure returned by a prior call to DsReplicaGetInfo().

Arguments:

    pInfo (IN) - Structure to free.

Return Value:

    None.

--*/
{
    if (NULL != pInfo) {
#define FREE(x) if (NULL != x) MIDL_user_free(x)

        DS_REPL_NEIGHBORSW *              pNeighbors;
        DS_REPL_OBJ_META_DATA *           pObjMetaData;
        DS_REPL_KCC_DSA_FAILURES *        pFailures;
        DS_REPL_PENDING_OPSW *            pPendingOps;
        DS_REPL_ATTR_VALUE_META_DATA *    pAttrValueMetaData;
        DS_REPL_CURSORS_3W *              pCursors3;
        DS_REPL_OBJ_META_DATA_2 *         pObjMetaData2;
        DS_REPL_ATTR_VALUE_META_DATA_2 *  pAttrValueMetaData2;
        DS_REPL_SERVER_OUTGOING_CALLS *   pCalls;
        DWORD                             i;

        // 98-10-29 JeffParh
        // RPC started stomping past the ned of its memory allocations when I
        // began using allocate(all_nodes) for these structures.  So we're
        // going to have to walk all the embedded pointers and free each one
        // individually.  Fun, eh? :-)

        switch (InfoType) {
        case DS_REPL_INFO_NEIGHBORS:
        case DS_REPL_INFO_REPSTO:
            pNeighbors = (DS_REPL_NEIGHBORSW *) pInfo;
            for (i = 0; i < pNeighbors->cNumNeighbors; i++) {
                FREE(pNeighbors->rgNeighbor[i].pszNamingContext);
                FREE(pNeighbors->rgNeighbor[i].pszSourceDsaDN);
                FREE(pNeighbors->rgNeighbor[i].pszSourceDsaAddress);
                FREE(pNeighbors->rgNeighbor[i].pszAsyncIntersiteTransportDN);
            }
            break;

        case DS_REPL_INFO_CURSORS_FOR_NC:
        case DS_REPL_INFO_CURSORS_2_FOR_NC:
        case DS_REPL_INFO_CLIENT_CONTEXTS:
            // No embedded pointers.
            break;

        case DS_REPL_INFO_METADATA_FOR_OBJ:
            pObjMetaData = (DS_REPL_OBJ_META_DATA *) pInfo;
            for (i = 0; i < pObjMetaData->cNumEntries; i++) {
                FREE(pObjMetaData->rgMetaData[i].pszAttributeName);
            }
            break;

        case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
        case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
            pFailures = (DS_REPL_KCC_DSA_FAILURES *) pInfo;
            for (i = 0; i < pFailures->cNumEntries; i++) {
                FREE(pFailures->rgDsaFailure[i].pszDsaDN);
            }
            break;

        case DS_REPL_INFO_PENDING_OPS:
            pPendingOps = (DS_REPL_PENDING_OPSW *) pInfo;
            for (i = 0; i < pPendingOps->cNumPendingOps; i++) {
                FREE(pPendingOps->rgPendingOp[i].pszNamingContext);
                FREE(pPendingOps->rgPendingOp[i].pszDsaDN);
                FREE(pPendingOps->rgPendingOp[i].pszDsaAddress);
            }
            break;

        case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
            pAttrValueMetaData = (DS_REPL_ATTR_VALUE_META_DATA *) pInfo;
            for (i = 0; i < pAttrValueMetaData->cNumEntries; i++) {
                FREE(pAttrValueMetaData->rgMetaData[i].pszObjectDn);
                FREE(pAttrValueMetaData->rgMetaData[i].pbData);
            }
            break;

        case DS_REPL_INFO_CURSORS_3_FOR_NC:
            pCursors3 = (DS_REPL_CURSORS_3W *) pInfo;
            for (i = 0; i < pCursors3->cNumCursors; i++) {
                FREE(pCursors3->rgCursor[i].pszSourceDsaDN);
            }
            break;

        case DS_REPL_INFO_METADATA_2_FOR_OBJ:
            pObjMetaData2 = (DS_REPL_OBJ_META_DATA_2 *) pInfo;
            for (i = 0; i < pObjMetaData2->cNumEntries; i++) {
                FREE(pObjMetaData2->rgMetaData[i].pszAttributeName);
                FREE(pObjMetaData2->rgMetaData[i].pszLastOriginatingDsaDN);
            }
            break;

        case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
            pAttrValueMetaData2 = (DS_REPL_ATTR_VALUE_META_DATA_2 *) pInfo;
            for (i = 0; i < pAttrValueMetaData2->cNumEntries; i++) {
                FREE(pAttrValueMetaData2->rgMetaData[i].pszObjectDn);
                FREE(pAttrValueMetaData2->rgMetaData[i].pbData);
                FREE(pAttrValueMetaData2->rgMetaData[i].pszLastOriginatingDsaDN);
            }
            break;

        case DS_REPL_INFO_SERVER_OUTGOING_CALLS:
            pCalls = (DS_REPL_SERVER_OUTGOING_CALLS *) pInfo;
            for (i = 0; i < pCalls->cNumCalls; i++) {
                FREE(pCalls->rgCall[i].pszServerName);
            }
            break;

	default:

            Assert(!"Unknown DS_REPLICA_INFO type!");
            break;
        }
#undef FREE

        MIDL_user_free(pInfo);
    }
} /* DsReplicaFreeInfo */



NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG ulOptions
    )

/*++

Routine Description:

Verify all objects for an NC with a source.

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    pUuidDsaSrc - uuid of the source
    ulOptions - 
    
Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPVERIFYOBJ msgRepVerify;
    DWORD status;
    DSNAME *pName = NULL;

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (pUuidDsaSrc == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!IS_DRS_REPLICA_VERIFY_OBJECT_V1_SUPPORTED(
	((BindState *) hDS)->pServerExtensions)) {
	return ERROR_NOT_SUPPORTED;
    }

    // Construct a DSNAME for the NameContext
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // Initialize Structure

    memset( &msgRepVerify, 0, sizeof( msgRepVerify ) );

    msgRepVerify.V1.pNC = pName;
    msgRepVerify.V1.uuidDsaSrc = *pUuidDsaSrc;
    msgRepVerify.V1.ulOptions = ulOptions;

    // Call the server

    __try
    {
        status = _IDL_DRSReplicaVerifyObjects(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &msgRepVerify );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
         
	status = RpcExceptionCode(); 
	HandleClientRpcException(status, &hDS);

    }

    MAP_SECURITY_PACKAGE_ERROR( status );

    LocalFree( pName );

    return status;
} /* DsReplicaVerifyObjectsW */


NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG ulOptions
    )

/*++

Routine Description:

Ascii version of ReplicaVerifyObjects. Calls DsReplicaVerifyObjectsW.

Arguments:

    hDS -
    NameContext -
    pUuidDsaSrc -
    dwFlags -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;

    status = AllocConvertWide( NameContext, &nameContextW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    status = DsReplicaVerifyObjectsW( hDS, nameContextW, pUuidDsaSrc, ulOptions );

    if (nameContextW != NULL) {
        LocalFree( nameContextW );
    }

    return status;
} /* DsReplicaVerifyObjectsA */


DWORD
translateOptions(
    DWORD PublicOptions,
    POPTION_TRANSLATION Table
    )

/*++

Routine Description:

Utility routine to translate options.

Performs a simple list lookup.

ENHANCEMENT: if the tables were sorted, we could do a binary search

Arguments:

    PublicOptions -
    Table -

Return Value:

    DWORD -

--*/

{
    DWORD i, internalOptions;

    internalOptions = 0;
    for( i = 0; 0 != Table[i].PublicOption; i++ ) {
        if (PublicOptions & Table[i].PublicOption) {
            internalOptions |= Table[i].InternalOption;
        }
    }

    return internalOptions;
} /* translateOptions */

#if WIN95 || WINNT4

//
// *** COPIED FROM dscommon/dsutil.c ***
//

UUID gNullUuid = {0,0,0,{0,0,0,0,0,0,0,0}};

// Return TRUE if the ptr to the UUID is NULL, or the uuid is all zeroes

BOOL fNullUuid (const UUID *pUuid)
{
    if (!pUuid) {
        return TRUE;
    }

    if (memcmp (pUuid, &gNullUuid, sizeof (UUID))) {
        return FALSE;
    }
    return TRUE;
}

#if DBG
#define DSUTIL_STR_TOO_SHORT(sz, cch)   Assert(!"Buffer too small");
                                        if((cch)>0){ \
                                            (sz)[0] = '\0'; \
                                        }
UCHAR * UuidToStr(CONST UUID* pUuid, UCHAR *pOutUuid, ULONG cchOutUuid)
{
    int i;
    unsigned char * pchar;

    if (!fNullUuid (pUuid)) {
        pchar = (char*) pUuid;

        for (i=0;i < sizeof(UUID);i++) {
             hr = StringCchPrintf(&(pOutUuid[i*2]),
                                  cchOutUuid - (i*2),
                                  "%.2x", 
                                  (*(pchar++)) );
             if (hr) {
                 DSUTIL_STR_TOO_SHORT(pOutUuid, cchOutUuid);
                 return(pOutUuid);
             }
        }
    } else {
        if (sizeof(UUID)*2+1 > cchOutUuid) {
            DSUTIL_STR_TOO_SHORT(pOutUuid, cchOutUuid);
            return(pOutUuid);
        }   
        memset (pOutUuid, '0', sizeof(UUID)*2);
        pOutUuid[sizeof(UUID)*2] = 0;
    }
    return pOutUuid;
}
#endif
#endif

/* end replica.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\tlog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tlog.c

Abstract:

    Routines dealing with ds logging

Author:

    Johnson Apacible    (JohnsonA)  23-Oct-1998

--*/

#include <windows.h>
#include <winsock.h>
#include <winerror.h>
#include <rpc.h>            // RPC defines
#include <stdlib.h>         // atoi, itoa
#include <dststlog.h>
#include <tlog.h>           // ds logging

// DsLogEntry is supported on chk'ed builds of w2k or greater
#if DBG && !WIN95 && !WINNT4

CRITICAL_SECTION csLogFile;
BOOL fInitializedLogCS = FALSE;
BOOL LogFileOpened = FALSE;

//
// from dscommon\filelog.c
//

VOID
DsPrintRoutineV(
    IN DWORD Flags,
    IN LPSTR Format,
    va_list arglist
    );

BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName,
    IN BOOL fCheckDSLOGMarker
    );

VOID
DsCloseLogFile(
    VOID
    );

BOOL
DsLogEntry(
    IN DWORD    Flags,
    IN LPSTR    Format,
    ...
    )
{
    va_list arglist;
    static BOOL fLogFileOpened = FALSE;

    if ( !fInitializedLogCS ) {
        return FALSE;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &csLogFile );
    __try{

        if ( !fLogFileOpened ) {
            fLogFileOpened = DsOpenLogFile("ds", NULL, TRUE);
        }
    
        //
        // Simply change arguments to va_list form and call DsPrintRoutineV
        //
    
        va_start(arglist, Format);
    
        DsPrintRoutineV( Flags, Format, arglist );
    
        va_end(arglist);
    }
    __finally{  
        LeaveCriticalSection( &csLogFile );
    }

    
    return TRUE;
}


VOID
InitDsLog(
    VOID
    )
{
    fInitializedLogCS = InitializeCriticalSectionAndSpinCount(&csLogFile,400);
    pfnDsPrintLog=(DS_PRINTLOG)DsLogEntry;
    return;
} // InitDsLog

VOID
TermDsLog(
    VOID
    )
{
    if (fInitializedLogCS) {
        if (LogFileOpened) {
            DsCloseLogFile();
        }
        LogFileOpened = FALSE;
        DeleteCriticalSection(&csLogFile);
        fInitializedLogCS = FALSE;
        pfnDsPrintLog=(DS_PRINTLOG)NULL;
    }
    return;
} // TermDsLog

//
// -----
// NOT SUPPORTED IN WIN95 AND WINNT4
// -----
//
#else DBG && !WIN95 && !WINNT4
BOOL
DsLogEntry(
    IN DWORD    Flags,
    IN LPSTR    Format,
    ...
    )
{
#if !WIN95 && !WINNT4
    return TRUE;
#else
    return FALSE;
#endif
}
#endif DBG && !WIN95 && !WINNT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\dllentry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllentry.c

Abstract:

    This file contains DLL entry point code.

Author:

    DaveStr     12-Mar-99

Environment:

    User Mode - Win32

Revision History:

--*/

#include "samclip.h"

DWORD gTlsIndex = 0xFFFFFFFF;

BOOL InitializeDll(
    IN  HINSTANCE hdll,
    IN  DWORD     dwReason,
    IN  LPVOID    lpReserved
    )
{
    UNREFERENCED_PARAMETER(hdll);
    UNREFERENCED_PARAMETER(lpReserved);

    if ( DLL_PROCESS_ATTACH  == dwReason )
    {
        gTlsIndex = TlsAlloc();

        if ( (0xFFFFFFFF == gTlsIndex) || !TlsSetValue(gTlsIndex, NULL) )
        {
            gTlsIndex = 0xFFFFFFFF;
            return(FALSE);
        }
    }
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        if ( 0xFFFFFFFF != gTlsIndex )
        {
            TlsFree(gTlsIndex);
            gTlsIndex = 0xFFFFFFFF;
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\util.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Private definitions inside ntdsapi.dll

Author:

    Will Lees (wlees) 02-Feb-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _PRIVATE_
#define _PRIVATE_

#include <bind.h>

#define OFFSET(s,m) \
    ((size_t)((BYTE*)&(((s*)0)->m)-(BYTE*)0))

#define NUMBER_ELEMENTS( A ) ( sizeof( A ) / sizeof( A[0] ) )

// util.c

DWORD
InitializeWinsockIfNeeded(
    VOID
    );

VOID
TerminateWinsockIfNeeded(
    VOID
    );

DWORD
AllocConvertWide(
    IN LPCSTR StringA,
    OUT LPWSTR *pStringW
    );

DWORD
AllocConvertWideBuffer(
    IN  DWORD   LengthA,
    IN  PCCH    BufferA,
    OUT PWCHAR  *OutBufferW
    );

DWORD
AllocConvertNarrow(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocConvertNarrowUTF8(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocBuildDsname(
    IN LPCWSTR StringDn,
    OUT DSNAME **ppName
    );

DWORD
ConvertScheduleToReplTimes(
    PSCHEDULE pSchedule,
    REPLTIMES *pReplTimes
    );

// Check if the RPC excption code implies that the server
// may not be reachable. A subsequent call to DsUnbind
// will not attempt the unbind at the server. An unreachable
// server may take many 10's of seconds to timeout
// and we wouldn't want to punish correctly behaving
// apps that are attempting an unbind after a failing
// server call; eg, DsCrackNames.
//
// The server-side RPC will eventually issue a
// callback to our server code that will effectivly
// unbind at the server.
#define CHECK_RPC_SERVER_NOT_REACHABLE(_hDS_, _dwErr_) \
    (((BindState *) (_hDS_))->bServerNotReachable = \
    ((_dwErr_) == RPC_S_SERVER_UNAVAILABLE \
     || (_dwErr_) == RPC_S_CALL_FAILED \
     || (_dwErr_) == RPC_S_CALL_FAILED_DNE \
     || (_dwErr_) == RPC_S_OUT_OF_MEMORY))

VOID
HandleClientRpcException(
    DWORD    dwErr,
    HANDLE * phDs
    );

HMODULE NtdsapiLoadLibraryHelper(
    WCHAR * szDllName
    );

#endif /* _PRIVATE_ */

/* end private.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\samrpc_c_stub.c ===
#include "samrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    wrappers.c

Abstract:

    This file contains all SAM rpc binding routines.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"
#include <rpcasync.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

RPC_BINDING_HANDLE
PSAMPR_SERVER_NAME_bind (
    PSAMPR_SERVER_NAME ServerName
    )

/*++

Routine Description:

    This routine calls a common bind routine that is shared by all services.
    This routine is called from SamConnect server stub to connect to the
    server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_BINDING_HANDLE          BindingHandle = NULL;
    WCHAR                       *StringBinding = NULL;
    DWORD                       dwErr;
    RPC_SECURITY_QOS            qos;
    TlsInfo                     *pTlsInfo;

    if (    (pTlsInfo = (TlsInfo *) TlsGetValue(gTlsIndex))
         && pTlsInfo->Creds )
    {
        RpcTryExcept
        {
            if ( 0 == wcsncmp(ServerName, L"\\\\", 2) )
            {
                ServerName += 2;
            }

            dwErr = RpcStringBindingComposeW(
                                    NULL,
                                    L"ncacn_ip_tcp",
                                    ServerName,
                                    NULL,
                                    NULL,
                                    &StringBinding);

            if ( RPC_S_OK == dwErr )
            {
                dwErr = RpcBindingFromStringBindingW(
                                    StringBinding,
                                    &BindingHandle);

                if ( RPC_S_OK == dwErr )
                {
                    dwErr = RpcEpResolveBinding(
                                    BindingHandle,
                                    samr_ClientIfHandle);

                    if ( RPC_S_OK == dwErr )
                    {
                        qos.Version = RPC_C_SECURITY_QOS_VERSION;
                        qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
                        qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
                        qos.ImpersonationType = RPC_C_IMP_LEVEL_DEFAULT;
                        
                        dwErr = RpcBindingSetAuthInfoExW(
                                    BindingHandle,
                                    (pTlsInfo->Spn) ? pTlsInfo->Spn 
                                                    : L"samr",
                                    RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                                    (pTlsInfo->Spn) ? RPC_C_AUTHN_GSS_NEGOTIATE
                                                    : RPC_C_AUTHN_WINNT,
                                    pTlsInfo->Creds,
                                    0,
                                    &qos);
                    }
                }
            }
        } 
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
            dwErr = RpcExceptionCode();
        }
        RpcEndExcept;

        if ( dwErr && BindingHandle )
        {
            RpcBindingFree(&BindingHandle);
        }

        if ( StringBinding )
        {
            RpcStringFreeW(&StringBinding);
        }
    }
    else
    {
        dwErr =  RpcpBindRpc(ServerName, L"samr", 0, &BindingHandle);

        if ( dwErr && BindingHandle )
        {
            RpcpUnbindRpc(BindingHandle);
            BindingHandle = NULL;
        }
    }

    return(BindingHandle);
}


void
PSAMPR_SERVER_NAME_unbind (
    PSAMPR_SERVER_NAME ServerName,
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.

    This routine is called from the SamConnect client stub to
    unbind from the SAM client.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);     // This parameter is not used


    RpcpUnbindRpc ( BindingHandle );
    return;
}

RPC_BINDING_HANDLE
SampSecureBind(
    LPWSTR ServerName,
    ULONG AuthnLevel
    )

/*++

Routine Description:

    This routine calls a common bind routine that is shared by all services.
    This routine is called from SamConnect server stub to connect to the
    server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

    AuthnLevel - Authentication level to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_BINDING_HANDLE  BindingHandle = NULL;
    RPC_STATUS          RpcStatus;

#if 1
    RpcpBindRpc (  ServerName,
                   L"samr",
                   0,
                   &BindingHandle
                   );
#else
    LPWSTR StringBinding;
    RpcStatus = RpcStringBindingComposeW(
                    0,
                    L"ncacn_spx",
                    ServerName+2,
                    NULL,           // dynamic endpoint
                    NULL,           // no options
                    &StringBinding
                    );
    if (RpcStatus != 0)
    {
        return(NULL);
    }
    RpcStatus = RpcBindingFromStringBindingW(
                    StringBinding,
                    &BindingHandle
                    );
    RpcStringFreeW(&StringBinding);

#endif


    if ( (BindingHandle != NULL) &&
         (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE) ) {

        RpcStatus = RpcBindingSetAuthInfoW(
                        BindingHandle,
                        NULL,               // server principal name
                        AuthnLevel,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        RPC_C_AUTHZ_DCE
                        );
        if (RpcStatus != 0) {
            RpcBindingFree(&BindingHandle);
        }

    }



    return( BindingHandle);
}



void
SampSecureUnbind (
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.

    This routine is called from the SamConnect client stub to
    unbind from the SAM client.


Arguments:

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{


    RpcpUnbindRpc ( BindingHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsapi\win95\apibuff.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    apibuff.c

Abstract:

    Implementation of NetApiBufferFree since it isn't supplied on Win95.
    See also private\net\api\apibuff.c.

Author:

    DaveStr     10-Dec-97

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <align.h>
#include <rpc.h>
#include <rpcndr.h>         // MIDL_user_free()

NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    )
{
    if ( NULL == Buffer )
    {
        return(NO_ERROR);
    }

    if ( !POINTER_IS_ALIGNED(Buffer, ALIGN_WORST) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    MIDL_user_free(Buffer);

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\samclip.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samclip.h

Abstract:

    This file contains definitions needed by SAM client stubs.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _NTSAMP_CLIENT_
#define _NTSAMP_CLIENT_




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <rpc.h>        // DataTypes and runtime APIs
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // LocalAlloc
//#include <winbase.h>    // LocalAlloc

#include <string.h>     // strlen
#include <stdio.h>      // sprintf
//#include <tstring.h>    // Unicode string macros

#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <samrpc_c.h>   // midl generated client SAM RPC definitions
#include <lmcons.h>     // To get LM password length
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>      // for LsaOpenPolicy...
#include <rc4.h>        // rc4, rc4_key
#include <rpcndr.h>     // RpcSsDestroyContext




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Defines                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// data types                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _TlsInfo {
    RPC_AUTH_IDENTITY_HANDLE    Creds;
    PWCHAR                      Spn;
    BOOL                        fDstIsW2K;
} TlsInfo;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Prototypes                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern DWORD gTlsIndex;

void
SampSecureUnbind (
    RPC_BINDING_HANDLE BindingHandle
    );

RPC_BINDING_HANDLE
SampSecureBind(
    LPWSTR ServerName,
    ULONG AuthnLevel
    );

NTSTATUS
SamiEncryptPasswords(
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    OUT PBOOLEAN LmPresent,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
    );

NTSTATUS
SampCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    );

NTSTATUS
SampRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
    );

#endif // _NTSAMP_CLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\password.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wrappers.c

Abstract:

    This file contains all SAM rpc wrapper routines.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"


NTSTATUS
SampRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
)
/*++

Routine Description:

    This routine fills a buffer with random data.

Parameters:

    BufferSize - Length of the input buffer, in bytes.

    Buffer - Input buffer to be filled with random data.

Return Values:

    Errors from NtQuerySystemTime()


--*/
{
    if(RtlGenRandom( Buffer, BufferSize ))
    {
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
SampCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    )

/*++

Routine Description:

    This service converts an NT password into a LM password.

Parameters:

    NtPassword - The Nt password to be converted.

    LmPasswordBuffer - On successful return, points at the LM password
                The buffer should be freed using MIDL_user_free

Return Values:

    STATUS_SUCCESS - LMPassword contains the LM version of the password.

    STATUS_NULL_LM_PASSWORD - The password is too complex to be represented
        by a LM password. The LM password returned is a NULL string.


--*/
{

#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)

    NTSTATUS       NtStatus;
    ANSI_STRING    LmPassword;

    //
    // Prepare for failure
    //

    *LmPasswordBuffer = NULL;


    //
    // Compute the Ansi version to the Unicode password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

    LmPassword.Buffer = MIDL_user_allocate(LM_BUFFER_LENGTH);
    if (LmPassword.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
    RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    NtStatus = RtlUpcaseUnicodeStringToOemString( &LmPassword, NtPassword, FALSE );


    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // The password is longer than the max LM password length
        //

        NtStatus = STATUS_NULL_LM_PASSWORD; // Informational return code
        RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    }




    //
    // Return a pointer to the allocated LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        *LmPasswordBuffer = LmPassword.Buffer;

    } else {

        MIDL_user_free(LmPassword.Buffer);
    }

    return(NtStatus);
}


NTSTATUS
SamiEncryptPasswords(
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    OUT PBOOLEAN LmPresent,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
)
/*++

Routine Description:

    This routine takes old and new cleartext passwords, converts them to
    LM passwords, generates OWF passwords, and produces reversibly
    encrypted cleartext and OWF passwords.

Arguments:

    OldPassword - The current cleartext password for the user.

    NewPassword - The new cleartext password for the user.

    NewEncryptedWithOldNt - The new password, in an SAMPR_USER_PASSWORD
        structure, reversibly encrypted with the old NT OWF password.

    OldNtOwfEncryptedWithNewNt - The old NT OWF password reversibly
        encrypted with the new NT OWF password.

    LmPresent - Indicates whether or not LM versions of the passwords could
        be calculated.

    NewEncryptedWithOldLm - The new password, in an SAMPR_USER_PASSWORD
        structure, reversibly encrypted with the old LM OWF password.

    OldLmOwfEncryptedWithNewNt - The old LM OWF password reversibly
        encrypted with the new NT OWF password.


Return Value:

    Errors from RtlEncryptXXX functions

--*/
{
    PCHAR OldLmPassword = NULL;
    PCHAR NewLmPassword = NULL;
    LM_OWF_PASSWORD OldLmOwfPassword;
    NT_OWF_PASSWORD OldNtOwfPassword;
    NT_OWF_PASSWORD NewNtOwfPassword;
    PSAMPR_USER_PASSWORD NewNt = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldNt;
    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;
    struct RC4_KEYSTRUCT Rc4Key;
    NTSTATUS NtStatus;
    BOOLEAN OldLmPresent = TRUE;
    BOOLEAN NewLmPresent = TRUE;


    //
    // Initialization
    //

    *LmPresent = TRUE;

    //
    // Make sure the password isn't too long.
    //

    if (NewPassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Calculate the LM passwords. This may fail because the passwords are
    // too complex, but we can deal with that, so just remember what failed.
    //

    NtStatus = SampCalculateLmPassword(
                OldPassword,
                &OldLmPassword
                );

    if (NtStatus != STATUS_SUCCESS) {
        OldLmPresent = FALSE;
        *LmPresent = FALSE;

        //
        // If the error was that it couldn't calculate the password, that
        // is o.k.
        //

        if (NtStatus == STATUS_NULL_LM_PASSWORD) {
            NtStatus = STATUS_SUCCESS;
        }

    }



    //
    // Calculate the LM OWF passwords
    //

    if (NT_SUCCESS(NtStatus) && OldLmPresent) {
        NtStatus = RtlCalculateLmOwfPassword(
                    OldLmPassword,
                    &OldLmOwfPassword
                    );
    }


    //
    // Calculate the NT OWF passwords
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlCalculateNtOwfPassword(
                    OldPassword,
                    &OldNtOwfPassword
                    );
    }

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlCalculateNtOwfPassword(
                    NewPassword,
                    &NewNtOwfPassword
                    );
    }

    //
    // Calculate the encrypted old passwords
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                    &OldNtOwfPassword,
                    &NewNtOwfPassword,
                    OldNtOwfEncryptedWithNewNt
                    );
    }

    //
    // Compute the encrypted old LM password.  Always use the new NT OWF
    // to encrypt it, since we may not have a new LM OWF password.
    //


    if (NT_SUCCESS(NtStatus) && OldLmPresent) {
        ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

        NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                    &OldLmOwfPassword,
                    (PLM_OWF_PASSWORD) &NewNtOwfPassword,
                    OldLmOwfEncryptedWithNewNt
                    );
    }

    //
    // Calculate the encrypted new passwords
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(sizeof(SAMPR_ENCRYPTED_USER_PASSWORD) == sizeof(SAMPR_USER_PASSWORD));

        //
        // Compute the encrypted new password with NT key.
        //

        rc4_key(
            &Rc4Key,
            NT_OWF_PASSWORD_LENGTH,
            (PUCHAR) &OldNtOwfPassword
            );

        RtlCopyMemory(
            ((PUCHAR) NewNt->Buffer) +
                SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR) -
                NewPassword->Length,
            NewPassword->Buffer,
            NewPassword->Length
            );

        *(ULONG UNALIGNED *) &NewNt->Length = NewPassword->Length;

        //
        // Fill the rest of the buffer with random numbers
        //

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        NewPassword->Length,
                    (PUCHAR) NewNt->Buffer
                    );
    }

    if (NT_SUCCESS(NtStatus))
    {
        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewEncryptedWithOldNt
            );

    }

    //
    // Compute the encrypted new password with LM key if it exists.
    //


    if (NT_SUCCESS(NtStatus) && OldLmPresent) {

        rc4_key(
            &Rc4Key,
            LM_OWF_PASSWORD_LENGTH,
            (PUCHAR) &OldLmOwfPassword
            );

        RtlCopyMemory(
            ((PUCHAR) NewLm->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                NewPassword->Length,
            NewPassword->Buffer,
            NewPassword->Length
            );

        *(ULONG UNALIGNED *) &NewLm->Length = NewPassword->Length;

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        NewPassword->Length,
                    (PUCHAR) NewLm->Buffer
                    );


    }

    //
    // Encrypt the password (or, if the old LM OWF password does not exist,
    // zero it).

    if (NT_SUCCESS(NtStatus) && OldLmPresent) {

        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewEncryptedWithOldLm
            );

    } else {
        RtlZeroMemory(
            NewLm,
            sizeof(SAMPR_ENCRYPTED_USER_PASSWORD)
            );
    }



    //
    // Make sure to zero the passwords before freeing so we don't have
    // passwords floating around in the page file.
    //

    if (OldLmPassword != NULL) {

        RtlZeroMemory(
            OldLmPassword,
            lstrlenA(OldLmPassword)
            );

        MIDL_user_free(OldLmPassword);
    }


    return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\tchgpwd.c ===
// Test changing a SAM password



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>


VOID
main (argc, argv)
int argc;
char **argv;

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PSID                        DomainSid = NULL;
    PULONG                      UserId = NULL;
    PSID_NAME_USE               NameUse = NULL;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    SAM_HANDLE                  UserHandle = NULL;
    WCHAR                       UserNameBuffer[80];
    WCHAR                       OldPasswordBuffer[80];
    WCHAR                       NewPasswordBuffer[80];
    UNICODE_STRING              UserName;
    UNICODE_STRING              Domain;
    UNICODE_STRING              OldPassword;
    UNICODE_STRING              NewPassword;
    ANSI_STRING                 AnsiString;

    UserName.Buffer = UserNameBuffer;
    UserName.MaximumLength = sizeof(UserNameBuffer);

    OldPassword.Buffer = OldPasswordBuffer;
    OldPassword.MaximumLength = sizeof(OldPasswordBuffer);

    NewPassword.Buffer = NewPasswordBuffer;
    NewPassword.MaximumLength = sizeof(NewPasswordBuffer);

    RtlInitUnicodeString(&Domain, L"Account");


    RtlInitAnsiString(&AnsiString, argv[1]);
    RtlAnsiStringToUnicodeString(&UserName, &AnsiString, FALSE);

    if (*(argv[2]) == '-') {
        *(argv[2]) = 0;
    }
    RtlInitAnsiString(&AnsiString, argv[2]);
    RtlAnsiStringToUnicodeString(&OldPassword, &AnsiString, FALSE);

    if (*(argv[3]) == '-') {
        *(argv[3]) = 0;
    }
    RtlInitAnsiString(&AnsiString, argv[3]);
    RtlAnsiStringToUnicodeString(&NewPassword, &AnsiString, FALSE);

    //
    // Setup ObjectAttributes for SamConnect call.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQos;

    SecurityQos.Length = sizeof(SecurityQos);
    SecurityQos.ImpersonationLevel = SecurityIdentification;
    SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SecurityQos.EffectiveOnly = FALSE;

    Status = SamConnect(
                 NULL,
                 &SamHandle,
                 GENERIC_EXECUTE,
                 &ObjectAttributes
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: SamConnect failed, status %8.8x\n", Status);
        goto Cleanup;
    }


    Status = SamLookupDomainInSamServer(
                 SamHandle,
                 &Domain,
                 &DomainSid
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot find account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    Status = SamOpenDomain(
                 SamHandle,
                 GENERIC_EXECUTE,
                 DomainSid,
                 &DomainHandle
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot open account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    Status = SamLookupNamesInDomain(
                 DomainHandle,
                 1,
                 &UserName,
                 &UserId,
                 &NameUse
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot lookup user %wZ, status %8.8x\n", &UserName, Status);
        goto Cleanup;
    }

    Status = SamOpenUser(
                 DomainHandle,
                 USER_CHANGE_PASSWORD,
                 *UserId,
                 &UserHandle
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot open user %wZ, status %8.8x\n",
                 &UserName, Status);
        goto Cleanup;
    }

    Status = SamChangePasswordUser(
                 UserHandle,
                 &OldPassword,
                 &NewPassword
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Failed to change user password, status %8.8x\n", Status);
    }


Cleanup:

    //
    // Free DomainSid if used.
    //

    if (DomainSid) {
        SamFreeMemory(DomainSid);
    }

    //
    // Free UserId if used.
    //

    if (UserId) {
        SamFreeMemory(UserId);
    }

    //
    // Free NameUse if used.
    //

    if (NameUse) {
        SamFreeMemory(NameUse);
    }

    //
    // Close UserHandle if open.
    //

    if (UserHandle) {
        SamCloseHandle(UserHandle);
    }

    //
    // Close DomainHandle if open.
    //

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    //
    // Close SamHandle if open.
    //

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\tconnect.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tconnect.c

Abstract:

    This is the file for a simple connection test to SAM.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntsam.h>
#include <ntrtl.h>      // DbgPrint()





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
main (
    VOID
    )

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS            NtStatus;
    SAM_HANDLE          ServerHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;


    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  SAM_SERVER_ALL_ACCESS,
                  &ObjectAttributes
                  );

    DbgPrint("SAM TEST (Connect): Status of SamConnect() is: 0x%lx\n", NtStatus);


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\tmultipl.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmultipl.c

Abstract:

    This module tests the addition and removal of multiple
    alias members.

Author:

    Jim Kelly    (JimK)  11-Oct-1994

Environment:

    User Mode - Win32

Revision History:


--*/







///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros and defines                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define TSAMP_MEMBER_COUNT          35

#ifndef SHIFT
#define SHIFT(c,v)      {c--; v++;}
#endif //SHIFT



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
TSampUsage( VOID )
{

    printf("\n\n Test multiple member operations on alias\n");
    printf("\n\n Command format:\n");
    printf("          tmultipl [/a] [/r]\n");
    printf("\n");
    printf(" Switches\n");
    printf("          /a - causes members to be added to an alias\n");
    printf("          /r - causes members to be removed from alias\n");
    printf("\n");
    printf(" If multiple switches are specified, first adding will be attempted\n");
    printf(" and then removal.\n");
    printf(" Defaults to Account Operator alias.\n");
    printf("\n");
    return;
}


VOID
TSampParseCommandLine(
    IN  int c,
    IN  char **v,
    OUT PBOOLEAN    Add,
    OUT PBOOLEAN    Remove
    )

{
    PCHAR
        p;

    CHAR
        ch;


    //
    // Command format:
    //
    //          tmultipl [/a] [/r]
    //
    // Switches
    //          /a - causes members to be added to an alias\n");
    //          /r - causes members to be removed from alias\n");
    //
    //      if multiple switches are specified, first adding will be
    //      attempted and then removal.
    //

    (*Add) = FALSE;
    (*Remove) = FALSE;

    SHIFT (c,v);
    while ((c > 0) && ((ch = *v[0]))) {
        p = *v;
        if (ch == '/') {
            while (*++p != '\0') {
                if ((*p == 'a') || (*p == 'A')) {
                    (*Add) = TRUE;
                    printf("Add\n");
                } else if ((*p == 'r') || (*p == 'R')) {
                    (*Remove) = TRUE;
                    printf("Remove\n");
                } else {
                    TSampUsage();
                    return;
                }
            }
        }
        SHIFT(c,v);
    }
}

NTSTATUS
TSampGetLsaDomainInfo(
    IN  PUNICODE_STRING             ServerName,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    ServerName - name of machine to get account domain information
        from.

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    LSA_HANDLE
        PolicyHandle;

    OBJECT_ATTRIBUTES
        PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    NtStatus = LsaOpenPolicy( ServerName,
                              &PolicyObjectAttributes,
                              POLICY_VIEW_LOCAL_INFORMATION,
                              &PolicyHandle );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Query the account domain information
        //

        NtStatus = LsaQueryInformationPolicy( PolicyHandle,
                                              PolicyAccountDomainInformation,
                                              (PVOID *)PolicyAccountDomainInfo );


        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(NtStatus);
}


NTSTATUS
TSampConnectToServer(
    IN  PUNICODE_STRING         ServerName,
    IN  ACCESS_MASK             DomainAccess,
    OUT PHANDLE                 ServerHandle,
    OUT PHANDLE                 AccountDomain       OPTIONAL,
    OUT PSID                    *AccountDomainSid   OPTIONAL,
    OUT PHANDLE                 BuiltinDomain       OPTIONAL,
    OUT PSID                    *BuiltinDomainSid   OPTIONAL
    )

/*++

Routine Description:

    Open a handle to the SAM server on the specified server
    and then open the account and builtin domains on that same
    server.

Arguments:

    ServerName - Name of server to connect to.

    DomainAccess - accesses needed to the account domain.

    ServerHandle - Receives a handle to the SAM server on the specified
        system.

    AccountDomain - Receives a handle to the account domain.

    AccountDomainSid - Receives a pointer to the SID of the account domain.
        Must be present if AccountDomain is present.

    BuiltinDomain - Receives a handle to the Builtin domain.

    BuiltinDomainSid - Receives a pointer to the SID of the Builtin domain.
        Must be present if BuiltinDomain is present.


Return Value:




--*/
{
    NTSTATUS
        NtStatus;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        AccountDomainInfo;

    SID_IDENTIFIER_AUTHORITY
        BuiltinAuthority = SECURITY_NT_AUTHORITY;

    //
    // Connect to the server
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  ServerName,
                  ServerHandle,
                  SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Failed to connect...\n"
               "          Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    //
    // Get account domain handle and sid
    //

    if (ARGUMENT_PRESENT(AccountDomain)) {
        //
        // get account domain info
        //
        
        NtStatus = TSampGetLsaDomainInfo( ServerName,
                                          &AccountDomainInfo);
        
        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Failed to get lsa domain info...\n"
                   "          Completion status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
        
        (*AccountDomainSid) = AccountDomainInfo->DomainSid;
        
        
        NtStatus = SamOpenDomain(
                       (*ServerHandle),
                       DomainAccess,
                       *AccountDomainSid,
                       AccountDomain
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed account domain open\n"
                   "        Completion status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
    } //end_if


    //
    // Get builtin domain handle and sid
    //

    if (ARGUMENT_PRESENT(BuiltinDomain)) {

        NtStatus = RtlAllocateAndInitializeSid(
                        &BuiltinAuthority,
                        1,  //SubAuthorities
                        SECURITY_BUILTIN_DOMAIN_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        BuiltinDomainSid
                        );

        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Failed to allocate and init builtin domain sid...\n"
                   "          status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
        
        NtStatus = SamOpenDomain(
                       (*ServerHandle),
                       DomainAccess,
                       *BuiltinDomainSid,
                       BuiltinDomain
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed builtin domain open\n"
                   "        Completion status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
    } //end_if

    return(STATUS_SUCCESS);
}




VOID
TSampInitializeSids(
    OUT PSID        *MemberSids,
    IN  ULONG       MemberCount
    )
{

    //
    // Return and array of sids.
    //

    NTSTATUS
        NtStatus;

    ULONG
        i;

    SID_IDENTIFIER_AUTHORITY
        BuiltinAuthority    = SECURITY_NT_AUTHORITY,
        UnusedSidAuthority  = {0, 0, 0, 0, 0, 6};  //Authority that isn't used

    //
    // Fill MemberSids with MemberCount SIDs
    //

    for (i=0; i<MemberCount; i++) {

        NtStatus = RtlAllocateAndInitializeSid(
                                    &UnusedSidAuthority,
                                    3,             //SubAuthorityCount
                                    72549230,
                                    i,
                                    i*17,
                                    0, 0, 0, 0, 0,
                                    &MemberSids[i]
                                    );
        if (!NT_SUCCESS(NtStatus)) {
            printf("Tsamp:  Couldn't allocate or initialize sid %d, status: 0x%lx\n", NtStatus);
            return;
        }
    } // end_for


    return;

}


NTSTATUS
TSampTestAddMembers(
    IN  SAM_HANDLE          AliasHandle,
    IN  PSID                *MemberSids,
    IN  ULONG               MemberCount
    )
{
    NTSTATUS
        NtStatus;

    NtStatus = SamAddMultipleMembersToAlias(
                    AliasHandle,
                    MemberSids,
                    MemberCount
                    );
    printf("TSamp:  Added %d members to alias.  Status: 0x%lx\n",
            MemberCount, NtStatus);
    return(NtStatus);
}


NTSTATUS
TSampTestRemoveMembers(
    IN  SAM_HANDLE          AliasHandle,
    IN  PSID                *MemberSids,
    IN  ULONG               MemberCount
    )
{
    NTSTATUS
        NtStatus;

    NtStatus = SamRemoveMultipleMembersFromAlias(
                    AliasHandle,
                    MemberSids,
                    MemberCount
                    );
    printf("TSamp:  Removed %d members from alias.  Status: 0x%lx\n",
            MemberCount, NtStatus);
    return(NtStatus);
}


//VOID
__cdecl
main(c,v)
int c;
char **v;

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:




Return Value:




--*/
{
    NTSTATUS
        NtStatus;

    BOOLEAN
        Add,
        Remove;

    UNICODE_STRING
        ControllerName;

    WCHAR
        ControllerNameBuffer[80];

    SAM_HANDLE
        ServerHandle,
        AccountDomainHandle,
        BuiltinHandle,
        AliasHandle;

    ULONG
        MemberCount = TSAMP_MEMBER_COUNT;

    PSID
        MemberSids[TSAMP_MEMBER_COUNT],
        AccountDomainSid,
        BuiltinSid;


    ControllerName.Length = 0;
    ControllerName.Buffer = ControllerNameBuffer;
    ControllerName.MaximumLength = sizeof(ControllerNameBuffer);


    TSampParseCommandLine( c, v, &Add, &Remove );

    if (!Add && !Remove) {
        TSampUsage();
        return;
    }

    //
    // Open the server and its domains
    //

    NtStatus = TSampConnectToServer(&ControllerName,
                                    DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                                    &ServerHandle,
                                    &AccountDomainHandle,
                                    &AccountDomainSid,
                                    &BuiltinHandle,
                                    &BuiltinSid);
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // Initialize a bunch of SIDs to add to the alias.
    //

    TSampInitializeSids( MemberSids, MemberCount );

    //
    // Open the alias we are going to play with
    //

    NtStatus = SamOpenAlias( BuiltinHandle,
                             (ALIAS_ADD_MEMBER | ALIAS_REMOVE_MEMBER),
                             DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                             &AliasHandle);

    if (Add) {
        NtStatus = TSampTestAddMembers( AliasHandle, MemberSids, MemberCount );
    }

    if (Remove) {
        NtStatus = TSampTestRemoveMembers( AliasHandle, MemberSids, MemberCount );
    }
    



    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\tdisplay.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tdisplay.c

Abstract:

    This file is a temporary test for the Display query apis.

Author:

    Jim Kelly    (JimK)  14-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#include <nt.h>
#include <ntsam.h>
#include <ntrtl.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


SAM_HANDLE                  SamHandle;
SAM_HANDLE                  DomainHandle;
PSID                        DomainSid;




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



VOID __cdecl
main( VOID )

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    UNICODE_STRING              Domain;

    UNICODE_STRING              TestString;
    ULONG                       TestIndex;


    ULONG TotalAvailable, TotalReturned, ReturnedEntryCount, i;
    PDOMAIN_DISPLAY_USER SortedUsers;
    PDOMAIN_DISPLAY_MACHINE SortedMachines;
    PDOMAIN_DISPLAY_GROUP SortedGroups;
    PDOMAIN_DISPLAY_OEM_USER SortedOemUsers;
    PDOMAIN_DISPLAY_OEM_GROUP SortedOemGroups;



    SamHandle = NULL;
    DomainHandle = NULL;
    DomainSid = NULL;

    DbgPrint("\n\n\nSAM TEST: Testing SamQueryDisplayInformation() api\n");

    //
    // Setup ObjectAttributes for SamConnect call.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQos;

    SecurityQos.Length = sizeof(SecurityQos);
    SecurityQos.ImpersonationLevel = SecurityIdentification;
    SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SecurityQos.EffectiveOnly = FALSE;

    Status = SamConnect(
                 NULL,
                 &SamHandle,
                 GENERIC_EXECUTE,
                 &ObjectAttributes
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("SamConnect failed, status %8.8x\n", Status);
        goto Cleanup;
    }

    RtlInitUnicodeString(&Domain, L"JIMK_DOM2");

    Status = SamLookupDomainInSamServer(
                 SamHandle,
                 &Domain,
                 &DomainSid
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("Cannot find account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    Status = SamOpenDomain(
                 SamHandle,
                 GENERIC_EXECUTE,
                 DomainSid,
                 &DomainHandle
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("Cannot open account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }


    //
    // normal users ...
    //

    DbgPrint("Query users - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayUser,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedUsers);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedUsers[i].Index);
            DbgPrint("          Rid:    %d\n", SortedUsers[i].Rid);
            DbgPrint("   Logon Name:    *%Z*\n", &SortedUsers[i].LogonName);
            DbgPrint("    Full Name:    *%Z*\n", &SortedUsers[i].FullName);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedUsers[i].AdminComment);
        }

        Status = SamFreeMemory( SortedUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query users - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayUser,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedUsers);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedUsers[i].Index);
            DbgPrint("          Rid:    %d\n", SortedUsers[i].Rid);
            DbgPrint("   Logon Name:    *%Z*\n", &SortedUsers[i].LogonName);
            DbgPrint("    Full Name:    *%Z*\n", &SortedUsers[i].FullName);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedUsers[i].AdminComment);
        }

        Status = SamFreeMemory( SortedUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }


    DbgPrint("Get enumeration index...\n");

    RtlInitUnicodeString(&TestString, L"BString");

    Status =  SamGetDisplayEnumerationIndex (
                  DomainHandle,
                  DomainDisplayUser,
                  &TestString,
                  &TestIndex
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint(" Enumeration index for %wZ is %d\n", &TestString, TestIndex);
    }



    //
    // Machine accounts ...
    //

    DbgPrint("\n\nQuery Machines - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayMachine,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedMachines)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedMachines);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedMachines[i].Index);
            DbgPrint("          Rid:    %d\n", SortedMachines[i].Rid);
            DbgPrint("      Machine:    *%Z*\n", &SortedMachines[i].Machine);
            DbgPrint("      Comment:    *%Z*\n\n\n", &SortedMachines[i].Comment);
        }

        Status = SamFreeMemory( SortedMachines );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query Machines - Nonzero index (index = 1)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayMachine,
                  1,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedMachines)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedMachines);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedMachines[i].Index);
            DbgPrint("          Rid:    %d\n", SortedMachines[i].Rid);
            DbgPrint("      Machine:    *%Z*\n", &SortedMachines[i].Machine);
            DbgPrint("      Comment:    *%Z*\n\n\n", &SortedMachines[i].Comment);
        }

        Status = SamFreeMemory( SortedMachines );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }


    DbgPrint("Get enumeration index...\n");

    RtlInitUnicodeString(&TestString, L"BString");

    Status =  SamGetDisplayEnumerationIndex (
                  DomainHandle,
                  DomainDisplayMachine,
                  &TestString,
                  &TestIndex
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint(" Enumeration index for %wZ is %d\n", &TestString, TestIndex);
    }




    //
    // normal Groups ...
    //

    DbgPrint("Query Groups - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayGroup,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedGroups);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedGroups[i].Index);
            DbgPrint("          Rid:    %d\n", SortedGroups[i].Rid);
            DbgPrint("         Name:    *%Z*\n", &SortedGroups[i].Group);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedGroups[i].Comment);
        }

        Status = SamFreeMemory( SortedGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query Groups - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayGroup,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedGroups);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedGroups[i].Index);
            DbgPrint("          Rid:    %d\n", SortedGroups[i].Rid);
            DbgPrint("         Name:    *%Z*\n", &SortedGroups[i].Group);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedGroups[i].Comment);
        }

        Status = SamFreeMemory( SortedGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }


    DbgPrint("Get enumeration index...\n");

    RtlInitUnicodeString(&TestString, L"BString");

    Status =  SamGetDisplayEnumerationIndex (
                  DomainHandle,
                  DomainDisplayGroup,
                  &TestString,
                  &TestIndex
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint(" Enumeration index for %wZ is %d\n", &TestString, TestIndex);
    }


    //
    // OEM user ...
    //

    DbgPrint("Query OEM users - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemUser,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedOemUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedOemUsers);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);


        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemUsers[i].Index);
            DbgPrint("         User:    *%Z*\n", &SortedOemUsers[i].User);
        }

        Status = SamFreeMemory( SortedOemUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query OEM users - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemUser,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedOemUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedOemUsers);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");


        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemUsers[i].Index);
            DbgPrint("         User:    *%Z*\n", &SortedOemUsers[i].User);
        }

        Status = SamFreeMemory( SortedOemUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }




    //
    // OEM groups ...
    //

    DbgPrint("Query OEM groups - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemGroup,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedOemGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedOemGroups);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);


        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemGroups[i].Index);
            DbgPrint("        Group:    *%Z*\n", &SortedOemGroups[i].Group);
        }

        Status = SamFreeMemory( SortedOemGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query OEM Groups - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemGroup,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedGroups);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemGroups[i].Index);
            DbgPrint("        Group:    *%Z*\n", &SortedOemGroups[i].Group);
        }

        Status = SamFreeMemory( SortedOemGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }






    DbgPrint("\n\n  Th Tha That's all folks\n");


Cleanup:

    //
    // Close DomainHandle if open.
    //

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    //
    // Close SamHandle if open.
    //

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\temp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    temp.c

Abstract:

    This file contains temporary SAM rpc wrapper routines.

Author:

    Jim Kelly    (JimK)  14-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"


typedef struct _SAMP_TEMP_USER_STRINGS {
    ULONG  Rid;
    WCHAR  LogonName[14];
    WCHAR  FullName[24];
    WCHAR  AdminComment[24];
} SAMP_TEMP_USER_STRINGS, *PSAMP_TEMP_USER_STRINGS;


#define SAMP_TEMP_USER_COUNT (40)
#define SAMP_TEMP_USER1      (25)
#define SAMP_TEMP_USER2      (15)


typedef struct _SAMP_TEMP_MACHINE_STRINGS {
    ULONG  Rid;
    WCHAR  Machine[14];
    WCHAR  Comment[24];
} SAMP_TEMP_MACHINE_STRINGS, *PSAMP_TEMP_MACHINE_STRINGS;


#define SAMP_TEMP_MACHINE_COUNT (40)
#define SAMP_TEMP_MACHINE1      (16)
#define SAMP_TEMP_MACHINE2      (24)


SAMP_TEMP_USER_STRINGS DummyUsers[SAMP_TEMP_USER_COUNT] = {

      {1031, L"Abba"          , L"Abb Abb"              , L"Admin Comment Field"},
      {1021, L"Acea"          , L"Ace Abb"              , L"Value Admin Comment"},
      {1526, L"beverlyE"      , L"Beverly Eng"          , L"Field Value Admin"},
      {1743, L"BorisB"        , L"Boris Borsch"         , L"Comment Field Value"},
      {1734, L"BruceK"        , L"Bruce Kane"           , L"Comment Field Value"},
      {1289, L"BullS"         , L"Bull Shiite"          , L"Comment Field Value"},
      {1830, L"CallieW"       , L"Callie Wilson"        , L"Comment Field Value"},
      {1628, L"CarrieT"       , L"Carrie Tibbits"       , L"Comment Field Value"},
      {1943, L"ChrisR"        , L"Christopher Robin"    , L"40 acre woods"},
      {1538, L"CorneliaG"     , L"Cornelia Gutierrez"   , L"Comment Field Value"},
      {1563, L"CoryA"         , L"Cory Ander"           , L"Comment Field Value"},
      {1758, L"DanielJ"       , L"Daniel John"          , L"Comment Field Value"},
      {1249, L"Dory"          , L"Dory"                 , L"Comment Field Value"},
      {1957, L"EltonJ"        , L"Elton John"           , L"Comment Field Value"},
      {1555, L"HarrisonF"     , L"Harrison Ford"        , L"Comment Field Value"},
      {1795, L"HarryB"        , L"Harry Belafonte"      , L"Comment Field Value"},
      {1458, L"IngridB"       , L"Ingrid Bergman"       , L"Comment Field Value"},
      {1672, L"Ingris"        , L"Ingris"               , L"Comment Field Value"},
      {1571, L"JenniferB"     , L"Jennifer Black"       , L"Comment Field Value"},
      {1986, L"JoyceG"        , L"Joyce Gerace"         , L"Comment Field Value"},
      {1267, L"KristinM"      , L"Kristin McKay"        , L"Comment Field Value"},
      {1321, L"LeahD"         , L"Leah Dootson"         , L"The Lovely Miss D"},
      {2021, L"LisaP"         , L"Lisa Perazzoli"       , L"Wild On Skis"},
      {1212, L"MeganB"        , L"Megan Bombeck"        , L"M1"},
      {2758, L"MelisaB"       , L"Melisa Bombeck"       , L"M3"},
      {2789, L"MichaelB"      , L"Michael Bombeck"      , L"M2"},
      {2682, L"PanelopiP"     , L"Panelopi Pitstop"     , L"Comment Field Value"},
      {2438, L"Prudence"      , L"Prudence Peackock"    , L"Comment Field Value"},
      {2648, L"QwertyU"       , L"Qwerty Uiop"          , L"Comment Field Value"},
      {2681, L"ReaddyE"       , L"Readdy Eddy"          , L""},
      {2456, L"SovietA"       , L"Soviet Union - NOT"   , L"Soviet Union Aint"},
      {1753, L"TAAAA"         , L"TTT   AAAA"           , L"Comment Field Value"},
      {1357, L"TBBB"          , L"Ingris"               , L"Comment Field Value"},
      {1951, L"TCCCCC"        , L"Jennifer Black"       , L"Comment Field Value"},
      {1159, L"TCAAAAAA"      , L"Joyce Gerace"         , L"Comment Field Value"},
      {1654, L"Ulga"          , L"Ulga Bulga"           , L"Comment Field Value"},
      {1456, L"UnixY"         , L"Unix Yuck"            , L"Unix - why ask why?"},
      {1852, L"Vera"          , L"Vera Pensicola"       , L""},
      {1258, L"WinP"          , L"Winnie The Pooh"      , L"Comment Field Value"},
      {2821, L"Zoro"          , L"Zoro"                 , L"The sign of the Z"}
};





SAMP_TEMP_MACHINE_STRINGS DummyMachines[SAMP_TEMP_MACHINE_COUNT] = {

      {1031, L"WKS$abba"          , L"Admin Comment Field"},
      {1021, L"WKS$Acea"          , L"Value Admin Comment"},
      {1526, L"WKS$beverlyE"      , L"Field Value Admin"},
      {1743, L"WKS$BorisB"        , L"Comment Field Value"},
      {1734, L"WKS$BruceK"        , L"Comment Field Value"},
      {1289, L"WKS$BullS"         , L"Comment Field Value"},
      {1830, L"WKS$CallieW"       , L"Comment Field Value"},
      {1628, L"WKS$CarrieT"       , L"Comment Field Value"},
      {1943, L"WKS$ChrisR"        , L"40 acre woods Server"},
      {1538, L"WKS$CorneliaG"     , L"Comment Field Value"},
      {1563, L"WKS$CoryA"         , L"Comment Field Value"},
      {1758, L"WKS$DanielJ"       , L"Comment Field Value"},
      {1249, L"WKS$Dory"          , L"Comment Field Value"},
      {1957, L"WKS$EltonJ"        , L"Comment Field Value"},
      {1555, L"WKS$HarrisonF"     , L"Comment Field Value"},
      {1795, L"WKS$HarryB"        , L"Comment Field Value"},
      {1458, L"WKS$IngridB"       , L"Comment Field Value"},
      {1672, L"WKS$Ingris"        , L"Comment Field Value"},
      {1571, L"WKS$JenniferB"     , L"Comment Field Value"},
      {1986, L"WKS$JoyceG"        , L"Comment Field Value"},
      {1267, L"WKS$KristinM"      , L"Comment Field Value"},
      {1321, L"WKS$LeahD"         , L"The Lovely Miss D's"},
      {2021, L"WKS$LisaP"         , L"Wild On Skis Server"},
      {1212, L"WKS$MeganB"        , L"M1 Machine"},
      {2758, L"WKS$MelisaB"       , L"M3 Machine"},
      {2789, L"WKS$MichaelB"      , L"M2 Machine"},
      {2682, L"WKS$PanelopiP"     , L"Comment Field Value"},
      {2438, L"WKS$Prudence"      , L"Comment Field Value"},
      {2648, L"WKS$QwertyU"       , L"Comment Field Value"},
      {2681, L"WKS$ReaddyE"       , L"Ready Eddy Computer"},
      {2456, L"WKS$SovietA"       , L"Soviet Union Aint"},
      {1753, L"WKS$TAAAA"         , L"Comment Field Value"},
      {1357, L"WKS$TBBB"          , L"Comment Field Value"},
      {1951, L"WKS$TCCCCC"        , L"Comment Field Value"},
      {1159, L"WKS$TCAAAAAA"      , L"Comment Field Value"},
      {1654, L"WKS$Ulga"          , L"Comment Field Value"},
      {1456, L"WKS$UnixY"         , L"Unix - why ask why?"},
      {1852, L"WKS$Vera"          , L"Vera tissue"},
      {1258, L"WKS$WinP"          , L"Comment Field Value"},
      {2821, L"WKS$Zoro"          , L"The sign of the Z"}
};




VOID
SampBuildDummyAccounts(
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
    );



VOID
SampBuildDummyAccounts(
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
    )

{
    ULONG AccountCount, Account1, Account2;
    ULONG i, j, BeginIndex, EndIndex;
    ULONG ReturnStructSize, ArrayLength, StringLengths;
    PCHAR NextByte;
    UNICODE_STRING Us;



    ASSERT (SAMP_TEMP_USER1 != 0);
    ASSERT (SAMP_TEMP_USER2 != 0);
    ASSERT (SAMP_TEMP_MACHINE1 != 0);
    ASSERT (SAMP_TEMP_MACHINE2 != 0);

    if (DisplayInformation == DomainDisplayUser) {

        ReturnStructSize = sizeof(DOMAIN_DISPLAY_USER);
        Account1 = SAMP_TEMP_USER1;
        Account2 = SAMP_TEMP_USER2;
        AccountCount = SAMP_TEMP_USER_COUNT;

    } else {

        ReturnStructSize = sizeof(DOMAIN_DISPLAY_MACHINE);
        Account1 = SAMP_TEMP_MACHINE1;
        Account2 = SAMP_TEMP_MACHINE2;
        AccountCount = SAMP_TEMP_MACHINE_COUNT;

    }



    //
    // Build up a number of dummy accounts in a single buffer.
    //


    if (Index < Account1) {

        //
        // Give the first group of accounts
        //

        ArrayLength  = ReturnStructSize * Account1;
        BeginIndex = 0;
        EndIndex   = Account1;


    } else {

        //
        // Give the second group of accounts
        //

        ArrayLength  = ReturnStructSize * Account2;
        BeginIndex = Account1;
        EndIndex   = AccountCount;

    }



    //
    // Figure out how large a buffer is needed.
    //

    StringLengths = 0;
    for (i=BeginIndex; i<EndIndex; i++) {

        if (DisplayInformation == DomainDisplayUser) {

            RtlInitUnicodeString( &Us, DummyUsers[i].LogonName);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyUsers[i].FullName);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyUsers[i].AdminComment);
            StringLengths += Us.Length;

        } else {

            RtlInitUnicodeString( &Us, DummyMachines[i].Machine);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyMachines[i].Comment);
            StringLengths += Us.Length;

        }

    }
    (*SortedBuffer) = MIDL_user_allocate( ArrayLength + StringLengths );
    ASSERT(SortedBuffer != NULL);


    //
    // First free byte in the return buffer
    //

    NextByte = (PCHAR)((ULONG)(*SortedBuffer) + (ULONG)ArrayLength);


    //
    // Now copy the structures

    if (DisplayInformation == DomainDisplayUser) {

        PDOMAIN_DISPLAY_USER r;
        r = (PDOMAIN_DISPLAY_USER)(*SortedBuffer);

        j=0;
        for (i=BeginIndex; i<EndIndex; i++) {

            r[j].AccountControl = USER_NORMAL_ACCOUNT;
            r[j].Index = i;
            r[j].Rid = DummyUsers[i].Rid;


            //
            // copy the logon name
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].LogonName);
            r[j].LogonName.MaximumLength = Us.Length;
            r[j].LogonName.Length = Us.Length;
            r[j].LogonName.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].LogonName.Length);
            NextByte += r[j].LogonName.Length;

            //
            // copy the full name
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].FullName);
            r[j].FullName.MaximumLength = Us.Length;
            r[j].FullName.Length = Us.Length;
            r[j].FullName.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].FullName.Length);
            NextByte += r[j].FullName.Length;

            //
            // copy the admin comment
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].AdminComment);
            r[j].AdminComment.MaximumLength = Us.Length;
            r[j].AdminComment.Length = Us.Length;
            r[j].AdminComment.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].AdminComment.Length);
            NextByte += r[j].AdminComment.Length;

            j++;

        }

    } else {

        PDOMAIN_DISPLAY_MACHINE r;
        r = (PDOMAIN_DISPLAY_MACHINE)(*SortedBuffer);

        j=0;
        for (i=BeginIndex; i<EndIndex; i++) {


            r[j].AccountControl = USER_WORKSTATION_TRUST_ACCOUNT;
            r[j].Index = i;
            r[j].Rid = DummyMachines[i].Rid;


            //
            // copy the logon name
            //

            RtlInitUnicodeString( &Us, DummyMachines[i].Machine);
            r[j].Machine.MaximumLength = Us.Length;
            r[j].Machine.Length = Us.Length;
            r[j].Machine.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].Machine.Length);
            NextByte += r[j].Machine.Length;


            //
            // copy the admin comment
            //

            RtlInitUnicodeString( &Us, DummyMachines[i].Comment);
            r[j].Comment.MaximumLength = Us.Length;
            r[j].Comment.Length = Us.Length;
            r[j].Comment.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].Comment.Length);
            NextByte += r[j].Comment.Length;

            j++;

        }


    }

    (*TotalAvailable) = 6*1024;        // A lie, but just a little lie.
    (*TotalReturned) = ArrayLength + StringLengths;
    (*ReturnedEntryCount) = EndIndex - BeginIndex;


    return;


}



NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      )

/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of SAM
    accounts for display in list boxes.  (Replication has similar but
    broader requirements.)

    The netui listboxes all contain similar information.  That is:

      o  AccountControl, the bits that identify the account type,
         eg, HOME, REMOTE, SERVER, WORKSTATION, etc.

      o  Logon name (machine name for computers)

      o  Full name (not used for computers)

      o  Comment (admin comment for users)

    SAM maintains this data locally in two sorted indexed cached
    lists identified by infolevels.

      o DomainDisplayUser:       HOME and REMOTE user accounts only

      o  DomainDisplayMachine:   SERVER and WORKSTATION accounts only

    Note that trust accounts, groups, and aliases are not in either of
    these lists.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which information is to be enumerated.

    Index - The index of the first entry to be retrieved.

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    TotalAvailable - Total number of bytes availabe in the specified info
        class.

    TotalReturned - Number of bytes actually returned for this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.


    SortedBuffer - Receives a pointer to a buffer containing a sorted
        list of the requested information.  This buffer is allocated
        by this routine and contains the following structure:


            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_USER structures.

            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_MACHINE.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_MACHINE structures.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_INVALID_INFO_CLASS - The requested class of information
        is not legitimate for this service.





--*/
{



//    if ((DisplayInformation != DomainDisplayUser) &&
//        (DisplayInformation != DomainDisplayMachine) ) {
//        return( STATUS_INVALID_INFO_CLASS );
//
//    }



    SampBuildDummyAccounts( DisplayInformation,
                            Index,
                            TotalAvailable,
                            TotalReturned,
                            ReturnedEntryCount,
                            SortedBuffer);

    return(STATUS_SUCCESS);

    DBG_UNREFERENCED_PARAMETER(DomainHandle);
    DBG_UNREFERENCED_PARAMETER(PreferredMaximumLength);

}


NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      )

/*++

Routine Description:

    This routine returns the index of the entry which alphabetically
    immediatly preceeds a specified prefix.  If no such entry exists,
    then zero is returned as the index.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.


--*/
{

    (*Index) = 0;

    return(STATUS_SUCCESS);


    DBG_UNREFERENCED_PARAMETER(DomainHandle);
    DBG_UNREFERENCED_PARAMETER(DisplayInformation);
    DBG_UNREFERENCED_PARAMETER(Prefix);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\tmachine.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmachine.c

Abstract:

    This module tests the machine account creation facilities
    of SAM.

Author:

    Jim Kelly    (JimK)  7-Feb-1994

Environment:

    User Mode - Win32

Revision History:


--*/







///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#ifndef SHIFT
#define SHIFT(c,v)      {c--; v++;}
#endif //SHIFT



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
TSampGetLsaDomainInfo(
    IN  PUNICODE_STRING             ServerName,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    ServerName - name of machine to get account domain information
        from.

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    LSA_HANDLE
        PolicyHandle;

    OBJECT_ATTRIBUTES
        PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    NtStatus = LsaOpenPolicy( ServerName,
                              &PolicyObjectAttributes,
                              POLICY_VIEW_LOCAL_INFORMATION,
                              &PolicyHandle );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Query the account domain information
        //

        NtStatus = LsaQueryInformationPolicy( PolicyHandle,
                                              PolicyAccountDomainInformation,
                                              (PVOID *)PolicyAccountDomainInfo );


        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(NtStatus);
}


NTSTATUS
TSampConnectToServer(
    IN  PUNICODE_STRING         ServerName,
    IN  ACCESS_MASK             DomainAccess,
    OUT PHANDLE                 ServerHandle,
    OUT PHANDLE                 DomainHandle,
    OUT PSID                    *DomainSid
    )

/*++

Routine Description:

    Open a handle to the SAM server on the specified server
    and then open the account domain on that same server.

Arguments:

    ServerName - Name of server to connect to.

    DomainAccess - accesses needed to the account domain.

    ServerHandle - Receives a handle to the SAM server on the specified
        system.

    DomainHandle - Receives a handle to the account domain.

    DomainSid - Receives a pointer to the SID of the account domain.


Return Value:




--*/
{
    NTSTATUS
        NtStatus;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        AccountDomainInfo;

    //
    // get account domain info
    //

    NtStatus = TSampGetLsaDomainInfo( ServerName,
                                      &AccountDomainInfo);

    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Failed to get lsa domain info...\n"
               "          Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }
    printf("SAM TEST: Target domain is %wZ\n", &AccountDomainInfo->DomainName);

    (*DomainSid) = AccountDomainInfo->DomainSid;

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  ServerName,
                  ServerHandle,
                  SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Failed to connect...\n"
               "          Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    NtStatus = SamOpenDomain(
                   (*ServerHandle),
                   DomainAccess,
                   *DomainSid,
                   DomainHandle
                   );

    if (!NT_SUCCESS(NtStatus)) {
        printf("Failed account domain open\n"
               "        Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }
    
    return(STATUS_SUCCESS);


}


BOOLEAN
TSampEnableMachinePrivilege( VOID )

/*++

Routine Description:

    This function enabled the SeMachineAccountPrivilege privilege.

Arguments:

    None.

Return Value:

    TRUE  if privilege successfully enabled.
    FALSE if not successfully enabled.

--*/
{

    NTSTATUS Status;
    HANDLE Token;
    LUID SecurityPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    if (!NT_SUCCESS(Status)) {
        printf("SAM TEST: Can't open process token to enable Privilege.\n"
               "          Completion status of NtOpenProcessToken() is: 0x%lx\n", Status);
        return(FALSE);
    }


    //
    // Initialize the adjustment structure
    //

    SecurityPrivilege =
        RtlConvertLongToLargeInteger(SE_MACHINE_ACCOUNT_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = RtlAllocateHeap( RtlProcessHeap(), 0, 100 );

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = SecurityPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


    //
    // Set the state of the privilege to ENABLED.
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );
    // don't use NT_SUCCESS here because STATUS_NOT_ALL_ASSIGNED is a success status
    if (Status != STATUS_SUCCESS) {
        return(FALSE);
    }


    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, NewState );
    Status = NtClose( Token );
    ASSERT(NT_SUCCESS(Status));


    return TRUE;

}


NTSTATUS
TSampCreateMachine(
    IN  SAM_HANDLE              DomainHandle,
    IN  PUNICODE_STRING         AccountName
    )

/*++

Routine Description:

    This routine attempts to create a machine account.

    One of two cases may be tested:

        1) DomainHandle is open for DOMAIN_CREATE_USER,
    or
        2) DomainHandle is open for DOMAIN_LOOKUP and
           the SeMachineAccountPrivilege privilege is
           enabled.

    It is the caller's responsibility to establish the
    correct case criteria before calling.

Arguments:

    DomainHandle - handle to domain to create account in.

    AccountName - Name of the account to create.


Return Value:

--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    SAM_HANDLE
        UserHandle;

    ACCESS_MASK
        GrantedAccess;

    ULONG
        Rid;

    NtStatus = SamCreateUser2InDomain( DomainHandle,
                                       AccountName,
                                       USER_WORKSTATION_TRUST_ACCOUNT,
                                       MAXIMUM_ALLOWED,
                                       &UserHandle,
                                       &GrantedAccess,
                                       &Rid);

    if (NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SamCloseHandle( UserHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        printf("SAM TEST: Machine account created.\n"
               "              GrantedAccess: 0x%lx\n"
               "              Rid:           %d (0x%lx)\n",
               GrantedAccess, Rid, Rid);
    } else {
        printf("SAM TEST: Machine account creation failed.\n"
               "              Status: 0x%lx\n", NtStatus);
    }


    return(NtStatus);


}


NTSTATUS
TSampSetPasswordMachine(
    IN  SAM_HANDLE              DomainHandle,
    IN  PUNICODE_STRING         AccountName,
    IN  PUNICODE_STRING         Password
    )

/*++

Routine Description:

    This routine attempts to set the password of a machine account.


Arguments:

    DomainHandle - handle to domain account is in.

    AccountName - Name of the account to set password.

    Password - New password.

Return Value:

--*/

{
    NTSTATUS
        NtStatus;

    SAM_HANDLE
        UserHandle;

    PULONG
        RelativeIds;

    PSID_NAME_USE
        Use;

    USER_SET_PASSWORD_INFORMATION
        PasswordInfo;


    PasswordInfo.Password = (*Password);
    PasswordInfo.PasswordExpired = FALSE;

    NtStatus = SamLookupNamesInDomain( DomainHandle,
                                       1,
                                       AccountName,
                                       &RelativeIds,
                                       &Use);
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't find account to set password.\n"
               "              Lookup status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    NtStatus = SamOpenUser( DomainHandle,
                            USER_FORCE_PASSWORD_CHANGE,
                            RelativeIds[0],
                            &UserHandle);
                            
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't open user account for FORCE_PASSWORD_CHANGE.\n"
               "              Lookup status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }

    NtStatus = SamSetInformationUser( UserHandle,
                                      UserSetPasswordInformation,
                                      &PasswordInfo
                                      );
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't set password on user account.\n"
               "              Set Info status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    return(STATUS_SUCCESS);


}


NTSTATUS
TSampDeleteMachine(
    IN  SAM_HANDLE              DomainHandle,
    IN  PUNICODE_STRING         AccountName
    )

/*++

Routine Description:

    This routine attempts to delete a machine account.


Arguments:

    DomainHandle - handle to domain to delete account from.

    AccountName - Name of the account to delete.


Return Value:

--*/

{
    NTSTATUS
        NtStatus;

    SAM_HANDLE
        UserHandle;

    PULONG
        RelativeIds;

    PSID_NAME_USE
        Use;

    NtStatus = SamLookupNamesInDomain( DomainHandle,
                                       1,
                                       AccountName,
                                       &RelativeIds,
                                       &Use);
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't find account to delete.\n"
               "              Lookup status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    NtStatus = SamOpenUser( DomainHandle,
                            DELETE,
                            RelativeIds[0],
                            &UserHandle);
                            
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't open user account for delete.\n"
               "              Open status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }

    NtStatus = SamDeleteUser( UserHandle );
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't delete user account.\n"
               "              DeleteUser status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    return(STATUS_SUCCESS);


}


VOID
TSampPrintYesOrNo(
    IN BOOLEAN b
    )
{
    if (b) {
        printf("Yes\n");
    } else {
        printf("No\n");
    }
}



VOID
TSampUsage( VOID )
{

    printf("\n\n Command format:\n");
    printf("          tmachine [/c] [/p] [/d] <account-name> <machine> [<password>]\n");
    printf("\n");
    printf(" Switches\n");
    printf("          /c - create account\n");
    printf("          /p - set password on account\n");
    printf("          /d - delete account\n");
    printf("\n");
    printf(" if multiple switches are specified, they are attempted in\n");
    printf(" the order listed above.  An error in any attempt will prevent\n");
    printf(" any further attempts.\n");
    printf("\n");
    return;
}


VOID
main (c,v)
int c;
char **v;

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    Argv[1] - account name to create or delete

    Argv[2] - domain controller machine name

    Argv[3] - 'D' to delete account, otherwise account is created.



Return Value:




--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    UNICODE_STRING
        AccountName,
        ControllerName,
        Password;

    WCHAR
        AccountNameBuffer[80],
        ControllerNameBuffer[80],
        PasswordBuffer[80];

    ANSI_STRING
        AnsiString;

    SAM_HANDLE
        ServerHandle,
        ServerHandle2,
        DomainHandle,
        DomainHandle2;

    PSID
        DomainSid;

    BOOLEAN
        Create = FALSE,
        SetPassword = FALSE,
        Delete = FALSE;

    ULONG
        ArgNum = 0;

    PCHAR
        p;

    CHAR
        ch;

    AccountName.Length = 0;
    ControllerName.Length = 0;
    Password.Length = 0;



    //
    // Command format:
    //
    //          tmachine [/c] [/p] [/d] <account-name> <machine> [<password>]
    //
    // Switches
    //          /c - create account
    //          /p - set password on account
    //          /d - delete account
    //
    // if multiple switches are specified, they are attempted in
    // the order listed above.  An error in any attempt will prevent
    // any further attempts.
    //

    SHIFT (c,v);
    while ((c > 0) && ((ch = *v[0]))) {
        p = *v;
        if (ch == '/') {
            while (*++p != '\0') {
                if ((*p == 'c') || (*p == 'C')) {
                    Create = TRUE;
//                    printf("Create\n");
                } else if ((*p == 'p') || (*p == 'P')) {
                    SetPassword = TRUE;
//                    printf("SetPassword\n");
                } else if ((*p == 'd') || (*p == 'D')) {
                    Delete = TRUE;
//                    printf("Delete\n");
                } else {
                    TSampUsage();
                    return;
                }
            }
        } else {

            switch (ArgNum) {
                case 0:

                    //
                    // collecting account name
                    //

                    AccountName.Buffer = AccountNameBuffer;
                    AccountName.MaximumLength = sizeof(AccountNameBuffer);
                    RtlInitAnsiString(&AnsiString, (*v));
                    RtlAnsiStringToUnicodeString(&AccountName, &AnsiString, FALSE);

//                    printf("account: %wZ\n", &AccountName);
                    break;

                case 1:

                    //
                    // collecting machine name
                    //

                    ControllerName.Buffer = ControllerNameBuffer;
                    ControllerName.MaximumLength = sizeof(ControllerNameBuffer);
                    RtlInitAnsiString(&AnsiString, (*v));
                    RtlAnsiStringToUnicodeString(&ControllerName, &AnsiString, FALSE);

//                    printf("machine: %wZ\n", &ControllerName);
                    break;


                case 2:

                    //
                    // collecting password name
                    //

                    Password.Buffer = PasswordBuffer;
                    Password.MaximumLength = sizeof(PasswordBuffer);
                    RtlInitAnsiString(&AnsiString, (*v));
                    RtlAnsiStringToUnicodeString(&Password, &AnsiString, FALSE);

//                    printf("password: %wZ\n", &Password);
                    break;

                default:

                    //
                    // collecting garbage.
                    //

                    break;
            }

            ArgNum++;
        }
    SHIFT(c,v);
    }



    printf("parameters:\n");
    printf("    Create Account:  "); TSampPrintYesOrNo( Create );
    printf("    Set Password  :  "); TSampPrintYesOrNo( SetPassword );
    printf("    Delete Account:  "); TSampPrintYesOrNo( Delete );
    printf("    Account       :  *%wZ*\n", &AccountName);
    printf("    Machine       :  *%wZ*\n", &ControllerName);
    printf("    Password      :  *%wZ*\n", &Password);


    //
    // Make sure we don't have conflicting parameters
    //
    // Rules:
    //
    //      1) account name is always required.
    //      2) password and machine are required if /P was specified.
    //      3) machine is optional if /P not specified.
    //
    //

    if ( (AccountName.Length == 0)                          ||
         ( SetPassword && (ControllerName.Length == 0) )    ||
         ( SetPassword && (Password.Length == 0) ) ) {
        TSampUsage();
        return;
    }


    //
    // Open the server and the account domain
    //

    NtStatus = TSampConnectToServer(&ControllerName,
                                    DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                                    &ServerHandle,
                                    &DomainHandle,
                                    &DomainSid);


    if (Create) {
        //
        // try to create the machine account with privilege.
        //


        printf("SAM TEST: Creating machine account with privilege.\n");
        TSampEnableMachinePrivilege();
        NtStatus = TSampCreateMachine( DomainHandle, &AccountName );
        if (NT_SUCCESS(NtStatus)) {
            printf("          Status: successful\n");
        } else {

            if (NtStatus == STATUS_ACCESS_DENIED) {
                //
                // We didn't have the privilege, and didn't have
                // the domain open so that it would work without
                // the privilege.
                //

                printf("      Couldn't create account with privilege (0x%lx)\n"
                       "      Attempting normal creation (without privilege)\n"
                       , NtStatus);
                NtStatus = TSampConnectToServer(&ControllerName,
                                                DOMAIN_LOOKUP |
                                                DOMAIN_READ_PASSWORD_PARAMETERS |
                                                DOMAIN_CREATE_USER,
                                                &ServerHandle2,
                                                &DomainHandle2,
                                                &DomainSid);
                if (!NT_SUCCESS(NtStatus)) {
                    printf("      Can't open domain for CREATE_USER access (0x%lx)\n", NtStatus);
                } else {
                    NtStatus = TSampCreateMachine( DomainHandle2,
                                                   &AccountName );
                    if (NT_SUCCESS(NtStatus)) {
                        printf("          Status: successful\n");
                    } else {
                        printf("          Failed: 0x%lx\n", NtStatus);
                    }

                    IgnoreStatus = SamCloseHandle( DomainHandle2 );

                }
            }
            if (!NT_SUCCESS(NtStatus)) {
                printf("          Status: 0x%lx", NtStatus);
                return;
            }
        }
    }


    if (SetPassword) {

        //
        // Try to set the password on the account
        //

        printf("SAM TEST: Setting password of account ...\n");
        NtStatus = TSampSetPasswordMachine( DomainHandle, &AccountName, &Password );
        if (NT_SUCCESS(NtStatus)) {
            printf("          Status: successful\n");
        } else {
            printf("          Status: 0x%lx", NtStatus);
            return;
        }
    }


    if (Delete) {

        printf("SAM TEST: Deleting account ...\n");
        NtStatus = TSampDeleteMachine( DomainHandle, &AccountName );
        if (NT_SUCCESS(NtStatus)) {
            printf("          Status: successful\n");
        } else {
            printf("          Status: 0x%lx", NtStatus);
            return;
        }
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\tshut.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tshut.c

Abstract:

    This test is used to shut-down a SAM server.  This might be useful
    for killing SAM without rebooting during development.

Author:

    Jim Kelly    (JimK)  12-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntsam.h>
#include <ntrtl.h>      // DbgPrint()





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
main (
    VOID
    )

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS            NtStatus;
    SAM_HANDLE          ServerHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;


    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  SAM_SERVER_ALL_ACCESS,
                  &ObjectAttributes
                  );

    DbgPrint("SAM TEST (Tshut): Status of SamConnect() is: 0x%lx\n", NtStatus);
    if (!NT_SUCCESS(NtStatus)) { return; }


    NtStatus = SamShutdownSamServer( ServerHandle );
    DbgPrint("SAM TEST (Tshut): Status of SamShutdownSamServer() is: 0x%lx\n", NtStatus);
    if (!NT_SUCCESS(NtStatus)) { return; }


    //
    // I'm not sure why, but it seems to take another awakening of the
    // server to make it die.
    //

    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  SAM_SERVER_ALL_ACCESS,
                  &ObjectAttributes
                  );



    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\toempass.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    toempass.c

Abstract:

    This file contains test code for the oem password change routine.

Author:

    Mike Swift      (MikeSw)  4-January-1995

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"


NTSTATUS
SampEncryptLmPasswords(
    IN LPSTR OldPassword,
    IN LPSTR NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    LM_OWF_PASSWORD OldLmOwfPassword;
    LM_OWF_PASSWORD NewLmOwfPassword;
    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;
    struct RC4_KEYSTRUCT Rc4Key;
    NTSTATUS NtStatus;
    CHAR LocalNewPassword[SAM_MAX_PASSWORD_LENGTH];
    CHAR LocalOldPassword[SAM_MAX_PASSWORD_LENGTH];

    if ((lstrlenA(OldPassword) > SAM_MAX_PASSWORD_LENGTH - 1) ||
        (lstrlenA(NewPassword) > SAM_MAX_PASSWORD_LENGTH - 1) )
    {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    //
    // Upcase the passwords
    //
    lstrcpyA(LocalOldPassword,OldPassword);
    lstrcpyA(LocalNewPassword,NewPassword);

    strupr(LocalOldPassword);
    strupr(LocalNewPassword);



    //
    // Calculate the LM OWF passwords
    //


    NtStatus = RtlCalculateLmOwfPassword(
                    LocalOldPassword,
                    &OldLmOwfPassword
                    );


    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlCalculateLmOwfPassword(
                    LocalNewPassword,
                    &NewLmOwfPassword
                    );
    }



    //
    // Calculate the encrypted old passwords
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                    &OldLmOwfPassword,
                    &NewLmOwfPassword,
                    OldLmOwfEncryptedWithNewLm
                    );
    }


    //
    // Calculate the encrypted new passwords
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(sizeof(SAMPR_ENCRYPTED_USER_PASSWORD) == sizeof(SAMPR_USER_PASSWORD));


        //
        // Compute the encrypted new password with LM key.
        //


        rc4_key(
            &Rc4Key,
            LM_OWF_PASSWORD_LENGTH,
            (PUCHAR) &OldLmOwfPassword
            );

        RtlCopyMemory(
            ((PUCHAR) NewLm->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                strlen(NewPassword),
            NewPassword,
            strlen(NewPassword)
            );

        NewLm->Length = strlen(NewPassword);
        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewEncryptedWithOldLm
            );


    }

    return(NtStatus);

}



NTSTATUS
SamOemChangePassword(
    LPWSTR ServerName,
    LPSTR UserName,
    LPSTR OldPassword,
    LPSTR NewPassword
    )
{
    handle_t BindingHandle = NULL;
    NTSTATUS Status;
    SAMPR_ENCRYPTED_USER_PASSWORD NewLmEncryptedWithOldLm;
    ENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm;
    STRING UserString;
    UNICODE_STRING ServerUnicodeString;
    STRING ServerString;

    RtlInitUnicodeString(
        &ServerUnicodeString,
        ServerName
        );

    Status = RtlUnicodeStringToOemString(
                &ServerString,
                &ServerUnicodeString,
                TRUE
                );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    RtlInitString(
        &UserString,
        UserName
        );

    Status = SampEncryptLmPasswords(
                OldPassword,
                NewPassword,
                &NewLmEncryptedWithOldLm,
                &OldLmOwfEncryptedWithNewLm
                );

    if (!NT_SUCCESS(Status)) {
        RtlFreeOemString(&ServerString);
        return(Status);
    }
    BindingHandle = SampSecureBind(
                        ServerName,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                        );
    if (BindingHandle == NULL) {
        RtlFreeOemString(&ServerString);
        return(RPC_NT_INVALID_BINDING);
    }

    RpcTryExcept{

        Status = SamrOemChangePasswordUser2(
                       BindingHandle,
                       (PRPC_STRING) &ServerString,
                       (PRPC_STRING) &UserString,
                       &NewLmEncryptedWithOldLm,
                       &OldLmOwfEncryptedWithNewLm
                       );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    RtlFreeOemString(&ServerString);
    return(Status);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\tsamobj.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tsamobj.c

Abstract:

    This is the primary SAM object test.
    It contains a suite of tests for each type of SAM object.

Author:

    Jim Kelly    (JimK)  12-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/







///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Definitions                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





#define TMPP_USER_NAME_ADMIN           "Administrator"
#define TMPP_USER_NAME_GUEST           "Guest"
#define TMPP_GROUP_NAME_ADMINS         "Domain Admins"
#define TMPP_GROUP_NAME_USERS          "Domain Users"
#define TMPP_GROUP_NAME_NONE           "None"
#define TMPP_ALIAS_NAME_ADMINS         "Administrators"
#define TMPP_ALIAS_NAME_SYSTEM_OPS     "System Operators"
#define TMPP_ALIAS_NAME_POWER_USERS    "Power Users"
#define TMPP_ALIAS_NAME_USERS          "Users"
#define TMPP_ALIAS_NAME_GUESTS         "Guests"
#define TMPP_ALIAS_NAME_ACCOUNT_OPS    "Account Operators"
#define TMPP_ALIAS_NAME_PRINT_OPS      "Print Operators"
#define TMPP_ALIAS_NAME_BACKUP_OPS     "Backup Operators"



#define GROUP_NAME1             "GROUP1"
#define ALIAS_NAME1             "ALIAS1"
#define ALIAS_NAME2             "ALIAS2"
#define USER_NAME1              "USER1"
#define USER_NAME2              "USER2"
#define USER_NAME3              "USER3"

// Keep these names not longer than 8 char's until long registry names supported
#define DUMMY_NAME1             "DName1"
#define DUMMY_NAME2             "2emaNuD"

#define DUMMY_STRING1           "This is test string 1"
#define DUMMY_STRING2           "Test String2 - test string 2 - tEST sTRING 2"

#define ALL_NAMES_COUNT         (3)
#define SOME_NAMES_COUNT        (7)
#define NO_NAMES_COUNT          (2)

#define LOOKUP_KNOWN_NAME0      TMPP_USER_NAME_ADMIN
#define LOOKUP_KNOWN_NAME1_A    TMPP_GROUP_NAME_NONE
#define LOOKUP_KNOWN_NAME2_A    TMPP_GROUP_NAME_NONE
#define LOOKUP_KNOWN_NAME1_P    TMPP_GROUP_NAME_USERS
#define LOOKUP_KNOWN_NAME2_P    TMPP_GROUP_NAME_USERS

#define LOOKUP_KNOWN_NAME0_RID  DOMAIN_USER_RID_ADMIN
#define LOOKUP_KNOWN_NAME1_RID  DOMAIN_GROUP_RID_USERS
#define LOOKUP_KNOWN_NAME2_RID  DOMAIN_GROUP_RID_USERS

#define LOOKUP_UNKNOWN_NAME0    "JoeJoe"
#define LOOKUP_UNKNOWN_NAME1    "Tanya"
#define LOOKUP_UNKNOWN_NAME2    "Fred"
#define LOOKUP_UNKNOWN_NAME3    "Anyone"

#define LOOKUP_KNOWN_NAME0_USE  (SidTypeUser)
#define LOOKUP_KNOWN_NAME1_USE  (SidTypeGroup)
#define LOOKUP_KNOWN_NAME2_USE  (SidTypeGroup)


//
// This byte is expected to be different in the DummyLogonHours and
// NoRestrictionLogonHours.
//

#define LOGON_HOURS_DIFFERENT_OFFSET    (5)



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LARGE_INTEGER LargeInteger1,
              LargeInteger2;

UNICODE_STRING DummyName1,
               DummyName2,
               DummyString1,
               DummyString2;

STRING         DummyAnsiString1,
               DummyAnsiString2;

LOGON_HOURS    NoLogonRestriction,
               DummyLogonHours;

CHAR           NoLogonRestrictionBitMask[21],
               DummyLogonHoursBitMask[21];


UNICODE_STRING  AllNames[ALL_NAMES_COUNT],
                SomeNames[SOME_NAMES_COUNT],
                NoNames[NO_NAMES_COUNT];


SID_NAME_USE    AllUses[ALL_NAMES_COUNT],
                SomeUses[SOME_NAMES_COUNT],
                NoUses[NO_NAMES_COUNT];

ULONG           AllRids[ALL_NAMES_COUNT],
                SomeRids[SOME_NAMES_COUNT],
                NoRids[NO_NAMES_COUNT];


PSID            BuiltinDomainSid,
                AccountDomainSid,
                PrimaryDomainSid,
                WorldSid,
                AdminsAliasSid,
                AccountAliasSid;


UNICODE_STRING  BuiltinDomainName,
                AccountDomainName,
                PrimaryDomainName;

BOOLEAN         AccountDomainIsNotPrimaryDomain;


//
// These are NOT mutually exclusive
//

BOOLEAN         BuiltinDomainTest,      // Test the builting domain
                SecurityOperatorTest,   // Test auditing accessibility
                AccountOpAliasTest,     // Test account operator functions
                AdminsAliasTest;        // Test domain admin functions



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private macros                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// VOID
// TST_SUCCESS_ASSERT( IN NTSTATUS S );
//

#define TST_SUCCESS_ASSERT( S )                                             \
{                                                                           \
    if ( !NT_SUCCESS((S)) ) {                                               \
        printf("\n** SUCCESS STATUS ASSERTION FAILURE **\n");             \
        printf("   Status is:  0x%lx\n", (S) );                           \
        ASSERT(NT_SUCCESS((S)));                                            \
    }                                                                       \
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




BOOLEAN
TInitialize( VOID );

BOOLEAN
EnableSecurityPrivilege( VOID );

VOID
DetermineTestsToRun( VOID );

VOID
SeeIfSidIsSpecial(
    IN PSID Sid
    );

BOOLEAN
ServerTestSuite(
    PHANDLE ServerHandle,
    PHANDLE DomainHandle,
    PHANDLE BuiltinDomainHandle,
    PSID    *DomainSid
    );

BOOLEAN
SecurityTestSuite(
    HANDLE ServerHandle,
    HANDLE DomainHandle,
    ULONG Pass
    );

BOOLEAN
CheckReturnedSD(
    IN SECURITY_INFORMATION SI,
    IN PSECURITY_DESCRIPTOR SD,
    IN BOOLEAN              PrintTestSuccess
    );


BOOLEAN
DomainTestSuite(
    HANDLE DomainHandle
    );

BOOLEAN
GroupTestSuite(
    HANDLE DomainHandle,
    ULONG  Pass
    );

BOOLEAN
AliasTestSuite(
    HANDLE DomainHandle,
    HANDLE BuiltinDomainHandle,
    PSID DomainSid,
    ULONG  Pass
    );

BOOLEAN
UserTestSuite(
    HANDLE DomainHandle,
    ULONG Pass
    );


NTSTATUS
SampSetDomainPolicy( VOID );


NTSTATUS
SampGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    );


//
// The following are in WRAPPERS.C, but are prototyped here since this
// test is the only thing that should ever call them.
//

NTSTATUS
SamTestPrivateFunctionsDomain(
    IN HANDLE DomainHandle
    );

NTSTATUS
SamTestPrivateFunctionsUser(
    IN HANDLE UserHandle
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
__cdecl main (
    VOID
    )

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS            NtStatus;
    SAM_HANDLE          ServerHandle, DomainHandle, BuiltinDomainHandle;
    PSID                DomainSid;
    BOOLEAN             TestSucceeded = FALSE;


    printf("\n\n\n\n");
    printf("                              Test:   TSAMOBJ\n\n");
    printf("                         Test Date:   \n");
    printf("                         Test Time:   \n");




    //
    // Initialize and determine which flavor test(s) to run
    //

    if (!TInitialize()) {
        return;
    }

    if (ServerTestSuite( &ServerHandle, &DomainHandle, &BuiltinDomainHandle, &DomainSid )) {

        //
        // Do security manipulation tests on domain object
        //

        if (SecurityTestSuite( ServerHandle, DomainHandle, 1)) {

            if (AdminsAliasTest) {

            //
            // Do individual tests for domain, group, and user objects.
            //

                if (DomainTestSuite( DomainHandle )) {

                    if (AdminsAliasTest) {

                        if (GroupTestSuite( DomainHandle, 1)) {

                            if (AliasTestSuite( DomainHandle, BuiltinDomainHandle, DomainSid, 1)) {

                                if (UserTestSuite( DomainHandle, 1 )) {

                                    if (SecurityTestSuite( ServerHandle, DomainHandle, 2)) {

                                        if (GroupTestSuite( DomainHandle, 2)) {

                                            if (AliasTestSuite( DomainHandle, BuiltinDomainHandle, DomainSid, 2)) {

                                                if (UserTestSuite( DomainHandle, 2)) {

                                                    TestSucceeded = TRUE;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                TestSucceeded = TRUE;
            }
        }

        SamFreeMemory(DomainSid);

        NtStatus = SamCloseHandle( DomainHandle );
        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Status of SamCloseHandle(Domain) is: 0x%lx\n", NtStatus);
            DbgBreakPoint();
            return;
        }

        NtStatus = SamCloseHandle( ServerHandle );
        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Status of SamCloseHandle(Server) is: 0x%lx\n", NtStatus);
            DbgBreakPoint();
            return;
        }

    }

    printf("\n");
    printf("\n");
    printf("  SAM Test:   ");
    if (TestSucceeded) {
        printf("Succeeded\n");
    } else {
        printf("**  Failed  **\n");
    }


    return;
}


BOOLEAN
TInitialize (
    VOID
    )

/*++

Routine Description:

    Initialize test variables, et cetera.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS NtStatus;
    STRING Name;
    ULONG i;

    SID_IDENTIFIER_AUTHORITY    WorldSidAuthority        = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    DomainSidAuthority       = {0,0,0,0,0,0};
    SID_IDENTIFIER_AUTHORITY    BuiltinAuthority         = SECURITY_NT_AUTHORITY;


    //
    // Get the domain SIDs from the policy database...
    //

    NtStatus = SampSetDomainPolicy();
    ASSERT(NT_SUCCESS(NtStatus));


    //
    // A random large integer value..
    //

    LargeInteger1.LowPart = 1234;
    LargeInteger1.HighPart = 0;

    LargeInteger2.LowPart = 4321;
    LargeInteger2.HighPart = 0;


    RtlInitString( &Name, DUMMY_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyName1, &Name, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    RtlInitString( &Name, DUMMY_NAME2 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyName2, &Name, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    RtlInitString( &DummyAnsiString1, DUMMY_STRING1 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyString1, &DummyAnsiString1, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    RtlInitString( &DummyAnsiString2, DUMMY_STRING2 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyString2, &DummyAnsiString2, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    DummyLogonHours.UnitsPerWeek = SAM_HOURS_PER_WEEK;
    DummyLogonHours.LogonHours   = &DummyLogonHoursBitMask[0];
    DummyLogonHoursBitMask[LOGON_HOURS_DIFFERENT_OFFSET] = 103; // Any non-zero value

    NoLogonRestriction.UnitsPerWeek = SAM_HOURS_PER_WEEK;
    NoLogonRestriction.LogonHours   = &NoLogonRestrictionBitMask[0];
    for ( i=0; i<(ULONG)((NoLogonRestriction.UnitsPerWeek+7)/8); i++) {
        NoLogonRestrictionBitMask[0] = 0;
    }



    //
    //  Initialize some SIDs
    //


    WorldSid = RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    ASSERT(WorldSid != NULL);
    RtlInitializeSid( WorldSid, &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( WorldSid, 0 )) = SECURITY_WORLD_RID;

    AdminsAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AdminsAliasSid != NULL);
    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    AccountAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AccountAliasSid != NULL);
    RtlInitializeSid( AccountAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AccountAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AccountAliasSid,  1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;




    //
    // Initialize some stuff for SID and NAME lookup operations
    //

    RtlInitString( &Name, LOOKUP_KNOWN_NAME0 );

    AllUses[0] = LOOKUP_KNOWN_NAME0_USE;  AllRids[0] = LOOKUP_KNOWN_NAME0_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &AllNames[0], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    SomeUses[0] = LOOKUP_KNOWN_NAME0_USE;  SomeRids[0] = LOOKUP_KNOWN_NAME0_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[0], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    if (AccountDomainIsNotPrimaryDomain == TRUE) {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME1_A );
    } else {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME1_P );
    }
    AllUses[1] = LOOKUP_KNOWN_NAME1_USE;  AllRids[1] = LOOKUP_KNOWN_NAME1_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &AllNames[1], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    SomeUses[1] = LOOKUP_KNOWN_NAME1_USE;  SomeRids[1] = LOOKUP_KNOWN_NAME1_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[1], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);

    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME0 );

    SomeUses[2] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[2], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    NoUses[0] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &NoNames[0], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME1 );

    SomeUses[3] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[3], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    NoUses[1] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &NoNames[1], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);



    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME2 );

    SomeUses[4] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[4], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    if (AccountDomainIsNotPrimaryDomain == TRUE) {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME2_A );
    } else {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME2_P );
    }
    AllUses[2] = LOOKUP_KNOWN_NAME2_USE;  AllRids[2] = LOOKUP_KNOWN_NAME2_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &AllNames[2], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    SomeUses[5] = LOOKUP_KNOWN_NAME2_USE;  SomeRids[5] = LOOKUP_KNOWN_NAME2_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[5], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);



    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME3 );

    SomeUses[6] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[6], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    DetermineTestsToRun();

    return(TRUE);
}


NTSTATUS
SampSetDomainPolicy(
    )
/*++


Routine Description:

    This routine sets the names and SIDs for the builtin and account domains.
    The builtin account domain has a well known name and SID.
    The account domain has these stored in the Policy database.


    It places the information for these domains in:

            BuiltinDomainSid
            BuiltinDomainName
            AccountDomainSid
            AccountDomainName
            PrimaryDomainSid
            PrimaryDomainName

    It also sets the boolean:

            AccountDomainIsNotPrimaryDomain

    to TRUE if the account domain is found to be different from the
    Primary Domain.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS NtStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    //
    // Builtin domain - well-known name and SID
    //

    RtlInitUnicodeString( &BuiltinDomainName, L"Builtin");

    BuiltinDomainSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( BuiltinDomainSid != NULL );
    RtlInitializeSid( BuiltinDomainSid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( BuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    //
    // Account domain
    //

    NtStatus = SampGetLsaDomainInfo(
                   &PolicyAccountDomainInfo,
                   &PolicyPrimaryDomainInfo
                   );

    if (!NT_SUCCESS(NtStatus)) {

        return(NtStatus);
    }

    AccountDomainSid = PolicyAccountDomainInfo->DomainSid;
    AccountDomainName = PolicyAccountDomainInfo->DomainName;

    PrimaryDomainSid = PolicyPrimaryDomainInfo->Sid;
    PrimaryDomainName = PolicyPrimaryDomainInfo->Name;

    //
    // Determine whether the account domain is a primary domain.
    //

    AccountDomainIsNotPrimaryDomain =
        !RtlEqualUnicodeString( &PrimaryDomainName, &AccountDomainName, TRUE);

    return(NtStatus);;
}



NTSTATUS
SampGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.

    PolicyPrimaryDomainInfo - Receives a pointer to a
        POLICY_PRIMARY_DOMAIN_INFO structure containing the Primary
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS Status, IgnoreStatus;

    LSA_HANDLE PolicyHandle;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( NULL,
                            &PolicyObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );
    if ( NT_SUCCESS(Status) ) {

        //
        // Query the account domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)PolicyAccountDomainInfo );
#if DBG
        if ( NT_SUCCESS(Status) ) {
            ASSERT( (*PolicyAccountDomainInfo) != NULL );
            ASSERT( (*PolicyAccountDomainInfo)->DomainSid != NULL );
            ASSERT( (*PolicyAccountDomainInfo)->DomainName.Buffer != NULL );
        }
#endif \\DBG

        //
        // Query the Primary domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyPrimaryDomainInformation,
                                            (PVOID *)PolicyPrimaryDomainInfo );
#if DBG
        if ( NT_SUCCESS(Status) ) {
            ASSERT( (*PolicyPrimaryDomainInfo) != NULL );
            ASSERT( (*PolicyPrimaryDomainInfo)->Sid != NULL );
            ASSERT( (*PolicyPrimaryDomainInfo)->Name.Buffer != NULL );
        }
#endif \\DBG

        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(Status);
}




PSID
CreateUserSid(
    PSID    DomainSid,
    ULONG   Rid
    )

/*++

Routine Description:

    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.

Arguments:

    None.

Return Value:

    Pointer to Sid, or NULL on failure.
    The returned Sid must be freed with DeleteUserSid

--*/
{

    NTSTATUS IgnoreStatus;
    PSID AccountSid;
    UCHAR AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    ULONG AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);
    PULONG  RidLocation;

    // Temp sanity check
    ASSERT(AccountSidLength == RtlLengthSid(DomainSid) + sizeof(ULONG));

    //
    // Allocate space for the account sid
    //

    AccountSid = MIDL_user_allocate(AccountSidLength);

    if (AccountSid != NULL) {

        //
        // Copy the domain sid into the first part of the account sid
        //

        IgnoreStatus = RtlCopySid(AccountSidLength, AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //

        *RtlSubAuthorityCountSid(AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //

        RidLocation = RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount - 1);
        *RidLocation = Rid;
    }

    return(AccountSid);
}



VOID
DeleteUserSid(
    PSID    UserSid
    )

/*++

Routine Description:

    Frees a sid returned by CreateUserSid.

Arguments:

    None.

Return Value:

    None.

--*/
{
    MIDL_user_free(UserSid);
}



BOOLEAN
EnableSecurityPrivilege(
    VOID
    )

/*++

Routine Description:

    This function enabled the SeSecurityPrivilege privilege.

Arguments:

    None.

Return Value:

    TRUE  if privilege successfully enabled.
    FALSE if not successfully enabled.

--*/
{

    NTSTATUS Status;
    HANDLE Token;
    LUID SecurityPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    if (!NT_SUCCESS(Status)) {
        printf(" \n\n\n");
        printf("Tsamobj: Can't open process token to enable Security Privilege.\n");
        printf("         Completion status of NtOpenProcessToken() is: 0x%lx\n", Status);
        printf("\n");
        return(FALSE);
    }


    //
    // Initialize the adjustment structure
    //

    SecurityPrivilege =
        RtlConvertLongToLargeInteger(SE_SECURITY_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = RtlAllocateHeap( RtlProcessHeap(), 0, 100 );

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = SecurityPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


    //
    // Set the state of the privilege to ENABLED.
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );
    // don't use NT_SUCCESS here because STATUS_NOT_ALL_ASSIGNED is a success status
    if (Status != STATUS_SUCCESS) {
        return(FALSE);
    }


    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, NewState );
    Status = NtClose( Token );
    ASSERT(NT_SUCCESS(Status));


    return TRUE;

}



VOID
printfSid(
    PSID    Sid
    )

/*++

Routine Description:

    Prints a sid

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR   Buffer[128];
    UCHAR   String[128];
    UCHAR   i;
    ULONG   Tmp;
    PISID   iSid = (PISID)Sid;  // pointer to opaque structure
    PSID    NextSid = (PSID)Buffer;

    ASSERT(sizeof(Buffer) >= RtlLengthRequiredSid(1));

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_WORLD_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("World");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Local");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_CREATOR_OWNER_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Creator");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_DIALUP_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Dialup");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_NETWORK_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Network");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_BATCH_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Batch");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_INTERACTIVE_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Interactive");
            return;
        }
    }


    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Local System");
            return;
        }
    }



    sprintf(Buffer, "S-%u-", (USHORT)iSid->Revision );
    strcpy(String, Buffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        sprintf(Buffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        strcat(String, Buffer);
    } else {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        sprintf(Buffer, "%lu", Tmp);
        strcat(String, Buffer);
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        sprintf(Buffer, "-%lu", iSid->SubAuthority[i]);
        strcat(String, Buffer);
    }

    printf(Buffer);

    return;
}


VOID
DetermineTestsToRun(
    VOID
    )

/*++

Routine Description:

    This function determines which tests are to be run.


Arguments:

    None.

Return Value:

    None.


--*/
{

    NTSTATUS            Status;
    HANDLE              Token;

    PTOKEN_USER         User;
    PTOKEN_GROUPS       Groups;

    ULONG               ReturnLength,
                        i;



    //
    // See if we can play with auditing information
    //

    SecurityOperatorTest = EnableSecurityPrivilege();


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_QUERY,
                 &Token
                 );
    if (!NT_SUCCESS(Status)) {
        printf(" \n\n\n");
        printf("Tsamobj: Can't open process token to query owner.\n");
        printf("         Completion status of NtOpenProcessToken() is: 0x%lx\n", Status);
        printf("\n");
        return;
    }


    //
    // Query the user id
    //

    User   = RtlAllocateHeap( RtlProcessHeap(), 0, 1000 ); // should be plenty big
    Status = NtQueryInformationToken( Token, TokenUser, User, 1000, &ReturnLength );
    ASSERT(NT_SUCCESS(Status));

    //
    // See if the ID is one of the special IDs (e.g., local admin,
    // domain account operator, or domain admin)
    //

    SeeIfSidIsSpecial( User->User.Sid );



    //
    // Query the group ids
    //

    Groups = RtlAllocateHeap( RtlProcessHeap(), 0, 1000 ); // should be plenty big
    Status = NtQueryInformationToken( Token, TokenGroups, Groups, 1000, &ReturnLength );
    ASSERT(NT_SUCCESS(Status));

    //
    // See if any of these IDs are special IDs
    //

    for (i=0; i<Groups->GroupCount; i++) {
        SeeIfSidIsSpecial( Groups->Groups[i].Sid );
    }





    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, User );
    RtlFreeHeap( RtlProcessHeap(), 0, Groups );
    Status = NtClose( Token );
    ASSERT(NT_SUCCESS(Status));



    printf("\n\n\n\nPerforming:\n\n");

    printf("        Administrator Alias Test. . . . . ");
    if (AdminsAliasTest) {
        printf("Yes\n\n");
    } else {
        printf("No\n\n");
    }

    printf("        Account Operator Alias  Test  . . ");
    if (AccountOpAliasTest) {
        printf("Yes\n\n");
    } else {
        printf("No\n\n");
    }

    printf("        Security Operator  Test . . . . . ");
    if (SecurityOperatorTest) {
        printf("Yes\n\n");
    } else {
        printf("No\n\n");
    }

    printf("\n\n\n");



    return;

}


VOID
SeeIfSidIsSpecial(
    IN PSID Sid
    )

/*++

Routine Description:

    This function determines whether the passed SID is one of the special
    SIDs, such as ADMINISTRATORS alias, or DomainAccountOperator, and
    sets test flags accordingly.


Arguments:

    Sid - Pointer to the SID to check.

Return Value:

    None.


--*/
{




    if (RtlEqualSid( Sid, AdminsAliasSid )){
        AdminsAliasTest = TRUE;
    }

    if (RtlEqualSid( Sid, AccountAliasSid )){
        AccountOpAliasTest = TRUE;
    }

    return;

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Server Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
ServerTestSuite(
    PHANDLE ServerHandle,
    PHANDLE DomainHandle,
    PHANDLE BuiltinDomainHandle,
    PSID    *DomainSid
    )

{
    NTSTATUS                        NtStatus;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    BOOLEAN                         TestStatus = TRUE;
    ULONG                           CountReturned;
    SAM_ENUMERATE_HANDLE            EnumerationContext;
    PSAM_RID_ENUMERATION            EnumerationBuffer;
    PSID                            BuiltinDomainSid;
    ACCESS_MASK                     ServerAccessMask, DomainAccessMask;





    printf("\n");
    printf("\n");
    printf("  Server Object                                           Test\n");

    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Connect To Server                                                     //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("\n");
    printf("    Connect / Disconnect. . . . . . . . . . . . . . . . .   Suite\n");

    printf("      Connect . . . . . . . . . . . . . . . . . . . . . .     ");


    ServerAccessMask = SAM_SERVER_READ | SAM_SERVER_EXECUTE;
    if (AdminsAliasTest) {
        ServerAccessMask |= SAM_SERVER_ALL_ACCESS;
    }
    if (SecurityOperatorTest) {
        ServerAccessMask |= ACCESS_SYSTEM_SECURITY;
    }

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  ServerHandle,
                  ServerAccessMask,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    if (NT_SUCCESS(NtStatus)) {

        printf("      Disconnect  . . . . . . . . . . . . . . . . . . . .     ");

        NtStatus = SamCloseHandle( (*ServerHandle) );

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        } else {
            printf("Succeeded\n");
        }
    }



    printf("      Re-Connect  . . . . . . . . . . . . . . . . . . . .     ");


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  ServerHandle,
                  ServerAccessMask,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Lookup/Enumerate Domains Suite                                        //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////


    printf("\n");
    printf("    Domain Lookup/Enumerate/Open  . . . . . . . . . . . .   Suite\n");



    if (NT_SUCCESS(NtStatus)) {

        printf("      Lookup Account Domain . . . . . . . . . . . . . . .     ");


        NtStatus = SamLookupDomainInSamServer(
                       (*ServerHandle),
                       &AccountDomainName,
                       DomainSid
                       );

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        } else {
            if ( TRUE != RtlEqualSid((*DomainSid), AccountDomainSid)) {
                printf("Failed\n");
                printf("        The SID retrieved from the policy database did not\n");
                printf("        match the SID retrieved from SAM for the account\n");
                printf("        domain.\n");
                printf("        Sid from Policy Database is: ");
                printfSid(      AccountDomainSid ); printf("\n");
                printf("        Sid from SAM is: ");
                printfSid(      (*DomainSid) ); printf("\n");
                TestStatus = FALSE;
            } else {
                printf("Succeeded\n");
            }
        }

    }






    if (NT_SUCCESS(NtStatus)) {

        printf("      Enumerate Domain  . . . . . . . . . . . . . . . . .     ");


        EnumerationContext = 0;
        EnumerationBuffer = NULL;
        NtStatus = SamEnumerateDomainsInSamServer(
                       (*ServerHandle),
                       &EnumerationContext,
                       (PVOID *)&EnumerationBuffer,
                       1024,                        // PreferedMaximumLength
                       &CountReturned
                       );

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        } else {

            if (CountReturned == 0) {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        CountReturned is: 0x%lx\n", CountReturned);
                printf("        EnumerationContext is: 0x%lx\n", EnumerationContext);
                printf("        EnumerationBuffer Address is: 0x%lx\n", (ULONG)EnumerationBuffer);
                TestStatus = FALSE;

            } else {
                printf("Succeeded\n");
            }

            SamFreeMemory( EnumerationBuffer );
        }

    }






    if (NT_SUCCESS(NtStatus)) {

        printf("      Open Account Domain . . . . . . . . . . . . . . . .     ");

        if (NT_SUCCESS(NtStatus)) {

            DomainAccessMask = DOMAIN_READ | DOMAIN_EXECUTE;
            if (AccountOpAliasTest) {
                DomainAccessMask |= DOMAIN_READ | DOMAIN_WRITE | DOMAIN_EXECUTE;
            }
            if (AdminsAliasTest) {
                DomainAccessMask |= DOMAIN_ALL_ACCESS;
            }
            if (SecurityOperatorTest) {
                DomainAccessMask |= ACCESS_SYSTEM_SECURITY;
            }
            NtStatus = SamOpenDomain(
                           (*ServerHandle),
                           DomainAccessMask,
                           *DomainSid,
                           DomainHandle
                           );

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            } else {
                printf("Succeeded\n");
            }
        }

    }

    if (NT_SUCCESS(NtStatus)) {

        printf("      Open Builtin Domain . . . . . . . . . . . . . . . .     ");

        NtStatus = SamLookupDomainInSamServer(
                       (*ServerHandle),
                       &BuiltinDomainName,
                       &BuiltinDomainSid
                       );

        if (NT_SUCCESS(NtStatus)) {

            DomainAccessMask = DOMAIN_READ | DOMAIN_EXECUTE;
            if (AccountOpAliasTest) {
                DomainAccessMask |= DOMAIN_READ | DOMAIN_WRITE | DOMAIN_EXECUTE;
            }
            if (AdminsAliasTest) {
                DomainAccessMask |= (DOMAIN_EXECUTE | DOMAIN_READ |
                                     DOMAIN_READ_OTHER_PARAMETERS |
                                     DOMAIN_ADMINISTER_SERVER     |
                                     DOMAIN_CREATE_ALIAS);
            }
//            if (SecurityOperatorTest) {
//                DomainAccessMask |= ACCESS_SYSTEM_SECURITY;
//            }
            NtStatus = SamOpenDomain(
                           (*ServerHandle),
                           DomainAccessMask,
                           BuiltinDomainSid,
                           BuiltinDomainHandle
                           );

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            } else {
                printf("Succeeded\n");
            }
        }

    }

    return(TestStatus);


}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Security Manipulation Test Suite                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SecurityTestSuite(
    HANDLE ServerHandle,
    HANDLE DomainHandle,
    ULONG Pass
    )
{

    BOOLEAN                 TestStatus = TRUE;
    NTSTATUS                NtStatus;

    PSECURITY_DESCRIPTOR    OriginalServerSD,
                            OriginalDomainSD,
                            OriginalUserSD,
                            OriginalGroupSD,
                            SD1;

    SECURITY_INFORMATION    SI1;
    PVOID TmpPointer1;

    SECURITY_DESCRIPTOR     SD1_Body;

    HANDLE                  GroupHandle,
                            UserHandle;




    printf("\n");
    printf("\n");
    printf("\n");

    if (Pass == 1) {

        printf("  Security Manipulation (Pass #1)                         Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query Suite                                                           //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Query Security  . . . . . . . . . . . . . . . . . . .   Suite\n");


        //
        // Get Server's original SD
        //


        SI1 = 0;
        if (AdminsAliasTest) {
            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
        }
        if (SecurityOperatorTest) {
            SI1 |= SACL_SECURITY_INFORMATION;
        }
        if (SI1 != 0) {
            printf("      Query Server Security Descriptor  . . . . . . . . . .     ");
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           ServerHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );

                //
                // Normally we would do a "SamFreeMemory( SD1 )" here.
                // However, we want to save this SD for future reference
                // and use.
                //

                OriginalServerSD = SD1;

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        //
        // Get domain's original SD
        //


        SI1 = 0;
        if (AdminsAliasTest) {
            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
        }
        if (SecurityOperatorTest) {
            SI1 |= SACL_SECURITY_INFORMATION;
        }
        if (SI1 != 0) {
            printf("      Query Domain Security Descriptor  . . . . . . . . . .     ");
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );

                //
                // Normally we would do a "SamFreeMemory( SD1 )" here.
                // However, we want to save this SD for future reference
                // and use.
                //

                OriginalDomainSD = SD1;

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }






        //
        // Make sure the wrapper doesn't choke on a non-null pointer being passed
        // (assuming we have allocated memory).
        //


        SI1 = 0;
        if (AdminsAliasTest) {
            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
        }
        if (SecurityOperatorTest) {
            SI1 |= SACL_SECURITY_INFORMATION;
        }
        if (SI1 != 0) {
            printf("      Query Passing Non-null return buffer  . . . . . . . .     ");
            SD1 = RtlAllocateHeap( RtlProcessHeap(), 0, 1000 ); ASSERT(SD1 != NULL);
            TmpPointer1 = SD1;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {
                if (SD1 != TmpPointer1) {

                    TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                    if (TestStatus) {
                        SamFreeMemory( SD1 );
                    }


                } else {
                    printf("Failed\n");
                    printf("        Passed buffer address used on return.\n");
                    printf("        RPC should have allocated another buffer.\n");
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }


            RtlFreeHeap( RtlProcessHeap(), 0, TmpPointer1 );

        }






        //
        // Make sure we can query nothing
        //

        printf("      Query Nothing . . . . . . . . . . . . . . . . . . . .     ");

        SI1 = 0;
        SD1 = NULL;
        NtStatus = SamQuerySecurityObject(
                       DomainHandle,
                       SI1,
                       &SD1
                       );
        if (NT_SUCCESS(NtStatus)) {

            TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
            if (TestStatus) {
                SamFreeMemory( SD1 );
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }





        //
        // Query owner
        //


        if (AdminsAliasTest) {
            printf("      Query Owner (Server Object) . . . . . . . . . . . . .     ");
            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           ServerHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }




        if (AdminsAliasTest) {
            printf("      Query Owner (Domain Object) . . . . . . . . . . . . .     ");
            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        if (AdminsAliasTest) {

            //
            // Query Group
            //

            printf("      Query Group . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // Query Dacl
            //

            printf("      Query DACL  . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // Query Sacl
            //

            printf("      Query SACL  . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = SACL_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }

        }  // end_if (AdminsAliasTest)





        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Suite                                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Security  . . . . . . . . . . . . . . . . . . . .   Suite\n");


        //
        // Make sure we can set nothing
        //

        printf("      Set Nothing . . . . . . . . . . . . . . . . . . . . .     ");

        SI1 = 0;
        SD1 = &SD1_Body;
        NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
        ASSERT( NT_SUCCESS(NtStatus) );
        NtStatus = SamSetSecurityObject(
                       DomainHandle,
                       SI1,     // <------ This is invalid
                       SD1
                       );
        if (NtStatus == STATUS_INVALID_PARAMETER) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }






        //
        // set something not passed
        //

        printf("      Set something not passed. . . . . . . . . . . . . . .     ");

        SI1 = GROUP_SECURITY_INFORMATION;
        SD1 = &SD1_Body;
        NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
        ASSERT( NT_SUCCESS(NtStatus) );
        NtStatus = SamSetSecurityObject(
                       DomainHandle,
                       SI1,
                       SD1
                       );
        if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }






        //
        // set a non-existant DACL
        //

        if (AdminsAliasTest) {
            printf("      Set non-existant DACL (Server object) . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_DACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           ServerHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }



        if (AdminsAliasTest) {
            printf("      Set non-existant DACL (Domain Object) . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_DACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        //
        // set original DACL (From original SD)
        //

        if (AdminsAliasTest) {

            printf("      Set original DACL (Server Object) . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = OriginalServerSD;
            NtStatus = SamSetSecurityObject(
                           ServerHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }



        if (AdminsAliasTest) {

            printf("      Set original DACL (Domain Object) . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = OriginalDomainSD;
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        if (AdminsAliasTest) {

            //
            // set a non-existant SACL
            //

            printf("      Set non-existant SACL . . . . . . . . . . . . . . . .     ");

            SI1 = SACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_SACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set original SACL (From original SD)
            //

            printf("      Set original SACL . . . . . . . . . . . . . . . . . .     ");

            SI1 = SACL_SECURITY_INFORMATION;
            SD1 = OriginalDomainSD;
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // set a owner to null
            //

            printf("      Set null Owner  . . . . . . . . . . . . . . . . . . .     ");

            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Owner = NULL;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // set owner to invalid value
            //

            printf("      Set owner to invalid value  . . . . . . . . . . . . .     ");

            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Owner = WorldSid;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_INVALID_OWNER) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }




            //
            // set a owner to valid value
            //

            printf("      Set owner to valid value  . . . . . . . . . . . . . .     ");

            printf("Untested\n");





            //
            // set group to null
            //

            printf("      Set null Group  . . . . . . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Group = NULL;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set Group to valid value
            //

            printf("      Set Group to valid value  . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Group = WorldSid;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // set Group back to original value
            //

            printf("      Set Group to original value . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = OriginalDomainSD;
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }




    }   // end Pass1


    if (Pass == 2) {

        ACCESS_MASK         AccessMask;
        PSID_NAME_USE       LookedUpUses;
        PULONG              LookedUpRids;
        UNICODE_STRING      AccountNames[10];
        STRING              AccountNameAnsi;


        //
        // This pass depends upon user and group accounts established in pass #1
        //





        if (AdminsAliasTest) {


            printf("  Security Manipulation (Pass #2)                         Test\n");

            ///////////////////////////////////////////////////////////////////////////
            //                                                                       //
            // Query Suite                                                           //
            //                                                                       //
            ///////////////////////////////////////////////////////////////////////////

            printf("\n");
            printf("    Query Security (User Object). . . . . . . . . . . . .   Suite\n");


            AccessMask = READ_CONTROL;
            if (SecurityOperatorTest) {
                AccessMask |= ACCESS_SYSTEM_SECURITY;
            }

            //
            // Open the user created in pass #1
            //

            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            NtStatus = SamOpenUser(
                           DomainHandle,
                           AccessMask,
                           LookedUpRids[0],
                           &UserHandle);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed to open user account created in pass #1\n");
            }
            TST_SUCCESS_ASSERT(NT_SUCCESS(NtStatus));



            //
            // Get user's original SD
            //

            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
            if (SecurityOperatorTest) {
                SI1 |= SACL_SECURITY_INFORMATION;
            }

            printf("      Query User Security Descriptor  . . . . . . . . . . .     ");
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           UserHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );

                //
                // Normally we would do a "SamFreeMemory( SD1 )" here.
                // However, we want to save this SD for future reference
                // and use.
                //

                OriginalUserSD = SD1;

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            NtStatus = SamCloseHandle( UserHandle );
            TST_SUCCESS_ASSERT( UserHandle );



            ///////////////////////////////////////////////////////////////////////////
            //                                                                       //
            // Set Suite                                                             //
            //                                                                       //
            ///////////////////////////////////////////////////////////////////////////

            printf("\n");
            printf("    Set Security  (User Object) . . . . . . . . . . . . .   Suite\n");

            AccessMask = WRITE_DAC | WRITE_OWNER;
            if (SecurityOperatorTest) {
                AccessMask |= ACCESS_SYSTEM_SECURITY;
            }

            //
            // Open the user created in pass #1
            //

            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            NtStatus = SamOpenUser(
                           DomainHandle,
                           AccessMask,
                           LookedUpRids[0],
                           &UserHandle);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed to open user account created in pass #1\n");
            }
            TST_SUCCESS_ASSERT(NT_SUCCESS(NtStatus));


            //
            // Make sure we can set nothing
            //

            printf("      Set Nothing . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = 0;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,     // <------ This is invalid
                           SD1
                           );
            if (NtStatus == STATUS_INVALID_PARAMETER) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set something not passed
            //

            printf("      Set something not passed. . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }








            printf("      Set non-existant DACL . . . . . . . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_DACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set original DACL (From original SD)
            //


            printf("      Set original DACL . . . . . . . . . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = OriginalUserSD;
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }







            NtStatus = SamCloseHandle( UserHandle );
            TST_SUCCESS_ASSERT( UserHandle );



        }

        DBG_UNREFERENCED_LOCAL_VARIABLE( GroupHandle );
        DBG_UNREFERENCED_LOCAL_VARIABLE( OriginalGroupSD );
    }





    return TestStatus;
}


BOOLEAN
CheckReturnedSD(
    IN SECURITY_INFORMATION SI,
    IN PSECURITY_DESCRIPTOR SD,
    IN BOOLEAN              PrintTestSuccess
    )


{
    NTSTATUS NtStatus;

    BOOLEAN  Failed = FALSE,
             IgnoreBoolean,
             AclPresent,
             TestStatus = TRUE;

    PSID     SID;
    PACL     ACL;



    //
    // Check a returned security descriptor agains the information requested.
    //

    if (SD == NULL) {
        TestStatus = FALSE;
        if (PrintTestSuccess) {
            printf("Failed\n");
            Failed = TRUE;
            printf("        The SecurityDescriptor return address was not properly\n");
            printf("        set.\n");
        }
    }


    if (TestStatus) {

        //
        // Check owner
        //

        NtStatus = RtlGetOwnerSecurityDescriptor ( SD, &SID, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & OWNER_SECURITY_INFORMATION) {
            if (SID == NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An owner was requested but the owner field of the\n");
                    printf("        security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // Owner not specified
            if (SID != NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An owner was not requested but the owner field of the\n");
                    printf("        security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }




        //
        // Check group
        //

        NtStatus = RtlGetGroupSecurityDescriptor ( SD, &SID, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & GROUP_SECURITY_INFORMATION) {
            if (SID == NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A group was requested but the group field of the\n");
                    printf("        security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // Group not specified
            if (SID != NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A group was not requested but the group field of the\n");
                    printf("        security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }




        //
        // Check sacl
        //

        NtStatus = RtlGetSaclSecurityDescriptor ( SD, &AclPresent, &ACL, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & SACL_SECURITY_INFORMATION) {
            if (!AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An SACL was requested but the SaclPresent flag\n");
                    printf("        of the security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // sacl not specified
            if (AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An SACL was not requested but the SaclPresent flag\n");
                    printf("        of the security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }





        //
        // Check Dacl
        //

        NtStatus = RtlGetDaclSecurityDescriptor ( SD, &AclPresent, &ACL, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & DACL_SECURITY_INFORMATION) {
            if (!AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A DACL was requested but the DaclPresent flag\n");
                    printf("        of the security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // Dacl not specified
            if (AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A DACL was not requested but the DaclPresent flag\n");
                    printf("        of the security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }





    }




    if (PrintTestSuccess) {
        if (TestStatus) {
            printf("Succeeded\n");
        }
    }



    return(TestStatus);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Domain Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
DomainTestSuite(
    HANDLE DomainHandle
    )
{

    BOOLEAN  TestStatus = TRUE;
    NTSTATUS NtStatus, IgnoreStatus;
    PVOID    Buffer, Buffer1, Buffer2;
    CHAR     UnusedBuffer[20];
    UNICODE_STRING      AccountName;
    STRING              AccountNameAnsi;
    HANDLE GroupHandle = NULL;
    HANDLE AliasHandle = NULL;
    HANDLE UserHandle = NULL;
    HANDLE ValidUserHandle = NULL;
    ULONG  GroupRid, AliasRid, UserRid, SavedGroupRid, SavedAliasRid, AccountCount, i;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    ULONG   CountReturned;
    USHORT NameLength;
    PUNICODE_STRING  LookedUpNames;
    PSID_NAME_USE    LookedUpUses;
    PULONG           LookedUpRids;


    printf("\n");
    printf("\n");
    printf("\n");
    printf("  Domain                                                  Test\n");

    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Query Suite                                                           //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("\n");
    printf("    Query Information . . . . . . . . . . . . . . . . . .   Suite\n");


    //
    // Make sure the wrapper doesn't choke on a non-null pointer being passed
    // (assuming we have allocated memory).
    //

    printf("      Query Buffer Allocation Test  . . . . . . . . . . . .     ");

    Buffer = &UnusedBuffer[0];
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainStateInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != &UnusedBuffer[0]) {
            if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Passed buffer address used on return.\n");
            printf("        RPC should have allocated another buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }


    //
    // Query all the fixed length info levels
    //  Query - Password, Logoff, ServerRole, DomainState, ModifiedCount, LockoutInfo
    //

    printf("      Query DomainState . . . . . . . . . . . . . . . . . .     ");

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainStateInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query ServerRole  . . . . . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainServerRoleInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Password Information  . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainPasswordInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Logoff Information  . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLogoffInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Modified  . . . . . . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainModifiedInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Lockout . . . . . . . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLockoutInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }





    //
    // Query the name of the domain ...
    //

    printf("      Query Domain Name . . . . . . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainNameInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if ( (((DOMAIN_NAME_INFORMATION *)Buffer)->DomainName.MaximumLength > 0) &&
                 (((DOMAIN_NAME_INFORMATION *)Buffer)->DomainName.Buffer != NULL) ) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        String body returned and allocated,\n");
                printf("        but character buffer pointer is NULL.\n");
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query whatever is in the OEM Information field ...
    //

    printf("      Query OEM Information . . . . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainOemInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if ( (((DOMAIN_OEM_INFORMATION *)Buffer)->OemInformation.MaximumLength >= 0) &&
                 (((DOMAIN_OEM_INFORMATION *)Buffer)->OemInformation.Buffer != NULL) ) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        String body returned and allocated,\n");
                printf("        but character buffer pointer is NULL.\n");
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query whatever is in the Replication Information field ...
    //

    printf("      Query Replication Information . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainReplicationInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if ( (((DOMAIN_REPLICATION_INFORMATION *)Buffer)->ReplicaSourceNodeName.MaximumLength >= 0) &&
                 (((DOMAIN_REPLICATION_INFORMATION *)Buffer)->ReplicaSourceNodeName.Buffer != NULL) ) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        String body returned and allocated,\n");
                printf("        but character buffer pointer is NULL.\n");
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query domain general Information...
    //

    printf("      Query General Information . . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainGeneralInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {

            printf("Succeeded\n");
            printf("          Number of Users  is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION *)Buffer)->UserCount );
            printf("          Number of groups is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION *)Buffer)->GroupCount);
            printf("          Number of aliases is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION *)Buffer)->AliasCount);


            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query domain general Information...
    //

    printf("      Query General Information 2 . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainGeneralInformation2,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {

            printf("Succeeded\n");
            printf("          Number of Users  is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION2 *)Buffer)->I1.UserCount );
            printf("          Number of groups is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION2 *)Buffer)->I1.GroupCount);
            printf("          Number of aliases is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION2 *)Buffer)->I1.AliasCount);


            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }








    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Set Suite                                                             //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("    Set Information . . . . . . . . . . . . . . . . . . .   Suite\n");

    //
    // Set all the fixed length info levels
    //   - Password, Logoff, ServerRole, DomainState, ModifiedCount
    //

/*
 *  CANT TEST SERVER STATE SETTING WITHOUT BREAKING THE REST OF THE TEST.
 *  THE REASON IS, ONCE THE STATE IS CHANGED, NOTHING ELSE CAN BE DONE.
 *
 *    printf("      Set DomainState . . . . . . . . . . . . . . . . . . .     ");
 *
 *    //
 *    // Get the current value...
 *    //
 *
 *    NtStatus = SamQueryInformationDomain(
 *                   DomainHandle,
 *                   DomainStateInformation,
 *                   &Buffer1
 *                   );
 *    ASSERT( NT_SUCCESS(NtStatus) );
 *
 *    //
 *    // Change the field to a new value and write it out.
 *    //
 *
 *    if ( ((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState ==
 *         DomainServerEnabled ) {
 *        ((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState =
 *            DomainServerDisabled;
 *    } else {
 *        ((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState =
 *            DomainServerEnabled;
 *    }
 *
 *    NtStatus = SamSetInformationDomain(
 *                   DomainHandle,
 *                   DomainStateInformation,
 *                   Buffer1
 *                   );
 *    if ( NT_SUCCESS(NtStatus) ) {
 *
 *        //
 *        // Now check that the change was really made...
 *        //
 *
 *        NtStatus = SamQueryInformationDomain(
 *                       DomainHandle,
 *                       DomainStateInformation,
 *                       &Buffer2
 *                       );
 *        ASSERT(NT_SUCCESS( NtStatus ) );
 *        if (((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState ==
 *            ((DOMAIN_STATE_INFORMATION *)Buffer2)->DomainServerState    ) {
 *
 *                printf("Succeeded\n");
 *
 *        } else {
 *
 *            printf("Failed\n");
 *            printf("        Value queried doesn't match value written\n");
 *            printf("        Value Written is   0x%lx\n",
 *                (ULONG)((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState);
 *            printf("        Value Retrieved is 0x%lx\n",
 *                (ULONG)((DOMAIN_STATE_INFORMATION *)Buffer2)->DomainServerState);
 *
 *            TestStatus = FALSE;
 *
 *        }
 *
 *        SamFreeMemory( Buffer1 );
 *        SamFreeMemory( Buffer2 );
 *
 *    } else {
 *        printf("Failed\n");
 *        printf("        Completion status is 0x%lx\n", NtStatus);
 *        TestStatus = FALSE;
 *        SamFreeMemory( Buffer1 );
 *
 *    }
 */



/*
 *  CANT TEST SERVER ROLE SETTING WITHOUT BREAKING THE REST OF THE TEST.
 *  THE REASON IS, ONCE THE ROLE IS SET TO BACKUP, NOTHING ELSE CAN BE
 *  SET.
 *
 *   printf("      Set ServerRole  . . . . . . . . . . . . . . . . . . .     ");
 *
 *   //
 *   // Get the current value...
 *   //
 *
 *   NtStatus = SamQueryInformationDomain(
 *                  DomainHandle,
 *                  DomainServerRoleInformation,
 *                  &Buffer1
 *                  );
 *   ASSERT( NT_SUCCESS(NtStatus) );
 *
 *   //
 *   // Change the field to a new value and write it out.
 *   //
 *
 *   if ( ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole ==
 *        DomainServerRolePrimary ) {
 *       ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole =
 *           DomainServerRoleBackup;
 *   } else {
 *       ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole =
 *           DomainServerRolePrimary;
 *   }
 *
 *   NtStatus = SamSetInformationDomain(
 *                  DomainHandle,
 *                  DomainServerRoleInformation,
 *                  Buffer1
 *                  );
 *   if ( NT_SUCCESS(NtStatus) ) {
 *
 *       //
 *       // Now check that the change was really made...
 *       //
 *
 *       NtStatus = SamQueryInformationDomain(
 *                      DomainHandle,
 *                      DomainServerRoleInformation,
 *                      &Buffer2
 *                      );
 *       ASSERT(NT_SUCCESS( NtStatus ) );
 *       if (((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole ==
 *           ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer2)->DomainServerRole    ) {
 *
 *               printf("Succeeded\n");
 *
 *       } else {
 *
 *           printf("Failed\n");
 *           printf("        Value queried doesn't match value written\n");
 *           printf("        Value Written is   0x%lx\n",
 *               (ULONG)((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole);
 *           printf("        Value Retrieved is 0x%lx\n",
 *               (ULONG)((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer2)->DomainServerRole);
 *
 *           TestStatus = FALSE;
 *
 *       }
 *
 *       SamFreeMemory( Buffer1 );
 *       SamFreeMemory( Buffer2 );
 *
 *   } else {
 *       printf("Failed\n");
 *       printf("        Completion status is 0x%lx\n", NtStatus);
 *       TestStatus = FALSE;
 *       SamFreeMemory( Buffer1 );
 *
 *   }
 */



    printf("      Set Password Information  . . . . . . . . . . . . . .     ");


    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainPasswordInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change a field to a new value and write it out.
    //

    if ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength == 0 ) {
         ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength =  6;
    } else {
        ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength =   0;
    }

    //
    // Set PasswordProperties to COMPLEX so that tests run after this one
    // are a little more interesting.
    //

    ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->PasswordProperties |= DOMAIN_PASSWORD_COMPLEX;

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainPasswordInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainPasswordInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength ==
            ((DOMAIN_PASSWORD_INFORMATION *)Buffer2)->MinPasswordLength    ) {

                printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_PASSWORD_INFORMATION *)Buffer2)->MinPasswordLength);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }



    printf("      Set Logoff Information  . . . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLogoffInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    if ( ((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart == 0 ) {
         ((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart = 1000;
    } else {
        ((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart =   0;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainLogoffInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainLogoffInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart ==
            ((DOMAIN_LOGOFF_INFORMATION *)Buffer2)->ForceLogoff.LowPart    ) {

                printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOGOFF_INFORMATION *)Buffer2)->ForceLogoff.LowPart);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }



    printf("      Set Modified  . . . . . . . . . . . . . . . . . . . .     ");


    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainModifiedInformation,
                   &LargeInteger1
                   );

    if (NtStatus != STATUS_INVALID_INFO_CLASS) {

        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    printf("      Set Lockout Information . . . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLockoutInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart == 0 ) {
         ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart = 9000000;
    } else {
        ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart =   0;
    }
    if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart == 0 ) {
         ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart = 8000000;
    } else {
        ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart =   0;
    }
    if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold == 0 ) {
         ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold =  2;
    } else {
        ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold  =  0;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainLockoutInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainLockoutInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if ( (((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart ==
             ((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutDuration.LowPart    ) &&
             (((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart ==
             ((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutObservationWindow.LowPart    ) &&
             (((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold ==
             ((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutThreshold    ) ) {

                printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Duration Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart);
            printf("        Duration  Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutDuration.LowPart);
            printf("        Window Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart);
            printf("        Window  Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutObservationWindow.LowPart);
            printf("        Duration Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold);
            printf("        Duration  Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutThreshold);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }




    printf("      Set Domain Name . . . . . . . . . . . . . . . . . . .     ");


    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainNameInformation,
                   &DummyName1
                   );

    if (NtStatus != STATUS_INVALID_INFO_CLASS) {

        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    printf("      Set OEM Information . . . . . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainOemInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    NameLength = ((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation.Length;
    if (  NameLength == DummyName1.Length ) {
        ((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation = DummyName2;
    } else {
        ((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation = DummyName1;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainOemInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainOemInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation.Length ==
            ((DOMAIN_OEM_INFORMATION *)Buffer2)->OemInformation.Length    ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation.Length);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_OEM_INFORMATION *)Buffer2)->OemInformation.Length);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }




    printf("      Set Replication Information . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainReplicationInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    NameLength = ((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName.Length;
    if (  NameLength == DummyName1.Length ) {
        ((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName = DummyName2;
    } else {
        ((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName = DummyName1;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainReplicationInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainReplicationInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName.Length ==
            ((DOMAIN_REPLICATION_INFORMATION *)Buffer2)->ReplicaSourceNodeName.Length    ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName.Length);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_REPLICATION_INFORMATION *)Buffer2)->ReplicaSourceNodeName.Length);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }




    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Create User/Group/Alias Suite                                         //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("    Create User/Group/Alias . . . . . . . . . . . . . . . .   Suite\n");


    printf("      Create Group  . . . . . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (GroupHandle == NULL) || (GroupRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid GroupHandle or GroupRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        GroupHandle value is: 0x%lx\n", (ULONG)GroupHandle);
        printf("        GroupRid value is:    0x%lx\n", GroupRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            SavedGroupRid = GroupRid;
            NtStatus = SamCloseHandle( GroupHandle );
            if (!NT_SUCCESS(NtStatus)) {
                printf("        SamCloseHandle() completion status is: 0x%lx\n", NtStatus);
            }
            ASSERT( NT_SUCCESS(NtStatus) );

        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Create Duplicate Group  . . . . . . . . . . . . . . .     ");
    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_GROUP_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_GROUP_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create Alias  . . . . . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   ALIAS_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (AliasHandle == NULL) || (AliasRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid AliasHandle or AliasRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        AliasHandle value is: 0x%lx\n", (ULONG)AliasHandle);
        printf("        AliasRid value is:    0x%lx\n", AliasRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            SavedAliasRid = AliasRid;
            NtStatus = SamCloseHandle( AliasHandle );
            if (!NT_SUCCESS(NtStatus)) {
                printf("        SamCloseHandle() completion status is: 0x%lx\n", NtStatus);
            }
            ASSERT( NT_SUCCESS(NtStatus) );


            if (AliasRid == SavedGroupRid) {
                printf("      Create Group/Alias Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new alias and group.\n");
                TestStatus = FALSE;
            }
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Create another Alias  . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME2 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   ALIAS_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (AliasHandle == NULL) || (AliasRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid AliasHandle or AliasRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        AliasHandle value is: 0x%lx\n", (ULONG)AliasHandle);
        printf("        AliasRid value is:    0x%lx\n", AliasRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            SavedAliasRid = AliasRid;
            NtStatus = SamCloseHandle( AliasHandle );
            if (!NT_SUCCESS(NtStatus)) {
                printf("        SamCloseHandle() completion status is: 0x%lx\n", NtStatus);
            }
            ASSERT( NT_SUCCESS(NtStatus) );


            if (AliasRid == SavedGroupRid) {
                printf("      Create Group/Alias Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new alias and group.\n");
                TestStatus = FALSE;
            }
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Create Duplicate Alias  . . . . . . . . . . . . . . .     ");
    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   ALIAS_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_ALIAS_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_ALIAS_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }





    printf("      Create User . . . . . . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, USER_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (UserHandle == NULL) || (UserRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid UserHandle or UserRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        UserHandle value is: 0x%lx\n", (ULONG)UserHandle);
        printf("        UserRid value is:    0x%lx\n", UserRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            ValidUserHandle = UserHandle;


            if (UserRid == SavedGroupRid) {
                printf("      Create Group/User Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new user and group.\n");
                TestStatus = FALSE;
            }

            if (UserRid == SavedAliasRid) {
                printf("      Create Alias/User Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new user and alias.\n");
                TestStatus = FALSE;
            }
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }







    printf("      Create Duplicate User . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, USER_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_USER_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_USER_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }




    printf("      Create Group With Same Name As User . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, USER_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_USER_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_USER_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }




    printf("      Create Group With Same Name As Alias. . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_ALIAS_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_ALIAS_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create Alias With Same Name As Group. . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_GROUP_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_GROUP_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create User With Same Name As Group . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_GROUP_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_GROUP_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create User With Same Name As Alias . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_ALIAS_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_ALIAS_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Call server to test internal functions                                //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("\n");
    printf("    Test internal functions . . . . . . . . . . . . . . .   Suite\n");
    printf("      Test internal domain functions  . . . . . . . . . .       ");

    NtStatus = SamTestPrivateFunctionsDomain( DomainHandle );

    if ( NT_SUCCESS( NtStatus ) ) {

        printf("Succeeded.\n");

    } else {

        if ( NtStatus == STATUS_NOT_IMPLEMENTED ) {

            printf("Not Implemented\n");

        } else {

            printf("Failed.\n");
            printf("    Status = %lx\n", NtStatus );
            TestStatus = FALSE;
        }
    }

    printf("      Test internal user functions  . . . . . . . . . . .       ");

    if (ValidUserHandle == NULL) {

        printf("Test omitted - Valid User handle not available\n");
        TestStatus = FALSE;

    } else {

        NtStatus = SamTestPrivateFunctionsUser( ValidUserHandle );
        IgnoreStatus = SamCloseHandle( ValidUserHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        if ( NT_SUCCESS( NtStatus ) ) {

            printf("Succeeded.\n");

        } else {

            if ( NtStatus == STATUS_NOT_IMPLEMENTED ) {

                printf("Not Implemented\n");

            } else {

                printf("Failed.\n");
                printf("    Status = %lx\n", NtStatus );
                TestStatus = FALSE;
            }
        }
    }


    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Enumerate Users/Groups Suite                                          //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////


    printf("    Enumerate Users/Groups/Aliases. . . . . . . . . . . .   Suite\n");

    printf("      Enumerate Groups - large prefered length  . . . . . .     ");


    EnumerationContext = 0;
    NtStatus = SamEnumerateGroupsInDomain(
                   DomainHandle,
                   &EnumerationContext,
                   &Buffer,
                   12000,                   // PreferedMaximumLength
                   &CountReturned
                   );
    AccountCount = CountReturned;       // Save for future test

    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if (NtStatus == STATUS_SUCCESS) {

                if (CountReturned > 1) {
                    printf("Succeeded\n");
                    for (i=0; i<CountReturned; i++) {
                        printf("            Rid/Name(%ld): 0x%lx / %wZ\n",i,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                              &((PSAM_RID_ENUMERATION)(Buffer))[i].Name
                              );
                    }

                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Expected several entries to be returned.\n");
                    printf("        Received 0x%lx entries instead.\n", CountReturned);
                    TestStatus = FALSE;
                }

            } else {

                printf("Failed\n");
                printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                printf("        Received 0x%lx instead.\n", NtStatus);
                printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                printf("        CountReturned = 0x%lx\n", CountReturned);
                TestStatus = FALSE;
            }

            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }




    printf("      Enumerate Groups - small prefered length  . . . . . .     ");


    for ( i=0; i<AccountCount; i++) {
        EnumerationContext = i;
        NtStatus = SamEnumerateGroupsInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       0,                   // PreferedMaximumLength
                       &CountReturned
                       );

        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {
                if ( ((i >= AccountCount -1) && (NtStatus == STATUS_SUCCESS)) ||
                     ((i <= AccountCount -1) && (NtStatus == STATUS_MORE_ENTRIES))  ) {

                    if (CountReturned != 1) {
                        printf("Failed\n");
                        printf("        Completion status is 0x%lx\n", NtStatus);
                        printf("        Expected one entry to be returned.\n");
                        printf("        Received 0x%lx entries instead.\n", CountReturned);
                        TestStatus = FALSE;
                        i = AccountCount + 100;
                    }

                } else {

                    printf("Failed\n");
                    if (i < AccountCount -1 ) {
                        printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                    } else {
                        printf("        Expected STATUS_SUCCESS to be returned.\n");
                    }
                    printf("        Received 0x%lx instead.\n", NtStatus);
                    printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                    printf("        CountReturned = 0x%lx\n", CountReturned);
                    TestStatus = FALSE;
                    i = AccountCount + 100;
                }

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                i = AccountCount + 100;
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            i = AccountCount + 100;

        }
    }

    if ( i == AccountCount) {
        printf("Succeeded\n");
    }




    printf("      Enumerate Aliases - large prefered length . . . . . .     ");


    EnumerationContext = 0;
    NtStatus = SamEnumerateAliasesInDomain(
                   DomainHandle,
                   &EnumerationContext,
                   &Buffer,
                   12000,                   // PreferedMaximumLength
                   &CountReturned
                   );
    AccountCount = CountReturned;       // Save for future test

    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if (NtStatus == STATUS_SUCCESS) {

                if (CountReturned > 1) {
                    printf("Succeeded\n");
                    for (i=0; i<CountReturned; i++) {
                        printf("            Rid/Name(%ld): 0x%lx / %wZ\n",i,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                              &((PSAM_RID_ENUMERATION)(Buffer))[i].Name
                              );
                    }

                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Expected several entries to be returned.\n");
                    printf("        Received 0x%lx entries instead.\n", CountReturned);
                    TestStatus = FALSE;
                }

            } else {

                printf("Failed\n");
                printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                printf("        Received 0x%lx instead.\n", NtStatus);
                printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                printf("        CountReturned = 0x%lx\n", CountReturned);
                TestStatus = FALSE;
            }

            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }




    printf("      Enumerate Aliases - small prefered length . . . . . .     ");


    for ( i=0; i<AccountCount; i++) {
        EnumerationContext = i;
        NtStatus = SamEnumerateAliasesInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       0,                   // PreferedMaximumLength
                       &CountReturned
                       );

        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {
                if ( ((i >= AccountCount -1) && (NtStatus == STATUS_SUCCESS)) ||
                     ((i <= AccountCount -1) && (NtStatus == STATUS_MORE_ENTRIES))  ) {

                    if (CountReturned != 1) {
                        printf("Failed\n");
                        printf("        Completion status is 0x%lx\n", NtStatus);
                        printf("        Expected one entry to be returned.\n");
                        printf("        Received 0x%lx entries instead.\n", CountReturned);
                        TestStatus = FALSE;
                        i = AccountCount + 100;
                    }

                } else {

                    printf("Failed\n");
                    if (i < AccountCount -1 ) {
                        printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                    } else {
                        printf("        Expected STATUS_SUCCESS to be returned.\n");
                    }
                    printf("        Received 0x%lx instead.\n", NtStatus);
                    printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                    printf("        CountReturned = 0x%lx\n", CountReturned);
                    TestStatus = FALSE;
                    i = AccountCount + 100;
                }

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                i = AccountCount + 100;
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            i = AccountCount + 100;

        }
    }

    if ( i == AccountCount) {
        printf("Succeeded\n");
    }





    printf("      Enumerate Users  - large prefered length  . . . . . .     ");


    EnumerationContext = 0;
    NtStatus = SamEnumerateUsersInDomain(
                   DomainHandle,
                   &EnumerationContext,
                   0,
                   &Buffer,
                   12000,                   // PreferedMaximumLength
                   &CountReturned
                   );
    AccountCount = CountReturned;       // Save for future test

    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if (NtStatus == STATUS_SUCCESS) {

                if (CountReturned > 1) {
                    printf("Succeeded\n");
                    for (i=0; i<CountReturned; i++) {
                        printf("            Rid/Name(%ld): 0x%lx / %wZ\n",i,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                              &((PSAM_RID_ENUMERATION)(Buffer))[i].Name
                              );
                    }

                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Expected several entries to be returned.\n");
                    printf("        Received 0x%lx entries instead.\n", CountReturned);
                    TestStatus = FALSE;
                }

            } else {

                printf("Failed\n");
                printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                printf("        Received 0x%lx instead.\n", NtStatus);
                printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                printf("        CountReturned = 0x%lx\n", CountReturned);
                TestStatus = FALSE;
            }

            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }




    printf("      Enumerate Users  - small prefered length  . . . . . .     ");


    for ( i=0; i<AccountCount; i++) {
        EnumerationContext = i;
        NtStatus = SamEnumerateUsersInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       0,
                       &Buffer,
                       0,                   // PreferedMaximumLength
                       &CountReturned
                       );

        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {
                if ( ((i >= AccountCount -1) && (NtStatus == STATUS_SUCCESS)) ||
                     ((i <= AccountCount -1) && (NtStatus == STATUS_MORE_ENTRIES))  ) {

                    if (CountReturned != 1) {
                        printf("Failed\n");
                        printf("        Completion status is 0x%lx\n", NtStatus);
                        printf("        Expected one entry to be returned.\n");
                        printf("        Received 0x%lx entries instead.\n", CountReturned);
                        TestStatus = FALSE;
                        i = AccountCount + 100;
                    }

                } else {

                    printf("Failed\n");
                    if (i < AccountCount -1 ) {
                        printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                    } else {
                        printf("        Expected STATUS_SUCCESS to be returned.\n");
                    }
                    printf("        Received 0x%lx instead.\n", NtStatus);
                    printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                    printf("        CountReturned = 0x%lx\n", CountReturned);
                    TestStatus = FALSE;
                    i = AccountCount + 100;
                }

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                i = AccountCount + 100;
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            i = AccountCount + 100;

        }
    }

    if ( i == AccountCount) {
        printf("Succeeded\n");
    }










    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Lookup Names/IDs Suite                                                //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////


    // LATER add alias search to lookup name suite.....


    printf("\n");
    printf("    Lookup Names/IDs  . . . . . . . . . . . . . . . . . .   Suite\n");


    printf("      Lookup Names (all existing) . . . . . . . . . . . . .     ");

    NtStatus = SamLookupNamesInDomain(
                   DomainHandle,
                   ALL_NAMES_COUNT,
                   &AllNames[0],
                   &LookedUpRids,
                   &LookedUpUses
                   );


    if (NT_SUCCESS(NtStatus)) {
        ASSERT( LookedUpRids != NULL );
        ASSERT( LookedUpUses != NULL );

        if (
            (LookedUpRids[0] == AllRids[0]) && (LookedUpUses[0] == AllUses[0])
                                            &&
            (LookedUpRids[1] == AllRids[1]) && (LookedUpUses[1] == AllUses[1])
                                            &&
            (LookedUpRids[2] == AllRids[2]) && (LookedUpUses[2] == AllUses[2])
            ) {


            printf("Succeeded\n");


        } else {
            printf("Failed\n");
            printf("        Rids or Uses dont match expected values.\n");
            printf("        Expected Rids:  0x%lx, 0x%lx, 0x%lx\n",
                AllRids[0], AllRids[1], AllRids[2]);
            printf("        Received Rids:  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpRids[0], LookedUpRids[1], LookedUpRids[2]);
            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx\n",
                AllUses[0], AllUses[1], AllUses[2]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpRids );
        SamFreeMemory( LookedUpUses );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Lookup Names (Some existing)  . . . . . . . . . . . .     ");

    NtStatus = SamLookupNamesInDomain(
                   DomainHandle,
                   SOME_NAMES_COUNT,
                   &SomeNames[0],
                   &LookedUpRids,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_SOME_NOT_MAPPED) {
        ASSERT( LookedUpRids != NULL );
        ASSERT( LookedUpUses != NULL );

        if (
            (LookedUpRids[0] == SomeRids[0]) && (LookedUpUses[0] == SomeUses[0])
                                             &&
            (LookedUpRids[1] == SomeRids[1]) && (LookedUpUses[1] == SomeUses[1])
                                             &&
            (LookedUpRids[2] == SomeRids[2]) && (LookedUpUses[2] == SomeUses[2])
                                             &&
            (LookedUpRids[3] == SomeRids[3]) && (LookedUpUses[3] == SomeUses[3])
                                             &&
            (LookedUpRids[4] == SomeRids[4]) && (LookedUpUses[4] == SomeUses[4])
                                             &&
            (LookedUpRids[5] == SomeRids[5]) && (LookedUpUses[5] == SomeUses[5])
                                             &&
            (LookedUpRids[6] == SomeRids[6]) && (LookedUpUses[6] == SomeUses[6])
            ) {


            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Rids or Uses dont match expected values.\n");
            printf("        Expected Rids:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                SomeRids[0], SomeRids[1], SomeRids[2], SomeRids[3], SomeRids[4], SomeRids[5], SomeRids[6]);
            printf("        Received Rids:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpRids[0], LookedUpRids[1], LookedUpRids[2], LookedUpRids[3], LookedUpRids[4], LookedUpRids[5], LookedUpRids[6]);
            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                SomeUses[0], SomeUses[1], SomeUses[2], SomeUses[3], SomeUses[4], SomeUses[5], SomeUses[6]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2], LookedUpUses[3], LookedUpUses[4], LookedUpUses[5], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpRids );
        SamFreeMemory( LookedUpUses );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    printf("      Lookup Names (None existing)  . . . . . . . . . . . .     ");

    NtStatus = SamLookupNamesInDomain(
                   DomainHandle,
                   NO_NAMES_COUNT,
                   &NoNames[0],
                   &LookedUpRids,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_NONE_MAPPED) {
        ASSERT( LookedUpRids == NULL );
        ASSERT( LookedUpUses == NULL );

        printf("Succeeded\n");

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }


 
    printf("      Lookup SIDs (all existing)  . . . . . . . . . . . . .     ");

    NtStatus = SamLookupIdsInDomain(
                   DomainHandle,
                   ALL_NAMES_COUNT,
                   &AllRids[0],
                   &LookedUpNames,
                   &LookedUpUses
                   );


    if (NT_SUCCESS(NtStatus)) {
        ASSERT( LookedUpUses  != NULL );
        ASSERT( LookedUpNames != NULL );
        ASSERT( LookedUpNames[0].Buffer != NULL );
        ASSERT( LookedUpNames[1].Buffer != NULL );
        ASSERT( LookedUpNames[2].Buffer != NULL );

        if (
            (LookedUpUses[0] == AllUses[0]) &&
            (LookedUpUses[1] == AllUses[1]) &&
            (LookedUpUses[2] == AllUses[2]) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[0], (PSTRING)&AllNames[0], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[1], (PSTRING)&AllNames[1], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[2], (PSTRING)&AllNames[2], TRUE )
            ) {


            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Names or Uses dont match expected values.\n");
            printf("        Expected Name[0]:  %wZ\n", &AllNames[0] );
            printf("        Received Name[0]:  %wZ\n", &LookedUpNames[0] );
            printf("        Expected Name[1]:  %wZ\n", &AllNames[1] );
            printf("        Received Name[1]:  %wZ\n", &LookedUpNames[1] );
            printf("        Expected Name[2]:  %wZ\n", &AllNames[2] );
            printf("        Received Name[2]:  %wZ\n", &LookedUpNames[2] );

            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx\n",
                AllUses[0], AllUses[1], AllUses[2]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpUses );
        SamFreeMemory( LookedUpNames );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Lookup SIDs (Some existing) . . . . . . . . . . . . .     ");

    NtStatus = SamLookupIdsInDomain(
                   DomainHandle,
                   SOME_NAMES_COUNT,
                   &SomeRids[0],
                   &LookedUpNames,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_SOME_NOT_MAPPED) {
        ASSERT( LookedUpUses  != NULL );
        ASSERT( LookedUpNames != NULL );
        ASSERT( LookedUpNames[0].Buffer != NULL );
        ASSERT( LookedUpNames[1].Buffer != NULL );
        ASSERT( LookedUpNames[2].Buffer == NULL );  // Unknown
        ASSERT( LookedUpNames[3].Buffer == NULL );  // Unknown
        ASSERT( LookedUpNames[4].Buffer == NULL );  // Unknown
        ASSERT( LookedUpNames[5].Buffer != NULL );
        ASSERT( LookedUpNames[6].Buffer == NULL );  // Unknown

        if (
            (LookedUpUses[0] == SomeUses[0]) &&
            (LookedUpUses[1] == SomeUses[1]) &&
            (LookedUpUses[2] == SomeUses[2]) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[0], (PSTRING)&SomeNames[0], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[1], (PSTRING)&SomeNames[1], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[5], (PSTRING)&SomeNames[5], TRUE )
            ) {


            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Names or Uses dont match expected values.\n");
            printf("        Expected Name[0]:  %wZ\n", &SomeNames[0] );
            printf("        Received Name[0]:  %wZ\n", &LookedUpNames[0] );
            printf("        Expected Name[1]:  %wZ\n", &SomeNames[1] );
            printf("        Received Name[1]:  %wZ\n", &LookedUpNames[1] );
            printf("                 Name[2]:  (Unknown)\n");
            printf("                 Name[3]:  (Unknown)\n");
            printf("                 Name[4]:  (Unknown)\n");
            printf("        Expected Name[5]:  %wZ\n", &SomeNames[5] );
            printf("        Received Name[5]:  %wZ\n", &LookedUpNames[5] );
            printf("                 Name[6]:  (Unknown)\n");

            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                SomeUses[0], SomeUses[1], SomeUses[2], SomeUses[3], SomeUses[4], SomeUses[5], SomeUses[6]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2], LookedUpUses[3], LookedUpUses[4], LookedUpUses[5], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpUses );
        SamFreeMemory( LookedUpNames );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Lookup SIDs (None existing) . . . . . . . . . . . . .     ");

    NtStatus = SamLookupIdsInDomain(
                   DomainHandle,
                   NO_NAMES_COUNT,
                   &NoRids[0],
                   &LookedUpNames,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_NONE_MAPPED) {
        ASSERT( LookedUpUses  == NULL );
        ASSERT( LookedUpNames == NULL );

        printf("Succeeded\n");

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }







    return TestStatus;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Group  Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
GroupTestSuite(
    HANDLE DomainHandle,
    ULONG  Pass
    )

{
    NTSTATUS            NtStatus, IgnoreStatus;
    HANDLE              GroupHandle1, GroupHandle2, UserHandle1;
    ULONG               CountReturned, NameLength, i, MemberCount;
    ULONG               UserRid, GroupRid;
    PVOID               Buffer, Buffer1, Buffer2;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    PULONG              Members, Attributes;
    PSID_NAME_USE       LookedUpUses;
    PULONG              LookedUpRids;
    UNICODE_STRING      AccountNames[10], AccountName;
    STRING              AccountNameAnsi;

    BOOLEAN             IndividualTestSucceeded, DeleteUser;
    BOOLEAN             TestStatus = TRUE;


    if (Pass == 1) {
        //
        // This test suite assumes that lookup and enumeration API funciton
        // properly.
        //

        printf("\n");
        printf("\n");
        printf("  Group (Pass #1) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Open Group Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("    Open Group  . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        printf("      Open Groups . . . . . . . . . . . . . . . . . . . . .     ");
        IndividualTestSucceeded = TRUE;
        EnumerationContext = 0;
        NtStatus = SamEnumerateGroupsInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       12000,                   // PreferedMaximumLength
                       &CountReturned
                       );

        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer != NULL);
        ASSERT(CountReturned > 0);

        for (i=0; i<CountReturned; i++) {

            NtStatus = SamOpenGroup(
                           DomainHandle,
                           GROUP_ALL_ACCESS,
                           ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                           &GroupHandle1
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamOpenGroup(
                               DomainHandle,
                               GENERIC_READ,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                               &GroupHandle2
                               );

                if (NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamCloseHandle( GroupHandle2 );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Failed opening group second time.\n");
                    printf("        Rid of account is:   0x%lx\n",
                        ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                    printf("        Name of account is:  %wZ\n",
                        &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                    TestStatus = FALSE;
                    IndividualTestSucceeded = FALSE;
                }

                IgnoreStatus = SamCloseHandle( GroupHandle1 );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            } else {

                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        Failed opening group for first time.\n");
                printf("        Rid of account is:   0x%lx\n",
                    ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                printf("        Name of account is:  %wZ\n",
                    &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                TestStatus = FALSE;
                IndividualTestSucceeded = FALSE;
            }

            if (!IndividualTestSucceeded) {
                printf("                                                                ");
            }
        }


        SamFreeMemory( Buffer );
        if (IndividualTestSucceeded) {
            printf("Succeeded\n");
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query     Group Suite                                                 //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Query Group . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Query Group General Information . . . . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupGeneralInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((GROUP_GENERAL_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((GROUP_GENERAL_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Member Count is:  0x%lx\n",
                     (((GROUP_GENERAL_INFORMATION *)Buffer)->MemberCount) );
                    printf("        Attributes are:   0x%lx\n",
                     (((GROUP_GENERAL_INFORMATION *)Buffer)->Attributes) );
                    printf("        Group Name is:    %wZ\n",
                     &(((GROUP_GENERAL_INFORMATION *)Buffer)->Name) );



                } else {
                    printf("Failed\n");
                    printf("        Group Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Group Name Information  . . . . . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((GROUP_NAME_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((GROUP_NAME_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Group Name is:    %wZ\n",
                     &(((GROUP_NAME_INFORMATION *)Buffer)->Name) );



                } else {
                    printf("Failed\n");
                    printf("        Group Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Group Admin Comment Information . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupAdminCommentInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((GROUP_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment.MaximumLength >= 0) ) {

                    printf("Succeeded\n");

                    printf("        Group Admin Comment is:    %wZ\n",
                     &(((GROUP_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment) );



                } else {
                    printf("Failed\n");
                    printf("        Group Admin Comment not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Group Attribute Information . . . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupAttributeInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf("        Attributes are:   0x%lx\n",
                 (((GROUP_ATTRIBUTE_INFORMATION *)Buffer)->Attributes) );


                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Get Members Of Group Suite                                            //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Get Members . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Get Members of Well-Known Account . . . . . . . . . .     ");

        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_LIST_MEMBERS,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamGetMembersInGroup(
                       GroupHandle1,
                       &Members,
                       &Attributes,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Members != NULL || Attributes != NULL) {

                printf("Succeeded\n");


                printf("       Member Count:    %d Users\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    printf("       User[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                        i, Members[i], Attributes[i]);


                }

                SamFreeMemory( Members );
                SamFreeMemory( Attributes );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Get Members of Empty Group. . . . . . . . . . . . . .     ");

        //
        // This group was created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeGroup);
        RtlFreeUnicodeString( &AccountNames[0] );



        GroupHandle1 = NULL;

        NtStatus = SamOpenGroup( DomainHandle, GROUP_LIST_MEMBERS, LookedUpRids[0], &GroupHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamGetMembersInGroup(
                       GroupHandle1,
                       &Members,
                       &Attributes,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (MemberCount == 0) {

                printf("Succeeded\n");




            } else {
                printf("Failed\n");
                printf("        Buffer addresses  set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("       Member Count:    %d\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    printf("       User[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                        i, Members[i], Attributes[i]);
                }

                SamFreeMemory( Members );
                SamFreeMemory( Attributes );
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );


        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Group Suite  (pass 1)                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Group . . . . . . . . . . . . . . . . . . . . . .   Suite\n");


        printf("      Set Attribute . . . . . . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_WRITE_ACCOUNT | GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer1 = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupAttributeInformation,
                       &Buffer1
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer1 != NULL);

        //
        // Change the value and write it back
        //

        ((GROUP_ATTRIBUTE_INFORMATION *)Buffer1)->Attributes ^=
            SE_GROUP_ENABLED_BY_DEFAULT;


        NtStatus = SamSetInformationGroup(
                       GroupHandle1,
                       GroupAttributeInformation,
                       Buffer1
                       );
        if (NT_SUCCESS(NtStatus)) {

            //
            // Check the written value to make sure it stuck
            //

            Buffer2 = NULL;
            NtStatus = SamQueryInformationGroup(
                           GroupHandle1,
                           GroupAttributeInformation,
                           &Buffer2
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer2 != NULL);

            if (((GROUP_ATTRIBUTE_INFORMATION *)Buffer1)->Attributes ==
                ((GROUP_ATTRIBUTE_INFORMATION *)Buffer2)->Attributes   ) {

                printf("Succeeded\n");

                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Returned Value Doesn't Match Set Value.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        SamFreeMemory( Buffer1 );
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Set Admin Comment . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenGroup(
                           DomainHandle,
                           GROUP_WRITE_ACCOUNT | GROUP_READ_INFORMATION,
                           DOMAIN_GROUP_RID_USERS,
                           &GroupHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationGroup(
                           GroupHandle1,
                           GroupAdminCommentInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment.Length;
            if (  NameLength == DummyString1.Length ) {
                ((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString2;
            } else {
                ((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString1;
            }

            NtStatus = SamSetInformationGroup(
                           GroupHandle1,
                           GroupAdminCommentInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                Buffer2 = NULL;
                NtStatus = SamQueryInformationGroup(
                               GroupHandle1,
                               GroupAdminCommentInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment,
                        (PSTRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }






    } // END PASS #1
    if (Pass == 2) {

        printf("\n");
        printf("\n");
        printf("  Group (Pass #2) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Delete Group Suite                                                    //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Delete Group  . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Delete Normal Group . . . . . . . . . . . . . . . . .     ");

        //
        // This group was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeGroup);
        RtlFreeUnicodeString( &AccountNames[0] );



        GroupHandle1 = NULL;

        NtStatus = SamOpenGroup( DomainHandle, DELETE, LookedUpRids[0], &GroupHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamDeleteGroup( GroupHandle1 );
        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Delete Well Known Group . . . . . . . . . . . . . . .     ");

        GroupHandle1 = NULL;

        NtStatus = SamOpenGroup( DomainHandle, DELETE, DOMAIN_GROUP_RID_USERS, &GroupHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamDeleteGroup( GroupHandle1 );
        if (NtStatus == STATUS_SPECIAL_ACCOUNT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        NtStatus = SamCloseHandle( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));








        printf("      Delete Primary Group Of A User. . . . . . . . . . . .     ");

        //
        // Make a user (might already exist)
        // Make a group
        // Make the group the user's primary group
        // Attempt to delete the group
        // Change the user so the group isn't the primary group
        // delete the group
        // If we created the user, delete it.

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));

        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );
        ASSERT(NT_SUCCESS(NtStatus));




        //
        // Now try to delete the group
        //

        NtStatus = SamDeleteGroup( GroupHandle1 );
        if (NtStatus == STATUS_MEMBER_IN_GROUP) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Now get rid of the group and possibly the user account
        //

        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        ASSERT(NT_SUCCESS(NtStatus));


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Add/Remove Member Suite                                               //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Add/Remove Member Suite . . . . . . . . . . . . . . .   Suite\n");

        printf("      Add Member  . . . . . . . . . . . . . . . . . . . . .     ");

        //
        // This test sets things up for the next test
        //

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInGroup(
                           GroupHandle1,
                           &Members,
                           &Attributes,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            for ( i=0; i<MemberCount; i++) {
                if (Members[i] == UserRid) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {
                if (Attributes[i] == (SE_GROUP_MANDATORY          |
                                           SE_GROUP_ENABLED_BY_DEFAULT |
                                           SE_GROUP_ENABLED)) {
                    printf("Succeeded\n");
                } else {
                    printf("Failed\n");
                    printf("Member Added but attributes don't match expected value.\n");
                    printf("Expected value:  0x%lx\n",(SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED));
                    printf("Retrieved value:  0x%lx\n",Attributes[i]);
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for group.\n");
                TestStatus = FALSE;
            }


            if (Members != NULL) {
                SamFreeMemory( Members );
                SamFreeMemory( Attributes );
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Remove Member . . . . . . . . . . . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //

        //
        // Now try to remove the user from the group
        //

        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInGroup(
                           GroupHandle1,
                           &Members,
                           &Attributes,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (Members[i] == UserRid) {
                    NtStatus = STATUS_MEMBER_IN_GROUP;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {
                printf("Succeeded\n");
            } else {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for group.\n");
                TestStatus = FALSE;
            }


            SamFreeMemory( Members );
            SamFreeMemory( Attributes );

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // and clean up the user and group accounts
        //

        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }






        printf("      Add Non-Existant Member . . . . . . . . . . . . . . .     ");

        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Specify a non-existant user be added to this group
        //

        UserRid = 30732579;             // Pretty sure this user doesn't exist.
        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );

        if (NtStatus == STATUS_NO_SUCH_USER) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




        printf("      Remove Non-existant Member  . . . . . . . . . . . . .     ");

        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Specify a non-existant user be removed from this group
        //

        UserRid = 30732579;             // Pretty sure this user doesn't exist.
        NtStatus = SamRemoveMemberFromGroup( GroupHandle1, UserRid );

        if (NtStatus == STATUS_NO_SUCH_USER) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




        printf("      Remove Primary Group Of Member  . . . . . . . . . . .     ");


        //
        // Make a user (might already exist)
        // Make a group
        // Make the group the user's primary group
        // Attempt to remove the group (should fail)
        // Change the user so the group isn't the primary group
        // remove the group
        // delete the group
        // If we created the user, delete it.

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );
        ASSERT(NT_SUCCESS(NtStatus));


        //
        // Set the user's primary group Id to be this group
        //

        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        ASSERT(NT_SUCCESS(NtStatus));



        //
        // Now try to remove the user from the group
        //

        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        if (NtStatus == STATUS_MEMBERS_PRIMARY_GROUP) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Set the user's primary group Id back and remove the user
        // from the group
        //

        GroupRid = DOMAIN_GROUP_RID_USERS;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        ASSERT(NT_SUCCESS(NtStatus));
        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        ASSERT(NT_SUCCESS(NtStatus));



        //
        // Now get rid of the group and possibly the user account
        //


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }






        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Group Suite  (pass 2)                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Group . . . . . . . . . . . . . . . . . . . . . .   Suite\n");


        printf("      Set Name  . . . . . . . . . . . . . . . . . . . . . .     ");
        printf("(Untested)\n");


        printf("      Set Name Of Well-Known Account  . . . . . . . . . . .     ");
        printf("(Untested)\n");

    }

    return(TestStatus);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Alias  Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
AliasTestSuite(
    HANDLE DomainHandle,
    HANDLE BuiltinDomainHandle,
    PSID   DomainSid,
    ULONG  Pass
    )

{
    NTSTATUS            NtStatus, IgnoreStatus;
    HANDLE              AdminAliasHandle, AliasHandle1, AliasHandle2, UserHandle1, UserHandle2, UserHandle3;
    ULONG               CountReturned, i, MemberCount;
    ULONG               UserRid, UserRid2, UserRid3, AliasRid, AliasRid2;
    PVOID               Buffer, Buffer1, Buffer2;
    ULONG               NameLength;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    PULONG              Members;
    PSID                *AliasMembers;
    PSID_NAME_USE       LookedUpUses;
    PULONG              LookedUpRids;
    UNICODE_STRING      AccountNames[10], AccountName;
    STRING              AccountNameAnsi;
    PSID                UserSid1, UserSid2, GroupSid;

    BOOLEAN             IndividualTestSucceeded, DeleteUser;
    BOOLEAN             TestStatus = TRUE;


    if (Pass == 1) {
        //
        // This test suite assumes that lookup and enumeration API funciton
        // properly.
        //

        printf("\n");
        printf("\n");
        printf("  Alias (Pass #1) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Open Alias Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("    Open Alias  . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        printf("      Open Aliases . . . . . . . . . . . . . . . . . . . . .     ");
        IndividualTestSucceeded = TRUE;
        EnumerationContext = 0;
        NtStatus = SamEnumerateAliasesInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       12000,                   // PreferedMaximumLength
                       &CountReturned
                       );

        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer != NULL);
        ASSERT(CountReturned > 0);

        for (i=0; i<CountReturned; i++) {

            NtStatus = SamOpenAlias(
                           DomainHandle,
                           ALIAS_ALL_ACCESS,
                           ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                           &AliasHandle1
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamOpenAlias(
                               DomainHandle,
                               GENERIC_READ,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                               &AliasHandle2
                               );

                if (NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamCloseHandle( AliasHandle2 );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Failed opening alias second time.\n");
                    printf("        Rid of account is:   0x%lx\n",
                        ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                    printf("        Name of account is:  %wZ\n",
                        &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                    TestStatus = FALSE;
                    IndividualTestSucceeded = FALSE;
                }

                IgnoreStatus = SamCloseHandle( AliasHandle1 );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            } else {

                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        Failed opening alias for first time.\n");
                printf("        Rid of account is:   0x%lx\n",
                    ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                printf("        Name of account is:  %wZ\n",
                    &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                TestStatus = FALSE;
                IndividualTestSucceeded = FALSE;
            }

            if (!IndividualTestSucceeded) {
                printf("                                                                ");
            }
        }


        SamFreeMemory( Buffer );
        if (IndividualTestSucceeded) {
            printf("Succeeded\n");
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query     Alias Suite                                                 //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////


        //
        // Get the rid of an alias created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );

        AliasRid = LookedUpRids[0];

        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );


        printf("\n");
        printf("    Query Alias . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Query Alias General Information . . . . . . . . . . .     ");


        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasGeneralInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((ALIAS_GENERAL_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((ALIAS_GENERAL_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Member Count is:  0x%lx\n",
                     (((ALIAS_GENERAL_INFORMATION *)Buffer)->MemberCount) );
                    printf("        Alias Name is:    %wZ\n",
                     &(((ALIAS_GENERAL_INFORMATION *)Buffer)->Name) );
                    
                } else {
                    printf("Failed\n");
                    printf("        Alias Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Alias Name Information  . . . . . . . . . . . .     ");


        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((ALIAS_NAME_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((ALIAS_NAME_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Alias Name is:    %wZ\n",
                     &(((ALIAS_NAME_INFORMATION *)Buffer)->Name) );
                } else {
                    printf("Failed\n");
                    printf("        Alias Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Alias Admin Comment Information . . . . . . . .     ");


        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasAdminCommentInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((ALIAS_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment.MaximumLength >= 0) ) {

                    printf("Succeeded\n");

                    printf("        Alias Admin Comment is:    %wZ\n",
                     &(((ALIAS_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment) );
                } else {
                    printf("Failed\n");
                    printf("        Alias Admin Comment not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Get Members Of Alias Suite                                            //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Get Members . . . . . . . . . . . . . . . . . . . . .   Suite\n");

#ifdef LATER // ALIAS_LATER - well-know aliases ?


        davidc/chads - this needs to access the builtin domain.

        printf("      Get Members of Well-Known Account . . . . . . . . . .     ");

        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_LIST_MEMBERS,
                       DOMAIN_ALIAS_RID_ADMINS,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamGetMembersInAlias(
                       AliasHandle1,
                       &AliasMembers,
                       &Attributes,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Members != NULL || Attributes != NULL) {

                printf("Succeeded\n");


                printf("       Member Count:    %d Users\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    // printf("       User[%d] Sid:      0x%lx\n",
                    //    i, Members[i]);


                }

                SamFreeMemory( AliasMembers );
                SamFreeMemory( Attributes );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );
#endif


        printf("      Get Members of Empty Alias. . . . . . . . . . . . . .     ");

        //
        // This alias was created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );



        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, ALIAS_LIST_MEMBERS, LookedUpRids[0], &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamGetMembersInAlias(
                       AliasHandle1,
                       &AliasMembers,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (MemberCount == 0) {

                printf("Succeeded\n");




            } else {
                printf("Failed\n");
                printf("       Member Count > 0 :    %d\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    // printf("       User[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                    //    i, Members[i], Attributes[i]);
                }

                SamFreeMemory( AliasMembers );
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Alias Suite  (pass 1)                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Alias . . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        //


        // Get the rid of an alias created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );

        AliasRid = LookedUpRids[0];

        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );



        printf("      Set Admin Comment . . . . . . . . . . . . . . . . . .     ");

        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_WRITE_ACCOUNT | ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Get the current value...
        //

        Buffer1 = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasAdminCommentInformation,
                       &Buffer1
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer1 != NULL);


        //
        // Change the field to a new value and write it out.
        //

        NameLength = ((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment.Length;
        if (  NameLength == DummyString1.Length ) {
            ((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString2;
        } else {
            ((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString1;
        }

        NtStatus = SamSetInformationAlias(
                       AliasHandle1,
                       AliasAdminCommentInformation,
                       Buffer1
                       );
        if ( NT_SUCCESS(NtStatus) ) {

            //
            // Now check that the change was really made...
            //

            Buffer2 = NULL;
            NtStatus = SamQueryInformationAlias(
                           AliasHandle1,
                           AliasAdminCommentInformation,
                           &Buffer2
                           );
            ASSERT(NT_SUCCESS( NtStatus ) );
            if (
                !RtlCompareString(
                    (PSTRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment,
                    (PSTRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment,
                    TRUE)
                ) {

                printf("Succeeded\n");

            } else {

                printf("Failed\n");
                printf("        Value queried doesn't match value written\n");
                printf("        Value Written is   %wZ\n",
                    (PUNICODE_STRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment);
                printf("        Value Retrieved is %wZ\n",
                    (PUNICODE_STRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment);

                TestStatus = FALSE;

            }

            SamFreeMemory( Buffer1 );
            SamFreeMemory( Buffer2 );

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            SamFreeMemory( Buffer1 );

        }





    } // END PASS #1
    if (Pass == 2) {

        printf("\n");
        printf("\n");
        printf("  Alias (Pass #2) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Delete Alias Suite                                                    //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Delete Alias  . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Delete Normal Alias . . . . . . . . . . . . . . . . .     ");

        //
        // This alias was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );



        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, DELETE, LookedUpRids[0], &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamDeleteAlias( AliasHandle1 );
        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


#ifdef LATER // ALIAS_LATER - well know aliases ?


        printf("      Delete Well Known Alias . . . . . . . . . . . . . . .     ");

        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, DELETE, DOMAIN_GROUP_RID_USERS, &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamDeleteAlias( AliasHandle1 );
        if (NtStatus == STATUS_SPECIAL_ACCOUNT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        NtStatus = SamCloseHandle( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




        printf("      Delete Admin Alias. . . . . . . . . . . . . . . . . .     ");
        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, DELETE, DOMAIN_ALIAS_RID_ADMINS, &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamDeleteAlias( AliasHandle1 );
        if (NtStatus == STATUS_SPECIAL_ACCOUNT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        NtStatus = SamCloseHandle( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));


#endif



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Add/Remove Member Suite                                               //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Add/Remove Member Suite . . . . . . . . . . . . . . .   Suite\n");

        printf("      Add Member  . . . . . . . . . . . . . . . . . . . . .     ");

        //
        // This test sets things up for the next test
        //

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));

        //
        // This account won't exist yet
        //

        RtlInitString( &AccountNameAnsi, USER_NAME2 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid2 = 0;
        UserHandle2 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle2,
                       &UserRid2
                       );
        RtlFreeUnicodeString( &AccountName );

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the alias
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        AliasRid = 0;
        AliasHandle1 = NULL;
        NtStatus = SamCreateAliasInDomain(
                       DomainHandle,
                       &AccountName,
                       ALIAS_ALL_ACCESS,
                       &AliasHandle1,
                       &AliasRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make user1 a member of this alias
        //

        UserSid1 = CreateUserSid(DomainSid, UserRid);
        ASSERT(UserSid1 != NULL);

        UserSid2 = CreateUserSid(DomainSid, UserRid2);
        ASSERT(UserSid2 != NULL);



        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid1)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid1,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }


                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be no aliases.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] != AliasRid) {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;

                        } else {
                            printf("Succeeded\n");
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }







        printf("      Add another member to another alias . . . . . . . . .     ");






        //
        // Make user2 a member of alias2
        //

        //
        // This alias was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME2 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );

        AliasHandle2 = NULL;
        AliasRid2 = LookedUpRids[0];

        NtStatus = SamOpenAlias( DomainHandle, ALIAS_ALL_ACCESS, LookedUpRids[0], &AliasHandle2 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );


        NtStatus = SamAddMemberToAlias(
                       AliasHandle2,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle2,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid2) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be in alias2.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 2) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (((Members[0] == AliasRid) && (Members[1] == AliasRid2)) ||
                            ((Members[0] == AliasRid2) && (Members[1] == AliasRid)) ) {
                            printf("Succeeded\n");
                        } else {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Remove user2 from alias2 again
        //

        NtStatus = SamRemoveMemberFromAlias(
                       AliasHandle2,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle2,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NtStatus != STATUS_MEMBER_NOT_IN_ALIAS) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid2) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be in no aliases.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] == AliasRid) {
                            printf("Succeeded\n");
                        } else {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        NtStatus = SamCloseHandle( AliasHandle2 );
        ASSERT(NT_SUCCESS(NtStatus));





        printf("      Add Another Member  . . . . . . . . . . . . . . . . .     ");


        //
        // Make user2 a member of this alias
        //

        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be in alias1.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] != AliasRid) {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;

                        } else {
                            printf("Succeeded\n");
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        printf("      Remove Member . . . . . . . . . . . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //

        //
        // Now try to remove the user from the alias
        //

        NtStatus = SamRemoveMemberFromAlias(AliasHandle1, UserSid1);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid1)) {
                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            SamFreeMemory( AliasMembers );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid1,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in no aliases
                // User2 should be in alias1.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] != AliasRid) {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;

                        } else {
                            printf("Succeeded\n");
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Add A User to ADMIN Alias . . . . . . . . . . . . . .     ");

        //
        // Make user2 a member of the ADMIN alias
        //

        NtStatus = SamOpenAlias(
                       BuiltinDomainHandle,
                       ALIAS_ALL_ACCESS,
                       DOMAIN_ALIAS_RID_ADMINS,
                       &AdminAliasHandle
                       );

        ASSERT( NT_SUCCESS( NtStatus ) );

        NtStatus = SamAddMemberToAlias(
                       AdminAliasHandle,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        printf("      Add A Group to ADMIN Alias . . . . . . . . . . . . . .     ");

        //
        // Make a group a member of the ADMIN alias
        //

        GroupSid = CreateUserSid(DomainSid, DOMAIN_GROUP_RID_USERS );
        ASSERT(GroupSid != NULL);

        NtStatus = SamAddMemberToAlias(
                       AdminAliasHandle,
                       GroupSid
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], GroupSid)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &GroupSid,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


// NOTE: user is already created in the group below.  Should keep this
// test, AND add another with an all-new group that's been added to the ADMIN
// alias (then ADD user to group, rather than create in it).
        printf("      Create user in ADMIN ALIAS'd Group. . . . . . . . . . .     ");

        RtlInitString( &AccountNameAnsi, USER_NAME3 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid3 = 0;
        UserHandle3 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle3,
                       &UserRid3
                       );
        RtlFreeUnicodeString( &AccountName );

        if ( NT_SUCCESS( NtStatus ) ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }



//NOTE: doesn't work because this is primary group.
//put back in when all-new group is created, above
//        printf("      Remove user from ADMIN ALIAS'd Group. . . . . . . . . . .     ");
//
//        NtStatus = SamOpenGroup(
//                       DomainHandle,
//                       GROUP_ALL_ACCESS,
//                       DOMAIN_GROUP_RID_USERS,
//                       &GroupHandle
//                       );
//
//        ASSERT(NT_SUCCESS(NtStatus));
//
//        NtStatus = SamRemoveMemberFromGroup(
//                       GroupHandle,
//                       UserRid3
//                       );
//
//        if ( NT_SUCCESS( NtStatus ) ) {
//
//            printf("Succeeded\n");
//
//        } else {
//
//            printf("Failed\n");
//            printf("        Completion status is 0x%lx\n", NtStatus);
//            TestStatus = FALSE;
//        }
//
//        IgnoreStatus = SamCloseHandle( GroupHandle );
//        ASSERT(NT_SUCCESS(IgnoreStatus));
        IgnoreStatus = SamCloseHandle( UserHandle3 );
        ASSERT(NT_SUCCESS(IgnoreStatus));



        printf("      Remove User from ADMIN alias. . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //
        // Now try to remove the user from the alias
        //

        NtStatus = SamRemoveMemberFromAlias(AdminAliasHandle, UserSid2);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            SamFreeMemory( AliasMembers );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        //
        // Make user2 a member of the ADMIN alias again, so we can test
        // the new function SamRemoveMemberFromForeignDomain().
        // NOTE: we should make this a real test item.
        //

        NtStatus = SamAddMemberToAlias(
                       AdminAliasHandle,
                       UserSid2
                       );

        ASSERT (NT_SUCCESS(NtStatus));

        NtStatus = SamRemoveMemberFromForeignDomain(
                       BuiltinDomainHandle,
                       UserSid2 );

        ASSERT (NT_SUCCESS(NtStatus));



        printf("      Remove Group from ADMIN alias. . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //
        // Now try to remove the group from the alias
        //

        NtStatus = SamRemoveMemberFromAlias(AdminAliasHandle, GroupSid);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], GroupSid)) {
                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            SamFreeMemory( AliasMembers );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &GroupSid,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        IgnoreStatus = SamCloseHandle( AdminAliasHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Delete account while member of alias. . . . . . . . .     ");


        //
        // Now delete user2 and check the alias member list is updated
        //

        NtStatus = SamDeleteUser( UserHandle2 );
        ASSERT(NT_SUCCESS(NtStatus));

        NtStatus = SamGetMembersInAlias(
                       AliasHandle1,
                       &AliasMembers,
                       &MemberCount
                       );
        ASSERT(NT_SUCCESS(NtStatus));

        for ( i=0; i<MemberCount; i++) {
            if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                NtStatus = STATUS_MEMBER_IN_ALIAS;
                break;
            }
        }

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("Service returned SUCCESS, but user still in member list for alias.\n");
            printf("Member list :\n");
            for (i=0; i<MemberCount; i++) {
                printfSid(AliasMembers[i]);
                printf("\n");
            }
            DebugBreak();
            TestStatus = FALSE;
        }

        SamFreeMemory( AliasMembers );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetAliasMembership(
                           DomainHandle,
                           1,
                           &UserSid2,
                           &MemberCount,
                           &Members
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            if (MemberCount != 0) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but alias still in alias membership list for account.\n");
                printf("Alias Membership :\n");
                for (i=0; i<MemberCount; i++) {
                    printf("0x%lx\n", Members[i]);
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            if (Members != NULL) {
                SamFreeMemory( Members );
            }

            //
            // Check for correct alias membership for multiple accounts
            // User1 should be in no aliases
            // User2 should be in no aliases.
            //

            if (NT_SUCCESS(NtStatus)) {

                PSID    SidArray[2];
                SidArray[0] = UserSid1;
                SidArray[1] = UserSid2;

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               2,
                               SidArray,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                if (MemberCount != 0) {

                    printf("Failed\n");
                    printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                    printf("Combined Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {
                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }
        }




        printf("      Delete alias with members . . . . . . . . . . . . . .     ");

        //
        // Make the user a member of this alias (again)
        //

        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Now delete the alias and check the membership list for user is updated
        //

        NtStatus = SamDeleteAlias( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        NtStatus = SamGetAliasMembership(
                       DomainHandle,
                       1,
                       &UserSid1,
                       &MemberCount,
                       &Members
                       );
        ASSERT(NT_SUCCESS(NtStatus));

        for ( i=0; i<MemberCount; i++) {
            if (Members[i] == AliasRid) {
                NtStatus = STATUS_MEMBER_IN_ALIAS;
                break;
            }
        }

        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");
        } else {
            printf("Failed\n");
            printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
            printf("Alias Membership :\n");
            for (i=0; i<MemberCount; i++) {
                printf("0x%lx\n", Members[i]);
            }
            DebugBreak();
            TestStatus = FALSE;
        }

        if (Members != NULL) {
            SamFreeMemory( Members );
        }



        DeleteUserSid(UserSid1);
        DeleteUserSid(UserSid2);

        //
        // and clean up
        //

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }






        printf("      Add Foreign Domain Member . . . . . . . . . . . . . .     ");

        //
        // create the alias
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        AliasRid = 0;
        AliasHandle1 = NULL;
        NtStatus = SamCreateAliasInDomain(
                       DomainHandle,
                       &AccountName,
                       ALIAS_ALL_ACCESS,
                       &AliasHandle1,
                       &AliasRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Specify a non-existant user be added to this alias
        //


        {
            PSID    ForeignDomainSid;

            ForeignDomainSid = CreateUserSid(DomainSid, 307333); // random domain sub-authority
            ASSERT(ForeignDomainSid != NULL);

            UserRid = 45728;    // Random user rid

            UserSid1 = CreateUserSid(ForeignDomainSid, UserRid);
            ASSERT(UserSid1 != NULL);

            DeleteUserSid(ForeignDomainSid);
        }


        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NtStatus == STATUS_SUCCESS) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid1)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid1,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (NT_SUCCESS(NtStatus)) {
                    printf("Succeeded\n");
                } else {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        DeleteUserSid(UserSid1);




        printf("      Add alias as member . . . . . . . . . . . . . . . . .     ");

        //
        // Specify an alias in the current domain be added to this alias
        //


        UserSid1 = CreateUserSid(DomainSid, AliasRid2);
        ASSERT(UserSid1 != NULL);


        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NtStatus != STATUS_INVALID_MEMBER) {

                printf("Failed\n");
                printf("Expected service to return STATUS_INVALID_MEMBER, actually returned 0x%lx.\n", NtStatus);
                DebugBreak();
                TestStatus = FALSE;
        } else {
                printf("Succeeded\n");
        }

        DeleteUserSid(UserSid1);



        printf("      Add non-existant account in this domain as member . .     ");

        //
        // Specify a non-existant account in the current domain be added to this alias
        //


        UserSid1 = CreateUserSid(DomainSid, 32567); // Random rid
        ASSERT(UserSid1 != NULL);


        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NtStatus != STATUS_NO_SUCH_MEMBER) {

                printf("Failed\n");
                printf("Expected service to return STATUS_NO_SUCH_MEMBER, actually returned 0x%lx.\n", NtStatus);
                DebugBreak();
                TestStatus = FALSE;
        } else {
                printf("Succeeded\n");
        }

        DeleteUserSid(UserSid1);



        printf("      Remove Non-member . . . . . . . . . . . . . . . . . .      ");

        //
        // Specify a non-existant user be removed from this alias
        //

        {
            PSID    ForeignDomainSid;

            ForeignDomainSid = CreateUserSid(DomainSid, 35775); // random domain sub-authority
            ASSERT(ForeignDomainSid != NULL);

            UserRid = 623545;    // Random user rid

            UserSid1 = CreateUserSid(ForeignDomainSid, UserRid);
            ASSERT(UserSid1 != NULL);

            DeleteUserSid(ForeignDomainSid);
        }

        NtStatus = SamRemoveMemberFromAlias( AliasHandle1, UserSid1 );

        if (NtStatus == STATUS_MEMBER_NOT_IN_ALIAS) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        DeleteUserSid(UserSid1);

        NtStatus = SamDeleteAlias( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




    }

    return(TestStatus);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// User Object Test Suite                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
UserTestSuite(
    HANDLE DomainHandle,
    ULONG Pass
    )


{

    PUSER_ALL_INFORMATION All, All2;
    NTSTATUS            NtStatus, IgnoreStatus, TmpStatus;
    HANDLE              UserHandle1, UserHandle2, GroupHandle1;
    ULONG               CountReturned, NameLength, MembershipCount, i;
    ULONG               UserRid, GroupRid;
    PVOID               Buffer, Buffer1, Buffer2;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    USER_GENERAL_INFORMATION GeneralInformation;
    USER_LOGON_INFORMATION LogonInformation;
    USER_ACCOUNT_INFORMATION AccountInformation;
    PSID_NAME_USE       LookedUpUses;
    PULONG              LookedUpRids;
    UNICODE_STRING      AccountNames[10], AccountName;
    STRING              AccountNameAnsi, TmpAnsiString;




    BOOLEAN             IndividualTestSucceeded, DeleteUser;
    BOOLEAN             TestStatus = TRUE;




    if (Pass == 1) {
        // This test suite assumes that lookup and enumeration API funciton
        // properly.
        //

        printf("\n");
        printf("\n");
        printf("  User  (Pass #1) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Open User  Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("    Open User   . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        printf("      Open Users  . . . . . . . . . . . . . . . . . . . . .     ");
        IndividualTestSucceeded = TRUE;
        EnumerationContext = 0;
        NtStatus = SamEnumerateUsersInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       0,
                       &Buffer,
                       12000,                   // PreferedMaximumLength
                       &CountReturned
                       );

        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer != NULL);
        ASSERT(CountReturned > 0);

        for (i=0; i<CountReturned; i++) {

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                           &UserHandle1
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamOpenUser(
                               DomainHandle,
                               GENERIC_READ,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                               &UserHandle2
                               );

                if (NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamCloseHandle( UserHandle2 );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Failed opening User  second time.\n");
                    printf("        Rid of account is:   0x%lx\n",
                        ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                    printf("        Name of account is:  %wZ\n",
                        &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                    TestStatus = FALSE;
                    IndividualTestSucceeded = FALSE;
                }

                IgnoreStatus = SamCloseHandle( UserHandle1 );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            } else {

                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        Failed opening User  for first time.\n");
                printf("        Rid of account is:   0x%lx\n",
                    ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                printf("        Name of account is:  %wZ\n",
                    &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                TestStatus = FALSE;
                IndividualTestSucceeded = FALSE;
            }

        }


        SamFreeMemory( Buffer );
        if (IndividualTestSucceeded) {
            printf("Succeeded\n");
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query User Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Query User  . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Query User  General Information . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserGeneralInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_GENERAL_INFORMATION *)Buffer)->UserName.MaximumLength
                    >= 0) &&
                     (((USER_GENERAL_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("      Primary Group is:   0x%lx\n",
                     (((USER_GENERAL_INFORMATION *)Buffer)->PrimaryGroupId) );
                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->FullName) );
                    printf("     Admin Comment is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->AdminComment) );
                    printf("      User Comment is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->UserComment) );


                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs  not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Name Information . . . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_NAME_INFORMATION *)Buffer)->UserName.MaximumLength > 0) &&
                     (((USER_NAME_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_NAME_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_NAME_INFORMATION *)Buffer)->FullName) );



                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Account Name Information . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAccountNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_ACCOUNT_NAME_INFORMATION *)Buffer)->UserName.MaximumLength > 0) &&
                     (((USER_ACCOUNT_NAME_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_ACCOUNT_NAME_INFORMATION *)Buffer)->UserName) );



                } else {
                    printf("Failed\n");
                    printf("        UNICODE_STRING not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Full Name Information  . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserFullNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_FULL_NAME_INFORMATION *)Buffer)->FullName.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("        Full Name is:    *%wZ*\n",
                     &(((USER_FULL_NAME_INFORMATION *)Buffer)->FullName) );



                } else {
                    printf("Failed\n");
                    printf("        UNICODE_STRING not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User  Admin Comment Information . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAdminCommentInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_ADMIN_COMMENT_INFORMATION *)Buffer)->AdminComment.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("     Admin Comment is:    *%wZ*\n",
                     &(((USER_ADMIN_COMMENT_INFORMATION *)Buffer)->AdminComment) );

                } else {
                    printf("Failed\n");
                    printf("        User  Admin Comment not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User  Primary Group Information . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf("     Primary Group  is:   0x%lx\n",
                 (((USER_PRIMARY_GROUP_INFORMATION *)Buffer)->PrimaryGroupId) );

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Control Information  . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_ACCOUNT,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserControlInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf(" Account Control is:      0x%lx\n",
                 (((USER_CONTROL_INFORMATION *)Buffer)->UserAccountControl) );

                SamFreeMemory( Buffer );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Expiration Information . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_ACCOUNT,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserExpiresInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf(" Account Expires on:      (0x%lx, 0x%lx)\n",
                 (((USER_EXPIRES_INFORMATION *)Buffer)->AccountExpires.HighPart),
                 (((USER_EXPIRES_INFORMATION *)Buffer)->AccountExpires.LowPart) );

                SamFreeMemory( Buffer );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );


        printf("      Query User Preferences Information  . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_PREFERENCES | USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserPreferencesInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_PREFERENCES_INFORMATION *)Buffer)->UserComment.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("     User Comment  is:    *%wZ*\n",
                     &(((USER_PREFERENCES_INFORMATION *)Buffer)->UserComment) );

                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query User Home Directory Information . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserHomeInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_HOME_INFORMATION *)Buffer)->HomeDirectory.MaximumLength
                    >= 0) &&
                     (((USER_HOME_INFORMATION *)Buffer)->HomeDirectoryDrive.MaximumLength
                     >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("    Home Directory is:    *%wZ*\n",
                     &(((USER_HOME_INFORMATION *)Buffer)->HomeDirectory) );
                    printf("    Home Directory Drive is:    *%wZ*\n",
                     &(((USER_HOME_INFORMATION *)Buffer)->HomeDirectoryDrive) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Script Path Information  . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserScriptInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_SCRIPT_INFORMATION *)Buffer)->ScriptPath.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("      Script Path  is:    *%wZ*\n",
                     &(((USER_SCRIPT_INFORMATION *)Buffer)->ScriptPath) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Query User ProfilePath Information  . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserProfileInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_PROFILE_INFORMATION *)Buffer)->ProfilePath.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("      Profile Path  is:    *%wZ*\n",
                     &(((USER_PROFILE_INFORMATION *)Buffer)->ProfilePath) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Query User Logon Information  . . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_ACCOUNT | USER_READ_GENERAL | USER_READ_PREFERENCES | USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserLogonInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_LOGON_INFORMATION *)Buffer)->UserName.MaximumLength > 0)       &&
                     (((USER_LOGON_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("          User RID is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->UserId) );
                    printf("     Primary Group is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->PrimaryGroupId) );
                    printf("      Logon Units are:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LogonHours.UnitsPerWeek) );
                    printf("     Bad PWD count is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->BadPasswordCount) );
                    printf("       Logon count is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LogonCount) );

                    printf("        last Logon is:    (0x%lx, 0x%lx)\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogon.HighPart),
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogon.LowPart)  );
                    printf("       last Logoff is:    (0x%lx, 0x%lx)\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogoff.HighPart),
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogoff.LowPart)  );


                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->FullName) );
                    printf("          Home Dir is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->HomeDirectory) );
                    printf("    Home Dir Drive is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->HomeDirectoryDrive) );
                    printf("      Script Path  is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->ScriptPath) );
                    printf("      Profile Path is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->ProfilePath) );
                    printf("     WorkStations are:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->WorkStations) );




                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs  not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Logon Hours  . . . . . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserLogonHoursInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                printf("Succeeded\n");

                printf("      Logon Units are:    0x%lx\n",
                 (((USER_LOGON_HOURS_INFORMATION *)Buffer)->LogonHours.UnitsPerWeek) );


                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Account Information . . . . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL | USER_READ_PREFERENCES |
                       USER_READ_LOGON   | USER_READ_ACCOUNT,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAccountInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_ACCOUNT_INFORMATION *)Buffer)->UserName.MaximumLength > 0)       &&
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("          User RID is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->UserId) );
                    printf("     Primary Group is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->PrimaryGroupId) );
                    printf("      Logon Units are:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LogonHours.UnitsPerWeek) );
                    printf("     Bad PWD count is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->BadPasswordCount) );
                    printf("       Logon count is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LogonCount) );
                    printf("      Account Ctrl is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->UserAccountControl) );

                    printf("        last Logon is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogon.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogon.LowPart)  );
                    printf("       last Logoff is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogoff.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogoff.LowPart)  );
                    printf("      Pwd Last Set is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->PasswordLastSet.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->PasswordLastSet.LowPart)  );
                    printf("   Account Expires is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->AccountExpires.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->AccountExpires.LowPart)  );


                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->FullName) );
                    printf("          Home Dir is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->HomeDirectory) );
                    printf("    Home Dir Drive is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->HomeDirectoryDrive) );
                    printf("      Script Path  is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->ScriptPath) );
                    printf("     Profile Path  is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->ProfilePath) );
                    printf("     Admin Comment is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->AdminComment) );
                    printf("     WorkStations are:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->WorkStations) );



                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs  not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );








        printf("      Query Workstations Information  . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserWorkStationsInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_WORKSTATIONS_INFORMATION *)Buffer)->WorkStations.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("      Workstations is:    *%wZ*\n",
                     &(((USER_WORKSTATIONS_INFORMATION *)Buffer)->WorkStations) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query Internal1 Information  . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserInternal1Information,
                       &Buffer
                       );

        if ( NtStatus == STATUS_INVALID_INFO_CLASS ) {

            //
            // We're not a trusted client, so we expected this to fail.
            //

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Status was %lx.\n", NtStatus );
            TestStatus = FALSE;
            if ( NT_SUCCESS( NtStatus ) ) {

                SamFreeMemory( Buffer );
            }
        }

// This is the code that USED to test this function, when it was allowed
// for non-trusted clients.
//
//        if (NT_SUCCESS(NtStatus)) {
//            if (Buffer != NULL) {
//
//                if ( (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseInsensitiveDbcs.MaximumLength > 0) &&
//                     (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseInsensitiveDbcs.Buffer != NULL) &&
//                     (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseSensitiveUnicode.MaximumLength > 0) &&
//                     (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseSensitiveUnicode.Buffer != NULL)
//                         ) {
//
//                     printf("Succeeded\n");
//
//                     //
//                     // Print them out as strings, even though they've been
//                     // through a OWF.
//                     //
//
//                     printf("      CaseInsensitiveDbcs is:    *%s*\n",
//                      &(((USER_INTERNAL1_INFORMATION *)Buffer)->CaseInsensitiveDbcs) );
//
//                     printf("      CaseSensitiveUnicode is:    *%s*\n",
//                      &(((USER_INTERNAL1_INFORMATION *)Buffer)->CaseSensitiveUnicode) );
//
//
//                } else {
//                    printf("Failed\n");
//                    printf("        One of the strings not returned.\n");
//                    TestStatus = FALSE;
//                }
//                SamFreeMemory( Buffer );
//            } else {
//                printf("Failed\n");
//                printf("        Buffer address not set on return.\n");
//                printf("        RPC should have allocated a buffer.\n");
//                TestStatus = FALSE;
//            }
//        } else {
//            printf("Failed\n");
//            printf("        Completion status is 0x%lx\n", NtStatus);
//            TestStatus = FALSE;
//        }

        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query Internal2 Information  . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserInternal2Information,
                       &Buffer
                       );

        if ( NtStatus == STATUS_INVALID_INFO_CLASS ) {

            //
            // We're not a trusted client, so we don't expect to be able
            // to do this.
            //

            printf("Succeeded.\n");

        } else {

            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            SamFreeMemory( Buffer );
        }

// This is the code that USED to test this function, when non-trusted
// clients were allowed to do this...
//
//        if (NT_SUCCESS(NtStatus)) {
//            if (Buffer != NULL) {
//
//                printf("Succeeded\n");
//
//                printf("        last Logon is:    (0x%lx, 0x%lx)\n",
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogon.HighPart),
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogon.LowPart)  );
//                printf("       last Logoff is:    (0x%lx, 0x%lx)\n",
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogoff.HighPart),
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogoff.LowPart)  );
//                printf("       BadPwdCount is:    (0x%x)\n",
//                 ((USER_INTERNAL2_INFORMATION *)Buffer)->BadPasswordCount );
//                printf("       LogonCount  is:    (0x%x)\n",
//                 ((USER_INTERNAL2_INFORMATION *)Buffer)->LogonCount );
//
//                SamFreeMemory( Buffer );
//            } else {
//                printf("Failed\n");
//                printf("        Buffer address not set on return.\n");
//                printf("        RPC should have allocated a buffer.\n");
//                TestStatus = FALSE;
//            }
//        } else {
//            printf("Failed\n");
//            printf("        Completion status is 0x%lx\n", NtStatus);
//            TestStatus = FALSE;
//        }

        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query Set Password Information  . . . . . . . . . . .     ");




        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserSetPasswordInformation,
                       &Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Get Groups For User Suite                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Get Groups For User . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Get Groups For Well-Known Account . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_LIST_GROUPS,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamGetGroupsForUser(
                       UserHandle1,
                       (PGROUP_MEMBERSHIP *)&Buffer,
                       &MembershipCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                printf("Succeeded\n");


                printf("          Member of:    %d groups\n", MembershipCount);
                for ( i=0; i<MembershipCount; i++) {

                    printf("      Group[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                        i,
                        (((PGROUP_MEMBERSHIP)Buffer)[i].RelativeId),
                        (((PGROUP_MEMBERSHIP)Buffer)[i].Attributes)
                        );

                }

                SamFreeMemory( Buffer );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set User Suite                                                        //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set User  . . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Set General Information . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_ALL_ACCESS,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Make the parameter marshallable, but don't worry about values.
        //

        GeneralInformation.UserName = DummyName1;
        GeneralInformation.FullName = DummyName1;
        GeneralInformation.AdminComment = DummyName1;
        GeneralInformation.UserComment  = DummyName1;

        Buffer = &GeneralInformation;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserGeneralInformation,
                       Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Set Preferences Information . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_READ_GENERAL | USER_WRITE_PREFERENCES | USER_READ_PREFERENCES,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserPreferencesInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the fields to  new values and write them out.
            //

            NameLength = ((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment = DummyString2;
            } else {
                ((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment = DummyString1;
            }

            ((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode += 1;
            ((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage += 1;

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserPreferencesInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserPreferencesInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment,
                        (PSTRING)&((USER_PREFERENCES_INFORMATION *)Buffer2)->UserComment,
                        TRUE)
                        &&
                        (((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode ==
                         ((USER_PREFERENCES_INFORMATION *)Buffer2)->CountryCode)
                        &&
                        (((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage ==
                         ((USER_PREFERENCES_INFORMATION *)Buffer2)->CodePage)
                    ) {

                    printf("Succeeded\n");

                    //
                    // Change back some fields to keep from screwing up our database
                    //

                    ((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode -= 1;
                    ((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage    -= 1;

                    IgnoreStatus = SamSetInformationUser(
                                       UserHandle1,
                                       UserPreferencesInformation,
                                       Buffer1
                                       );
                    ASSERT(NT_SUCCESS(IgnoreStatus));

                } else {

                    printf("Failed\n");
                    printf("        Values queried don't match values written\n");
                    printf("        UserComment Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment);
                    printf("        UserComment Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_PREFERENCES_INFORMATION *)Buffer2)->UserComment);
                    printf("        CountryCode Written is   0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode);
                    printf("        CountryCode Retrieved is 0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer2)->CountryCode);
                    printf("        CodePage Written is   0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage);
                    printf("        CodePage Retrieved is 0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer2)->CodePage);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Logon Information . . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_ALL_ACCESS,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Make the parameter marshallable, but don't worry about values.
        //

        LogonInformation.UserName       = DummyName1;
        LogonInformation.FullName       = DummyName1;
        LogonInformation.HomeDirectory  = DummyName1;
        LogonInformation.HomeDirectoryDrive = DummyName1;
        LogonInformation.ScriptPath     = DummyName1;
        LogonInformation.ProfilePath    = DummyName1;
        LogonInformation.WorkStations   = DummyName1;

        LogonInformation.LogonHours     = DummyLogonHours;

        Buffer = &LogonInformation;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserLogonInformation,
                       Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Set Logon Hours Information . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserLogonHoursInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);
            ASSERT( ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours
                    != NULL);  //Don't support zero length bit masks in this test yet.


            //
            // Change the field to a new value and write it out.
            // We have two choices for out test:
            //                                      NoLogonRestriction
            //                                      DummyLogonHours
            //
            // They are guaranteed to have different values in the
            // LOGON_HOURS_DIFFERENT_OFFSET byte of their respective bit masks.
            //

            if ( 0 == ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]) {
                ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours = DummyLogonHours;
            } else {
                ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours = NoLogonRestriction;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserLogonHoursInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserLogonHoursInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                    ==
                    ((USER_LOGON_HOURS_INFORMATION *)Buffer2)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Units Written are   0x%lx\n",
                        ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.UnitsPerWeek);
                    printf("        Units Retrieved are 0x%lx\n",
                        ((USER_LOGON_HOURS_INFORMATION *)Buffer2)->LogonHours.UnitsPerWeek);

                    printf("        Byte 0x%lx of the written bit mask is    0x%lx\n",
                        LOGON_HOURS_DIFFERENT_OFFSET,
                        (ULONG)((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                        );
                    printf("        Byte 0x%lx of the retrieved bit mask is  0x%lx\n",
                        LOGON_HOURS_DIFFERENT_OFFSET,
                        (ULONG)((USER_LOGON_HOURS_INFORMATION *)Buffer2)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                        );

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }





        printf("      Set Account Information . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_WRITE_ACCOUNT        |
                           USER_READ_GENERAL     |
                           USER_READ_PREFERENCES |
                           USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Make the parameter marshallable, but don't worry about values.
        //

        AccountInformation.UserName       = DummyName1;
        AccountInformation.FullName       = DummyName1;
        AccountInformation.HomeDirectory  = DummyName1;
        AccountInformation.HomeDirectoryDrive = DummyName1;
        AccountInformation.ScriptPath     = DummyName1;
        AccountInformation.ProfilePath    = DummyName1;
        AccountInformation.AdminComment   = DummyName1;
        AccountInformation.WorkStations   = DummyName1;

        AccountInformation.LogonHours     = DummyLogonHours;

        Buffer = &AccountInformation;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserAccountInformation,
                       Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );


        printf("      Set Home  . . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserHomeInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory = DummyString2;
            } else {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory = DummyString1;
            }

            NameLength = ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive = DummyString2;
            } else {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserHomeInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserHomeInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );

                if (!RtlCompareString(
                        (PSTRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory,
                        (PSTRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectory,
                        TRUE) ) {

                    if (!RtlCompareString(
                            (PSTRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive,
                            (PSTRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectoryDrive,
                            TRUE)
                    ) {
                        printf("Succeeded\n");
                    } else {

                        printf("Failed\n");
                        printf("        Drive Value queried doesn't match value written\n");
                        printf("        Value Written is   %wZ\n",
                            (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive);
                        printf("        Value Retrieved is %wZ\n",
                            (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectoryDrive);

                        TestStatus = FALSE;
                    }

                } else {

                    printf("Failed\n");
                    printf("        Directory Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectory);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Script  . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserScriptInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath = DummyString2;
            } else {
                ((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserScriptInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserScriptInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath,
                        (PSTRING)&((USER_SCRIPT_INFORMATION *)Buffer2)->ScriptPath,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_SCRIPT_INFORMATION *)Buffer2)->ScriptPath);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Profile . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserProfileInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath = DummyString2;
            } else {
                ((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserProfileInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserProfileInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath,
                        (PSTRING)&((USER_PROFILE_INFORMATION *)Buffer2)->ProfilePath,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_PROFILE_INFORMATION *)Buffer2)->ProfilePath);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Admin Comment . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_GENERAL,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserAdminCommentInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString2;
            } else {
                ((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserAdminCommentInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserAdminCommentInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment,
                        (PSTRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer2)->AdminComment,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer2)->AdminComment);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }


        printf("      Set Workstations  . . . . . . . . . . . . . . . . . .     ");
        printf("BROKEN TEST - NOT TESTED\n");
#ifdef BROKEN
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserWorkStationsInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations = DummyString2;
            } else {
                ((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserWorkStationsInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserWorkStationsInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations,
                        (PSTRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer2)->WorkStations,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer2)->WorkStations);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }
#endif //BROKEN


        printf("      Set Internal1   . . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON | USER_FORCE_PASSWORD_CHANGE,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // We can't get the current values, since this level is only
            // queryable by trusted clients.  So just try setting a couple
            // of values and make sure that we don't get an error.
            //

            Buffer1 = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(USER_INTERNAL1_INFORMATION) );
            ASSERT( Buffer1 != NULL );

            ((PUSER_INTERNAL1_INFORMATION)Buffer1)->NtPasswordPresent = FALSE;
            ((PUSER_INTERNAL1_INFORMATION)Buffer1)->LmPasswordPresent = FALSE;

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserInternal1Information,
                           Buffer1
                           );

            if (NtStatus != STATUS_PASSWORD_RESTRICTION) {

                printf("Failed\n");
                printf("    Expected Status = 0x%lx\n", STATUS_PASSWORD_RESTRICTION);
                printf("    Received Status = 0x%lx\n", NtStatus );
                TestStatus = FALSE;

            } else {

                //
                // The NULL password worked, so let's try a real password.
                //

                NtStatus = RtlCalculateNtOwfPassword(
                    &DummyName1,
                    &((PUSER_INTERNAL1_INFORMATION)Buffer1)->NtOwfPassword
                    );
                ASSERT(NT_SUCCESS(NtStatus));

                ((PUSER_INTERNAL1_INFORMATION)Buffer1)->NtPasswordPresent = TRUE;

                NtStatus = RtlCalculateLmOwfPassword(
                    DUMMY_STRING1,
                    &((PUSER_INTERNAL1_INFORMATION)Buffer1)->LmOwfPassword
                    );
                ASSERT(NT_SUCCESS(NtStatus));

                ((PUSER_INTERNAL1_INFORMATION)Buffer1)->LmPasswordPresent = TRUE;

                NtStatus = SamSetInformationUser(
                               UserHandle1,
                               UserInternal1Information,
                               Buffer1
                               );

                if ( NT_SUCCESS(NtStatus) ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("    Return status was %lx\n", NtStatus );
                    TestStatus = FALSE;
                }
            }

            RtlFreeHeap( RtlProcessHeap(), 0, Buffer1 );


// This is the code that used to be here, when UserInternal1Information was
// queryable by non-trusted clients...
//
//            Buffer1 = NULL;
//            NtStatus = SamQueryInformationUser(
//                           UserHandle1,
//                           UserInternal1Information,
//                           &Buffer1
//                           );
//            TST_SUCCESS_ASSERT(NtStatus);
//            ASSERT(Buffer1 != NULL);
//
//            //
//            // The passwords were initially empty.  Put in some random
//            // OWF passwords, and have them written out.
//            //
//
//            NtStatus = RtlCalculateNtOwfPassword(
//                (PNT_PASSWORD)&DummyName1,
//                &EncryptedPasswordBuffer
//                );
//
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode.Buffer = (PCHAR)&EncryptedPasswordBuffer;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode.Length = 16;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode.MaximumLength = 16;
//
//            NtStatus = RtlCalculateNtOwfPassword(
//                (PNT_PASSWORD)&DummyName2,
//                &EncryptedPasswordBuffer2
//                );
//
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs.Buffer = (PCHAR)&EncryptedPasswordBuffer2;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs.Length = 16;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs.MaximumLength = 16;
//
//            NtStatus = SamSetInformationUser(
//                           UserHandle1,
//                           UserInternal1Information,
//                           Buffer1
//                           );
//            if ( NT_SUCCESS(NtStatus) ) {
//
//                //
//                // Now check that the change was really made...
//                //
//
//                NtStatus = SamQueryInformationUser(
//                               UserHandle1,
//                               UserInternal1Information,
//                               &Buffer2
//                               );
//                ASSERT(NT_SUCCESS( NtStatus ) );
//
//                if ( (
//                    !RtlCompareString(
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode,
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseSensitiveUnicode,
//                        TRUE)
//                    ) || (
//                    !RtlCompareString(
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs,
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseInsensitiveDbcs,
//                        TRUE)
//                    ) ) {
//
//                    printf("Succeeded\n");
//
//                } else {
//
//                    printf("Failed\n");
//                    printf("        Value queried doesn't match value written\n");
//                    printf("        CaseInsensitiveDbcs Written is   %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs);
//                    printf("        CaseInsensitiveDbcs Retrieved is %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseInsensitiveDbcs);
//                    printf("        CaseSensitiveUnicode Written is   %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode);
//                    printf("        CaseSensitiveUnicode Retrieved is %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseSensitiveUnicode);
//
//                    TestStatus = FALSE;
//
//                }
//
//                SamFreeMemory( Buffer1 );
//                SamFreeMemory( Buffer2 );
//
//            } else {
//                printf("Failed\n");
//                printf("        Completion status is 0x%lx\n", NtStatus);
//                TestStatus = FALSE;
//                SamFreeMemory( Buffer1 );
//
//            }



        printf("      Set Internal2   . . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // We can't get the current values, since this level is only
            // queryable by trusted clients.  We can't set either, but
            // try it and make sure we get the correct error.
            //

            Buffer1 = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(USER_INTERNAL2_INFORMATION) );
            ASSERT( Buffer1 != NULL );

            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.HighPart = 1;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.HighPart = 2;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.LowPart = 3;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.LowPart = 4;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->BadPasswordCount = 5;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LogonCount = 6;

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserInternal2Information,
                           Buffer1
                           );

            RtlFreeHeap( RtlProcessHeap(), 0, Buffer1 );

            if ( NtStatus == STATUS_INVALID_INFO_CLASS ) {

                printf("Succeeded\n");

            } else {

                printf("Failed\n");
                printf("    Expected Status = 0x%lx\n", STATUS_INVALID_INFO_CLASS);
                printf("    Received Status = 0x%lx\n", NtStatus );
                TestStatus = FALSE;
            }

// This is the code that was here when UserInternal2Information could be
// queried and set by non-trusted clients...
//
//            //
//            // Get the current values...
//            //
//
//            Buffer1 = NULL;
//            NtStatus = SamQueryInformationUser(
//                           UserHandle1,
//                           UserInternal2Information,
//                           &Buffer1
//                           );
//            TST_SUCCESS_ASSERT(NtStatus);
//            ASSERT(Buffer1 != NULL);
//
//            //
//            // Now change the fields and write them out.
//            //
//
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.HighPart += 1;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.HighPart += 1;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.LowPart += 2;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.LowPart += 2;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->BadPasswordCount += 1;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LogonCount += 1;
//
//            NtStatus = SamSetInformationUser(
//                           UserHandle1,
//                           UserInternal2Information,
//                           Buffer1
//                           );
//            if ( NT_SUCCESS(NtStatus) ) {
//
//                //
//                // Now check that the change was really made...
//                //
//
//                NtStatus = SamQueryInformationUser(
//                               UserHandle1,
//                               UserInternal2Information,
//                               &Buffer2
//                               );
//                ASSERT(NT_SUCCESS( NtStatus ) );
//                if (
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.HighPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogon.HighPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.LowPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogon.LowPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.HighPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogoff.HighPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.LowPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogoff.LowPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->BadPasswordCount ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->BadPasswordCount) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LogonCount ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LogonCount)
//                     ) {
//
//                    printf("Succeeded\n");
//
//                } else {
//
//                    printf("Failed\n");
//                    printf("        Value queried doesn't match value written\n");
//
//                    TestStatus = FALSE;
//
//                }
//
//                SamFreeMemory( Buffer1 );
//                SamFreeMemory( Buffer2 );
//
//            } else {
//                printf("Failed\n");
//                printf("        Completion status is 0x%lx\n", NtStatus);
//                TestStatus = FALSE;
//                SamFreeMemory( Buffer1 );
//
//            }



        printf("      Set Password  . . . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_FORCE_PASSWORD_CHANGE,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Create a fake cleartext UNICODE password and write it out.
            //

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserSetPasswordInformation,
                           &DummyName2
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // We can't verify that it really worked, so we just have
                // to trust the return code.
                //

                printf("Succeeded\n");

            } else {

                printf("Failed\n");
                printf("    Return code was %lx\n", NtStatus );
                TestStatus = FALSE;
            }



        printf("      Set Control . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_ACCOUNT,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserControlInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);

            //
            // Change the value and write it back
            //

            ((USER_CONTROL_INFORMATION *)Buffer1)->UserAccountControl ^= USER_HOME_DIRECTORY_REQUIRED;


            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserControlInformation,
                           Buffer1
                           );
            if (NT_SUCCESS(NtStatus)) {

                //
                // Check the written value to make sure it stuck
                //

                Buffer2 = NULL;
                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserControlInformation,
                               &Buffer2
                               );
                TST_SUCCESS_ASSERT(NtStatus);
                ASSERT(Buffer2 != NULL);

                if ( ((USER_CONTROL_INFORMATION *)Buffer1)->UserAccountControl  ==
                     ((USER_CONTROL_INFORMATION *)Buffer2)->UserAccountControl ) {

                    printf("Succeeded\n");

                    SamFreeMemory( Buffer2 );

                    //
                    // Make sure the account is left enabled to prevent problems.
                    //

                    ((USER_CONTROL_INFORMATION *)Buffer1)->UserAccountControl &= ~USER_ACCOUNT_DISABLED;

                    IgnoreStatus = SamSetInformationUser(
                                       UserHandle1,
                                       UserControlInformation,
                                       Buffer1
                                       );
                    ASSERT(NT_SUCCESS(IgnoreStatus));

                } else {
                    printf("Failed\n");
                    printf("        Returned Value Doesn't Match Set Value.\n");
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer1 );
            IgnoreStatus = SamCloseHandle( UserHandle1 );
            ASSERT( NT_SUCCESS(IgnoreStatus) );


        printf("      Set Expires . . . . . . . . . . . . . . . . . . . . .     ");
        printf("BROKEN TEST - NOT TESTED\n");
#ifdef BROKEN
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_ACCOUNT,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserExpiresInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);

            //
            // Change the value and write it back
            //

            ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.LowPart  += 1234;
            ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.HighPart += 1234;


            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserExpiresInformation,
                           Buffer1
                           );
            if (NT_SUCCESS(NtStatus)) {

                //
                // Check the written value to make sure it stuck
                //

                Buffer2 = NULL;
                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserExpiresInformation,
                               &Buffer2
                               );
                TST_SUCCESS_ASSERT(NtStatus);
                ASSERT(Buffer2 != NULL);

                if ( ( ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.LowPart  ==
                       ((USER_EXPIRES_INFORMATION *)Buffer2)->AccountExpires.LowPart )  &&
                     ( ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.HighPart  ==
                       ((USER_EXPIRES_INFORMATION *)Buffer2)->AccountExpires.HighPart ) ) {

                    printf("Succeeded\n");

                    SamFreeMemory( Buffer2 );

                    //
                    // Change the values back
                    //

                    ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.LowPart  += 1234;
                    ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.HighPart += 1234;

                    IgnoreStatus = SamSetInformationUser(
                                       UserHandle1,
                                       UserExpiresInformation,
                                       Buffer1
                                       );
                    ASSERT(NT_SUCCESS(IgnoreStatus));

                } else {
                    printf("Failed\n");
                    printf("        Returned Value Doesn't Match Set Value.\n");
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer1 );
            IgnoreStatus = SamCloseHandle( UserHandle1 );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
#endif //BROKEN



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Change Password For User Suite                                        //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Change Password For User  . . . . . . . . . . . . . .   Suite\n");

        printf("      Change Password For Well-Known User . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_CHANGE_PASSWORD,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;

        //
        // The current password is DummyName2.  Using DummyName2 as the
        // old password, change it to DummyName1 and make sure we get
        // STATUS_SUCCESS.
        //

        NtStatus = SamChangePasswordUser(
                       UserHandle1,
                       &DummyName2,
                       &DummyName1
                       );

        //
        // The current password is DummyName1.  Using something WRONG for
        // the old password, try to change it to DummyName2 and make sure
        // it doesn't succeed.
        //

        if ( NtStatus == STATUS_SUCCESS ) {

            NtStatus = SamChangePasswordUser(
                           UserHandle1,
                           &DummyName2,
                           &DummyName2
                           );

            if ( NtStatus == STATUS_SUCCESS ) {

                NtStatus = STATUS_UNSUCCESSFUL;

            } else {

                NtStatus = STATUS_SUCCESS;
            }
        }

        //
        // The current password is DummyName1.  Using DummyName1 as the
        // old password, change it to DummyName2 and make sure it works
        // since by default there is no password history.
        //

        if ( NtStatus == STATUS_SUCCESS ) {

            NtStatus = SamChangePasswordUser(
                           UserHandle1,
                           &DummyName1,
                           &DummyName2
                           );
        }

        if ( NT_SUCCESS( NtStatus ) ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Status is %lx\n", NtStatus);

            TestStatus = FALSE;
        }

        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

    }

// END PASS #1

    if (Pass == 2) {

        printf("\n");
        printf("\n");
        printf("  User  (Pass #2) . . . . . . . . . . . . . . . . . . .   Test\n");


        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Delete User  Suite                                                    //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Delete User   . . . . . . . . . . . . . . . . . . . .   Suite\n");



        printf("      Delete Normal User  . . . . . . . . . . . . . . . . .     ");

        //
        // This User was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeUser);
        RtlFreeUnicodeString( &AccountNames[0] );



        UserHandle1 = NULL;

        NtStatus = SamOpenUser( DomainHandle, DELETE, LookedUpRids[0], &UserHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamDeleteUser( UserHandle1 );
        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Delete Admin Group Member . . . . . . . . . . . . . .     ");
        printf("(Unimplemented)\n");

        printf("      Delete Last Admin Group Member  . . . . . . . . . . .     ");
        printf("(Unimplemented)\n");





        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set User Suite                                                        //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set User (Pass 2) . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Set ALL information. . . . . . . . . . . .     ");
        printf("BROKEN TEST - NOT TESTED\n");
#ifdef BROKEN

        RtlInitString( &AccountNameAnsi, "AllUser" );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );

        ASSERT(NT_SUCCESS(NtStatus));

        All = NULL;

        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAllInformation,
                       &All
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Now change some of the data, and set it
            //

            RtlInitString( &TmpAnsiString, "FullName" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->FullName),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "HomeDirectory" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->HomeDirectory),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "HomeDirectoryDrive" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->HomeDirectoryDrive),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "ScriptPath" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->ScriptPath),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "ProfilePath" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->ProfilePath),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "AdminComment" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->AdminComment),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "WorkStations" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->WorkStations),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "UserComment" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->UserComment),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "Parameters" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->Parameters),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            All->CountryCode = 7;
            All->CodePage = 8;

            All->PasswordExpired = TRUE;
            All->NtPasswordPresent = TRUE;
            All->LmPasswordPresent = FALSE;

            RtlInitString( &TmpAnsiString, "NtPassword" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->NtPassword),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            All->LogonHours.UnitsPerWeek = 7;

            All->WhichFields =  ( USER_ALL_FULLNAME |
                                USER_ALL_HOMEDIRECTORY |
                                USER_ALL_HOMEDIRECTORYDRIVE |
                                USER_ALL_SCRIPTPATH |
                                USER_ALL_PROFILEPATH |
                                USER_ALL_ADMINCOMMENT |
                                USER_ALL_WORKSTATIONS |
                                USER_ALL_USERCOMMENT |
                                USER_ALL_PARAMETERS |
                                USER_ALL_COUNTRYCODE |
                                USER_ALL_CODEPAGE |
                                USER_ALL_PASSWORDEXPIRED |
                                USER_ALL_NTPASSWORDPRESENT |
                                USER_ALL_LOGONHOURS );

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserAllInformation,
                           All
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserAllInformation,
                               &All2
                               );

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // Verify that queried info is as we set it
                    //

                    if (

                        //
                        // Fields that we didn't touch.  Note that
                        // PasswordMustChange changed anyway, since we
                        // changed from a null to a non-null password.
                        //

                        ( All2->WhichFields != (USER_ALL_READ_GENERAL_MASK    |
                                               USER_ALL_READ_PREFERENCES_MASK |
                                               USER_ALL_READ_ACCOUNT_MASK     |
                                               USER_ALL_READ_LOGON_MASK) ) ||
                        ( All->LastLogon.QuadPart != All2->LastLogon.QuadPart) ||
                        ( All->LastLogoff.QuadPart != All2->LastLogoff.QuadPart) ||
                        ( All->PasswordLastSet.QuadPart != All2->PasswordLastSet.QuadPart) ||
                        ( All->AccountExpires.QuadPart != All2->AccountExpires.QuadPart) ||
                        ( All->PasswordCanChange.QuadPart != All2->PasswordCanChange.QuadPart) ||
                        ( All->PasswordMustChange.QuadPart == All2->PasswordMustChange.QuadPart) ||
                        (RtlCompareUnicodeString(
                            &(All->UserName),
                            &(All2->UserName),
                            FALSE) != 0) ||
                        ( All->UserId != All2->UserId ) ||
                        ( All->PrimaryGroupId != All2->PrimaryGroupId ) ||
                        ( All->UserAccountControl != All2->UserAccountControl ) ||
                        ( All->PrivateDataSensitive !=
                            All2->PrivateDataSensitive ) ||

                        // Fields that we changed.  Note that we set
                        // NtPasswordSet, but it shouldn't be set on return.

                        (RtlCompareUnicodeString(
                            &(All->FullName),
                            &(All2->FullName),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->HomeDirectory),
                            &(All2->HomeDirectory),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->HomeDirectoryDrive),
                            &(All2->HomeDirectoryDrive),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->ScriptPath),
                            &(All2->ScriptPath),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->ProfilePath),
                            &(All2->ProfilePath),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->AdminComment),
                            &(All2->AdminComment),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->WorkStations),
                            &(All2->WorkStations),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->UserComment),
                            &(All2->UserComment),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->Parameters),
                            &(All2->Parameters),
                            FALSE) != 0) ||
                        ( All->CountryCode != All2->CountryCode ) ||
                        ( All->CodePage != All2->CodePage ) ||
                        ( All->LmPasswordPresent != All2->LmPasswordPresent ) ||
                        ( All->NtPasswordPresent == All2->NtPasswordPresent ) ||
                        ( All->LogonHours.UnitsPerWeek !=
                            All2->LogonHours.UnitsPerWeek )
                        ) {

                        NtStatus = STATUS_DATA_ERROR;
                    }

                    SamFreeMemory( All2 );
                }
            }

            SamFreeMemory( All );
        }

        if (NtStatus == STATUS_SUCCESS) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        //
        // Now get rid of the user account if necessary
        //

        NtStatus = SamDeleteUser( UserHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));
#endif //BROKEN


        printf("      Set Primary Group (non member). . . . . . . . . . . .     ");
        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            RtlFreeUnicodeString( &AccountNames[0] );
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           LookedUpRids[0],
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // The user is not a member of DOMAIN_GROUP_RID_ADMINS.
        // See if we can make this group the user's primary group
        //

        ASSERT(sizeof(GroupRid) == sizeof(USER_PRIMARY_GROUP_INFORMATION));
        GroupRid = DOMAIN_GROUP_RID_ADMINS;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );

        if (NtStatus == STATUS_MEMBER_NOT_IN_GROUP) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Now get rid of the user account if necessary
        //

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }



        printf("      Set Primary Group (member). . . . . . . . . . . . . .     ");

        //
        // Make a user (might already exist)
        // Make a group
        // Make the group the user's primary group
        // Change the user so the group isn't the primary group
        // remove the group
        // delete the group
        // If we created the user, delete it.

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );
        ASSERT(NT_SUCCESS(NtStatus));


        //
        // Set the user's primary group Id to be this group
        //

        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        if (NT_SUCCESS(NtStatus)) {

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserPrimaryGroupInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);

            if ( ((USER_PRIMARY_GROUP_INFORMATION *)Buffer1)->PrimaryGroupId  ==
                 GroupRid ) {

                printf("Succeeded\n");

                SamFreeMemory( Buffer1 );
            } else {

                printf("Failed\n");
                printf("        Returned Value Doesn't Match Set Value.\n");
                printf("        Value written is: 0x%lx\n", GroupRid);
                printf("      Value retrieved is: 0x%lx\n",
                    ((USER_PRIMARY_GROUP_INFORMATION *)Buffer1)->PrimaryGroupId);
                TestStatus = FALSE;

            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Set the user's primary group Id back and remove the user
        // from the group
        //

        GroupRid = DOMAIN_GROUP_RID_USERS;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        ASSERT(NT_SUCCESS(NtStatus));
        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        ASSERT(NT_SUCCESS(NtStatus));



        //
        // Now get rid of the group and possibly the user account
        //


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }









        printf("      Set Name Information  . . . . . . . . . . . . . . . .     ");
        printf("(Untested)\n");


    }

    return(TestStatus);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following symbols should be defined in your environment:
#       NOTE: This file is designed to provide separate generation
#             of client and server stubs.  Right now, it uses an
#             .acf for only the client stub generation.  However,
#             lines to cause a server .acf file to be used are present
#             but commented out.
# The following is where you put the name of your .idl file without
# the .idl extension:


CLIENT_ACF = samcli.acf
SERVER_ACF = $(PROJECT_ROOT)\published\ds\sam\idl\samsrv.acf

CLIENT_INC_FILE= $(IDL_NAME)_c.h
SERVER_INC_FILE= $(IDL_NAME).h

CLIENT_TARGETS = \
        $(O)\$(IDL_NAME)_c.c \
        $(O)\$(CLIENT_INC_FILE)

SERVER_TARGETS = \
        $(O)\$(IDL_NAME)_s.c \
        $(O)\$(SERVER_INC_FILE)

MIDL_INCS= -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(DS_INC_PATH) -I$(PROJECT_ROOT)\published\ds\sam\idl
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all

CLIENT_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(CLIENT_ACF) -server none -out .\$(O) -header $(CLIENT_INC_FILE)
SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(SERVER_ACF) -client none -out .\$(O) -header $(SERVER_INC_FILE)

CPP = -cpp_cmd "$(MIDL_CPP)"

TARGETS: \
        $(CLIENT_TARGETS) \
        $(SERVER_TARGETS)

clean:
    -del /F /Q $(CLIENT_TARGETS)
    -del /F /Q $(SERVER_TARGETS)

$(CLIENT_TARGETS): $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl $(CLIENT_ACF)
    $(MIDL) $(CPP) $(CLIENT_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl

$(SERVER_TARGETS): $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\lib\recmem.c ===
#include <ntosp.h>
#include <nturtl.h>
#include "recmem.h"



#ifdef RECOVERY_KERNELMODE


PVOID
RecSamAlloc(
    ULONG Size
    )
{
    return ExAllocatePoolWithTag( PagedPool, Size, RECOVERY_BUFFER_TAG );
}

VOID
RecSamFree(
    PVOID p
    )
{
    ExFreePoolWithTag( p, RECOVERY_BUFFER_TAG );
}


#else  // RECOVERY_KERNELMODE


PVOID
RecSamAlloc(
    ULONG Size
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, Size);
}
VOID
RecSamFree(
    PVOID p
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}



#endif // RECOVERY_KERNELMODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\lib\enckey.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.c
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//              
//              09-Jan-99       ShaoYin copy it from newsam2\server to support 
//                              recovery mode authentication
//
//---------------------------------------------------------------------------


//
// This file should keep sync with newsam2\server\enckey.c
// 
// This file is just a minimum subset of \newsam2\server\enckey.c
// only contains KEDecryptKey().
// 



#include <windows.h>
#include <rc4.h>
#include <md5.h>
#include <rng.h>
#include <enckey.h>



//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.  Note that
//  this function is ALWAYS destructive to the passed encryption block.  In
//  the case of a decrypt, it will be zeroed out.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey   *pPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey  *pSAMKey,
    IN DWORD        dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT   LocalRC4Key;

    if ((pPassword == NULL) || (pEncBlock == NULL) || (pSAMKey == NULL))
        return KE_FAIL;

    if ((pEncBlock->dwVersion != KE_CUR_VERSION) ||
        (pPassword->dwVersion != KE_CUR_VERSION))
        return KE_FAIL;

    pSAMKey->dwVersion = KE_CUR_VERSION;
    pSAMKey->dwLength = sizeof(KEClearKey);

    // Decrypt the key and the confirmer
    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *) &(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
    RtlSecureZeroMemory(&(LocalRC4Key), sizeof(LocalRC4Key));

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    // Check that the confirmer matches

    if (memcmp(&(LocalHash.digest), &(pEncBlock->Confirm), KE_KEY_SIZE))
    {
        // Failed.  Zero and leave.
        // No need to zero the block, since rc4 trashed it.

        RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
        return KE_BAD_PASSWORD;
    }

    // Confirmer matched.

    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
    memcpy(pSAMKey->ClearKey, pEncBlock->EncKey, KE_KEY_SIZE);
    RtlSecureZeroMemory(pEncBlock, sizeof(KEEncKey));

    return KE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\lib\recmem.h ===
//
// Pool Tag
// 
#define RECOVERY_BUFFER_TAG     'RecB'

PVOID
RecSamAlloc(
    ULONG Size
    );

VOID
RecSamFree(
    PVOID p
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\lib\enckey.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.h
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//
//---------------------------------------------------------------------------



// consts

#define KE_KEY_SIZE     16
#define KE_CUR_VERSION  1

#define MAGIC_CONST_1   "0123456789012345678901234567890123456789"
#define MAGIC_CONST_2   "!@#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%"

// error codes

#define KE_OK           0
#define KE_FAIL         1
#define KE_BAD_PASSWORD 2

typedef struct _EncKey {
    DWORD   dwVersion;      // 00000001 = 128 bit RC4
    DWORD   dwLength;       // = sizeof(KEEncKey)
    BYTE    Salt[16];       // 16 bytes of random salt
    BYTE    EncKey[KE_KEY_SIZE];     // Key encrypted with PW + Salt
    BYTE    Confirm[16];    // MD5(Key) encrypted with PW+Salt
} KEEncKey;

typedef struct _ClearKey {
    DWORD   dwVersion;          // 00000001 = 128 bit plain key
    DWORD   dwLength;           // = sizeof(KEClearKey)
    BYTE    ClearKey[KE_KEY_SIZE];   // 128 bits of key data
} KEClearKey;


//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey       *pszPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\client\wrappers.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wrappers.c

Abstract:

    This file contains all SAM rpc wrapper routines.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"
#include <md5.h>
#include <rpcasync.h>
#include <wxlpc.h>
#include <ntdsapi.h>    //for DsMakeSpn

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private defines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SAMP_MAXIMUM_SUB_LOOKUP_COUNT   ((ULONG) 0x00000200)

// Simple tracing routine for client-side API -- this should be removed once
// we understand how the DS-based SAM works. This macro is only called from
// within wrappers.c.

#define SAMP_TRACE_CLIENT_API 0

#if SAMP_TRACE_CLIENT_API == 1

#define SampOutputDebugString(Message) \
    OutputDebugStringA("SAM API = ");  \
    OutputDebugStringA(Message);       \
    OutputDebugStringA("\n");          \

#else

#define SampOutputDebugString(Message)

#endif



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local data types                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// This structure is used to pass a (potentially) very large
// user requested name lookup into (possibly many) smaller
// remote lookup requests.  This is necessary to prevent the
// server from being asked to allocate huge chunks of memory,
// potentially running out of memory.
//
// There will be one of these structures for each server call
// that is necessary.
//

typedef struct _SAMP_NAME_LOOKUP_CALL {

    //
    // Each call is represented by one of these structures.
    // The structures are chained together to show the order
    // the calls were made (allowing an easy way to build the
    // buffer that is to be returned to the user).
    //

    LIST_ENTRY          Link;

    //
    // These fields define the beginning and ending indexes into
    // the user passed Names buffer that are being represented by
    // this call.
    //

    ULONG               StartIndex;
    ULONG               Count;


    //
    // These fields will receive the looked up RIDs and USE buffers.
    // Notice that the .Element fields of these fields will receive
    // pointers to the bulk of the returned information.
    //

    SAMPR_ULONG_ARRAY   RidBuffer;
    SAMPR_ULONG_ARRAY   UseBuffer;

} SAMP_NAME_LOOKUP_CALL, *PSAMP_NAME_LOOKUP_CALL;

//
// This is the handle returned to clients
//
typedef struct _SAMP_CLIENT_INFO
{
    // RPC context handle
    SAMPR_HANDLE ContextHandle;

    // Information about the server we are connected to
    SAMPR_REVISION_INFO_V1 ServerInfo;

    // The domain sid of the handle -- not set on handles returned
    // from SamConnect
    PSID DomainSid;  OPTIONAL

} SAMP_CLIENT_INFO, *PSAMP_CLIENT_INFO;

typedef PSAMP_CLIENT_INFO SAMP_HANDLE;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use OPTIONAL
    );

NTSTATUS
SampMapCompletionStatus(
    IN NTSTATUS Status
    );

NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING Password
    );

NTSTATUS
SampCheckPasswordRestrictions(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING NewNtPassword,
    OUT PBOOLEAN UseOwfPasswords
    );

NTSTATUS
SampCreateNewHandle(
    IN  SAMP_HANDLE RequestingHandle,
    IN  PSID        DomainSid,
    OUT SAMP_HANDLE* NewHandle
    );

VOID
SampFreeHandle(
    IN OUT SAMP_HANDLE *Handle
    );

BOOLEAN
SampIsValidClientHandle(
    IN     SAM_HANDLE  SampHandle,
    IN OUT SAMPR_HANDLE *RpcHandle OPTIONAL
    );

NTSTATUS
SampMakeSid(
    IN PSID  DomainSid,
    IN ULONG Rid,
    OUT PSID* Sid
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// General services                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SamFreeMemory(
    IN PVOID Buffer
    )

/*++
Routine Description:


    Some SAM services that return a potentially large amount of memory,
    such as an enumeration might, allocate the buffer in which the data
    is returned.  This function is used to free those buffers when they
    are no longer needed.

Parameters:

    Buffer - Pointer to the buffer to be freed.  This buffer must
        have been allocated by a previous SAM service call.

Return Values:

    STATUS_SUCCESS - normal, successful completion.


--*/
{
    if (NULL != Buffer)
    {
        MIDL_user_free( Buffer );
    }
    return(STATUS_SUCCESS);
}



NTSTATUS
SamSetSecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++
Routine Description:


    This function (SamSetSecurityObject) takes a well formed Security
    Descriptor provided by the caller and assigns specified portions of
    it to an object.  Based on the flags set in the SecurityInformation
    parameter and the caller's access rights, this procedure will
    replace any or all of the security information associated with an
    object.

    This is the only function available to users and applications for
    changing security information, including the owner ID, group ID, and
    the discretionary and system ACLs of an object.  The caller must
    have WRITE_OWNER access to the object to change the owner or primary
    group of the object.  The caller must have WRITE_DAC access to the
    object to change the discretionary ACL.  The caller must have
    ACCESS_SYSTEM_SECURITY access to an object to assign a system ACL
    to the object.

    This API is modelled after the NtSetSecurityObject() system service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Indicates which security information is to
        be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.

    SecurityDescriptor - A pointer to a well formed Security
        Descriptor.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates something about security descriptor
        is not valid.  This may indicate that the structure of the descriptor is
        not valid or that a component of the descriptor specified via the
        SecurityInformation parameter is not present in the security descriptor.

    STATUS_INVALID_PARAMETER - Indicates no security information was specified.



--*/
{
    NTSTATUS                        NtStatus;

    ULONG                           SDLength;
    SAMPR_SR_SECURITY_DESCRIPTOR    DescriptorToPass;
    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamSetSecurityObject");

    if (!SampIsValidClientHandle(ObjectHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Make a self relative security descriptor for use in the RPC call..
    //


    SDLength = 0;
    NtStatus = RtlMakeSelfRelativeSD(
                   SecurityDescriptor,
                   NULL,
                   &SDLength
                   );

    if (NtStatus != STATUS_BUFFER_TOO_SMALL) {

        return(STATUS_INVALID_PARAMETER);

    } else {


        DescriptorToPass.SecurityDescriptor = MIDL_user_allocate( SDLength );
        DescriptorToPass.Length = SDLength;
        if (DescriptorToPass.SecurityDescriptor == NULL) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {


            //
            // make an appropriate self-relative security descriptor
            //

            NtStatus = RtlMakeSelfRelativeSD(
                           SecurityDescriptor,
                           (PSECURITY_DESCRIPTOR)DescriptorToPass.SecurityDescriptor,
                           &SDLength
                           );
        }

    }







    //
    // Call the server ...
    //

    if (NT_SUCCESS(NtStatus)) {
        RpcTryExcept{

            NtStatus =
                SamrSetSecurityObject(
                    (SAMPR_HANDLE)RpcContextHandle,
                    SecurityInformation,
                    &DescriptorToPass
                    );



        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }

    MIDL_user_free( DescriptorToPass.SecurityDescriptor );

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamQuerySecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR * SecurityDescriptor
    )
/*++

Routine Description:


    This function (SamQuerySecurityObject) returns to the caller requested
    security information currently assigned to an object.

    Based on the caller's access rights this procedure
    will return a security descriptor containing any or all of the
    object's owner ID, group ID, discretionary ACL or system ACL.  To
    read the owner ID, group ID, or the discretionary ACL the caller
    must be granted READ_CONTROL access to the object.  To read the
    system ACL the caller must be granted ACCESS_SYSTEM_SECURITY
    access.

    This API is modelled after the NtQuerySecurityObject() system
    service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Supplies a value describing which pieces of
        security information are being queried.

    SecurityDescriptor - Receives a pointer to the buffer containing
        the requested security information.  This information is
        returned in the form of a self-relative security descriptor.
        The caller is responsible for freeing the returned buffer
        (using SamFreeMemory()) when the security descriptor
        is no longer needed.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.



--*/
{
    NTSTATUS                        NtStatus;
    SAMPR_SR_SECURITY_DESCRIPTOR    ReturnedSD;
    PSAMPR_SR_SECURITY_DESCRIPTOR   PReturnedSD;

    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamQuerySecurityObject");

    //
    // The retrieved security descriptor is returned via a data structure that
    // looks like:
    //
    //             +-----------------------+
    //             | Length (bytes)        |
    //             |-----------------------|          +--------------+
    //             | SecurityDescriptor ---|--------->| Self-Relative|
    //             +-----------------------+          | Security     |
    //                                                | Descriptor   |
    //                                                +--------------+
    //
    // The first of these buffers is a local stack variable.  The buffer containing
    // the self-relative security descriptor is allocated by the RPC runtime.  The
    // pointer to the self-relative security descriptor is what is passed back to our
    // caller.
    //
    //

    if (!SampIsValidClientHandle(ObjectHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // To prevent RPC from trying to marshal a self-relative security descriptor,
    // make sure its field values are appropriately initialized to zero and null.
    //

    ReturnedSD.Length = 0;
    ReturnedSD.SecurityDescriptor = NULL;



    //
    // Call the server ...
    //


    RpcTryExcept{

        PReturnedSD = &ReturnedSD;
        NtStatus =
            SamrQuerySecurityObject(
                (SAMPR_HANDLE)RpcContextHandle,
                SecurityInformation,
                &PReturnedSD
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    (*SecurityDescriptor) = ReturnedSD.SecurityDescriptor;
    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamCloseHandle(
    OUT SAM_HANDLE SamHandle
    )

/*++
Routine Description:

    This API closes a currently opened SAM object.

Arguments:

    SamHandle - Specifies the handle of a previously opened SAM object to
        close.


Return Value:


    STATUS_SUCCESS - The object was successfully closed.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        TmpHandle;

    SampOutputDebugString("SamCloseHandle");

    if (!SampIsValidClientHandle(SamHandle, &TmpHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus = SamrCloseHandle(
                       (SAMPR_HANDLE *)(&TmpHandle)
                       );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        ULONG Code = RpcExceptionCode();
// Don't assert when clients pass in bad handles; also this can happen legally
// in stress scenarios
//        ASSERT(Code != RPC_X_SS_CONTEXT_MISMATCH);
        ASSERT(Code != RPC_S_INVALID_BINDING);
        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if ( !NT_SUCCESS(NtStatus)
      && (0 != TmpHandle)  ) {
        //
        // Make sure in all error cases to remove the client side resources
        // consumed by this handle.
        //
        RpcTryExcept  {
            (void) RpcSsDestroyClientContext(&TmpHandle);
        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // The try/except is for app compat so that bad handles don't bring
            // the process down
            //
            NOTHING;
        } RpcEndExcept;
    }

    SampFreeHandle((SAMP_HANDLE*)&SamHandle);

    return(SampMapCompletionStatus(NtStatus));
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Server object related services                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamConnect(
    IN PUNICODE_STRING ServerName,
    OUT PSAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++
Routine Description:

    Establish a session with a SAM subsystem and subsequently open the
    SamServer object of that subsystem.  The caller must have
    SAM_SERVER_CONNECT access to the SamServer object of the subsystem
    being connected to.

    The handle returned is for use in future calls.


Arguments:

    ServerName - Name of the server to use, or NULL if local.

    ServerHandle - A handle to be used in future requests.  This handle
        represents both the handle to the SamServer object and the RPC
        context handle for the connection to the SAM subsystem.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the SamServer.  These access types are reconciled
        with the Discretionary Access Control list of the SamServer to
        determine whether the accesses will be granted or denied.  The
        access type of SAM_SERVER_CONNECT is always implicitly included
        in this access mask.

    ObjectAttributes - Pointer to the set of object attributes to use for
        this connection.  Only the security Quality Of Service
        information is used and should provide SecurityIdentification
        level of impersonation.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Access was denied.


--*/
{
    NTSTATUS            NtStatus;

    PSAMPR_SERVER_NAME  RServerName;
    PSAMPR_SERVER_NAME  RServerNameWithNull;
    USHORT              RServerNameWithNullLength;
    TlsInfo             *pTlsInfo;
    SAMP_HANDLE         SampServerHandle = NULL;
    SAMPR_HANDLE        RpcContextHandle;

    SAMPR_REVISION_INFO_V1 SamServerInfo;

    RtlZeroMemory(&SamServerInfo, sizeof(SamServerInfo));

    SampOutputDebugString("SamConnect");

    if (IsBadWritePtr(ServerHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    NtStatus = SampCreateNewHandle(NULL,
                                   NULL,
                                   &SampServerHandle);
    if ( !NT_SUCCESS(NtStatus) ) {
        return NtStatus;
    }

    //
    // Hmmm - what to do with security QOS???
    //

    //
    // Call the server, passing either a NULL Server Name pointer, or
    // a pointer to a Unicode Buffer with a Wide Character NULL terminator.
    // Since the input name is contained in a counted Unicode String, there
    // is no NULL terminator necessarily provided, so we must append one.
    //

    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName) &&
        (ServerName->Buffer != NULL) &&
            (ServerName->Length != 0)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        if (RServerNameWithNullLength < sizeof(WCHAR)) {
           return(STATUS_INVALID_PARAMETER_1);
        }
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';
    }

    RpcTryExcept {

        SAMPR_REVISION_INFO InInfo;
        SAMPR_REVISION_INFO OutInfo;
        ULONG               OutInfoVersion;

        RtlZeroMemory(&InInfo, sizeof(InInfo));
        RtlZeroMemory(&OutInfo, sizeof(OutInfo));

        InInfo.V1.Revision = SAM_NETWORK_REVISION_LATEST;

        NtStatus = SamrConnect5(
                       RServerNameWithNull,
                       DesiredAccess,
                       1, // in info version
                       &InInfo,
                       &OutInfoVersion,
                       &OutInfo,
                       &RpcContextHandle);

        if (NT_SUCCESS(NtStatus)) {

            ASSERT(OutInfoVersion == 1);
            ASSERT(sizeof(SamServerInfo) == sizeof(OutInfo.V1));

            RtlCopyMemory(&SamServerInfo, &OutInfo.V1, sizeof(SamServerInfo));

        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {

            NtStatus = SamrConnect4(
                           RServerNameWithNull,
                           (SAMPR_HANDLE *)&RpcContextHandle,
                           SAM_CLIENT_NT5,
                           DesiredAccess
                           );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }

    if (    NT_SUCCESS(NtStatus)
         && (pTlsInfo = (TlsInfo *) TlsGetValue(gTlsIndex)) )
    {
        pTlsInfo->fDstIsW2K = TRUE;
    }

    //
    // If the new connect  call failed because it didn't exist,
    // try the old one.
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {

            NtStatus = SamrConnect2(
                           RServerNameWithNull,
                           (SAMPR_HANDLE *)&RpcContextHandle,
                           DesiredAccess
                           );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {

            NtStatus = SamrConnect(
                           RServerNameWithNull,
                           (SAMPR_HANDLE *)&RpcContextHandle,
                           DesiredAccess
                           );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }

    if (RServerNameWithNull != NULL) {
        MIDL_user_free( RServerNameWithNull );
    }

    //
    // Store the RPC context handle
    //
    if (NT_SUCCESS(NtStatus)) {
        SampServerHandle->ContextHandle = RpcContextHandle;
        SampServerHandle->ServerInfo = SamServerInfo;
    } else {
        SampFreeHandle(&SampServerHandle);
    }
    *ServerHandle = (SAM_HANDLE) SampServerHandle;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamConnect() failed. NtStatus %x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));

    DBG_UNREFERENCED_PARAMETER(ObjectAttributes);

}


NTSTATUS
SamShutdownSamServer(
    IN SAM_HANDLE ServerHandle
    )

/*++
Routine Description:

    This is the wrapper routine for SamShutdownSamServer().

Arguments:

    ServerHandle - Handle from a previous SamConnect() call.

Return Value:


    STATUS_SUCCESS The service completed successfully or the server
        has already shutdown.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    if (!SampIsValidClientHandle(ServerHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        NtStatus = SamrShutdownSamServer(RpcContextHandle);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());


        //
        // If the error status is one that would result from a server
        // not being there, then replace it with success.
        //

        if (NtStatus == RPC_NT_CALL_FAILED) {
            NtStatus = STATUS_SUCCESS;
        }

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamLookupDomainInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN PUNICODE_STRING Name,
    OUT PSID *DomainId
    )

/*++

Routine Description:

    This service returns the SID corresponding to the specified domain.
    The domain is specified by name.


Arguments:

    ServerHandle - Handle from a previous SamConnect() call.

    Name - The name of the domain whose ID is to be looked up.  A
        case-insensitive comparison of this name will be performed for
        the lookup operation.

    DomainId - Receives a pointer to a buffer containing the SID of the
        looked up domain.  This buffer must be freed using
        SamFreeMemory() when no longer needed.


Return Value:


    STATUS_SUCCESS - The service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.  SAM_SERVER_LOOKUP_DOMAIN access is
        needed.

    STATUS_NO_SUCH_DOMAIN - The specified domain does not exist at this
        server.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is currently
        disabled.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamLookupDomainInSamServer");

    if (!SampIsValidClientHandle(ServerHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*DomainId) = 0;

        NtStatus =
            SamrLookupDomainInSamServer(
                (SAMPR_HANDLE)RpcContextHandle,
                (PRPC_UNICODE_STRING)Name,
                (PRPC_SID *)DomainId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamEnumerateDomainsInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID * Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the domains defined in the account database.
    Since there may be more domains than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires SAM_SERVER_ENUMERATE_DOMAINS access to the
    SamServer object.


Parameters:

    ServerHandle - Handle obtained from a previous SamConnect call.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    Buffer - Receives a pointer to the buffer where the information
        is placed.  The information returned is contiguous
        SAM_RID_ENUMERATION data structures.  However, the
        RelativeId field of each of these structures is not valid.
        This buffer must be freed when no longer needed using
        SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have the access required
        to enumerate the domains.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is
        currently disabled.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamEnumerateDomainsInSamServer");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(ServerHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //

    (*Buffer) = NULL;
     LocalBuffer = NULL;

    RpcTryExcept{

        NtStatus = SamrEnumerateDomainsInSamServer(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );

        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Domain object related services                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SamOpenDomain(
    IN SAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PSID DomainId,
    OUT PSAM_HANDLE DomainHandle
    )

/*++
Routine Description:

    This API opens a domain object.  It returns a handle to the newly
    opened domain that must be used for successive operations on the
    domain.  This handle may be closed with the SamCloseHandle API.


Arguments:

    ServerHandle - Handle from a previous SamConnect() call.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the domain.  These access types are reconciled with
        the Discretionary Access Control list of the domain to determine
        whether the accesses will be granted or denied.

    DomainId - The SID assigned to the domain to open.

    DomainHandle - Receives a handle referencing the newly opened domain.
        This handle will be required in successive calls to operate on
        the domain.

Return Value:


    STATUS_SUCCESS - The domain was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is currently
        disabled.

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE        DomainRpcContextHandle, ServerRpcContextHandle;
    SAMP_HANDLE         SampDomainHandle;

    SampOutputDebugString("SamOpenDomain");

    //
    // Parameter check
    //
    if (IsBadWritePtr(DomainHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(ServerHandle, &ServerRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    _try {
        if (!RtlValidSid(DomainId)) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    } _except( EXCEPTION_EXECUTE_HANDLER ) {
        NtStatus = STATUS_INVALID_PARAMETER;
    }
    if ( !NT_SUCCESS(NtStatus) ) {
        return NtStatus;
    }

    //
    // Prepare the returned handle
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)ServerHandle,
                                   DomainId,
                                   &SampDomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*DomainHandle) = 0;

        NtStatus =
            SamrOpenDomain(
                (SAMPR_HANDLE)ServerRpcContextHandle,
                DesiredAccess,
                (PRPC_SID)DomainId,
                (SAMPR_HANDLE *)&DomainRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampDomainHandle->ContextHandle = DomainRpcContextHandle;
    } else {
        SampFreeHandle(&SampDomainHandle);
    }
    *DomainHandle = SampDomainHandle;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamQueryInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PVOID *Buffer
    )

/*++
Routine Description:

    This API retrieves the domain information.  This API requires either
    DOMAIN_READ_PASSWORD_PARAMETERS or DOMAIN_READ_OTHER_PARAMETERS.


Arguments:

    DomainHandle - Handle from a previous SamOpenDomain() call.

    DomainInformationClass - Class of information desired.  The accesses
        required for each class is shown below:

            Info Level                      Required Access Type
            ---------------------------     -------------------------------
            DomainGeneralInformation        DOMAIN_READ_OTHER_PARAMETERS
            DomainPasswordInformation       DOMAIN_READ_PASSWORD_PARAMS
            DomainLogoffInformation         DOMAIN_READ_OTHER_PARAMETERS
            DomainOemInformation            DOMAIN_READ_OTHER_PARAMETERS
            DomainNameInformation           DOMAIN_READ_OTHER_PARAMETERS
            DomainServerRoleInformation     DOMAIN_READ_OTHER_PARAMETERS
            DomainReplicationInformation    DOMAIN_READ_OTHER_PARAMETERS
            DomainModifiedInformation       DOMAIN_READ_OTHER_PARAMETERS
            DomainStateInformation          DOMAIN_READ_OTHER_PARAMETERS
            DomainUasInformation            DOMAIN_READ_OTHER_PARAMETERS
       Added for NT1.0A...
            DomainGeneralInformation2       DOMAIN_READ_OTHER_PARAMETERS
            DomainLockoutInformation        DOMAIN_READ_OTHER_PARAMETERS


    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this buffer
        must be freed using SamFreeMemory().

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamQueryInformationDomain");

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        if (DomainInformationClass <= DomainUasInformation) {
            NtStatus = SamrQueryInformationDomain(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DomainInformationClass,
                           (PSAMPR_DOMAIN_INFO_BUFFER *)Buffer
                           );
        } else {
            NtStatus = SamrQueryInformationDomain2(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DomainInformationClass,
                           (PSAMPR_DOMAIN_INFO_BUFFER *)Buffer
                           );

        }



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        //
        // If the exception indicates the server doesn't have
        // the selected api, that means the server doesn't know
        // about the info level we passed.  Set our completion
        // status appropriately.
        //

        if (RpcExceptionCode() == RPC_S_INVALID_LEVEL         ||
            RpcExceptionCode() == RPC_S_PROCNUM_OUT_OF_RANGE  ||
            RpcExceptionCode() == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
            NtStatus = STATUS_INVALID_INFO_CLASS;
        } else {
            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
        }

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamSetInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PVOID DomainInformation
)

/*++

Routine Description:

    This API sets the domain information to the values passed in the
    buffer.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DomainInformationClass - Class of information desired.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -------------------------       ----------------------------

        DomainPasswordInformation       DOMAIN_WRITE_PASSWORD_PARAMS

        DomainLogoffInformation         DOMAIN_WRITE_OTHER_PARAMETERS

        DomainOemInformation            DOMAIN_WRITE_OTHER_PARAMETERS

        DomainNameInformation           (not valid for set operations.)

        DomainServerRoleInformation     DOMAIN_ADMINISTER_SERVER

        DomainReplicationInformation    DOMAIN_ADMINISTER_SERVER

        DomainModifiedInformation       (not valid for set operations.)

        DomainStateInformation          DOMAIN_ADMINISTER_SERVER

        DomainUasInformation            DOMAIN_WRITE_OTHER_PARAMETERS

    DomainInformation - Buffer where the domain information can be
        found.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be disabled before role
        changes can be made.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS            NtStatus;

    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetInformationDomain");


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        NtStatus =
            SamrSetInformationDomain(
                (SAMPR_HANDLE)RpcContextHandle,
                DomainInformationClass,
                (PSAMPR_DOMAIN_INFO_BUFFER)DomainInformation
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamCreateGroupInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE GroupHandle,
    OUT PULONG RelativeId
    )
/*++

Routine Description:

    This API creates a new group in the account database.  Initially,
    this group does not contain any users.  Note that creating a group
    is a protected operation, and requires the DOMAIN_CREATE_GROUP
    access type.

    This call returns a handle to the newly created group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.

    A newly created group will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the group object manipulation services.

        Name - The name of the group will be as specified in the
               creation API.

        Attributes - The following attributes will be set:

                                Mandatory
                                EnabledByDefault

        MemberCount - Zero.  Initially the group has no members.

        RelativeId - will be a uniquelly allocated ID.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - Points to the name of the new account.  A
        case-insensitive comparison must not find a group, alias or user
        with this name already defined.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.

    GroupHandle - Receives a handle referencing the newly created
        group.  This handle will be required in successive calls to
        operate on the group.

    RelativeId - Receives the relative ID of the newly created group
        account.  The SID of the new group account is this relative
        ID value prefixed with the domain's SID value.

Return Values:

    STATUS_SUCCESS - The group was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before groups
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create group accounts.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, GroupRpcContextHandle;
    SAMP_HANDLE         SampGroupHandle;

    SampOutputDebugString("SamCreateGroupInDomain");


    if (IsBadWritePtr(GroupHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampGroupHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    (*GroupHandle) = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateGroupInDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                DesiredAccess,
                (SAMPR_HANDLE *)&GroupRpcContextHandle,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampGroupHandle->ContextHandle = GroupRpcContextHandle;
    } else {
        SampFreeHandle(&SampGroupHandle);
    }
    *GroupHandle = SampGroupHandle;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamEnumerateGroupsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN PVOID * Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the groups defined in the account database.
    Since there may be more groups than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ACCOUNTS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamEnumerateGroupsInDomain");



    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    (*Buffer) = NULL;
     LocalBuffer = NULL;


    RpcTryExcept{

        NtStatus = SamrEnumerateGroupsInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );


        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}


NTSTATUS
SamCreateUser2InDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG GrantedAccess,
    OUT PULONG RelativeId
)

/*++

Routine Description:

    This API adds a new user to the account database.  The account is
    created in a disabled state.  Default information is assigned to all
    fields except the account name.  A password must be provided before
    the account may be enabled, unless the PasswordNotRequired control
    field is set.

    This api may be used in either of two ways:

        1) An administrative utility may use this api to create
           any type of user account.  In this case, the DomainHandle
           is expected to be open for DOMAIN_CREATE_USER access.

        2) A non-administrative user may use this api to create
           a machine account.  In this case, the caller is expected
           to have the SE_CREATE_MACHINE_ACCOUNT_PRIV privilege
           and the DomainHandle is expected to be open for DOMAIN_LOOKUP
           access.


    For the normal administrative model ( #1 above), the creator will
    be assigned as the owner of the created user account.  Furthermore,
    the new account will be give USER_WRITE access to itself.

    For the special machine-account creation model (#2 above), the
    "Administrators" will be assigned as the owner of the account.
    Furthermore, the new account will be given NO access to itself.
    Instead, the creator of the account will be give USER_WRITE and
    DELETE access to the account.


    This call returns a handle to the newly created user that may be
    used for successive operations on the user.  This handle may be
    closed with the SamCloseHandle() API.  If a machine account is
    being created using model #2 above, then this handle will have
    only USER_WRITE and DELETE access.  Otherwise, it will be open
    for USER_ALL_ACCESS.


    A newly created user will automatically be made a member of the
    DOMAIN_USERS group.

    A newly created user will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the user object manipulation services.

        UserName - the name of the account will be as specified in the
             creation API.

        FullName - will be null.

        UserComment - will be null.

        Parameters - will be null.

        CountryCode - will be zero.

        UserId - will be a uniquelly allocated ID.

        PrimaryGroupId - Will be DOMAIN_USERS.

        PasswordLastSet - will be the time the account was created.

        HomeDirectory - will be null.

        HomeDirectoryDrive - will be null.

        UserAccountControl - will have the following flags set:

              UserAccountDisable,
              UserPasswordNotRequired,
              and the passed account type.


        ScriptPath - will be null.

        WorkStations - will be null.

        CaseInsensitiveDbcs - will be null.

        CaseSensitiveUnicode - will be null.

        LastLogon - will be zero delta time.

        LastLogoff - will be zero delta time

        AccountExpires - will be very far into the future.

        BadPasswordCount - will be negative 1 (-1).

        LastBadPasswordTime - will be SampHasNeverTime ( [High,Low] = [0,0] ).

        LogonCount - will be negative 1 (-1).

        AdminCount - will be zero.

        AdminComment - will be null.

        Password - will be "".


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find a group or user with this name already defined.

    AccountType - Indicates what type of account is being created.
        Exactly one account type must be provided:

              USER_INTERDOMAIN_TRUST_ACCOUNT
              USER_WORKSTATION_TRUST_ACCOUNT
              USER_SERVER_TRUST_ACCOUNT
              USER_TEMP_DUPLICATE_ACCOUNT
              USER_NORMAL_ACCOUNT
              USER_MACHINE_ACCOUNT_MASK


    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.

    UserHandle - Receives a handle referencing the newly created
        user.  This handle will be required in successive calls to
        operate on the user.

    GrantedAccess - Receives the accesses actually granted to via
        the UserHandle.  When creating an account on a down-level
        server, this value may be unattainable.  In this case, it
        will be returned as zero (0).

    RelativeId - Receives the relative ID of the newly created user
        account.  The SID of the new user account is this relative ID
        value prefixed with the domain's SID value.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before users
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create user accounts.


--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;


    USER_CONTROL_INFORMATION
        UserControlInfoBuffer;

    SAMP_HANDLE
        SampUserHandle;

    SAMPR_HANDLE
        DomainRpcContextHandle,
        UserRpcContextHandle;


    SampOutputDebugString("SamCreateUser2InDomain");


    if (IsBadWritePtr(UserHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampUserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    (*UserHandle) = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateUser2InDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                AccountType,
                DesiredAccess,
                (SAMPR_HANDLE *)&UserRpcContextHandle,
                GrantedAccess,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        if (RpcExceptionCode() == RPC_S_PROCNUM_OUT_OF_RANGE  ||
            RpcExceptionCode() == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
            NtStatus = RPC_NT_PROCNUM_OUT_OF_RANGE;
        } else {
            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
        }

    } RpcEndExcept;



    //
    // If the server doesn't support the new api, then
    // do the equivalent work with the old apis.
    //

    if (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE) {

        DesiredAccess = DesiredAccess | USER_WRITE_ACCOUNT;
        NtStatus =
            SamCreateUserInDomain(
                                   DomainRpcContextHandle,
                                   AccountName,
                                   DesiredAccess,
                                   &UserRpcContextHandle,
                                   RelativeId );

        if (NT_SUCCESS(NtStatus)) {


            SampUserHandle->ContextHandle = UserRpcContextHandle;

            //
            // Set the AccountType (unless it is normal)
            //

            if (~(AccountType & USER_NORMAL_ACCOUNT)) {

                UserControlInfoBuffer.UserAccountControl =
                        AccountType             |
                        USER_ACCOUNT_DISABLED   |
                        USER_PASSWORD_NOT_REQUIRED;

                NtStatus = SamSetInformationUser(
                               (SAM_HANDLE)SampUserHandle,
                               UserControlInformation,
                               &UserControlInfoBuffer
                               );
                if (!NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamDeleteUser( (SAM_HANDLE)SampUserHandle );
                    if (NT_SUCCESS(IgnoreStatus)) {
                        SampUserHandle = NULL;
                    }
                }

                //
                // We can't be positive what accesses have been
                // granted, so don't try lying.
                //

                (*GrantedAccess) = 0;

            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {
        SampUserHandle->ContextHandle = UserRpcContextHandle;
    } else {
        if (SampUserHandle) {
            SampFreeHandle(&SampUserHandle);
        }
    }
    *UserHandle = (SAM_HANDLE) SampUserHandle;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamCreateUser2InDomain() failed. NtStatus 0x%x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamCreateUserInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG RelativeId
)

/*++

Routine Description:

    This API adds a new user to the account database.  The account is
    created in a disabled state.  Default information is assigned to all
    fields except the account name.  A password must be provided before
    the account may be enabled, unless the PasswordNotRequired control
    field is set.

    Note that DOMAIN_CREATE_USER access type is needed by this API.
    Also, the caller of this API becomes the owner of the user object
    upon creation.

    This call returns a handle to the newly created user that may be
    used for successive operations on the user.  This handle may be
    closed with the SamCloseHandle() API.

    A newly created user will automatically be made a member of the
    DOMAIN_USERS group.

    A newly created user will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the user object manipulation services.

        UserName - the name of the account will be as specified in the
             creation API.

        FullName - will be null.

        UserComment - will be null.

        Parameters - will be null.

        CountryCode - will be zero.

        UserId - will be a uniquelly allocated ID.

        PrimaryGroupId - Will be DOMAIN_USERS.

        PasswordLastSet - will be the time the account was created.

        HomeDirectory - will be null.

        HomeDirectoryDrive - will be null.

        UserAccountControl - will have the following flags set:

              USER_ACCOUNT_DISABLED,
              USER_NORMAL_ACCOUNT,
              USER_PASSWORD_NOT_REQUIRED

        ScriptPath - will be null.

        WorkStations - will be null.

        CaseInsensitiveDbcs - will be null.

        CaseSensitiveUnicode - will be null.

        LastLogon - will be zero.

        LastLogoff - will be zero.

        AccountExpires - will be very far into the future.

        BadPasswordCount - will be negative 1 (-1).

        LogonCount - will be negative 1 (-1).

        AdminComment - will be null.

        Password - will contain any value, but is not used because the
             USER_PASSWORD_NOT_REQUIRED control flag is set.  If a password
             is to be required, then this field must be set to a
             specific value and the USER_PASSWORD_NOT_REQUIRED flag must be
             cleared.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - The name to be assigned to the new account.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.

    UserHandle - Receives a handle referencing the newly created
        user.  This handle will be required in successive calls to
        operate on the user.

    RelativeId - Receives the relative ID of the newly created user
        account.  The SID of the new user account is this relative ID
        value prefixed with the domain's SID value.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before users
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create user accounts.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, UserRpcContextHandle;
    SAMP_HANDLE         SampUserHandle;


    SampOutputDebugString("SamCreateUserInDomain");

    if (IsBadWritePtr(UserHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampUserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    UserRpcContextHandle = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateUserInDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                DesiredAccess,
                (SAMPR_HANDLE *)&UserRpcContextHandle,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampUserHandle->ContextHandle = UserRpcContextHandle;
    } else {
        SampFreeHandle(&SampUserHandle);
    }
    *UserHandle = SampUserHandle;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamCreateUserInDomain() failed. NtStatus 0x%x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));
}




NTSTATUS
SamEnumerateUsersInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN ULONG UserAccountControl,
    OUT PVOID * Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the users defined in the account database.  Since
    there may be more users than can fit into a buffer, the caller is
    provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ACCOUNTS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    UserAccountControl - Provides enumeration filtering information.  Any
        characteristics specified here will cause that type of User account
        to be included in the enumeration process.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;

    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamEnumerateUsersInDomain");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    (*Buffer) = NULL;
    LocalBuffer = NULL;


    RpcTryExcept{

        NtStatus = SamrEnumerateUsersInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       UserAccountControl,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );


        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamCreateAliasInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE AliasHandle,
    OUT PULONG RelativeId
)

/*++

Routine Description:

    This API adds a new alias to the account database.  Initially, this
    alias does not contain any members.

    This call returns a handle to the newly created account that may be
    used for successive operations on the object.  This handle may be
    closed with the SamCloseHandle API.

    A newly created group will have the following initial field value
    settings.  If another value is desired, it must be explicitly changed
    using the Alias object manipulation services.

        Name - the name of the account will be as specified in the creation
            API.

        MemberCount - Zero.  Initially the alias has no members.

        RelativeId - will be a uniquelly allocated ID.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.  The handle must be open for DOMAIN_CREATE_ALIAS
        access.

    AccountName - The name of the alias to be added.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the alias.

    AliasHandle - Receives a handle referencing the newly created
        alias.  This handle will be required in successive calls to
        operate on the alias.

    RelativeId - Receives the relative ID of the newly created alias.
        The SID of the new alias is this relative ID value prefixed with
        the domain's SID value.


Return Values:

    STATUS_SUCCESS - The account was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before aliases
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create aliases.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, AliasRpcContextHandle;
    SAMP_HANDLE         SampAliasHandle;

    SampOutputDebugString("SamCreateAliasInDomain");

    if (IsBadWritePtr(AliasHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampAliasHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }


    //
    // Call the server ...
    //


    (*AliasHandle) = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateAliasInDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                DesiredAccess,
                (SAMPR_HANDLE *)&AliasRpcContextHandle,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    if (NT_SUCCESS(NtStatus)) {
        SampAliasHandle->ContextHandle = AliasRpcContextHandle;
    } else {
        SampFreeHandle(&SampAliasHandle);
    }
    *AliasHandle = (SAM_HANDLE)SampAliasHandle;


    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamEnumerateAliasesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the aliases defined in the account database.  Since
    there may be more aliases than can fit into a buffer, the caller is
    provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ACCOUNTS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;
    SAMPR_HANDLE        RpcContextHandle;


    SampOutputDebugString("SamEnumerateAliasesInDomain");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    (*Buffer) = NULL;
    LocalBuffer = NULL;


    RpcTryExcept{

        NtStatus = SamrEnumerateAliasesInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );


        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamGetAliasMembership(
    IN SAM_HANDLE DomainHandle,
    IN ULONG PassedCount,
    IN PSID *Sids,
    OUT PULONG MembershipCount,
    OUT PULONG *Aliases
)

/*++

Routine Description:

    This API searches the set of aliases in the specified domain to see
    which aliases, if any, the passed SIDs are members of.  Any aliases
    that any of the SIDs are found to be members of are returned.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    PassedCount - Specifies the number of Sids being passed.

    Sids - Pointer to an array of Count pointers to Sids whose alias
        memberships are to be looked up.

    MembershipCount - Receives the number of aliases that are being
        returned via the Aliases parameter.

    Aliases - Receives a pointer to an array of SIDs.  This is the set
        of aliases the passed SIDs were found to be members of.  If
        MembershipCount is returned as zero, then a null value will be
        returned here.

        When this information is no longer needed, it must be released
        by passing the returned pointer to SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    SAMPR_PSID_ARRAY    Accounts;
    SAMPR_ULONG_ARRAY   Membership;

    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamAliasMembership");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(Sids) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(MembershipCount) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Aliases) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    Membership.Element = NULL;

    RpcTryExcept{

        Accounts.Count = PassedCount;
        Accounts.Sids = (PSAMPR_SID_INFORMATION)Sids;

        NtStatus = SamrGetAliasMembership(
                       (SAMPR_HANDLE)RpcContextHandle,
                       &Accounts,
                       &Membership
                       );

        if (NT_SUCCESS(NtStatus)) {
            (*MembershipCount) = Membership.Count;
            if ((Membership.Count == 0) && (NULL != Membership.Element))
            {
                MIDL_user_free(Membership.Element);
                Membership.Element = NULL;
            }
            (*Aliases)         = Membership.Element;
        } else {

            //
            // Deallocate any returned buffers on error
            //

            if (Membership.Element != NULL) {
                MIDL_user_free(Membership.Element);
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}





NTSTATUS
SamLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PULONG *RelativeIds,
    OUT PSID_NAME_USE *Use
)

/*++

Routine Description:

    This API attempts to find relative IDs corresponding to name
    strings.  If a name can not be mapped to a relative ID, a zero is
    placed in the corresponding relative ID array entry, and translation
    continues.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Number of names to translate.

    Names - Pointer to an array of Count UNICODE_STRINGs that contain
        the names to map to relative IDs.  Case-insensitive
        comparisons of these names will be performed for the lookup
        operation.

    RelativeIds - Receives a pointer to an array of Count Relative IDs
        that have been filled in.  The relative ID of the nth name will
        be the nth entry in this array.  Any names that could not be
        translated will have a zero relative ID.  This buffer must be
        freed when no longer needed using SamFreeMemory().

    Use - Recieves a pointer to an array of Count SID_NAME_USE
        entries that have been filled in with what significance each
        name has.  The nth entry in this array indicates the meaning
        of the nth name passed.  This buffer must be freed when no longer
        needed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.


--*/
{


    NTSTATUS
        ReturnStatus = STATUS_SUCCESS,
        NtStatus = STATUS_SUCCESS;

    LIST_ENTRY
        CallHead;

    PSAMP_NAME_LOOKUP_CALL
        Next;

    PSID_NAME_USE
        UseBuffer;

    PULONG
        RidBuffer;

    ULONG
        Calls,
        CallLength,
        i;

    BOOLEAN
        NoneMapped = TRUE,
        SomeNotMapped = FALSE;

    SAMPR_HANDLE
        RpcContextHandle;

    SampOutputDebugString("SamLookupNamesInDomain");


    if ( (Count == 0)   ||  (Names == NULL)    ) {
        return(STATUS_INVALID_PARAMETER);
    }


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Default error return
    //

    (*Use)         = UseBuffer = NULL;
    (*RelativeIds) = RidBuffer = NULL;


    //
    // Set up the call structures list
    //

    InitializeListHead( &CallHead );
    Calls = 0;


    //
    // By default we will return NONE_MAPPED.
    // This will get superseded by either STATUS_SUCCESS
    // or STATUS_SOME_NOT_MAPPED.
    //

    //
    // Now build up and make each call
    //

    i = 0;
    while ( i < Count ) {

        //
        // Make sure the next entry isn't too long.
        // That would put us in an infinite loop.
        //

        if (Names[i].Length > SAM_MAXIMUM_LOOKUP_LENGTH) {
            ReturnStatus = STATUS_INVALID_PARAMETER;
            goto SampNameLookupFreeAndReturn;
        }

        //
        // Get the next call structure
        //

        Next = (PSAMP_NAME_LOOKUP_CALL)MIDL_user_allocate( sizeof(SAMP_NAME_LOOKUP_CALL) );

        if (Next == NULL) {
            ReturnStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto SampNameLookupFreeAndReturn;
        }

        //
        // Fill in the call structure.
        // It takes a little to figure out how many entries to send in
        // this call.  It is limited by both Count (sam_MAXIMUM_LOOKUP_COUNT)
        // and by size (SAM_MAXIMUM_LOOKUP_LENGTH).
        //

        Next->Count             = 0;
        Next->StartIndex        = i;
        Next->RidBuffer.Element = NULL;
        Next->UseBuffer.Element = NULL;

        CallLength = 0;
        for ( i=i;
              ( (i < Count)                                             &&
                (CallLength+Names[i].Length < SAM_MAXIMUM_LOOKUP_LENGTH) &&
                (Next->Count < SAM_MAXIMUM_LOOKUP_COUNT)
              );
              i++ ) {

            //
            // Add in the next length and increment the number of entries
            // being processed by this call.
            //

            CallLength += Names[i].Length;
            Next->Count ++;

        }



        //
        // Add this call structure to the list of call structures
        //

        Calls ++;
        InsertTailList( &CallHead, &Next->Link );


        //
        // Now make the call
        //

        RpcTryExcept{

            NtStatus = SamrLookupNamesInDomain(
                                 (SAMPR_HANDLE)RpcContextHandle,
                                 Next->Count,
                                 (PRPC_UNICODE_STRING)(&Names[Next->StartIndex]),
                                 &Next->RidBuffer,
                                 &Next->UseBuffer
                                 );


        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;


        //
        // Keep track of what our completion status should be.
        //

        if (!NT_SUCCESS(NtStatus)    &&
            NtStatus != STATUS_NONE_MAPPED) {
                ReturnStatus = NtStatus;      // Unexpected error
                goto SampNameLookupFreeAndReturn;
        }

        if (NT_SUCCESS(NtStatus)) {
            NoneMapped = FALSE;
            if (NtStatus == STATUS_SOME_NOT_MAPPED) {
                SomeNotMapped = TRUE;
            }
        }
    }


    //
    // Set our return status...
    //

    if (NoneMapped) {
        ASSERT(SomeNotMapped == FALSE);
        ReturnStatus = STATUS_NONE_MAPPED;
    } else  if (SomeNotMapped) {
        ReturnStatus = STATUS_SOME_NOT_MAPPED;
    } else {
        ReturnStatus = STATUS_SUCCESS;
    }




    //
    // At this point we have (potentially) a lot of call structures.
    // The RidBuffer and UseBuffer elements of each call structure
    // is allocated and returned by the RPC call and looks
    // like:
    //
    //              RidBuffer
    //              +-------------+
    //              |   Count     |
    //              |-------------|    +-------+ *
    //              | Element  ---|--->| Rid-0 |  |    /
    //              +-------------+    |-------|  |   / Only this part
    //                                 |  ...  |   > <  is allocated by
    //                                 |-------|  |   \ the rpc call.
    //                                 | Rid-N |  |    \
    //                                 +-------+ *
    //
    //   If only one RPC call was made, we can return this information
    //   directly.  Otherwise, we need to copy the information from
    //   all the calls into a single large buffer and return that buffer
    //   (freeing all the individual call buffers).
    //
    //   The user is responsible for freeing whichever buffer we do
    //   return.
    //

    ASSERT(Calls != 0);  // Error go around this path, success always has calls


    //
    // Optimize for a single call
    //

    if (Calls == 1) {
        (*Use) = (PSID_NAME_USE)
                  (((PSAMP_NAME_LOOKUP_CALL)(CallHead.Flink))->
                     UseBuffer.Element);
        (*RelativeIds) = ((PSAMP_NAME_LOOKUP_CALL)(CallHead.Flink))->
                            RidBuffer.Element;
        MIDL_user_free( CallHead.Flink ); // Free the call structure
        return(ReturnStatus);
    }


    //
    // More than one call.
    // Allocate return buffers large enough to copy all the information into.
    //

    RidBuffer = MIDL_user_allocate( sizeof(ULONG) * Count );
    if (RidBuffer == NULL) {
        ReturnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto SampNameLookupFreeAndReturn;
    }

    UseBuffer = MIDL_user_allocate( sizeof(SID_NAME_USE) * Count );
    if (UseBuffer == NULL) {
        MIDL_user_free( RidBuffer );
        RidBuffer = NULL;
        ReturnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto SampNameLookupFreeAndReturn;
    }




SampNameLookupFreeAndReturn:

    //
    // Walk the list of calls.
    // For each call:
    //
    //      If we have a return buffer, copy the results into it.
    //      Free the call buffers.
    //      Free the call structure itself.
    //
    // Completion status has already been set appropriatly in ReturnStatus.
    //

    Next = (PSAMP_NAME_LOOKUP_CALL)RemoveHeadList( &CallHead );
    while (Next != (PSAMP_NAME_LOOKUP_CALL)&CallHead) {

        //
        // Copy RID information and then free the call buffer
        //

        if (RidBuffer != NULL) {
            RtlMoveMemory(
                &RidBuffer[ Next->StartIndex ],     // Destination
                &Next->RidBuffer.Element[0],        // Source
                Next->Count * sizeof(ULONG)         // Length
                );
        }

        if (Next->RidBuffer.Element != NULL) {
            MIDL_user_free( Next->RidBuffer.Element );
        }


        //
        // Copy USE information and then free the call buffer
        //

        if (UseBuffer != NULL) {
            RtlMoveMemory(
                &UseBuffer[ Next->StartIndex ],     // Destination
                &Next->UseBuffer.Element[0],        // Source
                Next->Count * sizeof(SID_NAME_USE)  // Length
                );
        }

        if (Next->UseBuffer.Element != NULL) {
            MIDL_user_free( Next->UseBuffer.Element );
        }

        //
        // Free the call structure itself
        //

        MIDL_user_free( Next );

        Next = (PSAMP_NAME_LOOKUP_CALL)RemoveHeadList( &CallHead );
    }  // end-while



    //
    // For better or worse, we're all done
    //

    (*Use)         = UseBuffer;
    (*RelativeIds) = RidBuffer;


    return(SampMapCompletionStatus(ReturnStatus));
}

NTSTATUS
SamLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use OPTIONAL
    )

/*++

Routine Description:

    This API maps a number of relative IDs to their corresponding names.
    The use of the name (domain, group, alias, user, or unknown) is also
    returned.

    The API stores the actual names in Buffer, then creates an array of
    UNICODE_STRINGs in the Names OUT parameter.  If a relative ID can
    not be mapped, a NULL value is placed in the slot for the
    UNICODE_STRING, and STATUS_SOME_NOT_MAPPED is returned.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Provides the number of relative IDs to translate.

    RelativeIds - Array of Count relative IDs to be mapped.

    Names - Receives a pointer to an array of Count UNICODE_STRINGs that
        have been filled in.  The nth pointer within this array will
        correspond the nth relative id passed .  Each name string buffer
        will be in a separately allocated block of memory.  Any entry is
        not successfully translated will have a NULL name buffer pointer
        returned.  This Names buffer must be freed using SamFreeMemory()
        when no longer needed.

    Use - Optionally, receives a pointer to an array of Count SID_NAME_USE
        entries that have been filled in with what significance each
        name has.  The nth entry in this array indicates the meaning
        of the nth name passed.  This buffer must be freed when no longer
        needed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.
--*/

{
    NTSTATUS                        NtStatus;
    ULONG                           SubRequest, SubRequests;
    ULONG                           TotalCountToDate;
    ULONG                           Index, UsedLength, Length, NamesLength;
    ULONG                           UsesLength, LastSubRequestCount;
    PULONG_PTR                      UstringStructDisps = NULL;
    PULONG                          Counts = NULL;
    PULONG                          RidIndices = NULL;
    NTSTATUS                        *SubRequestStatus = NULL;
    PUNICODE_STRING                 *SubRequestNames = NULL;
    PSID_NAME_USE                   *SubRequestUses = NULL;
    PUNICODE_STRING                 OutputNames = NULL;
    PSID_NAME_USE                   OutputUses = NULL;
    PUCHAR                          Destination = NULL, Source = NULL;
    PUNICODE_STRING                 DestUstring = NULL;
    ULONG                           SomeNotMappedStatusCount = 0;
    ULONG                           NoneMappedStatusCount = 0;

    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamLookupIdsInDomain");

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // If the Count for this request does not exceed the maximum limit that
    // can be looked up in a single call, just call the Sub Request version
    // of the routine.
    //


    if (Count <= SAM_MAXIMUM_LOOKUP_COUNT) {

        NtStatus = SampLookupIdsInDomain(
                       DomainHandle,
                       Count,
                       RelativeIds,
                       Names,
                       Use
                       );

        return(NtStatus);
    }

    //
    // Break down larger requests into smaller chunks
    //

    SubRequests = Count / SAMP_MAXIMUM_SUB_LOOKUP_COUNT;
    LastSubRequestCount = Count % SAMP_MAXIMUM_SUB_LOOKUP_COUNT;

    if (LastSubRequestCount > 0) {

        SubRequests++;
    }

    //
    // Allocate memory for array of starting Rid Indices, Rid Counts and
    // Unicode String block offsets for each SubRequest.
    //

    NtStatus = STATUS_NO_MEMORY;

    RidIndices = MIDL_user_allocate( SubRequests * sizeof(ULONG) );

    if (RidIndices == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( RidIndices, SubRequests * sizeof(ULONG) );

    Counts = MIDL_user_allocate( SubRequests * sizeof(ULONG) );

    if (Counts == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( Counts, SubRequests * sizeof(ULONG) );

    SubRequestStatus = MIDL_user_allocate( SubRequests * sizeof(NTSTATUS) );

    if (SubRequestStatus == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( SubRequestStatus, SubRequests * sizeof(NTSTATUS) );

    SubRequestNames = MIDL_user_allocate( SubRequests * sizeof(PUNICODE_STRING) );

    if (SubRequestNames == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( SubRequestNames, SubRequests * sizeof(PUNICODE_STRING) );

    SubRequestUses = MIDL_user_allocate( SubRequests * sizeof(PSID_NAME_USE) );

    if (SubRequestUses == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( SubRequestUses, SubRequests * sizeof(PSID_NAME_USE) );

    UstringStructDisps = MIDL_user_allocate( SubRequests * sizeof(ULONG_PTR) );

    if (UstringStructDisps == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( UstringStructDisps, SubRequests * sizeof(ULONG_PTR) );

    NtStatus = STATUS_SUCCESS;

    TotalCountToDate = 0;

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        RidIndices[SubRequest] = TotalCountToDate;

        if ((Count - TotalCountToDate) > SAMP_MAXIMUM_SUB_LOOKUP_COUNT) {

            Counts[SubRequest] = SAMP_MAXIMUM_SUB_LOOKUP_COUNT;

        } else {

            Counts[SubRequest] = Count - TotalCountToDate;
        }

        TotalCountToDate += Counts[SubRequest];

        NtStatus = SampLookupIdsInDomain(
                       DomainHandle,
                       Counts[SubRequest],
                       &RelativeIds[RidIndices[SubRequest]],
                       &SubRequestNames[SubRequest],
                       &SubRequestUses[SubRequest]
                       );

        //
        // SubRequestStatus[] is an array to keep the return
        // status of each Sub Request when calling SampLookupIdsInDomain.
        // The reason why we will need it is that
        // if SampLookupIdsInDomain returns STATUS_NONE_MAPPED,
        // no memory will be allocated for SubRequestNames[SubRequest] and
        // SubRequestUses[SubRequest]
        //

        SubRequestStatus[SubRequest] = NtStatus;

        //
        // We keep a tally of the number of times STATUS_SOME_NOT_MAPPED
        // and STATUS_NONE_MAPPED were returned.  This is so that we
        // can return the appropriate status at the end based on the
        // global picture.  We continue lookups after either status code
        // is encountered.
        //

        if (NtStatus == STATUS_SOME_NOT_MAPPED) {

            SomeNotMappedStatusCount++;

        } else if (NtStatus == STATUS_NONE_MAPPED) {

            NoneMappedStatusCount++;
            NtStatus = STATUS_SUCCESS;

        }

        if (!NT_SUCCESS(NtStatus)) {

            break;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {

        goto LookupIdsInDomainError;
    }

    //
    // Now allocate a single buffer for the Names
    //

    NamesLength = Count * sizeof(UNICODE_STRING);

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (SubRequestStatus[SubRequest] == STATUS_NONE_MAPPED) {
            continue;
        }

        for (Index = 0; Index < Counts[SubRequest]; Index++) {

            NamesLength += (SubRequestNames[SubRequest] + Index)->MaximumLength;
        }
    }

    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    OutputNames = MIDL_user_allocate( NamesLength );

    if (OutputNames == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory(OutputNames, NamesLength);


    NtStatus = STATUS_SUCCESS;

    //
    // Now copy in the Unicode String Structures for the Names returned from
    // each subrequest.  We will later overwrite the Buffer fields in them
    // when we assign space and move in each Unicode String.
    //

    Destination = (PUCHAR) OutputNames;
    UsedLength = 0;

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (SubRequestStatus[SubRequest] == STATUS_NONE_MAPPED) {
            continue;
        }

        Source = (PUCHAR) SubRequestNames[SubRequest];
        Length = Counts[SubRequest] * sizeof(UNICODE_STRING);
        UstringStructDisps[SubRequest] = (ULONG_PTR)(Destination - Source);
        RtlMoveMemory( Destination, Source, Length );
        Destination += Length;
        UsedLength += Length;
    }

    //
    // Now copy in the Unicode Strings themselves.  These are appended to
    // the array of Unicode String structures.  As we go, update the
    // Unicode string buffer pointers to point to the copied version
    // of each string.
    //

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (STATUS_NONE_MAPPED == SubRequestStatus[SubRequest]) {
            continue;
        }

        for (Index = 0; Index < Counts[SubRequest]; Index++) {

            Source = (PUCHAR)(SubRequestNames[SubRequest] + Index)->Buffer;
            Length = (ULONG)(SubRequestNames[SubRequest] + Index)->MaximumLength;

            //
            // It is possible that a returned Unicode String has 0 length
            // because an Id was not mapped.  In this case, skip to the next
            // one.
            //

            if (Length == 0) {

                continue;
            }

            DestUstring = (PUNICODE_STRING)
               (((PUCHAR)(SubRequestNames[SubRequest] + Index)) +
                  UstringStructDisps[SubRequest]);

            DestUstring->Buffer = (PWSTR) Destination;

            ASSERT(UsedLength + Length <= NamesLength);

            RtlMoveMemory( Destination, Source, Length );
            Destination += Length;
            UsedLength += Length;
            continue;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {

        goto LookupIdsInDomainError;
    }

    //
    // Now allocate a single buffer for the Uses
    //

    UsesLength = Count * sizeof(SID_NAME_USE);

    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    OutputUses = MIDL_user_allocate( UsesLength );

    if (OutputUses == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( OutputUses, UsesLength );

    NtStatus = STATUS_SUCCESS;

    //
    // Now copy in the SID_NAME_USE Structures for the Uses returned from
    // each subrequest.
    //

    Destination = (PUCHAR) OutputUses;
    UsedLength = 0;

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (STATUS_NONE_MAPPED == SubRequestStatus[SubRequest]) {
            continue;
        }

        Source = (PUCHAR) SubRequestUses[SubRequest];
        Length = Counts[SubRequest] * sizeof(SID_NAME_USE);
        RtlMoveMemory( Destination, Source, Length );
        Destination += Length;
        UsedLength += Length;
    }

    if (!NT_SUCCESS(NtStatus)) {

        goto LookupIdsInDomainError;
    }

    *Names = OutputNames;

    if (ARGUMENT_PRESENT(Use))
    {
        *Use = OutputUses;
    }

    //
    // Determine the final status to return.  This is the normal NtStatus code
    // except that if NtStatus is a success status and none/not all Ids were
    // mapped, NtStatus will be set to either STATUS_SOME_NOT_MAPPED or
    // STATUS_NONE_MAPPED as appropriate.  If STATUS_SOME_NOT_MAPPED was
    // returned on at least one call, return that status.  If STATUS_NONE_MAPPED
    // was returned on all calls, return that status.
    //

    if (NT_SUCCESS(NtStatus)) {

        if (SomeNotMappedStatusCount > 0) {

            NtStatus = STATUS_SOME_NOT_MAPPED;

        } else if (NoneMappedStatusCount == SubRequests) {

            NtStatus = STATUS_NONE_MAPPED;

        } else if (NoneMappedStatusCount > 0) {

            //
            // One or more calls returned STATUS_NONE_MAPPED but not all.
            // So at least one Id was mapped, but not all ids.
            //

            NtStatus = STATUS_SOME_NOT_MAPPED;
        }
    }

LookupIdsInDomainFinish:

    //
    // If necessary, free the buffer containing the starting Rid Indices for
    // each Sub Request.
    //

    if (RidIndices != NULL) {

        MIDL_user_free(RidIndices);
        RidIndices = NULL;
    }

    //
    // If necessary, free the buffer containing the Rid Counts for
    // each Sub Request.
    //

    if (Counts != NULL) {

        MIDL_user_free(Counts);
        Counts = NULL;
    }

    //
    // if necessary, free the buffer containing the NtStatus for
    // each Sub Request.
    //

    if (SubRequestStatus != NULL) {

        MIDL_user_free(SubRequestStatus);
        SubRequestStatus = NULL;
    }

    //
    // If necessary, free the buffer containing the offsets from the
    // source and destination Unicode String structures.
    //

    if (UstringStructDisps != NULL) {

        MIDL_user_free(UstringStructDisps);
        UstringStructDisps = NULL;
    }

    //
    // If necessary, free the SubRequestNames output returned for each
    // Sub Request.
    //

    if (SubRequestNames != NULL) {

        for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

            if (SubRequestNames[SubRequest] != NULL) {

                MIDL_user_free(SubRequestNames[SubRequest]);
                SubRequestNames[SubRequest] = NULL;
            }
        }

        MIDL_user_free(SubRequestNames);
        SubRequestNames = NULL;
    }

    //
    // If necessary, free the SubRequestUses output returned for each
    // Sub Request.
    //

    if (SubRequestUses != NULL) {

        for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

            if (SubRequestUses[SubRequest] != NULL) {

                MIDL_user_free(SubRequestUses[SubRequest]);
                SubRequestUses[SubRequest] = NULL;
            }
        }

        MIDL_user_free(SubRequestUses);
        SubRequestUses = NULL;
    }

    return(NtStatus);

LookupIdsInDomainError:

    //
    // If necessary, free the buffers we would hande returned for
    // Names and Use.
    //

    if (OutputNames != NULL) {

        MIDL_user_free(OutputNames);
        OutputNames = NULL;
    }

    if (OutputUses != NULL) {

        MIDL_user_free(OutputUses);
        OutputUses = NULL;
    }

    *Names = NULL;
    *Use = NULL;

    goto LookupIdsInDomainFinish;
}



NTSTATUS
SampLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use OPTIONAL
    )

/*++

Routine Description:

    This API maps a number of relative IDs to their corresponding names.
    The use of the name (domain, group, alias, user, or unknown) is also
    returned.

    The API stores the actual names in Buffer, then creates an array of
    UNICODE_STRINGs in the Names OUT parameter.  If a relative ID can
    not be mapped, a NULL value is placed in the slot for the
    UNICODE_STRING, and STATUS_SOME_NOT_MAPPED is returned.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Provides the number of relative IDs to translate.

    RelativeIds - Array of Count relative IDs to be mapped.

    Names - Receives a pointer to an array of Count UNICODE_STRINGs that
        have been filled in.  The nth pointer within this array will
        correspond the nth relative id passed .  Each name string buffer
        will be in a separately allocated block of memory.  Any entry is
        not successfully translated will have a NULL name buffer pointer
        returned.  This Names buffer must be freed using SamFreeMemory()
        when no longer needed.

    Use - Optionally, receives a pointer to an array of Count SID_NAME_USE
        entries that have been filled in with what significance each
        name has.  The nth entry in this array indicates the meaning
        of the nth name passed.  This buffer must be freed when no longer
        needed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.


--*/

{

    NTSTATUS                        NtStatus = STATUS_SUCCESS;
    SAMPR_RETURNED_USTRING_ARRAY    NameBuffer;
    SAMPR_ULONG_ARRAY               UseBuffer;
    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamLookupIdsInDomain");

    //
    // Make sure our parameters are within bounds
    //

    if (0 == Count)
    {
        (*Names) = NULL;
        if ( ARGUMENT_PRESENT(Use) ) {
            (*Use) = NULL;
        }
        return(STATUS_SUCCESS);
    }

    if (RelativeIds == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (Count > SAM_MAXIMUM_LOOKUP_COUNT) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    NameBuffer.Element = NULL;
    UseBuffer.Element  = NULL;


    RpcTryExcept{

        NtStatus = SamrLookupIdsInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       Count,
                       RelativeIds,
                       &NameBuffer,
                       &UseBuffer
                       );


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    //
    // What comes back for the "Names" OUT parameter is a two level
    // structure, the first level of which is on our stack:
    //
    //              NameBuffer
    //              +-------------+
    //              |   Count     |
    //              |-------------|    +-------+
    //              | Element  ---|--->| Name0 | --- > (NameBuffer0)
    //              +-------------+    |-------|            o
    //                                 |  ...  |            o
    //                                 |-------|            o
    //                                 | NameN | --- > (NameBufferN)
    //                                 +-------+
    //
    //   The buffer containing the EntriesRead field is not returned
    //   to our caller.  Only the buffers containing name information
    //   are returned.
    //
    //   NOTE:  The buffers containing name information are allocated
    //          by the RPC runtime in a single buffer.  This is caused
    //          by a line the the client side .acf file.
    //

    //
    // What comes back for the "Use" OUT parameter is a two level
    // structure, the first level of which is on our stack:
    //
    //              UseBuffer
    //              +-------------+
    //              |   Count     |
    //              |-------------|    +-------+
    //              | Element  ---|--->| Use-0 |
    //              +-------------+    |-------|
    //                                 |  ...  |
    //                                 |-------|
    //                                 | Use-N |
    //                                 +-------+
    //
    //   The Pointer in the Element field is what gets returned
    //   to our caller.  The caller is responsible for deallocating
    //   this when no longer needed.
    //

    (*Names) = (PUNICODE_STRING)NameBuffer.Element;
    if ( ARGUMENT_PRESENT(Use) ) {
        (*Use) = (PSID_NAME_USE) UseBuffer.Element;
    } else {
        if (UseBuffer.Element != NULL) {
            MIDL_user_free(UseBuffer.Element);
            UseBuffer.Element = NULL;
        }
    }


    //
    // Don't force our caller to deallocate things on unexpected
    // return value.
    //

    if (NtStatus != STATUS_SUCCESS         &&
        NtStatus != STATUS_SOME_NOT_MAPPED
       ) {
        if ( ARGUMENT_PRESENT(Use) ) {
            (*Use) = NULL;
        }
        if (UseBuffer.Element != NULL) {
            MIDL_user_free(UseBuffer.Element);
            UseBuffer.Element = NULL;
        }

        (*Names) = NULL;
        if (NameBuffer.Element != NULL) {
            MIDL_user_free(NameBuffer.Element);
            NameBuffer.Element = NULL;
        }

    }


    return(SampMapCompletionStatus(NtStatus));




}



NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      EntryCount,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      )
/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of SAM
    accounts for display in list boxes.  (Replication has similar but
    broader requirements.)


Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which information is to be enumerated.

    Index - The index of the first entry to be retrieved.

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    TotalAvailable - Total number of bytes availabe in the specified info
        class.  This parameter is optional (and is not returned) for
        the following info levels:

                DomainDisplayOemUser
                DomainDisplayOemGroup


    TotalReturned - Number of bytes actually returned for this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.


    SortedBuffer - Receives a pointer to a buffer containing a sorted
        list of the requested information.  This buffer is allocated
        by this routine and contains the following structure:


            DomainDisplayUser     --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_USER structures.

            DomainDisplayMachine  --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_MACHINE.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_MACHINE structures.

            DomainDisplayGroup    --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_GROUP.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_GROUP structures.

            DomainDisplayOemUser  --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_user structures.

            DomainDisplayOemGroup --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_GROUP.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_GROUP structures.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_INVALID_INFO_CLASS - The requested class of information
        is not legitimate for this service.


--*/
{
    NTSTATUS
        NtStatus;

    SAMPR_DISPLAY_INFO_BUFFER
        DisplayInformationBuffer;

    ULONG
        LocalTotalAvailable;

    SAMPR_HANDLE
        RpcContextHandle;

    SampOutputDebugString("SamQueryDisplayInformation");

    //
    // Check parameters
    //

    if ( !ARGUMENT_PRESENT(TotalAvailable)           &&
        (DisplayInformation != DomainDisplayOemUser) &&
        (DisplayInformation != DomainDisplayOemGroup)   ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(TotalReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(ReturnedEntryCount) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(SortedBuffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        if (DisplayInformation  <= DomainDisplayMachine) {
            NtStatus = SamrQueryDisplayInformation(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DisplayInformation,
                           Index,
                           EntryCount,
                           PreferredMaximumLength,
                           &LocalTotalAvailable,
                           TotalReturned,
                           &DisplayInformationBuffer);

        } else if (DisplayInformation <= DomainDisplayGroup) {
            NtStatus = SamrQueryDisplayInformation2(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DisplayInformation,
                           Index,
                           EntryCount,
                           PreferredMaximumLength,
                           &LocalTotalAvailable,
                           TotalReturned,
                           &DisplayInformationBuffer);
        } else {
            NtStatus = SamrQueryDisplayInformation3(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DisplayInformation,
                           Index,
                           EntryCount,
                           PreferredMaximumLength,
                           &LocalTotalAvailable,
                           TotalReturned,
                           &DisplayInformationBuffer);
        }

        if (NT_SUCCESS(NtStatus)) {

            if (ARGUMENT_PRESENT(TotalAvailable)) {
                (*TotalAvailable) = LocalTotalAvailable;
            }

            switch (DisplayInformation) {

            case DomainDisplayUser:
                *ReturnedEntryCount = DisplayInformationBuffer.UserInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.UserInformation.Buffer;
                break;

            case DomainDisplayMachine:
                *ReturnedEntryCount = DisplayInformationBuffer.MachineInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.MachineInformation.Buffer;
                break;

            case DomainDisplayGroup:
                *ReturnedEntryCount = DisplayInformationBuffer.GroupInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.GroupInformation.Buffer;
                break;

            case DomainDisplayOemUser:
                *ReturnedEntryCount = DisplayInformationBuffer.OemUserInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.OemUserInformation.Buffer;
                break;

            case DomainDisplayOemGroup:
                *ReturnedEntryCount = DisplayInformationBuffer.OemGroupInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.OemGroupInformation.Buffer;
                break;

            }

        } else {
            *ReturnedEntryCount = 0;
            *SortedBuffer = NULL;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        //
        // If the exception indicates the server doesn't have
        // the selected api, that means the server doesn't know
        // about the info level we passed.  Set our completion
        // status appropriately.
        //

        if (RpcExceptionCode() == RPC_S_INVALID_LEVEL         ||
            RpcExceptionCode() == RPC_S_PROCNUM_OUT_OF_RANGE  ||
            RpcExceptionCode() == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
            NtStatus = STATUS_INVALID_INFO_CLASS;
        } else {
            NtStatus = I_RpcMapWin32Status(RpcExcepti