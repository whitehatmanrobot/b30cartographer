     pmap = amapClassicMSHTML;
        cmap = ARRAY_SIZE(amapClassicMSHTML);
    }
    else if (*pguidCmdGroup == CGID_Explorer)
    {
        pmap = amapExplorer;
        cmap = ARRAY_SIZE(amapExplorer);
    }
    else if (*pguidCmdGroup == CGID_ShortCut)
    {
        pmap = amapPersistence;
        cmap = ARRAY_SIZE(amapPersistence);
    }
    else if (*pguidCmdGroup == CGID_DownloadHost)
    {
        pmap = amapDownloadHost;
        cmap = ARRAY_SIZE(amapDownloadHost);
    }
    else
    {
        return IDM_UNKNOWN;
    }

    for (; --cmap >= 0; pmap++)
    {
        if (pmap->usCmdID == ulCmdID)
            return pmap->idm;
    }

    return IDM_UNKNOWN;
}


//+-------------------------------------------------------------------------
//
//  Method:     OLECMDIDFromIDM
//
//  Synopsis:   Compute standard command id from an idm.
//
//--------------------------------------------------------------------------

BOOL
OLECMDIDFromIDM(int idm, ULONG *pulCmdID)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(amapCommandSet95); i++)
    {
        if (amapCommandSet95[i].idm == idm)
        {
            *pulCmdID = amapCommandSet95[i].usCmdID;
            return TRUE;
        }
    }

    return FALSE;
}


// Table used to to translate command names to command IDs and get command value return types
// Notice that the last element defines the default cmdID and vt returned when the item is not found

// *******
// NOTE: If you add a command that is clipboard related and should be checked by the security
// manager, make sure to add to the inclusion list in CMarkup::AllowClipboardAccess.
// *******

const CBase::CMDINFOSTRUCT CBase::cmdTable[] =
{
        _T("AutoDetect"),           IDM_AUTODETECT,
        _T("CreateBookmark"),       IDM_BOOKMARK,
        _T("CreateLink"),           IDM_HYPERLINK,
        _T("InsertImage"),          IDM_IMAGE,
        _T("Bold"),                 IDM_BOLD,
        _T("TristateBold"),         IDM_TRISTATEBOLD,
        _T("BrowseMode"),           IDM_BROWSEMODE,
        _T("EditMode"),             IDM_EDITMODE,
        _T("InsertButton"),         IDM_BUTTON,
        _T("InsertIFrame"),         IDM_IFRAME,
        _T("InsertInputButton"),    IDM_INSINPUTBUTTON,
        _T("InsertInputCheckbox"),  IDM_CHECKBOX,
        _T("InsertInputImage"),     IDM_INSINPUTIMAGE,
        _T("InsertInputRadio"),     IDM_RADIOBUTTON,
        _T("InsertInputText"),      IDM_TEXTBOX,
        _T("InsertSelectDropdown"), IDM_DROPDOWNBOX,
        _T("InsertSelectListbox"),  IDM_LISTBOX,
        _T("InsertTextArea"),       IDM_TEXTAREA,
#ifdef NEVER        
        _T("InsertHtmlArea"),       IDM_HTMLAREA,
#endif        
        _T("Italic"),               IDM_ITALIC,
        _T("TristateItalic"),       IDM_TRISTATEITALIC,
        _T("SizeToControl"),        IDM_SIZETOCONTROL,
        _T("SizeToControlHeight"),  IDM_SIZETOCONTROLHEIGHT,
        _T("SizeToControlWidth"),   IDM_SIZETOCONTROLWIDTH,
        _T("Underline"),            IDM_UNDERLINE,
        _T("TristateUnderline"),    IDM_TRISTATEUNDERLINE,
        _T("Copy"),                 IDM_COPY,
        _T("Cut"),                  IDM_CUT,
        _T("Delete"),               IDM_DELETE,
        _T("Print"),                IDM_EXECPRINT,
        _T("JustifyCenter"),        IDM_JUSTIFYCENTER,
        _T("JustifyFull"),          IDM_JUSTIFYFULL,
        _T("JustifyLeft"),          IDM_JUSTIFYLEFT,
        _T("JustifyRight"),         IDM_JUSTIFYRIGHT,
        _T("JustifyNone"),          IDM_JUSTIFYNONE,
        _T("Paste"),                IDM_PASTE,
        _T("PlayImage"),            IDM_DYNSRCPLAY,
        _T("StopImage"),            IDM_DYNSRCSTOP,
        _T("InsertInputReset"),     IDM_INSINPUTRESET,
        _T("InsertInputSubmit"),    IDM_INSINPUTSUBMIT,
        _T("InsertInputFileUpload"),IDM_INSINPUTUPLOAD,
        _T("InsertFieldset"),       IDM_INSFIELDSET,
        _T("Unselect"),             IDM_CLEARSELECTION,
        _T("BackColor"),            IDM_BACKCOLOR,
        _T("ForeColor"),            IDM_FORECOLOR,
        _T("FontName"),             IDM_FONTNAME,
        _T("FontSize"),             IDM_FONTSIZE,
        _T("GetBlockFormats"),      IDM_GETBLOCKFMTS,
        _T("FormatBlock"),          IDM_BLOCKFMT,
        _T("Indent"),               IDM_INDENT,
        _T("InsertMarquee"),        IDM_MARQUEE,
        _T("InsertOrderedList"),    IDM_ORDERLIST,
        _T("InsertParagraph"),      IDM_PARAGRAPH,
        _T("InsertUnorderedList"),  IDM_UNORDERLIST,
        _T("Outdent"),              IDM_OUTDENT,
        _T("UIOutdent"),            IDM_UI_OUTDENT,
        _T("Redo"),                 IDM_REDO,
        _T("Refresh"),              IDM_REFRESH,
        _T("RemoveParaFormat"),     IDM_REMOVEPARAFORMAT,
        _T("RemoveFormat"),         IDM_REMOVEFORMAT,
        _T("SelectAll"),            IDM_SELECTALL,
        _T("StrikeThrough"),        IDM_STRIKETHROUGH,
        _T("Subscript"),            IDM_SUBSCRIPT,            
        _T("Superscript"),          IDM_SUPERSCRIPT,
        _T("Undo"),                 IDM_UNDO,
        _T("Unlink"),               IDM_UNLINK,
        _T("InsertHorizontalRule"), IDM_HORIZONTALLINE,
        _T("UnBookmark"),           IDM_UNBOOKMARK,
        _T("OverWrite"),            IDM_OVERWRITE,
        _T("InsertInputPassword"),  IDM_INSINPUTPASSWORD,
        _T("InsertInputHidden"),    IDM_INSINPUTHIDDEN,
        _T("DirLTR"),               IDM_DIRLTR,
        _T("DirRTL"),               IDM_DIRRTL,
        _T("BlockDirLTR"),          IDM_BLOCKDIRLTR,
        _T("BlockDirRTL"),          IDM_BLOCKDIRRTL,
        _T("InlineDirLTR"),         IDM_INLINEDIRLTR,
        _T("InlineDirRTL"),         IDM_INLINEDIRRTL,
        _T("SaveAs"),               IDM_SAVEAS,
        _T("Open"),                 IDM_OPEN,
        _T("Stop"),                 IDM_STOP,
        _T("MultipleSelection"),    IDM_MULTIPLESELECTION,
        _T("2D-Position"),          IDM_2D_POSITION,
        _T("AbsolutePosition"),     IDM_ABSOLUTE_POSITION,
        _T("LiveResize"),           IDM_LIVERESIZE,
        _T("KeepSelection"),        IDM_KEEPSELECTION,
        _T("RespectVisibilityInDesign"), IDM_RESPECTVISIBILITY_INDESIGN,
        _T("UnloadDocument"), IDM_UNLOADDOCUMENT,
        _T("ClearAuthenticationCache"), IDM_CLEARAUTHENTICATIONCACHE,
        NULL,                       0
};

// Translates command name into command ID. If the command is not found and the
//  command string starts with a digit the command number is used.
HRESULT 
CBase::CmdIDFromCmdName(BSTR bstrCmdName, ULONG *pcmdValue)
{
    int     i;
    HRESULT hr=S_OK;

    Assert(pcmdValue != NULL);
    *pcmdValue = 0;

    if(FormsIsEmptyString(bstrCmdName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    i = 0;
    while(cmdTable[i].cmdName != NULL)
    {
        if(StrCmpIC(cmdTable[i].cmdName, bstrCmdName) == 0)
        {
            break;
        }
        i++;
    }
    if(cmdTable[i].cmdName != NULL)
    {
        // The command name was found, use the value from the table
        *pcmdValue = cmdTable[i].cmdID;
        if(*pcmdValue == 0)
            hr = E_INVALIDARG;
    }
    else
    {
        hr = E_INVALIDARG;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandSupported(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    ULONG           uCmdId;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = CmdIDFromCmdName(bstrCmdId, &uCmdId);
    if(hr == S_OK)
    {
        *pfRet = VB_TRUE;
    }
    else if(hr == E_INVALIDARG)
    {
        *pfRet = VB_FALSE;
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandEnabled(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    DWORD           dwFlags;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfRet = VB_FALSE;

    hr = THR(QueryCommandHelper(bstrCmdId, &dwFlags, NULL));
    if(hr)
        goto Cleanup;

   if(dwFlags == MSOCMDSTATE_NINCHED ||
      dwFlags == MSOCMDSTATE_UP || dwFlags == MSOCMDSTATE_DOWN)
    {
        *pfRet = VB_TRUE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandState(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    DWORD           dwFlags;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfRet = VB_FALSE;

    hr = THR(QueryCommandHelper(bstrCmdId, &dwFlags, NULL));
    if(hr)
        goto Cleanup;

   if(dwFlags == MSOCMDSTATE_DOWN)
    {
        *pfRet = VB_TRUE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandIndeterm(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    DWORD           dwFlags;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfRet = VB_FALSE;

    hr = THR(QueryCommandHelper(bstrCmdId, &dwFlags, NULL));
    if(hr)
        goto Cleanup;

    if(dwFlags == MSOCMDSTATE_NINCHED)
    {
        *pfRet = VB_TRUE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandText(const BSTR bstrCmdId, BSTR *pcmdText)
{
    HRESULT     hr = S_OK;

    if(pcmdText == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pcmdText = NULL;

    hr = THR(QueryCommandHelper(bstrCmdId, NULL, pcmdText));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandValue(const BSTR bstrCmdId, VARIANT *pvarRet)
{
    HRESULT     hr = S_OK;
    DWORD       dwCmdId;

    if(pvarRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantClear(pvarRet);
    if(hr)
        goto Cleanup;

    // Convert the command ID from string to number
    hr = THR(CmdIDFromCmdName(bstrCmdId, &dwCmdId));
    if(hr)
        goto Cleanup;

    // Set the appropriate variant type
    V_VT(pvarRet) = GetExpectedCmdValueType(dwCmdId);

    // Call QueryStatus instead of exec if the expected return value is boolean
    if(V_VT(pvarRet) == VT_BOOL)
    {
        MSOCMD msocmd;
        
        msocmd.cmdID = dwCmdId;
        msocmd.cmdf  = 0;

        hr = THR(QueryStatus(const_cast < GUID * > ( & CGID_MSHTML ),
                        1, &msocmd, NULL));
        if (hr)
            goto Cleanup;

        V_BOOL(pvarRet) = (msocmd.cmdf == MSOCMDSTATE_NINCHED || msocmd.cmdf == MSOCMDSTATE_DOWN)
                        ? VB_TRUE : VB_FALSE;
    }
    else
    {
        // Use exec to get the string on integer value

        // If GetExpectedCmdValueType returned a VT_BSTR we need to null out the value
        // VariantClear wont do that.  If the pvarRet passed in the VariantClear
        // the bstrVal would be bogus.
        V_BSTR(pvarRet) = NULL;

        hr = THR(Exec(const_cast < GUID * > ( & CGID_MSHTML )
                                ,dwCmdId, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, pvarRet));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+---------------------------------------------------------------------------
//
//  Member:     queryCommandHelper
//
//  Synopsis:   This function is called by QueryCommandXXX functions and does the
//              command ID conversions and returns the flags or the text for given
//              command. Only one of the return parameters must be not NULL.
//
//  Returns:    S_OK if the value is returned
//----------------------------------------------------------------------------

struct MSOCMDTEXT_WITH_TEXT
{
    MSOCMDTEXT   header;
    WCHAR        text[FORMS_BUFLEN];
};

HRESULT
CBase::QueryCommandHelper(const BSTR bstrCmdId, DWORD *cmdf, BSTR *pcmdText)
{
    HRESULT                 hr = S_OK;
    MSOCMD                  msocmd;
    MSOCMDTEXT_WITH_TEXT    msocmdtext;

    Assert((cmdf == NULL && pcmdText != NULL) || (cmdf != NULL && pcmdText == NULL));

    // initialize the values so in case of error we return a NULL pointer
    if(pcmdText != NULL)
    {
        *pcmdText = NULL;
    }
    else
    {
        *cmdf = 0L;
    }

    // Fill the command structure converting the command ID from string to number
    hr = CmdIDFromCmdName(bstrCmdId, &(msocmd.cmdID));
    if(hr)
        goto Cleanup;
    msocmd.cmdf  = 0;

    if(pcmdText != NULL)
    {
        msocmdtext.header.cmdtextf = MSOCMDTEXTF_NAME;
        msocmdtext.header.cwBuf    = FORMS_BUFLEN;
        msocmdtext.header.cwActual = 0;
    }
    else
    {
        msocmdtext.header.cmdtextf = MSOCMDTEXTF_NONE;
        msocmdtext.header.cwBuf    = 0;
        msocmdtext.header.cwActual = 0;
    }

    hr = THR(QueryStatus(const_cast < GUID * > ( & CGID_MSHTML ),
                    1, &msocmd, (MSOCMDTEXT *)&msocmdtext));
    if (hr)
        goto Cleanup;

    if(pcmdText != NULL)
    {
        // Ignore the  msocmd value, just return the text
        if(msocmdtext.header.cwActual > 0)
        {
             // Allocate the return string
            *pcmdText = SysAllocString(msocmdtext.header.rgwz);
            if(*pcmdText == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }
    else
    {
        // return the flags
        *cmdf = msocmd.cmdf;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     execCommand
//
//  Synopsis:   Executes given command
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CBase::execCommand(const BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT value)
{
    DWORD     dwCmdOpt;
    DWORD     dwCmdId;
    VARIANT * pValue = NULL;
    HRESULT   hr;
    
    // Translate the "show UI" flag into appropriate option
    dwCmdOpt = (showUI == VB_FALSE) 
            ? MSOCMDEXECOPT_DONTPROMPTUSER 
            : MSOCMDEXECOPT_PROMPTUSER;

    // Convert the command ID from string to number
    hr = THR_NOTRACE(CmdIDFromCmdName(bstrCmdId, &dwCmdId));
    if(hr)
        goto Cleanup;

    pValue = (V_VT(&value) == (VT_BYREF | VT_VARIANT)) ?
        V_VARIANTREF(&value) : &value;

    // Some functions do not check for empty or error type variants
    if (V_VT(pValue) == VT_ERROR || V_VT(pValue) == VT_EMPTY)
    {
        pValue = NULL;
    }

    hr = THR(Exec(const_cast < GUID * > ( & CGID_MSHTML )
                            ,dwCmdId, dwCmdOpt, pValue, NULL));

Cleanup:
    RRETURN(hr);
 }


//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CBase::execCommandShowHelp(const BSTR bstrCmdId)
{
    HRESULT   hr;
    DWORD     dwCmdId;

    // Convert the command ID from string to number
    hr = CmdIDFromCmdName(bstrCmdId, &dwCmdId);
    if(hr)
        goto Cleanup;

    hr = THR(Exec(const_cast < GUID * > ( & CGID_MSHTML )
                    , dwCmdId, MSOCMDEXECOPT_SHOWHELP, NULL, NULL));

Cleanup:
    RRETURN(hr);
}



// Returns the expected VARIANT type of the command value (like VT_BSTR for font name)
VARTYPE CBase::GetExpectedCmdValueType(ULONG uCmdID)
{
    // We do not need to set the pvarOut, except for IDM_FONTSIZE. But we still
    // use this logic to determine if we need to use the queryStatus or exec
    // to get the command value

    switch (uCmdID)
    {
        case IDM_FONTSIZE:
        case IDM_FORECOLOR:
        case IDM_BACKCOLOR:
            return VT_I4;

        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
            return VT_BSTR;

        case IDM_GETBLOCKFMTS:
            return VT_ARRAY;           
    }

    return VT_BOOL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::ExecSetGetProperty and 
//              CBase::ExecSetGetKnownProp
//
//  Synopsis:   Helper functions for Exec(), it Set/Get a property for
//              control. pvarargIn, pvarargOut can both not NULL. they both
//              call CBase:: ExecSetGetHelper for the invoke logic.
//
//--------------------------------------------------------------------------
HRESULT
CBase::ExecSetGetProperty(
        VARIANTARG *    pvarargIn,      // In parameter
        VARIANTARG *    pvarargOut,     // Out parameter
        UINT            uPropName,      // property name
        VARTYPE         vt)             // Parameter type
{
    HRESULT         hr = S_OK;
    IDispatch *     pDispatch = NULL;
    DISPID          dispid;

    // Invalid parameters
    if (!pvarargIn && !pvarargOut)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // try to turn the uPropName into a dispid for the property
    hr = THR_NOTRACE(GetDispatchForProp(uPropName, &pDispatch, &dispid));
    if (hr)
        goto Cleanup;

    // call the helper to do the work
    hr = THR_NOTRACE(ExecSetGetHelper(pvarargIn, pvarargOut, pDispatch, dispid, vt));

Cleanup:
    ReleaseInterface(pDispatch);
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    RRETURN(hr);
}

HRESULT
CBase::ExecSetGetKnownProp(
        VARIANTARG *    pvarargIn,      // In parameter
        VARIANTARG *    pvarargOut,     // Out parameter
        DISPID          dispidProp, 
        VARTYPE         vt)             // Parameter type
{
    HRESULT hr = S_OK;
    IDispatch *     pDispatch = NULL;

    // Invalid parameters?
    if (!pvarargIn && !pvarargOut)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // now get the IDispatch for *this*
    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatch, (void **)&pDispatch));
    if (hr)
        goto Cleanup;

    // now call the helper to do the work
    hr = THR_NOTRACE(ExecSetGetHelper(pvarargIn, pvarargOut, pDispatch, dispidProp, vt));

Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}


HRESULT
CBase::ExecSetGetHelper(
        VARIANTARG *    pvarargIn,      // In parameter
        VARIANTARG *    pvarargOut,     // Out parameter
        IDispatch  *    pDispatch,      // the IDispatch for *this*
        DISPID          dispid,         // the property dispid
        VARTYPE         vt)             // Parameter type
{
    HRESULT      hr  =S_OK;
    DISPPARAMS   dp = g_Zero.dispparams;         // initialized be zero.
    DISPID       dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.

    // Set property
    if (pvarargIn)
    {
        // Fill in dp
        dp.rgvarg = pvarargIn;
        dp.rgdispidNamedArgs = &dispidPut;
        dp.cArgs = 1;
        dp.cNamedArgs = 1;

        hr = THR_NOTRACE(pDispatch->Invoke(
                dispid,
                IID_NULL,
                NULL,
                DISPATCH_PROPERTYPUT,
                &dp,
                NULL,
                NULL,
                NULL));

        if (hr)
            goto Cleanup;
    }

    // Get property
    if (pvarargOut)
    {
        // Get property requires different dp
        dp = g_Zero.dispparams;

        hr = THR_NOTRACE(pDispatch->Invoke(
                dispid,
                IID_NULL,
                NULL,
                DISPATCH_PROPERTYGET,
                &dp,
                pvarargOut,
                NULL,
                NULL));

        if (hr)
        {
            //
            // (EricVas) - This is a hack to prevent the member
            // not found from trickling up, causing a nasty message box to
            // appear
            //

            hr = OLECMDERR_E_DISABLED;

            goto Cleanup;
        }

        // Update the VT if necessary
        V_VT(pvarargOut) = vt;
    }

Cleanup:
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::ExecToggleCmd
//
//  Synopsis:   Helper function for exec(). It is used for cmdidBold,
//              cmdidItalic, cmdidUnderline. It always toggle property
//              value.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT
CBase::ExecToggleCmd(UINT uPropName)       // Dipatch ID for command
{
    HRESULT         hr ;
    IDispatch *     pDispatch = NULL;
    DISPPARAMS      dp = g_Zero.dispparams;         // initialized be zero.
    DISPID          dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    VARIANT         var;
    DISPID          dispid;

    hr = THR(GetDispatchForProp(uPropName, &pDispatch, &dispid));
    if (hr)
        goto Cleanup;

    VariantInit(&var);
    V_VT(&var) = VT_BOOL;

    // Get property value
    hr = THR_NOTRACE(pDispatch->Invoke(
            dispid,
            IID_NULL,
            NULL,
            DISPATCH_PROPERTYGET,
            &dp,
            &var,
            NULL,
            NULL));
    if (hr)
        goto Cleanup;

    // Toggle property value
    V_BOOL(&var) = !V_BOOL(&var);

    // Fill in dp
    dp.rgvarg = &var;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;

    // Set new property value
    hr = THR_NOTRACE(pDispatch->Invoke(
            dispid,
            IID_NULL,
            NULL,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL));

Cleanup:
    ReleaseInterface(pDispatch);
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::QueryStatusProperty
//
//  Synopsis:   Helper function for QueryStatus(), it determines if a control
//              supports a property by checking whether you can get property. .
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT
CBase::QueryStatusProperty(
        MSOCMD *    pCmd,
        UINT        uPropName,
        VARTYPE     vt)
{
    HRESULT         hr;
    IDispatch *     pDispatch = NULL;
    CVariant        var;
    DISPPARAMS      dp = g_Zero.dispparams;         // initialized be zero.
    DISPID          dispid;

    hr = THR_NOTRACE(GetDispatchForProp(uPropName, &pDispatch, &dispid));
    if (hr)
        goto Cleanup;

    V_VT(&var) = vt;

    hr = THR_NOTRACE(pDispatch->Invoke(
            dispid,
            IID_NULL,
            NULL,
            DISPATCH_PROPERTYGET,
            &dp,
            &var,
            NULL,
            NULL));

Cleanup:
    if(!hr)
    {
        if(V_VT(&var) == VT_BOOL && V_BOOL(&var) == VB_TRUE)
            pCmd->cmdf = MSOCMDSTATE_DOWN;
        else
            pCmd->cmdf = MSOCMDSTATE_UP;
    }
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::ExecSetPropertyCmd
//
//  Synopsis:   Helper function for Exec(), It is used for SpecialEffect
//              Commands, Justify (TextAlign). For these commands, there are
//              not input parameter.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT
CBase::ExecSetPropertyCmd(UINT uPropName, DWORD value)
{
    VARIANT     var;

    VariantInit(&var);
    V_VT(&var) = VT_I4;
    V_I4(&var) = value;

    return THR_NOTRACE(ExecSetGetProperty(&var, NULL, uPropName, VT_I4));
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetDispatchForProp
//
//  Synopsis:   Helper function for flavours of Exec()-s and QueryStatus()-es
//
//--------------------------------------------------------------------------

HRESULT
CBase::GetDispatchForProp(UINT uPropName, IDispatch ** ppDisp, DISPID * pdispid)
{
    HRESULT     hr;
    TCHAR       achPropName[64];
    LPTSTR      pchPropName = achPropName;
    int         nLoadStringRes;

    *ppDisp = NULL;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatch, (void **)ppDisp));
    if (hr)
        goto Cleanup;

    nLoadStringRes = LoadString(GetResourceHInst(), uPropName, achPropName, ARRAY_SIZE(achPropName));
    if (0 == nLoadStringRes)
    {
        hr = THR(GetLastWin32Error());
        Assert (!OK(hr));
        goto Cleanup;
    }

    hr = THR_NOTRACE((*ppDisp)->GetIDsOfNames(IID_NULL, &pchPropName, 1, g_lcidUserDefault, pdispid));

Cleanup:
    if (hr)
        ClearInterface (ppDisp);

    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
// Method:      CTQueryStatus
//
// Synopsis:    Call IOleCommandTarget::QueryStatus on an object.
//
//--------------------------------------------------------------------------

HRESULT
CTQueryStatus(
        IUnknown *pUnk,
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    IOleCommandTarget * pCommandTarget;
    HRESULT             hr;

    if (!pUnk)
    {
        Assert(0);
        RRETURN(E_FAIL);
    }

    hr = THR_NOTRACE(pUnk->QueryInterface(
            IID_IOleCommandTarget,
            (void**) &pCommandTarget));

    if (!hr)
    {
        hr = THR_NOTRACE(pCommandTarget->QueryStatus(
                pguidCmdGroup,
                cCmds,
                rgCmds,
                pcmdtext));
        pCommandTarget->Release();
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
// Method: CTExec
//
// Synopsis:    Call IOleCommandTarget::Exec on an object.
//
//--------------------------------------------------------------------------

HRESULT
CTExec(
        IUnknown *pUnk,
        const GUID * pguidCmdGroup,
        DWORD  nCmdID,
        DWORD  nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    IOleCommandTarget * pCommandTarget;
    HRESULT             hr;

    if (!pUnk)
    {
        Assert(0);
        RRETURN(E_FAIL);
    }

    hr = THR_NOTRACE(pUnk->QueryInterface(
            IID_IOleCommandTarget,
            (void**) &pCommandTarget));

    if (!hr)
    {
        hr = THR_NOTRACE(pCommandTarget->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
        pCommandTarget->Release();
    }

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\baseprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       baseprop.cxx
//
//  Contents:   CBase property setting utilities.
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif // X_CBUFSTR_HXX_

#ifndef X_HIMETRIC_HXX_
#define X_HIMETRIC_HXX_
#include "himetric.hxx"
#endif


#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

MtDefine(StripCRLF, Utilities, "StripCRLF *ppDest")
size_t ValidStyleUrl(TCHAR *pch);
// forward reference decl's: local helper function
static HRESULT StripCRLF(TCHAR *pSrc, TCHAR **pCstrDest);

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

BOOL ContainsUrl(TCHAR* pch);
extern BOOL  IsCompositeUrl(CStr *pcstr, int startAt = 0);

static const TCHAR strURLBeg[] = _T("url(");

static HRESULT RTCCONV PropertyStringToLong (
        LPCTSTR nptr,
        TCHAR **endptr,
        int ibase,
        int flags,
        unsigned long *plNumber );


#define GET_CUSTOM_VALUE() ( GetInvalidDefault() - 1) 
#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

HRESULT
BASICPROPPARAMS::GetCustomString(void * pObject, CStr *pstr, BOOL * pfValuePresent ) const
{
    
    BOOL  fDummy;
    if (!pfValuePresent)
        pfValuePresent = &fDummy;

    LPCTSTR lpStr;

    Assert( dwPPFlags & PROPPARAM_CUSTOMENUM);
    *pfValuePresent = (*(CAttrArray**)pObject)->FindString ( (((PROPERTYDESC*)this) -1)->GetDispid(),
                                                            &lpStr, 
                                                            CAttrValue::AA_CustomProperty );
                                                            
    if ( *pfValuePresent )
    {
        pstr->Set ( lpStr );
    }

    return S_OK;
}

HRESULT
BASICPROPPARAMS::GetAvString (void * pObject, const void * pvParams, CStr *pstr, BOOL * pfValuePresent ) const
{
    HRESULT hr = S_OK;
    LPCTSTR lpStr;
    BOOL  fDummy;

    if (!pfValuePresent)
        pfValuePresent = &fDummy;

    Assert(pstr);


    if (dwPPFlags & PROPPARAM_ATTRARRAY)
    {
        *pfValuePresent = CAttrArray::FindString ( *(CAttrArray**)pObject, ((PROPERTYDESC*)this) -1, &lpStr );
        // String pointer will be set to a default if not present
        pstr->Set ( lpStr );
    }
    else
    {
        //Stored as offset from a struct
        CStr *pstoredstr = (CStr *)(  (BYTE *)pObject + *(DWORD *)pvParams  );
        pstr -> Set ( (LPTSTR)*pstoredstr ); 
        *pfValuePresent = TRUE;
    }
    RRETURN(hr);
}

DWORD
BASICPROPPARAMS::GetAvNumber (void * pObject, const void * pvParams,
    UINT uNumBytes, BOOL * pfValuePresent  ) const
{
    DWORD dwValue;
    BOOL  fDummy;

    if (!pfValuePresent)
        pfValuePresent = &fDummy;

    if (dwPPFlags & PROPPARAM_ATTRARRAY)
    {
        *pfValuePresent = CAttrArray::FindSimple ( *(CAttrArray**)pObject, ((PROPERTYDESC*)this) -1, &dwValue  );
    }
    else
    {
        //Stored as offset from a struct
        BYTE *pbValue = (BYTE *)pObject + *(DWORD *)pvParams;
        dwValue = (DWORD)GetNumberOfSize( (void*) pbValue, uNumBytes);
        *pfValuePresent = TRUE;
    }
    return dwValue;
}


HRESULT
BASICPROPPARAMS::SetAvNumber ( void *pObject, DWORD dwNumber, const void *pvParams,
    UINT uNumberBytes, WORD wFlags /*=0*/ ) const
{
    HRESULT hr = S_OK;

    if (dwPPFlags & PROPPARAM_ATTRARRAY)
    {
        hr = CAttrArray::SetSimple ( (CAttrArray**)pObject,
            ((PROPERTYDESC*)this) -1, dwNumber, wFlags );
    }
    else
    {
        BYTE *pbData = (BYTE *)pObject + *(DWORD *)pvParams;
        SetNumberOfSize ( (void *)pbData, uNumberBytes, dwNumber );
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Function:   GetGetSetMf
//
//  Synopsis:   Helper for getting get/set pointer to member functions
//
//----------------------------------------------------------------
typedef HRESULT (BUGCALL CVoid::* PFN_ARBITRARYPROPGET) ( ... );
typedef HRESULT (BUGCALL CVoid::* PFN_ARBITRARYPROPSET) ( ... );

// ===========================  New generic handlers and helpers  =============================


inline HRESULT StringToLong( LPTSTR pch, long * pl)
{
    // Skip a leading '+' that would otherwise cause a
    // convert failure
//    RRETURN(VarI4FromStr(pch, LOCALE_SYSTEM_DEFAULT, 0, pl));
    *pl = _tcstol(pch, 0, 0);
    return S_OK;
}

inline HRESULT WriteText (IStream * pStm, TCHAR * pch)
{
    if (pch)
        return pStm->Write(pch, _tcslen(pch)*sizeof(TCHAR), 0);
    else
        return S_OK;
}

inline HRESULT WriteTextLen (IStream * pStm, TCHAR * pch, int nLen)
{
    return pStm->Write(pch, nLen*sizeof(TCHAR), 0);
}

inline HRESULT WriteTextCStr(CStreamWriteBuff * pStmWrBuff, CStr * pstr, BOOL fAlwaysQuote, BOOL fNeverQuote )
{
    UINT u;

    if ((u = pstr->Length()) != 0)
    {
        if ( fNeverQuote )
            RRETURN(pStmWrBuff->Write( *pstr ));
        else
            RRETURN(pStmWrBuff->WriteQuotedText(*pstr, fAlwaysQuote));
    }
    else
    {
        if ( !fNeverQuote )
            RRETURN(WriteText(pStmWrBuff, _T("\"\"")));
    }
    return S_OK;
}

inline HRESULT WriteTextLong(IStream * pStm, long l)
{
    TCHAR ach[20];

    HRESULT hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), l);
    if (hr)
        goto Cleanup;

    hr = pStm->Write(ach, _tcslen(ach)*sizeof(TCHAR), 0);
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Function:   GetGetMethodPtr
//
//  Synopsis:   Helper for getting get/set pointer to member functions
//
//----------------------------------------------------------------

void
BASICPROPPARAMS::GetGetMethodP (const void * pvParams, void * pfn) const
{
    Assert(!(dwPPFlags & PROPPARAM_MEMBER));
    Assert(dwPPFlags & PROPPARAM_GETMFHandler);
    Assert(dwPPFlags & PROPPARAM_SETMFHandler);

    memcpy(pfn, pvParams, sizeof(PFN_ARBITRARYPROPGET));
}


//+---------------------------------------------------------------
//
//  Function:   GetSetMethodptr
//
//  Synopsis:   Helper for getting get/set pointer to member functions
//
//----------------------------------------------------------------

void
BASICPROPPARAMS::GetSetMethodP (const void * pvParams, void * pfn) const
{
    Assert(!(dwPPFlags & PROPPARAM_MEMBER));
    Assert(dwPPFlags & PROPPARAM_GETMFHandler);
    Assert(dwPPFlags & PROPPARAM_SETMFHandler);

    memcpy(pfn, (BYTE *)pvParams + sizeof(PFN_ARBITRARYPROPGET), sizeof(PFN_ARBITRARYPROPSET));
}


//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetColorProperty, public
//
//  Synopsis:   Helper for setting color valued properties
//
//----------------------------------------------------------------



HRESULT
BASICPROPPARAMS::GetColorProperty(VARIANT * pVar, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    if(!pVar)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        VariantInit(pVar);
        V_VT(pVar) = VT_BSTR;
        hr = THR( GetColor(pSubObject,  &(pVar->bstrVal)) );
    }

    RRETURN(pObject->SetErrorInfoPGet(hr, dispid));
}


//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::SetColorProperty, public
//
//  Synopsis:   Helper for setting color valued properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetColorProperty(VARIANT var, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    CBase::CLock    Lock(pObject);
    HRESULT         hr=S_OK;
    DWORD           dwOldValue;
    CColorValue     cvValue;
    CVariant        *v = (CVariant *)&var;

    // check for shorts to keep vbscript happy and other VT_U* and VT_UI* types to keep C programmer's happy.
    // vbscript interprets values between 0x8000 and 0xFFFF in hex as a short!, jscript doesn't
    if (v->CoerceNumericToI4())
    {
        DWORD dwRGB = V_I4(v);

        // if -ve value or highbyte!=0x00, ignore (NS compat)
        if (dwRGB & CColorValue::MASK_FLAG)
            goto Cleanup;
        
        // flip RRGGBB to BBGGRR to be in CColorValue format
        cvValue.SetFromRGB(dwRGB);
    }
    else if (V_VT(&var) == VT_BSTR)
    {
// Removed 4/24/97 because "" clearing a color is a useful feature.  -CWilso
// if NULL or empty string, ignore (NS compat)
//        if (!(V_BSTR(&var)) || !*(V_BSTR(&var)))
//            goto Cleanup;

        hr = cvValue.FromString((LPTSTR)(V_BSTR(&var)), FALSE, ( dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY ) );
    }
    else
        goto Cleanup;   // if invalid type, ignore

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetColor( pSubObject, & dwOldValue );
    if (hr)
        goto Cleanup;

    if ( dwOldValue == (DWORD)cvValue.GetRawValue() )
    {
        // No change - ignore it
        hr = S_OK;
        goto Cleanup;
    }

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            CStr    strOldColor;
            CVariant varOldColor;
            BOOL    fOldPresent;

            hr = THR( GetColor( pSubObject, &strOldColor, FALSE, &fOldPresent ) );

            if (hr)
                goto Cleanup;

            if (fOldPresent)
            {
                V_VT(&varOldColor) = VT_BSTR;
                hr = THR( strOldColor.AllocBSTR( &V_BSTR(&varOldColor) ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                V_VT(&varOldColor) = VT_NULL;
            }

            if( fTreeSync )
            {
                pObject->LogAttributeChange( dispid, &varOldColor, &var );
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(dispid, &varOldColor, NULL));
        
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOldColor
        }
    }
#endif // NO_EDIT

    hr = THR( SetColor( pSubObject, cvValue.GetRawValue(), wFlags ) );
    if (hr)
        goto Cleanup;

    hr = THR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    if (hr)
    {
        IGNORE_HR(SetColor(pSubObject, dwOldValue, wFlags));
        IGNORE_HR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));
    }

Cleanup:

    RRETURN1(pObject->SetErrorInfoPSet(hr, dispid), E_INVALIDARG);
}

//+---------------------------------------------------------------
//
//  Function:   SetString
//
//  Synopsis:   Helper for setting string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetString(CVoid * pObject, TCHAR * pch, WORD wFlags) const
{
    HRESULT hr;

    if (dwPPFlags & PROPPARAM_SETMFHandler)
    {
        PFN_CSTRPROPSET pmfSet;
        CStr szString;
        szString.Set ( pch );

        GetSetMethodP(this + 1, &pmfSet );

        hr = CALL_METHOD(pObject,pmfSet,( &szString));
    }
    else
    {

        if (dwPPFlags & PROPPARAM_ATTRARRAY)
        {            
            hr = THR( CAttrArray::SetString ( (CAttrArray**) (void*) pObject,
                    (PROPERTYDESC*)this - 1, pch, FALSE, wFlags ) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            //Stored as offset from a struct
            CStr *pcstr;
            pcstr = (CStr *) (  (BYTE *)pObject + *(DWORD *)(this + 1)  );
            hr = THR( pcstr->Set(pch) );
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Function:   GetString
//
//  Synopsis:   Helper for getting string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetString(CVoid * pObject, CStr * pcstr, BOOL *pfValuePresent) const
{
    HRESULT hr = S_OK;

    if (dwPPFlags & PROPPARAM_GETMFHandler)
    {
        PFN_CSTRPROPGET pmfGet;

        GetGetMethodP(this + 1, &pmfGet);

        // Get Method fn prototype takes a BSTR ptr
        //
        hr = CALL_METHOD(pObject,pmfGet,( pcstr ));
        if (pfValuePresent)
            *pfValuePresent = TRUE;
    }
    else
    {
        hr = GetAvString (pObject,this + 1,  pcstr, pfValuePresent);
    }

    RRETURN( hr );
}


//+---------------------------------------------------------------
//
//  Member:     SetStringProperty, public
//
//  Synopsis:   Helper for setting string values properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetStringProperty(BSTR bstrNew, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    CBase::CLock    Lock(pObject);
    HRESULT         hr;
    CStr            cstrOld;
    BOOL            fOldPresent;

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetString(pSubObject, &cstrOld, &fOldPresent);
    if (hr)
        goto Cleanup;

    // HACK! HACK! HACK! (MohanB) In order to fix #64710 at this very late
    // stage in IE5, I am putting in this hack to specifically check for
    // DISPID_CElement_id. For IE6, we should not fire onpropertychange for any
    // property (INCLUDING non-string type properties!) if the value of the
    // property has not been modified.

    // Quit if the value has not been modified
    if (    fOldPresent
        &&  DISPID_IHTMLELEMENT_ID == dispid
        &&  0 == _tcscmp(cstrOld, bstrNew)
       )
    {
        goto Cleanup;
    }

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            CVariant varOld;

            if (fOldPresent)
            {
                V_VT(&varOld) = VT_BSTR;
                if( wFlags & CAttrValue::AA_Extra_UrlEnclosed )
                {
                    CBufferedStr szBufSt;

                    szBufSt.Set(_T("url(\""));
                    szBufSt.QuickAppend(cstrOld);
                    szBufSt.QuickAppend(_T("\")"), 2);

                    hr = THR( FormsAllocString( szBufSt, &(V_BSTR(&varOld)) ) );
                }
                else
                    hr = THR( cstrOld.AllocBSTR( &V_BSTR(&varOld) ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                V_VT(&varOld) = VT_NULL;
            }

            if( fTreeSync )
            {
                VARIANT    varNew;
                CBufferedStr szBufSt;

                V_VT( &varNew ) = VT_LPWSTR;
                if( wFlags & CAttrValue::AA_Extra_UrlEnclosed )
                {
                    szBufSt.Set(_T("url(\""));
                    szBufSt.QuickAppend(bstrNew);
                    szBufSt.QuickAppend(_T("\")"));
                    varNew.byref = szBufSt;
                }
                else
                    varNew.byref = bstrNew;

                pObject->LogAttributeChange( dispid, &varOld, &varNew );
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(dispid, &varOld, NULL));
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT

    hr = THR(SetString(pSubObject, (TCHAR *)bstrNew, wFlags));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    if (hr)
    {
        IGNORE_HR(SetString(pSubObject, (TCHAR *)cstrOld, wFlags));
        IGNORE_HR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));
    }

Cleanup:
    RRETURN(pObject->SetErrorInfoPSet(hr, dispid));
}

const PROPERTYDESC *HDLDESC::FindPropDescForName ( LPCTSTR szName, BOOL fCaseSensitive, long *pidx ) const
{
    const PROPERTYDESC *pfoundHash = NULL;
    if(pidx)
        *pidx = -1;

    if(pStringTableAggregate)
    {
        const VTABLEDESC *pVTableDesc;

        if(fCaseSensitive)
        {
            pVTableDesc = pStringTableAggregate->GetCs(szName, VTABLEDESC_BELONGSTOPARSE);
        }
        else    
        {
            pVTableDesc = pStringTableAggregate->GetCi(szName, VTABLEDESC_BELONGSTOPARSE);            
        }

        // Return only PropDescs which "belong" to the parser
        if(pVTableDesc)
        {
            pfoundHash = pVTableDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
            Assert(pfoundHash);

            if(pidx)
                *pidx = pVTableDesc->GetParserIndex();
        }
    }
    return pfoundHash;
}

HRESULT ENUMDESC::EnumFromString ( LPCTSTR pStr, long *plValue, BOOL fCaseSensitive ) const
{   
    int i;
    HRESULT hr = S_OK;              
    STRINGCOMPAREFN pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpIC;

    if (!pStr)
        pStr = _T("");

    for (i = cEnums - 1; i >= 0; i--)
    {
        if (!( pfnCompareString ( pStr, aenumpairs[i].pszName) ) )
        {
            *plValue = aenumpairs[i].iVal;
            break;
        }
    }

    if (i < 0)
    {
        hr = E_INVALIDARG;
    }

    RRETURN1(hr, E_INVALIDARG);
}

HRESULT ENUMDESC::StringFromEnum ( long lValue, BSTR *pbstr ) const
{
    int     i;
    HRESULT hr = E_INVALIDARG;

    for (i = 0; i < cEnums; i++)
    {
        if ( aenumpairs[i].iVal == lValue )
        {
            hr = THR(FormsAllocString( aenumpairs[i].pszName, pbstr ));
            break;
        }
    }
    RRETURN1(hr,E_INVALIDARG);
}


LPCTSTR ENUMDESC::StringPtrFromEnum ( long lValue ) const
{
    int     i;

    for (i = 0; i < cEnums; i++)
    {
        if ( aenumpairs[i].iVal == lValue )
        {
            return( aenumpairs[i].pszName );
        }
    }
    return( NULL );
}


HRESULT
NUMPROPPARAMS::SetEnumStringProperty(BSTR bstrNew, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    HRESULT hr = E_INVALIDARG;
    CBase::CLock    Lock(pObject);
    long lNewValue,lOldValue;
    BOOL fOldPresent;
    TCHAR* pchCustom = NULL;
    
    hr = GetNumber(pObject, pSubObject, &lOldValue, &fOldPresent);
    if ( hr )
        goto Cleanup;

    hr = LookupEnumString ( this, (LPTSTR)bstrNew, &lNewValue );
    if ( hr )
    {    
        if ( this->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM )
        {
            //
            // TODO - move all URL parsing code to the custom cursor class.
            //
            TCHAR* pv = bstrNew;
            if ( ContainsUrl ( (TCHAR*) pv ))
            {
                int nLenIn = ValidStyleUrl((TCHAR*) pv);
                if ( nLenIn > 0 )
                {
                    TCHAR *pch = (TCHAR*) pv;
                    TCHAR *psz = pch+4;
                    TCHAR *quote = NULL;
                    TCHAR *pszEnd;
                    TCHAR terminator;

                    while ( _istspace( *psz ) )
                        psz++;
                    if ( *psz == _T('\'') || *psz == _T('"') )
                    {
                        quote = psz++;
                    }
                    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
                    pszEnd = pch + nLenIn - 1;
                    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
                        pszEnd--;
                    if ( quote && ( *pszEnd == *quote ) )
                        pszEnd--;
                    terminator = *(pszEnd+1);
                    *(pszEnd+1) = _T('\0');

                    pchCustom = psz;
                }
                else
                {
                    pchCustom =(TCHAR*) pv;
                }
            }
            else
                pchCustom = (TCHAR*) pv;
        }
        else
            goto Cleanup;

    }
    else
    {
        if ( lNewValue == lOldValue )
            goto Cleanup;

        hr = ValidateNumberProperty( &lNewValue, pObject);
        if (hr)
            goto Cleanup;
    }
    
#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            CVariant      varOld;

            if (fOldPresent)
            {
                ENUMDESC *    pEnumDesc;
                const TCHAR * pchOldValue;

                if ( bpp.dwPPFlags & PROPPARAM_ANUMBER )
                {
                    pEnumDesc = *(ENUMDESC **)((BYTE *)(this+1)+ sizeof(DWORD_PTR));
                }
                else
                {
                    pEnumDesc = (ENUMDESC *) lMax;
                }

                pchOldValue = pEnumDesc->StringPtrFromEnum( lOldValue );

                V_VT(&varOld) = VT_BSTR;
                hr = FormsAllocString(pchOldValue, &V_BSTR(&varOld));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                V_VT(&varOld) = VT_NULL;
            }
        
            if( fTreeSync )
            {
                VARIANT    varNew;

                // NOTE: Someone (maybe editing) is cheating here - 
                // bstrNew is NOT a real bstr. 
                varNew.vt = VT_LPWSTR;
                varNew.byref = bstrNew;

                pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
            }
        
            if( fCreateUndo )
            {
                hr = THR( pObject->CreatePropChangeUndo( bpp.dispid, &varOld, NULL ) );
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT
    
    if ( ! pchCustom )
    {
        hr = SetNumber(pObject, pSubObject, lNewValue, wFlags );
        if (hr)
            goto Cleanup;
    }
    else
    {
        const PROPERTYDESC* pDesc = GetPropertyDesc();
        lNewValue = pDesc->GetInvalidDefault() - 1; 
        
        hr = SetCustomNumber( pObject, pSubObject, lNewValue, wFlags,pchCustom );
    }
    
    hr = THR(pObject->OnPropertyChange(bpp.dispid, bpp.dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    CHECK_HEAP();

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, bpp.dispid));
}

HRESULT
NUMPROPPARAMS::GetEnumStringProperty(BSTR *pbstr, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;
    VARIANT varValue;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    if(!pbstr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pSubObject)
    {
        pSubObject = pObject;
    }


	hr = THR(ppdPropDesc->HandleNumProperty( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT<<16), 
        (void *)&varValue, pObject, pSubObject ));
    if ( !hr )
        *pbstr = V_BSTR(&varValue);

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, bpp.dispid));
}

//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetStringProperty, public
//
//  Synopsis:   Helper for setting string valued properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetStringProperty(BSTR *pbstr, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    if(!pbstr)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CStr    cstr;

        // CONSIDER: (anandra) Possibly have a helper here that returns
        // a bstr to avoid two allocations.
        hr = THR(GetString(pSubObject, &cstr));
        if (hr)
            goto Cleanup;
        hr = THR(cstr.AllocBSTR(pbstr));
    }

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, dispid));
}


//+---------------------------------------------------------------
//
//  Function:   SetUrl
//
//  Synopsis:   Helper for setting url string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetUrl(CVoid * pObject, TCHAR * pch, WORD wFlags) const
{
    HRESULT hr = S_OK;
    TCHAR   *pstrNoCRLF=NULL;

    hr = THR(StripCRLF(pch, &pstrNoCRLF));
    if (hr)
        goto Cleanup;

    hr =THR(SetString(pObject, pstrNoCRLF, wFlags));

Cleanup:
    if (pstrNoCRLF)
        MemFree(pstrNoCRLF);

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:     SetUrlProperty, public
//
//  Synopsis:   Helper for setting url-string values properties
//     strip off CR/LF and call setString
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetUrlProperty(BSTR bstrNew, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    HRESULT   hr=S_OK;
    TCHAR    *pstrNoCRLF=NULL;

    hr = THR(StripCRLF((TCHAR*)bstrNew, &pstrNoCRLF));
    if (hr)
        goto Cleanup;

    // SetStringProperty calls Set ErrorInfoPSet
    hr = THR(SetStringProperty(pstrNoCRLF, pObject, pSubObject, wFlags));

Cleanup:
    if (pstrNoCRLF)
        MemFree(pstrNoCRLF);

    RRETURN(pObject->SetErrorInfoPSet(hr, dispid));
}

//+---------------------------------------------------------------
//
//  Function:   GetUrl
//
//  Synopsis:   Helper for getting url-string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetUrl(CVoid * pObject, CStr * pcstr) const
{
    RRETURN( GetString(pObject, pcstr) );
}


//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetUrlProperty, public
//
//  Synopsis:   Helper for setting url string valued properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetUrlProperty(BSTR *pbstr, CBase * pObject, CVoid * pSubObject) const
{
    // SetString does the SetErrorInfoPGet
    RRETURN( GetStringProperty(pbstr, pObject, pSubObject));
}

//+---------------------------------------------------------------
//
//  Function:   GetNumber
//
//  Synopsis:   Helper for getting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::GetNumber (CBase * pObject, CVoid * pSubObject, long * plNum, BOOL *pfValuePresent) const
{
    HRESULT hr = S_OK;

    if (bpp.dwPPFlags & PROPPARAM_GETMFHandler)
    {
        PFN_NUMPROPGET pmfGet;

        bpp.GetGetMethodP(this + 1, &pmfGet);

        hr = CALL_METHOD((CVoid*)(void*)pObject,pmfGet,(plNum));
        if (pfValuePresent)
            *pfValuePresent = TRUE;
    }
    else
    {
        *plNum = bpp.GetAvNumber ( pSubObject, this + 1, cbMember, pfValuePresent );
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Function:   SetCustomNumber
//
//  Synopsis:   Helper for setting custom number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::SetCustomNumber (CBase * pObject, CVoid * pSubObject, long lNum, WORD wFlags, TCHAR* pchCustom /*=NULL*/) const
{
    HRESULT hr = S_OK;

    hr = THR( bpp.SetAvNumber (pSubObject, (DWORD)lNum, this + 1, cbMember, wFlags ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( bpp.SetString( pSubObject, pchCustom, wFlags ));
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Function:   SetNumber
//
//  Synopsis:   Helper for setting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::SetNumber (CBase * pObject, CVoid * pSubObject, long lNum, WORD wFlags ) const
{
    HRESULT hr = S_OK;

    if (bpp.dwPPFlags & PROPPARAM_SETMFHandler)
    {
        PFN_NUMPROPSET pmfSet;

        bpp.GetSetMethodP(this + 1, &pmfSet);

        hr = CALL_METHOD((CVoid*)(void*)pObject,pmfSet,(lNum));
    }
    else
    {
        hr = THR( bpp.SetAvNumber (pSubObject, (DWORD)lNum, this + 1, cbMember, wFlags) );
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     ValidateNumberProperty, public
//
//  Synopsis:   Helper for testing the validity of numeric properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::ValidateNumberProperty(long *lArg, CBase * pObject ) const
{
    long lMinValue = 0, lMaxValue = LONG_MAX;
    HRESULT hr = S_OK;
    int ids = 0;
    const PROPERTYDESC *pPropDesc = (const PROPERTYDESC *)this -1;

    if (vt == VT_BOOL || vt == VT_BOOL4)
        return S_OK;

    // Check validity of input argument
    if ( bpp.dwPPFlags & PROPPARAM_UNITVALUE )
    {
        CUnitValue uv;
        uv.SetRawValue ( *lArg );
        hr = uv.IsValid( pPropDesc );
        if ( hr )
        {
            if (bpp.dwPPFlags & PROPPARAM_MINOUT)
            {
                // set value to min;
                *lArg = lMin;
                hr = S_OK;
            }
            else
            {
                    //otherwise return error, i.e. set to default
                ids = IDS_ES_ENTER_PROPER_VALUE;
            }
        }
        goto Cleanup;
    }

    if ( ( ( bpp.dwPPFlags & PROPPARAM_ENUM )  && ( bpp.dwPPFlags & PROPPARAM_ANUMBER) )
        || !(bpp.dwPPFlags & PROPPARAM_ENUM) )
    {
        lMinValue = lMin; lMaxValue = lMax;
        if( (*lArg < lMinValue || *lArg > lMaxValue) && 
            *lArg != (long)pPropDesc->GetNotPresentDefault() &&
            *lArg != (long)pPropDesc->GetInvalidDefault() )
        {
            if (lMaxValue != LONG_MAX)
            {
                ids = IDS_ES_ENTER_VALUE_IN_RANGE;
            }
            else if (lMinValue == 0)
            {
                ids = IDS_ES_ENTER_VALUE_GE_ZERO;
            }
            else if (lMinValue == 1)
            {
                ids = IDS_ES_ENTER_VALUE_GT_ZERO;
            }
            else
            {
                ids = IDS_ES_ENTER_VALUE_IN_RANGE;
            }
            hr = E_INVALIDARG;
        }
        else
        {
            // inside of range
            goto Cleanup;
        }
    }

    // We have 3 scenarios to check for :-
    // 1) Just a number validate w min & max
    // 2) Just an emum validated w pEnumDesc
    // 3) A number w. min & max & one or more enum values

    // If we've got a number OR enum type, first check the
    if ( bpp.dwPPFlags & PROPPARAM_ENUM )
    {
        ENUMDESC *pEnumDesc = pPropDesc->GetEnumDescriptor();

        Assert(pEnumDesc);

        // dwMask represent a mask allowing or rejecting values 0 to 31
        if(*lArg >= 0 && *lArg < 32 )
        {
            if (!((pEnumDesc -> dwMask >> (DWORD)*lArg) & 1))
            {
                if ( !hr )
                {
                    ids = IDS_ES_ENTER_PROPER_VALUE;
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = S_OK;
            }
        }
        else
        {
            // If it's not in the mask, look for the value in the array
            WORD i;

            for ( i = 0 ; i < pEnumDesc -> cEnums ; i++ )
            {
                if ( pEnumDesc -> aenumpairs [ i ].iVal == *lArg )
                {
                    break;
                }
            }
            if ( i == pEnumDesc -> cEnums )
            {
                if ( !hr )
                {
                    ids = IDS_ES_ENTER_PROPER_VALUE;
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = S_OK;
            }
        }
    }

Cleanup:
    if ( hr && ids == IDS_ES_ENTER_PROPER_VALUE )
    {
        RRETURN1 ( pObject->SetErrorInfoPBadValue ( bpp.dispid, ids ), E_INVALIDARG );
    }
    else if ( hr )
    {
        RRETURN1 (pObject->SetErrorInfoPBadValue(
                    bpp.dispid,
                    ids,
                    lMinValue,
                    lMaxValue ),E_INVALIDARG );
    }
    else
        return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CBase::GetNumberProperty, public
//
//  Synopsis:   Helper for getting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::GetNumberProperty(void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;
    long num;

    if(!pv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetNumber(pObject, pSubObject, &num);
    if (hr)
        goto Cleanup;

    SetNumberOfType(pv, VARENUM(vt), num);

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, bpp.dispid));
}


//+---------------------------------------------------------------
//
//  Member:     SetNumberProperty, public
//
//  Synopsis:   Helper for setting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::SetNumberProperty(long lValueNew, CBase * pObject, CVoid * pSubObject, BOOL fValidate /* = TRUE */, WORD wFlags ) const
{
    CBase::CLock    Lock(pObject);
    HRESULT     hr;
    long        lValueOld;
    BOOL        fOldPresent;
    BOOL        fRuntimeStyle = (CAttrValue::AA_Extra_RuntimeStyle == wFlags);

    //
    // Get the current value of the property
    //
    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetNumber(pObject, pSubObject, &lValueOld, &fOldPresent);
    if (hr)
        goto Cleanup;

    //
    // Validate the old value, just for kicks...
    //

    //
    // If the old and new values are the same and the old value was actually set,
    // then git out of here
    //

    if (lValueNew == lValueOld && (fOldPresent || !fRuntimeStyle))
        goto Cleanup;

    //
    // Make sure the new value is OK
    //

    if ( fValidate )
    {
        // Validate using propdesc encoded parser rules 
        hr = THR(ValidateNumberProperty(&lValueNew, pObject ));
        if (hr)
            return hr;  // Error info set in validate
    }

    //
    // Create the undo thing-a-ma-jig
    //

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );
 
        if ( fCreateUndo || fTreeSync )
        {
            CVariant  varOld;
            TCHAR     achValueOld[30];

            // Handle CUnitValues as BSTRs, everything else as plain numbers.

            if ( !fOldPresent )
            {
                V_VT(&varOld) = VT_NULL;
            }

#if defined(_MAC)
            else if ( GetPropertyDesc()->pfnHandleProperty ==
                 &PROPERTYDESC::HandleUnitValueProperty )
#else
            else if ( GetPropertyDesc()->pfnHandleProperty ==
                 PROPERTYDESC::HandleUnitValueProperty )
#endif
            {
                CUnitValue uv;

                uv.SetRawValue( lValueOld );

                if (uv.IsNull())
                {
                    V_VT(&varOld) = VT_BSTR;
                }
                else
                {
                    hr = uv.FormatBuffer( achValueOld, ARRAY_SIZE( achValueOld ),
                                          GetPropertyDesc() );
                    if ( hr )
                        goto Cleanup;

                    V_VT(&varOld) = VT_BSTR;
                    hr = FormsAllocString(achValueOld, &V_BSTR(&varOld));
                    if (hr)
                        goto Cleanup;
                }
            }
            else if ( GetPropertyDesc()->pfnHandleProperty == PROPERTYDESC::HandleEnumProperty )
            {
                ENUMDESC * pEnumDesc = GetPropertyDesc()->GetEnumDescriptor();

                Assert( pEnumDesc );

                V_VT(&varOld) = VT_BSTR;
                hr = THR( FormsAllocString( pEnumDesc->StringPtrFromEnum( lValueOld ), &V_BSTR(&varOld) ) );
                if( hr )
                    goto Cleanup;
            }
            else
            {
                AssertSz( vt == VT_I4 || vt == VT_I2 || vt == VT_BOOL || vt == VT_BOOL4, "Bad vt" );

                V_VT(&varOld) = vt;
                V_I4(&varOld) = lValueOld;
            }

            if( fTreeSync )
            {
                VARIANT    varNew;
                TCHAR      achValueNew[30];

                // UnitValues need to be converted to BSTR's.
                if( GetPropertyDesc()->pfnHandleProperty == PROPERTYDESC::HandleUnitValueProperty )
                {
                    CUnitValue uv( lValueNew );

                    if( SUCCEEDED( uv.FormatBuffer( achValueNew, ARRAY_SIZE( achValueNew ), GetPropertyDesc() ) ) )
                    {
                        varNew.vt = VT_LPWSTR;
                        varNew.byref = achValueNew;
                        pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
                    }
                }
                else if( GetPropertyDesc()->pfnHandleProperty == PROPERTYDESC::HandleEnumProperty )
                {
                    ENUMDESC * pEnumDesc = GetPropertyDesc()->GetEnumDescriptor();

                    Assert( pEnumDesc );

                    varNew.vt = VT_LPWSTR;
                    varNew.byref = (void *)( const_cast<TCHAR *>( pEnumDesc->StringPtrFromEnum( lValueNew ) ) );
                    pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
                }
                else
                {
                    V_VT( &varNew ) = VT_I4;
                    V_I4( &varNew ) = lValueNew;

                    pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
                }
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(bpp.dispid, &varOld, NULL));
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT

    //
    // Stuff the new value in
    //

    hr = THR(SetNumber(pObject, pSubObject, lValueNew, wFlags));
    if (hr)
        goto Cleanup;

    //
    // Tell everybody about the new value
    //

    hr = THR(pObject->OnPropertyChange(bpp.dispid, bpp.dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    //
    // If anybody complained, then revert
    //

    if (hr)
    {
        IGNORE_HR(SetNumber(pObject, pSubObject, lValueOld, wFlags));
        IGNORE_HR(pObject->OnPropertyChange(bpp.dispid, bpp.dwFlags, (PROPERTYDESC *)GetPropertyDesc()));
    }

Cleanup:
    RRETURN(pObject->SetErrorInfoPSet(hr, bpp.dispid));
}




HRESULT BUGCALL
PROPERTYDESC::HandleUnitValueProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr = S_OK,hr2;
    const NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(this + 1);
    const BASICPROPPARAMS *bpp = (BASICPROPPARAMS *)ppp;
    CVariant varDest;
    LONG lNewValue;
    long lTemp = 0;
    BOOL fValidated = FALSE;

    // The code in this fn assumes that the address of the object
    // is the address of the long value
    if (ISSET(dwOpCode))
    {
        CUnitValue uvValue;
        uvValue.SetDefaultValue();
        LPCTSTR pStr = (TCHAR *)pv;

        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...

        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
FromString:
            if ( pStr == NULL || !pStr[0] )
            {
                lNewValue = GetNotPresentDefault();
            }
            else
            {
                hr = uvValue.FromString ( pStr, this, dwOpCode & HANDLEPROP_STRICTCSS1 );
                if ( !hr )
                {
                    lNewValue = uvValue.GetRawValue ();
                    if ( !(dwOpCode & HANDLEPROP_DONTVALIDATE ) )
                        hr = uvValue.IsValid( this );
                }

                if ( hr == E_INVALIDARG )
                {
                    // If in strict css1 ignore invalid values
                    if (dwOpCode & HANDLEPROP_STRICTCSS1)
                        goto Cleanup;

                    // Ignore invalid values when parsing a stylesheet
                    if(IsStyleSheetProperty())
                        goto Cleanup;

                    lNewValue = GetInvalidDefault();
                }
                else if ( hr )
                {
                    goto Cleanup;
                }
            }
            // If we're just sniffing for a good parse - don't set up a default
            if ( hr && ISSAMPLING( dwOpCode ) )
                goto Cleanup;
            fValidated = TRUE;
            pv = &lNewValue;
            break;
                                             
        case PROPTYPE_VARIANT:
            {
                VARIANT *pVar = (VARIANT *)pv;

                switch ( pVar -> vt )
                {
                default:
                    hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pVar, VT_BSTR);
                    if (hr)
                        goto Cleanup;

                    pVar = &varDest;

                    // Fall thru to VT_BSTR code below

                case VT_BSTR:
                    pStr = pVar -> bstrVal;
                    goto FromString;

                case VT_NULL:
                    lNewValue = 0;
                    break;

                }
                pv = &lNewValue;
            }
            break;

        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }

        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
            // Set default Value from propdesc
            hr = ppp->SetNumber(pObject, pSubObject,
                (long)ulTagNotPresentDefault, wFlags );
            goto Cleanup;


        case HANDLEPROP_AUTOMATION:
            if ( hr )
                goto Cleanup;

			// The unit value handler can be called directly through automation
			// This is pretty unique - we usualy have a helper fn
            hr = HandleNumProperty(SETPROPTYPE(dwOpCode, PROPTYPE_EMPTY),
				pv, pObject, pSubObject);
            if (hr)
                goto Cleanup;
			break;

        case HANDLEPROP_VALUE:
            if ( !fValidated )
            {
                // We need to preserve an existing error code if there is one
                hr2 = ppp->ValidateNumberProperty((long *)pv, pObject);
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }
            hr2 = ppp->SetNumber(pObject, pSubObject, *(long *)pv, wFlags);
            if (hr2)
            {
                hr = hr2;
                goto Cleanup;
            }

            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr2 = THR(pObject->OnPropertyChange(bpp->dispid, bpp->dwFlags, (PROPERTYDESC *)this));
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }

            break;
        }
        RRETURN1(hr, E_INVALIDARG);
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            hr = ppp->GetNumberProperty(&lTemp, pObject, pSubObject);
            if ( hr )
                goto Cleanup;
            // Coerce to type
            {
                BSTR *pbstr = (BSTR *)pv;

                switch(PROPTYPE(dwOpCode))
                {
                case PROPTYPE_VARIANT:
                    // pv points to a VARIANT
                    VariantInit ( (VARIANT *)pv );
                    V_VT ( (VARIANT *)pv ) = VT_BSTR;
                    pbstr = &V_BSTR((VARIANT *)pv);
                    // intentional fall-through
                case PROPTYPE_BSTR:
                    {
                        TCHAR cValue [ 30 ];


                        CUnitValue uvThis;
                        uvThis.SetRawValue ( lTemp );

                        if ( uvThis.IsNull() )
                        {
                            // Return an empty BSTR
                            hr = FormsAllocString( g_Zero.ach, pbstr );
                        }
                        else
                        {
                            hr = uvThis.FormatBuffer ( (LPTSTR)cValue, (UINT)ARRAY_SIZE ( cValue ), this );
                            if ( hr )
                                goto Cleanup;

                            hr = THR(FormsAllocString( cValue, pbstr ));
                        }
                    }
                    break;

                    default:
                        *(long *)pv = lTemp;
                        break;
                }
            }
            goto Cleanup;
            break;

        case HANDLEPROP_VALUE:
            {
                CUnitValue uvValue;

                // get raw value
                hr = ppp->GetNumber(pObject, pSubObject, (long *)&uvValue);

                if (PROPTYPE(dwOpCode) == VT_VARIANT)
                {
                    ((VARIANT *)pv)->vt = VT_I4;
                    ((VARIANT *)pv)->lVal = uvValue.GetUnitValue();
                }
                else if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
                {
                    TCHAR cValue [ 30 ];

                    hr = uvValue.FormatBuffer ( (LPTSTR)cValue, (UINT)ARRAY_SIZE ( cValue ), this );
                    if ( hr )
                        goto Cleanup;

                    hr = THR( FormsAllocString( cValue, (BSTR *)pv ) );
                }
                else
                {
                    Assert(PROPTYPE(dwOpCode) == 0);
                    *(long *)pv = uvValue.GetUnitValue();
                }
            }
            goto Cleanup;

        case HANDLEPROP_COMPARE:
            hr = ppp->GetNumber(pObject, pSubObject, &lTemp);
            if (hr)
                goto Cleanup;
            // if inherited and not set, return S_OK
            hr = ( lTemp == *(long *)pv ) ? S_OK : S_FALSE;
            RRETURN1 (hr, S_FALSE);
            break;

        case HANDLEPROP_STREAM:
            {
            // Get value into an IStream
            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);

            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if (hr)
                goto Cleanup;

            CUnitValue uvValue;
            uvValue.SetRawValue ( lNewValue );

            hr = uvValue.Persist ( (IStream *)pv, this );

            goto Cleanup;
            }
            break;

        }
    }
    // Let the basic numproperty handler handle all other cases
    hr = HandleNumProperty ( dwOpCode, pv, pObject, pSubObject );
Cleanup:
    RRETURN1(hr, E_INVALIDARG);
}


HRESULT LookupEnumString ( const NUMPROPPARAMS *ppp, LPCTSTR pStr, long *plNewValue )
{
    HRESULT hr = S_OK;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)ppp)-1;
    ENUMDESC *pEnumDesc = ppdPropDesc->GetEnumDescriptor();
        
    if (pEnumDesc == NULL)
    {
        RRETURN(E_INVALIDARG);
    }
    
    // ### v-gsrir - Modified the 3rd parameter to result in a 
    // Bool instead of a DWORD - which was resulting in the parameter
    // being taken as 0 always.
    hr = pEnumDesc->EnumFromString ( pStr, plNewValue,( 
        ppp->bpp.dwPPFlags & PROPPARAM_CASESENSITIVE ) ? TRUE:FALSE);

    if ( hr == E_INVALIDARG )
    {
        if ( ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER )
        {
            // Not one of the enums, is it a number??
            hr = ttol_with_error( pStr, plNewValue);
        }
    }
    RRETURN(hr);
}

// Don't call this function outside of automation - loads oleaut!
HRESULT LookupStringFromEnum( const NUMPROPPARAMS *ppp, BSTR *pbstr, long lValue )
{
    ENUMDESC *pEnumDesc;

    Assert( (ppp->bpp.dwPPFlags&PROPPARAM_ENUM) && "Can't convert a non-enum to an enum string!" );

    if ( ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER )
    {
        pEnumDesc = *(ENUMDESC **)((BYTE *)(ppp+1)+ sizeof(DWORD_PTR));
    }
    else
    {
        pEnumDesc = (ENUMDESC *) ppp->lMax;
    }

    RRETURN1( pEnumDesc->StringFromEnum( lValue, pbstr ), S_FALSE );
}

BOOL 
PROPERTYDESC::IsBOOLProperty ( void ) const
{                        
    return  ( pfnHandleProperty == &PROPERTYDESC::HandleNumProperty &&
        ((NUMPROPPARAMS *)(this + 1))-> vt == VT_BOOL  ) ? TRUE : FALSE;
}

//
// Determine if a custom url property is a "composite" url
//
// if it isn't we add back a url('...') around the property
// if it is - we leave it alone.
// 
HRESULT 
UnMungeCustomUrl( CStr* pcstrUrlOrig, CStr* pcstrResult )
{
    HRESULT hr;
    
    if ( ! IsCompositeUrl ( pcstrUrlOrig ))
    {
        CStr cstrEnd;
    
        IFC( pcstrResult->Set(_T("url('")));
        IFC( cstrEnd.Set(_T("')")));            
        IFC( pcstrResult->Append( *pcstrUrlOrig ));
        IFC( pcstrResult->Append( cstrEnd ));        
    }
    else
    {
        IFC( pcstrResult->Set( *pcstrUrlOrig ));
    }
    
Cleanup:
    RRETURN ( hr );
}

//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleNumProperty, public
//
//  Synopsis:   Helper for getting/setting number value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (long in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleNumProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT             hr = S_OK, hr2;
    const NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(this + 1);
    const BASICPROPPARAMS *bpp = (BASICPROPPARAMS *)ppp;
    VARIANT             varDest;
    LONG                lNewValue, lTemp = 0;
    CStreamWriteBuff    *pStmWrBuff;
    VARIANT             *pVariant;
    VARIANT             varTemp;
    varDest.vt = VT_EMPTY;
    TCHAR*              pchCustom = NULL ;
    
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            // If the parameter is a BOOL, the presence of the value sets the value
            if ( ppp -> vt == VT_BOOL )
            {
                // For an OLE BOOL -1 == True
                lNewValue = -1;
            }
            else
            {
SetFromString:
                LPTSTR pStr = (TCHAR *)pv;
                hr = S_OK;
                if ( pStr == NULL || !pStr[0] )
                {
                    // Just have Tag=, set to not assigned value
                    lNewValue = GetNotPresentDefault();
                }
                else
                {                
                    if ( !(ppp->bpp.dwPPFlags & PROPPARAM_ENUM) )
                    {
                        hr = ttol_with_error( pStr, &lNewValue);
                    }
                    else
                    {
                        // enum string, look it up
                        hr = LookupEnumString ( ppp, pStr, &lNewValue );
                    }
                    if ( hr )
                    {
                        //
                        // For custom Enum's we'll currently treat these as strings.
                        //
                        if (  ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM )
                        {
                            //
                            // TODO - move all URL parsing code to the custom cursor class.
                            //
                            
                            //
                            // TODO - expand propdesc to include a generic "custom" 
                            // identifier. Like is done for defaults.
                            // currently the only CustomENUM type is cursor
                            // but if we want to expand this - we need to expand this mechanism
                            //
                            // For now - just make custom type be invalidDefault - 1
                            // 
                            Assert( ppp->bpp.dispid == DISPID_A_CURSOR );
                            
                            lNewValue = GET_CUSTOM_VALUE() ; 
                            
                            if ( ContainsUrl ( (TCHAR*) pv ))
                            {
                                int nLenIn = ValidStyleUrl((TCHAR*) pv);
                                if ( nLenIn > 0 )
                                {
                                    TCHAR *pch = (TCHAR*) pv;
                                    TCHAR *psz = pch+4;
                                    TCHAR *quote = NULL;
                                    TCHAR *pszEnd;
                                    TCHAR terminator;

                                    dwOpCode |= HANDLEPROP_URLENCLOSE;

                                    while ( _istspace( *psz ) )
                                        psz++;
                                    if ( *psz == _T('\'') || *psz == _T('"') )
                                    {
                                        quote = psz++;
                                    }
                                    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
                                    pszEnd = pch + nLenIn - 1;
                                    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
                                        pszEnd--;
                                    if ( quote && ( *pszEnd == *quote ) )
                                        pszEnd--;
                                    terminator = *(pszEnd+1);
                                    *(pszEnd+1) = _T('\0');

                                    pchCustom = psz;
                                }
                                else
                                {
                                    pchCustom =(TCHAR*) pv;
                                }
                            }
                            else
                            {
                                lNewValue = GetInvalidDefault();
                            }
                        }
                        else
                            lNewValue = GetInvalidDefault();
                    }
                }
            }
            // If we're just sniffing for a good parse - don't set up a default
            if ( hr && ISSAMPLING( dwOpCode ) )
                goto Cleanup;
            pv = &lNewValue;
            break;

        case PROPTYPE_VARIANT:        
            if ( pv == NULL )
            {
                // Just have Tag=, ignore it
                return S_OK;
            }
            VariantInit ( &varDest );
            if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
            {          
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv, VT_BSTR);
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
                // Send it through the String handler
                goto SetFromString;
            }
            else
            {            
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv, VT_I4);
                if (hr)
                    goto Cleanup;
                pv = &V_I4(&varDest);
            }
            break;
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }
        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        if ( dwOpCode & HANDLEPROP_RUNTIMESTYLE )
            wFlags |= CAttrValue::AA_Extra_RuntimeStyle;
            
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
        
            // We need to preserve an existing hr
            hr2 = ppp->ValidateNumberProperty((long *)pv, pObject);
            if (hr2)
            {
                hr = hr2;
                goto Cleanup;
            }

            hr2 = !pchCustom ? ppp->SetNumber(pObject, pSubObject, *(long *)pv, wFlags) :
                               ppp->SetCustomNumber( pObject, pSubObject,*(long*)pv, wFlags, pchCustom );
            if ( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }

            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr2 = THR(pObject->OnPropertyChange(bpp->dispid, bpp->dwFlags, (PROPERTYDESC *)this));
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }
            break;
            
        case HANDLEPROP_AUTOMATION:
        
            if ( hr )
                goto Cleanup;
            hr = ppp->SetNumberProperty(*(long *)pv, pObject, pSubObject,
                dwOpCode & HANDLEPROP_DONTVALIDATE ? FALSE : TRUE, wFlags );
            break;

        case HANDLEPROP_DEFAULT:
        
            Assert(pv == NULL);
            hr = !pchCustom ? ppp->SetNumber(pObject, pSubObject,(long)ulTagNotPresentDefault, wFlags) :
                              ppp->SetCustomNumber( pObject, pSubObject,(long)ulTagNotPresentDefault, wFlags, pchCustom );
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }
    else
    {        
        BOOL fFoundString = FALSE;
        CStr cstrCustom; 
        
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            hr = ppp->GetNumberProperty( &lTemp, pObject, pSubObject);
            if ( hr )
                goto Cleanup;
        
            if (  ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM && 
                 (unsigned) lTemp == GET_CUSTOM_VALUE() )
            {                
                fFoundString = TRUE;
                hr = THR( ppp->bpp.GetCustomString(  pSubObject, & cstrCustom ));
            }
            else
            {
                hr = ppp->GetNumberProperty( &lTemp, pObject, pSubObject);
                if ( hr )
                    goto Cleanup;            
            }         
            
            switch(PROPTYPE(dwOpCode))
            {
                case PROPTYPE_VARIANT:
                    pVariant = (VARIANT *)pv;
                    VariantInit ( pVariant );
                    if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
                    {
                        if ( ! fFoundString )
                        {
                            hr = LookupStringFromEnum( ppp, &V_BSTR(pVariant), lTemp );
                            if ( !hr )
                            {
                                V_VT( pVariant ) = VT_BSTR;
                            }
                            else
                            {
                                if ( hr != E_INVALIDARG)
                                    goto Cleanup;

                                hr = S_OK;
                            }
                        }
                        else
                        {
                            BSTR bstrCustom;
                            CStr cstrUnMunged;
                            hr = THR( UnMungeCustomUrl( & cstrCustom, & cstrUnMunged ));
                            if ( hr )
                                goto Cleanup;
                                
                            cstrUnMunged.AllocBSTR( & bstrCustom );

                            V_VT( pVariant ) = VT_BSTR;
                            V_BSTR( pVariant ) = bstrCustom;
                        }
                    }
                    if ( V_VT ( pVariant ) == VT_EMPTY )
                    {
                        V_VT ( pVariant ) = VT_I4;
                        V_I4 ( pVariant ) = lTemp;
                    }
                    break;

                case PROPTYPE_BSTR:
                    *((BSTR *)pv) = NULL;
                    if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
                    {
                        if ( ! ( (ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM) &&
                                  fFoundString ) )
                        {                   
                            hr = LookupStringFromEnum( ppp, (BSTR *)pv, lTemp );
                        }
                        else
                        {                            
                            CStr cstrEnd;
                            IFC( UnMungeCustomUrl( &cstrCustom, & cstrEnd ));
                            
                            IFC( cstrEnd.AllocBSTR( (BSTR*) pv  ));                            
                        }
                    }
                    else
                    {
                        TCHAR szNumber[33];
                        hr = THR( Format(0, szNumber, 32, _T("<0d>"), lTemp ) );
                        if ( hr == S_OK )
                            hr = FormsAllocString( szNumber, (BSTR *)pv );
                    }
                    break;

                default:
                    *(long *)pv = lTemp;
                    break;
            }
            break;

        case HANDLEPROP_STREAM:
            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if (hr)
                goto Cleanup;
            pStmWrBuff = (CStreamWriteBuff *)pv;
            // If it's one of the enums, save out the enum string
            if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
            {
                if ( ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM && 
                     (unsigned) lNewValue == GET_CUSTOM_VALUE() )
                {
                    CStr    cstr, cstrResult;
                    
                    hr = THR( ppp->bpp.GetCustomString( pSubObject, & cstr ));
                    if ( hr )
                        goto Cleanup;
                    
                    IFC( UnMungeCustomUrl( & cstr, & cstrResult ));
                            
                    hr = pStmWrBuff->WriteQuotedText( (LPTSTR) cstrResult, FALSE);
                    if ( hr )
                        goto Cleanup;                    

                    goto Cleanup;                        
                }
                
                INT i;
                ENUMDESC *pEnumDesc = GetEnumDescriptor();
                // until the binary persistance we assume text save
                for (i = pEnumDesc->cEnums - 1; i >= 0; i--)
                {
                    if (lNewValue == pEnumDesc->aenumpairs[i].iVal)
                    {
                        hr = pStmWrBuff->WriteQuotedText(pEnumDesc->aenumpairs[i].pszName, FALSE);
                        goto Cleanup;
                    }
                }
            }
            // Either don't have an enum array or wasn't one of the enum values
            hr = WriteTextLong(pStmWrBuff, lNewValue);
            break;

        case HANDLEPROP_VALUE:
            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if ( hr )
                goto Cleanup;
            switch (PROPTYPE(dwOpCode))
            {
            case VT_VARIANT:
                {
                ENUMDESC *pEnumDesc = GetEnumDescriptor();
                if ( pEnumDesc )
                {
                    hr = pEnumDesc->StringFromEnum ( lNewValue, &V_BSTR((VARIANT *)pv) );
                    if ( !hr )
                    {
                        ((VARIANT *)pv)->vt = VT_BSTR;
                        goto Cleanup;
                    }
                }

                // if the Numeric prop is boolean...
                if (GetNumPropParams()->vt == VT_BOOL)
                {
                    ((VARIANT *)pv)->boolVal = (VARIANT_BOOL)lNewValue;
                    ((VARIANT *)pv)->vt = VT_BOOL;
                    break;
                }

                // Either mixed enum/integer or plain integer return I4
                ((VARIANT *)pv)->lVal = lNewValue;
                ((VARIANT *)pv)->vt = VT_I4;
                }
                break;

            case VT_BSTR:
                {
                    ENUMDESC *pEnumDesc = GetEnumDescriptor();
                    if ( pEnumDesc )
                    {
                        hr = pEnumDesc->StringFromEnum ( lNewValue, (BSTR *)pv );
                        if ( !hr )
                        {
                            goto Cleanup;
                        }
                    }
                    // Either mixed enum/integer or plain integer return BSTR
                    varTemp.lVal = lNewValue;
                    varTemp.vt = VT_I4;   
                    hr = VariantChangeTypeSpecial ( &varTemp, &varTemp, VT_BSTR );
                    *(BSTR *)pv = V_BSTR(&varTemp);
                }
                break;

            default:
                Assert(PROPTYPE(dwOpCode) == 0);
                *(long *)pv = lNewValue;
                break;
            }
            break;

        case HANDLEPROP_COMPARE:
            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if (hr)
                goto Cleanup;
            hr = ( lNewValue == *(long *)pv ) ? S_OK : S_FALSE;
            RRETURN1(hr,S_FALSE);
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }

Cleanup:

    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }

    RRETURN1(hr, E_INVALIDARG);
}

BOOL
ContainsUrl(TCHAR* pch)
{
    size_t i;
    size_t iSize = ARRAY_SIZE(strURLBeg) - 1;
    
    size_t nLen = pch ? _tcslen(pch) : 0 ;

    if ( nLen < iSize )
        return FALSE;
        
    for( i = 0; 
         i< nLen -  iSize ; 
         i++,pch++ )
    {
        if (0==_tcsnicmp(pch, iSize, strURLBeg, iSize))
        {
            return TRUE;
        }        
    }
    return FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleStringProperty, public
//
//  Synopsis:   Helper for getting/setting string value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (CStr in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------


HRESULT
PROPERTYDESC::HandleStringProperty(DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK;
    BASICPROPPARAMS * ppp = (BASICPROPPARAMS *)(this + 1);
    VARIANT     varDest;

    varDest.vt = VT_EMPTY;
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            break;
        case PROPTYPE_VARIANT:
            if (V_VT((VARIANT *)pv) == VT_BSTR)
            {
                pv = (void *)V_BSTR((VARIANT *)pv);
            }
            else
            {
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR);
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
            }
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }
        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        if ( dwOpCode & HANDLEPROP_URLENCLOSE )
            wFlags |= CAttrValue::AA_Extra_UrlEnclosed;
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
            Assert(pv == NULL);
            pv = (void *)ulTagNotPresentDefault;

            if (!pv)
                goto Cleanup;       // zero string

            // fall thru
        case HANDLEPROP_VALUE:
            hr = ppp->SetString(pSubObject, (TCHAR *)pv, wFlags);
            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr = THR(pObject->OnPropertyChange(ppp->dispid, ppp->dwFlags, (PROPERTYDESC *)this));
                if (hr)
                    goto Cleanup;
            }
            break;
        case HANDLEPROP_AUTOMATION:
            hr = ppp->SetStringProperty( (TCHAR *)pv, pObject, pSubObject, wFlags );
            break;
        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            {
                BSTR bstr;
                hr = ppp->GetStringProperty( &bstr, pObject, pSubObject );
                if(hr)
                    goto Cleanup;
                switch(PROPTYPE(dwOpCode))
                {
                case PROPTYPE_VARIANT:
                    V_VT((VARIANTARG *)pv) = VT_BSTR;
                    V_BSTR((VARIANTARG *)pv) = bstr;
                    break;
                case PROPTYPE_BSTR:
                    *(BSTR *)pv = bstr;
                    break;
                default:
                    Assert( "Wrong type for property!" );
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }

            }
            break;

        case HANDLEPROP_STREAM:
            {
                CStr cstr;

                // until the binary persistance we assume text save
                Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
                hr = ppp->GetString(pSubObject, &cstr);
                if (hr)
                    goto Cleanup;

                hr = WriteTextCStr((CStreamWriteBuff *)pv, &cstr, FALSE, ( ppp->dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY ) );
            }
            break;
        case HANDLEPROP_VALUE:
            if (PROPTYPE(dwOpCode) == PROPTYPE_VARIANT)
            {
                CStr cstr;

                // PERF: istvanc this is bad, we allocate the string twice
                // we need a new API which allocates the BSTR directly
                hr = ppp->GetString(pSubObject, &cstr);
                if (hr)
                    goto Cleanup;

                hr = cstr.AllocBSTR(&((VARIANT *)pv)->bstrVal);
                if (hr)
                    goto Cleanup;

                ((VARIANT *)pv)->vt = VT_BSTR;
            }
            else if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
            {
                CStr cstr;

                // PERF: istvanc this is bad, we allocate the string twice
                // we need a new API which allocates the BSTR directly
                hr = ppp->GetString(pSubObject, &cstr);
                if (hr)
                    goto Cleanup;

                hr = cstr.AllocBSTR((BSTR *)pv);
            }
            else
            {
                Assert(PROPTYPE(dwOpCode) == 0);
                hr = ppp->GetString(pSubObject, (CStr *)pv);
            }
            break;
        case HANDLEPROP_COMPARE:
            {
                CStr cstr;
                hr = ppp->GetString ( pSubObject, &cstr );
                if ( hr )
                    goto Cleanup;
                LPTSTR lpThisString = (LPTSTR) cstr;
                if (lpThisString == NULL || *(TCHAR**)pv == NULL)
                {
                    hr = ( lpThisString == NULL &&  *(TCHAR**)pv == NULL ) ? S_OK : S_FALSE;
                }
                else
                {
                    hr = _tcsicmp(lpThisString, *(TCHAR**)pv) ? S_FALSE : S_OK;
                }
            }
            RRETURN1(hr,S_FALSE);
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }

Cleanup:

    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }
    RRETURN1(hr, E_INVALIDARG);
}


//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleEnumProperty, public
//
//  Synopsis:   Helper for getting/setting enum value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (long in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleEnumProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr;
    NUMPROPPARAMS * ppp = (NUMPROPPARAMS *)(this + 1);
    long lNewValue;

    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        Assert(ppp->bpp.dwPPFlags & PROPPARAM_ENUM);
    }
    else if (OPCODE(dwOpCode) == HANDLEPROP_STREAM)
    {
        RRETURN1 ( HandleNumProperty ( dwOpCode,
            pv, pObject, pSubObject ), E_INVALIDARG );
    }
    else if (OPCODE(dwOpCode) == HANDLEPROP_COMPARE)
    {
        hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
        if (hr)
            goto Cleanup;
        // if inherited and not set, return S_OK
        hr = ( lNewValue == *(long *)pv ) ? S_OK : S_FALSE;
        RRETURN1(hr, S_FALSE);
    }

    hr = HandleNumProperty(dwOpCode, pv, pObject, pSubObject);

Cleanup:

    RRETURN1(hr, E_INVALIDARG);
}


//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleColorProperty, public
//
//  Synopsis:   Helper for getting/setting enum value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (OLE_COLOR in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleColorProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK,hr2;
    BASICPROPPARAMS * ppp = (BASICPROPPARAMS *)(this + 1);
    VARIANT     varDest;
    DWORD       dwNewValue;
    CColorValue cvValue;
    LPTSTR pStr;

    // just to be a little paranoid
    Assert(sizeof(OLE_COLOR) == 4);
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        VariantInit(&varDest);
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            V_VT(&varDest) = VT_BSTR;
            V_BSTR(&varDest) = (BSTR)pv;
            break;
        case PROPTYPE_VARIANT:
            if ( pv == NULL )
            {
                // Just have Tag=, ignore it
                return S_OK;
            }
            break;
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }
        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
            pStr = (LPTSTR)pv;
            if ( pStr == NULL || !pStr[0] )
            {
                if ( IsNotPresentAsDefaultSet() || !UseNotAssignedValue() )
                    cvValue = *(CColorValue *)&ulTagNotPresentDefault;
                else
                    cvValue = *(CColorValue *)&ulTagNotAssignedDefault;
            }
            else
            {
                hr = cvValue.FromString(pStr, dwOpCode & HANDLEPROP_STRICTCSS1, (ppp->dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY));
                if (hr || S_OK != cvValue.IsValid())
                {
                    if ( IsInvalidAsNoAssignSet() && UseNotAssignedValue() )
                        cvValue = *(CColorValue *)&ulTagNotAssignedDefault;
                    else
                        cvValue = *(CColorValue *)&ulTagNotPresentDefault;
                }
           }
            // If we're just sniffing for a good parse - don't set up a default
            if ( hr && ISSAMPLING( dwOpCode ) )
                goto Cleanup;

            // if asp string, we need to store the original string itself as an unknown attr
            // skip leading white space.
            while (pStr && *pStr && _istspace(*pStr))
                pStr++;

            if (pStr && (*pStr == _T('<')) && (*(pStr+1) == _T('%')))
                hr = E_INVALIDARG;
 
            // We need to preserve the hr if there is one
            hr2 = ppp->SetColor(pSubObject, cvValue.GetRawValue(), wFlags );
            if (hr2)
            {
                hr = hr2;
                goto Cleanup;
            }
            
            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr2 = THR(pObject->OnPropertyChange(ppp->dispid, ppp->dwFlags, (PROPERTYDESC *)this));
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }
            break;

        case HANDLEPROP_AUTOMATION:
            if (PROPTYPE(dwOpCode)==PROPTYPE_LPWSTR)
                hr = ppp->SetColorProperty( varDest, pObject, pSubObject, wFlags);
            else
                hr = ppp->SetColorProperty( *(VARIANT *)pv, pObject, pSubObject, wFlags);
            break;

        case HANDLEPROP_DEFAULT:
            Assert(pv == NULL);
            // CColorValue is initialized to VALUE_UNDEF.
            hr = ppp->SetColor(pSubObject, *(DWORD *)&ulTagNotPresentDefault, wFlags);
            break;
        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            {
                // this code path results from OM access. OM color's are 
                // always returned in Pound6 format.
                // make sure there is a subObject

                if (!pSubObject)
                    pSubObject = pObject;

                // get the dw Color value
                V_VT(&varDest) = VT_BSTR;
		V_BSTR(&varDest) = NULL;
                ppp->GetColor(pSubObject, &(V_BSTR(&varDest)), !(ppp->dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY) );

                // Coerce to type to return
                switch(PROPTYPE(dwOpCode))
                {
                    case PROPTYPE_VARIANT:
                        VariantInit ( (VARIANT *)pv );
                        V_VT ( (VARIANT *)pv ) = VT_BSTR;
                        V_BSTR((VARIANT *)pv) = V_BSTR(&varDest);
                        break;
                    default:
                        *(BSTR *)pv = V_BSTR(&varDest);
                }
                hr = S_OK;
            }
            break;
        case HANDLEPROP_STREAM:
            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            hr = ppp->GetColor(pSubObject, &dwNewValue);
            if (hr)
                goto Cleanup;
            cvValue = dwNewValue;

            hr = cvValue.Persist( (IStream *)pv, this );
            break;
        case HANDLEPROP_VALUE:
            if (PROPTYPE(dwOpCode) == PROPTYPE_VARIANT)
            {
                ((VARIANT *)pv)->vt = VT_UI4;
                hr = ppp->GetColor(pSubObject, &((VARIANT *)pv)->ulVal);
            }
            else
            if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
            {
                hr = ppp->GetColorProperty(&varDest, pObject, pSubObject);
                if (hr)
                    goto Cleanup;
                *(BSTR *)pv = V_BSTR(&varDest);
            }
            else
            {
                Assert(PROPTYPE(dwOpCode) == 0);
                hr = ppp->GetColor(pSubObject, (DWORD *)pv);
            }
            break;
        case HANDLEPROP_COMPARE:
            hr = ppp->GetColor(pSubObject, &dwNewValue);
            if (hr)
                goto Cleanup;
            // if inherited and not set, return S_OK
            hr = dwNewValue == *(DWORD *)pv ? S_OK : S_FALSE;
            RRETURN1(hr,S_FALSE);
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }

Cleanup:

    RRETURN1(hr, E_INVALIDARG);
}

//+---------------------------------------------------------------------------
//  Member: HandleUrlProperty
//
//  Synopsis : Handler for Getting/setting Url typed properties
//              pretty much, the only thing this needs to do is strip out CR/LF;s and 
//                  call the HandleStringProperty
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (OLE_COLOR in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//+---------------------------------------------------------------------------
HRESULT
PROPERTYDESC::HandleUrlProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr = S_OK;
    TCHAR   *pstrNoCRLF=NULL;
    VARIANT     varDest;

    varDest.vt = VT_EMPTY;
    if ISSET(dwOpCode)
    {
        // First handle the storage type
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            break;
        case PROPTYPE_VARIANT:
            if (V_VT((VARIANT *)pv) == VT_BSTR)
            {
                pv = (void *)V_BSTR((VARIANT *)pv);
            }
            else
            {
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR);
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
            }
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }

        //then handle the operation
        switch(OPCODE(dwOpCode))
        {
            case HANDLEPROP_VALUE:
            case HANDLEPROP_DEFAULT:
                hr =THR(StripCRLF((TCHAR *)pv, &pstrNoCRLF));
                if (hr)
                    goto Cleanup;

                hr = THR(HandleStringProperty( dwOpCode, (void *)pstrNoCRLF, pObject, pSubObject));
    
                if (pstrNoCRLF)
                    MemFree(pstrNoCRLF);
                goto Cleanup;
                break;
        }
    }
    else
    {   // NOTE: This code should not be necessary - it forces us to always quote URLs when
        // persisting.  It is here to circumvent an Athena bug (IEv4.1 RAID #20953) - CWilso
        if(ISSTREAM(dwOpCode))
        {   // Have to make sure we quote URLs when persisting.
            CStr cstr;
            BASICPROPPARAMS * ppp = (BASICPROPPARAMS *)(this + 1);

            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            hr = ppp->GetString(pSubObject, &cstr);
            if (hr)
                goto Cleanup;

            hr = WriteTextCStr((CStreamWriteBuff *)pv, &cstr, TRUE, FALSE );
            goto Cleanup;
        }
    }

    hr = THR(HandleStringProperty( dwOpCode, pv, pObject, pSubObject));

Cleanup:
    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }
    if ( OPCODE(dwOpCode)== HANDLEPROP_COMPARE )
        RRETURN1( hr, S_FALSE );
    else
        RRETURN1( hr, E_INVALIDARG );
}


const CUnitValue::TypeDesc CUnitValue::TypeNames[] =
{
    { _T("null"), UNIT_NULLVALUE,       SHIFTOFFSET_NULLVALUE    , SCALEMULT_NULLVALUE     }, // Never used
    { _T("pt"),   UNIT_POINT,           SHIFTOFFSET_POINT        , SCALEMULT_POINT         },
    { _T("pc"),   UNIT_PICA,            SHIFTOFFSET_PICA         , SCALEMULT_PICA          },
    { _T("in"),   UNIT_INCH,            SHIFTOFFSET_INCH         , SCALEMULT_INCH          },
    { _T("cm"),   UNIT_CM,              SHIFTOFFSET_CM           , SCALEMULT_CM            },
    { _T("mm"),   UNIT_MM,              SHIFTOFFSET_MM           , SCALEMULT_MM            }, // Chosen to match HIMETRIC
    { _T("em"),   UNIT_EM,              SHIFTOFFSET_EM           , SCALEMULT_EM            },
    { _T("ex"),   UNIT_EX,              SHIFTOFFSET_EX           , SCALEMULT_EX            },
    { _T("px"),   UNIT_PIXELS,          SHIFTOFFSET_PIXELS       , SCALEMULT_PIXELS        },
    { _T("%"),    UNIT_PERCENT,         SHIFTOFFSET_PERCENT      , SCALEMULT_PERCENT       },
    { _T("*"),    UNIT_TIMESRELATIVE,   SHIFTOFFSET_TIMESRELATIVE, SCALEMULT_TIMESRELATIVE },
    { _T("float"),UNIT_FLOAT,           SHIFTOFFSET_FLOAT        , SCALEMULT_FLOAT         },
};

#define LOCAL_BUF_COUNT   (pdlLength + 1)

HRESULT
CUnitValue::NumberFromString ( LPCTSTR pStr, const PROPERTYDESC *pPropDesc, BOOL fStrictCSS1 )
{
    BOOL fIsSigned = FALSE;
    long lNewValue = 0;
    LPCTSTR pStartPoint = NULL;
    UNITVALUETYPE uvt = UNIT_INTEGER;
    WORD i,j,k;
    HRESULT hr = S_OK;
    TCHAR tcValue [ LOCAL_BUF_COUNT ];  
    WORD wShift;
    NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(pPropDesc + 1);
    long lExponent = 0;
    BOOL fNegativeExponent = FALSE;

    enum ParseState
    {
        Starting,
        AfterPoint,
        AfterE,
        InExponent,
        InTypeSpecifier,
        ParseState_Last_enum
    } State = Starting;

    UINT uNumChars =0;
    UINT uPrefixDigits = 0;
    BOOL fSeenDigit = FALSE;
    BOOL fSeenAfterPointDigit = FALSE;
    BOOL fSeenTypeSpecifier = FALSE;

    // Find the unit specifier
    for ( i = 0 ; uNumChars < LOCAL_BUF_COUNT ; i++ )
    {
        switch ( State )
        {
        case Starting:
            if ( i == 0 && ( pStr [ i ] == _T('-') || pStr [ i ] == _T('+')  ) )
            {
                tcValue [ uNumChars++ ] = pStr [ i ]; uPrefixDigits++;
                fIsSigned = TRUE;
            }
            else if ( !_istdigit ( pStr [ i ] ) )
            {
                if ( pStr [ i ] == _T('.') )
                {
                    State = AfterPoint;
                }
                else if ( pStr[ i ] == _T('\0') || pStr[ i ] == _T('\"')  ||pStr[ i ] == _T('\'') )
                {
                    goto Convert;
                }
                else
                {
                    // such up white space, and treat whatevers left as the type
                    if (fStrictCSS1 && _istspace(pStr[i]))
                    {
                        /* (gschneid) In strict mode if we encounter here a space we MUST have 
                         * seen everything in this line because spaces are not allowed between
                         * number and unit specifier in a measure. E.g. 100px is valid but not
                         * 100 px. We do NOT necessarily need a unit specifier. E.g. in line-height
                         * or in zoom. For example "zoom: 3" means 3 times zoom.
                         * Again, it might be valid iff we have parsed everything except white spaces. 
                         * This is checked at the end of the function.
                         */

                        // We skip white spaces.
                        while (_istspace(pStr[i]))
                            i++;

                        if (pStr[i] == _T('\0'))
                        {                        
                            // If we are at the end of the string we are fine because there is no unit
                            // specifier. 
                            goto Convert;
                        }
                        else
                        {
                            // There is another character, i.e. we have a situation like "100 px".
                            // Because we are under strict css we bail out.
                            hr = E_INVALIDARG;
                            goto Cleanup;
                        }
                    }
                        
                    while ( _istspace ( pStr [ i ] ) )
                        i++;
                    
                    pStartPoint = pStr + i;
                    State = ( pStr [ i ] == _T('e') || pStr [ i ] == _T('E') ) ? AfterE : InTypeSpecifier;
                }
            }
            else
            {
                fSeenDigit = TRUE;
                tcValue [ uNumChars++ ] = pStr [ i ]; uPrefixDigits++;
            }
            break;


        case AfterPoint:
            if ( !_istdigit ( pStr [ i ] ) )
            {
                if (fStrictCSS1 && !fSeenAfterPointDigit)
                {
                    /* 
                     * Under strict css there must be a digit after the period. E.g. 1.px is not
                     * allowed. See CSS2 Spec, D.2 Lexical Scanner.
                     * Here we are after the period and have not seen a digit and therefore have
                     * an invalid specification.
                     */
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                     
                if (fStrictCSS1 && _istspace(pStr[i]))
                {
                    /* (gschneid) In strict mode if we encounter here a space we MUST have 
                     * seen everything in this line because spaces are not allowed between
                     * number and unit specifier in a measure. E.g. 1.333px is valid but not
                     * 1.333 px. We do NOT necessarily need a unit specifier. E.g. in line-height
                     * or in zoom. For example "zoom: 3.0" means 3.0 times zoom.
                     * Again, it might be valid iff we have parsed everything except white spaces. 
                     * This is checked at the end of the function.
                     */

                    // We skip white spaces.
                    while (_istspace(pStr[i]))
                        i++;

                    if (pStr[i] == _T('\0'))
                    {                        
                        // If we are at the end of the string we are fine because there is no unit
                        // specifier. 
                        goto Convert;
                    }
                    else
                    {
                        // There is another character, i.e. we have a situation like "100 px".
                        // Because we are under strict css we bail out.
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                }

                if ( pStr [ i ] == _T('\0') )
                {
                    goto Convert;
                }
                else if ( !_istspace ( pStr [ i ] ) )
                {
                    pStartPoint = pStr + i;
                    State = ( pStr [ i ] == _T('e') || pStr [ i ] == _T('E') ) ? AfterE : InTypeSpecifier;
                }
            }
            else
            {
                fSeenDigit = TRUE;
                fSeenAfterPointDigit = TRUE;
                tcValue [ uNumChars++ ] = pStr [ i ];
            }
            break;

        case AfterE:
            if ( pStr [ i ] == _T('-') || pStr [ i ] == _T('+')  ||
                 _istdigit ( pStr [ i ] ) )
            {   // Looks like scientific notation to me.
                if ( _istdigit ( pStr [ i ] ) )
                    lExponent = pStr [ i ] - _T('0');
                else if ( pStr [ i ] == _T('-') )
                    fNegativeExponent = TRUE;
                State = InExponent;
                break;
            }
            // Otherwise, this must just be a regular old "em" or "en" type specifier-
            // Set the state and let's drop back into this switch with the same char...
            State = InTypeSpecifier;
            i--;
            break;

        case InExponent:
            if ( _istdigit ( pStr [ i ] ) )
            {
                lExponent *= 10;
                lExponent += pStr [ i ] - _T('0');
                break;
            }
            while ( _istspace ( pStr [ i ] ) )
                i++;
            if ( pStr [ i ] == _T('\0') )
                goto Convert;
            State = InTypeSpecifier;    // otherwise, fall through to type handler
            pStartPoint = pStr + i;

        case InTypeSpecifier:
            if ( _istspace ( pStr [ i ] ) )
            {
                if ( pPropDesc->IsStyleSheetProperty() )
                {
                    // In style sheets this checks that there is nothing after the unit specifier.
                    while ( _istspace ( pStr [ i ] ) )
                        i++;
                    if ( pStr [ i ] != _T('\0') )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                }
                goto CompareTypeNames;
            }
            if ( pStr [ i ] == _T('\0') )
            {
CompareTypeNames:
                for ( j = 0 ; j < ARRAY_SIZE ( TypeNames ) ; j++ )
                {
                    if ( TypeNames[ j ].pszName )
                    {
                        int iLen = _tcslen( TypeNames[ j ].pszName );

                        if ( _tcsnipre( TypeNames [ j ].pszName, iLen, pStartPoint, -1 ) )
                        {
                            if ( pPropDesc->IsStyleSheetProperty() )
                            {
                                if ( pStartPoint[ iLen ] && !_istspace( pStartPoint[ iLen ] ) )
                                    continue;
                            }
                            break;
                        }
                    }
                }
                if ( j == ARRAY_SIZE ( TypeNames ) )
                {
                    if ( ( ppp -> bpp.dwPPFlags & PP_UV_UNITFONT ) == PP_UV_UNITFONT )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    // In strict css1 mode invalid unit specifiers are invalid; in comp mode we just ignore them (and therefore assume later px)
                    if (fStrictCSS1)
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    } 
                    else
                    {
                        goto Convert;
                    }
                }
                uvt = TypeNames [ j ].uvt;
                fSeenTypeSpecifier = TRUE;
                goto Convert;
            }
            break;
        }
    }

Convert:

    if ( !fSeenDigit && uvt != UNIT_TIMESRELATIVE )
    {
        if ( ppp -> bpp.dwPPFlags & PROPPARAM_ENUM )
        {
            long lEnum;
            hr = LookupEnumString ( ppp, (LPTSTR)pStr, &lEnum );
            if ( hr == S_OK )
            {
                SetValue ( lEnum, UNIT_ENUM );
                goto Cleanup;
            }
        }

        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( fIsSigned && uvt == UNIT_INTEGER && ( ( ppp->bpp.dwPPFlags & PP_UV_UNITFONT ) != PP_UV_UNITFONT ) )
    {
        uvt = UNIT_RELATIVE;
    }


    // If the validation for this attribute does not require that we distinguish
    // between integer and relative, just store integer

    // Currently the only legal relative type is a Font size, if this changes either
    // add a separte PROPPARAM_ or do something else
    if ( uvt == UNIT_RELATIVE && !(ppp -> bpp.dwPPFlags & PROPPARAM_FONTSIZE ))
    {
        uvt = UNIT_INTEGER;
    }

    // If a unit was supplied that is not valid for this propdesc,
    // drop back to the default (pixels if no notpresent and notassigned defaults)
    if ( ( IsScalerUnit ( uvt ) && !(ppp -> bpp.dwPPFlags & PROPPARAM_LENGTH ) ) ||
        ( uvt == UNIT_PERCENT && !(ppp -> bpp.dwPPFlags & PROPPARAM_PERCENTAGE ) ) ||
        ( uvt == UNIT_TIMESRELATIVE && !(ppp -> bpp.dwPPFlags & PROPPARAM_TIMESRELATIVE ) ) ||
        ( ( uvt == UNIT_INTEGER ) && !(ppp -> bpp.dwPPFlags & PROPPARAM_FONTSIZE ) ) )
    {   // If no units where specified and a default unit is specified, use it
        if ( ( uvt != UNIT_INTEGER ) && pPropDesc->IsStyleSheetProperty() ) // Stylesheet unit values only:
        {   // We'll default unadorned numbers to "px", but we won't change "100%" to "100px" if percent is not allowed.
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
        CUnitValue uv;
        uv.SetRawValue ( (long)pPropDesc -> ulTagNotPresentDefault );
        uvt = uv.GetUnitType();
        if ( uvt == UNIT_NULLVALUE )
        {
            uv.SetRawValue ( (long)pPropDesc -> ulTagNotAssignedDefault );
            uvt = uv.GetUnitType();
            if ( uvt == UNIT_NULLVALUE )
                uvt = UNIT_PIXELS;
        }
    }

    // Check the various types, don't do the shift for the various types
    switch ( uvt )
    {
    case UNIT_INTEGER:
    case UNIT_RELATIVE:
    case UNIT_ENUM:
        wShift = 0;
        break;

    default:
        wShift = TypeNames [ uvt ].wShiftOffset;
        break;
    }

    if ( lExponent && !fNegativeExponent && ( ( uPrefixDigits + wShift ) < uNumChars ) )
    {
        long lAdditionalShift = uNumChars - ( uPrefixDigits + wShift );
        if ( lAdditionalShift > lExponent )
            lAdditionalShift = lExponent;
        wShift += (WORD)lAdditionalShift;
        lExponent -= lAdditionalShift;
    }
    // uPrefixDigits tells us how may characters there are before the point;
    // Assume we're always shifting to the right of the point
    k = (uPrefixDigits + wShift < LOCAL_BUF_COUNT) ? uPrefixDigits + wShift : LOCAL_BUF_COUNT - 1;
    tcValue [ k ] = _T('\0');
    for ( j = (WORD)uNumChars; j < k ; j++ )
    {
        tcValue [ j ] = _T('0');
    }

    // Skip leading zeros, they confuse StringToLong
    for ( pStartPoint = tcValue ; *pStartPoint == _T('0') && *(pStartPoint+1) != _T('\0') ; pStartPoint++ );

    if (*pStartPoint)
    {
        hr = ttol_with_error( pStartPoint, &lNewValue);
        // returns LONG_MIN or LONG_MIN on overflow
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else if (uvt != UNIT_TIMESRELATIVE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((uvt == UNIT_TIMESRELATIVE) && (lNewValue == 0))
    {
        lNewValue = 1 * TypeNames[UNIT_TIMESRELATIVE].wScaleMult;
    }

    if ( fNegativeExponent )
    {
        while ( lNewValue && lExponent-- > 0 )
            lNewValue /= 10;
    }
    else
    {
        while ( lExponent-- > 0 )
        {
            if ( lNewValue > LONG_MAX/10 )
            {
                lNewValue = LONG_MAX;
                break;
            }
            lNewValue *= 10;
        }
    }

    // iff in strict css1 mode AND there was NO unit specifier THEN we only have a legal specification
    // iff either the specified value is 0 or we specify line-height (According to CSS1 spec a line-height 
    // spec without a unit specifier means that <line-height> := <specfied value> * <font-size>. For a 0 value 
    // no unit specifier is need according to CSS1).
    // By the way: Invalid unit specifiers are NOT allowed. See above in the section where the unit (type)
    // specifier is parsed.
    if (fStrictCSS1 && !fSeenTypeSpecifier && lNewValue) 
    {
        DISPID dispid = ppp->GetPropertyDesc()->GetDispid();
        // we are not looking at a lineheight or zoom spec.
        // !!!! When adding new attributes this NEEDS MAINTAINANCE. The straight forward solution would be to add
        // !!!! a flag to the property parameters to be able to specify that no unit specifier is needed.
        if ((dispid != DISPID_A_LINEHEIGHT) && (dispid != DISPID_A_ZOOM))
        { 
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    SetValue ( lNewValue, uvt );

Cleanup:
    RRETURN1 ( hr, E_INVALIDARG );
}

long 
CUnitValue::SetValue ( long lVal, UNITVALUETYPE uvt ) 
{
    if ( lVal > (LONG_MAX>>NUM_TYPEBITS ))
        lVal = LONG_MAX>>NUM_TYPEBITS;
    else if ( lVal < (LONG_MIN>>NUM_TYPEBITS) )
        lVal = LONG_MIN>>NUM_TYPEBITS;
    return _lValue = (lVal << NUM_TYPEBITS) | uvt; 
}


HRESULT
CUnitValue::Persist (
    IStream *pStream,
    const PROPERTYDESC *pPropDesc ) const
{
    TCHAR   cBuffer [ 30 ];
    int     iBufSize = ARRAY_SIZE ( cBuffer );
    LPTSTR  pBuffer = (LPTSTR)&cBuffer;
    HRESULT hr;
    UNITVALUETYPE   uvt = GetUnitType();

    if (uvt==UNIT_PERCENT )
    {
        *pBuffer++ = _T('\"');
        // Need another character for the closing quotes
        iBufSize -= 2;
    }

    hr = FormatBuffer ( pBuffer, iBufSize, pPropDesc );
    if ( hr )
        goto Cleanup;

    // and finally the close quotes
    if (uvt==UNIT_PERCENT )
        _tcscat(cBuffer, _T("\""));

    hr = WriteText ( pStream, cBuffer );

Cleanup:
    RRETURN ( hr );
}


// We usually do not append default unit types to the string we return. Setting fAlwaysAppendUnit
//   to true forces the unit to be always appended to the number
HRESULT
CUnitValue::FormatBuffer ( LPTSTR szBuffer, UINT uMaxLen, 
                        const PROPERTYDESC *pPropDesc, BOOL fAlwaysAppendUnit /*= FALSE */) const
{
    HRESULT         hr = S_OK;
    UNITVALUETYPE   uvt = GetUnitType();
    long            lUnitValue = GetUnitValue();
    TCHAR           ach[20 ];
    int             nLen,i,nOutLen = 0;
    BOOL            fAppend = TRUE;

    switch ( uvt )
    {
    case UNIT_ENUM:
        {
            ENUMDESC *pEnumDesc;
            LPCTSTR pcszEnum;

            Assert( ( ((NUMPROPPARAMS *)(pPropDesc + 1))->bpp.dwPPFlags & PROPPARAM_ENUM ) && "Not an enum property!" );

            hr = E_INVALIDARG;
            pEnumDesc = pPropDesc->GetEnumDescriptor();
            if ( pEnumDesc )
            {
                pcszEnum = pEnumDesc->StringPtrFromEnum( lUnitValue );
                if ( pcszEnum )
                {
                    _tcsncpy( szBuffer, pcszEnum, uMaxLen );
                    szBuffer[ uMaxLen - 1 ] = _T('\0');
                    hr = S_OK;
                }
            }
        }
        break;

    case UNIT_INTEGER:
        hr = Format(0, szBuffer, uMaxLen, _T("<0d>"), lUnitValue);
        break;

    case UNIT_RELATIVE:
        if ( lUnitValue >= 0 )
        {
            szBuffer [ nOutLen++ ] = _T('+');
        }
        hr = Format(0, szBuffer+nOutLen, uMaxLen-nOutLen, _T("<0d>"), lUnitValue);
        break;

    case UNIT_NULLVALUE:
        // TODO: Need to chage save code to NOT comapre the lDefault directly
        // But to go through the handler
        szBuffer[0] = 0;
        hr = S_OK;
        break;

    case UNIT_TIMESRELATIVE:
        _tcscpy ( szBuffer, TypeNames [ uvt ].pszName );
        hr = Format(0, szBuffer+_tcslen ( szBuffer ), uMaxLen-_tcslen ( szBuffer ),
            _T("<0d>"), lUnitValue);
        break;

    default:
        hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), lUnitValue);
        if ( hr )
            goto Cleanup;

        nLen = _tcslen ( ach );

        LPTSTR pStr = ach;

        if ( ach [ 0 ] == _T('-') )
        {
            szBuffer [ nOutLen++ ] = _T('-');
            pStr++; nLen--;
        }

        if ( nLen > TypeNames [ uvt ].wShiftOffset )
        {
            for ( i = 0 ; i < ( nLen - TypeNames [ uvt ].wShiftOffset ) ; i++ )
            {
                szBuffer [ nOutLen++ ] = *pStr++;
            }
            szBuffer [ nOutLen++ ] = _T('.');
            for ( i = 0 ; i < TypeNames [ uvt ].wShiftOffset ; i++ )
            {
                szBuffer [ nOutLen++ ] = *pStr++;
            }
        }
        else
        {
            szBuffer [ nOutLen++ ] = _T('0');
            szBuffer [ nOutLen++ ] = _T('.');
            for ( i = 0 ; i < ( TypeNames [ uvt ].wShiftOffset - nLen ) ; i++ )
            {
                szBuffer [ nOutLen++ ] = _T('0');
            }
            for ( i = 0 ; i < nLen ; i++ )
            {
                szBuffer [ nOutLen++ ] = *pStr++;
            }
        }

        // Strip trailing 0 digits. If there's at least one trailing digit put a point
        for ( i = nOutLen-1 ; ; i-- )
        {
            if ( szBuffer [ i ] == _T('.') )
            {
                nOutLen--;
                break;
            }
            else if ( szBuffer [ i ] == _T('0') )
            {
                nOutLen--;
            }
            else
            {
                break;
            }
        }

        // Append the type prefix, unless it's the default and not forced
        if(uvt == UNIT_FLOAT)
        {
            fAppend = FALSE;
        }
        else if(!fAlwaysAppendUnit && !( pPropDesc->GetPPFlags() & PROPPARAM_LENGTH ) )
        {
            CUnitValue      uvDefault;
            uvDefault.SetRawValue ( pPropDesc -> ulTagNotPresentDefault );
            UNITVALUETYPE   uvtDefault = uvDefault.GetUnitType();

            if(uvt == uvtDefault || (uvtDefault == UNIT_NULLVALUE && uvt == UNIT_PIXELS))
            {
                fAppend = FALSE;
            }
        }

        if(fAppend)
            _tcscpy ( szBuffer + nOutLen, TypeNames [ uvt ].pszName );
        else
            szBuffer [ nOutLen ] = _T('\0');
                
        break;
    }
Cleanup:
    RRETURN ( hr );
}

HRESULT
CUnitValue::IsValid ( const PROPERTYDESC *pPropDesc ) const
{
    HRESULT hr = S_OK;
    BOOL    fTestAnyHow=FALSE;
    UNITVALUETYPE uvt = GetUnitType();
    long lUnitValue = GetUnitValue();
    NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(pPropDesc + 1);

    if ( ( ppp->lMin == 0 ) && ( lUnitValue < 0 ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch ( uvt )
    {
    case UNIT_TIMESRELATIVE:
        if ( ! ( ppp ->bpp.dwPPFlags & PROPPARAM_TIMESRELATIVE ) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_ENUM:
        if ( !(ppp->bpp.dwPPFlags & PROPPARAM_ENUM) &&
             !(ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_INTEGER:
        if ( !(ppp->bpp.dwPPFlags & PROPPARAM_FONTSIZE) && 
             !(ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_RELATIVE:
        if ( ppp ->bpp.dwPPFlags & PROPPARAM_FONTSIZE )
        {
            // Netscape treats any FONTSIZE as valid . A value greater than
            // 6 gets treated as seven, less than -6 gets treated as -6.
            // 8 and 9 get treated as "larger" and "smaller".
            goto Cleanup;
        }
        else if ( !( ppp ->bpp.dwPPFlags & PROPPARAM_ANUMBER ) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_PERCENT:
        if ( ! ( ppp ->bpp.dwPPFlags & PROPPARAM_PERCENTAGE ) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            long lMin = ((CUnitValue*)&(ppp->lMin))->GetUnitValue();
            long lMax = ((CUnitValue*)&(ppp->lMax))->GetUnitValue();

            lUnitValue = lUnitValue /  TypeNames [ UNIT_PERCENT ].wScaleMult;

            if ( lUnitValue < lMin || lUnitValue > lMax )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
        break;

    case UNIT_NULLVALUE: // Always valid
        break;

    case UNIT_PIXELS:  // pixels are HTML and CSS valid
        fTestAnyHow = TRUE;
        // fall through

    case UNIT_FLOAT:
    default:  // other Units of measurement are only CSS valid
        if ( ! ( ppp ->bpp.dwPPFlags & PROPPARAM_LENGTH ) && !fTestAnyHow)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            // it is a length but sometimes we do not want negatives
            long lMin = ((CUnitValue*)&(ppp->lMin))->GetUnitValue();
            long lMax = ((CUnitValue*)&(ppp->lMax))->GetUnitValue();
            if ( lUnitValue < lMin || lUnitValue > lMax )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        break;
    }
Cleanup:
    RRETURN1 ( hr, E_INVALIDARG );
}

// The following conversion table converts whole units of basic types and assume
// 1 twip = 1/20 point
// 1 pica = 12 points
// 1 point = 1/72 inch
// 1 in = 2.54 cm

#define CVIX(off) ( off - UNIT_POINT )

const CUnitValue::ConvertTable CUnitValue::BasicConversions[6][6] =
{
    {  // From UNIT_POINT
        { 1,1 },                // To UNIT_POINT
        { 1,12 },               // To UNIT_PICA
        { 1, 72 },              // To UNIT_INCH
        { 1*254, 72*100 },      // To UNIT_CM
        { 1*2540, 72*100 },     // To UNIT_MM
        { 20,1 },               // To UNIT_EM 
    },
    { // From UNIT_PICA
        { 12,1 },               // To UNIT_POINT
        { 1,1 },                // To UNIT_PICS
        { 12, 72 },             // To UNIT_INCH
        { 12*254, 72*100 },     // To UNIT_CM
        { 12*2540, 72*100 },    // To UNIT_MM
        { 20*12, 1 },           // To UNIT_EM 
    },
    { // From UNIT_INCH
        { 72,1 },               // To UNIT_POINT
        { 72,12 },              // To UNIT_PICA
        { 1, 1 },               // To UNIT_INCH
        { 254, 100 },           // To UNIT_CM
        { 2540, 100 },          // To UNIT_MM
        { 1440,1 },             // To UNIT_EM 
    },
    { // From UNIT_CM
        { 72*100,1*254 },        // To UNIT_POINT
        { 72*100,12*254 },       // To UNIT_PICA
        { 100, 254 },            // To UNIT_INCH
        { 1, 1 },                // To UNIT_CM
        { 10, 1 },               // To UNIT_MM
        { 20*72*100, 254 },      // To UNIT_EM 
    },
    { // From UNIT_MM
        { 72*100,1*2540 },       // To UNIT_POINT
        { 72*100,12*2540 },      // To UNIT_PICA
        { 100, 2540 },           // To UNIT_INCH
        { 10, 1 },               // To UNIT_CM
        { 1,1 },                 // To UNIT_MM
        { 20*72*100, 2540 },     // To UNIT_EM 
    },
    { // From UNIT_EM
        { 1,20 },                // To UNIT_POINT
        { 1, 20*12 },            // To UNIT_PICA
        { 1, 20*72 },            // To UNIT_INCH
        { 254, 20*72*100 },      // To UNIT_CM
        { 2540, 20*72*100 },     // To UNIT_MM
        { 1,1 },                 // To UNIT_EM 
    },
};

// EM's, EN's and EX's get converted to pixels

// Whever we convert to-from pixels we use the screen logpixs to ensure that the screen size
// matches the printer size


/* static */
long CUnitValue::ConvertTo( long lValue, 
                            UNITVALUETYPE uvtFromUnits, 
                            UNITVALUETYPE uvtTo, 
                            DIRECTION direction,
                            long  lFontHeight,          // = 1 
                            SIZE  *psizeInch )          // = NULL
{
    UNITVALUETYPE uvtToUnits;
    long lFontMul = 1,lFontDiv = 1;

    if ( uvtFromUnits == uvtTo )
    {
        return lValue;
    }

    if ( uvtFromUnits == UNIT_PIXELS )
    {
        SIZE const* psizeLogInch = psizeInch ? psizeInch : &g_uiDisplay.GetResolution();
        int logPixels = ( direction == DIRECTION_CX ) ? psizeLogInch->cx : psizeLogInch->cy;
        
        // Convert to inches ( stored precision )
        lValue = MulDivQuick ( lValue, TypeNames [ UNIT_INCH ].wScaleMult,
            logPixels );

        uvtFromUnits = UNIT_INCH;
        uvtToUnits = uvtTo;
    }
    else if ( uvtTo == UNIT_PIXELS )
    {
        uvtToUnits = UNIT_INCH;
    }
    else
    {
        uvtToUnits = uvtTo;
    }

    if ( uvtToUnits == UNIT_EM )
        lFontDiv = lFontHeight;
    if ( uvtFromUnits == UNIT_EM )
        lFontMul = lFontHeight;

    if ( uvtToUnits == UNIT_EX )
    {
        lFontDiv = lFontHeight*2;
        uvtToUnits = UNIT_EM;
    }
    if ( uvtFromUnits == UNIT_EX )
    {
        lFontMul = lFontHeight/2;
        uvtFromUnits = UNIT_EM;
    }

    // Note that we perform two conversions in one here to avoid losing
    // intermediate accuracy for conversions to pixels, i.e. we're converting
    // units to inches and from inches to pixels.
    if ( uvtTo == UNIT_PIXELS )
    {
        SIZE const* psizeLogInch = psizeInch ? psizeInch : &g_uiDisplay.GetResolution();
        int logPixels = ( direction == DIRECTION_CX ) ? psizeLogInch->cx : psizeLogInch->cy;

        lValue = MulDivQuick ( lValue,
            lFontMul * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lMul * 
                               TypeNames [ uvtToUnits ].wScaleMult * logPixels,
            lFontDiv * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lDiv * 
                               TypeNames [ uvtFromUnits ].wScaleMult *
                               TypeNames [ UNIT_INCH ].wScaleMult );
    }
    else
    {
        lValue = MulDivQuick ( lValue,
            lFontMul * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lMul * 
                               TypeNames [ uvtToUnits ].wScaleMult ,
            lFontDiv * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lDiv * 
                               TypeNames [ uvtFromUnits ].wScaleMult);
    }        


    return lValue;
}



// Set the Percent Value - Don't need a transform because we assume lNewValue is in the
// same transform as lPercentOfValue
BOOL CUnitValue::SetPercentValue ( long lNewValue, DIRECTION direction, long lPercentOfValue )
{
    UNITVALUETYPE uvtToUnits = GetUnitType() ;
    long lUnitValue = GetUnitValue();

    // Set the internal percentage to reflect what percentage of lMaxValue
    if ( lPercentOfValue == 0 )
    {
        lUnitValue = 0;
    }
    else if ( uvtToUnits == UNIT_PERCENT )
    {
        lUnitValue = MulDivQuick ( lNewValue, 100*TypeNames [ UNIT_PERCENT ].wScaleMult, lPercentOfValue  );
    }
    else
    {
        lUnitValue = MulDivQuick ( lNewValue, TypeNames [ UNIT_TIMESRELATIVE ].wScaleMult, lPercentOfValue  );
    }
    SetValue ( lUnitValue, uvtToUnits );
    return TRUE;
}

long CUnitValue::GetPixelValueCore ( CDocScaleInfo const *pdocScaleInfo, 
                                     DIRECTION direction,
                                     long lPercentOfValue,
                                     long lFontHeight /* =1 */) const
{
    UNITVALUETYPE uvtFromUnits = GetUnitType() ;
    long lRetValue;

    SIZE sizeInch;

    // (dmitryt) we come here without pdocScaleInfo from CHTMLDlg code
    //(see CHTMLDlg::GetWidth() for example). In this case, we want screen 
    //resolution (we are about to size dialog window on screen)
    // IE6 bug 7049
    if (pdocScaleInfo)
        sizeInch = pdocScaleInfo->GetDocPixelsPerInch();
    else
        sizeInch = g_uiDisplay.GetResolution(); 
    
    switch ( uvtFromUnits )
    {
    case UNIT_TIMESRELATIVE:
        lRetValue = MulDivQuick(GetUnitValue(), lPercentOfValue,
                                TypeNames[UNIT_TIMESRELATIVE].wScaleMult);
        break;

    case UNIT_NULLVALUE:
        return 0L;

    case UNIT_PERCENT:
        lRetValue = GetPercentValue ( direction, lPercentOfValue );
        break;

    case UNIT_EX:
    case UNIT_EM:
        // turn the twips into pixels
        lRetValue = ConvertTo(GetUnitValue(), 
                              uvtFromUnits, 
                              UNIT_PIXELS, 
                              direction,
                              lFontHeight,
                              &sizeInch);

        // Still need to scale since zooming has been taken out and thus ConvertTo() no longer
        // scales (zooms) for printing (IE5 8543, IE4 11376).  Formerly:  pTransform = NULL;
        break;

    case UNIT_ENUM:
        // TODO: We need to put proper handling for enum in the Apply() so that
        // no one calls GetPixelValue on (for example) the margin CUV objects if
        // they're set to "auto".
        Assert( "Shouldn't call GetPixelValue() on enumerated unit values!" );
        return 0;

    case UNIT_INTEGER:
    case UNIT_RELATIVE:
        // TODO: this doesn't seem right; nothing's being done to convert the
        // retrieved value to anything resembling pixels.
        return GetUnitValue();

    case UNIT_FLOAT:
        lRetValue = MulDivQuick(GetUnitValue(), lFontHeight,
                                TypeNames[UNIT_FLOAT].wScaleMult);
        break;

    default:
        lRetValue = ConvertTo(GetUnitValue(), 
                              uvtFromUnits, 
                              UNIT_PIXELS, 
                              direction, 
                              lFontHeight,
                              &sizeInch);

        break;
    }
    // Finally convert from Window to Doc units, assuming return value is a length
    // For conversions to HIMETRIC, involve the transform
    if ( pdocScaleInfo  )
    {
        Assert(pdocScaleInfo->IsInitialized());
        BOOL fRelative = UNIT_PERCENT == uvtFromUnits ||
                         UNIT_TIMESRELATIVE == uvtFromUnits;
        if (!fRelative)
        {
            if ( direction == DIRECTION_CX )
                lRetValue = pdocScaleInfo->DeviceFromDocPixelsX(lRetValue);
            else
                lRetValue = pdocScaleInfo->DeviceFromDocPixelsY(lRetValue);
        }
    }
    return lRetValue;
}


HRESULT
CUnitValue::FromString ( LPCTSTR pStr, const PROPERTYDESC *pPropDesc, BOOL fStrictCSS1 )
{
    NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(pPropDesc + 1);

    // if string is empty and boolean is an allowed type make it so...

    // Note the special handling of the table relative "*" here

    while ( _istspace ( *pStr ) )
        pStr++;

    if ( _istdigit ( pStr [ 0 ] ) || pStr [ 0 ] == _T('+') || pStr [ 0 ] == _T('-') ||
        pStr [ 0 ] == _T('*') || pStr [ 0 ] == _T('.') )
    {
        // Assume some numerical value followed by an optional unit
        // specifier
        RRETURN1 ( NumberFromString ( pStr, pPropDesc, fStrictCSS1 ), E_INVALIDARG );
    }
    else
    {
        // Assume an enum
        if ( ppp -> bpp.dwPPFlags & PROPPARAM_ENUM )
        {
            long lNewValue;

            if ( S_OK == LookupEnumString( ppp, (LPTSTR)pStr, &lNewValue ) )
            {
                SetValue( lNewValue, UNIT_ENUM );
                return S_OK;
            }
        }
        return E_INVALIDARG;
    }
}

float CUnitValue::GetFloatValueInUnits ( UNITVALUETYPE uvtTo, 
                                        DIRECTION dir, 
                                        long lFontHeight /*=1*/ )
{
    // Convert the unitvalue into a floating point number in units uvt
    long lEncodedValue = ConvertTo ( GetUnitValue(), GetUnitType(), uvtTo,  dir, lFontHeight );

    return (float)lEncodedValue / (float)TypeNames [ uvtTo ].wScaleMult;
}


HRESULT CUnitValue::ConvertToUnitType ( UNITVALUETYPE uvtConvertTo, 
                                       long           lCurrentPixelSize, 
                                       DIRECTION      dir,
                                       long           lFontHeight /*=1*/)
{
    AssertSz(GetUnitType() != UNIT_PERCENT, "Cannot handle percent units! Contact RGardner!");
    
    // Convert the unit value to the new type but keep the
    // absolute value of the units the same
    // e.e. 20.34 pels -> 20.34 in

    if ( GetUnitType() == uvtConvertTo )
        return S_OK;

    if ( GetUnitType() == UNIT_NULLVALUE )
    {
        // The current value is Null, treat it as a pixel unit with lCurrentPixelSize value
        SetValue ( lCurrentPixelSize, UNIT_PIXELS );
        // fall into one of the cases below
    }

    if ( uvtConvertTo == UNIT_NULLVALUE )
    {
        SetValue ( 0, UNIT_NULLVALUE );
    }
    else if ( IsScalerUnit ( GetUnitType() ) && IsScalerUnit ( uvtConvertTo )  )
    {
        SIZE sizeInch = g_uiDisplay.GetDocPixelsPerInch();
        // Simply converting between scaler units e.g. 20mm => 2px
        SetValue ( ConvertTo ( GetUnitValue(), GetUnitType(), uvtConvertTo, dir, lFontHeight, &sizeInch ), uvtConvertTo);
    }
    else if ( IsScalerUnit ( GetUnitType() ) )
    {
        // Convert from a scaler type to a non-scaler type e.g. 20.3in => %
        // Have no reference for conversion, max it out
        switch ( uvtConvertTo )
        {
        case UNIT_PERCENT:
            SetValue ( 100 * TypeNames [ UNIT_PERCENT ].wScaleMult, UNIT_PERCENT );
            break;

        case UNIT_TIMESRELATIVE:
            SetValue ( 1 * TypeNames [ UNIT_PERCENT ].wScaleMult, UNIT_TIMESRELATIVE );
            break;

        default:
            AssertSz ( FALSE, "Invalid type passed to ConvertToUnitType()" );
            return E_INVALIDARG;
        }
    }
    else if ( IsScalerUnit ( uvtConvertTo) )
    {
        // Convert from a non-scaler to a scaler type use the current pixel size
        // e.g. We know that 20% is equivalent to 152 pixels. So we convert
        // the current pixel value to the new metric unit
        SetValue ( ConvertTo ( lCurrentPixelSize, UNIT_PIXELS, uvtConvertTo, dir, lFontHeight ), uvtConvertTo );
    }
    else
    {
        // Convert between non-scaler types e,g, 20% => *
        // Since we have only two non-sclaer types right now:-
        switch ( uvtConvertTo )
        {
        case UNIT_PERCENT:  // From UNIT_TIMESRELATIVE
            // 1* == 100%
            SetValue ( MulDivQuick ( GetUnitValue(),
                100 * TypeNames [ UNIT_PERCENT ].wScaleMult,
                TypeNames [ UNIT_TIMESRELATIVE ].wScaleMult ) ,
                uvtConvertTo );
            break;

        case UNIT_TIMESRELATIVE: // From UNIT_PERCENT
            // 100% == 1*
            SetValue ( MulDivQuick ( GetUnitValue(),
                TypeNames [ UNIT_TIMESRELATIVE ].wScaleMult,
                TypeNames [ UNIT_PERCENT ].wScaleMult * 100 ) ,
                uvtConvertTo );
            break;

        default:
            AssertSz ( FALSE, "Invalid type passed to ConvertToUnitType()" );
            return E_INVALIDARG;
        }
    }
    return S_OK;
}


/* static */
BOOL CUnitValue::IsScalerUnit ( UNITVALUETYPE uvt ) 
{
    switch ( uvt )
    {
    case UNIT_POINT:
    case UNIT_PICA:
    case UNIT_INCH:
    case UNIT_CM:
    case UNIT_MM:
    case UNIT_PIXELS:
    case UNIT_EM:
    case UNIT_EX:
    case UNIT_FLOAT:
        return TRUE;

    default:
        return FALSE;
    }
}

HRESULT CUnitValue::SetFloatValueKeepUnits ( float fValue, 
                                             UNITVALUETYPE uvt, 
                                             long lCurrentPixelValue,
                                             DIRECTION dir,
                                             long lFontHeight)
{
    long lNewValue;

    // Set the new value to the equivalent of : fValue in uvt units
    // If the current value is a percent use the lCurrentPixelValue to
    // work out the new size

    // There are a number of restrictions on the uvt coming in. Since it's either
    // Document Units when called from CUnitMeasurement::SetValue or
    // PIXELS when called from CUnitMeasurement::SetPixelValue we restrict our
    // handling to the possible doc unit types - which are all the "metric" types

    lNewValue = (long) ( fValue * (float)TypeNames [ uvt ].wScaleMult );
    
    if ( uvt == GetUnitType() )
    {
        SetValue ( lNewValue, uvt );
    }
    else if ( uvt == UNIT_NULLVALUE || !IsScalerUnit ( uvt ) )
    {
        return E_INVALIDARG;
    }
    else if ( GetUnitType() == UNIT_NULLVALUE )
    {
        // If we're current NUll, just set to the new value
        SetValue ( lNewValue, uvt );
    }
    else if ( IsScalerUnit ( GetUnitType() ) )
    {
        // If the conversion is to/from metric units, just convert units
        SetValue ( ConvertTo ( lNewValue, uvt, GetUnitType(), dir, lFontHeight ), GetUnitType() );
    }
    else
    {
        // unit value holds a relative unit,
        // Convert the fValue,uvt to pixels
        lNewValue = ConvertTo ( lNewValue, uvt, UNIT_PIXELS, dir, lFontHeight );

        if ( GetUnitType() == UNIT_PERCENT )
        {
            SetValue ( MulDivQuick ( lNewValue, 
                                     100*TypeNames [ UNIT_PERCENT ].wScaleMult, 
                                     (!! lCurrentPixelValue) ?  lCurrentPixelValue : 1), // don't pass in 0 for divisor
                UNIT_PERCENT );
        }
        else
        {
            // Cannot keep units without loss of precision, over-ride
            SetValue ( lNewValue, UNIT_PIXELS );
        }
    }
    return S_OK;
}

HRESULT CUnitValue::SetFloatUnitValue ( float fValue )
{
    // Set the value from fValue
    // but keep the internaly stored units intact
    UNITVALUETYPE uvType;

    if ( ( uvType = GetUnitType()) == UNIT_NULLVALUE )
    {
        // This case can only happen if SetUnitValue is called when the current value is NULL
        // so force a unit type
        uvType = UNIT_PIXELS;
    }

    // Convert the fValue into a CUnitValue with current unit
    SetValue ( (long)(fValue * (float)TypeNames [ uvType ].wScaleMult),
        uvType );
    return S_OK;
}

//
// Support for CColorValue follows.
//
// IEUNIX: color value starts from 0x10.

extern const struct COLORVALUE_PAIR aColorNames[];
extern const struct COLORVALUE_PAIR aSystemColors[];
extern const INT cbSystemColorsSize;

HRESULT
CColorValue::Persist (
    IStream *pStream,
    const PROPERTYDESC * pPropDesc ) const
{
    TCHAR cBuffer[ 64 ];
    HRESULT hr;

    Assert( S_OK == IsValid() );

    hr = FormatBuffer( cBuffer, ARRAY_SIZE( cBuffer ), pPropDesc );
    if (hr)
        goto Cleanup;

    hr = WriteText( pStream, cBuffer );

Cleanup:
    RRETURN ( hr );
}

HRESULT
CColorValue::FormatBuffer (
    TCHAR * szBuffer,
    UINT uMaxLen,
    const PROPERTYDESC *pPropDesc,
    BOOL fReturnAsHex6 /*==FALSE */) const
{
    HRESULT hr = S_OK;
    const struct COLORVALUE_PAIR * pColorPair;
    LONG lValue;
    DWORD type = GetType();
    INT idx;
    DWORD dwSysColor;
    TCHAR achFmt[5] = _T("<0C>");

    switch (type)
    {
        default:
        case TYPE_UNDEF:
            *szBuffer = 0;
            break;

        case TYPE_NAME:
            // requests from the OM set fReturnAsHex to true, so instead
            // of returning "red; we want to return "#ff0000"
            if (!fReturnAsHex6)
            {
                pColorPair = FindColorByValue( GetRawValue() );
                Assert(pColorPair);
                _tcsncpy( szBuffer, pColorPair->szName, uMaxLen );
                break;
            }
            // else fall through !!!

        case TYPE_RGB:
            // requests from the OM set fReturnAsHex to true, so instead
            // of returning "rgb(255,0,0)" we want to return "#ff0000"
            if (!fReturnAsHex6)
            {
                hr = Format(0, szBuffer, uMaxLen, _T("rgb(<0d>,<1d>,<2d>)"), (_dwValue & 0x0000FF), (_dwValue & 0x00FF00)>>8, (_dwValue & 0xFF0000)>>16);
                break;
            }
            // else fall through !!!

        case TYPE_SYSINDEX:
        case TYPE_POUND6:
        case TYPE_POUND5:
        case TYPE_POUND4:
            achFmt[2] = _T('c');

        case TYPE_POUND3:
        case TYPE_POUND2:
        case TYPE_POUND1:
            lValue = (LONG)GetColorRef();
            if (fReturnAsHex6)
            {
                achFmt[2] = _T('c');
            }
            hr = Format(0, szBuffer, uMaxLen, achFmt, lValue);
            if (!fReturnAsHex6 && (type != TYPE_POUND6))
            {
                szBuffer[((TYPE_POUND1 - type)>>24) + 2] = _T('\0');
            }
            break;

#ifdef UNIX
        case TYPE_UNIXSYSCOL:
            hr = E_INVALIDARG;
            if (!g_fSysColorInit)
                InitColorTranslation();

            for (int idx = 0; idx < ARRAY_SIZE(g_acrSysColor); idx++)
			{
                if ( _dwValue == g_acrSysColor[idx] )
                {
                    _tcsncpy( szBuffer, aSystemColors[idx].szName, uMaxLen );
                    hr = S_OK;
                    break;
                }
			}
            if ( hr )
                AssertSz ( FALSE, "Invalid Color Stored" );
            break;
#endif

        case TYPE_SYSNAME:
            dwSysColor = (_dwValue & MASK_SYSCOLOR)>>24;
            hr = E_INVALIDARG;
            for ( idx = 0; idx < cbSystemColorsSize; idx++ )
            {
                if ( dwSysColor == aSystemColors[idx].dwValue )
                {
                    _tcsncpy( szBuffer, aSystemColors[idx].szName, uMaxLen );
                    hr = S_OK;
                    break;
                }
            }
            AssertSz ( !hr, "Invalid Color Stored" );
            break;
        case TYPE_TRANSPARENT:
            _tcsncpy( szBuffer, _T("transparent"), uMaxLen );
            break;
    }
    RRETURN ( hr );
}

DWORD 
CColorValue::GetIntoRGB(void) const
{
    DWORD dwRet = GetColorRef();
    return ((dwRet & 0xFF) << 16) | (dwRet & 0xFF00) | ((dwRet & 0xFF0000) >> 16);
}

COLORREF
CColorValue::GetColorRef() const
{
    if ( IsSysColor() )
        return (COLORREF)GetSysColorQuick((_dwValue & MASK_SYSCOLOR)>>24);

#ifdef UNIX
        if ( IsUnixSysColor()) 
            return (COLORREF)_dwValue;
#endif

    return (COLORREF) ((_dwValue & MASK_COLOR) | 0x02000000);
}

// Allocates and returns a string reperesenting the color value as #RRGGBB
HRESULT 
CColorValue::FormatAsPound6Str(BSTR *pszColor, DWORD dwColor)
{
    HRESULT     hr;
    OLECHAR     szBuf[8];

    hr = THR(Format(0, szBuf, ARRAY_SIZE(szBuf), _T("<0c>"), dwColor));
    if(hr)
        goto Cleanup;

    hr = FormsAllocString(szBuf, pszColor);

Cleanup:
    RRETURN(hr);
}

HRESULT
BASICPROPPARAMS::GetColor(CVoid * pObject, BSTR * pbstrColor, 
                          BOOL fReturnAsHex /* == FALSE */) const
{
    HRESULT hr;
    TCHAR szBuffer[64];
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_GETMFHandler));

    cvColor = (CColorValue)GetAvNumber (pObject, this + 1, sizeof(CColorValue));
    hr = cvColor.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL, fReturnAsHex );
    if ( hr )
        goto Cleanup;

    hr = FormsAllocString(szBuffer, pbstrColor);
Cleanup:
    RRETURN( hr );
}


HRESULT
BASICPROPPARAMS::GetColor(CVoid * pObject, CStr * pcstr, 
                          BOOL fReturnAsHex/* =FALSE*/, BOOL *pfValuePresent /*= NULL*/) const
{
    HRESULT hr;
    TCHAR szBuffer[64];
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_GETMFHandler));

    cvColor = (CColorValue)GetAvNumber (pObject, this + 1, sizeof(CColorValue), pfValuePresent);
    hr = cvColor.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL, fReturnAsHex );
    if ( hr )
        goto Cleanup;
    hr = pcstr->Set( szBuffer );
Cleanup:
    RRETURN( hr );
}

HRESULT
BASICPROPPARAMS::GetColor(CVoid * pObject, DWORD * pdwValue) const
{
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_GETMFHandler));

    cvColor = (CColorValue)GetAvNumber (pObject, this + 1, sizeof(CColorValue));
    *pdwValue = cvColor.GetRawValue();

    return S_OK;
}

HRESULT
BASICPROPPARAMS::SetColor(CVoid * pObject, TCHAR * pch, WORD wFlags) const
{
    HRESULT hr;
    CColorValue cvColor;

    hr = cvColor.FromString(pch);
    if (hr)
        goto Cleanup;

    Assert(!(dwPPFlags & PROPPARAM_SETMFHandler));

    hr = THR( SetAvNumber ( pObject, (DWORD)cvColor.GetRawValue(), this+1, sizeof ( CColorValue ), wFlags ) );

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

HRESULT
BASICPROPPARAMS::SetColor(CVoid * pObject, DWORD dwValue, WORD wFlags) const
{
    HRESULT hr;
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_SETMFHandler));

    cvColor.SetRawValue(dwValue);

    hr = THR( SetAvNumber ( pObject, (DWORD)cvColor.GetRawValue(), this+1, sizeof ( CColorValue ), wFlags ) );

    RRETURN1(hr,E_INVALIDARG);
}



//+-----------------------------------------------------
//
//  Member : StripCRLF
//
//  Synopsis : strips CR and LF from a provided string
//      the returned string has been allocated and needs 
//      to be freed by the caller.
//
//+-----------------------------------------------------
static HRESULT
StripCRLF(TCHAR *pSrc, TCHAR **ppDest)
{
    HRESULT hr = S_OK;
    long    lLength;
    TCHAR  *pTarget = NULL;


    if (!ppDest)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( !pSrc )
        goto Cleanup;

    lLength = _tcslen(pSrc);
    *ppDest= (TCHAR*)MemAlloc(Mt(StripCRLF), sizeof(TCHAR)*(lLength+1));
    if (!*ppDest)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pTarget = *ppDest;

    for (; lLength>0; lLength--)
    {
        if ((*pSrc != _T('\r')) && (*pSrc != _T('\n'))) 
        {
            // we want it.
            *pTarget = *pSrc;
            pTarget++;
        }
        pSrc++;
    }

    *pTarget = _T('\0');

Cleanup:
    RRETURN(hr);
}


HRESULT ttol_with_error ( LPCTSTR pStr, long *plValue )
{
    // Always do base 10 regardless of contents of 
    RRETURN1 ( PropertyStringToLong ( pStr, NULL, 10, 0, (unsigned long *)plValue ), E_INVALIDARG );
}


static HRESULT RTCCONV PropertyStringToLong (
        LPCTSTR nptr,
        TCHAR **endptr,
        int ibase,
        int flags,
        unsigned long *plNumber )
{
        const TCHAR *p;
        TCHAR c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        *plNumber = 0;                  /* on error result is 0 */

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while (_istspace(c))
            c = *p++;                   /* skip whitespace */

        if (c == '-') 
        {
            flags |= FL_NEG;        /* remember minus sign */
            c = *p++;
        }
        else if (c == '+')
            c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) 
        {
            /* bad base! */
            if (endptr)
                    /* store beginning of string in endptr */
                    *endptr = (TCHAR *)nptr;
            return E_INVALIDARG;              /* return 0 */
        }
        else if (ibase == 0) 
        {
            /* determine base free-lance, based on first two chars of
               string */
            if (c != L'0')
                    ibase = 10;
            else if (*p == L'x' || *p == L'X')
                    ibase = 16;
            else
                    ibase = 8;
        }

        if (ibase == 16) 
        {
            /* we might have 0x in front of number; remove if there */
            if (c == L'0' && (*p == L'x' || *p == L'X')) 
            {
                    ++p;
                    c = *p++;       /* advance past prefix */
            }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) 
        {      /* exit in middle of loop */
            /* convert c to value */
            if (_istdigit(c))
                    digval = c - L'0';
            else if (_istalpha(c))
            {
                if ( ibase > 10 )
                {
                    if (c >= 'a' && c <= 'z')
                        digval = (unsigned)c - 'a' + 10;
                    else
                        digval = (unsigned)c - 'A' + 10;
                }
                else
                {
                    return E_INVALIDARG;              /* return 0 */
                }
            }
            else
                break;

            if (digval >= (unsigned)ibase)
                break;          /* exit loop if bad digit found */

            /* record the fact we have read one digit */
            flags |= FL_READDIGIT;

            /* we now need to compute number = number * base + digval,
               but we need to know if overflow occured.  This requires
               a tricky pre-check. */

            if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) 
            {
                    /* we won't overflow, go ahead and multiply */
                    number = number * ibase + digval;
            }
            else 
            {
                    /* we would have overflowed -- set the overflow flag */
                    flags |= FL_OVERFLOW;
            }

            c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) 
        {
            number = 0L;                        /* return 0 */

            /* no number there; return 0 and point to beginning of
               string */
            if (endptr)
                /* store beginning of string in endptr later on */
                p = nptr;

            return E_INVALIDARG;            // Return error not a number
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
            /* overflow or signed overflow occurred */
            //errno = ERANGE;
            if ( flags & FL_UNSIGNED )
                    number = ULONG_MAX;
            else if ( flags & FL_NEG )
                    number = (unsigned long)(-LONG_MIN);
            else
                    number = LONG_MAX;
        }

        if (endptr != NULL)
            /* store pointer to char that stopped the scan */
            *endptr = (TCHAR *)p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        *plNumber = number; 
        return S_OK;                  /* done. */
}

//+---------------------------------------------------------------------------
//
//  Member: PROPERTYDESC::HandleCodeProperty
//
//+---------------------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleCodeProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT             hr = S_OK;
    BASICPROPPARAMS *   ppp = (BASICPROPPARAMS *)(this + 1);

    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...

        //
        // Assert ( actualTypeOf(pv) == (VARIANT*) );
        //

        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
        case HANDLEPROP_VALUE:
            hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            break;

        case HANDLEPROP_AUTOMATION:

            // Assert ( actualTypeOf(pv) == (VARIANT*) );
            Assert (PROPTYPE_VARIANT == PROPTYPE(dwOpCode) && "Only this type supported for this case");

            hr = THR(ppp->SetCodeProperty( (VARIANT*)pv, pObject, pSubObject));
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
        case HANDLEPROP_STREAM:
            hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            break;

        case HANDLEPROP_COMPARE:
            hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            RRETURN1(hr,S_FALSE);
            break;

        case HANDLEPROP_AUTOMATION:
            if (!pv)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            Assert (PROPTYPE_VARIANT == PROPTYPE(dwOpCode) && "Only V_DISPATCH supported for this case");

            hr = THR(ppp->GetCodeProperty ((VARIANT*)pv, pObject, pSubObject));
            if (hr)
                goto Cleanup;
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }

Cleanup:

    RRETURN1(hr, E_INVALIDARG);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase::SetCodeProperty
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetCodeProperty (DISPID dispidCodeProp, IDispatch *pDispCode, BOOL *pfAnyDeleted /* = NULL */)
{
    HRESULT hr = S_OK;
    BOOL    fAnyDelete;

    fAnyDelete = DidFindAAIndexAndDelete (dispidCodeProp, CAttrValue::AA_Attribute);
    fAnyDelete |= DidFindAAIndexAndDelete (dispidCodeProp, CAttrValue::AA_Internal);

    if (pDispCode)
    {
        hr = THR(AddDispatchObject(
            dispidCodeProp,
            pDispCode,
            CAttrValue::AA_Internal,
            CAttrValue::AA_Extra_OldEventStyle));
    }

    // if this is an element, let it know that events can now fire
    IGNORE_HR(OnPropertyChange(DISPID_EVPROP_ONATTACHEVENT, 0));

    if (pfAnyDeleted)
        *pfAnyDeleted = fAnyDelete;

    RRETURN (hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_StyleComponent(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StyleComponentHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_StyleComponentHelper(BSTR v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->SetStyleComponentProperty(v, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Url(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_UrlHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_UrlHelper(BSTR v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);
    
    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->SetUrlProperty(v, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_String(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StringHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_StringHelper(BSTR v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                         (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    switch (pPropDesc->GetBasicPropParams()->wInvFunc)
    {
    case IDX_GS_BSTR:
        return pPropDesc->GetBasicPropParams()->SetStringProperty(v, this, pSubObj, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
    case IDX_GS_PropEnum:
        return pPropDesc->GetNumPropParams()->SetEnumStringProperty(v, this, pSubObj, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
    }
    return S_OK;
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Short(short v)
{
    GET_THUNK_PROPDESC
    return put_ShortHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_ShortHelper(short v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetNumPropParams()->SetNumberProperty(v, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()), TRUE, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Long(long v)
{
    GET_THUNK_PROPDESC
    return put_LongHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_LongHelper(long v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                        (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    return pPropDesc->GetNumPropParams()->SetNumberProperty(v, this, pSubObj, TRUE, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Bool(VARIANT_BOOL v)
{
    GET_THUNK_PROPDESC
    return put_BoolHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_BoolHelper(VARIANT_BOOL v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                        (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    return pPropDesc->GetNumPropParams()->SetNumberProperty(v, this, pSubObj, TRUE, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Variant(VARIANT v)
{
    GET_THUNK_PROPDESC
    return put_VariantHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_VariantHelper(VARIANT v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return SetErrorInfo((pPropDesc->*pPropDesc->pfnHandleProperty)(HANDLEPROP_SET | HANDLEPROP_AUTOMATION | (fRuntimeStyle ? HANDLEPROP_RUNTIMESTYLE : 0) | (PROPTYPE_VARIANT << 16),
                                                                   &v,
                                                                   this,
                                                                   ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::get_Url(BSTR *p)
{
    GET_THUNK_PROPDESC
    return get_UrlHelper(p, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::get_UrlHelper(BSTR *p, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_GET_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->GetUrlProperty(p, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::get_StyleComponent(BSTR *p)
{
    GET_THUNK_PROPDESC
    return get_StyleComponentHelper(p, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::get_StyleComponentHelper(BSTR *p, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_GET_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->GetStyleComponentProperty(p, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::get_Property(void *p)
{
    GET_THUNK_PROPDESC
    return get_PropertyHelper(p, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::get_PropertyHelper(void *p, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_GET_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                        (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    switch (pPropDesc->GetBasicPropParams()->wInvFunc)
    {
    case IDX_G_VARIANT:
    case IDX_GS_VARIANT:
    	return SetErrorInfo((pPropDesc->*pPropDesc->pfnHandleProperty)(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16), p, this, pSubObj));
    case IDX_G_VARIANTBOOL:
    case IDX_GS_VARIANTBOOL:
    case IDX_G_long:
    case IDX_GS_long:
    case IDX_G_short:
    case IDX_GS_short:
	    return pPropDesc->GetNumPropParams()->GetNumberProperty(p, this, pSubObj);
    case IDX_G_BSTR:
    case IDX_GS_BSTR:
        return pPropDesc->GetBasicPropParams()->GetStringProperty((BSTR *)p, this, pSubObj);
    case IDX_G_PropEnum:
    case IDX_GS_PropEnum:
        return pPropDesc->GetNumPropParams()->GetEnumStringProperty((BSTR *)p, this, pSubObj);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::SetCodeProperty
//
//----------------------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetCodeProperty(VARIANT *pvarCode, CBase * pObject, CVoid *) const
{
    HRESULT hr = S_OK;

    Assert ((dwPPFlags & PROPPARAM_ATTRARRAY) && "only attr array support implemented for 'type:code'");

    if ( V_VT(pvarCode) == VT_NULL )
    {
        hr = pObject->SetCodeProperty(dispid, NULL);
    }
    else if ( V_VT(pvarCode) == VT_DISPATCH )
    {
        hr = pObject->SetCodeProperty(dispid, V_DISPATCH(pvarCode) );
    }
    else if ( V_VT(pvarCode) == VT_BSTR )
    {
        pObject->FindAAIndexAndDelete (dispid, CAttrValue::AA_Internal);
        hr = THR(pObject->AddString(dispid, V_BSTR(pvarCode),CAttrValue::AA_Attribute ));
    }
    else
    {
        hr = E_NOTIMPL;
    }

    if (!hr)
        hr = THR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));


    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetCodeProperty
//
//----------------------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetCodeProperty (VARIANT *pvarCode, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK;
    AAINDEX     aaidx;

    V_VT(pvarCode) = VT_NULL;

    Assert ((dwPPFlags & PROPPARAM_ATTRARRAY) && "only attr array support implemented for 'type:code'");

    aaidx = pObject->FindAAIndex(dispid, CAttrValue::AA_Internal);
    if ((AA_IDX_UNKNOWN != aaidx) && (pObject->GetVariantTypeAt(aaidx) == VT_DISPATCH))
    {
        hr = THR(pObject->GetDispatchObjectAt(aaidx, &V_DISPATCH(pvarCode)) );
        if ( hr )
            goto Cleanup;
        V_VT(pvarCode) = VT_DISPATCH;
    }
    else
    {
        LPCTSTR szCodeText;
        aaidx = pObject->FindAAIndex(dispid, CAttrValue::AA_Attribute);
        if (AA_IDX_UNKNOWN != aaidx)
        {
            hr = THR(pObject->GetStringAt(aaidx, &szCodeText) );
            if ( hr )
                goto Cleanup;
            hr = FormsAllocString ( szCodeText, &V_BSTR(pvarCode) );
            if ( hr )
                goto Cleanup;            
            V_VT(pvarCode) = VT_BSTR;
        }
    }
Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Helper Function:    NextParenthesizedToken
//
//  Synopsis:
//      This function tokenizes a word or functional notation.
//      Expects string to have no leading whitespace.
//
//  Return Values:
//      "" if the end of the string was reached.
//      pointer to following characters if success.
//-------------------------------------------------------------------------
TCHAR *NextParenthesizedToken( TCHAR *pszToken )
{
    int iParenDepth = 0;
    BOOL fInQuotes = FALSE;
    TCHAR quotechar = _T('"');

    while ( *pszToken && ( iParenDepth || !_istspace( *pszToken ) ) )
    {
        if ( !fInQuotes )
        {
            if ( ( *pszToken == _T('\'') ) || ( *pszToken == _T('"') ) )
            {
                fInQuotes = TRUE;
                quotechar = *pszToken;
            }
            else if ( iParenDepth && ( *pszToken == _T(')') ) )
                iParenDepth--;
            else if ( *pszToken == _T('(') )
                iParenDepth++;
        }
        else if ( quotechar == *pszToken )
        {
            fInQuotes = FALSE;
        }
        pszToken++;
    }
    return pszToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\cache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cache.cxx
//
//  Contents:   CServer implmentation of IOleCache2
//
//  Classes:    CServer
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CServerEnumCacheAry, Locals, "CServer::EnumCache CDataAry<STATDATA>")
MtDefine(CServerEnumCacheAry_pv, CServerEnumCacheAry, "CServer::EnumCache CDataAry<STATDATA>::_pv")
DECLARE_CDataAry(CServerEnumCacheAry, STATDATA, Mt(CServerEnumCacheAry), Mt(CServerEnumCacheAry_pv))

//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureCache, public
//
//  Synopsis:   Initializes the cache object by creating the default data
//              cache and initializing its storage if necessary.
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::EnsureCache()
{
    HRESULT hr;

    //
    // Return immediatly if already initialized.
    //

    if (_pCache)
        return S_OK;

    hr = THR(CreateDataCache(NULL, CLSID_NULL, IID_IOleCache2,
            (void **)&_pCache));
    if (hr)
        goto Error;

    hr = THR(_pCache->QueryInterface(IID_IPersistStorage,
            (void **)&_pPStgCache));
    if (hr)
        goto Error;

    // QUESTION: Is it ok to ignore erros from pDefPstg methods called below?
    // If so, then use IGNORE_HR macro.

    if (_state >= OS_LOADED)
    {
        if (_pStg)
        {
            if (_fInitNewed)
            {
                _pPStgCache->InitNew(_pStg);
            }
            else
            {
                _pPStgCache->Load(_pStg);
                //
                // REVIEW - We fail if our container does a QI for IOleCache[2]
                // after calling Save() but before SaveCompleted().
                //
                if (_fNoScribble)
                {
                    TraceTag((tagError, "Attempt to QI for IOleCache(2) "
                                   "after a call to Save but before calling "
                                   "SaveCompleted!"));
                    TraceTag((tagError, "Fatal: Returning E_UNEXPECTED."));
                    hr = E_UNEXPECTED;
                    goto Error;
                }
            }
        }
        else if (_fHandsOff)
        {
            //
            // REVIEW - The Ctrl object is in Hands-Off state.  A QI for
            // IOleCache[2] is illegal at this time.
            //
            TraceTag((tagError, "Attempt to QI for IOleCache(2) "
                           "after a call to HandsOffStorage but before calling "
                           "SaveCompleted!"));
            TraceTag((tagError, "Fatal: Returning E_UNEXPECTED."));
            hr = E_UNEXPECTED;
            goto Error;
        }
        else
        {
            //  The control is using IPersistStreamInit which means we can't
            //  persist the cache data.  We have chosen to fail in this case,
            //  since the cache is not useful.
            //
            TraceTag((
                    tagError,
                    "Attempt to QI for IOleCache(2) on an "
                    "object which is being stored using IPersistStreamInit!"));
            TraceTag((tagError, "Fatal: Returning E_UNEXPECTED."));
            hr = E_UNEXPECTED;
            goto Error;
        }
    }

    hr = THR(_pCache->QueryInterface(IID_IViewObject2,
            (LPVOID*)&_pViewObjectCache));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    ClearInterface(&_pCache);
    ClearInterface(&_pPStgCache);
    ClearInterface(&_pViewObjectCache);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::Cache, IOleCache
//
//  Synopsis:   Caches data
//
//  Arguments:  [petc]          -- Format to cache
//              [advf]          -- Cache flags
//              [pdwConnection] -- Place to put connection id.
//
//  Returns:    HRESULT
//
//  Notes:      As a DLL server, we normally do implicit caching of all our
//              data types.  The only exceptions are for the icon aspect and
//              if the ADVFCACHE_FORCEBUILTIN flag is specified.  Note that
//              the cache will not be persistent unless the container saves
//              us using a storage (as opposed to a stream).
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::Cache(FORMATETC *petc, DWORD advf, DWORD *pdwConnection)
{
    HRESULT hr;

    if (petc == NULL)
        RRETURN(E_INVALIDARG);

    if (petc->lindex != -1)
        RRETURN(DV_E_LINDEX);

    if (pdwConnection)
        *pdwConnection = 0;

    if ((petc->cfFormat == 0) ||
        (FindCompatibleFormat(ServerDesc()->_pGetFmtTable,
                              ServerDesc()->_cGetFmtTable,
                              *petc) != -1))
    {
        if ((advf & ADVFCACHE_FORCEBUILTIN) ||
            (petc->dwAspect == DVASPECT_ICON))
        {
            hr = THR(EnsureCache());
            if (hr)
                goto Cleanup;

             hr = THR(_pCache->Cache(petc, advf, pdwConnection));
        }
        else
        {
            // Implicit data type, so we return S_OK with a connection ID of
            // zero.
            hr = S_OK;
        }
    }
    else
    {
        //
        // Not a recognized format.
        //

        hr = DV_E_CLIPFORMAT;
    }

Cleanup:
    RRETURN2(hr, CACHE_S_FORMATETC_NOTSUPPORTED, CACHE_S_SAMECACHE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::Uncache, IOleCache
//
//  Synopsis:   Uncaches a previously cached data type
//
//  Arguments:  [dwConnection] -- Connection ID returned from call to ::Cache
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::Uncache(DWORD dwConnection)
{
    HRESULT hr;

    if (dwConnection == 0)     // They're uncaching an implicit data type.
        return S_OK;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->Uncache(dwConnection));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnumCache, IOleCache
//
//  Synopsis:   Enumerates current cache nodes, including implicitely cached
//              data (which is pretty much everything).
//
//  Arguments:  [ppenumSTATDATA] -- Place to put enumerator
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::EnumCache(IEnumSTATDATA **ppenumSTATDATA)
{
    //
    // Due to the format of the GetFmtTable in the class descriptor, we
    // have to do some extra work here...
    //
    LPENUMSTATDATA          penum;
    const FORMATETC *       petc;
    STATDATA                statdata;
    int                     i;
    HRESULT                 hr;
    CServerEnumCacheAry *   pAryStat;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    pAryStat = new CServerEnumCacheAry;
    if (!pAryStat)
        RRETURN(E_OUTOFMEMORY);

    petc = ServerDesc()->_pGetFmtTable;

    statdata.advf   = 0;
    statdata.pAdvSink = NULL;
    statdata.dwConnection = 0;

    //
    // First, build our array of supported (implicitly cached) formats...
    //
    for (i = 0; i < ServerDesc()->_cGetFmtTable; i++)
    {
        statdata.formatetc = petc[i];

        pAryStat->AppendIndirect(&statdata);
    }

    //
    // Next, determine which formats are explictely cached and update the
    // info on them.
    //

    if (_pCache &&
            SUCCEEDED(_pCache->EnumCache(&penum)) && (penum != NULL))
    {
        while (penum->Next(1, &statdata, NULL) == S_OK)
        {
            for (i=0; i < pAryStat->Size(); i++)
            {
                if (statdata.formatetc.dwAspect == (*pAryStat)[i].formatetc.dwAspect)
                {
                    (*pAryStat)[i].advf = statdata.advf;
                    (*pAryStat)[i].dwConnection = statdata.dwConnection;
                }
            }

            CoTaskMemFree(statdata.formatetc.ptd);
            if (statdata.pAdvSink)
                statdata.pAdvSink->Release();
        }
        penum->Release();
    }

    //
    // The enumerator created during this call will delete pAryStat when
    // appropriate.
    //

    hr = THR(pAryStat->EnumElements(IID_IEnumSTATDATA,
            (LPVOID*)ppenumSTATDATA,
            FALSE, FALSE, TRUE));

    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    delete pAryStat;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::InitCache, public
//
//  Synopsis:   Initializes the cache.
//
//  Arguments:  [pDataObject] -- Data object to initialize from
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::InitCache(IDataObject *pDataObject)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->InitCache(pDataObject));

Cleanup:
    RRETURN1(hr, CACHE_S_SOMECACHES_NOTUPDATED);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetData, IOleObject
//
//  Synopsis:   Sets the data in the cache for a particlar data format.
//
//  Arguments:  [pformatetc] -- Format description
//              [pmedium]    -- Data
//              [fRelease]   -- If TRUE, pmedium will be released
//
//  Returns:    HRESULT
//
//  Notes:      We only allow the DVASPECT_ICON data to be set using this
//              method. All the other formats are implicitely cached.
//
//              Note that this function is renamed for SetData to SetDataCache
//              to avoid conflicts with IDataObject::SetData
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::SetDataCache(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    //
    // The only data we allow a caller to set is the icon
    //
    if (pformatetc->dwAspect == DVASPECT_ICON)
    {
        hr = THR(_pCache->SetData(pformatetc, pmedium, fRelease));
    }
    else
    {
        hr = THR(QueryGetData(pformatetc));

        if (SUCCEEDED(hr) && fRelease)
        {
            ReleaseStgMedium(pmedium);
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::UpdateCache, IOleCache
//
//  Synopsis:   Updates the cache. Delegated to the default cache impl.
//
//  Arguments:  [pDataObject] -- Object to use for updating data
//              [grfUpdf]     -- Update flags
//              [pReserved]   -- Reserved
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::UpdateCache(LPDATAOBJECT pDataObject,
                       DWORD grfUpdf,
                       LPVOID pReserved)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->UpdateCache(pDataObject, grfUpdf, pReserved));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::DiscardCache, public
//
//  Synopsis:   Discards the cache. Delegated to the default cache impl.
//
//  Arguments:  [dwDiscardOptions] -- Discard flags
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DiscardCache(DWORD dwDiscardOptions)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->DiscardCache(dwDiscardOptions));

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\cnct.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cnct.cxx
//
//  Contents:   Connections interfaces and implementations (part 1 of 2).
//
//  History:    12-22-93   adams   Created
//              5-22-95    kfl     converted WCHAR to TCHAR
//              2-21-96    LyleC   Cleaned out unused stuff
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CEnumConnections, ObjectModel, "CEnumConnections")
MtDefine(CEnumConnectionsCreate_pary, Locals, "CEnumConnections::Create pary")
MtDefine(CEnumConnectionsCreate_pary_pv, CEnumConnectionsCreate_pary, "CEnumConnections::Create pary->_pv")

//+------------------------------------------------------------------------
//
//  CEnumConnections Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumConnections::Create(
        int                 ccd,
        CONNECTDATA *       pcd,
        CEnumConnections ** ppenum)
{
    HRESULT                 hr      = S_OK;
    CEnumConnections *      penum   = NULL;
    CDataAry<CONNECTDATA> * pary = NULL;
    CONNECTDATA *           pcdT;
    int                     c;
    int                     cNonNull;

    Assert(ppenum);
    *ppenum = NULL;

    penum = new CEnumConnections;
    if (!penum)
        goto MemError;

    pary = new(Mt(CEnumConnectionsCreate_pary)) CDataAry<CONNECTDATA>(Mt(CEnumConnectionsCreate_pary_pv));
    if (!pary)
        goto MemError;

    Assert(!penum->_pary);

    //  Copy the AddRef'd array of pointers into a CFormsAry
    hr = THR(pary->EnsureSize(ccd));
    if (hr)
        goto Error;

    cNonNull = 0;
    for (c = ccd, pcdT = pcd; c > 0; c--, pcdT++)
    {
        if (pcdT->pUnk)
        {
            (*pary)[cNonNull] = *pcdT;
            pcdT->pUnk->AddRef();
            cNonNull++;
        }
    }

    pary->SetSize(cNonNull);
    penum->_pary = pary;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

MemError:
    hr = E_OUTOFMEMORY;
    // fall through

Error:
    ReleaseInterface(penum);
    delete pary;

    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::CEnumConnections
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumConnections::CEnumConnections(void) :
        CBaseEnum(sizeof(IUnknown *), IID_IEnumConnections, TRUE, TRUE)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::~CEnumConnections
//
//  Synopsis:   dtor.
//
//  History:    10-12-99   alanau   Created
//
//----------------------------------------------------------------------------

CEnumConnections::~CEnumConnections()
{
    if (_pary && _fDelete)
    {
        if ( _fAddRef )
        {
            CONNECTDATA * pcdT;
            int         i;
            int         cSize = _pary->Size();
            
            for (i=0, pcdT = (CONNECTDATA *) Deref(0);
                 i < cSize;
                 i++, pcdT++)
            {
                pcdT->pUnk->Release();
            }
        }

        delete _pary;
        _pary = NULL;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::CEnumConnections
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumConnections::CEnumConnections(const CEnumConnections & enumc)
    : CBaseEnum(enumc)
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::Next
//
//  Synopsis:   Per IEnumConnections::Next.
//
//  History:    12-28-93   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CEnumConnections::Next(
        ULONG           ulConnections,
        void *          reelt,
        ULONG *         lpcFetched)
{
    HRESULT         hr;
    CONNECTDATA *   pCD;               // CONNECTDATA's to enumerate
    CONNECTDATA *   pCDEnd;            // end of CONNECTDATA's
    CONNECTDATA *   pCDSrc;
    int             iActual;           // elems returned

    // Determine number of elements to enumerate.
    if (_i + (int) ulConnections <= _pary->Size())
    {
        hr = S_OK;
        iActual = (int) ulConnections;
    }
    else
    {
        hr = S_FALSE;
        iActual = _pary->Size() - _i;
    }

    if (iActual > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (lpcFetched)
    {
        *lpcFetched = (ULONG) iActual;
    }

    // Return elements to enumerate.
    pCDEnd = (CONNECTDATA *) reelt + iActual;
    for (pCD = (CONNECTDATA *) reelt, pCDSrc = (CONNECTDATA *) Deref(_i);
        pCD < pCDEnd;
        pCD++, pCDSrc++)
    {
        *pCD = *pCDSrc;
        pCD->pUnk->AddRef();
    }

    _i += iActual;

    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::Clone
//
//  Synopsis:   Per IEnumConnections::Clone.
//
//  History:    12-28-93   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CEnumConnections::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(Create(
            _pary->Size(),
            (CONNECTDATA *)(LPVOID)*_pary,
            (CEnumConnections **) ppenum));
    if (hr)
        RRETURN(hr);

    (* (CEnumConnections **) ppenum)->_i = _i;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\connect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       connect.cxx
//
//  Contents:   Connection points.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

MtDefine(CConnectionPointContainer, ObjectModel, "CConnectionPointContainer")
MtDefine(CCPCEnumCPAry, Locals, "CConnectionPointContainer::EnumConnectionPoints CPtrAry<IConnectionPoint *>")
MtDefine(CCPCEnumCPAry_pv, CCPCEnumCPAry, "CConnectionPointContainer::EnumConnectionPoints CPtrAry<IConnectionPoint *>::_pv")
MtDefine(CConnectionPtEnumConnectionsAry_pv, Locals, "CConnectionPt::EnumConnections CPtrAry<LPUNKNOWN>::_pv")

DECLARE_CPtrAry(CCPCEnumCPAry, IConnectionPoint *, Mt(CCPCEnumCPAry), Mt(CCPCEnumCPAry_pv))

EXTERN_C const IID DIID_HTMLElementEvents;
EXTERN_C const IID DIID_HTMLControlElementEvents;
EXTERN_C const IID IID_IControlEvents;

#ifdef _WIN64
DWORD   g_dwCookieForWin64 = 0;
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CBase::DoAdvise
//
//  Synopsis:   Implements IConnectionPoint::Advise.
//
//  Arguments:  [ppUnkSinkOut]    -- Pointer to outgoing sink ptr.
//              [iid]             -- Interface of the advisee.
//              [fEvent]          -- Whether it's an event iface advise
//              [pUnkSinkAdvise]  -- Advisee's sink.
//              [pdwCookie]       -- Cookie to identify connection.
//
//----------------------------------------------------------------------------

HRESULT
CBase::DoAdvise(
    REFIID          iid,
    DISPID          dispidBase,
    IUnknown *      pUnkSinkAdvise,
    IUnknown **     ppUnkSinkOut,
    DWORD *         pdwCookie)
{
    HRESULT                     hr;
    IUnknown                   *pUnk = NULL;
    CAttrValue::AAExtraBits     wAAExtra = CAttrValue::AA_Extra_Empty;
    DWORD                       dwCookie;

    Assert(iid != IID_NULL);
    
    if (!pUnkSinkAdvise)
        RRETURN(E_INVALIDARG);

    hr = THR_NOTRACE(pUnkSinkAdvise->QueryInterface(iid, (void **) &pUnk));
    if (hr)
    {
        // If someone is trying to listen to IE4 bad guid for IHTMLControlElementEvents the IID
        // was changed to be unique.  Java VM needs to be advised on this interface not IDispatch
        // (it can't handle it although it should).
        if (iid == DIID_HTMLControlElementEvents)
        {
            hr = THR_NOTRACE(pUnkSinkAdvise->QueryInterface(IID_IControlEvents, (void **) &pUnk));
        }

        if (hr)
        {
            if (dispidBase == DISPID_A_EVENTSINK)
		    {
		        hr = THR(pUnkSinkAdvise->QueryInterface(IID_IDispatch, (void **) &pUnk));
		    }

            if (hr)
                RRETURN1(CONNECT_E_CANNOTCONNECT, CONNECT_E_CANNOTCONNECT);
        }
    }


    if (iid == IID_ITridentEventSink)
    {
        // Quick VBS event hookup.
        wAAExtra = CAttrValue::AA_Extra_TridentEvent;
    }
    // Any event IIDs between 0x305f60e and max UUID of 0x30c38c70 would support
    // new style event binding of the eventObj being a parameter when the event is
    // fired.
    else if (iid.Data1 >= 0x3050f60f && iid.Data1 <= 0x30c38c70)
    {
        // is the rest of GUID in the Trident range?  If not then we're old style
        // event hookup (no eventObj argument)
        if (memcmp(&(DIID_HTMLElementEvents.Data2),
                   &(iid.Data2),
                   sizeof(REFIID) - sizeof(DWORD)))
        {
            // Old style Trident event hookup w/o EventObj as a parameter.
            wAAExtra = CAttrValue::AA_Extra_OldEventStyle;
        }
    }
    else
    {
        // Old style Trident event hookup w/o EventObj as a parameter.
        wAAExtra = CAttrValue::AA_Extra_OldEventStyle;
    }

    hr = THR(AddUnknownObjectMultiple(dispidBase, pUnk, CAttrValue::AA_Internal, wAAExtra));
    if (hr)
        goto Cleanup;

    if (ppUnkSinkOut)
    {
        *ppUnkSinkOut = pUnk;
        pUnk->AddRef();
    }

#ifdef _WIN64
    AAINDEX aaidx;
    aaidx = AA_IDX_UNKNOWN;
    Verify(FindAdviseIndex(dispidBase, 0, pUnk, &aaidx) == S_OK);    // We just added it, so this better not fail
    dwCookie = (DWORD)InterlockedIncrement((LONG *)&g_dwCookieForWin64);
    if (aaidx != AA_IDX_UNKNOWN)
    {
        Verify(SetCookieAt(aaidx, dwCookie) == S_OK);
    }
#else
    dwCookie = (DWORD)pUnk;
#endif

    if (pdwCookie)
    {
        *pdwCookie = dwCookie;
    }

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN1(hr, CONNECT_E_ADVISELIMIT);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::DoUnadvise
//
//  Synopsis:   Implements IConnectionPoint::Unadvise.
//
//  Arguments:  [dwCookie]        -- Cookie handed out upon Advise.
//
//----------------------------------------------------------------------------

HRESULT
CBase::DoUnadvise(DWORD dwCookie, DISPID dispidBase)
{
#ifdef _WIN64
    HRESULT hr;
    AAINDEX aaidx;
    
    if (!dwCookie)
        return S_OK;

    hr = THR(FindAdviseIndex(dispidBase, dwCookie, NULL, &aaidx));
    if (hr)
        goto Cleanup;

    DeleteAt(aaidx);

Cleanup:
    RRETURN1(hr, CONNECT_E_NOCONNECTION);
#else
    return DoUnadvise((IUnknown *)dwCookie, dispidBase);
#endif
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::DoUnadvise
//
//  Synopsis:   Implements IConnectionPoint::Unadvise. Gor internal use only.
//              Useful for avoiding transforming DWORD to pUNk in Win 64.
//
//----------------------------------------------------------------------------

HRESULT
CBase::DoUnadvise(IUnknown * pUnk, DISPID dispidBase)
{
    HRESULT hr;
    AAINDEX aaidx;
    
    if (!pUnk)
        return S_OK;

    hr = THR(FindAdviseIndex(dispidBase, 0, pUnk, &aaidx));
    if (hr)
        goto Cleanup;

    DeleteAt(aaidx);

Cleanup:
    RRETURN1(hr, CONNECT_E_NOCONNECTION);
}


HRESULT
CBase::FindAdviseIndex(DISPID dispidBase, DWORD dwCookie, IUnknown * pUnkCookie, AAINDEX * paaidx)
{
    HRESULT     hr       = S_OK;
    IUnknown *  pUnkSink = NULL;
    AAINDEX     aaidx    = AA_IDX_UNKNOWN;

    if (!*GetAttrArray())
    {
        hr = CONNECT_E_NOCONNECTION;
        goto Cleanup;
    }

    //
    // Loop through the attr array indices looking for the dwCookie and/or
    // pUnkCookie as the value.
    //

    for (;;)
    {
        aaidx = FindNextAAIndex(
            dispidBase,
            CAttrValue::AA_Internal,
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        if (pUnkCookie)
        {
            ClearInterface(&pUnkSink);
            hr = THR(GetUnknownObjectAt(aaidx, &pUnkSink));
            if (hr || !pUnkSink)
            {
                hr = CONNECT_E_NOCONNECTION;
                goto Cleanup;
            }

            if (pUnkSink == pUnkCookie)
                break;
        }

#ifdef _WIN64
        if (dwCookie)
        {
            DWORD dwCookieSink;
            hr = THR(GetCookieAt(aaidx, &dwCookieSink));
            if (dwCookie == dwCookieSink)
                break;
        }
#endif
    }

    if (aaidx == AA_IDX_UNKNOWN)
    {
        hr = CONNECT_E_NOCONNECTION;
        goto Cleanup;
    }

    *paaidx = aaidx;

Cleanup:
    ReleaseInterface(pUnkSink);
    RRETURN1(hr, CONNECT_E_NOCONNECTION);
}

//+------------------------------------------------------------------------
//
//  CConnectionPointContainer implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::CConnectionPointContainer
//
//  Synopsis:   ctor.
//
//  Arguments:  [pBase]     -- CBase object using this container.
//
//----------------------------------------------------------------------------

CConnectionPointContainer::CConnectionPointContainer(CBase * pBase, IUnknown *pUnkOuter)
{
    CONNECTION_POINT_INFO * pcpi;
    long            i;
    
    MemSetName((this, "CPC pBase=%08x", pBase));

    Assert(pBase);
    Assert(pBase->BaseDesc()->_pcpi);

    for (i = 0; i < CONNECTION_POINTS_MAX; i++)
    {
        _aCP[i]._index = -1;
    }
    
    //
    // Note: we set the refcount to 0 because the caller of this function will
    // AddRef it as part of its implementation of QueryInterface.
    //

    _ulRef      = 0;
    _pBase      = pBase;
    _pUnkOuter  = pUnkOuter;

    // _pUnkOuter is specified explicitly when creating a new
    // COM identity on top of the CBase object. In this case,
    // we only need to SubAddRef the CBase object.

    if (_pUnkOuter)
    {
        _pBase->SubAddRef();
        _pUnkOuter->AddRef();
    }
    else
    {
        _pBase->PrivateAddRef();
        _pBase->PunkOuter()->AddRef();
    }
    
    for (i = 0, pcpi = GetCPI(); pcpi && pcpi->piid; pcpi++, i++)
    {
        _aCP[i]._index = i;
    }

    Assert(i < CONNECTION_POINTS_MAX - 1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::~CConnectionPointContainer
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

CConnectionPointContainer::~CConnectionPointContainer()
{
    // _pUnkOuter is specified explicitly when creating a new
    // COM identity on top of the CBase object. In this case,
    // we only need to SubRelease the CBase object.

    if (_pUnkOuter)
    {
        _pBase->SubRelease();
        _pUnkOuter->Release();
    }
    else
    {
        _pBase->PrivateRelease();
        _pBase->PunkOuter()->Release();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::QueryInterface, IUnknown
//
//  Synopsis:   As per IUnknown.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CConnectionPointContainer::QueryInterface(REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = _pUnkOuter ? _pUnkOuter : _pBase->PunkOuter();
    RRETURN_NOTRACE(THR_NOTRACE(pUnk->QueryInterface(iid, ppvObj)));
}


//+------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::AddRef, IUnknown
//
//  Synopsis:   As per IUnknown.
//
//-------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPointContainer::AddRef()
{
    return _ulRef++;
}



//+------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::Release, IUnknown
//
//  Synopsis:   As per IUnknown.
//
//-------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPointContainer::Release()
{
    Assert(_ulRef > 0);

    if (--_ulRef == 0)
    {
        _ulRef = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }

    return _ulRef;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::EnumConnectionPoints
//
//  Synopsis:   Enumerates the container's connection points.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPointContainer::EnumConnectionPoints(IEnumConnectionPoints ** ppEnum)
{
    HRESULT                         hr;
    CCPCEnumCPAry *                 paCP;
    CConnectionPt *                 pCP;

    if (!ppEnum)
        RRETURN(E_POINTER);

    //
    // Copy pointers to connection points to new array.
    //

    *ppEnum = NULL;
    paCP = new CCPCEnumCPAry;
    if (!paCP)
        RRETURN(E_OUTOFMEMORY);

    for (pCP = _aCP; pCP->_index != -1; pCP++)
    {
        hr = THR(paCP->Append(pCP));
        if (hr)
            goto Error;

        pCP->AddRef();
    }

    //
    // Create enumerator which references array.
    //

    hr = THR(paCP->EnumElements(
            IID_IEnumConnectionPoints,
            (LPVOID*)ppEnum,
            TRUE,
            FALSE,
            TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    paCP->ReleaseAll();
    delete paCP;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::FindConnectionPoint
//
//  Synopsis:   Finds a connection point with a particular IID.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPointContainer::FindConnectionPoint(
        REFIID              iid,
        IConnectionPoint ** ppCP)
{
    CConnectionPt * pCP;

    if (!ppCP)
        RRETURN(E_POINTER);

    *ppCP = NULL;

    for (pCP = _aCP; pCP->_index != -1; pCP++)
    {
        if (*(pCP->MyCPI()->piid) == iid)
        {
            *ppCP = pCP;
            pCP->AddRef();

            return S_OK;
        }
    }

    // If someone is trying to listen to IE4 bad guid for IHTMLControlElementEvents the IID
    // was changed to be unique.  IE4 shipped with IControlEvents for the guid of
    // IControlEvents so we'll map that interface to the correct IE5 IHTMLControlElementEvents
    // IID.
    if (iid == IID_IControlEvents)
    {
        for (pCP = _aCP; pCP->_index != -1; pCP++)
        {
            if (*(pCP->MyCPI()->piid) == DIID_HTMLControlElementEvents)
            {
                *ppCP = pCP;
                pCP->AddRef();
                return S_OK;
            }
        }
    }

    RRETURN(E_NOINTERFACE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::GetCPI
//
//  Synopsis:   Get a hold of the array of connection pt information.
//
//----------------------------------------------------------------------------

CONNECTION_POINT_INFO *
CConnectionPointContainer::GetCPI()
{
    return (CONNECTION_POINT_INFO *)(_pBase->BaseDesc()->_pcpi);
}


//+------------------------------------------------------------------------
//
//  CConnectionPt implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::QueryInterface(REFIID iid, LPVOID * ppvObj)
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);

    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppvObj = (IConnectionPoint *) this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppvObj)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::AddRef
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPt::AddRef()
{
    MyCPC()->_ulRef++;
    return MyCPC()->_pBase->SubAddRef();
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::Release
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPt::Release()
{
    CBase * pBase;

    Assert(MyCPC()->_ulRef > 0);

    pBase = MyCPC()->_pBase;
    if (--MyCPC()->_ulRef == 0)
    {
        MyCPC()->_ulRef = ULREF_IN_DESTRUCTOR;
        delete MyCPC();
    }

    return pBase->SubRelease();
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::GetConnectionInterface
//
//  Synopsis:   Returns the IID of this connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::GetConnectionInterface(IID * pIID)
{
    if (!pIID)
        RRETURN(E_POINTER);

    Assert(_index != -1);
    *pIID = *MyCPI()->piid;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::GetConnectionPointContainer
//
//  Synopsis:   Returns the container of this connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    Assert(_index != -1);
    
    if (!ppCPC)
        RRETURN(E_POINTER);

    if (MyCPC()->_pBase->PunkOuter() != (IUnknown *) MyCPC()->_pBase)
    {
        RRETURN(MyCPC()->_pBase->PunkOuter()->QueryInterface(
                IID_IConnectionPointContainer, (void **) ppCPC));
    }

    *ppCPC = MyCPC();
    (*ppCPC)->AddRef();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::Advise
//
//  Synopsis:   Adds a connection.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie)
{
    Assert(_index != -1);

    const CONNECTION_POINT_INFO * pcpi = MyCPI();
    
    RRETURN(MyCPC()->_pBase->DoAdvise(
        *pcpi->piid,
        pcpi->dispid,
        pUnkSink,
        NULL,
        pdwCookie));
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::Unadvise
//
//  Synopsis:   Removes a connection.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::Unadvise(DWORD dwCookie)
{
    Assert(_index != -1);
    
    RRETURN(MyCPC()->_pBase->DoUnadvise(
        dwCookie,
        MyCPI()->dispid));
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::EnumConnections
//
//  Synopsis:   Enumerates the connections.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    Assert(_index != -1);
    
    HRESULT                 hr;
    DISPID                  dispidBase;
    CEnumConnections *      pEnum   = NULL;
    CDataAry<CONNECTDATA>   aryCD(Mt(CConnectionPtEnumConnectionsAry_pv));
    CONNECTDATA             cdNew;
    AAINDEX                 aaidx = AA_IDX_UNKNOWN;
    
    cdNew.pUnk = NULL;

    if (!ppEnum)
        RRETURN(E_POINTER);

    if (*(MyCPC()->_pBase->GetAttrArray()))
    {
        dispidBase = MyCPI()->dispid;

        //
        // Iterate thru attr array values with this dispid, appending
        // the IUnknown into a local array.
        //

        for (;;)
        {
            aaidx = MyCPC()->_pBase->FindNextAAIndex(
                dispidBase,
                CAttrValue::AA_Internal,
                aaidx);
            if (aaidx == AA_IDX_UNKNOWN)
                break;
                
            ClearInterface(&cdNew.pUnk);
            hr = THR(MyCPC()->_pBase->GetUnknownObjectAt(
                    aaidx, 
                    &cdNew.pUnk));
            if (hr)
                goto Cleanup;

#ifdef _WIN64
            Verify(MyCPC()->_pBase->GetCookieAt(aaidx, &cdNew.dwCookie) == S_OK);
#else
            cdNew.dwCookie = (DWORD)cdNew.pUnk;
#endif

            hr = THR(aryCD.AppendIndirect(&cdNew));
            if (hr)
                goto Cleanup;
        }
    }

    hr = THR(CEnumConnections::Create(aryCD.Size(), (CONNECTDATA *)(LPVOID)aryCD, &pEnum));

    //  Note that since our enumeration base class doesn't officially
    //    support the IEnumConnections interface, we have to do
    //    an explicit cast via void *

    *ppEnum = (IEnumConnections *) (void *) pEnum;

Cleanup:
    ReleaseInterface(cdNew.pUnk);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\olectrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olectrl.cxx
//
//  Contents:   Ole Control Specific Interface implementations
//
//----------------------------------------------------------------------------


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CControlBaseCtrl::GetControlInfo, IOleControl
//
//  Synopsis:   Returns a filled-in CONTROLINFO.
//
//  Arguments:  [pCI] -- CONTROLINFO to fill in
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetControlInfo(CONTROLINFO *pCI)
{
    memset(pCI, 0, sizeof(CONTROLINFO));
    pCI->cb = sizeof(CONTROLINFO);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnMnemonic, IOleControl
//
//  Synopsis:   Indicates one of our mnemonics has been pressed by the user
//              and we need to take the appropriate action.
//
//  Arguments:  [pMsg] -- Message which corresponds to a mnemonic.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::OnMnemonic(LPMSG pMsg)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnAmbientPropertyChange, IOleControl
//
//  Synopsis:   Indicates one or more ambient properties have changed so we
//              can update our state.
//
//  Arguments:  [dispid] -- Property which changed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_UNKNOWN:
    case DISPID_AMBIENT_USERMODE:
        _fUserMode = GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);
        break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::FreezeEvents, IOleControl
//
//  Synopsis:   Enables or disables the ability of the control to fire events.
//              Any control which cares about the status of the event
//              freeze count should overwrite this method.
//
//  Arguments:  [fFreeze] -- If TRUE, events are disabled.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::FreezeEvents(BOOL fFreeze)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetDisplayString, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetDisplayString(DISPID dispid, BSTR * pbstr)
{
    if (pbstr)
        *pbstr = NULL;

    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::MapPropertyToPage, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::MapPropertyToPage(DISPID dispid, LPCLSID lpclsid)
{
    if (lpclsid)
        *lpclsid = CLSID_NULL;

    return PERPROP_E_NOPAGEAVAILABLE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetPredefinedStrings, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetPredefinedStrings(DISPID       dispid,
                              CALPOLESTR * pcaStringsOut,
                              CADWORD *    lpcaCookiesOut)
{
    if (pcaStringsOut)
    {
        pcaStringsOut->cElems = 0;
        pcaStringsOut->pElems = NULL;
    }

    if (lpcaCookiesOut)
    {
        lpcaCookiesOut->cElems = 0;
        lpcaCookiesOut->pElems = NULL;
    }

    // NOTE (ChrisF): according to the spec this should probably return S_FALSE
    // however, because of a bug in VB4 and VB5/VBA this causes VB not to look for
    // the string in the typelib either. 
    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetPredefinedValue, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetPredefinedValue(DISPID dispid, DWORD dwCookie, VARIANT * pvarOut)
{
    if (pvarOut)
        V_VT(pvarOut) = VT_EMPTY;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\colorval.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       baseprop.cxx
//
//  Contents:   CBase property setting utilities.
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif // X_CBUFSTR_HXX_

#ifndef X_HIMETRIC_HXX_
#define X_HIMETRIC_HXX_
#include "himetric.hxx"
#endif


#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

//
// Support for CColorValue follows.
//
// IEUNIX: color value starts from 0x10.

#define nColorNamesStartOffset 0x11
#define COLOR_INDEX(i) (((DWORD)nColorNamesStartOffset + (DWORD)(i)) << 24)


const struct COLORVALUE_PAIR aColorNames[] =
{
    { _T("aliceblue"),             COLOR_INDEX(0x00) | 0xfff8f0 },
    { _T("antiquewhite"),          COLOR_INDEX(0x01) | 0xd7ebfa },
    { _T("aqua"),                  COLOR_INDEX(0x02) | 0xffff00 },
    { _T("aquamarine"),            COLOR_INDEX(0x03) | 0xd4ff7f },
    { _T("azure"),                 COLOR_INDEX(0x04) | 0xfffff0 },
    { _T("beige"),                 COLOR_INDEX(0x05) | 0xdcf5f5 },
    { _T("bisque"),                COLOR_INDEX(0x06) | 0xc4e4ff },
    { _T("black"),                 COLOR_INDEX(0x07) | 0x000000 },
    { _T("blanchedalmond"),        COLOR_INDEX(0x08) | 0xcdebff },
    { _T("blue"),                  COLOR_INDEX(0x09) | 0xff0000 },
    { _T("blueviolet"),            COLOR_INDEX(0x0a) | 0xe22b8a },
    { _T("brown"),                 COLOR_INDEX(0x0b) | 0x2a2aa5 },
    { _T("burlywood"),             COLOR_INDEX(0x0c) | 0x87b8de },
    { _T("cadetblue"),             COLOR_INDEX(0x0d) | 0xa09e5f },
    { _T("chartreuse"),            COLOR_INDEX(0x0e) | 0x00ff7f },
    { _T("chocolate"),             COLOR_INDEX(0x0f) | 0x1e69d2 },
    { _T("coral"),                 COLOR_INDEX(0x10) | 0x507fff },
    { _T("cornflowerblue"),        COLOR_INDEX(0x11) | 0xed9564 },
    { _T("cornsilk"),              COLOR_INDEX(0x12) | 0xdcf8ff },
    { _T("crimson"),               COLOR_INDEX(0x13) | 0x3c14dc },
    { _T("cyan"),                  COLOR_INDEX(0x14) | 0xffff00 },
    { _T("darkblue"),              COLOR_INDEX(0x15) | 0x8b0000 },
    { _T("darkcyan"),              COLOR_INDEX(0x16) | 0x8b8b00 },
    { _T("darkgoldenrod"),         COLOR_INDEX(0x17) | 0x0b86b8 },
    { _T("darkgray"),              COLOR_INDEX(0x18) | 0xa9a9a9 },
    { _T("darkgreen"),             COLOR_INDEX(0x19) | 0x006400 },
    { _T("darkkhaki"),             COLOR_INDEX(0x1a) | 0x6bb7bd },
    { _T("darkmagenta"),           COLOR_INDEX(0x1b) | 0x8b008b },
    { _T("darkolivegreen"),        COLOR_INDEX(0x1c) | 0x2f6b55 },
    { _T("darkorange"),            COLOR_INDEX(0x1d) | 0x008cff },
    { _T("darkorchid"),            COLOR_INDEX(0x1e) | 0xcc3299 },
    { _T("darkred"),               COLOR_INDEX(0x1f) | 0x00008b },
    { _T("darksalmon"),            COLOR_INDEX(0x20) | 0x7a96e9 },
    { _T("darkseagreen"),          COLOR_INDEX(0x21) | 0x8fbc8f },
    { _T("darkslateblue"),         COLOR_INDEX(0x22) | 0x8b3d48 },
    { _T("darkslategray"),         COLOR_INDEX(0x23) | 0x4f4f2f },
    { _T("darkturquoise"),         COLOR_INDEX(0x24) | 0xd1ce00 },
    { _T("darkviolet"),            COLOR_INDEX(0x25) | 0xd30094 },
    { _T("deeppink"),              COLOR_INDEX(0x26) | 0x9314ff },
    { _T("deepskyblue"),           COLOR_INDEX(0x27) | 0xffbf00 },
    { _T("dimgray"),               COLOR_INDEX(0x28) | 0x696969 },
    { _T("dodgerblue"),            COLOR_INDEX(0x29) | 0xff901e },
    { _T("firebrick"),             COLOR_INDEX(0x2a) | 0x2222b2 },
    { _T("floralwhite"),           COLOR_INDEX(0x2b) | 0xf0faff },
    { _T("forestgreen"),           COLOR_INDEX(0x2c) | 0x228b22 },
    { _T("fuchsia"),               COLOR_INDEX(0x2d) | 0xff00ff },
    { _T("gainsboro"),             COLOR_INDEX(0x2e) | 0xdcdcdc },
    { _T("ghostwhite"),            COLOR_INDEX(0x2f) | 0xfff8f8 },
    { _T("gold"),                  COLOR_INDEX(0x30) | 0x00d7ff },
    { _T("goldenrod"),             COLOR_INDEX(0x31) | 0x20a5da },
    { _T("gray"),                  COLOR_INDEX(0x32) | 0x808080 },
    { _T("green"),                 COLOR_INDEX(0x33) | 0x008000 },
    { _T("greenyellow"),           COLOR_INDEX(0x34) | 0x2fffad },
    { _T("honeydew"),              COLOR_INDEX(0x35) | 0xf0fff0 },
    { _T("hotpink"),               COLOR_INDEX(0x36) | 0xb469ff },
    { _T("indianred"),             COLOR_INDEX(0x37) | 0x5c5ccd },
    { _T("indigo"),                COLOR_INDEX(0x38) | 0x82004b },
    { _T("ivory"),                 COLOR_INDEX(0x39) | 0xf0ffff },
    { _T("khaki"),                 COLOR_INDEX(0x3a) | 0x8ce6f0 },
    { _T("lavender"),              COLOR_INDEX(0x3b) | 0xfae6e6 },
    { _T("lavenderblush"),         COLOR_INDEX(0x3c) | 0xf5f0ff },
    { _T("lawngreen"),             COLOR_INDEX(0x3d) | 0x00fc7c },
    { _T("lemonchiffon"),          COLOR_INDEX(0x3e) | 0xcdfaff },
    { _T("lightblue"),             COLOR_INDEX(0x3f) | 0xe6d8ad },
    { _T("lightcoral"),            COLOR_INDEX(0x40) | 0x8080f0 },
    { _T("lightcyan"),             COLOR_INDEX(0x41) | 0xffffe0 },
    { _T("lightgoldenrodyellow"),  COLOR_INDEX(0x42) | 0xd2fafa },
    { _T("lightgreen"),            COLOR_INDEX(0x43) | 0x90ee90 },
    { _T("lightgrey"),             COLOR_INDEX(0x44) | 0xd3d3d3 },
    { _T("lightpink"),             COLOR_INDEX(0x45) | 0xc1b6ff },
    { _T("lightsalmon"),           COLOR_INDEX(0x46) | 0x7aa0ff },
    { _T("lightseagreen"),         COLOR_INDEX(0x47) | 0xaab220 },
    { _T("lightskyblue"),          COLOR_INDEX(0x48) | 0xface87 },
    { _T("lightslategray"),        COLOR_INDEX(0x49) | 0x998877 },
    { _T("lightsteelblue"),        COLOR_INDEX(0x4a) | 0xdec4b0 },
    { _T("lightyellow"),           COLOR_INDEX(0x4b) | 0xe0ffff },
    { _T("lime"),                  COLOR_INDEX(0x4c) | 0x00ff00 },
    { _T("limegreen"),             COLOR_INDEX(0x4d) | 0x32cd32 },
    { _T("linen"),                 COLOR_INDEX(0x4e) | 0xe6f0fa },
    { _T("magenta"),               COLOR_INDEX(0x4f) | 0xff00ff },
    { _T("maroon"),                COLOR_INDEX(0x50) | 0x000080 },
    { _T("mediumaquamarine"),      COLOR_INDEX(0x51) | 0xaacd66 },
    { _T("mediumblue"),            COLOR_INDEX(0x52) | 0xcd0000 },
    { _T("mediumorchid"),          COLOR_INDEX(0x53) | 0xd355ba },
    { _T("mediumpurple"),          COLOR_INDEX(0x54) | 0xdb7093 },
    { _T("mediumseagreen"),        COLOR_INDEX(0x55) | 0x71b33c },
    { _T("mediumslateblue"),       COLOR_INDEX(0x56) | 0xee687b },
    { _T("mediumspringgreen"),     COLOR_INDEX(0x57) | 0x9afa00 },
    { _T("mediumturquoise"),       COLOR_INDEX(0x58) | 0xccd148 },
    { _T("mediumvioletred"),       COLOR_INDEX(0x59) | 0x8515c7 },
    { _T("midnightblue"),          COLOR_INDEX(0x5a) | 0x701919 },
    { _T("mintcream"),             COLOR_INDEX(0x5b) | 0xfafff5 },
    { _T("mistyrose"),             COLOR_INDEX(0x5c) | 0xe1e4ff },
    { _T("moccasin"),              COLOR_INDEX(0x5d) | 0xb5e4ff },
    { _T("navajowhite"),           COLOR_INDEX(0x5e) | 0xaddeff },
    { _T("navy"),                  COLOR_INDEX(0x5f) | 0x800000 },
    { _T("oldlace"),               COLOR_INDEX(0x60) | 0xe6f5fd },
    { _T("olive"),                 COLOR_INDEX(0x61) | 0x008080 },
    { _T("olivedrab"),             COLOR_INDEX(0x62) | 0x238e6b },
    { _T("orange"),                COLOR_INDEX(0x63) | 0x00a5ff },
    { _T("orangered"),             COLOR_INDEX(0x64) | 0x0045ff },
    { _T("orchid"),                COLOR_INDEX(0x65) | 0xd670da },
    { _T("palegoldenrod"),         COLOR_INDEX(0x66) | 0xaae8ee },
    { _T("palegreen"),             COLOR_INDEX(0x67) | 0x98fb98 },
    { _T("paleturquoise"),         COLOR_INDEX(0x68) | 0xeeeeaf },
    { _T("palevioletred"),         COLOR_INDEX(0x69) | 0x9370db },
    { _T("papayawhip"),            COLOR_INDEX(0x6a) | 0xd5efff },
    { _T("peachpuff"),             COLOR_INDEX(0x6b) | 0xb9daff },
    { _T("peru"),                  COLOR_INDEX(0x6c) | 0x3f85cd },
    { _T("pink"),                  COLOR_INDEX(0x6d) | 0xcbc0ff },
    { _T("plum"),                  COLOR_INDEX(0x6e) | 0xdda0dd },
    { _T("powderblue"),            COLOR_INDEX(0x6f) | 0xe6e0b0 },
    { _T("purple"),                COLOR_INDEX(0x70) | 0x800080 },
    { _T("red"),                   COLOR_INDEX(0x71) | 0x0000ff },
    { _T("rosybrown"),             COLOR_INDEX(0x72) | 0x8f8fbc },
    { _T("royalblue"),             COLOR_INDEX(0x73) | 0xe16941 },
    { _T("saddlebrown"),           COLOR_INDEX(0x74) | 0x13458b },
    { _T("salmon"),                COLOR_INDEX(0x75) | 0x7280fa },
    { _T("sandybrown"),            COLOR_INDEX(0x76) | 0x60a4f4 },
    { _T("seagreen"),              COLOR_INDEX(0x77) | 0x578b2e },
    { _T("seashell"),              COLOR_INDEX(0x78) | 0xeef5ff },
    { _T("sienna"),                COLOR_INDEX(0x79) | 0x2d52a0 },
    { _T("silver"),                COLOR_INDEX(0x7a) | 0xc0c0c0 },
    { _T("skyblue"),               COLOR_INDEX(0x7b) | 0xebce87 },
    { _T("slateblue"),             COLOR_INDEX(0x7c) | 0xcd5a6a },
    { _T("slategray"),             COLOR_INDEX(0x7d) | 0x908070 },
    { _T("snow"),                  COLOR_INDEX(0x7e) | 0xfafaff },
    { _T("springgreen"),           COLOR_INDEX(0x7f) | 0x7fff00 },
    { _T("steelblue"),             COLOR_INDEX(0x80) | 0xb48246 },
    { _T("tan"),                   COLOR_INDEX(0x81) | 0x8cb4d2 },
    { _T("teal"),                  COLOR_INDEX(0x82) | 0x808000 },
    { _T("thistle"),               COLOR_INDEX(0x83) | 0xd8bfd8 },
    { _T("tomato"),                COLOR_INDEX(0x84) | 0x4763ff },
    { _T("turquoise"),             COLOR_INDEX(0x85) | 0xd0e040 },
    { _T("violet"),                COLOR_INDEX(0x86) | 0xee82ee },
    { _T("wheat"),                 COLOR_INDEX(0x87) | 0xb3def5 },
    { _T("white"),                 COLOR_INDEX(0x88) | 0xffffff },
    { _T("whitesmoke"),            COLOR_INDEX(0x89) | 0xf5f5f5 },
    { _T("yellow"),                COLOR_INDEX(0x8a) | 0x00ffff },
    { _T("yellowgreen"),           COLOR_INDEX(0x8b) | 0x32cd9a }
};

extern const struct COLORVALUE_PAIR aSystemColors[];
const struct COLORVALUE_PAIR aSystemColors[] =
{
    { _T("activeborder"),       COLOR_ACTIVEBORDER},    // Active window border.
    { _T("activecaption"),      COLOR_ACTIVECAPTION},   // Active window caption.
    { _T("appworkspace"),       COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { _T("background"),         COLOR_BACKGROUND},      // Desktop background.
    { _T("buttonface"),         COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { _T("buttonhighlight"),    COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { _T("buttonshadow"),       COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { _T("buttontext"),         COLOR_BTNTEXT},         // Text on push buttons.
    { _T("captiontext"),        COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { _T("graytext"),           COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { _T("highlight"),          COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { _T("highlighttext"),      COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { _T("inactiveborder"),     COLOR_INACTIVEBORDER},  // Inactive window border.
    { _T("inactivecaption"),    COLOR_INACTIVECAPTION}, // Inactive window caption.
    { _T("inactivecaptiontext"),COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { _T("infobackground"),     COLOR_INFOBK},          // Background color for tooltip controls.
    { _T("infotext"),           COLOR_INFOTEXT},        // Text color for tooltip controls.
    { _T("menu"),               COLOR_MENU},            // Menu background.
    { _T("menutext"),           COLOR_MENUTEXT},        // Text in menus.
    { _T("scrollbar"),          COLOR_SCROLLBAR},       // Scroll bar gray area.
    { _T("threeddarkshadow"),   COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { _T("threedface"),         COLOR_3DFACE},
    { _T("threedhighlight"),    COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { _T("threedlightshadow"),  COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { _T("threedshadow"),       COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { _T("window"),             COLOR_WINDOW},          // Window background.
    { _T("windowframe"),        COLOR_WINDOWFRAME},     // Window frame.
    { _T("windowtext"),         COLOR_WINDOWTEXT},      // Text in windows.
};

extern const INT cbSystemColorsSize;
const  INT cbSystemColorsSize = ARRAY_SIZE(aSystemColors);

int RTCCONV
CompareColorValuePairsByName( const void * pv1, const void * pv2 )
{
    return StrCmpIC( ((struct COLORVALUE_PAIR *)pv1)->szName,
                     ((struct COLORVALUE_PAIR *)pv2)->szName );
}

const struct COLORVALUE_PAIR *
FindColorByName( const TCHAR * szString )
{
    struct COLORVALUE_PAIR ColorName;

    ColorName.szName = szString;

    return (const struct COLORVALUE_PAIR *)bsearch( &ColorName,
                                              aColorNames,
                                              ARRAY_SIZE(aColorNames),
                                              sizeof(struct COLORVALUE_PAIR),
                                              CompareColorValuePairsByName );
}

const struct COLORVALUE_PAIR *
FindColorBySystemName( const TCHAR * szString )
{
    struct COLORVALUE_PAIR ColorName;

    ColorName.szName = szString;

    return (const struct COLORVALUE_PAIR *)bsearch( &ColorName,
                                                    aSystemColors,
                                                    ARRAY_SIZE(aSystemColors),
                                                    sizeof(struct COLORVALUE_PAIR),
                                                    CompareColorValuePairsByName );
}

const struct COLORVALUE_PAIR *
FindColorByColor( DWORD lColor )
{
    int nIndex;
    const struct COLORVALUE_PAIR * pColorName = NULL;

    // Unfortunately, this is a linear search.
    // Fortunately, we will need to lookup the name rarely.

    // The mask (high) byte should be clear.
    if (!(lColor & CColorValue::MASK_FLAG)) 
    {
        // Can't possibly be one of our colors
        return NULL;
    }

    for ( nIndex = ARRAY_SIZE( aColorNames ); nIndex-- ; )
    {
        if (lColor == (aColorNames[nIndex].dwValue & CColorValue::MASK_COLOR))
        {
            pColorName = aColorNames + nIndex;
            break;
        }
    }

    return pColorName;
}

const struct COLORVALUE_PAIR *
FindColorByValue( DWORD dwValue )
{
    CColorValue cvColor = dwValue;
    Assert(ARRAY_SIZE( aColorNames ) > cvColor.Index( dwValue ));
    return aColorNames + cvColor.Index( dwValue );
}

CColorValue::CColorValue ( VARIANT * pvar )
{
    if (V_VT(pvar) == VT_I4)
    {
        SetValue( V_I4( pvar ), TRUE );
    }
    else if (V_VT(pvar) == VT_BSTR)
    {
        FromString( V_BSTR( pvar ) );
    }
    else
    {
        _dwValue = VALUE_UNDEF;
    }
}

int
CColorValue::Index(const DWORD dwValue) const
{
    // The index, as stored in dwValue, should be 1-based.  This
    // is because we want to retain 0 as 'default' flag (undefined).

    // For the return value, however, we generally want an index
    // into aColorNames, so convert it to a 0-based index.

    // IEUNIX: color value starts form nColorNamesStartOffset.

    int nOneBasedIndex = (int)(dwValue >> 24);
    Assert( ARRAY_SIZE( aColorNames ) >= nOneBasedIndex - nColorNamesStartOffset );
    return nOneBasedIndex - nColorNamesStartOffset;
}

long
CColorValue::SetValue( long lColor, BOOL fLookupName, TYPE type)
{
    const struct COLORVALUE_PAIR * pColorName = NULL;

    if (fLookupName)
    {
        pColorName = FindColorByColor( lColor );
    }

    if (pColorName)
    {
        SetValue( pColorName );
    }
    else
    {
#ifdef UNIX
        if ( CColorValue(lColor).IsUnixSysColor()) {
            _dwValue = lColor;
            return _dwValue;
        }
#endif

        _dwValue = (lColor & MASK_COLOR) | type;
    }

    return _dwValue & MASK_COLOR;
}

long
CColorValue::SetValue( const struct COLORVALUE_PAIR * pColorName )
{
    Assert( pColorName );
    Assert( ARRAY_SIZE( aColorNames ) > Index( pColorName->dwValue ) );

    _dwValue = pColorName->dwValue;
    return _dwValue & MASK_COLOR;
}

long
CColorValue::SetRawValue( DWORD dwValue )
{
    _dwValue = dwValue;
    AssertSz( S_OK == IsValid(), "CColorValue::SetRawValue invalid value.");

#ifdef UNIX
    if ( IsUnixSysColor()) {
        return _dwValue;
    }
#endif

    return _dwValue & MASK_COLOR;
}

long
CColorValue::SetSysColor(int nIndex)
{
    _dwValue = TYPE_SYSINDEX + (nIndex << 24);

    return _dwValue & MASK_COLOR;
}


//+-----------------------------------------------------------------
//
//  Member : FromString
//
//  Synopsis : '#' tells us to force a Hex interpretation, w/0 it
//      we try to do a name look up, and if that fails, then we
//      fall back on hex interpretation anyhow.
//
//+-----------------------------------------------------------------
HRESULT
CColorValue::FromString( LPCTSTR pch, BOOL fStrictCSS1 /* FALSE */, BOOL fValidOnly /*=FALSE*/ , int iStrLen /* =-1 */)
{
    HRESULT hr = E_INVALIDARG;

    if (!pch || !*pch)
    {
        Undefine();
        hr = S_OK;
        goto Cleanup;
    }

    if (iStrLen == -1)
        iStrLen = _tcslen(pch);
    else
        iStrLen = min(iStrLen, (int)_tcslen(pch));

    // Leading '#' means it's a hex color, not a named color.
    if ( *pch != _T('#') )
    {
        // it can only be a name if there it is all alphanumeric
        int   i;
        BOOL  bNotAName = FALSE;
        BOOL  bFoundNonHex = FALSE;

        for (i=0; i<iStrLen; i++)
        {
            if (!_istalpha(pch[i]))
            {
                bNotAName = TRUE;
                break;
            }
            if (!bFoundNonHex && !_istxdigit(pch[i]))
                bFoundNonHex = TRUE;
        }

        // if it still COULD be a name, try it
        if (!bNotAName && bFoundNonHex)
        {
            hr = THR_NOTRACE(NameColor( pch ));
            //S_OK means we got it
            if (!hr)
                goto Cleanup;
        }

        // Try it as an rgb(r,g,b) functional notation
        hr = RgbColor( pch, iStrLen );
        // S_OK means it was.
        if ( !hr )
            goto Cleanup;

        // In strict css1 mode we do not try to recognize a string without a leading #
        // as a hex value.
        if (fStrictCSS1)
            goto Cleanup;
    }
    else
    {
         // Skip the '#' character
         pch++;
         iStrLen--;
    }

    // either its NOT a known name or it is a hex value so
    //   convert if necessary
	hr = THR_NOTRACE(HexColor(pch, iStrLen, fValidOnly));

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

HRESULT GetRgbParam( LPCTSTR &pch, int &iStrLen, BYTE *pResult )
{
    HRESULT hr = S_OK;
    long lValue = 0;
    long lFractionDecimal = 1;
    BOOL fIsNegative = FALSE;

    Assert( "GetRgbParam requires a place to store its result!" && pResult );

    while ( iStrLen && _istspace( *pch ) )
    {
        pch++;
        iStrLen--;
    }

    if ( iStrLen && ( *pch == _T('-') ) )
    {
        fIsNegative = TRUE;
        pch++;
        iStrLen--;
    }

    if ( !(iStrLen && _istdigit( *pch ) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    while ( iStrLen && _istdigit( *pch ) )
    {
        lValue *= 10;
        lValue += (long)(*pch) - '0';
        pch++;
        iStrLen--;
        if ( lValue > 255 )
        {   // We're over the maximum, might as well stop paying attention.
            while ( _istdigit( *pch ) )
            {
                pch++;
                iStrLen--;
            }
        }
    }

    if ( iStrLen && ( *pch == _T('.') ) )
    {
        pch++;
        iStrLen--;
        while ( iStrLen && _istdigit( *pch ) )
        {
            lValue *= 10;
            lValue += (long)(*pch) - _T('0');
            lFractionDecimal *= 10;
            pch++;
            iStrLen--;

            if ( lValue > ( LONG_MAX / 5100 ) ) // 5100 = 255 (multiplier in algorithm below) * 10 (multiplier in loop above) * 2 (slop)
            {   // Safety valve so we don't overrun a long.
                while ( _istdigit( *pch ) )
                {
                    pch++;
                    iStrLen--;
                }
            }
        }

    }

    if ( iStrLen && ( *pch == _T('%') ) )
    {
        if ( ( lValue / lFractionDecimal ) >= 100 )
            *pResult = 255;
        else
            *pResult = (BYTE) ( ( lValue * 255 ) / ( lFractionDecimal * 100 ) );
        pch++;
        iStrLen--;
    }
    else
    {
        if ( ( lValue / lFractionDecimal ) > 255 )
            *pResult = 255;
        else
            *pResult = (BYTE)(lValue/lFractionDecimal);
    }

    while ( iStrLen && _istspace( *pch ) )
    {
        pch++;
        iStrLen--;
    }

    if ( iStrLen && ( *pch == _T(',') ) )
    {
        pch++;
        iStrLen--;
    }

    if ( fIsNegative )
        *pResult = 0;
Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Member   : CColorValue::RgbColor
//
//  Synopsis : Convert an RGB functional notation to RGB DWORD
//
//  On entry : pch: "rgb( r, g, b )"
//
//  Returns  : 
//+-----------------------------------------------------------------------
HRESULT CColorValue::RgbColor( LPCTSTR pch, int iStrLen )
{
    HRESULT hr = E_INVALIDARG;
    DWORD   rgbColor = 0;

    if ( iStrLen > 4 && !_tcsnicmp( pch, 4, _T("rgb("), 4 ) )
    {
        // Looks like a functional notation to me.
        pch += 4;
        iStrLen -= 4;

#ifndef unix
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[0] );
#else
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[3] );
#endif
        if ( hr != S_OK )
            goto Cleanup;
#ifndef unix
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[1] );
#else
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[2] );
#endif
        if ( hr != S_OK )
            goto Cleanup;
#ifndef unix
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[2] );
#else
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[1] );
#endif
        if ( hr != S_OK )
            goto Cleanup;

        if ( ( iStrLen == 1 ) && ( *pch == _T(')') ) )
            SetValue( rgbColor, FALSE, TYPE_RGB );
        else
            hr = E_INVALIDARG;
    }

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+-----------------------------------------------------------------------
//
//  Member   : GetHexDigit
//
//  Synopsis : Convert an ASCII hex digit character to binary
//
//  On entry : ch: ASCII character '0'..'9','A'..'F', or 'a'..'f'
//
//  Returns  : binary equivalent of ch interpretted at hex digit
//             0 if ch isn't a hex digit
//+-----------------------------------------------------------------------
static inline BYTE GetHexDigit( TCHAR ch, BOOL &fIsValid )
{
    if ( ch >= _T('0') && ch <= _T('9') ) 
    {
        return (BYTE) (ch - _T('0'));
    } 
    else 
    {
        if (ch >= _T('a') && ch <=('f'))
            return (BYTE) (ch - _T('a') + 10);            
        if ( ch >= _T('A') && ch <= _T('F') )
            return (BYTE) (ch - _T('A') + 10);
    }
    fIsValid = FALSE;
    return 0;
}

//+------------------------------------------------------------------------
//  Member: CColorValue::HexColor
//
//  Synopsis: Modifed from IE3 code base, this function takes a string which
//      needs to be converted into a hex rep for the rrggbb color.  The 
//      converstion is annoyingly lenient.
//
//  Note: The leniency of this routine is designed to emulate a popular Web browser
//        Fundamentally, the idea is to divide the given hex string into thirds, with 
//        each third being one of the colors (R,G,B).  If the string length isn't a multiple
//        three, it is (logically) extended with 0's.  Any character that isn't a hex digit
//        is treated as if it were a 0.  When each individual color spec is greater than
//        8 bits, the largest supplied color is used to determine how the given color
//        values should be interpretted (either as is, or scaled down to 8 bits).
//
//+------------------------------------------------------------------------
#define NUM_PRIMARIES   3
#define SHIFT_NUM_BASE  4
#define NUMBER_BASE     (1<<SHIFT_NUM_BASE)
#define MAX_COLORLENGTH 255

HRESULT
CColorValue::HexColor( LPCTSTR pch, int iStrLen, BOOL fValidOnly )
{
    HRESULT hr   = E_INVALIDARG;
    LPCTSTR pchTemp = pch;
    int     vlen = (iStrLen+NUM_PRIMARIES-1)/NUM_PRIMARIES;   // how many digits per section
    int     i, j;
    unsigned int rgb_vals[NUM_PRIMARIES];
    unsigned int max_seen = 0;
    DWORD   rgbColor = 0;
    TYPE    ColorType;
    BOOL    fIsValid = TRUE;

    if (!pch)
        goto Cleanup;

    if ( fValidOnly && (iStrLen != 3) && (iStrLen != 6) && (iStrLen != 9) )
        return E_INVALIDARG;

    // convert string to three color digits ala IE3, and others
    for ( i = 0; i < NUM_PRIMARIES; i++ ) 
    {                               
        // for each tri-section of the string
        for ( j = 0, rgb_vals[i] = 0; j < vlen; j++ ) 
        {                        
            rgb_vals[i] = (rgb_vals[i]<<SHIFT_NUM_BASE) + GetHexDigit(*pchTemp, fIsValid);

            if ( fValidOnly && !fIsValid )
                return E_INVALIDARG;

            if ( *pchTemp )                                         
                pchTemp++; 
        }
        if ( rgb_vals[i] > max_seen ) 
            max_seen = rgb_vals[i]; 
    }

    // rgb_values now has the triad in decimal
    // If any individual color component uses more than 8 bits, 
    //      scale all color values down.
    for ( i = 0 ; max_seen > MAX_COLORLENGTH ; i++ ) 
    {
        max_seen >>= SHIFT_NUM_BASE; 
    }

    if ( i>0 )
    {
        for ( j = 0; j < NUM_PRIMARIES; j++ ) 
            rgb_vals[j] >>= i*SHIFT_NUM_BASE;
    }

    // we used to do arena compatible handling of pound[1,2,3] colors always,
    // however we want NS compatibility and so #ab is turned to #0a0b00 rather
    // than #aabb00, but ONLY for non-stylesheet properties.
    if ( fValidOnly )
    {
        // This code makes #RGB expand to #RRGGBB, instead of #0R0G0B, which apparently those ... people at NS think is correct.
        if ( vlen == 1 )	// only 4 bits/color - scale up by 4 bits (& add to self, to get full range).
        {
            for ( i = 0; i < NUM_PRIMARIES; i++ ) 
            {
                rgb_vals[ i ] += rgb_vals[ i ]<<SHIFT_NUM_BASE;
            }
        }
    }

    // now put the rgb_vals together into a format our code understands
    // mnopqr => qropmn  or in colorese:  rrggbb => bbggrr
#ifdef BIG_ENDIAN
    ((BYTE *)&rgbColor)[0] = 0; 
    ((BYTE *)&rgbColor)[1] = (BYTE)rgb_vals[2];
    ((BYTE *)&rgbColor)[2] = (BYTE)rgb_vals[1];
    ((BYTE *)&rgbColor)[3] = (BYTE)rgb_vals[0];
#else
    ((BYTE *)&rgbColor)[0] = (BYTE)rgb_vals[0];
    ((BYTE *)&rgbColor)[1] = (BYTE)rgb_vals[1];
    ((BYTE *)&rgbColor)[2] = (BYTE)rgb_vals[2];
    ((BYTE *)&rgbColor)[3] = 0;
#endif
    switch (iStrLen) 
    {
    case 0:
        ColorType = TYPE_UNDEF;
        break;
    case 1:
        ColorType = TYPE_POUND1;
        break;
    case 2:
        ColorType = TYPE_POUND2;
        break;
    case 3:
        ColorType = TYPE_POUND3;
        break;
    case 4:
        ColorType = TYPE_POUND4;
        break;
    case 5:
        ColorType = TYPE_POUND5;
        break;
    case 6:
    default:
        ColorType = TYPE_POUND6;
        break;
    }

    // and finally set the color
    SetValue( rgbColor, FALSE, ColorType);
    hr = S_OK;

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+--------------------------------------------------------------------
//
//  member : Name Color
//
//  Sysnopsis : trying to parse a color string.. it could be a name
//      so lets look for it. if we find it, set the value and leave
//      otherwite return invalidarg (i.e. membernotfound)
//
//+--------------------------------------------------------------------
HRESULT
CColorValue::NameColor( LPCTSTR pch )
{
    const struct COLORVALUE_PAIR * pColorName = FindColorByName( pch );
    HRESULT hr = S_OK;

    if (pColorName)
        SetValue( pColorName );
    else
    {
        pColorName = FindColorBySystemName( pch );
        if ( pColorName )
            _dwValue = TYPE_SYSNAME + (pColorName->dwValue<<24);
        else
        {
            if ( !_wcsicmp( pch, _T("transparent") ) )
                _dwValue = (DWORD)TYPE_TRANSPARENT;
            else
                hr = E_INVALIDARG;
        }
    }
    RRETURN1( hr, E_INVALIDARG );
}

HRESULT
CColorValue::IsValid() const
{
    return ((TYPE_NAME != GetType()) ||
            (ARRAY_SIZE(aColorNames) > Index(GetRawValue()))) ? S_OK : E_INVALIDARG;
}

OLE_COLOR
CColorValue::GetOleColor() const
{
    if ( IsSysColor()) 
        return OLECOLOR_FROM_SYSCOLOR((_dwValue & MASK_SYSCOLOR)>>24);

#ifdef UNIX       
    if ( IsUnixSysColor()) {
        return (OLE_COLOR)_dwValue;
    }
#endif

    return (OLE_COLOR)(_dwValue & MASK_COLOR);
}

CColorValue::TYPE
CColorValue::GetType() const
{
    DWORD dwFlag = _dwValue & MASK_FLAG;

    // What a royal mess.  See the comment in cdbase.hxx for more info
    if ((dwFlag < TYPE_TRANSPARENT) && (dwFlag >= TYPE_NAME))
    {
        if (dwFlag >= TYPE_SYSNAME)
        {
            // A fancy way of avoiding yet another comparison (against TYPE_SYSINDEX)

            dwFlag &= ~MASK_SYSCOLOR;
        }
        else
        {
            dwFlag = TYPE_NAME;
        }
    }

    return (CColorValue::TYPE) dwFlag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\ippaint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ippain.cxx
//
//  Contents:   IOleInPlaceSiteWindowless helper methods
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetDC
//
//  Synopsis:   Gets a DC for the caller, type of DC depends on flags.
//
//  Arguments:  [prc]     -- param as per IOleInPlaceSiteWindowless::GetDC
//              [dwFlags] --                -do-
//              [phDC]    --                -do-
//
//  Returns:    HRESULT
//
//  History:    28-Mar-95   SumitC      Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetDC(LPRECT prc, DWORD dwFlags, HDC * phDC)
{
    HRESULT hr = S_OK;

    if (phDC == NULL)
        return E_POINTER;

    *phDC = NULL;

    if (_pInPlace == NULL)
        return E_FAIL;

    _pInPlace->_fIPNoDraw =
    _pInPlace->_fIPPaintBkgnd =
    _pInPlace->_fIPOffScreen = FALSE;

    if (_pInPlace->_hwnd)
    {
        // get the window dc
        *phDC = ::GetDC(_pInPlace->_hwnd);
        if (*phDC == NULL)
            RRETURN(GetLastWin32Error());

        HPALETTE hpal = GetPalette(*phDC);

        if (dwFlags & OLEDC_OFFSCREEN)
        {
            // build an offscreen buffer to return
            Assert(_pInPlace->_pOSC == NULL);
            _pInPlace->_pOSC = new COffScreenContext
                (
                *phDC,
                prc->right - prc->left,
                prc->bottom - prc->top,
                hpal,
                ((dwFlags >> 16) & OFFSCR_BPP)
                    | (dwFlags & OFFSCR_SURFACE)
                    | (dwFlags & OFFSCR_3DSURFACE)
                );
            
            if (_pInPlace->_pOSC == NULL)
            {
                ::ReleaseDC(_pInPlace->_hwnd, *phDC);
                RRETURN(E_OUTOFMEMORY);
            }

            *phDC = _pInPlace->_pOSC->GetDC(prc);
            _pInPlace->_fIPOffScreen = TRUE;
        }

        if (dwFlags & OLEDC_NODRAW)
        {
            _pInPlace->_fIPNoDraw = TRUE;
        }
        else if (dwFlags & OLEDC_PAINTBKGND)
        {
            _pInPlace->_fIPPaintBkgnd = TRUE;
        }
        _pInPlace->_rcPaint = *prc;

    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                GetDC(prc, dwFlags, phDC);
        if ((hr == S_OK) && *phDC)
            GetPalette(*phDC);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::ReleaseDC
//
//  Synopsis:   Releases a DC obtained via GetDC above.
//
//  Arguments:  [hDC] -- param as per IOleInPlaceSiteWindowless::ReleaseDC
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::ReleaseDC(HDC hDC)
{
    HRESULT hr = S_OK;

    Assert(_pInPlace);

    // Get our palette out of the DC so that it doesn't stay locked
    SelectPalette(hDC, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);

    if (_pInPlace->_hwnd)
    {
        if (_pInPlace->_fIPOffScreen)
        {
            Assert(_pInPlace->_pOSC);

            ::ReleaseDC(_pInPlace->_hwnd, _pInPlace->_pOSC->ReleaseDC(_pInPlace->_hwnd, !_pInPlace->_fIPNoDraw));

            delete _pInPlace->_pOSC;
            _pInPlace->_pOSC = NULL;
        }
        else
        {
            if (::ReleaseDC(_pInPlace->_hwnd, hDC) == 0)
                hr = GetLastWin32Error();
        }
    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->ReleaseDC(hDC);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::InvalidateRect
//
//  Synopsis:
//
//  Arguments:  [prc]    -- param as per IOleInPlaceSiteWindowless::InvalidateRect
//              [fErase] --             -do-
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::InvalidateRect(LPCRECT prc, BOOL fErase)
{
    HRESULT hr = S_OK;

    if (_state >= OS_INPLACE)
    {
        Assert(_pInPlace);

        if (_pInPlace->_hwnd)
        {
            if (::InvalidateRect(_pInPlace->_hwnd, prc, fErase) == 0)
                hr = GetLastWin32Error();
        }
        else
        {
            Assert(_pInPlace->_fWindowlessInplace);
            hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                    InvalidateRect(prc, fErase);
        }
    }

    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::InvalidateRgn
//
//  Synopsis:
//
//  Arguments:  [hrgn]   -- param as per IOleInPlaceSiteWindowless::InvalidateRgn
//              [fErase] --                 -do-
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::InvalidateRgn(HRGN hrgn, BOOL fErase)
{
    HRESULT hr = S_OK;

    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        ::InvalidateRgn(_pInPlace->_hwnd, hrgn, fErase);    // always returns TRUE
    }
    else
    {
        Assert(_pInPlace->_fWindowlessInplace);
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                InvalidateRgn(hrgn, fErase);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::Scroll
//
//  Synopsis:
//
//  Arguments:  [dx]        --
//              [dy]        --
//              [prcScroll] --
//              [prcClip]   --
//
//  Returns:    HRESULT
//
//  History:    28-Mar-95   SumitC      Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CServer::Scroll(int dx, int dy, LPCRECT prcScroll, LPCRECT prcClip)
{
    HRESULT hr      = S_OK;

    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        if (::ScrollWindowEx(_pInPlace->_hwnd,
                             dx,
                             dy,
                             prcScroll,
                             prcClip,
                             NULL,
                             NULL,
                             SW_INVALIDATE) == ERROR)
        {
            hr = GetLastWin32Error();
        }
    }
    else
    {
        Assert(_pInPlace->_fWindowlessInplace);
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                ScrollRect(dx, dy, prcScroll, prcClip);
    }

    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::AdjustRect
//
//  Synopsis:
//
//  Arguments:  [prc] -- param as per IOleInPlaceSiteWindowless::AdjustRect
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::AdjustRect(LPRECT prc)
{
    HRESULT hr = S_OK;

    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        IntersectRect(prc, prc, &_pInPlace->_rcClip);
    }
    else
    {
        Assert(_pInPlace->_fWindowlessInplace);
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                AdjustRect(prc);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\ipobj2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:       src\core\cdbase\ipobj2.cxx
//
//  Contents:   Implementation of IOleInPlaceObjectWindowless
//
//  Classes:    CServer
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

MtDefine(CDropTarget, ObjectModel, "CDropTarget")


// IDropTarget methods

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DragEnter, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DragEnter (
        IDataObject * pIDataSource,
        DWORD grfKeyState,
        POINTL pt,
        DWORD * pdwEffect)
{
    HRESULT hr = S_OK;

    if (pIDataSource==NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  DragLeave will not always be called, since we bubble up to
    //    our container's DragEnter if we decide we don't like the
    //    data object offered.  As a result, we need to clear any
    //    pointers hanging around from the last drag-drop. (chrisz)

    ReplaceInterface(&_pInPlace->_pDataObj, pIDataSource);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DragOver, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DragLeave, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DragLeave(BOOL fDrop)
{
    ClearInterface(&_pInPlace->_pDataObj);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::Drop, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::Drop(
    IDataObject * pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD * pdwEffect)
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:   CDropTarget::CDropTarget
//
//  Synopsis: Point to CServer for D&D Method delegation
//
//----------------------------------------------------------------------------

CDropTarget::CDropTarget(CServer * pServer)
{
    _pServer = pServer;
    _ulRef = 1;
    pServer->SubAddRef();

    MemSetName((this, "CDropTarget _pServer=%08x", pServer));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDropTarget::~CDropTarget
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

CDropTarget::~CDropTarget()
{

}

//+----------------------------------------------------------------------------
//
//  Member:     CDropTarget::QueryInterface
//
//  Synopsis:   Returns only IDropTarget and IUnknown interfaces. Does not
//              delegate QI calss to pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::QueryInterface (REFIID riid, void ** ppv)
{

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        *ppv = (IDropTarget *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;

}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::AddRef
//
//  Synopsis:   AddRefs the parent server
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDropTarget::AddRef()
{
    _pServer->SubAddRef();
    return ++_ulRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::Release
//
//  Synopsis:   Releases the parent server
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDropTarget::Release()
{
    _pServer->SubRelease();

    if (0 == --_ulRef)
    {
        delete this;
        return 0;
    }

    return _ulRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragEnter
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::DragEnter(
        IDataObject * pIDataSource,
        DWORD grfKeyState,
        POINTL pt,
        DWORD * pdwEffect)
{
    return _pServer->DragEnter(pIDataSource, grfKeyState, pt, pdwEffect);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragOver
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    return _pServer->DragOver (grfKeyState, pt, pdwEffect);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragLeave
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::DragLeave()
{
    return _pServer->DragLeave(FALSE);      // fDrop is FALSE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::Drop
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::Drop(
        IDataObject * pIDataSource,
        DWORD grfKeyState,
        POINTL pt,
        DWORD * pdwEffect)
{
    return _pServer->Drop(pIDataSource, grfKeyState, pt, pdwEffect);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetDropTarget
//
//  Synopsis:   returns IDropTarget interface.
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetDropTarget(IDropTarget ** ppDropTarget)
{
    HRESULT hr;

    if (!ServerDesc()->TestFlag(SERVERDESC_SUPPORT_DRAG_DROP))
    {
        *ppDropTarget = NULL;
        hr = E_NOTIMPL;
    }
    else
    {
        *ppDropTarget = new CDropTarget(this);
        hr =*ppDropTarget ? S_OK : E_OUTOFMEMORY;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\recalchlp.cxx ===
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       recalc.cxx
//
//  Contents:   CBase recalc support
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECALC_H_
#define X_RECALC_H_
#include <recalc.h>
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

MtDefine(CRecalcInfo, ObjectModel, "CRecalcInfo")

//---------------------------------------------------------------
//
//  Member:     CBase::removeExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CBase::removeExpression(BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    AssertSz(0, "CBase recalc methods should never be called");
    return E_FAIL;
}

//---------------------------------------------------------------
//
//  Member:     CBase::setExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CBase::setExpression(BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    AssertSz(0, "CBase recalc methods should never be called");
    return E_FAIL;
}

//---------------------------------------------------------------
//
//  Member:     CBase::getExpression
//
// REVIEW michaelw : need to add a language parameter to allow
// REVIEW michaelw : the caller to get the expression language
//
//---------------------------------------------------------------
STDMETHODIMP
CBase::getExpression(BSTR strPropertyName, VARIANT *pvExpression)
{
    AssertSz(0, "CBase recalc methods should never be called");
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\prophelp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       prophelp.cxx
//
//  Contents:   Some functions to help in dealing with object properties
//
//  Functions:  GetCommonPropertyValue
//              SetCommonPropertyValue
//
//  History:    29-Jun-93   SumitC      Created.
//              26-Oct-93   DonCl       Error code usage
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

HRESULT
SetFontProperty(
        UINT        cUnk,
        IUnknown ** apUnk,
        LOGFONT     lf,
        CY          cy);

//+------------------------------------------------------------------------
//
//  Function:   IsSameFontValue
//
//  Synopsis:   Checks to see if two font objects have the same value
//
//-------------------------------------------------------------------------

BOOL
IsSameFontValue(VARIANT * pvar1, VARIANT * pvar2)
{
    HRESULT     hr = S_OK;
    IFont *     pFont1 = NULL;
    IFont *     pFont2 = NULL;

    Assert(V_VT(pvar1) == VT_DISPATCH);
    Assert(V_VT(pvar2) == VT_DISPATCH);

    hr = V_DISPATCH(pvar1)->QueryInterface(IID_IFont, (void **)&pFont1);
    if (hr)
        goto Cleanup;

    hr = V_DISPATCH(pvar2)->QueryInterface(IID_IFont, (void **)&pFont2);
    if (hr)
        goto Cleanup;

    hr = pFont1->IsEqual(pFont2);

Cleanup:
    ReleaseInterface(pFont1);
    ReleaseInterface(pFont2);
    return hr ? FALSE : TRUE;
}


//+---------------------------------------------------------------
//
//  Member:     FindFontObject
//
//  Synopsis:   Find font object in a control set
//
//  Notes:      Helper function for OpenFontDialog()
//
//---------------------------------------------------------------
#ifndef NO_PROPERTY_PAGE
HRESULT
FindFontObject(
        UINT        cUnk,
        IUnknown ** apUnk,
        IFont **    ppFont)
{
    HRESULT         hr = S_OK;
    UINT            i;
    VARIANT         var;
    IDispatch *     pDispatch = NULL;

    VariantInit(&var);

    // Find the first control supports font
    for (i = 0; i < cUnk; i++)
    {
        hr = apUnk[i]->QueryInterface(IID_IDispatch, (LPVOID *) &pDispatch);
        if (hr)
            goto Cleanup;

        hr = GetDispProp(
            pDispatch,
            DISPID_FONT,
            g_lcidUserDefault,
            &var,
            NULL);

        if (hr)
        {
            // The control does not suport font, continue on next one
            ClearInterface(&pDispatch);
            VariantClear(&var);
            continue;
        }
        else
        {
            // Find a font object, stop here
            Assert(V_VT(&var) == VT_DISPATCH);
            hr = V_DISPATCH(&var)->QueryInterface(IID_IFont, (void **)ppFont);
            goto Cleanup;
       }
    }

Cleanup:
    ReleaseInterface(pDispatch);
    VariantClear(&var);
    RRETURN(hr);
}
#endif // NO_PROPERTY_PAGE

HRESULT
GetCommonSubObjectPropertyValue(
        DISPID      dispidMainObject,
        DISPID      dispidSubObject,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr                  = S_OK;
    UINT        i;
    VARIANT     var;
    VARIANT     varDispatch;
    BOOL        fCommonValueExists  = TRUE;
    EXCEPINFO   ei;

    VariantInit(pVar);
    VariantInit(&var);
    VariantInit(&varDispatch);

    InitEXCEPINFO(&ei);

    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; fCommonValueExists && i < cDisp; i++)
    {
        hr = GetDispProp(
                apDisp[i], 
                dispidMainObject,
                g_lcidUserDefault,
                &varDispatch,
                &ei);

        if (hr)
            goto Error;

        // Now get the sub object identified by dispidSubObject
        hr = GetDispProp(
                V_DISPATCH(&varDispatch), 
                dispidSubObject,
                g_lcidUserDefault,
                i == 0 ? pVar : &var,
                &ei);

        if (hr)
            goto Error;

        if (i > 0)
        {
            fCommonValueExists = IsVariantEqual(pVar, &var);
        }

        VariantClear(&var);
        VariantClear(&varDispatch);
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    if (!hr)
    {
        hr = !fCommonValueExists;
    }

    FreeEXCEPINFO(&ei);
    RRETURN2(hr, S_FALSE, DISP_E_MEMBERNOTFOUND);

Error:
    VariantClear(pVar);
    VariantClear(&varDispatch);
    VariantClear(&var);
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Function:   GetCommonPropertyValue
//
//  Synopsis:   Checks to see if an array of objects all have the same value
//              for a given property, returning the value of that property
//              if so.
//
//  Arguments:  [dispid]        --  Property id
//              [cDisp]         --  Number of objects in array
//              [apDisp]        --  Array of objects
//              [pVar]          --  The shared property value is returned
//                                  in *pVar
//
//  Notes:
//              If all the objects support the given property, but the
//              values don't match, this function returns S_FALSE.  The
//              variant returned will have the value of the first
//              object's property.
//
//              If cUnk == 0, this function returns E_INVALIDARG
//
//  Returns:    HRESULT (STDAPI); S_OK, S_FALSE, or error
//              Also sets the current error object.
//
//-------------------------------------------------------------------------

HRESULT
GetCommonPropertyValue(
        DISPID      dispid,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr                  = S_OK;
    UINT        i;
    VARIANT     var;
    BOOL        fCommonValueExists  = TRUE;
    EXCEPINFO   ei;

    VariantInit(pVar);
    VariantInit(&var);
    InitEXCEPINFO(&ei);

    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; fCommonValueExists && i < cDisp; i++)
    {
        hr = GetDispProp(
                apDisp[i], 
                dispid,
                g_lcidUserDefault,
                i == 0 ? pVar : &var,
                &ei);

        if (hr)
            goto Error;

        if (i > 0)
        {
            if (DISPID_FONT == dispid)
            {
                fCommonValueExists = IsSameFontValue(pVar, &var);
            }
            else
            {
                fCommonValueExists = IsVariantEqual(pVar, &var);
            }
        }

        VariantClear(&var);
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    if (!hr)
    {
        hr = !fCommonValueExists;
    }

    FreeEXCEPINFO(&ei);
    RRETURN2(hr, S_FALSE, DISP_E_MEMBERNOTFOUND);

Error:
    VariantClear(pVar);
    goto Cleanup;
}

HRESULT
SetCommonSubObjectPropertyValue(
        DISPID      dispidMainObject,
        DISPID      dispidSubObject,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr       = S_OK;
    UINT        i;
    EXCEPINFO   ei;
    VARIANT     varDispatch;

    VariantInit(&varDispatch);

    InitEXCEPINFO(&ei);
    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; i < cDisp; i++)
    {
        hr = GetDispProp(
                apDisp[i], 
                dispidMainObject,
                g_lcidUserDefault,
                &varDispatch,
                &ei);

        if (hr)
            goto Cleanup;

        hr = SetDispProp(
                V_DISPATCH(&varDispatch),
                dispidSubObject,
                g_lcidUserDefault,
                pVar,
                &ei);

        VariantClear(&varDispatch);

        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    FreeEXCEPINFO(&ei);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   SetCommonPropertyValue
//
//  Synopsis:   Sets a property value on an array of objects
//
//  Arguments:  [dispid]        --  Property id
//              [cDisp]         --  Number of objects in array
//              [apDisp]        --  Objects
//              [pVar]          --  New property value
//
//  Notes:      If cUnk == 0, this function returns E_INVALIDARG
//
//  Returns:    HRESULT (STDAPI)
//              Also sets the current error object.
//
//-------------------------------------------------------------------------

HRESULT
SetCommonPropertyValue(
        DISPID      dispid,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr       = S_OK;
    UINT        i;
    EXCEPINFO   ei;

    InitEXCEPINFO(&ei);
    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; i < cDisp; i++)
    {
        hr = SetDispProp(
                apDisp[i],
                dispid,
                g_lcidUserDefault,
                pVar,
                &ei);

        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    FreeEXCEPINFO(&ei);
    RRETURN(hr);
}


#ifndef NO_PROPERTY_PAGE
UINT_PTR CALLBACK ChooseFontCallback
(
    HWND hwnd,
    UINT msg,
    WPARAM wp,
    LPARAM lp
)
{
    return 0;
}

//+------------------------------------------------------------------------
//
//  Function:   OpenFontDialog
//
//  Synopsis:   Open a font dialog, which is used to set font property.
//
//  Arguments:  [pBase]         --  point to class where this func is called
//                                  It is used to create undo action
//              hWnd            --  point to owner window of dialog
//              [cUnk]          --  Number of objects in array
//              [apUnk]         --  Array of objects
//              [fUndo]         --  Indicate if need to create undo action
//              [pfRet]         --  reture value indicating if use click OK
//
//
//  Notes:
//              The objects are not IDispatch pointers, just regular old
//              IUnknowns.  If an object in the array doesn't support
//              IID_IDispatch, this function will return an error.
//
//              The font value displayed in dialog is the first
//              object's property.
//
//              If cUnk == 0, this function returns E_INVALIDARG
//
//  Returns:    HRESULT (STDAPI); S_OK, S_FALSE, or error
//              Also sets the current error object.
//
//-------------------------------------------------------------------------
HRESULT
OpenFontDialog(
        CBase *     pBase,
        HWND        hWnd,
        UINT        cUnk,
        IUnknown ** apUnk,
        BOOL *      pfRet)
{
    HRESULT         hr;
    LOGFONT         lf;
    CHOOSEFONT      cf;
    IFont *         pFont = NULL;
    CY              cy;
    BOOL            fBold = FALSE;
    BOOL            fItalic = FALSE;
    BOOL            fUnderline = FALSE;
    BOOL            fStrikethrough = FALSE;
#ifdef _MAC
    short           sWeight;
#endif
    BSTR            bstr = NULL;
    BOOL            fRet = FALSE;
    short           sCharSet = FALSE;
    
    cy.Lo = cy.Hi = 0;

    if (cUnk == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(FindFontObject(cUnk, apUnk, &pFont));
    if (hr)
        goto Cleanup;

    // Get current font information
    if (pFont)
    {
        pFont->get_Name(&bstr);
        pFont->get_Size(&cy);
        pFont->get_Bold(&fBold);
        pFont->get_Italic(&fItalic);
        pFont->get_Underline(&fUnderline);
        pFont->get_Strikethrough(&fStrikethrough);
#ifdef _MAC
        pFont->get_Weight(&sWeight);
#endif
        pFont->get_Charset(&sCharSet);
    }

    // Fill in LOGFONT struct
    memset(&lf, 0, sizeof(LOGFONT));
    _tcsncpy(lf.lfFaceName, bstr, SysStringLen(bstr));
    lf.lfHeight = (int) (cy.Lo * g_uiDisplay.GetResolution().cy / 720000L);

    lf.lfItalic     = !!fItalic;
    lf.lfWeight     = fBold ? 700: 400;
    lf.lfStrikeOut  = !!fStrikethrough;
    lf.lfUnderline  = !!fUnderline;
    lf.lfCharSet    = (BYTE) sCharSet;
#ifdef _MAC
    // mac note: we are using the high order bits of the IFont weight member
    //      to hold the outline and shadow flags.  Since the IFont Weight
    //      interface has the weight as a short, we must move the flags
    //      to the "long" end of the lfWeight field passing it on.
    if( sWeight & MAC_OUTLINE )
        lf.lfWeight     |= FW_OUTLINE;
    if( sWeight & MAC_SHADOW )
        lf.lfWeight     |= FW_SHADOW;
#endif

    // Fill in CHOOSEFONT struct
    memset(&cf, 0, sizeof(CHOOSEFONT));
    cf.lStructSize  = sizeof(CHOOSEFONT);
    cf.hwndOwner    = hWnd;
    cf.hDC          = NULL;
    cf.lpLogFont    = &lf;
    cf.iPointSize   = cy.Lo/1000;
    cf.Flags        = CF_SCREENFONTS |
                      CF_INITTOLOGFONTSTRUCT |
                      CF_FORCEFONTEXIST |
                      CF_EFFECTS |
                      CF_ENABLEHOOK;
    cf.lCustData    = 0;
    cf.lpfnHook     = ChooseFontCallback;
    cf.hInstance    = NULL;
    cf.nFontType    = SCREEN_FONTTYPE;

    //
    //  Open font dialog
    //
    fRet = ChooseFont(&cf);
    if (fRet)
    {
#ifndef NO_EDIT
        CParentUndoUnit *pCPUU = NULL;

        pCPUU = pBase->OpenParentUnit(pBase, IDS_UNDOPROPCHANGE);
#endif // NO_EDIT
        cy.Lo = cf.iPointSize * 1000;

        hr = SetFontProperty(cUnk, apUnk, lf, cy);
#ifndef NO_EDIT
        pBase->CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    }

Cleanup:
    if (pfRet)
    {
        *pfRet = fRet;
    }
    FormsFreeString(bstr);
    ReleaseInterface(pFont);

    RRETURN(hr);
}
#endif // NO_PROPERTY_PAGE



//+---------------------------------------------------------------
//
//  Member:     SetFontProperty
//
//  Synopsis:   Set font property to selected objects
//
//  Notes:      Helper function for OpenFontDialog()
//
//---------------------------------------------------------------
HRESULT
SetFontProperty(
        UINT        cUnk,
        IUnknown ** apUnk,
        LOGFONT     lf,
        CY          cy)
{
    HRESULT         hr = S_OK;
    IDispatch *     pDispatch = NULL;
    IFont *         pFont = NULL;
    BSTR            bstr = NULL;
    VARIANT         var;
    UINT            i;

    //MAKEBSTR does nothing on Intel Platform, recent change in
    //CFontNew::put_NameHelper(BSTR bstrName) of fontutil.cxx
    //has some code calling SysStringLen, which must be a real
    //BSTR
    hr = FormsReAllocString(&bstr , lf.lfFaceName);
    if (hr)
        goto Cleanup;

    VariantInit(&var);
    for (i = 0; i < cUnk; i++)
    {
        hr = apUnk[i]->QueryInterface(IID_IDispatch, (LPVOID *) &pDispatch);
        if (hr)
            goto Cleanup;

        hr = GetDispProp(
                pDispatch,
                DISPID_FONT,
                g_lcidUserDefault,
                &var,
                NULL);
        if (hr)
            goto Cleanup;

        Assert(V_VT(&var) == VT_DISPATCH);
        hr = V_DISPATCH(&var)->QueryInterface(IID_IFont, (void **)&pFont);
        if (hr)
            goto Cleanup;

        pFont->put_Size(cy);
        pFont->put_Name(bstr);
        pFont->put_Bold((lf.lfWeight == 400) ? FALSE : TRUE);
        pFont->put_Italic(lf.lfItalic);
        pFont->put_Underline(lf.lfUnderline);
        pFont->put_Strikethrough(lf.lfStrikeOut);
        pFont->put_Charset(lf.lfCharSet);
#ifdef _MAC
        // mac note: we are using the high order bits of the weight member
        //      to hold the outline and shadow flags.  Since the IFont put_Weight
        //      interface has the weight as a short, we must move the flags
        //      to the "short" end of the field before casting it out.
        if( lf.lfWeight & FW_OUTLINE )
            lf.lfWeight     |= MAC_OUTLINE;
        if( lf.lfWeight & FW_SHADOW )
            lf.lfWeight     |= MAC_SHADOW;

        pFont->put_Weight((short)lf.lfWeight);
#endif

        ClearInterface(&pDispatch);
        ClearInterface(&pFont);
        VariantClear(&var);
    }

Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pFont);
    FormsFreeString(bstr);
    VariantClear(&var);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\sdocobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       docobj.cxx
//
//  Contents:   Implementation for IOleDocument and IOleDocumentView
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


DeclareTag(tagMsoView, "IOleDocumentView", "IOleDocumentView methods in CServer")
DeclareTag(tagMsoDoc, "IOleDocument", "IOleDocument methods in CServer")


//+-------------------------------------------------------------------------
//
//  IOleDocument implementation
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CServer::CreateView, IOleDocument
//
//  Synopsis:   Asks the document to create a new viewand optionally
//              make the view initialize its view state from the given
//              stream.  Fails if we support only one view and this
//              method has already been called.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::CreateView(
        IOleInPlaceSite * pIPSite,
        IStream * pStm,
        DWORD dwReserved,
        IOleDocumentView ** ppView)
{
    HRESULT         hr;

    TraceTag((tagMsoDoc, "CServer::CreateView"));
    Assert(_fMsoDocMode);
    Assert(pIPSite);

    if (_fMsoViewExists)
    {
        RRETURN(E_FAIL);
    }

    hr = THR(EnsureInPlaceObject());
    if (hr)
        goto Cleanup;

    hr = THR(SetInPlaceSite(pIPSite));
    if (hr)
        goto Cleanup;

    if (pStm)
    {
        IGNORE_HR(ApplyViewState(pStm));
    }

    hr = THR(PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView));
    if (hr)
        goto Cleanup;

    _fMsoViewExists = TRUE;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetDocMiscStatus, IOleDocument
//
//  Synopsis:   Returns miscellaneous information about the doc object.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::GetDocMiscStatus(DWORD * pdwStatus)
{
    TraceTag((tagMsoDoc, "CServer::GetDocMiscStatus"));
    Assert(_fMsoDocMode);

    *pdwStatus = DOCMISC_CANTOPENEDIT | DOCMISC_NOFILESUPPORT;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::EnumViews, IOleDocument
//
//  Synopsis:   Enumerates the views of the document.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::EnumViews(IEnumOleDocumentViews ** ppEnumViews, IOleDocumentView ** ppView)
{
    TraceTag((tagMsoDoc, "CServer::EnumViews"));
    Assert(_fMsoDocMode);

    HRESULT hr = S_OK;

    *ppEnumViews = NULL;

    if (_fMsoViewExists)
    {
        hr = THR(PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView));
    }
    else
    {
        *ppView = NULL;
    }

    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  IOleDocumentView implementation
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetInPlaceSite, IOleDocumentView
//
//  Synopsis:   Detaches from the existing docsite, inplace deactivates
//              and saves new pointer.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetInPlaceSite(IOleInPlaceSite * pIPSite)
{
    HRESULT hr = S_OK;
    IOleInPlaceSiteEx * pIPSiteEx = NULL;
    
    TraceTag((tagMsoView, "CServer::SetInPlaceSite"));
    Assert(_fMsoDocMode);

    IGNORE_HR(InPlaceDeactivate());
    if (pIPSite)
    {
        hr = THR(EnsureInPlaceObject());
        if (hr)
            goto Cleanup;

        if (!(THR_NOTRACE(pIPSite->QueryInterface(
                   IID_IOleInPlaceSiteEx, (void **)&pIPSiteEx))))
        {
            //
            // This is really something that supports InPlaceSiteEx
            //

            _pInPlace->_fUseExtendedSite = TRUE;
            ReplaceInterface(
                &_pInPlace->_pInPlaceSite, 
                (IOleInPlaceSite *)pIPSiteEx);
        }
        else
        {
            _pInPlace->_fUseExtendedSite = FALSE;
            ReplaceInterface(&_pInPlace->_pInPlaceSite, pIPSite);
        }
        ReleaseInterface(pIPSiteEx);
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetInPlaceSite, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetInPlaceSite(IOleInPlaceSite ** ppIPSite)
{
    TraceTag((tagMsoView, "CServer::GetInPlaceSite"));
    Assert(_fMsoDocMode);

    if (_pInPlace && _pInPlace->_pInPlaceSite)
    {
        _pInPlace->_pInPlaceSite->AddRef();
        
        *ppIPSite = _pInPlace->_pInPlaceSite;
    }
    else
    {
        *ppIPSite = NULL;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetDocument, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetDocument(IUnknown ** ppUnk)
{
    TraceTag((tagMsoView, "CServer::GetDocument"));
    Assert(_fMsoDocMode);

    // cast to any non-tearoff interface
    *ppUnk = (IViewObject *)this;
    (*(IUnknown **) ppUnk)->AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetRect, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetRect(LPRECT prcView)
{
    long lDirty = 0;
    HRESULT hr = S_OK;
    SIZEL sizel;

    TraceTag((tagMsoView, "CServer::SetRect"));
    Assert(_fMsoDocMode);

    // NOTE (garybu): SHDOCVW incorrect calls this method
    // before we are inplace activated. Look at bug 20233
    // for more info about this if statement.
    if (State() < OS_INPLACE)
    {
        goto Cleanup;
    }

    sizel.cx = HimetricFromHPix(prcView->right - prcView->left);
    sizel.cy = HimetricFromVPix(prcView->bottom - prcView->top);

    if (sizel.cx != _sizel.cx || sizel.cy != _sizel.cy)
    {
        hr = THR(SetExtent(DVASPECT_CONTENT, &sizel));
        if (hr)
            goto Cleanup;
        //
        // TODO - marka bug for 10161
        // notifications are inadvertently setting dirtiness.
        // this must be fixed for beta2
        //
        lDirty = _lDirtyVersion;
        hr = THR(SetObjectRects(ENSUREOLERECT(prcView), ENSUREOLERECT(prcView)));
        if ( ( ! lDirty ) && ( _lDirtyVersion ))
            _lDirtyVersion = 0;
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetRect, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetRect(LPRECT prcView)
{
    TraceTag((tagMsoView, "CServer::GetRect"));

    Assert(_pInPlace);
    Assert(_fMsoDocMode);

    *prcView = _pInPlace->_rcPos;
    OffsetRect(prcView, _pInPlace->_ptWnd.x, _pInPlace->_ptWnd.y);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetRectComplex, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetRectComplex(
        LPRECT lprcView,
        LPRECT lprcHScroll,
        LPRECT lprcVScroll,
        LPRECT lprcSizeBox)
{
    TraceTag((tagMsoView, "CServer::SetRectComplex"));
    Assert(_fMsoDocMode);

    RRETURN(E_FAIL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::Show, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::Show(BOOL fShow)
{
    HRESULT     hr = S_OK;

    TraceTag((tagMsoView, "CServer::Show"));
    Assert(_fMsoDocMode);

    if (fShow)
    {
        if (_state < OS_INPLACE)
        {
            hr = THR(TransitionTo(OS_INPLACE, NULL));
            if (hr)
                goto Cleanup;
        }

        if (_pInPlace->_hwnd)
        {
            ShowWindow(_pInPlace->_hwnd, SW_SHOWNORMAL);
        }
    }
    else
    {
        if (_state == OS_UIACTIVE)
        {
            IGNORE_HR(UIActivate(FALSE));
        }

        if (_state >= OS_INPLACE && _pInPlace->_hwnd)
        {
            ShowWindow(_pInPlace->_hwnd, SW_HIDE);
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::UIActivate, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::UIActivate(BOOL fActivate)
{
    HRESULT     hr = S_OK;
    long lDirtyBefore;
    TraceTag((tagMsoView, "CServer::UIActivate"));
    Assert(_fMsoDocMode);

    lDirtyBefore = _lDirtyVersion;
    if (fActivate && (_state < OS_UIACTIVE))
    {
        hr = THR(TransitionTo(OS_UIACTIVE, NULL));
    }
    else if ((fActivate == FALSE) && (_state == OS_UIACTIVE))
    {
        IGNORE_HR(UIDeactivate());
    }
    //
    // TODO ( marka) - HACK for Bug 10161
    // to be fixed post beta 2
    //
    if ( ( ! lDirtyBefore  ) && ( _lDirtyVersion))
        _lDirtyVersion = 0;
        
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::Open, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::Open(void)
{
    TraceTag((tagMsoView, "CServer::Open"));
    Assert(_fMsoDocMode);

    //
    //  No view frame of our own
    //

    RRETURN(E_FAIL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::CloseView, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::CloseView(DWORD dwReserved)
{
    TraceTag((tagMsoView, "CServer::CloseView"));
    Assert(_fMsoDocMode);

    //
    //  Implementation of IOleDocumentView::CloseView - we support
    //  only one view.  Send the view the NULL InPlaceSite.
    //

    IGNORE_HR(SetInPlaceSite(NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SaveViewState, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SaveViewState(IStream * pStm)
{
    TraceTag((tagMsoView, "CServer::SaveViewState"));
    Assert(_fMsoDocMode);

    //  No view state for now
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::ApplyViewState, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::ApplyViewState(IStream * pStm)
{
    TraceTag((tagMsoView, "CServer::ApplyViewState"));
    Assert(_fMsoDocMode);

    //  No view state for now
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::Clone, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::Clone(IOleInPlaceSite * pNewIPSite, IOleDocumentView ** ppNewView)
{
    TraceTag((tagMsoView, "CServer::Clone"));
    Assert(_fMsoDocMode);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\sdv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//   File:       sdv.cxx
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifdef _MAC
#ifndef X_MACCONTROLS_H_
#define X_MACCONTROLS_H_
#include "maccontrols.h"
#endif
#endif

//  TODO make this string shorter!

const OLECHAR szContents[] = OLESTR("contents");

#if !defined(WINCE)
/*
 * CreateDCFromTargetDev()
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 *    SCODE  -  S_OK if successful
 */
HDC
CreateDCFromTargetDev(DVTARGETDEVICE FAR* ptd)
{
    HDC hdc=NULL;
    LPDEVNAMES lpDevNames;
    LPDEVMODE lpDevMode;
    LPTSTR lpszDriverName;
    LPTSTR lpszDeviceName;
    LPTSTR lpszPortName;

    if (ptd == NULL)
    {
        hdc = CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        goto errReturn;
    }

    lpDevNames = (LPDEVNAMES) ptd; // offset for size field

    if (ptd->tdExtDevmodeOffset == 0)
        lpDevMode = NULL;
    else
        lpDevMode = (LPDEVMODE) ((LPTSTR)ptd + ptd->tdExtDevmodeOffset);

    lpszDriverName = (LPTSTR) lpDevNames + ptd->tdDriverNameOffset;
    lpszDeviceName = (LPTSTR) lpDevNames + ptd->tdDeviceNameOffset;
    lpszPortName   = (LPTSTR) lpDevNames + ptd->tdPortNameOffset;

    hdc = CreateDC(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode);

errReturn:
    return hdc;
}
#endif // !WINCE


//+---------------------------------------------------------------
//
//  Member:     CServer::SendOnDataChange
//
//  Synopsis:   Send data change notification to advise sinks.
//
//---------------------------------------------------------------
void
CServer::SendOnDataChange(DWORD_PTR dwAdvf)
{
    HRESULT         hr;
    IDataObject *   pDO;

    if (_pDataAdviseHolder)
    {
        hr = PrivateQueryInterface(IID_IDataObject, (void **)&pDO);
        if (OK(hr))
        {
            _pDataAdviseHolder->SendOnDataChange(pDO, 0, (DWORD)dwAdvf);
            pDO->Release();
        }
    }

    _fDataChangePosted = FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::OnDataChange, public
//
//  Synopsis:   Raises data and view changed to all registered 
//              advises
//
//  Notes:      This function should be called whenever the native
//              data of the object is modified.
//
//---------------------------------------------------------------

void
CServer::OnDataChange(BOOL fInvalidateView )
{
    if(fInvalidateView)
        OnViewChange(DVASPECT_CONTENT);

    if (_pDataAdviseHolder && !_fDataChangePosted && !IsPassivating() && !IsPassivated())
    {
        HRESULT hr = GWPostMethodCall(this, ONCALL_METHOD(CServer, SendOnDataChange, sendondatachange), 0, FALSE, "CServer::SendOnDataChange");
        if (!hr)
            _fDataChangePosted = TRUE;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnPropertyChange
//
//  Synopsis:   Fires property change event, and then OnDataChange
//
//  Arguments:  [dispidProperty] -- PROPID of property that changed
//              [dwFlags]        -- Flags to inhibit behavior
//
//  Notes:      The [dwFlags] parameter has the following values that can be
//              OR'd together:
//
//              SERVERCHNG_NOPROPCHANGE -- Inhibits the OnChanged notification
//                 through the PropNotifySink.
//              SERVERCHNG_NOVIEWCHANGE -- Inhibits the OnViewChange notification.
//              SERVERCHNG_NODATACHANGE -- Inhibits the OnDataChange notification.
//
//----------------------------------------------------------------------------

HRESULT
CServer::OnPropertyChange(
        DISPID dispidProperty,
        DWORD  dwFlags,
        const PROPERTYDESC *ppropdesc)
{

    if (TestLock(SERVERLOCK_PROPNOTIFY) || _state < OS_LOADED)
        return S_OK;

    _lDirtyVersion = MAXLONG;

    if (!(dwFlags & SERVERCHNG_NOPROPCHANGE))
    {
        IGNORE_HR(FireOnChanged(dispidProperty));
    }

    if (!(dwFlags & SERVERCHNG_NODATACHANGE))
    {
        SendOnDataChange(0);
    }

    if (!(dwFlags & SERVERCHNG_NOVIEWCHANGE))
    {
        OnViewChange(DVASPECT_CONTENT);
    }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::GetMonikerDisplayName, public
//
//  Synopsis:   Returns the display name from the object's moniker
//
//  Notes:      The display name of the object is used in for dispensing
//              the Object Descriptor clipboard format.  The caller must
//              free the string returned using TaskFreeString.
//
//---------------------------------------------------------------

LPTSTR
CServer::GetMonikerDisplayName(DWORD dwAssign)
{
    //  Default dwAssign is OLEGETMONIKER_ONLYIFTHERE

    LPMONIKER pmk;
    LPTSTR    lpstrDisplayName = NULL;

    if (OK(GetMoniker(dwAssign, OLEWHICHMK_OBJFULL, &pmk)))
    {
        ::GetMonikerDisplayName(pmk, &lpstrDisplayName);
        pmk->Release();
    }

    return lpstrDisplayName;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetEMBEDDEDOBJECT, static
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Embedded Object clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetEMBEDDEDOBJECT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT     hr = E_FAIL;

#if !defined(WINCE)
    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTORAGE;
        pmedium->pUnkForRelease = NULL;

        hr = THR(StgCreateDocfile(
                NULL,
                STGM_DFRALL | STGM_CREATE | STGM_DELETEONRELEASE,
                0,
                &pmedium->pstg));
        if (hr)
            goto Error;
    }

    hr = THR(WriteClassStg(pmedium->pstg, *pServer->BaseDesc()->_pclsid));
    if (hr)
        goto Error;

    hr = THR(pServer->Save(pmedium->pstg, FALSE));
    if (hr)
        goto Error;

    hr = THR(pServer->SaveCompleted((IStorage *) NULL));
    if (!hr)
    {
        IGNORE_HR(pmedium->pstg->Commit(STGC_DEFAULT));
    }


Error:
    //  If we failed somehow and yet created a docfile, then we will
    //      release the docfile to delete it

    if (hr && !fHere)
        ClearInterface(&pmedium->pstg);
#endif // !WINCE

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetMETAFILEPICT, static
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Metafilepict clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This member function uses IViewObject::Draw to construct
//              the metafile pict.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetMETAFILEPICT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
#if defined(WINCE)
    RRETURN(E_FAIL);
#else
    HRESULT         hr      = S_OK;
    RECTL           rcl;
    HMETAFILE       hmf     = NULL;
    HDC             hdc;
    LPMETAFILEPICT  pPict;
#ifdef _MAC
    UINT        dwFlags = GMEM_SHARE | GMEM_MOVEABLE;
    HANDLE      hdl;
    HANDLE  *   phdl = &hdl;
#else
    UINT        dwFlags = GMEM_SHARE;
    HANDLE  *   phdl = &pmedium->hGlobal;
#endif



    if (!fHere)
    {
        //  Fill in the pmedium structure

        pmedium->tymed = TYMED_MFPICT;
        pmedium->pUnkForRelease = NULL;
        *phdl = GlobalAlloc(dwFlags, sizeof(METAFILEPICT));

        if (*phdl == NULL)
            goto MemoryError;
#ifdef _MAC
        if(!UnwrapHandle(*phdl,(Handle*)&pmedium->hGlobal))
        {
            goto MemoryError;
        }
#  if DBG == 1
        else
        {
            // the wlm HANDLE is no more...
            hdl = NULL;
        }
#  endif
#endif
    }

    rcl.left = rcl.top = 0;
    hr = THR(pServer->GetExtent(
            pformatetc->dwAspect,
            pformatetc->lindex,
            pformatetc->ptd,
            (SIZEL *)&rcl.right));
    if (hr)
        goto Error;

    hdc = CreateMetaFileA(NULL);
    if (!hdc)
        goto MemoryError;

    rcl.right = HPixFromHimetric(rcl.right);
    rcl.bottom = VPixFromHimetric(rcl.bottom);

    SetMapMode(hdc, MM_ANISOTROPIC);
    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, rcl.right, rcl.bottom, NULL);

    hr = THR(pServer->Draw(pformatetc->dwAspect,
            pformatetc->lindex,
            NULL,
            pformatetc->ptd,
            NULL,
            hdc,
            &rcl,
            &rcl,
            NULL,
            0));

    hmf = CloseMetaFile(hdc);

    if (hmf == NULL)
        goto MemoryError;

    if (hr)
        goto Error;

#ifdef _MAC
    if(!WrapHandle((Handle)pmedium->hGlobal,phdl,FALSE,dwFlags))
    {
        goto MemoryError;
    }
#endif
    pPict = (LPMETAFILEPICT) GlobalLock(*phdl);
    if (pPict == NULL)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // fill in the object descriptor

    pPict->mm   =  MM_ANISOTROPIC;
    pPict->hMF  =  hmf;
    //
    // The following two values MUST BE in HIMETRIC, as long as the mapping
    // mode is MM_ANISOTROPIC.
    //
    pPict->xExt = HimetricFromHPix(rcl.right);
    pPict->yExt = HimetricFromVPix(rcl.bottom);

    GlobalUnlock(*phdl);

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (!fHere && *phdl)
        GlobalFree(*phdl);

    if (hmf)
        DeleteMetaFile(hmf);

    goto Cleanup;
#endif //WINCE
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetENHMETAFILE, static
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the enhanced metafile clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This member function uses IViewObject::Draw to construct
//              the metafile pict.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetENHMETAFILE(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
#if defined(WINCE)
    RRETURN(E_FAIL);
#else
    HRESULT         hr      = S_OK;
    RECTL           rcl;
    HDC             hdc;
    HDC             hdcRef = CreateDCFromTargetDev(pformatetc->ptd);
    if (!hdcRef)
        goto MemoryError;

    pmedium->tymed = TYMED_ENHMF;
    pmedium->pUnkForRelease = NULL;
    pmedium->hEnhMetaFile = NULL;

    rcl.left = rcl.top = 0;
    hr = THR(pServer->GetExtent(
            pformatetc->dwAspect,
            pformatetc->lindex,
            pformatetc->ptd,
            (SIZEL *)&rcl.right));
    if (hr)
        goto Error;

    hdc = CreateEnhMetaFileA(
            hdcRef,
            NULL,
            (RECT *)&rcl,
            NULL);
    if (!hdc)
        goto MemoryError;

    rcl.right = MulDivQuick(rcl.right,
            GetDeviceCaps(hdcRef, HORZRES),
            100 * GetDeviceCaps(hdcRef, HORZSIZE));
    rcl.bottom = MulDivQuick(rcl.bottom,
            GetDeviceCaps(hdcRef, VERTRES),
            100 * GetDeviceCaps(hdcRef, VERTSIZE));

    hr = THR(pServer->Draw(pformatetc->dwAspect,
            pformatetc->lindex,
            NULL,
            pformatetc->ptd,
            NULL,
            hdc,
            &rcl,
            &rcl,
            NULL,
            0));

    pmedium->hEnhMetaFile = CloseEnhMetaFile(hdc);

    if (pmedium->hEnhMetaFile == NULL)
        goto MemoryError;

    if (hr)
        goto Error;

Cleanup:
    if (hdcRef)
        DeleteDC(hdcRef);
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (pmedium->hEnhMetaFile)
        DeleteEnhMetaFile(pmedium->hEnhMetaFile);

    goto Cleanup;
#endif // WINCE
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetOBJECTDESCRIPTOR, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Object Descriptor clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetOBJECTDESCRIPTOR(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT             hr                  = S_OK;
    LPTSTR              lpstrDisplay        = NULL;
    size_t              cch;
    size_t              cbSize;
    size_t              cbUserTypeFull;
    size_t              cbDisplay;
    LPOBJECTDESCRIPTOR  pObjDesc;
    TCHAR               achUserTypeFull[MAX_USERTYPE_LEN + 1];
#ifdef _MAC
    UINT        dwFlags = GMEM_SHARE | GMEM_MOVEABLE;
    HANDLE      hdl;
    HANDLE  *   phdl = &hdl;
#else
    UINT        dwFlags = GMEM_SHARE;
    HANDLE  *   phdl = &pmedium->hGlobal;
#endif



    //  REVIEW This is not the best display name for the OBJECTDESCRIPTOR
    //    It would be more useful to see the Class name...

    lpstrDisplay = pServer->GetMonikerDisplayName(OLEGETMONIKER_ONLYIFTHERE);



    Verify(LoadString(
            GetResourceHInst(),
            IDS_USERTYPEFULL(pServer->BaseDesc()->_idrBase),
            achUserTypeFull,
            ARRAY_SIZE(achUserTypeFull)));

    // Compute the size of the descriptor.

    Assert(_tcsclen(achUserTypeFull));

    cbUserTypeFull = (_tcsclen(achUserTypeFull) + 1) * sizeof(TCHAR);

    cbDisplay = 0;
    if (lpstrDisplay != NULL)
    {
        cch = _tcsclen(lpstrDisplay);
        if (cch)
            cbDisplay = (cch + 1) * sizeof(TCHAR);
    }

    cbSize = sizeof(OBJECTDESCRIPTOR) + cbUserTypeFull + cbDisplay;

    if (!fHere)
    {
        // fill in the pmedium structure

        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->pUnkForRelease = NULL;
        *phdl = GlobalAlloc(dwFlags, cbSize);
        if (*phdl == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
#ifdef _MAC
        if(!UnwrapHandle(*phdl,(Handle*)&pmedium->hGlobal))
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }
    if(!WrapHandle( (Handle)pmedium->hGlobal, phdl,FALSE,dwFlags))
    {
        hr = E_HANDLE;
        goto Error;
#endif
    }

    pObjDesc = (LPOBJECTDESCRIPTOR) GlobalLock(*phdl);
    if (!pObjDesc)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // fill in the object descriptor

    pObjDesc->cbSize = cbSize;
    pObjDesc->clsid = *pServer->BaseDesc()->_pclsid;
    pObjDesc->dwDrawAspect = DVASPECT_CONTENT;
    pObjDesc->dwStatus = pServer->ServerDesc()->_dwMiscStatus;

#ifdef _MAC
    pObjDesc->sizel.cx = HPixFromHimetric(pServer->_sizel.cx);
    pObjDesc->sizel.cy = VPixFromHimetric(pServer->_sizel.cy);
#else
    pObjDesc->sizel = pServer->_sizel;
#endif
    pObjDesc->pointl.y = pObjDesc->pointl.x = 0;

    pObjDesc->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
    memcpy(pObjDesc + 1, achUserTypeFull, cbUserTypeFull);

    if (lpstrDisplay == NULL)
    {
        pObjDesc->dwSrcOfCopy = 0;
    }
    else
    {
        pObjDesc->dwSrcOfCopy = sizeof(OBJECTDESCRIPTOR) + cbUserTypeFull;
        memcpy(
                ((BYTE *) pObjDesc) + pObjDesc->dwSrcOfCopy,
                lpstrDisplay,
                cbDisplay);
    }

    GlobalUnlock(*phdl);

Cleanup:
    TaskFreeString(lpstrDisplay);
    RRETURN(hr);

Error:
    if (!fHere && *phdl)
    {
        GlobalFree(*phdl);
        pmedium->hGlobal = NULL;
    }
    goto Cleanup;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetLINKSOURCE, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Link Source clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This method uses the moniker cached by the data/view
//              object.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetLINKSOURCE(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT     hr;
    LPMONIKER   pmk = NULL;
    CLSID       clsid;

    if (!fHere)
    {
        // fill in the pmedium structure

        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pUnkForRelease = NULL;
        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm));
        if (hr)
            goto Error;
    }

    hr = THR(pServer->GetMoniker(
            OLEGETMONIKER_ONLYIFTHERE,
            OLEWHICHMK_OBJFULL,
            &pmk));
    if (hr)
        goto Error;

    hr = THR(pmk->GetClassID(&clsid));
    if (hr)
        goto Error;

    hr = THR(WriteClassStm(pmedium->pstm, clsid));
    if (hr)
        goto Error;

    hr = THR(pmk->Save(pmedium->pstm, FALSE));
    if (hr)
        goto Error;

Cleanup:
    ReleaseInterface(pmk);

    RRETURN(hr);

Error:
    if (!fHere && pmedium->pstm)
        ClearInterface(&pmedium->pstm);

    goto Cleanup;
}


//+--------------------------------------------------------------
//
//  Member:     CServer::GetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    HRESULT         hr;
    int             i;

    if (pformatetc == NULL || pmedium == NULL)
        RRETURN(E_INVALIDARG);

    i = FindCompatibleFormat(
            ServerDesc()->_pGetFmtTable,
            ServerDesc()->_cGetFmtTable,
            *pformatetc);

    if (i < 0)
    {
        hr = DV_E_FORMATETC;
    }
    else
    {
        LPDATAOBJECT    pDO;
        //
        // For the icon aspect, check the cache first.
        //
        if (pformatetc->dwAspect == DVASPECT_ICON && _pCache)
        {
            hr = THR(_pCache->QueryInterface(
                    IID_IDataObject,
                    (LPVOID *) &pDO));
            if (!hr)
            {
                hr = THR(pDO->GetData(pformatetc, pmedium));
                pDO->Release();

                if (!hr)
                    RRETURN(hr);
            }
        }
        hr = THR((*ServerDesc()->_pGetFuncs[i]) (this, pformatetc, pmedium, FALSE));
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetDataHere, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    HRESULT         hr;
    int             i;

    i = FindCompatibleFormat(
            ServerDesc()->_pGetFmtTable,
            ServerDesc()->_cGetFmtTable,
            *pformatetc);

    if (i < 0)
    {
        hr = DV_E_FORMATETC;
    }
    else
    {
        LPDATAOBJECT    pDO;
        //
        // For the icon aspect, check the cache first.
        //
        if ((pformatetc->dwAspect == DVASPECT_ICON) && _pCache)
        {
            hr = THR(_pCache->QueryInterface(IID_IDataObject, (LPVOID *) &pDO));
            if (!hr)
            {
                hr = THR(pDO->GetDataHere(pformatetc, pmedium));
                pDO->Release();

                if (!hr)
                    RRETURN(hr);
            }
        }
        hr = THR((*ServerDesc()->_pGetFuncs[i]) (this, pformatetc, pmedium, TRUE));
    }

    RRETURN1(hr, S_FALSE);
}




//+---------------------------------------------------------------
//
//  Member:     CServer::QueryGetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  The return value indicates
//              whether or not a compatible format was found.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::QueryGetData(LPFORMATETC pformatetc)
{
    int     i;

    i = FindCompatibleFormat(
            ServerDesc()->_pGetFmtTable,
            ServerDesc()->_cGetFmtTable,
            *pformatetc);

    RRETURN((i >= 0) ? S_OK : DV_E_FORMATETC);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetCanonicalFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method returns DATA_S_SAMEFORMATETC assuming
//              that each format the server dispenses is its own
//              canonical format.  If this is not the case then this
//              method should be overridden.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetCanonicalFormatEtc(
        LPFORMATETC pformatetc,
        LPFORMATETC pformatetcOut)
{
    return DATA_S_SAMEFORMATETC;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Set format table
//              for a compatible format.  If one is found it calls
//              the corresponding Set function.
//
//---------------------------------------------------------------
STDMETHODIMP
CServer::SetData(
        LPFORMATETC pformatetc,
        STGMEDIUM FAR *pmedium,
        BOOL fRelease)
{
    HRESULT hr;
    int     i;

    if (!pformatetc || !pmedium)
        RRETURN(E_INVALIDARG);

    i = FindCompatibleFormat(
            ServerDesc()->_pSetFmtTable,
            ServerDesc()->_cSetFmtTable,
            *pformatetc);

    if (i < 0)
    {
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = THR((*ServerDesc()->_pSetFuncs[i])(this, pformatetc, pmedium));
    }

    if (fRelease)
        ReleaseStgMedium(pmedium);

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::EnumFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method creates an enumerator over the Get or
//              Set format tables depending on the value of the
//              dwDirection argument.
//
//              TODO -- This method is incorrect because it ends
//              up enumerating formatetc's with more than one
//              DVASPECT flag set in the dwAspect member at a time.
//              This is illegal.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumFormatEtc(
        DWORD dwDirection,
        LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    HRESULT     hr;

    if (!ppenumFormatEtc)
        RRETURN(E_INVALIDARG);

    *ppenumFormatEtc = NULL;            // set out params to NULL

    //  Create an enumerator over our static format table.

    switch (dwDirection)
    {
    case DATADIR_GET:
        hr = THR(CreateFORMATETCEnum(
                ServerDesc()->_pGetFmtTable,
                ServerDesc()->_cGetFmtTable,
                ppenumFormatEtc));
        break;

    case DATADIR_SET:
        hr = THR(CreateFORMATETCEnum(
                ServerDesc()->_pSetFmtTable,
                ServerDesc()->_cSetFmtTable,
                ppenumFormatEtc));
        break;

    default:
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::DAdvise(
        FORMATETC FAR* pFormatetc,
        DWORD advf,
        LPADVISESINK pAdvSink,
        DWORD FAR* pdwConnection)
{
    HRESULT         hr;
    IDataObject *   pDO;
    int             i;

    if (pdwConnection == NULL)
        RRETURN(E_INVALIDARG);

    *pdwConnection = NULL;              // set out params to NULL

    //
    //  Make sure we support the requested format if
    //  no request for data is pending.
    //

    if ((advf & ADVF_NODATA) == 0)
    {
        i = FindCompatibleFormat(
                ServerDesc()->_pGetFmtTable,
                ServerDesc()->_cGetFmtTable,
                *pFormatetc);

        if (i < 0)
            RRETURN(DATA_E_FORMATETC);
    }

    if (_pDataAdviseHolder == NULL)
    {
        hr = THR(CreateDataAdviseHolder(&_pDataAdviseHolder));
        if (hr)
            goto Cleanup;
    }

    hr = PrivateQueryInterface(IID_IDataObject, (void **)&pDO);
    if (hr)
        goto Cleanup;

    hr = THR(_pDataAdviseHolder->Advise(
            pDO,
            pFormatetc,
            advf,
            pAdvSink,
            pdwConnection));

    pDO->Release();

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DUnadvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::DUnadvise(DWORD dwConnection)
{
    HRESULT     hr;

    if (!_pDataAdviseHolder)
        RRETURN(OLE_E_NOCONNECTION);

    hr = THR(_pDataAdviseHolder->Unadvise(dwConnection));

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::EnumDAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumDAdvise (LPENUMSTATDATA FAR* ppenumAdvise)
{
    HRESULT     hr;

    if (!ppenumAdvise)
        RRETURN(E_INVALIDARG);

    *ppenumAdvise = NULL;               // set out params to NULL

    if (_pDataAdviseHolder == NULL)
    {
        hr = S_OK;
    }
    else
    {
        hr = THR(_pDataAdviseHolder->EnumAdvise(ppenumAdvise));
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::Draw, IViewObject
//
//  Synopsis:   Render object to the DC.
//              Derived classes should override this method to implemnt
//              rendering for DVASPECT_CONTENT.
//
//  Arguments:  Per IViewObjectDraw.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Draw(
        DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hdcTargetDev,
        HDC hdcDraw,
        LPCRECTL prclDraw,
        LPCRECTL prcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    HRESULT     hr;
    CDrawInfo   DI;
    RECT        rc;
    POINT       ptOrg = { 0 };
    SIZE        sizeExt;
    BOOL        fDeleteTargetDev = FALSE;
    
    Assert((prclDraw || _state >= OS_INPLACE) &&
        "violation of prcl==NULL contract");

    Assert(hdcDraw);

    if (dwDrawAspect ==  DVASPECT_ICON)
    {
        hr = E_FAIL;

        //
        //  See if the cache has our icon first before we draw it.
        //
        if (_pViewObjectCache)
        {
            hr = THR(_pViewObjectCache->Draw(
                    dwDrawAspect,
                    lindex,
                    pvAspect,
                    ptd,
                    hdcTargetDev,
                    hdcDraw,
                    prclDraw,
                    prcWBounds,
                    pfnContinue,
                    dwContinue));
        }

// WINCEREVIEW - no support for metafiles or different mapping modes in CE
#ifndef WINCE
        if (hr)
        {
            //
            // Get the 'standard' icon
            //
            HGLOBAL hMetaPict = OleGetIconOfClass(*BaseDesc()->_pclsid,
                                                  NULL, TRUE);

            LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);
            if (pMF)
            {
                POINT ptOrg;
                SIZE  sizeExt;

                SetMapMode(hdcDraw, pMF->mm);
                SetViewportOrgEx(hdcDraw, prclDraw->left, prclDraw->top, &ptOrg);
                SetViewportExtEx(hdcDraw,
                                 prclDraw->right - prclDraw->left,
                                 prclDraw->bottom - prclDraw->top,
                                 &sizeExt);

                PlayMetaFile(hdcDraw, pMF->hMF);

                SetViewportOrgEx(hdcDraw, ptOrg.x, ptOrg.y, (POINT *)NULL);
                SetViewportExtEx(hdcDraw, sizeExt.cx, sizeExt.cy, (SIZE *)NULL);

                GlobalUnlock(hMetaPict);

                DeleteMetaFile(pMF->hMF);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
#endif // WINCE

        RRETURN(hr);
    }

    if (prclDraw &&
        ( (_sizel.cx == 0 && prclDraw->right - prclDraw->left != 0) ||
          (_sizel.cy == 0 && prclDraw->bottom - prclDraw->top != 0) ) )
    {
        Assert(0 && "Host error: Infinite scale factor.");
        RRETURN(E_FAIL);
    }

    // Copy rectangle because we scribble on it.

    rc = *(prclDraw ? (RECT*)prclDraw : (RECT*)&_pInPlace->_rcPos);

    // Save the DC always

    if (SaveDC(hdcDraw) == 0)
        RRETURN(GetLastWin32Error());

// WINCEREVIEW - no support for metafiles or different mapping modes in CE
//only mapping mode we know in MM_TEXT
#ifndef WINCE
    // Retrieve current window origin
    GetWindowOrgEx(hdcDraw, & ptOrg);
    
    // Ensure that there is a one to one mapping between logial units and
    // device units.

    // If we are drawing into a meta file, then make sure that x and y
    // are going in the right directions.

    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE)
    {
        BOOL    fSwapXExt = rc.left > rc.right;
        BOOL    fSwapYExt = rc.top > rc.bottom;

        if (fSwapXExt || fSwapYExt)
        {
            if (GetWindowExtEx(hdcDraw, &sizeExt) == 0)
                RRETURN(GetLastWin32Error());

            if (fSwapXExt)
            {
                ptOrg.x    = -ptOrg.x;
                sizeExt.cx = -sizeExt.cx;
                rc.left    = -rc.left;
                rc.right   = -rc.right;
            }

            if (fSwapYExt)
            {
                ptOrg.y    = -ptOrg.y;
                sizeExt.cy = -sizeExt.cy;
                rc.top     = -rc.top;
                rc.bottom  = -rc.bottom;
            }

            SetWindowOrgEx(hdcDraw, ptOrg.x, ptOrg.y, (POINT *)NULL);
            SetWindowExtEx(hdcDraw, sizeExt.cx, sizeExt.cy, (SIZE *)NULL);
        }
    }
    else
    {
        // Convert the rc to the device space, and set of the mapping so that
        // there is a one to one mapping to device.

        // CONSIDER: It may be better performing to place the dc in MM_TEXT
        LPtoDP(hdcDraw, LPPOINT( & rc ), 2);

        GetWindowExtEx(hdcDraw, &sizeExt);
        SetViewportExtEx(hdcDraw, sizeExt.cx, sizeExt.cy, (SIZE *)NULL);
    }
#endif // !WINCE

#ifdef _MAC
	EnsureMacScrollbars(hdcDraw);
#endif

    // According to Doc. We should ignore hdcTargetDev if ptd is NULL.
    // since TextServices requires hdcTargetDev to be NULL if ptd is NULL
    // we better null it here
    //
    // NOTE(SujalP): Our code cannot survive with hdcTargetDev=NULL. It has
    // to reflect some physical device. Hence we make it reflect the ptd
    // passed in. If the ptd too is NULL then we make hdcTargetDev reflect
    // the screen (this is done inside CreateDCFromTargetDev).
    if (   NULL == ptd
        || NULL == hdcTargetDev
       )
    {
        hdcTargetDev = CreateDCFromTargetDev(ptd);
        if (!hdcTargetDev)
            RRETURN(GetLastWin32Error());
        fDeleteTargetDev = TRUE;
    }

    // Set the viewport origin to our starting point, and normalize the
    //  draw rectangle.
    ptOrg.x   += rc.left;
    ptOrg.y   += rc.top;
    rc.left    = rc.top = 0;
    rc.right  -= ptOrg.x;
    rc.bottom -= ptOrg.y;
    SetViewportOrgEx(hdcDraw, ptOrg.x, ptOrg.y, (POINT *)NULL);

    memset(&DI, 0, sizeof(DI));
    DI._dwDrawAspect = dwDrawAspect;
    DI._lindex = lindex;
    DI._pvAspect = pvAspect;
    DI._ptd = ptd;
    DI._hic = XHDC(hdcTargetDev, NULL);
    DI._hdc = XHDC(hdcDraw, NULL);
    DI._prcWBounds = prcWBounds;
    DI._dwContinue = dwContinue;
    DI._pfnContinue = pfnContinue;
    DI._fInplacePaint = prclDraw == NULL;

    /* NOTE (mikhaill) -- following six lines are removed as
       making false impression that scaling is changed here, while
       DI.CDocScaleInfo will be anyway reinitialized in CDoc::Draw().

    SIZE    size, sizeInch;

    size.cx = rc.right - rc.left;
    size.cy = rc.bottom - rc.top;
    sizeInch.cx = GetDeviceCaps(DI._hic, LOGPIXELSX);
    sizeInch.cy = GetDeviceCaps(DI._hic, LOGPIXELSY);

    DI.CDocScaleInfo::Init(size, _sizel, &sizeInch);
    */

    GetPalette(hdcDraw, &DI._fHtPalette);

    // Delegate to the other Draw method, which is overridden by derived
    // classes.

    // Inhibit OnViewChange Calls from Invalidate, as this could potentially
    // cause Draw to be called back
    CLock ViewLock(this, SERVERLOCK_VIEWCHANGE);

    hr = Draw(&DI, &rc);

    RestoreDC(hdcDraw, -1);

    if (fDeleteTargetDev)
    {
        DeleteDC(hdcTargetDev);
    }
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::DrawHighContrastBackground
//
//  Note:       Draws background for controls
//
//----------------------------------------------------------------------------

void
CServer::DrawHighContrastBackground(HDC hdc, const RECT * prc, COLORREF crBack)
{
    COLORREF crOld;

    Assert(g_fHighContrastMode);

    crOld = ::SetBkColor(hdc, crBack);
    ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, prc, 0, 0, 0);
    ::SetBkColor(hdc, crOld);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetColorSet, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method returns S_FALSE indicating the server
//              does not support this functionality.  Server's that
//              wish to support it should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetColorSet(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        LPLOGPALETTE FAR* ppColorSet)
{
    if (!ppColorSet)
        RRETURN(E_INVALIDARG);

    *ppColorSet = (LPLOGPALETTE)CoTaskMemAlloc(sizeof(LOGPAL256));
    if (*ppColorSet == NULL)
        return E_OUTOFMEMORY;

    memcpy(*ppColorSet, &g_lpHalftone, sizeof(LOGPAL256));

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetPalette, public
//
//  Synopsis:   Returns the document palette
//
//  Notes:      Returns the document palette.  This implementation is
//              doesn't cache the result from the ambient.
//              it is really expected to be overridden by the derived
//              class.
//
//---------------------------------------------------------------

HPALETTE
CServer::GetPalette(HDC hdc, BOOL *pfHtPal)
{
    CVariant var;
    HPALETTE hpal = GetAmbientPalette();

    if (hpal == NULL)
        hpal = GetDefaultPalette();

    if (hdc && hpal)
    {
        Verify(SelectPalette(hdc, hpal, TRUE));
        RealizePalette(hdc);
    }

    if (pfHtPal)
        *pfHtPal = FALSE;
        
    return hpal;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::Freeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method sets flag _fViewFrozen.
//
//              The derived class should pay attention to this flag
//              and not allow any modifications that would change
//              the current rendering.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Freeze(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DWORD FAR* pdwFreeze)
{
    if (pdwFreeze == NULL)
        RRETURN(E_INVALIDARG);

    *pdwFreeze = 0; //set out params to NULL

    _fViewFrozen = TRUE;
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Unfreeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method clears the flag _fViewFrozen.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Unfreeze(DWORD dwFreeze)
{
    _fViewFrozen = FALSE;
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetAdvise, IViewObject
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method implements an advise holder for the view
//              advise.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetAdvise(DWORD dwAspects, DWORD dwAdvf, LPADVISESINK pAdvSink)
{
    ClearInterface(&_pAdvSink);

    if (!pAdvSink)
        return S_OK;

    if ((dwAspects != DVASPECT_CONTENT) || (dwAdvf != 0))
    {
        _dwAspects = dwAspects;
        _dwAdvf = dwAdvf;
    }

    if (OK(pAdvSink->QueryInterface(IID_IAdviseSinkEx, (void **)&_pAdvSink)))
    {
        _fUseAdviseSinkEx = TRUE;
    }
    else
    {
        _fUseAdviseSinkEx = FALSE;
        _pAdvSink = pAdvSink;
        _pAdvSink->AddRef();
    }

    if (dwAdvf & ADVF_PRIMEFIRST)
        OnViewChange(dwAspects);

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetAdvise, public
//
//  Synopsis:   Method of IViewObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetAdvise(
        DWORD FAR* pdwAspects,
        DWORD FAR* pdwAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    if (pdwAspects)
        *pdwAspects = _dwAspects;

    if (pdwAdvf)
        *pdwAdvf = _dwAdvf;

    if (ppAdvSink)
    {
        *ppAdvSink = _pAdvSink;

        // COMMFIXLAJOSF : 7694
        if (_pAdvSink)
            _pAdvSink->AddRef();
    }

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetExtent, public
//
//  Synopsis:   Method of IViewObject2
//
//  Arguments:  [dwDrawAspect] -- View aspect of interest
//              [lindex]       -- Always -1
//              [ptd]          -- Target device being used
//              [lpsizel]      -- Place to put object's size
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetExtent(
        DWORD dwDrawAspect,
        LONG lindex,
        DVTARGETDEVICE* ptd,
        LPSIZEL lpsizel)
{
    //
    // Until the cache is in place we'll just forward to IOleObject's
    // implementation of this method.
    //

    RRETURN(GetExtent(dwDrawAspect, lpsizel));
}

void
CServer::SendOnViewChange(DWORD_PTR dwAspects)
{
    if (_pAdvSink && (dwAspects & _dwAspects))
    {
        _pAdvSink->OnViewChange((DWORD)dwAspects, -1);
        if (_dwAdvf & ADVF_ONLYONCE)
            SetAdvise(NULL, 0, 0);
    }

    _fViewChangePosted = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnViewChange
//
//  Synopsis:   Sends an view change notification to registered sinks.
//
//  Arguments:  [dwAspect] -- Aspect of view that changed.
//
//  Returns:    HRESULT.
//
//  History:    4-06-94   adams   Created
//
//----------------------------------------------------------------------------

void
CServer::OnViewChange(DWORD dwAspects)
{
    if (dwAspects == DVASPECT_CONTENT)
    {
        if (_pAdvSink && !_fViewChangePosted && !TestLock(SERVERLOCK_VIEWCHANGE))
        {
            HRESULT hr = GWPostMethodCall(this, ONCALL_METHOD(CServer, SendOnViewChange, sendonviewchange), dwAspects, FALSE, "CServer::SendOnViewChange");
            if (!hr)
                _fViewChangePosted = TRUE;
        }
    }
    else
    {
        SendOnViewChange(dwAspects);
    }
}


//+---------------------------------------------------------------
//
//  Member:     CServer::LoadFromStream, protected
//
//  Synopsis:   Loads the object's persistent state from a stream
//
//  Arguments:  [pStrm] -- stream to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStreamInit::Load and IPersistFile::Load when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::LoadFromStream(LPSTREAM pStrm)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SaveToStream, protected
//
//  Synopsis:   Saves the object's persistent state to a stream
//
//  Arguments:  [pStrm] -- stream to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStreamInit::Save and IPersistFile::Save when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::SaveToStream(LPSTREAM pStrm)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetStreamSizeMax, protected
//
//  Synopsis:   Returns the number of bytes required to serialize object
//
//  Notes:      This function is used in the implementation of
//              IPersistStreamInit::GetSizeMax.
//              All objects should override this method.
//
//---------------------------------------------------------------
DWORD
CServer::GetStreamSizeMax(void)
{
    return 0;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::IsDirty, public
//
//  Synopsis:   Method of IPersistStreamInit/Storage/File interface
//
//  Notes:      This method uses the dirty flag, _fDirty.
//              Objects should not set the _fDirty flag directly
//              but instead call the OnDataChange method to set the
//              flag.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::IsDirty(void)
{
    return (_lDirtyVersion ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CServer::Load, public
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Notes:      This function uses the LoadFromStream method and
//              transitions the object to the loaded state if the
//              load was successful.
//
//---------------------------------------------------------------
STDMETHODIMP
CServer::Load(LPSTREAM pStrm)
{
    RRETURN(THR(LoadFromStream(pStrm)));
}

//+---------------------------------------------------------------
//
//  Member:     CServer::Save, public
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Notes:      This method uses the SaveToStream method and
//              clears the _fDirty flag as appropriate.
//              Containers that have nonserializeable embeddings can
//              override this method and return STG_E_CANTSAVE
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Save(LPSTREAM pStrm, BOOL fClearDirty)
{
    HRESULT hr;

    if (pStrm == NULL)
    {
        hr = S_FALSE;
        // (hackhack) clear dirty bit if asked
    }
    else if (_state == OS_PASSIVE)
    {
        RRETURN(E_UNEXPECTED);
    }
    else
    {
        hr = THR(SaveToStream(pStrm));
        if (hr)
            goto Cleanup;
    }
    
    if (fClearDirty)
        _lDirtyVersion = 0;

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetSizeMax
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Notes:
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    if (pcbSize == NULL)
        RRETURN(E_INVALIDARG);

    ULISet32(*pcbSize, GetStreamSizeMax());
    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member:     CServer::InitNew
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CServer::InitNew( )
{
    HRESULT     hr = S_OK;

    // object can be loaded only once!

    if (_state != OS_PASSIVE)
        RRETURN(CO_E_ALREADYINITIALIZED);
    Assert(!_pCache);
    _fInitNewed = TRUE;
    _lDirtyVersion = MAXLONG;     // set dirty to true, as per OLE spec (frankman)

    _state = OS_LOADED;

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::LoadFromStorage, protected
//
//  Synopsis:   Loads the object's persistent state from a storage
//
//  Arguments:  [pStg] -- storage to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Load and IPersistFile::Load when
//              the file is a docfile.
//
//              This method opens a stream, "CONTENTS", and uses
//              method LoadFromStream to complete the load.
//              Servers that do more sophisticated loading will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::LoadFromStorage(LPSTORAGE pStg)
{
    HRESULT     hr;
    LPSTREAM    pStrm   = NULL;

    hr = THR(pStg->OpenStream(szContents, NULL, STGM_SRO, 0, &pStrm));
    if (hr)
        goto Cleanup;

    hr = THR(LoadFromStream(pStrm));

Cleanup:
    ReleaseInterface(pStrm);

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member: CServer::SaveToStorage
//
//  Synopsis:   Saves the object's persistent state to a storage
//
//  Arguments:  [pStg] -- storage to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Save and IPersistFile::Save when
//              the file is a docfile.
//
//              This method opens a stream, "CONTENTS", and uses
//              method SaveToStream to complete the save.
//              Servers that do more sophisticated saving will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::SaveToStorage(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    HRESULT     hr;
    LPSTREAM    pStrm   = NULL;

    hr = THR(pStg->CreateStream(
            szContents,
            STGM_SALL|STGM_CREATE,
            0L,
            0L,
            &pStrm));
    if (hr)
        goto Cleanup;

    hr = THR(SaveToStream(pStrm));

Cleanup:
    ReleaseInterface(pStrm);

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InitNew
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method transitions the object to loaded.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::InitNew(LPSTORAGE pStg)
{
    HRESULT     hr  = S_OK;

    if (pStg == NULL)
        RRETURN(E_INVALIDARG);

    // object can be loaded only once!

    if (_state != OS_PASSIVE)
        RRETURN(CO_E_ALREADYINITIALIZED);

    //  CONSIDER what's the cleanup behavior here?

    if (_pPStgCache)
    {
        hr = THR(_pPStgCache->InitNew(pStg));
        if (hr)
            goto Cleanup;
    }

    _pStg = pStg;
    pStg->AddRef();

    _fInitNewed = TRUE;
    _lDirtyVersion = MAXLONG;     // set dirty to true, as per OLE spec (frankman)

    _state = OS_LOADED;

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Load
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method loads the object using LoadFromStorage and
//              then transitions the object to loaded.
//
//              A pointer to our storage is maintained in member variable
//              _pStg.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Load(LPSTORAGE  pStg)
{
    HRESULT         hr;
    IOleCache2 *    pCache2 = NULL;
    if (pStg == NULL)
        RRETURN(E_INVALIDARG);

    //  Object can be loaded only once!

    if (_state != OS_PASSIVE)
        RRETURN(CO_E_ALREADYINITIALIZED);

    //  Do the load and move to the loaded state

    hr = THR(LoadFromStorage(pStg));
    if (hr)
        goto Cleanup;

    _pStg = pStg;
    pStg->AddRef();

    _state = OS_LOADED;

       // Don't nned to save it until the doc changes
    _lDirtyVersion = 0;

Cleanup:
    ReleaseInterface(pCache2);
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Save
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method uses SaveToStorage to write the persistent
//              state.  It also writes the full user type string to the
//              storage as is required.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Save(LPSTORAGE  pStg, BOOL fSameAsLoad)
{
    HRESULT     hr;
    CLIPFORMAT  clipfmt;
    TCHAR       achUserTypeFull[MAX_USERTYPE_LEN + 1];

    if (pStg == NULL)
        RRETURN(E_INVALIDARG);

    if (_state == OS_PASSIVE)
        RRETURN(E_UNEXPECTED);

    if (_fHandsOff || _fNoScribble)
    {
        TraceTag((tagError, "IPersistStorage::Save called in hands-off or "
                  "no-scribble mode!"));
        RRETURN(E_UNEXPECTED);
    }

    hr = THR(SaveToStorage(pStg, fSameAsLoad));
    if (hr)
        goto Cleanup;

    // Write the UserType string. We don't let this fail the operation.

    clipfmt = (ServerDesc()->_cGetFmtTable > 0) ?
                    ServerDesc()->_pGetFmtTable[0].cfFormat : 0;

    Verify(LoadString(
            GetResourceHInst(),
            IDS_USERTYPEFULL(BaseDesc()->_idrBase),
            achUserTypeFull,
            ARRAY_SIZE(achUserTypeFull)));

    WriteFmtUserTypeStg(pStg, clipfmt, achUserTypeFull);

    _fNoScribble = TRUE;
    _fSameAsLoad = fSameAsLoad;
    _lDirtyVersion = 0;

    //  CONSIDER what's our error recovery strategy here?

    if (_pPStgCache)
        hr = THR(_pPStgCache->Save(pStg, fSameAsLoad));

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SaveCompleted
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method clears the dirty flag and updates our
//              storage pointer, _pStg, if required.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SaveCompleted(LPSTORAGE  pStg)
{
    HRESULT hr  = S_OK;

    if (_fHandsOff == TRUE && NULL == pStg)
    {
        //
        // We are in hands off mode and we get didn't get the expected storage.
        //
        TraceTagEx((tagCServer, TAG_NONEWLINE, "CServer::SaveCompleted:"));
        TraceTagEx((tagCServer, TAG_NONAME|TAG_NONEWLINE, "We are in hands off mode and "));
        TraceTagEx((tagCServer, TAG_NONAME, "we get didn't get a storage"));
        RRETURN(E_UNEXPECTED);
    }

    if (_fHandsOff == FALSE && _fNoScribble == FALSE)
    {
        //
        // SaveCompleted is being called in a "normal" state i.e.  without
        // HandsOffStorage() or Save() having been called.
        //
        RRETURN(E_UNEXPECTED);
    }

    if (pStg != NULL)
    {
        if (_pStg != NULL)
        {
            HandsOffStorage();
        }

        Assert(_pStg == NULL);

        _pStg = pStg;
        _pStg->AddRef();
    }

    if (pStg != NULL || _fSameAsLoad)
    {
        if (_fNoScribble)
        {
            _lDirtyVersion = 0;     // clear our dirty flag

            if (_pOleAdviseHolder)
                _pOleAdviseHolder->SendOnSave();
        }
    }

    if (_pPStgCache)
        hr = THR(_pPStgCache->SaveCompleted(pStg));

    _fSameAsLoad = FALSE;
    _fNoScribble = FALSE;       // we are out of NO-SCRIBBLE mode
    _fHandsOff   = FALSE;       // we are out of HANDS-OFF mode

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::HandsOffStorage
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method releases the storage we are holding on to.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::HandsOffStorage(void)
{
    HRESULT     hr  = S_OK;

    ClearInterface(&_pStg);

    if (_pPStgCache)
        hr = THR(_pPStgCache->HandsOffStorage());

    _fHandsOff = TRUE;

    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//
//  Member:     LoadFromBag
//
//  Synopsis:   Load object state from a property bag
//
//-----------------------------------------------------------------------------

HRESULT
CServer::LoadFromBag(
    LPPROPERTYBAG   pBag,
    LPERRORLOG      pErrLog)
{
    RRETURN(S_OK);
}



//+----------------------------------------------------------------------------
//
//  Member:     SaveToBag
//
//  Synopsis:   Save object state to a property bag
//
//-----------------------------------------------------------------------------

HRESULT
CServer::SaveToBag(
    LPPROPERTYBAG   pBag,
    BOOL            fSaveAllProperties)
{
    RRETURN(S_OK);
}



//+----------------------------------------------------------------------------
//
//  Member:     CServer::Load
//
//  Synopsis:   Method of IPersistPropertyBag interface
//
//  Notes:      This method uses the LoadFromBag method
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CServer::Load(
    LPPROPERTYBAG   pBag,
    LPERRORLOG      pErrLog)
{
    HRESULT hr;

    if (pBag == NULL)
        RRETURN(E_INVALIDARG);

    // object can be loaded only once!
    if (_state != OS_PASSIVE)
        RRETURN(E_UNEXPECTED);

    hr = THR(LoadFromBag(pBag, pErrLog));
    if (hr)
        goto Cleanup;

    _state = OS_LOADED;

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//
//  Member:     CServer::Save
//
//  Synopsis:   Method of IPersistPropertyBag interface
//
//  Notes:      This method uses the SaveToBag method and
//              clears the _fDirty flag as appropriate.
//              Containers that have nonserializeable embeddings can
//              override this method and return STG_E_CANTSAVE
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CServer::Save(
    LPPROPERTYBAG   pBag,
    BOOL            fClearDirty,
    BOOL            fSaveAllProperties)
{
    HRESULT hr;

    if (pBag == NULL)
        RRETURN(E_INVALIDARG);

    if (_state == OS_PASSIVE)
        RRETURN(E_UNEXPECTED);

    hr = THR(SaveToBag(pBag, fSaveAllProperties));
    if (hr)
        goto Cleanup;

    if (fClearDirty)
        _lDirtyVersion = 0;

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetRect
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------


STDMETHODIMP
CServer::GetRect(DWORD dwAspect, LPRECTL prcl)
{
    HRESULT hr              = OLE_E_BLANK;
    DWORD   dwViewStatus    = 0L;

    TraceTag((tagCServer, "CServer::GetRect"));

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
        hr = S_OK;
        break;

    case DVASPECT_TRANSPARENT:
        IGNORE_HR(GetViewStatus(&dwViewStatus));
        if (dwViewStatus & VIEWSTATUS_DVASPECTTRANSPARENT)
            hr = S_OK;
#if DBG == 1
        else
            Assert(0 && "CServer::GetRect -- DVASPECTTRANSPARENT not supported");
#endif
        break;

    case DVASPECT_OPAQUE:
        IGNORE_HR(GetViewStatus(&dwViewStatus));
        if (dwViewStatus & VIEWSTATUS_DVASPECTOPAQUE)
            hr = S_OK;
#if DBG == 1
        else
            Assert(0 && "CServer::GetRect -- DVASPECTOPAQUE not supported");
#endif
        break;
    }

    if (hr == S_OK)
    {
        SetRectl(prcl, 0, 0, _sizel.cx, _sizel.cy);
    }
#if DBG == 1
    else
        Assert(0 && "Unhandled value");
#endif

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetViewStatus
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetViewStatus(DWORD *pdwStatus)
{
    TraceTag((tagCServer, "CServer::GetViewStatus"));
    *pdwStatus = ServerDesc()->_dwViewStatus;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::QueryHitPoint
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::QueryHitPoint(
        DWORD dwAspect,
        LPCRECT prcBounds,
        POINT ptLoc,
        LONG lCloseHint,
        DWORD *pHitResult)
{
    HRESULT hr;

    TraceTag((tagCServer, "CServer::QueryHitPoint"));

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
    {
        *pHitResult = (PtInRect(prcBounds, ptLoc)) ? 
                        HITRESULT_HIT : 
                        HITRESULT_OUTSIDE;
        hr = S_OK;
        break;
    }

    default:
        *pHitResult = 0;
        hr = E_NOTIMPL;
        break;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::QueryHitRect
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::QueryHitRect(DWORD dwAspect, LPCRECT pRectBounds,
                      LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult)
{
    HRESULT hr;

    TraceTag((tagCServer, "CServer::QueryHitRect"));

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
    {
        *pHitResult = HITRESULT_HIT;
        hr = S_OK;
        break;
    }

    default:
        *pHitResult = 0;
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetNaturalExtent
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetNaturalExtent(
    DWORD dwAspect, LONG lindex, DVTARGETDEVICE * ptd,
    HDC hicTargetDev, DVEXTENTINFO * pExtentInfo, LPSIZEL psizel )
{
    TraceTag((tagCServer, "CServer::GetNaturalExtent"));
    // CONSIDER: Should this routine deal with aspects other than content?
    return E_NOTIMPL;
}


#ifdef _MAC
//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureMacScrollbars
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

void CServer::EnsureMacScrollbars(HDC hdc)
{
	if ( !_hVertScroll )
		_hVertScroll = CreateMacScrollbar(hdc);
	if ( !_hHorzScroll )
		_hHorzScroll = CreateMacScrollbar(hdc);	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\undo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       undo.cxx
//
//  Contents:   Implementation of Undo classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_QI_IMPL_H
#define X_QI_IMPL_H
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif


DeclareTag(tagUndo, "Undo", "Form Undo");
DeclareTag(tagAllowParentlessUndo, "Undo", "Allow parentless undo")
DeclareTag(tagNoUndo, "Undo", "Disable undo")
MtDefine(Undo, Mem, "Undo")
MtDefine(UndoStringDescription, Undo, "Undo Description String")
MtDefine(CUndoManager, Undo, "CUndoManager")
MtDefine(CParentUndoUnit, Undo, "CParentUndoUnit")
MtDefine(CParentUndo, Undo, "CParentUndo")
MtDefine(CUndoPropChange, Undo, "CUndoPropChange")
MtDefine(CUndoUnitAry_pv, Undo, "CUndoUnitAry::_pv")

CDummyUndoManager      g_DummyUndoMgr;    // No ctor, dtor or member data
CBlockedParentUnit     g_BlockedUnit;


// Private guid for undo manager - {FABDA060-28C7-11d2-B0A7-00C04FA34D84}
const CLSID CLSID_CUndoManager = { 0xfabda060, 0x28c7, 0x11d2, { 0xb0, 0xa7, 0x0, 0xc0, 0x4f, 0xa3, 0x4d, 0x84 } };

static HRESULT 
SafeUndoAryRelease( CUndoUnitAry * pAry, int indexReleaseFrom, int indexReleaseTo)
{
    HRESULT         hr = S_OK;
    CUndoUnitAry    aryRelease;
    int             c;

    c = indexReleaseTo - indexReleaseFrom + 1;

    if (c <= 0)
        goto Cleanup;

    Assert( c <= pAry->Size() );

    hr = aryRelease.Grow( c );
    if (hr)
        goto Cleanup;

    // Copy the part of the array that we want to release
    {
        IOleUndoUnit ** ppUndoFrom = ((IOleUndoUnit**)(*pAry)) + indexReleaseFrom;
        IOleUndoUnit ** ppUndoTo = aryRelease;

        for ( ; c > 0; c--, ppUndoFrom++, ppUndoTo++ )
            *ppUndoTo = *ppUndoFrom;
    }

    // Remove the pointers from the original array
    pAry->DeleteMultiple( indexReleaseFrom, indexReleaseTo );

    // Release all of the pointers in the copied array
    aryRelease.ReleaseAll();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBlockedParentUnit::Close, public
//
//  Synopsis:   Implements the close method for the dummy blocked parent
//              unit.
//
//  Arguments:  [pPUU]    -- Pointer to object being closed.
//              [fCommit] -- ignored
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBlockedParentUnit::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{
    //
    // We're always blocked, so we only handle that case.
    //
    if (pPUU == (IOleParentUndoUnit*)this)
    {
        return S_FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::CreateUndoManager, public
//
//  Synopsis:   Creates the undo manager if it hasn't already been created.
//              Does not query our container for the undo service.
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::CreateUndoManager(void)
{
    if (_pUndoMgr == &g_DummyUndoMgr)
    {
        TraceTag((tagUndo, "CServer::CreateUndoManager -- creating manager."));

        _pUndoMgr = new CUndoManager();
        if (!_pUndoMgr)
        {
            _pUndoMgr = &g_DummyUndoMgr;
            RRETURN(E_OUTOFMEMORY);;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::BlockNewUndoUnits, public
//
//  Synopsis:   Causes any new undo units that might be created to be blocked.
//
//  Arguments:  (none)
//
//  Returns:    An HRESULT and a cookie. If the cookie is zero then you don't
//              have to call UnblockNewUndoUnits. All other values are
//              undefined and UnblockNewUndoUnits must be called.
//
//----------------------------------------------------------------------------

HRESULT
CBase::BlockNewUndoUnits(DWORD *pdwCookie)
{
    //
    // Note that QueryCreateUndo _must_ checked for blocked undo units so
    // that nested calls to this method work properly!
    //
    if (QueryCreateUndo(FALSE))
    {
        *pdwCookie = 1;
        RRETURN(UndoManager()->Open(&g_BlockedUnit));
    }

    *pdwCookie = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::UnblockNewUndoUnits, public
//
//  Synopsis:   Unblocks undo units that were blocked by calling
//              BlockNewUndoUnits.
//
//----------------------------------------------------------------------------

void
CBase::UnblockNewUndoUnits(DWORD dwCookie)
{
    if (dwCookie)
    {
        IGNORE_HR(UndoManager()->Close(&g_BlockedUnit, FALSE));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::QueryCreateUndo, public
//
//  Synopsis:   Indicates whether an undo unit should be created or not.
//
//  Arguments:  [fRequiresParent] -- If TRUE, the return value will be FALSE
//                                   unless an undo unit is open on the
//                                   stack.
//
//  Returns:    TRUE if an undo unit should be created, FALSE if not.
//
//  Notes:      If [fRequiresParent] is TRUE, and there is no open unit on
//              the undo stack, then the undo stack will be flushed.
//
//----------------------------------------------------------------------------

BOOL
CBase::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = TRUE */, BOOL * pfTreeSync /* = NULL */)
{
    HRESULT              hr;
    DWORD                dwUndoState;
    IOleUndoManager * pUM;

    pUM = UndoManager();
    Assert(pUM);

    if( pfTreeSync )
        *pfTreeSync = FALSE;

    if (pUM == &g_DummyUndoMgr WHEN_DBG(|| IsTagEnabled(tagNoUndo)))
        return FALSE;

    hr = pUM->GetOpenParentState(&dwUndoState);
    if (FAILED(hr))
        goto Error;

    if (hr == S_OK)
    {
        //
        // There's an open unit on the stack.
        //
        if ((dwUndoState & UAS_NOPARENTENABLE) && fRequiresParent)
        {
            goto Error;
        }
        else if (dwUndoState & UAS_BLOCKED)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }

    if (!fRequiresParent || TLS( fAllowParentLessPropChanges )
        WHEN_DBG( || IsTagEnabled(tagAllowParentlessUndo) ) )
        return TRUE;

    //
    // The unit needs a parent, but there isn't one, so clear the undo
    // stack.
    //
Error:
    if( fDirtyChange )
        pUM->DiscardFrom(NULL);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::OpenParentUnit, public
//
//  Synopsis:   Opens a parent unit which does nothing but contain other
//              units and puts it on the undo stack.
//
//  Arguments:  [pBase] -- Owning object
//              [uiID]  -- ID for description
//
//  Returns:    Open parent, may be NULL in certain cases, but this is not
//              an error condition.
//
//  Notes:      The caller should not release the interface returned by
//              this function.  It will be released by CloseParentUnit.
//
//----------------------------------------------------------------------------

CParentUndoUnit *
CBase::OpenParentUnit(CBase * pBase, UINT uiID, TCHAR * pchDescription /* = NULL */)
{
    CParentUndoUnit *      pCPUU     = NULL;
    IOleUndoManager *  pUM;
    DWORD                    dwState;
    HRESULT                  hr;

    TraceTag((tagUndo, "CBase::OpenParentUnit"));

    pUM = UndoManager();
    Assert(pUM);

    if (pUM == &g_DummyUndoMgr)
        return NULL;

    //
    // If there is no undo manager or an already open parent unit then
    // just return NULL because we don't need to create a parent object.
    //
    hr = pUM->GetOpenParentState(&dwState);
    if (FAILED(hr))
        return NULL;

    if ((hr == S_FALSE) ||
        ((dwState & UAS_NOPARENTENABLE) && !(dwState & UAS_BLOCKED)))
    {
        //
        // There's no open object on the stack or it's non-enabling, so put
        // an enabling parent on and return it.
        // 
        if (pchDescription)
            pCPUU = new CParentUndoUnit(pBase, pchDescription);
        else
            pCPUU = new CParentUndoUnit(pBase, uiID);

        if (pCPUU)
        {
            if (FAILED(pUM->Open(pCPUU)))
            {
                ClearInterface(&pCPUU);
            }
        }
    }

    return pCPUU;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::CloseParentUnit, public
//
//  Synopsis:   Closes a parent unit opened with OpenParentUnit.
//
//  Arguments:  [pCPUU]    -- Unit returned from OpenParentUnit.
//              [hrCommit] -- If S_OK, then the unit is committed.
//                            Otherwise it's released and not added to the
//                            stack.
//
//  Returns:    HRESULT
//
//  Notes:      If the [pCPUU] object is empty (has no children) then it is
//              not committed.
//
//----------------------------------------------------------------------------

HRESULT
CBase::CloseParentUnit(CParentUndoUnit * pCPUU, HRESULT hrCommit)
{
    HRESULT              hr;
    IOleUndoManager * pUM;

    if (!pCPUU)
        return S_OK;

    TraceTag((tagUndo, "CBase::CloseParentUnit"));

    pUM = UndoManager();
    Assert(pUM);

    //
    // Don't commit if the unit is empty.  Later, if needed, we can add a
    // flag to this function which disables this behavior if we ever get any
    // parent units that affect state and don't need children to be useful.
    //
    if (pCPUU->_aryUndo.Size() == 0)
    {
        hrCommit = S_FALSE;
    }

    hr = pUM->Close(pCPUU, (hrCommit == S_OK) ? TRUE : FALSE);
    if (hr == S_FALSE)
    {
        //
        // The open unit was most likely thrown away by a call to
        // DiscardFrom, so we ignore that situation.
        //
        hr = S_OK;
    }

    pCPUU->Release();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::CreatePropChangeUndo, public
//
//  Synopsis:   Creates a property change undo object for simple property
//              types.
//
//  Arguments:  [dispidProp] -- Dispid of the property
//              [wpiType]    -- Type of the property (must match the
//                              in-memory size of the property).
//              [dwProp]     -- Current (old) value of property.
//              [ppUndo]     -- Undo object returned here. Can be NULL. The
//                              returned value may be NULL in non-error cases.
//
//  Returns:    HRESULT
//
//  Notes:
//
// If [wpiType] is WPI_CSTRING, then [dwProp] should be a pointer to a CStr.
//
// If [ppUndo] is NULL, the current value of the property is stored and the
// unit is given to the undo manager.
//
// If [ppUndo] is not NULL, the current value of the property is stored but
// the unit is not given to the Undo Manager.  [ppUndo] is filled in with a
// pointer to the unit, and the caller is responsible for adding the unit
// to the undo stack by calling Add() on the undo manager, and then releasing
// the unit.  The unit does not have to be given to the undo manager (in
// the case of a later error for example), but the returned object should
// always be released if it was not NULL.  The value returned in [ppUndo] is
// NULL if an error occurs or if there is no open unit on the undo stack.
//
//----------------------------------------------------------------------------

HRESULT
CBase::CreatePropChangeUndo(DISPID             dispidProp,
                            VARIANT *          pVar,
                            CUndoPropChange ** ppUndo)
{
    HRESULT           hr;
    CUndoPropChange * pUndo;

    if (ppUndo)
        *ppUndo = NULL;

    if (!QueryCreateUndo(TRUE))
        return S_OK;

    TraceTag((tagUndo, "CBase::CreatePropChangeUndo creating an object."));

    pUndo = new CUndoPropChange(this, IDS_UNDOPROPCHANGE);
    if (!pUndo)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pUndo->Init(dispidProp, pVar));
    if (hr)
        goto Error;

    if (!ppUndo)
    {
        IOleUndoManager *pUM = UndoManager();

        Assert(pUM);

        hr = THR(pUM->Add(pUndo));

        ReleaseInterface(pUndo);
    }
    else
    {
        *ppUndo = pUndo;
    }

Cleanup:
    RRETURN(hr);

Error:
    ReleaseInterface(pUndo);
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::QueryStatusUndoRedo
//
//  Synopsis:   Helper function for QueryStatus(). Check if in our current
//              state we suport these commands.
//
//--------------------------------------------------------------------------

HRESULT
CBase::QueryStatusUndoRedo(BOOL fUndo, MSOCMD * pcmd, MSOCMDTEXT * pcmdtext)
{
    BSTR        bstr = NULL;
    HRESULT     hr;

    // Get the Undo/Redo state.
    if (fUndo)
        hr = THR_NOTRACE(UndoManager()->GetLastUndoDescription(&bstr));
    else
        hr = THR_NOTRACE(UndoManager()->GetLastRedoDescription(&bstr));

    // Return the command state.
    pcmd->cmdf = hr ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;

    // Return the command text if requested.
    if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_NAME)
    {

        // TODO - This code needs to be supported on the MAC. (rodc)
        if (hr)
        {
            pcmdtext->cwActual = LoadString(
                    GetResourceHInst(),
                    fUndo ? IDS_CANTUNDO : IDS_CANTREDO,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf);
        }
        else
        {
            hr = Format(
                    0,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf,
                    MAKEINTRESOURCE(fUndo ? IDS_UNDO : IDS_REDO),
                    bstr);
            if (!hr)
                pcmdtext->cwActual = _tcslen(pcmdtext->rgwz);
        }
    }

    if (bstr)
        FormsFreeString(bstr);

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CBase::EditUndo
//
//  Synopsis:   Performs an Undo
//
//---------------------------------------------------------------

HRESULT
CBase::EditUndo()
{
    TraceTag((tagUndo, "CBase::EditUndo"));

    HRESULT hr = THR(UndoManager()->UndoTo(NULL));

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CForm::EditRedo
//
//  Synopsis:   Performs a Redo
//
//---------------------------------------------------------------

HRESULT
CBase::EditRedo()
{
    TraceTag((tagUndo, "CBase::EditRedo"));

    HRESULT hr = THR(UndoManager()->RedoTo(NULL));

    RRETURN(hr);
}






//+---------------------------------------------------------------------------
//
//  CComposeUndo Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::CComposeUndo, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CComposeUndo::CComposeUndo()
{
    Assert(_pPUUOpen   == NULL);
    Assert(_fDisabled  == FALSE);
    Assert(_UndoState  == UNDO_BASESTATE);
    Assert(_BlockCount == 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::~CComposeUndo, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CComposeUndo::~CComposeUndo()
{
    IGNORE_HR(SafeUndoAryRelease(&_aryUndo, 0, _aryUndo.Size()-1));
    IGNORE_HR(SafeUndoAryRelease(&_aryRedo, 0, _aryRedo.Size()-1));

    ReleaseInterface(_pPUUOpen);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::GetTopUndoUnit, protected
//
//  Synopsis:   Returns the undo unit at the top of the stack.
//
//----------------------------------------------------------------------------

IOleUndoUnit *
CComposeUndo::GetTopUndoUnit()
{
    int c = _aryUndo.Size();

    if (c)
        return _aryUndo[c-1];

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::GetTopRedoUnit, protected
//
//  Synopsis:   Returns the redo unit at the top of the stack.
//
//----------------------------------------------------------------------------

IOleUndoUnit *
CComposeUndo::GetTopRedoUnit()
{
    int c = _aryRedo.Size();

    if (c)
        return _aryRedo[c-1];

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::Open, public
//
//  Synopsis:   Adds a parent undo unit, and leaves it open. All further
//              calls to the parent undo methods are forwarded to the object
//              until it is closed.
//
//  Arguments:  [pUU] -- Object to add and leave open.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::Open(IOleParentUndoUnit *pPUU)
{
    TraceTag((tagUndo, "CComposeUndo::Open,  this=%p", this));

    if (_fDisabled || (_BlockCount > 0))
        return S_OK;

    if (!pPUU)
    {
        RRETURN(E_INVALIDARG);
    }

    if (_pPUUOpen)
    {
        RRETURN(_pPUUOpen->Open(pPUU));
    }

    ReplaceInterface(&_pPUUOpen, pPUU);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::Close, public
//
//  Synopsis:   Closes an open undo unit, not necessarily the one we have
//              open directly.
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::Close(IOleParentUndoUnit * pPUU, BOOL fCommit)
{
    HRESULT hr;

    TraceTag((tagUndo, "CComposeUndo::Close,  this=%p", this));

    if (_fDisabled ||
        ((_BlockCount > 0) && (pPUU != (IOleParentUndoUnit*)this)))
    {
        return S_OK;
    }

    if ((!_pPUUOpen) || (_BlockCount > 0))
    {
        Assert(_NonEnableCount == 0);

        hr = OnClose();
        if (hr)
            RRETURN(hr);

        return S_FALSE;
    }

    hr = THR(_pPUUOpen->Close(pPUU, fCommit));

    if (FAILED(hr) || (hr == S_OK))
        RRETURN(hr);

    Assert(hr == S_FALSE);
    // Close returned S_FALSE

    if (_pPUUOpen != pPUU)
        RRETURN(E_INVALIDARG);

    if (fCommit)
    {
        hr = AddUnit(_pPUUOpen);
    }

    ClearInterface(&_pPUUOpen);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::OnNextAdd, public
//
//  Synopsis:   Notifies most recent child of new unit
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CComposeUndo::OnNextAdd()
{
    if (_pPUUOpen)
        IGNORE_HR( _pPUUOpen->OnNextAdd() ); // must return S_OK

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::Add, public
//
//  Synopsis:   Adds an undo unit to the stack directly. Doesn't leave it
//              open.
//
//  Arguments:  [pUU] -- Unit to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::Add(IOleUndoUnit *pUU)
{
    HRESULT hr;

    TraceTag((tagUndo, "CComposeUndo::Add,  this=%p", this));

    if (_fDisabled || (_BlockCount > 0))
        return S_OK;

    if (!pUU)
    {
        RRETURN(E_INVALIDARG);
    }

    if (_pPUUOpen)
    {
        RRETURN(_pPUUOpen->Add(pUU));
    }

    hr = AddUnit(pUU);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::DoTo, protected
//
//  Synopsis:   Helper method that calls do on an array of objects
//
//  Arguments:  [pUM]         -- Pointer to undo manager to pass to units
//              [paryUnit]    -- Undo or Redo stack
//              [pUU]         -- Object to undo or redo to.
//              [fDoRollback] -- If TRUE, rollback will be attempted on an
//                               error. Noone but the undo manager should
//                               pass TRUE for this.
//
//  Returns:    HRESULT
//
//  Notes:      Parent units can use the _fUnitSucceeded flag to determine
//              whether or not they should commit the unit they put on the
//              opposite stack.  If _fUnitSucceeded is TRUE after calling
//              this function, then the unit should commit itself.  If
//              FALSE, the unit does not have to commit itself.  In either
//              case any error code returned by this function should be
//              propagated to the caller.
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::DoTo(IOleUndoManager *            pUM,
                   CUndoUnitAry *               paryUnit,
                   IOleUndoUnit *               pUU,
                   BOOL                         fDoRollback)
{
    IOleUndoUnit **         ppUA;
    CUndoUnitAry            aryCopy;
    int                     iUnit;
    HRESULT                 hr;

    TraceTag((tagUndo, "CComposeUndo::DoTo"));

    _fUnitSucceeded = FALSE;
    _fRollbackNeeded = FALSE;

    if (_fDisabled || _pPUUOpen)
        RRETURN(E_UNEXPECTED);

    Assert(paryUnit);

    if (paryUnit->Size() == 0)
        return S_OK;

    hr = THR(aryCopy.Copy(*paryUnit, FALSE));
    if (hr)
        RRETURN(hr);

    if (pUU)
    {
        iUnit = aryCopy.Find(pUU);
        if (iUnit == -1)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else
    {
        iUnit = aryCopy.Size() - 1;
        pUU = aryCopy[iUnit];
    }

    //
    // Delete the units from the original array before we call Do() on those
    // units in case they do something naughty like call DiscardFrom which
    // would Release them.
    //
    paryUnit->DeleteMultiple(iUnit, paryUnit->Size() - 1);

    //
    // Make sure the copy of the array has only the units in it we're
    // processing.
    //
    if (iUnit > 0)
    {
        aryCopy.DeleteMultiple(0, iUnit - 1);
    }

    for(ppUA = &aryCopy.Item(aryCopy.Size() - 1);
        ; // Infinite
        ppUA--)
    {
        hr = THR((*ppUA)->Do(pUM));
        if (hr)
            goto Error;

        _fUnitSucceeded = TRUE;

        if (*ppUA == pUU)
            break;
    }

    Assert(!_pPUUOpen);

Cleanup:
    if (hr == E_ABORT)
    {
        hr = E_FAIL;
    }

Cleanup2:
    aryCopy.ReleaseAll();

    RRETURN(hr);

Error:
    if (fDoRollback)
    {
        HRESULT hr2 = S_OK;

        // Using a local because the calls to Do() may change the state
        // of this flag.
        BOOL    fRollbackNeeded = _fRollbackNeeded;

        if (fRollbackNeeded)
        {
            TraceTag((tagUndo, "Undo failed! Attempting rollback..."));

            if (_UndoState == UNDO_UNDOSTATE)
            {
                hr2 = THR(GetTopRedoUnit()->Do(NULL));
            }
            else
            {
                hr2 = THR(GetTopUndoUnit()->Do(NULL));
            }
        }

        Assert(!_pPUUOpen);

        _aryUndo.ReleaseAll();
        _aryRedo.ReleaseAll();
        ClearInterface(&_pPUUOpen); // For safety in retail builds only.

        if (fRollbackNeeded)
        {
            if (hr2)
            {
                TraceTag((tagUndo, "Rollback failed! Bailing out..."));

                hr = E_ABORT;
                goto Cleanup2;
            }
            else
                TraceTag((tagUndo, "Rollback succeeded! Returning error %hr", hr));
        }
    }
#if DBG == 1
    else
    {
        if (!fDoRollback)
        {
            TraceTag((tagUndo, "Undo failed for parent unit!"));
        }
        else if (!_fRollbackNeeded)
        {
            TraceTag((tagUndo, "Undo failed but rollback not needed!"));
        }
    }
#endif

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::AddUnit, protected
//
//  Synopsis:   Adds a new unit to the appropriate stack, no questions asked.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::AddUnit(IOleUndoUnit *pUU)
{
    HRESULT hr;

    if (_UndoState == UNDO_UNDOSTATE)
    {
        if (_aryRedo.Size() > 0)
        {
            GetTopRedoUnit()->OnNextAdd();
        }

        Assert(!_fRespectMaxEntries || _aryRedo.Size() <= MAX_STACK_ENTRIES);

        hr = THR(_aryRedo.Append(pUU));
        if (hr)
            goto Cleanup;

        pUU->AddRef();

        if (_aryRedo.Size() > MAX_STACK_ENTRIES && _fRespectMaxEntries )
        {
            _aryRedo.ReleaseAndDelete(0);
        }
    }
    else
    {
        if (_aryUndo.Size() > 0)
        {
            GetTopUndoUnit()->OnNextAdd();
        }

        Assert(!_fRespectMaxEntries || _aryUndo.Size() <= MAX_STACK_ENTRIES);

        hr = THR(_aryUndo.Append(pUU));
        if (hr)
            goto Cleanup;

        pUU->AddRef();

        if (_aryUndo.Size() > MAX_STACK_ENTRIES && _fRespectMaxEntries)
        {
            _aryUndo.ReleaseAndDelete(0);
        }

        if (_UndoState == UNDO_BASESTATE)
        {
            _aryRedo.ReleaseAll();
        }
    }

    _fRollbackNeeded = TRUE;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::FindChild, public
//
//  Synopsis:   Searches the children in a given stack for a undo unit.
//
//  Arguments:  [aryUnit] -- Array to look in
//              [pUU]     -- Unit to look for
//
//  Returns:    The index of the element in [aryUnit] that contains [pUU].
//
//----------------------------------------------------------------------------

int
CComposeUndo::FindChild(CUndoUnitAry &aryUnit, IOleUndoUnit *pUU)
{
    IOleParentUndoUnit * pPUU;
    IOleUndoUnit **      ppUA;
    HRESULT              hr     = S_FALSE;
    int                  i;

    for (i = aryUnit.Size(), ppUA = aryUnit;
         i;
         i--, ppUA++)
    {
        if ((*ppUA)->QueryInterface(IID_IOleParentUndoUnit, (LPVOID*)&pPUU) == S_OK)
        {
            hr = pPUU->FindUnit(pUU);

            ReleaseInterface(pPUU);
        }

        if (hr == S_OK)
            break;
    }

    if (i == 0)
        i = -1;
    else
        i = ppUA - (IOleUndoUnit **)aryUnit;

    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::SetBlockedState, public
//
//  Synopsis:   Sets the blocked state of the parent unit. The unit
//              maintains a counter.
//
//  Arguments:  [fBlocked] -- If TRUE, the block count is incremented.
//                            Otherwise it's decremented.
//
//  Notes:      If the block count is non-zero, the unit is blocked.
//
//----------------------------------------------------------------------------

void
CComposeUndo::SetBlockedState(BOOL fBlocked)
{
    if (fBlocked)
    {
        Assert(!_pPUUOpen);

        Assert(_BlockCount < MAX_BLOCK_COUNT);
        _BlockCount++;
    }
    else
    {
        Assert(_BlockCount > 0);
        _BlockCount--;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::SetNonEnableState, public
//
//  Synopsis:   Sets the non-parent-enable state of the parent unit.  The
//              unit maintains a counter.
//
//  Arguments:  [fNonEnable] -- If TRUE, the non-enable count is incremented.
//                              Otherwise it's decremented.
//
//  Notes:      If the non-enable count is non-zero, the unit returns
//              UAS_NOPARENTENABLE from GetParentState.
//
//----------------------------------------------------------------------------

void
CComposeUndo::SetNonEnableState(BOOL fNonEnable)
{
    if (fNonEnable)
    {
        Assert(_NonEnableCount < MAX_BLOCK_COUNT);
        _NonEnableCount++;
    }
    else
    {
        Assert(_NonEnableCount > 0);
        _NonEnableCount--;
    }
}

//+---------------------------------------------------------------------------
//
//  CUndoManager Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::CUndoManager, public
//
//  Synopsis:   CUndoManager ctor
//
//----------------------------------------------------------------------------

CUndoManager::CUndoManager()
{
    _ulRefs = 1;
    _fRespectMaxEntries = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::QueryInterface, public
//
//  Synopsis:   Implements QueryInterface for the undo manager
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::QueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    if (iid == CLSID_CUndoManager)
    {
        *ppv = LPVOID(this);
        return S_OK;
    }

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IOleUndoManager)
    }

    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetOpenParentState, public
//
//  Synopsis:   Indicates whether there's an open unit, and if so whether
//              or not it's blocked.
//
//  Arguments:  [pdwState] -- Place to fill in state.
//
//  Returns:    S_OK for an open object, S_FALSE for not.
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetOpenParentState(DWORD * pdwState)
{
    TraceTag((tagUndo, "CUndoManager::GetOpenParentState"));

    if (_fDisabled)
    {
        *pdwState = UAS_BLOCKED;
        return S_OK;
    }

    *pdwState = 0;

    if (_pPUUOpen)
    {
        return _pPUUOpen->GetParentState(pdwState);
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::DiscardFrom, public
//
//  Synopsis:   Removes the specified undo unit and all units below it
//              from the undo stack. Checks child undo units for the given
//              unit and deletes the topmost parent of the given unit.
//
//  Arguments:  [pUU] -- Unit to remove. If NULL, the entire undo and redo
//                       stacks are cleared.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::DiscardFrom(IOleUndoUnit * pUU)
{
    TraceTag((tagUndo, "CUndoManager::DiscardFrom"));

    HRESULT hr = S_OK;

    if (_fDisabled)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pUU)
    {
        int indexUndo;
        int indexRedo = -1;

        //
        // The most common scenario is for the given unit to exist somewhere
        // in the top-level undo or redo stack. So, we search those first
        // before checking children.
        //
        indexUndo = _aryUndo.Find(pUU);
        if (indexUndo == -1)
        {
            indexRedo = _aryRedo.Find(pUU);
            if (indexRedo == -1)
            {
                indexUndo = FindChild(_aryUndo, pUU);
                if (indexUndo == -1)
                {
                    indexRedo = FindChild(_aryRedo, pUU);
                }
            }
        }

        if ((indexUndo == -1) && (indexRedo == -1))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (indexUndo != -1)
        {
            hr = SafeUndoAryRelease( &_aryUndo, 0, indexUndo );
            if (hr)
                goto Cleanup;
        }
        else
        {
            Assert(indexRedo != -1);
            hr = SafeUndoAryRelease( &_aryRedo, 0, indexRedo );
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = SafeUndoAryRelease( &_aryUndo, 0, _aryUndo.Size() - 1 );
        if (hr)
            goto Cleanup;

        hr = SafeUndoAryRelease( &_aryRedo, 0, _aryRedo.Size() - 1 );
        if (hr)
            goto Cleanup;

        if (_pPUUOpen)
        {
            ClearInterface(&_pPUUOpen);
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::UndoTo, public
//
//  Synopsis:   Performs undo operations up to the given unit on the stack.
//
//  Arguments:  [pUU] -- Undo unit to undo up to. If NULL undo the last one.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::UndoTo(IOleUndoUnit *pUU)
{
    HRESULT hr;

    TraceTag((tagUndo, "CUndoManager::UndoTo"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    _UndoState = UNDO_UNDOSTATE;

    hr = DoTo(this, &_aryUndo, pUU, TRUE);

    _UndoState = UNDO_BASESTATE;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::RedoTo, public
//
//  Synopsis:   Performs redo operations up to the given unit on the stack.
//
//  Arguments:  [pUU] -- Redo unit to redo up to. If NULL redo the last one.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::RedoTo(IOleUndoUnit *pUU)
{
    HRESULT hr;

    TraceTag((tagUndo, "CUndoManager::RedoTo"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    _UndoState = UNDO_REDOSTATE;

    hr = DoTo(this, &_aryRedo, pUU, TRUE);

    _UndoState = UNDO_BASESTATE;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::EnumUndoable, public
//
//  Synopsis:   Returns an enumerator that enumerates the undo stack.
//
//  Arguments:  [ppEnum] -- Place to put enumerator.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::EnumUndoable(IEnumOleUndoUnits **ppEnum)
{
    TraceTag((tagUndo, "CUndoManager::EnumUndoable"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    RRETURN(_aryUndo.EnumElements(IID_IEnumOleUndoUnits,
                                  (void**)ppEnum,
                                  TRUE, TRUE, TRUE));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::EnumRedoable, public
//
//  Synopsis:   Returns an enumerator that enumerates the redo stack.
//
//  Arguments:  [ppEnum] -- Place to put enumerator.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::EnumRedoable(IEnumOleUndoUnits **ppEnum)
{
    TraceTag((tagUndo, "CUndoManager::EnumRedoable"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    RRETURN(_aryRedo.EnumElements(IID_IEnumOleUndoUnits,
                                  (void**)ppEnum,
                                  TRUE, TRUE, TRUE));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetLastUndoDescription, public
//
//  Synopsis:   Returns the description of the top-most undo unit
//
//  Arguments:  [pbstr] -- Place to put description.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetLastUndoDescription(BSTR *pbstr)
{
    TraceTag((tagUndo, "CUndoManager::GetLastUndoDescription"));

    RRETURN(GetDescr(GetTopUndoUnit(), pbstr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetLastRedoDescription, public
//
//  Synopsis:   Returns the description of the top-most redo unit
//
//  Arguments:  [pstr] -- Place to put description. Should be freed with
//                        the OLE task allocator.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetLastRedoDescription(BSTR *pbstr)
{
    TraceTag((tagUndo, "CUndoManager::GetLastRedoDescription"));

    RRETURN(GetDescr(GetTopRedoUnit(), pbstr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::Enable, public
//
//  Synopsis:   Enables or disables the undo manager.
//
//  Arguments:  [fEnable] -- If TRUE the undo manager is enabled.
//
//  Returns:    HRESULT
//
//  Notes:      The manager cannot be disabled when it is in the middle of
//              an undo or redo, or if there is an open unit.
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::Enable(BOOL fEnable)
{
    TraceTag((tagUndo, "CUndoManager::Enable(%s)", fEnable ? "TRUE" : "FALSE"));

    //
    // Can't disable in the middle of an undo or redo, or when an unit
    // is open.
    //
    if ((_UndoState > UNDO_BASESTATE) || _pPUUOpen)
    {
        RRETURN(E_UNEXPECTED);
    }

    if (fEnable)
    {
        _fDisabled = FALSE;
    }
    else
    {
        DiscardFrom(NULL);
        _fDisabled = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetDescr, protected
//
//  Synopsis:   Helper method for GetLast{Un|Re}doDescription
//
//  Arguments:  [pUU]   -- Unit to get description
//              [pbstr] -- Place to put it
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetDescr(IOleUndoUnit *pUU, BSTR *pbstr)
{
    *pbstr = NULL;

    if (pUU == NULL)
        RRETURN(E_FAIL);

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    RRETURN(pUU->GetDescription(pbstr));
}

//+---------------------------------------------------------------------------
//
//  CUndoUnit Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnit::CUndoUnit, public
//
//  Synopsis:   CUndoUnit ctor
//
//  Effects:    Saves member data.
//
//  Arguments:  [pBase]      -- Owner Class
//              [uiStringID] -- String ID of name. Must be a valid resource ID.
//
//  Notes:      [uiStringID] should be unique for each undo class since it is
//              used by GetUnitType() to identify the undo unit.
//
//----------------------------------------------------------------------------

CUndoUnit::CUndoUnit(CBase * pBase, UINT uiStringID)
{
    _pBase   = pBase;
    _uiResID = uiStringID;
    _pchDescription = NULL;
}


CUndoUnit::CUndoUnit(CBase * pBase, TCHAR * pchDescription )
{
    _pBase   = pBase;
    MemAllocString( Mt(UndoStringDescription), pchDescription, &_pchDescription );
}

CUndoUnit::~CUndoUnit()
{
    if( _pchDescription )
        MemFreeString(_pchDescription);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnit::GetDescription, public
//
//  Synopsis:   Gets the description for this undo unit.
//
//  Arguments:  [pbstr] -- Place to put description
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoUnit::GetDescription(BSTR *pbstr)
{
    TCHAR szName[FORMS_BUFLEN + 1]; // String for name

    szName[0] = '\0';

    Assert(pbstr);

    if (_pchDescription)
    {
        RRETURN( FormsAllocString( _pchDescription, pbstr ) );
    }
    else
    {
        if (TW32(0, LoadString(GetResourceHInst(), _uiResID, szName, FORMS_BUFLEN)) == 0)
            RRETURN(GetLastWin32Error());
        RRETURN(FormsAllocString(szName, pbstr));
    }

    
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnit::GetUnitType, public
//
//  Synopsis:   Returns the type of this undo unit.
//
//  Arguments:  [pclsid] -- Place to put CLSID (caller allocated).
//              [plID]   -- Place to put identifier.
//
//  Returns:    HRESULT
//
//  Notes:      The classid returned is the form's classid, and the integer
//              is the resource identifier given in the constructor. This
//              information is meaningful only to the form.
//
//----------------------------------------------------------------------------

HRESULT
CUndoUnit::GetUnitType(CLSID *pclsid, LONG *plID)
{
    Assert(pclsid && plID);

    if (_pBase)
    {
        *pclsid = *(_pBase->BaseDesc()->_pclsid);
        *plID = _uiResID;
    }
    else
    {
        *pclsid = CLSID_NULL;
        *plID   = 0;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CUndoUnitBase Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnitBase::CUndoUnitBase, public
//
//  Synopsis:   CUndoUnitBase ctor
//
//  Effects:    Saves member data.
//
//  Arguments:  [pBase]      -- Owner class
//              [uiStringID] -- String ID of name. Must be a valid resource ID.
//
//  Notes:      [uiStringID] should be unique for each undo class since it is
//              used by GetUnitType() to identify the undo unit.
//
//----------------------------------------------------------------------------

CUndoUnitBase::CUndoUnitBase(CBase * pBase, UINT uiStringID)
    : CUndoUnit(pBase, uiStringID)
{
    _ulRefs = 1;

    // We are an undo if we in the base state or in the redo state
    // currently.  i.e. we are not in the undo state
    _fUndo = TLS(nUndoState) != UNDO_UNDOSTATE;
}


HRESULT CUndoUnitBase::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr;
    THREADSTATE * pts = GetThreadState();

    // Do should not be called recursively!
    Assert( TLS(nUndoState) == UNDO_BASESTATE );

    pts->nUndoState = _fUndo ? UNDO_UNDOSTATE : UNDO_REDOSTATE;

    // call the derived class
    hr = PrivateDo( pUndoManager );

    pts->nUndoState = UNDO_BASESTATE;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnitBase::QueryInterface, public
//
//----------------------------------------------------------------------------

HRESULT
CUndoUnitBase::QueryInterface(REFIID iid, LPVOID *ppv)
{
    *ppv = NULL;

    switch(iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IOleUndoUnit)
    }

    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CParentUnitBase Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::CParentUnitBase, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CParentUnitBase::CParentUnitBase(CBase * pBase, UINT uiStringID)
    : CUndoUnit(pBase, uiStringID)
{
    _ulRefs  = 1;
}


CParentUnitBase::CParentUnitBase(CBase * pBase, BSTR bstrDescription)
    : CUndoUnit(pBase, bstrDescription)
{
    _ulRefs  = 1;
}
//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::~CParentUnitBase, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CParentUnitBase::~CParentUnitBase()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::QueryInterface, public
//
//----------------------------------------------------------------------------

HRESULT
CParentUnitBase::QueryInterface(REFIID iid, LPVOID *ppv)
{
    *ppv = NULL;

    switch(iid.Data1)
    {
        QI_INHERITS(this,  IUnknown)
        QI_INHERITS(this,  IOleParentUndoUnit)
        QI_INHERITS2(this, IOleUndoUnit, IOleParentUndoUnit)
    }

    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::FindUnit, public
//
//  Synopsis:   Indicates if the given unit is in our undo stack or the stack
//              of one of our children. Doesn't check the current open object.
//
//  Arguments:  [pUU] -- Unit to find
//
//  Returns:    TRUE if we found it.
//
//----------------------------------------------------------------------------

HRESULT
CParentUnitBase::FindUnit(IOleUndoUnit *pUU)
{
    int                      i;

    TraceTag((tagUndo, "CParentUnitBase::FindUnit"));

    if (!pUU)
        RRETURN(E_INVALIDARG);

    Assert(_UndoState == UNDO_BASESTATE);

    i = _aryUndo.Find(pUU);
    if (i != -1)
        return S_OK;

    i = FindChild(_aryUndo, pUU);
    if (i != -1)
        return S_OK;

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::GetParentState, public
//
//  Synopsis:   Indicates whether there's an open unit, and if so whether
//              or not it's blocked.
//
//  Arguments:  [pdwState] -- Place to fill in state.
//
//  Returns:    S_OK always, unless disabled.
//
//----------------------------------------------------------------------------

HRESULT
CParentUnitBase::GetParentState(DWORD * pdwState)
{
    if (!pdwState)
        RRETURN(E_INVALIDARG);

    *pdwState = 0;

    Assert(_UndoState == UNDO_BASESTATE);

    if (_BlockCount > 0)
    {
        Assert(!_pPUUOpen);

        *pdwState = UAS_BLOCKED;
    }
    else if (_pPUUOpen)
    {
        return _pPUUOpen->GetParentState(pdwState);
    }

    if (_NonEnableCount > 0)
    {
        *pdwState |= UAS_NOPARENTENABLE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CParentUndoUnit Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   CParentUndoUnit::CParentUndoUnit
//
//  Synopsis:   CParentUndoUnit ctor
//
//----------------------------------------------------------------------------

CParentUndoUnit::CParentUndoUnit(CBase * pBase, UINT uiStringID)
    : CParentUnitBase(pBase, uiStringID)
{
    TraceTag((tagUndo, "Creating CParentUndoUnit"));
}


CParentUndoUnit::CParentUndoUnit(CBase * pBase, BSTR bstrDescription)
    : CParentUnitBase(pBase, bstrDescription)
{
    TraceTag((tagUndo, "Creating CParentUndoUnit"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoUnit::Do, public
//
//  Synopsis:   Calls undo on our contained undo object.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CParentUndoUnit::Do(IOleUndoManager *pUndoManager)
{
    HRESULT        hr    = S_OK;

    TraceTag((tagUndo, "CParentUndoUnit::Do"));

    if (_aryUndo.Size() == 0)
        return S_OK;

    //
    // Put ourself on the undo manager's Redo stack.
    //
    if (pUndoManager)
    {
        hr = THR(pUndoManager->Open(this));
        if (hr)
            goto Cleanup;
    }

    //
    // Call Do() on all the units. This call makes a copy of the array and
    // removes the units from _aryUndo before making any calls to Do().
    //
    hr = THR(DoTo(pUndoManager, &_aryUndo, _aryUndo[0], FALSE));

    //
    // _fUnitSucceeded will be TRUE after calling DoTo only if at least
    // one of our contained units was successful. In this case we need to
    // commit ourselves, even if an error occurred.
    //

    if (pUndoManager)
    {
        HRESULT hr2;
        BOOL    fCommit = TRUE;

        //
        // If we are empty or none of our contained units succeeded then do
        // not commit ourselves.
        //
        if (!_fUnitSucceeded || (_aryUndo.Size() == 0))
        {
            TraceTag((tagUndo, "Not committing parent unit to redo stack."));
            fCommit = FALSE;
        }

        hr2 = THR(pUndoManager->Close(this, fCommit));
        //
        // Preserve the HRESULT from the call to DoTo() if it failed.
        //
        if (!hr && FAILED(hr2))
        {
            hr = hr2;
        }
    }

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CParentUndo Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndo::Start, public
//
//  Synopsis:   Create the undo unit and open it
//
//----------------------------------------------------------------------------
HRESULT
CParentUndo::Start(UINT uiStringID)
{
    _puu = _pBase->OpenParentUnit( _pBase, uiStringID );

    return S_OK;
}

HRESULT
CParentUndo::Start(TCHAR * pchDescription)
{
    _puu = _pBase->OpenParentUnit( _pBase, 0, pchDescription );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndo::Finish, public
//
//  Synopsis:   Close the parent unit
//
//----------------------------------------------------------------------------
HRESULT
CParentUndo::Finish(HRESULT hrCommit)
{
    HRESULT hr;

    hr = THR( _pBase->CloseParentUnit( _puu, hrCommit ) ); 
    if( hr )
        goto Cleanup;

Cleanup:
    _puu = NULL;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  CUndoPropChange Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::CUndoPropChange, public
//
//  Synopsis:   Object ctor
//
//----------------------------------------------------------------------------

CUndoPropChange::CUndoPropChange(CBase * pBase,
                                 UINT    uiStringID)
    : CUndoUnitBase(pBase, uiStringID)
{
    Assert(pBase);

    TraceTag((tagUndo, "CUndoPropChange ctor"));

    pBase->PrivateAddRef();

    VariantInit(&_varData);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::~CUndoPropChange, public
//
//  Synopsis:   Undo unit dtor
//
//----------------------------------------------------------------------------

CUndoPropChange::~CUndoPropChange()
{
    TraceTag((tagUndo, "CUndoPropChange dtor"));

    _pBase->PrivateRelease();
    
    VariantClear(&_varData);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::Init, public
//
//  Synopsis:   Initializes the undo unit for an integer property that is
//              changing.  The function takes ownership of the variant
//              passed in.
//
//  Arguments:  [dispidProp] -- Dispid of property.
//              [pvar] -- the old value, as a variant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoPropChange::Init(DISPID dispidProp, VARIANT* pvar)
{
    TraceTag((tagUndo, "CUndoPropChange::Init"));

    HRESULT hr = S_OK;

    // Take ownership of the variant
    _varData = *pvar;
    VariantInit( pvar );

    _dispid  = dispidProp;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::PrivateDo, public
//
//  Synopsis:   Performs the undo of the property change.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoPropChange::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT       hr;
    IDispatch   * pDisp = NULL;
    DWORD         dwCookie = 0;

    TraceTag((tagUndo, "CUndoPropChange::Do"));

    hr = THR(_pBase->PunkOuter()->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp));
    if (hr)
        goto Cleanup;

    //
    // The redo unit should be put on the stack in this call to Invoke()
    // unless we need to disable it.
    //
    if (!pUndoManager)
    {
        _pBase->BlockNewUndoUnits(&dwCookie);
    }

    // NOTE: might want to have different way to specify unset method
    if (V_VT(&_varData) == VT_NULL)
    {
        PROPERTYDESC * pPropDesc = NULL;

        // No propdesc's for expandos, and we don't need them, anyway.
        if( !_pBase->IsExpandoDISPID( _dispid ) )
        {
            hr = THR(_pBase->FindPropDescFromDispID(_dispid, &pPropDesc, NULL, NULL));
            if (hr)
                goto Cleanup;
        }

        _pBase->removeAttributeDispid( _dispid, pPropDesc );
    }
    else
    {
        hr = THR(SetDispProp(
                       pDisp,
                       _dispid,
                       g_lcidUserDefault,
                       &_varData,
                       NULL));
    }

    if (!pUndoManager)
    {
        _pBase->UnblockNewUndoUnits(dwCookie);
    }

Cleanup:
    ReleaseInterface(pDisp);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\sctrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  Contents:   CServer implementation (partial).
//
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifdef _MAC
#ifndef X_MACCONTROLS_H_
#define X_MACCONTROLS_H_
#include "maccontrols.h"
#endif
#endif

DeclareTag(tagOleState, "Server", "OLE state transitions")
PerfDbgExtern(tagPerfWatch)
ExternTag(tagDisableLockAR);

BEGIN_TEAROFF_TABLE(CServer, IOleInPlaceObjectWindowless)
    TEAROFF_METHOD(CServer, GetWindow, getwindow, (HWND*))
    TEAROFF_METHOD(CServer, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    TEAROFF_METHOD(CServer, InPlaceDeactivate, inplacedeactivate, ())
    TEAROFF_METHOD(CServer, UIDeactivate, uideactivate, ())
    TEAROFF_METHOD(CServer, SetObjectRects, setobjectrects, (LPCOLERECT lprcPosRect, LPCOLERECT lprcClipRect))
    TEAROFF_METHOD(CServer, ReactivateAndUndo, reactivateandundo, ())
    TEAROFF_METHOD(CServer, OnWindowMessage, onwindowmessage, (UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult))
    TEAROFF_METHOD(CServer, GetDropTarget, getdroptarget, (IDropTarget** ppDropTarget))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleDocumentView)
    TEAROFF_METHOD(CServer, SetInPlaceSite, setinplacesite, (LPOLEINPLACESITE pIPSite))
    TEAROFF_METHOD(CServer, GetInPlaceSite, getinplacesite, (LPOLEINPLACESITE* ppIPSite))
    TEAROFF_METHOD(CServer, GetDocument, getdocument, (IUnknown** ppUnk))
    TEAROFF_METHOD(CServer, SetRect, setrect, (LPRECT lprcView))
    TEAROFF_METHOD(CServer, GetRect, getrect, (LPRECT lprcView))
    TEAROFF_METHOD(CServer, SetRectComplex, setrectcomplex, (LPRECT lprcView, LPRECT lprcHScroll, LPRECT lprcVScroll, LPRECT lprcSizeBox))
    TEAROFF_METHOD(CServer, Show, show, (BOOL fShow))
    TEAROFF_METHOD(CServer, UIActivate, uiactivate, (BOOL fActivate))
    TEAROFF_METHOD(CServer, Open, open, ())
    TEAROFF_METHOD(CServer, CloseView, closeview, (DWORD dwReserved))
    TEAROFF_METHOD(CServer, SaveViewState, saveviewstate, (IStream* pStm))
    TEAROFF_METHOD(CServer, ApplyViewState, applyviewstate, (IStream* pStm))
    TEAROFF_METHOD(CServer, Clone, clone, (IOleInPlaceSite* pNewIPSite, IOleDocumentView** ppNewView))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleInPlaceActiveObject)
    TEAROFF_METHOD(CServer, GetWindow, getwindow, (HWND*))
    TEAROFF_METHOD(CServer, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    TEAROFF_METHOD(CServer, TranslateAccelerator, translateaccelerator, (LPMSG lpmsg))
    TEAROFF_METHOD(CServer, OnFrameWindowActivate, onframewindowactivate, (BOOL fActivate))
    TEAROFF_METHOD(CServer, OnDocWindowActivate, ondocwindowactivate, (BOOL fActivate))
    TEAROFF_METHOD(CServer, ResizeBorder, resizeborder, ( LPCOLERECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow))
    TEAROFF_METHOD(CServer, EnableModeless, enablemodeless, (BOOL fEnable))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleObject)
    TEAROFF_METHOD(CServer, SetClientSite, setclientsite, (LPOLECLIENTSITE pClientSite))
    TEAROFF_METHOD(CServer, GetClientSite, getclientsite, (LPOLECLIENTSITE FAR* ppClientSite))
    TEAROFF_METHOD(CServer, SetHostNames, sethostnames, (LPCTSTR szContainerApp, LPCTSTR szContainerObj))
    TEAROFF_METHOD(CServer, Close, close, (DWORD dwSaveOption))
    TEAROFF_METHOD(CServer, SetMoniker, setmoniker, (DWORD dwWhichMoniker, LPMONIKER pmk))
    TEAROFF_METHOD(CServer, GetMoniker, getmoniker, (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk))
    TEAROFF_METHOD(CServer, InitFromData, initfromdata, (LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved))
    TEAROFF_METHOD(CServer, GetClipboardData, getclipboarddata, (DWORD dwReserved, LPDATAOBJECT * ppDataObject))
    TEAROFF_METHOD(CServer, DoVerb, doverb, (LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCOLERECT lprcPosRect))
    TEAROFF_METHOD(CServer, EnumVerbs, enumverbs, (LPENUMOLEVERB FAR* ppenumOleVerb))
    TEAROFF_METHOD(CServer, Update, update, ())
    TEAROFF_METHOD(CServer, IsUpToDate, isuptodate, ())
    TEAROFF_METHOD(CServer, GetUserClassID, getuserclassid, (CLSID FAR* pClsid))
    TEAROFF_METHOD(CServer, GetUserType, getusertype, (DWORD dwFormOfType, LPTSTR FAR* pszUserType))
    TEAROFF_METHOD(CServer, SetExtent, setextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CServer, GetExtent, getextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CServer, Advise, advise, (IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection))
    TEAROFF_METHOD(CServer, Unadvise, unadvise, (DWORD dwConnection))
    TEAROFF_METHOD(CServer, EnumAdvise, enumadvise, (LPENUMSTATDATA FAR* ppenumAdvise))
    TEAROFF_METHOD(CServer, GetMiscStatus, getmiscstatus, (DWORD dwAspect, DWORD FAR* pdwStatus))
    TEAROFF_METHOD(CServer, SetColorScheme, setcolorscheme, (LPLOGPALETTE lpLogpal))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleControl)
    TEAROFF_METHOD(CServer, GetControlInfo, getcontrolinfo, (CONTROLINFO * pCI))
    TEAROFF_METHOD(CServer, OnMnemonic, onmnemonic, (LPMSG pMsg))
    TEAROFF_METHOD(CServer, OnAmbientPropertyChange, onambientpropertychange, (DISPID dispid))
    TEAROFF_METHOD(CServer, FreezeEvents, freezeevents, (BOOL fFreeze))
END_TEAROFF_TABLE()

#ifdef FANCY_CONNECTION_STUFF
BEGIN_TEAROFF_TABLE(CServer, IRunnableObject)
    TEAROFF_METHOD(CServer, GetRunningClass, getrunningclass, (LPCLSID lpclsid))
    TEAROFF_METHOD(CServer, Run, run, (LPBINDCTX pbc))
    TEAROFF_METHOD_(CServer, IsRunning, isrunning, BOOL, ())
    TEAROFF_METHOD(CServer, LockRunning, lockrunning, (BOOL fLock, BOOL fLastUnlockCloses))
    TEAROFF_METHOD(CServer, SetContainedObject, setcontainedobject, (BOOL fContained))
END_TEAROFF_TABLE()
#endif

#ifdef FANCY_CONNECTION_STUFF
BEGIN_TEAROFF_TABLE(CServer, IExternalConnection)
    TEAROFF_METHOD_(CServer, AddConnection, addconnection, DWORD, (DWORD extconn, DWORD reserved))
    TEAROFF_METHOD_(CServer, ReleaseConnection, releaseconnection, DWORD, (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses))
END_TEAROFF_TABLE()
#endif

BEGIN_TEAROFF_TABLE(CServer, IPersistStreamInit)
    TEAROFF_METHOD(CServer, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CServer, IsDirty, isdirty, ())
    TEAROFF_METHOD(CServer, Load, LOAD, (LPSTREAM pStm))
    TEAROFF_METHOD(CServer, Save, SAVE, (LPSTREAM pStm, BOOL fClearDirty))
    TEAROFF_METHOD(CServer, GetSizeMax, GETSIZEMAX, (ULARGE_INTEGER FAR * pcbSize))
    TEAROFF_METHOD(CServer, InitNew, initnew, ())
END_TEAROFF_TABLE()

//BEGIN_TEAROFF_TABLE(CServer, IPersistStorage)
//    TEAROFF_METHOD(GetClassID, (LPCLSID lpClassID))
//    TEAROFF_METHOD(IsDirty, ())
//    TEAROFF_METHOD(InitNew, (LPSTORAGE  pStg))
//    TEAROFF_METHOD(Load, (LPSTORAGE  pStg))
//    TEAROFF_METHOD(Save, (LPSTORAGE  pStgSave, BOOL fSameAsLoad))
//    TEAROFF_METHOD(SaveCompleted, (LPSTORAGE  pStgNew))
//    TEAROFF_METHOD(HandsOffStorage, ())
//END_TEAROFF_TABLE()

//BEGIN_TEAROFF_TABLE(CServer, IPersistPropertyBag)
//    TEAROFF_METHOD(GetClassID, (LPCLSID lpClassID))
//    TEAROFF_METHOD(InitNew, ())
//    TEAROFF_METHOD(Load, (LPPROPERTYBAG pBag, LPERRORLOG pErrLog))
//    TEAROFF_METHOD(Save, (LPPROPERTYBAG pBag, BOOL fClearDirty, BOOL fSaveAllProperties))
//END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IDataObject)
    TEAROFF_METHOD(CServer, GetData, getdata, (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium))
    TEAROFF_METHOD(CServer, GetDataHere, getdatahere, (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium))
    TEAROFF_METHOD(CServer, QueryGetData, querygetdata, (LPFORMATETC pformatetc))
    TEAROFF_METHOD(CServer, GetCanonicalFormatEtc, getcanonicalformatetc, (LPFORMATETC pformatetc, LPFORMATETC pformatetcOut))
    TEAROFF_METHOD(CServer, SetData, setdata, (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium, BOOL fRelease))
    TEAROFF_METHOD(CServer, EnumFormatEtc, enumformatetc, (DWORD dwDirection, LPENUMFORMATETC FAR* ppenum))
    TEAROFF_METHOD(CServer, DAdvise, dadvise, (LPFORMATETC pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD FAR* pdwConnection))
    TEAROFF_METHOD(CServer, DUnadvise, dunadvise, (DWORD dwConnection))
    TEAROFF_METHOD(CServer, EnumDAdvise, enumdadvise, (LPENUMSTATDATA FAR* ppenumAdvise))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleDocument)
    TEAROFF_METHOD(CServer, CreateView, createview, (IOleInPlaceSite * pIPSite, IStream * pStm, DWORD dwReserved, IOleDocumentView ** ppView))
    TEAROFF_METHOD(CServer, GetDocMiscStatus, getdocmiscstatus, (DWORD * pdwStatus))
    TEAROFF_METHOD(CServer, EnumViews, enumviews, (IEnumOleDocumentViews ** ppEnumViews, IOleDocumentView ** ppView))
END_TEAROFF_TABLE()

//BEGIN_TEAROFF_TABLE(CServer, IQuickActivate)
//    TEAROFF_METHOD(QuickActivate, (QACONTAINER *pqacontainer, QACONTROL *pqacontrol))
//    TEAROFF_METHOD(SetContentExtent, (LPSIZEL))
//    TEAROFF_METHOD(GetContentExtent, (LPSIZEL))
//END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleCache2)
 TEAROFF_METHOD(CServer, Cache, cache, (FORMATETC *pformatetc, DWORD advf, DWORD *pdwConnection))
 TEAROFF_METHOD(CServer, Uncache, uncache, (DWORD dwConnection))
 TEAROFF_METHOD(CServer, EnumCache, enumcache, (IEnumSTATDATA  **ppenumSTATDATA))
 TEAROFF_METHOD(CServer, InitCache, initcache, (IDataObject *pDataObject))
 // SetData renamed to SetDataCache to avoid conflict with IDataObject::SetData
 TEAROFF_METHOD(CServer, SetDataCache, setdatacache, (FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease))
 TEAROFF_METHOD(CServer, UpdateCache, updatecache, (LPDATAOBJECT pDataObject, DWORD grfUpdf, LPVOID pReserved))
 TEAROFF_METHOD(CServer, DiscardCache, discardcache, (DWORD dwDiscardOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IPointerInactive)
    TEAROFF_METHOD(CServer, GetActivationPolicy, getactivationpolicy, (DWORD * pdwPolicy))
    TEAROFF_METHOD(CServer, OnInactiveMouseMove, oninactivemousemove, (LPCRECT pRectBounds, long x, long y, DWORD grfKeyState))
    TEAROFF_METHOD(CServer, OnInactiveSetCursor, oninactivesetcursor, (LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IPerPropertyBrowsing)
    TEAROFF_METHOD(CServer, GetDisplayString, getdisplaystring, (DISPID dispid, BSTR * lpbstr))
    TEAROFF_METHOD(CServer, MapPropertyToPage, mappropertytopage, (DISPID dispid, LPCLSID lpclsid))
    TEAROFF_METHOD(CServer, GetPredefinedStrings, getpredefinedstrings, (DISPID dispid, CALPOLESTR * lpcaStringsOut, CADWORD FAR* lpcaCookiesOut))
    TEAROFF_METHOD(CServer, GetPredefinedValue, getpredefinedvalue, (DISPID dispid, DWORD dwCookie, VARIANT * lpvarOut))
END_TEAROFF_TABLE()


//+---------------------------------------------------------------
//
//  Member:     CServer::CServer
//
//  Synopsis:   Constructor for CServer object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

CServer::CServer(IUnknown *pUnkOuter) : CBase()
{
    TraceTag((tagCServer, "constructing CServer"));

    IncrementObjectCount(&_dwObjCnt);

    _pUnkOuter  = pUnkOuter ? pUnkOuter : PunkInner();

    _state = OS_PASSIVE;
    _fUserMode = TRUE;

#ifndef NO_EDIT
    Assert(!_pUndoMgr);

    _pUndoMgr = &g_DummyUndoMgr;
#endif // NO_EDIT

    _dwAspects = DVASPECT_CONTENT;

    _sizel.cx = _sizel.cy = 1;

}

//+---------------------------------------------------------------
//
//  Member:     CServer::~CServer
//
//  Synopsis:   Destructor for the CServer object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It ensure the object
//              is in a passive state and releases the data/view and inplace
//              subobjects objects.
//
//---------------------------------------------------------------

CServer::~CServer(void)
{
    //  Release interface pointers and strings

    // Delete here just in case we created it without going inplace.
    delete _pInPlace;
    _pInPlace = NULL;

    ReleaseInterface(_pClientSite);
    ReleaseInterface(_pAdvSink);
    ReleaseInterface(_pStg);
#ifndef NO_EDIT
    ReleaseInterface(_pUndoMgr);
#endif // NO_EDIT

    ReleaseInterface(_pOleAdviseHolder);
    ReleaseInterface(_pDataAdviseHolder);
    ReleaseInterface(_pCache);
    ReleaseInterface(_pPStgCache);
    ReleaseInterface(_pViewObjectCache);
    ReleaseInterface(_pPictureMouse);

#ifdef _MAC
	DestroyMacScrollbar(_hVertScroll);
	DestroyMacScrollbar(_hHorzScroll);
#endif

    DecrementObjectCount(&_dwObjCnt);

    TraceTag((tagCServer, "destructed CServer"));
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::Passivate
//
//  Synopsis:   Per CBase.
//
//----------------------------------------------------------------------------

void
CServer::Passivate()
{
    //  Containers are not required to call IOleObject::Close on
    //    objects; containers are allowed to just release all pointers
    //    to an embedded object.  This means that the last reference
    //    to an object can disappear while the object is still in
    //    the OS_RUNNING state.  So, we demote it if necessary.

    Assert(_state <= OS_RUNNING);
    if (_state > OS_LOADED)
    {
        TransitionTo(OS_LOADED);
    }

#ifndef NO_EDIT
    ClearInterface(&_pUndoMgr);

    _pUndoMgr = &g_DummyUndoMgr;
#endif // NO_EDIT


    CBase::Passivate();
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::PrivateQueryInterface, public
//
//  Synopsis:   QueryInterface on the private unknown for CServer
//
//  Arguments:  [riid] -- Interface to return
//              [ppv]  -- New interface returned here
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IViewObjectEx)
        QI_INHERITS2(this, IViewObject, IViewObjectEx)
        QI_INHERITS2(this, IViewObject2, IViewObjectEx)
        QI_TEAROFF(this, IOleObject, _pUnkOuter)
        QI_TEAROFF(this, IOleControl, _pUnkOuter)
        QI_TEAROFF((CBase *)this, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo2, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF((CBase *)this, ISpecifyPropertyPages, _pUnkOuter)
#ifdef FANCY_CONNECTION_STUFF
        QI_TEAROFF(this, IRunnableObject, _pUnkOuter)
        QI_TEAROFF(this, IExternalConnection, _pUnkOuter)
#endif
        QI_TEAROFF(this, IDataObject, _pUnkOuter)
        QI_TEAROFF(this, IOleDocument, _pUnkOuter)
        QI_TEAROFF(this, IOleCache2, _pUnkOuter)
        QI_TEAROFF2(this, IOleCache, IOleCache2, _pUnkOuter)
        QI_TEAROFF((CBase *)this, IOleCommandTarget, _pUnkOuter)
        QI_TEAROFF(this, IPointerInactive, _pUnkOuter)
        QI_TEAROFF(this, ISupportErrorInfo, _pUnkOuter)
        QI_TEAROFF(this, IPerPropertyBrowsing, _pUnkOuter)
        QI_TEAROFF2(this, IOleWindow, IOleInPlaceObjectWindowless, _pUnkOuter)
        QI_TEAROFF2(this, IOleInPlaceObject, IOleInPlaceObjectWindowless, _pUnkOuter)
        QI_TEAROFF(this, IOleInPlaceObjectWindowless, _pUnkOuter)
        QI_TEAROFF(this, IOleInPlaceActiveObject, _pUnkOuter)
        QI_TEAROFF(this, IOleDocumentView, _pUnkOuter)

        default:
            if (iid == IID_IConnectionPointContainer)
            {
                *((IConnectionPointContainer **)ppv) =
                        new CConnectionPointContainer(this, NULL);

                if (!*ppv)
                    RRETURN(E_OUTOFMEMORY);
            }
            else if (((BaseDesc()->_piidDispinterface && iid == *(BaseDesc()->_piidDispinterface)) ||
                (iid == IID_IDispatch)) &&
                (ServerDesc()->_ibItfPrimary != 0))
            {
                *ppv = (IUnknown *) ((BYTE *) this + ServerDesc()->_ibItfPrimary);
            }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    DbgTrackItf(iid, "CServer", FALSE, ppv);

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::TransitionTo, public
//
//  Synopsis:   Drives the transition of the object from one state to another
//
//  Arguments:  [state] -- the desired resulting state of the object
//
//  Returns:    Success iff the transition completed successfully.  On failure
//              the object will be in the original or some intermediate,
//              but consistent, state.
//
//  Notes:      There are eight direct state transitions.  These are:
//              between the passive and loaded states, between the
//              loaded and inplace states, between the inplace and U.I. active
//              states, and between the loaded and opened states.
//              Each of these direct transitions has an overridable method
//              that effects it.  The TransitionTo function implements
//              transitions between any two arbitrary states by calling
//              these direct transition methods in the proper order.
//
//---------------------------------------------------------------

HRESULT
CServer::TransitionTo(OLE_SERVER_STATE state, LPMSG lpmsg)
{
    PerfDbgLog2(tagPerfWatch, this, "+CServer::TransitionTo %s --> %s", DebugOleStateName(_state), DebugOleStateName(state));

    HRESULT hr = S_OK;

    //  Our objects are not arbitrarily reentrant; specifically,
    //    during TransitionTo, reentrancy to other state transition
    //    functions is only allowed during the various
    //    On[InPlace/UI][Activate/Deactivate] notifications.

    if (TestLock(SERVERLOCK_TRANSITION))
        RRETURN(E_UNEXPECTED);
    //
    //  CLock takes care of blocking transitions and
    //    stabilizing the reference count.
    //

    CLock Lock(this, SERVERLOCK_TRANSITION);

    //  Note that support for the OPEN state is being removed
    //    from the base classes

    Assert(state >= OS_LOADED && state <= OS_UIACTIVE);
    Assert(_state >= OS_PASSIVE && _state <= OS_UIACTIVE);

    // trace tag output
    TraceTag((tagOleState,
                    "%08lX Transition from %s to %s",
                    this,
                    DebugOleStateName(_state),
                    DebugOleStateName(state)));
    
    //  Loop until we've reached the target state.  Some of the
    //    transitions include callbacks to the container, where we
    //    allow the container to make a reentrant call to TransitionTo.
    //    If the state doesn't match our immediate (one-hop) target,
    //    then we stop trying, under the assumption that someone else
    //    has transitioned us to a more urgent target.
    //
    //  + Transitions which do not have reentrant callbacks have
    //    asserts that either an error occurred, or else we're in
    //    the right state
    //
    //  + Transitions with callbacks exit (with success) if after
    //    the transition the object is in an unexpected state

    while (State() != state && !hr)
    {
        switch (_state)
        {
        case OS_PASSIVE:
            PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (PassiveToLoaded)");
            hr = THR(PassiveToLoaded());
            PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (PassiveToLoaded)");
            Assert(hr || _state == OS_LOADED);
            break;

        case OS_LOADED:
            PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (LoadedToRunning)");
            hr = THR(LoadedToRunning());
            PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (LoadedToRunning)");
            Assert(hr || _state == OS_RUNNING);
            break;

        case OS_RUNNING:
            switch (state)
            {
            case OS_LOADED:
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (RunningToLoaded)");
                hr = THR(RunningToLoaded());
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (RunningToLoaded)");
                Assert(hr || _state == OS_LOADED);
                break;

            case OS_INPLACE:
            case OS_UIACTIVE:
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (RunningToInPlace)");
                hr = THR(RunningToInPlace(lpmsg));
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (RunningToInPlace)");
                if (_state != OS_INPLACE)
                    goto StopTrying;
                break;

            }
            break;

        case OS_INPLACE:
            switch (state)
            {
            case OS_UIACTIVE:
                if (!RequestUIActivate())
                {
                    hr = E_FAIL;
                    goto StopTrying;
                }
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (InPlaceToUIActive)");
                hr = THR(InPlaceToUIActive(lpmsg));
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (InPlaceToUIActive)");
                if (_state != OS_UIACTIVE)
                    goto StopTrying;
                break;

            default:
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (InPlaceToRunning)");
                hr = THR(InPlaceToRunning());
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (InPlaceToRunning)");
                if (_state != OS_RUNNING)
                    goto StopTrying;
                break;
            }
            break;

        case OS_UIACTIVE:
            PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (UIActiveToInPlace)");
            hr = THR(UIActiveToInPlace());
            PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (UIActiveToInPlace)");
            if (_state != OS_INPLACE)
                goto StopTrying;
            break;

        }
    }

StopTrying:

    PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo");
    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::PassiveToLoaded, protected
//
//  Synopsis:   Effects the direct passive to loaded state transition
//
//  Returns:    Success iff the object is in the loaded state.  On failure
//              the object will be in a consistent passive state.
//
//  Notes:      The base class does not do any processing on this transition.
//
//---------------------------------------------------------------

HRESULT
CServer::PassiveToLoaded(void)
{
    _state = OS_LOADED;
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::LoadedToRunning, protected
//
//  Synopsis:   Effects the direct loaded to running state transition
//
//  Returns:    Success if the object is running.
//
//  Notes:      This transition occurs as a result of an
//              IRunnableObject::Run call and is implicit in any
//              DoVerb call.
//
//---------------------------------------------------------------

HRESULT
CServer::LoadedToRunning(void)
{
    LPOLECONTAINER  pContainer;

    //  Put a lock on our container.  This is necessary if our container
    //    allows other clients to link to contained objects (us).

    if (_pClientSite && !_pClientSite->GetContainer(&pContainer))
    {
        // CONSIDER - should we remember LockContainer failed so that we
        //      can avoid calling LockContainer(FALSE) later?

        THR_NOTRACE(pContainer->LockContainer(TRUE));
        pContainer->Release();
    }

    _state = OS_RUNNING;

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::RunningToLoaded, protected
//
//  Synopsis:   Effects the direct running to loaded state transition
//
//  Returns:    Success if the object is loaded.
//
//  Notes:      This transition occurs as a result of an IOleObject::Close()
//              call.
//              This method sends an OnClose notification to all of our
//              advises.
//
//---------------------------------------------------------------

HRESULT
CServer::RunningToLoaded(void)
{
    LPOLECONTAINER  pContainer  = NULL;

    //  Release the lock we put on our container.  Not all containers
    //    support locking, so we allow failures

    if (_pClientSite)
    {
        if (!_pClientSite->GetContainer(&pContainer))
        {
            THR_NOTRACE(pContainer->LockContainer(FALSE));
            pContainer->Release();
        }
    }

    if (_lDirtyVersion)
    {
        SendOnDataChange(ADVF_DATAONSTOP);
    }

    //  Notify our advise holders that we have closed

    if (_pOleAdviseHolder)
        _pOleAdviseHolder->SendOnClose();

#if 0
    //  CONSIDER not sure where (or even if) we should be calling
    //    this.  Chris and Gary need to investigate.

    //  Forcibly cut off remoting clients

    CoDisconnectObject((LPOLEOBJECT) this, 0);
#endif

    _state = OS_LOADED;

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::RunningToInPlace, protected
//
//  Synopsis:   Effects the direct Running to inplace state transition
//
//  Returns:    Success iff the object is in the inplace state.  On failure
//              the object will be in a consistent Running state.
//
//  Notes:      This transition invokes the ActivateInPlace method.  Containers
//              will typically override this method in order to additionally
//              inplace activate any inside-out embeddings that are visible.
//
//---------------------------------------------------------------

HRESULT
CServer::RunningToInPlace(LPMSG lpmsg)
{
    HRESULT                     hr;

    //  CONSIDER flatten call tree

    hr = THR(ActivateInPlace(lpmsg));
    if (hr)
        goto Error;

#ifdef FANCY_CONNECTION_STUFF
    //  Put an external lock on ourselves so we stay in the running
    //    state even if we have other external connections.

    IGNORE_HR(LockRunning(TRUE, FALSE));
#endif

Error:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InPlaceToRunning, protected
//
//  Synopsis:   Effects the direct inplace to Running state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateInPlace method.
//
//              Containers will typically override this method in
//              order to additionally inplace deactivate any inplace-active
//              embeddings.
//
//              This method is called as the result of a DoVerb(HIDE...)
//
//---------------------------------------------------------------

HRESULT
CServer::InPlaceToRunning(void)
{
    HRESULT     hr;

    //  CONSIDER flatten call tree

    //
    // Free the external lock we hold to keep ourselves in the running
    // state in the case of other external connections.
    //

#ifdef FANCY_CONNECTION_STUFF
    IGNORE_HR(LockRunning(FALSE, FALSE));
#endif

    hr = THR(DeactivateInPlace());

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InPlaceToUIActive, protected
//
//  Synopsis:   Effects the direct inplace to U.I. active state transition
//
//  Returns:    Success iff the object is in the U.I. active state.  On failure
//              the object will be in a consistent inplace state.
//
//  Notes:      This transition invokes the ActivateUI method.
//
//---------------------------------------------------------------

HRESULT
CServer::InPlaceToUIActive(LPMSG lpmsg)
{
    HRESULT     hr;

    //  CONSIDER flatten call tree

#ifndef NO_OLEUI
    hr = THR(ActivateUI(lpmsg));
    if (hr)
        goto Error;
#endif // NO_OLEUI

    hr = THR(SetActiveObject());

Error:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::UIActiveToInPlace, protected
//
//  Synopsis:   Effects the direct U.I. Active to inplace state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateUI method.
//              Containers will typically override this method in
//              order to possibly U.I. deactivate a U.I. active embedding.
//
//---------------------------------------------------------------

HRESULT
CServer::UIActiveToInPlace(void)
{
    IGNORE_HR(ClearActiveObject());

#ifndef NO_OLEUI
    RRETURN(THR(DeactivateUI()));
#else
	RRETURN(S_OK);
#endif // NO_OLEUI
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetActiveObject, protected
//
//  Synopsis:   Informs the frame that we are now the UIActive object.
//
//---------------------------------------------------------------

HRESULT
CServer::SetActiveObject()
{
    HRESULT hr;
    IOleInPlaceActiveObject * pInPlaceActiveObject = NULL;

    TCHAR   ach[MAX_USERTYPE_LEN + 1];

    Verify(LoadString(
            GetResourceHInst(),
            IDS_USERTYPESHORT(BaseDesc()->_idrBase),
            ach,
            ARRAY_SIZE(ach)));

    hr = THR(PrivateQueryInterface(IID_IOleInPlaceActiveObject, (void **)&pInPlaceActiveObject));
    if (hr)
        goto Cleanup;

    hr = THR(_pInPlace->_pFrame->SetActiveObject(pInPlaceActiveObject, ach));

Cleanup:
    ReleaseInterface(pInPlaceActiveObject);
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer:ClearActiveObject, protected
//
//  Synopsis:   Informs the frame that we are no longer the UIActive object.
//
//---------------------------------------------------------------

HRESULT
CServer::ClearActiveObject()
{
    RRETURN(THR(_pInPlace->_pFrame->SetActiveObject(NULL,NULL)));
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetClientSite, public
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method saves the client site pointer in the
//              _pClientSite member variable.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    IOleDocumentSite *   pMsoDocSite;
    IOleUndoManager *    pUM = NULL;
    HRESULT              hr;
    HRESULT              hr2;


    //  If we already have a client site, refuse requests to
    //    change it
    hr = S_OK;
    if (_pClientSite)
    {
        if (pClientSite)
            RRETURN(E_INVALIDARG);

        ClearInterface(&_pClientSite);

        Assert(!_pInPlace || !_pInPlace->_pInPlaceSite);

        // QUESTION - Why is this needed?
        _fMsoViewExists = FALSE;
    }
    else
    {
        _pClientSite = pClientSite;
        _pClientSite->AddRef();

        DbgTrackItf(IID_IOleClientSite, "HostSite", TRUE, (void **)&_pClientSite);

        _fUserMode = GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);

        // CONSIDER Can we recognize doc mode without doing this? (garybu)
        if (OK(THR_NOTRACE(pClientSite->QueryInterface(
                IID_IOleDocumentSite, (void **) &pMsoDocSite))))
        {
            _fMsoDocMode = TRUE;
            ReleaseInterface(pMsoDocSite);
        }

#ifndef NO_EDIT
        if (!hr && (_pUndoMgr == &g_DummyUndoMgr))
        {
            //
            // We don't want to call any overridden implementations because
            // all we want to do is check our parent. We don't want any
            // derived classes creating the undo manager in this call because
            // we'll create it ourselves below.
            //
            hr2 = THR_NOTRACE(CServer::QueryService(
                                SID_SOleUndoManager,
                                IID_IOleUndoManager,
                                (LPVOID*)&pUM));

            if (OK(hr2) && pUM)
            {
                _pUndoMgr = pUM;
            }
            else
            {
                if (ServerDesc()->TestFlag(SERVERDESC_CREATE_UNDOMGR))
                {
                    hr = THR(CreateUndoManager());
                }
                else
                {
                    _pUndoMgr = &g_DummyUndoMgr;
                }
            }
        }
#endif // NO_EDIT
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetClientSite, IOleObject
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetClientSite(LPOLECLIENTSITE * ppClientSite)
{
    *ppClientSite = _pClientSite;
    if (_pClientSite)
    {
        _pClientSite->AddRef();
    }
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetHostNames
//
//  Synopsis:   Method of IOleObject interface
//
//              These strings should be remembered for open
//              edit or to pass along to embeddings that open
//              edit.  Most classes derived from CServer don't
//              care about this, so we ignore them here.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetHostNames(LPCTSTR lpstrCntrApp, LPCTSTR lpstrCntrObj)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::Close
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method ensures the object is in the loaded
//              (not passive!) state.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Close(DWORD dwSaveOption)
{
    HRESULT hr          = S_OK;
    BOOL    fSave;
    int     id;

    // if our object is dirty then we should save it, depending on the
    // save options
    if (_pClientSite != NULL && _lDirtyVersion)
    {
        switch(dwSaveOption)
        {
        case OLECLOSE_SAVEIFDIRTY:
            fSave = TRUE;
            break;

        case OLECLOSE_NOSAVE:
            fSave = FALSE;
            break;

        case OLECLOSE_PROMPTSAVE:
            {
                if (_state <= OS_INPLACE)
                {
                    //we do not prompt if the object
                    //is in-place or invisible
                    fSave = TRUE;
                    break;
                }

                //we only prompt in the following state
                Assert(_state == OS_UIACTIVE);

                //  Put up a message box asking the user if they want
                //    to update the container.

                //  CONSIDER make this work better with DisplayName
                //    ambient property

                hr = THR(ShowMessage(
                    &id,
                    MB_YESNOCANCEL | MB_ICONQUESTION,
                    0,
                    IDS_MSG_SAVE_MODIFIED_OBJECT));

                if (hr)
                    RRETURN(hr);

                if (id == IDCANCEL)
                    RRETURN(OLE_E_PROMPTSAVECANCELLED);

                fSave = (id == IDYES);
            }
            break;

        default:
            RRETURN(E_INVALIDARG);
        }

        if (fSave)
            hr = THR(_pClientSite->SaveObject());
    }

    if (!hr)
        hr = THR(TransitionTo(OS_LOADED));

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method notifies our data/view subobject of our new
//              moniker.  It also registers us in the running object
//              table and sends an OnRename notification to all registered
//              advises.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    HRESULT     hr      = S_OK;
    LPMONIKER   pmkFull = NULL;

    //  Ensure that we have a full moniker to register in the ROT
    //  If we have a full moniker, then go with it.
    //  Otherwise ask our client site for a full moniker.

    if (dwWhichMoniker == OLEWHICHMK_OBJFULL)
    {
        pmkFull = pmk;
        if (pmkFull)
            pmkFull->AddRef();
    }
    else
    {
        if (_pClientSite == NULL)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = THR(_pClientSite->GetMoniker(
                    OLEGETMONIKER_ONLYIFTHERE,
                    OLEWHICHMK_OBJFULL,
                    &pmkFull));
        }

        if (hr)
            goto Cleanup;
    }

    if (pmkFull)
    {
        //  Notify our advise holders that we have been renamed

        if (_pOleAdviseHolder)
            _pOleAdviseHolder->SendOnRename(pmkFull);
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method forwards the request to our client site
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    HRESULT     hr;

    if (ppmk == NULL)
        RRETURN(E_INVALIDARG);

    *ppmk = NULL;   // set out parameters to NULL

    //  Get the requested moniker from our client site

    if (_pClientSite == NULL)
        hr = MK_E_UNAVAILABLE;
    else
        hr = THR_NOTRACE(_pClientSite->GetMoniker(dwAssign, dwWhichMoniker, ppmk));

    RRETURN_NOTRACE(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InitFromData
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_FALSE indicating InitFromData
//              is not supported.  Servers that wish to support initialization
//              from a selection should override this function.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::InitFromData(
        LPDATAOBJECT pDataObject,
        BOOL fCreation,
        DWORD dwReserved)
{
    return S_FALSE;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetClipboardData
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetClipboardData(DWORD dwReserved, LPDATAOBJECT FAR* ppDataObject)
{
    if (ppDataObject == NULL)
        RRETURN(E_INVALIDARG);

    *ppDataObject = NULL;               // set out params to NULL

    RRETURN(E_NOTIMPL);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoVerb
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method locates the requested verb in the servers
//              verb table and calls the associated verb function.
//              If the verb is not found then the first (at index 0) verb in
//              the verb table is called.  This should be the primary verb
//              with verb number 0.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::DoVerb(
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCOLERECT lprcPosRect)
{
    HRESULT hr  = S_OK;
    int     i;

    Assert(ServerDesc());
    Assert(ServerDesc()->_pOleVerbTable);
    Assert(ServerDesc()->_pOleVerbTable[0].lVerb == OLEIVERB_PRIMARY);

    //  Find the verb in the verb table.

    for (i = 0; i < ServerDesc()->_cOleVerbTable; i++)
    {
        if (iVerb == ServerDesc()->_pOleVerbTable[i].lVerb)
            break;
    }

    //  If the verb is not in the table, then return an error for negative
    //      verbs or default to the 0th entry in the table for positive verbs.
    //      The 0th entry in the table must be the primary verb.

    if (i >= ServerDesc()->_cOleVerbTable)
    {
        if (iVerb < 0)
            RRETURN(E_NOTIMPL);

        i = 0;
    }

    //  All DoVerbs make an implicit transition to the running state if
    //  the object is not already running.
    //
    //  Putting the server into the running state and then returning
    //  E_NOTIMPL for a verb will confuse the container about our state.
    //  Because some classes can return E_NOTIMPL from the state transition
    //  verbs, we skip the step of putting the object into the running
    //  state here.  The implementation of the state transition verbs
    //  will take care of getting the server into the running state.

    if (_state < OS_RUNNING &&
            iVerb != OLEIVERB_INPLACEACTIVATE &&
            iVerb != OLEIVERB_UIACTIVATE)
    {
        // if we are less than OS_LOADED this will transition us up to
        // running.  This happens with outlook
        hr = THR(TransitionTo(OS_RUNNING));
        if (hr)
            goto Cleanup;
    }

    //  Dispatch the verb

    hr = THR((*ServerDesc()->_pfnDoVerb[i])(
            this,
            iVerb,
            lpmsg,
            pActiveSite,
            lindex,
            hwndParent,
            lprcPosRect));
    
    if (hr)
        goto Cleanup;

    //  If we defaulted to the 0th entry in the table (primary verb),
    //      then return the appropriate status.

    if (OK(hr) && iVerb != ServerDesc()->_pOleVerbTable[i].lVerb)
    {
        hr = OLEOBJ_S_INVALIDVERB;
    }

Cleanup:

    //  CONSIDER the error handling here is a little unclear.  Normally,
    //    if we get an error, we try to leave ourselves in our original
    //    state.  However, with DoVerb, we don't have enough information
    //    to know why we're in the state we're in.  We might have
    //    failed, or someone might have moved us there during a callback,
    //    or whatever.
    //
    //  For Forms95, we just leave ourselves in whatever state we're
    //    in if an error occurs.  Note that we do guarantee that we've
    //    legally reached the current state.  Revisit for Forms96.

    RRETURN2(hr, OLEOBJ_S_INVALIDVERB, OLEOBJ_S_CANNOT_DOVERB_NOW);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::EnumVerbs
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method produces an enumerator over the server's
//              verb table.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumVerbs(LPENUMOLEVERB FAR* ppenum)
{
    HRESULT     hr;

    if (ppenum == NULL)
        RRETURN(E_INVALIDARG);

    hr = THR(CreateOLEVERBEnum(
            ServerDesc()->_pOleVerbTable,
            ServerDesc()->_cOleVerbTable,
            ppenum));

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Update
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_OK indicating that the update was
//              successful.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Update(void)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::IsUpToDate
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_OK indicating that the object is
//              up to date.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::IsUpToDate(void)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetUserClassID
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the class id from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetUserClassID(CLSID FAR* pClsid)
{
    if (pClsid == NULL)
    {
        RRETURN(E_INVALIDARG);
    }

    *pClsid = *BaseDesc()->_pclsid;
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetUserType
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the user type string from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetUserType(DWORD dwFormOfType, LPTSTR FAR* ppstr)
{
    int         ids;
    TCHAR       ach[MAX_USERTYPE_LEN + 1];
    const CBase::CLASSDESC * pcd = BaseDesc();

    switch (dwFormOfType)
    {
    case USERCLASSTYPE_APPNAME:
        ids = IDS_USERTYPEAPP;
        break;

    case USERCLASSTYPE_SHORT:
        ids = IDS_USERTYPESHORT(pcd->_idrBase);
        break;

    case USERCLASSTYPE_FULL:
        ids = IDS_USERTYPEFULL(pcd->_idrBase);
        break;

    default:
        *ppstr = NULL;
        RRETURN(E_INVALIDARG);
    }



    Verify(LoadString(
            GetResourceHInst(),
            ids,
            ach,
            ARRAY_SIZE(ach)));

    RRETURN(TaskAllocString(ach, ppstr));
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetExtent
//
//  Synopsis:   Method of IOleObject interface.  Sets the extent
//              for some aspect of the object.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetExtent(DWORD dwAspect, SIZEL *psizel)
{
    HRESULT     hr;
    BOOL fChangedExtent = FALSE;

    Assert(psizel->cx >= 0);
    Assert(psizel->cy >= 0);

    if (psizel->cx < 0 || psizel->cy < 0)
    {
        RRETURN(E_FAIL);
    }

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:

/*
        if (State() >= OS_INPLACE && _sizel.cx && _sizel.cy)
        {
            SIZE size;

            // In order to do himetric <-> pixel conversions, we need to keep
            // _sizel and _pInPlace->_rcPos in sync.  We do this by updating
            // _pInPlace->_rcPos to what we think the container will tell us
            // in a later call to IOleInPlaceObject::SetObjectRects. If the
            // container does not do this, we will be in a confused state.
            //
            // CONSIDER: Consider the CDK behavior.  It keeps things in sync
            // by calling IOleInPlace::OnPosRectChanged with the new rectangle
            // instead of setting _pInPlace->_rcPos directly. This seems
            // wasteful because it causes the container to call
            // SetObjectRects twice -- once from OnPosRectChanged and a
            // second time because the container is trying to resize the
            // control. The CDK uses a flag to prevent infinite recursion
            // should the container call IOleObject::SetExtent from
            // IOleInPlaceSite::OnPosRectChanged (as many seem to do).

            DeviceFromHimetric(&size, *psizel);
            _pInPlace->_rcPos.right  = _pInPlace->_rcPos.left + size.cx;
            _pInPlace->_rcPos.bottom = _pInPlace->_rcPos.top  + size.cy;
        }
*/
        if ( memcmp ( &_sizel, psizel, sizeof ( SIZEL ) ) )
        {
            fChangedExtent = TRUE;
        }
        _sizel = *psizel;
        hr = S_OK;
        break;

    case DVASPECT_DOCPRINT:
        hr = E_NOTIMPL;
        goto Cleanup;

    case DVASPECT_THUMBNAIL:
    case DVASPECT_ICON:
        hr = E_FAIL;
        goto Cleanup;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    if (!_fMsoDocMode && fChangedExtent )
    {
        // Our width & height are persisted through property changes
        // So don't dirty the form
        OnDataChange(FALSE);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetExtent
//
//  Synopsis:   Method of IOleObject interface.  Returns the current
//              size of some aspect of the object.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetExtent(DWORD dwAspect, LPSIZEL lpsizel)
{
    HRESULT     hr  = S_OK;

    if (lpsizel == NULL)
        RRETURN(E_INVALIDARG);

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
    case DVASPECT_DOCPRINT:
        *lpsizel = _sizel;
        break;

    case DVASPECT_THUMBNAIL:
        lpsizel->cx = HimetricFromHPix(32);
        lpsizel->cy = HimetricFromVPix(32);
        break;

    case DVASPECT_ICON:
        if (_pViewObjectCache)
        {
            hr = THR(_pViewObjectCache->GetExtent(
                    dwAspect,
                    -1,
                    NULL,
                    lpsizel));
        }
        else
        {
#ifdef WINCE
	        hr = E_INVALIDARG;
#else
            HGLOBAL         hMF;
            LPMETAFILEPICT  pMF;

            hMF = OleGetIconOfClass(*BaseDesc()->_pclsid, NULL, TRUE);
            if (hMF)
            {
                pMF = (LPMETAFILEPICT) GlobalLock(hMF);
                if (pMF)
                {
	                lpsizel->cx = pMF->xExt;    //  Values are HIMETRIC
    	            lpsizel->cy = pMF->yExt;
	
    	            DeleteMetaFile(pMF->hMF);
                }
                else
               	{
    	            hr = E_OUTOFMEMORY;
               	}
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
#endif // WINCE
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Advise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Advise(IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    HRESULT hr;

    if (!pdwConnection)
        RRETURN(E_INVALIDARG);

    *pdwConnection = NULL;              // set out params to NULL

    if (!_pOleAdviseHolder)
    {
        hr = THR(CreateOleAdviseHolder(&_pOleAdviseHolder));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_pOleAdviseHolder->Advise(pAdvSink, pdwConnection));

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Unadvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Unadvise(DWORD dwConnection)
{
    HRESULT     hr;

    if (!_pOleAdviseHolder)
        RRETURN(OLE_E_NOCONNECTION);

    hr = THR(_pOleAdviseHolder->Unadvise(dwConnection));

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::EnumAdvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    HRESULT     hr;

    if (!ppenumAdvise)
        RRETURN(E_INVALIDARG);

    if (_pOleAdviseHolder == NULL)
    {
        *ppenumAdvise = NULL;
        hr = S_OK;
    }
    else
    {
        hr = THR(_pOleAdviseHolder->EnumAdvise(ppenumAdvise));
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetMiscStatus
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the misc status flags from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetMiscStatus (DWORD dwAspect, DWORD FAR* pdwStatus)
{
    *pdwStatus = ServerDesc()->_dwMiscStatus;
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetColorScheme
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Servers should override this method if they are
//              interested in the palette.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetColorScheme (LPLOGPALETTE lpLogpal)
{
    RRETURN(E_NOTIMPL);   //will we ever?
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetRunningClass, public
//
//  Synopsis:   Returns our current class ID.  Method on IRunnableObject.
//
//  Arguments:  [lpClsid] -- Place to return clsid
//
//----------------------------------------------------------------------------
#ifdef FANCY_CONNECTION_STUFF

STDMETHODIMP
CServer::GetRunningClass(LPCLSID lpClsid)
{
    if (!lpClsid)
        RRETURN(E_INVALIDARG);

    *lpClsid = *BaseDesc()->_pclsid;

    return S_OK;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::Run, public
//
//  Synopsis:   Method in IRunnableObject.  Puts us into the running state if
//              we're not already there.
//
//  Arguments:  [pbc] -- Bind context. (Ignored)
//
//  Notes:      If we're in the running, inplace, or UI Active states, then
//              this method has no effect.
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF

STDMETHODIMP
CServer::Run(LPBINDCTX pbc)
{
    HRESULT hr = S_OK;

    if (_state < OS_RUNNING)
        hr = THR(TransitionTo(OS_RUNNING));

    RRETURN(hr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::IsRunning, public
//
//  Synopsis:   Method on IRunnableObject.  Returns whether or not we're
//              running.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------
#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP_(BOOL)
CServer::IsRunning(void)
{
    return (_state >= OS_RUNNING);
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::LockRunning, public
//
//  Synopsis:   Method on IRunnableObject.  Locks us in the running state.
//
//  Arguments:  [fLock]             -- TRUE to add a lock, FALSE to release.
//              [fLastUnlockCloses] -- If TRUE, releasing the last lock
//                                     closes us by calling IOleObject::Close
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP
CServer::LockRunning(BOOL fLock, BOOL fLastUnlockCloses)
{
    if (fLock)
    {
        _pUnkOuter->AddRef();

        Assert(_cStrongRefs < 255);
        _cStrongRefs += 1;
    }
    else
    {
        Assert(_cStrongRefs > 0);
        _cStrongRefs -= 1;
        if ((_cStrongRefs == 0) && fLastUnlockCloses)
        {
            Close(OLECLOSE_NOSAVE);
        }
        _pUnkOuter->Release();
    }
    return S_OK;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetContainedObject, public
//
//  Synopsis:   Indicates whether or not we're a contained object.
//
//  Arguments:  [fContained] -- Tells us if we're a contained object.
//
//  Notes:      Since objects based on CServer are always contained, this
//              method is ignored.
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF

STDMETHODIMP
CServer::SetContainedObject(BOOL fContained)
{
    return S_OK;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::AddConnection, public
//
//  Synopsis:   Method on IExternalConnection.  Indicates we have an
//              external connection, which will allow us to clean up
//              properly when all the external connections go away.
//
//  Arguments:  [extconn]  -- Type of connection
//              [reserved] --
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP_(DWORD)
CServer::AddConnection(DWORD extconn, DWORD reserved)
{
    if (extconn & EXTCONN_STRONG)
    {
        LockRunning(TRUE, FALSE);
        return _cStrongRefs;
    }
    return 0;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::ReleaseConnection, public
//
//  Synopsis:   Method on IExternalConnection. Tells us one of our external
//              connections is going away.  If we have no more external
//              connections, then we close.
//
//  Arguments:  [extconn]            -- Type of connection being released
//              [reserved]           --
//              [fLastReleaseCloses] -- Indicates if we should close or not.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP_(DWORD)
CServer::ReleaseConnection(DWORD extconn,
                            DWORD reserved,
                            BOOL fLastReleaseCloses)
{
    if (extconn & EXTCONN_STRONG)
    {
        DWORD cStrongRefs = _cStrongRefs;
        LockRunning(FALSE, fLastReleaseCloses);
        return cStrongRefs - 1;
    }
    return 0;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CServer::QuickActivate, IQuickActivate
//
//  Synopsis:   Connect this object to the container.
//
//              For high performance, functionality in CServer::SetClientSite
//              and other functions is inlined here.  If a derived class
//              overrides CServer::SetClientSite, it will need to override
//              this function as well.
//
//              This function assumes that the class has the following
//              connection points:
//
//                  [0] - Automation events
//                  [1] - Property notifications
//
//  Arguments:  pqacontainer    In, information about the container.
//              pqacontrol      Out, information about this object.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

STDMETHODIMP
CServer::QuickActivate(QACONTAINER *pqacontainer, QACONTROL *pqacontrol)
{
    HRESULT                 hr = S_OK;
    const CLASSDESC *       pcd = ServerDesc();

    if (pqacontainer->cbSize < sizeof(QACONTAINER) ||
        pqacontrol->cbSize < sizeof(QACONTROL))
        RRETURN(E_INVALIDARG);

    // CONSIDER: inline ReplaceInterface here for high speed.
    ReplaceInterface(&_pAdvSink, (IAdviseSink *)pqacontainer->pAdviseSink);
    ReplaceInterface(&_pClientSite, pqacontainer->pClientSite);

#ifndef NO_EDIT
    if (pqacontainer->pUndoMgr)
    {
        ReplaceInterface(&_pUndoMgr, pqacontainer->pUndoMgr);
    }
    else if (ServerDesc()->TestFlag(SERVERDESC_CREATE_UNDOMGR))
    {
        hr = THR(CreateUndoManager());
        if (hr)
            goto Cleanup;
    }
    else
    {
        _pUndoMgr = &g_DummyUndoMgr;
    }
#endif // NO_EDIT

    _fUseAdviseSinkEx = TRUE;
    _fUserMode = (pqacontainer->dwAmbientFlags & QACONTAINER_USERMODE) != 0;


    if (pqacontainer->pPropertyNotifySink)
    {
        hr = THR(ClampITFResult(DoAdvise(
                IID_IPropertyNotifySink,
                DISPID_A_PROPNOTIFYSINK,
                pqacontainer->pPropertyNotifySink,
                NULL,
                &pqacontrol->dwPropNotifyCookie)));
        if (hr)
            goto Cleanup;
    }

    pqacontrol->dwMiscStatus = pcd->_dwMiscStatus;
    pqacontrol->dwViewStatus = pcd->_dwViewStatus;
    GetActivationPolicy(&pqacontrol->dwPointerActivationPolicy);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CServer::SetContentExtent, IQuickActivate
//
//  Synopsis:   Set the extent of the object.
//
//  Arguments:  lpsizel     The extent in himetric
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CServer::SetContentExtent(LPSIZEL lpsizel)
{
    RRETURN(THR(SetExtent(DVASPECT_CONTENT, lpsizel)));
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::GetContentExtent, IQuickActivate
//
//  Synopsis:   Get the extent of the object.
//
//  Arguments:  lpsizel     The extent in himetric.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CServer::GetContentExtent(LPSIZEL lpsizel)
{
    RRETURN(THR(GetExtent(DVASPECT_CONTENT, lpsizel)));
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::GetAmbientBool
//
//  Synopsis:   Helper method to get an ambient property of type BOOL.
//              The caller passes in a default value that is returned if
//              the property isn't present on the site, or if no
//              site is present.
//
//  Arguments:  [dispid]        --  property to get
//              [fDefaultValue] --  default value to use if property
//                                  not present
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
CServer::GetAmbientBool(DISPID dispid, BOOL fDefaultValue)
{
    HRESULT     hr;
    CVariant    var;
    BOOL        f = fDefaultValue;

    hr = GetAmbientVariant(dispid, &var);
    if (!hr && (var.vt == VT_BOOL))
    {
        f = (var.boolVal != 0);
    }

    return f;
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::GetAmbientBstr
//
//  Synopsis:   Helper method to get an ambient property of type BSTR.
//
//  Arguments:  [dispid]        --  property to get
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CServer::GetAmbientBstr(DISPID dispid, BSTR *pbstr)
{
    HRESULT     hr;
    CVariant    var;

    *pbstr = NULL;

    hr = GetAmbientVariant(dispid, &var);
    if (!hr)
    {
        if (var.vt == VT_BSTR)
        {
            *pbstr = var.bstrVal;
            VariantInit(&var);
        }
        else
            hr = DISP_E_MEMBERNOTFOUND;
    }

    return hr;
}

HPALETTE
CServer::GetAmbientPalette()
{
    CVariant var;
    HRESULT hr = GetAmbientVariant(DISPID_AMBIENT_PALETTE, &var);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_HANDLE)
        {
            Assert(!var.byref || GetObjectType((HGDIOBJ)var.byref) == OBJ_PAL);

            if (!var.byref || GetObjectType((HGDIOBJ)var.byref) != OBJ_PAL)
                return NULL;
                
            return (HPALETTE)var.byref;
        }
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::GetAmbientPropOfType
//
//  Synopsis:   Helper method to get an ambient property of arbitrary
//              type.  Used as GetDispPropOfType.
//
//  Arguments:  [dispid]    --  Property to get
//              [vt]        --  Type of property
//              [pv]        --  Pointer to c data type that receives
//                              the value
//
//  Returns:    HRESULT.  Returns DISP_E_MEMBERNOTFOUND if no client
//              site has been set.
//
//-------------------------------------------------------------------------

HRESULT
CServer::GetAmbientVariant(
        DISPID dispid,
        VARIANT * pvar)
{
    HRESULT     hr;
    IDispatch * pDisp = NULL;

    if (!_pClientSite)
        RRETURN_NOTRACE(DISP_E_MEMBERNOTFOUND);

    hr = THR_NOTRACE(_pClientSite->QueryInterface(
            IID_IDispatch,
            (LPVOID*) &pDisp));
    if (hr)
        RRETURN_NOTRACE(DISP_E_MEMBERNOTFOUND);

    Assert(pDisp);

    hr = THR_NOTRACE(GetDispProp(
                        pDisp,
                        dispid,
                        g_lcidUserDefault,
                        pvar));

    pDisp->Release();

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetCanUndo
//
//  Synopsis:   Helper to determine whether an undo operation is available.
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
HRESULT
CServer::GetCanUndo(VARIANT_BOOL * pfCanUndo)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    if (!pfCanUndo)
        RRETURN(SetErrorInfoInvalidArg());

    hr = THR_NOTRACE(_pUndoMgr->GetLastUndoDescription(&bstr));
    FormsFreeString(bstr);

    *pfCanUndo = (hr == S_OK) ? VB_TRUE : VB_FALSE;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetCanRedo
//
//  Synopsis:   Helper to determine whether a redo operation is available.
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetCanRedo(VARIANT_BOOL * pfCanRedo)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    if (!pfCanRedo)
        RRETURN(SetErrorInfoInvalidArg());

    hr = THR_NOTRACE(_pUndoMgr->GetLastRedoDescription(&bstr));
    FormsFreeString(bstr);

    *pfCanRedo = (hr == S_OK) ? VB_TRUE : VB_FALSE;

    return S_OK;
}
#endif // NO_EDIT

//+-------------------------------------------------------------------------
//
//  Method:     CServer::RequestUIActivate
//
//  Synopsis:   Ask site if it's ok to UI activate.
//
//--------------------------------------------------------------------------

BOOL
CServer::RequestUIActivate()
{
    Assert(State() >= OS_INPLACE);

    if (State() < OS_UIACTIVE &&
        _pInPlace->_fUseExtendedSite)
    {
        if (((IOleInPlaceSiteEx *)_pInPlace->_pInPlaceSite)->RequestUIActivate() == S_OK)
            return TRUE;

        // Per spec call OnUIDeactivate.
        // Bug 7243: during the request the host could fire eventcode that will change
        // our current state (like making us invisible). That would invalidate the _pInplace
        // pointer
        if (_pInPlace)
        {
            IGNORE_HR(_pInPlace->_pInPlaceSite->OnUIDeactivate(FALSE));
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CServer::RequestFocusFromServer
//
//  Synopsis:   Ask site if it's ok to call SetFocus.  This is just a copy
//  of RequestUIActivate function above.  The only difference being that we
//  don't check the UI state in this function.  We're checking to see if we
//  can take focus, rather than asking for UI activation.  This fixes a focus
//  bug Mars.
//
//--------------------------------------------------------------------------

BOOL
CServer::RequestFocusFromServer()
{
    Assert(State() >= OS_INPLACE);

    if (_pInPlace->_fUseExtendedSite)
    {
        if (((IOleInPlaceSiteEx *)_pInPlace->_pInPlaceSite)->RequestUIActivate() == S_OK)
            return TRUE;

        // Per spec call OnUIDeactivate.
        // Bug 7243: during the request the host could fire eventcode that will change
        // our current state (like making us invisible). That would invalidate the _pInplace
        // pointer
        if (_pInPlace)
        {
            IGNORE_HR(_pInPlace->_pInPlaceSite->OnUIDeactivate(FALSE));
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetFocus, public
//
//  Synopsis:   Set the focus to this server.
//
//----------------------------------------------------------------------------

HRESULT
CServer::SetFocus(BOOL fFocus)
{
    HRESULT           hr = S_OK;

    Assert(_pInPlace);
    Assert(State() >= OS_INPLACE);

    if (State() < OS_INPLACE)
    {
        Assert(!fFocus);
        goto Cleanup;
    }

    if (_pInPlace->_fWindowlessInplace)
    {
        hr = THR(((IOleInPlaceSiteWindowless*)
                (_pInPlace->_pInPlaceSite))->SetFocus(fFocus));
    }
    else
    {
        Assert(_pInPlace->_hwnd);
        if (fFocus)
        {
            // Capture the focus.
            ::SetFocus(_pInPlace->_hwnd);
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetFocus, public
//
//  Synopsis:   Determines whether the client site has focus
//
//----------------------------------------------------------------------------

BOOL
CServer::GetFocus()
{
    if (_pInPlace->_fWindowlessInplace)
        return (((IOleInPlaceSiteWindowless *) (_pInPlace->_pInPlaceSite))->GetFocus() == S_OK);
    else
        return (_pInPlace->_hwnd == ::GetFocus());
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetCapture, public
//
//  Synopsis:   Find out if we have captured the mouse.
//
//----------------------------------------------------------------------------

BOOL
CServer::GetCapture()
{
    Assert(_pInPlace);
    Assert(State() >= OS_INPLACE);

    if (_pInPlace->_fWindowlessInplace)
    {
        return ((IOleInPlaceSiteWindowless*)
                (_pInPlace->_pInPlaceSite))->GetCapture() == S_OK;
    }
    else
    {
        if (_pInPlace->_hwnd)
        {
            return ::GetCapture() == _pInPlace->_hwnd;
        }
        else
        {            
            return FALSE;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetCapture, public
//
//  Synopsis:   fCaptured --> Capture the mouse to this server
//              !fCaptured --> This server will not have the capture.
//
//----------------------------------------------------------------------------

HRESULT
CServer::SetCapture(BOOL fCaptured)
{
    HRESULT hr = S_OK;

    if (State() < OS_INPLACE)
    {
        Assert(!fCaptured);
    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        hr = THR(((IOleInPlaceSiteWindowless*)
                (_pInPlace->_pInPlaceSite))->SetCapture(fCaptured));
    }
    else
    {
        Assert(_pInPlace->_hwnd || !fCaptured);
        if (fCaptured)
        {
             // Capture the focus.
            ::SetCapture(_pInPlace->_hwnd);
        }
        else if (::GetCapture() == _pInPlace->_hwnd)
        {
            // Release capture if we have it.
#if DBG==1
            Assert(!TLS(fHandleCaptureChanged));
#endif //DBG==1
            ::ReleaseCapture();
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetActivationPolicy
//
//  Synopsis:   Member of IPointerInactive.  Returns bits indicating whether
//              this server should be automatically activated when the
//              mouse passes over it, and deactivated when no longer over.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::GetActivationPolicy(DWORD * pdwPolicy)
{
    *pdwPolicy = 0;

    if (ServerDesc()->TestFlag(SERVERDESC_ACTIVATEONENTRY))
    {
        *pdwPolicy |= POINTERINACTIVE_ACTIVATEONENTRY;
    }

    if (ServerDesc()->TestFlag(SERVERDESC_DEACTIVATEONLEAVE))
    {
        *pdwPolicy |= POINTERINACTIVE_DEACTIVATEONLEAVE;
    }

    if (ServerDesc()->TestFlag(SERVERDESC_ACTIVATEONDRAG))
    {
        *pdwPolicy |= POINTERINACTIVE_ACTIVATEONDRAG;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::OnInactiveSetCursor
//
//  Synopsis:   Member of IPointerInactive.  Allows the server to set the
//              cursor without requiring activation.
//              Coordinates are in window device units.
//
//  Returns:    S_OK if cursor set.
//              S_FALSE if _mousepointer == fmMousePointerDefault (and does not
//                  set the cursor.)
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::OnInactiveSetCursor(LPCRECT pRectBounds,
                             long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
{
    HRESULT hr;

    hr = SetCursor();

    // if cursor not set yet and required to set something,
    // set standard arrow cursor
    if(fSetAlways && hr == S_FALSE)
    {
        SetCursorIDC(IDC_ARROW);
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetCursor
//
//  Synopsis:   Helper function that sets the cursor according to the
//              MousePointer and MouseIcon properties of the CServer.
//
//  Returns:    S_OK if cursor set.
//              S_FALSE if _mousepointer == fmMousePointerDefault (and does not
//                  set the cursor.)
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetCursor()
{
       return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::OnInactiveMouseMove
//
//  Synopsis:   Member of IPointerInactive.  Allows the server to fire
//              mouse move events without going inplace active.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::OnInactiveMouseMove(LPCRECT prc, long x, long y, DWORD grfKeyState)
{
    /*
    POINTL          ptl;
    POINTF          ptf;

    if (ServerDesc()->_sef & SEF_MOUSEMOVE)
    {
        // Convert to document coordinates
        ptl.x = MulDivQuick(x - prc->left, _sizel.cx, prc->right - prc->left);
        ptl.y = MulDivQuick(y -  prc->top, _sizel.cy, prc->bottom -  prc->top);

        UserFromDocument(&ptf, ptl.x, ptl.y);
        IGNORE_HR(FireStdControlEvent_MouseMove(
                VBButtonState((short)grfKeyState),
                VBShiftState(),
                ptf.x,
                ptf.y));
    }
    */
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetEnabled
//
//  Synopsis:   Helper method.  Many objects will simply override this.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = VB_TRUE;
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CServer::QueryService, CServer
//
//  Synopsis:   Get service from the inplace or client site.
//
//  Arguments:  guidService     id of service
//              iid             id of interface on service
//              ppv             the service
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::QueryService(REFGUID guidService, REFIID iid, void **ppv)
{
    IUnknown *  apUnk[2];
    IUnknown ** ppUnk;
    int         cUnk = 0;
    HRESULT     hr = E_FAIL;            // Assume failure.

    *ppv = NULL;

    //
    // If were are in a doc object and we're inplace (or above), then
    // first see if the service is supported by the InPlaceSite.
    //
    
    if (_fMsoDocMode && _pInPlace && _pInPlace->_pInPlaceSite)
    {
        apUnk[cUnk++] = _pInPlace->_pInPlaceSite;
    }

    // If we have a client site, check it next.
    if (_pClientSite)
    {
        apUnk[cUnk++] = _pClientSite;
    }

    // Now perform the checks.
    ppUnk = apUnk;
    for (cUnk--; cUnk >= 0; cUnk--, ppUnk++)
    {
        IServiceProvider *  pSP;

        hr = THR_NOTRACE((*ppUnk)->QueryInterface(
                IID_IServiceProvider,
                (void **)&pSP));
        if (!hr)
        {
            hr = THR_NOTRACE(pSP->QueryService(guidService, iid, ppv));
            pSP->Release();
            if (!hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::CLock::CLock
//
//  Synopsis:   Lock resources in CServer object.
//
//-------------------------------------------------------------------------

CServer::CLock::CLock(CServer *pServer, WORD wLockFlags)
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pServer = pServer;
    _wLockFlags = pServer->_wLockFlags;
    pServer->_wLockFlags |= wLockFlags | SERVERLOCK_STABILIZED;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        pServer->_pUnkOuter->AddRef();
        pServer->PrivateAddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

CServer::CLock::CLock(CServer *pServer)
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pServer = pServer;
    _wLockFlags = pServer->_wLockFlags;
    pServer->_wLockFlags |= SERVERLOCK_STABILIZED;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        pServer->_pUnkOuter->AddRef();

        pServer->PrivateAddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::CLock::~CLock
//
//  Synopsis:   Unlock resources in CServer object.
//
//-------------------------------------------------------------------------

CServer::CLock::~CLock()
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    // _pServer refcount can go down to zero and then the
    // statement : delete this will be executed. After that
    // _pUnkOuter has no valid value any longer and
    // _pServer->_pUnkOuter->Release() can cause a GPF.
    // Therefore we save the value of _pUnkOuter in a local
    // variable maintaining the original release order.
    // The GPF can be reproduce in VBAPP by putting the
    // Unload Me statement into the UserForm1_Layout event
    // procedure

    IUnknown *  pUnkOuter = _pServer->_pUnkOuter;

    _pServer->_wLockFlags = _wLockFlags;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pServer->PrivateRelease();
        pUnkOuter->Release();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\verb.cxx ===
//+---------------------------------------------------------------------
//
//  File:       verb.cxx
//
//  Contents:   CServer verb stuff.
//
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------
//
//  Common verb tables
//
//          These are the common verb tables.  Specialized verb tables
//          can be defined elsewhere.
//
//          DoProperties is duplicated in these tables because most
//          containers will not add menu items for negative lVerb values.
//
//          The sizes for these arrays are defined in CDBASE.HXX.  You
//          must update the sizes in CDBASE if you make changes here.
//
//---------------------------------------------------------------

const OLEVERB g_aOleVerbStandard[C_OLEVERB_STANDARD] =
{
    { OLEIVERB_PRIMARY,         NULL, 0, 0 },
    { 1,                        NULL, 0, 0 },
    { OLEIVERB_INPLACEACTIVATE, NULL, 0, 0 },
    { OLEIVERB_UIACTIVATE,      NULL, 0, 0 },
    { OLEIVERB_HIDE,            NULL, 0, 0 },
    { OLEIVERB_SHOW,            NULL, 0, 0 },
    { OLEIVERB_PROPERTIES,      NULL, 0, 0 },
};

const CServer::PFNDOVERB g_apfnDoVerbStandard[C_OLEVERB_STANDARD]=
{
    &CServer::DoUIActivate,
#if !defined(PRODUCT_RT) && !defined(PRODUCT_96)
    &CServer::DoProperties,
#endif
    &CServer::DoInPlaceActivate,
    &CServer::DoUIActivate,
    &CServer::DoHide,
    &CServer::DoUIActivate,
#if !defined(PRODUCT_RT) && !defined(PRODUCT_96)
    &CServer::DoProperties,
#endif
};


//+---------------------------------------------------------------------------
//
//  Member:     CServer::PrepareActivationMessage
//
//  Synopsis:   Setup an activation message to be later sent by
//              SendActivationMessage.
//
//  Arguments:  lpmsg       The message handed to us in DoVerb.
//              lpmsgSend   The message to send.
//
//  Notes:      > Handles the lpmsg == NULL case.
//              > Translates message parameters, so that the window
//                can deal with the message as if it arrived
//                normally.
//              > We only send mouse messages which cause activation.
//
//----------------------------------------------------------------------------

void
CServer::PrepareActivationMessage(LPMSG lpmsg, LPMSG lpmsgSend)
{
    POINT   pt;
    HRESULT hr;

    Assert(State() >= OS_INPLACE && _pInPlace);

    // Assume no message to send by default.

    lpmsgSend->message = 0;

    if (!lpmsg)
        return;

    // We send only mouse messages. Derived classes can handle
    // keyboard messages in ActivateUI().

    if (lpmsg->message != WM_LBUTTONDOWN &&
             lpmsg->message != WM_RBUTTONDOWN &&
             lpmsg->message != WM_MBUTTONDOWN)
        return;

    pt = lpmsg->pt;

    if (_pInPlace->_hwnd)
    {
        // We need to re-hit-test (since the control may create child windows)
        // and re-translate mouse message coordinates.
        POINT   ptClient = pt;

        ScreenToClient(_pInPlace->_hwnd, &ptClient);
        lpmsgSend->hwnd = ChildWindowFromPointEx(
                _pInPlace->_hwnd,
                ptClient,
                CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);
    }
    else
    {
        hr = THR(_pInPlace->_pInPlaceSite->GetWindow(&lpmsgSend->hwnd));
        if (hr)
            return;
    }

    ScreenToClient(lpmsgSend->hwnd, &pt);
    lpmsgSend->message = lpmsg->message;
    lpmsgSend->wParam = lpmsg->wParam;
    lpmsgSend->lParam = MAKELONG(pt.x, pt.y);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::SendActivationMessage
//
//  Synopsis:   Sends message prepared by PrepareActivationMessage
//
//  Arguments:  lpmsg   Message to send.
//
//----------------------------------------------------------------------------

void
CServer::SendActivationMessage(LPMSG lpmsg)
{
    LRESULT lResult;

    if (lpmsg->message != 0)
    {
        if (_pInPlace->_hwnd)
        {
            SendMessage(lpmsg->hwnd,
                    lpmsg->message,
                    lpmsg->wParam,
                    lpmsg->lParam);
        }
        else
        {
            IGNORE_HR(OnWindowMessage(
                    lpmsg->message,
                    lpmsg->wParam,
                    lpmsg->lParam,
                    &lResult));
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     CServer::ActivateView
//
//  Synopsis:   Activate an IOleDocumentView
//
//---------------------------------------------------------------

HRESULT
CServer::ActivateView()
{
    HRESULT hr;
    IOleDocumentSite * pMsoDocSite = NULL;
    IOleDocumentView * pOleDocumentView = NULL;

    Assert(_fMsoDocMode);

    hr = THR(_pClientSite->QueryInterface(IID_IOleDocumentSite,
                 (void **)&pMsoDocSite));
    if (hr)
        goto Cleanup;

    hr = THR(PrivateQueryInterface(IID_IOleDocumentView, (void **)&pOleDocumentView));
    if (hr)
        goto Cleanup;
    
    hr = THR(pMsoDocSite->ActivateMe(pOleDocumentView));

Cleanup:
    ReleaseInterface(pOleDocumentView);
    ReleaseInterface(pMsoDocSite);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CServer::DoShow, public
//
//  Synopsis:   Implement an OLE verb by asking the client site to show
//              this object.
//
//  Arguments:  [pServer] -- pointer to a CServer object.
//
//              All other parameters are the same as the IOleObject::DoVerb
//              method.
//
//  Returns:    Success if the verb was successfully executed
//
//  Notes:      This and the other static Do functions are provided for
//              use in the server's verb table.  This verb results in
//              a ShowObject call on our container and a transition
//              to the U.I. active state
//
//---------------------------------------------------------------

HRESULT
CServer::DoShow(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT hr = S_OK;

    if (!pServer->_pClientSite)
        RRETURN(E_UNEXPECTED);

    if (pServer->_fMsoDocMode)
    {
        hr = THR(pServer->ActivateView());
    }
    else
    {
        IGNORE_HR(pServer->_pClientSite->ShowObject());
        pServer->_fHidden = FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member: CServer::DoHide, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_HIDE
//              This verb results in a transition to the Running state.
//
//---------------------------------------------------------------

HRESULT
CServer::DoHide(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT hr;

    if (pServer->_fMsoDocMode)
    {
        //
        //  If we're a docobj, then hide should not be called on us.
        //

        hr = E_UNEXPECTED;
    }
    else
    {
        hr = THR(pServer->TransitionTo(OS_RUNNING, lpmsg));
        if (OK(hr))
        {
            pServer->_fHidden = TRUE;
        }
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoUIActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_UIACTIVATE
//              This verb results in a transition to the U.I. active state.
//
//---------------------------------------------------------------

HRESULT
CServer::DoUIActivate(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT     hr;
    MSG         msg;

    if (pServer->_fMsoDocMode)
    {
        hr = THR(pServer->ActivateView());
    }
    else
    {
        // Get the server into the OS_INPLACE state so that we can setup
        // the activation message.

        if (pServer->State() < OS_INPLACE)
        {
            hr = THR(pServer->TransitionTo(OS_INPLACE, lpmsg));
            if (hr)
                goto Cleanup;
        }

        // Setup the activation message.   We do this before UI activating because
        // this server's screen position (used in setting up the message) can change
        // as a result of UI activation. This can happen because another server removes
        // its UI when deactivting or this server installs UI.

        pServer->PrepareActivationMessage(lpmsg, &msg);

        hr = THR(pServer->TransitionTo(OS_UIACTIVE, lpmsg));
        if (hr)
            goto Cleanup;

        pServer->SendActivationMessage(&msg);
    }

Cleanup:
    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoInPlaceActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_INPLACEACTIVATE
//              This verb results in a transition to the inplace state.
//
//---------------------------------------------------------------

HRESULT
CServer::DoInPlaceActivate(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT     hr;
    MSG         msg;

    if (pServer->_fMsoDocMode)
    {
        hr = THR(pServer->ActivateView());
    }
    else
    {
        hr = THR(pServer->TransitionTo(OS_INPLACE, lpmsg));
        if (!hr)
        {
            pServer->PrepareActivationMessage(lpmsg, &msg);
            pServer->SendActivationMessage(&msg);
        }

        pServer->_fHidden = FALSE;
        // Fixes VB4 problem where they call InPlaceActivate instead
        // of DoShow when setting visible=true.
    }

    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}


#if !defined(PRODUCT_RT) && !defined(PRODUCT_96)
//+---------------------------------------------------------------------------
//
//  Member:     CServer::DoProperties
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_PROPERTIES.
//              This verb results in bringing up the property frame on
//              this object.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::DoProperties(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT           hr;
    BSTR              bstrName    = NULL;
    LPTSTR            pszCaption  = NULL;
    IOleControlSite * pSite;
    HWND              hwnd        = NULL;

    Assert(pActiveSite);

    if (!pActiveSite->QueryInterface(IID_IOleControlSite, (LPVOID *) &pSite))
    {
        hr = THR(pSite->ShowPropertyFrame());
        ReleaseInterface(pSite);
        if (!hr)
            return S_OK;
    }

    //  Ignore failure to get display name; in this case, no
    //    display name is given in the property frame title

    hr = pServer->GetAmbientBstr(
            DISPID_AMBIENT_DISPLAYNAME,
            &bstrName);
    if (hr)
        goto Cleanup;

    hr = Format(FMT_OUT_ALLOC,
            &pszCaption, 128,
            MAKEINTRESOURCE(bstrName ? IDS_NAMEDCTRLPROPERTIES : IDS_CTRLPROPERTIES),
            bstrName);
    FormsFreeString(bstrName);

    if (hr)
        goto Cleanup;

    if (pServer->_pInPlace)
    {
        hwnd = pServer->_pInPlace->_hwnd;
    }
#ifndef PRODUCT_96

    int                    i;
    const CLSID * const *  apclsid;
    CLSID                  aclsid[32];

#ifdef NO_PROPERTY_PAGE
    apclsid = NULL;
#else
    apclsid = pServer->BaseDesc()->_apclsidPages;
#endif // NO_PROPERTY_PAGE

    if (!apclsid)
    {
        i = 0;
    }
    else
    {
        for (i = 0; i < ARRAY_SIZE(aclsid) && apclsid[i]; i++)
        {
            aclsid[i] = *apclsid[i];
        }
    }

    hr = THR(OleCreatePropertyFrame(
                hwnd,
                32,
                32,
                pszCaption,
                1,
                (IUnknown **)&pServer,
                i,
                aclsid,
                g_lcidUserDefault,
                0,
                NULL));
#else

    hr = THR(FormsCreatePropertyFrame(
                hwnd,
                32,
                32,
                pszCaption,
                1,
                (IUnknown **)&pServer,
                0,
                NULL,
                g_lcidUserDefault));

#endif
#if DBG == 1
    if (hr)
        TraceTag((tagError, "CServer::DoProperties -- "
                                  "CreatePropertyFrame failed: %lx.", hr));
#endif

Cleanup:
    FormsFreeString(bstrName);
    delete [] pszCaption;

    RRETURN(hr);
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DoUIActivateIfDesign, public
//
//  Synopsis:   Implement OLE Verb by showing the object in user mode or
//              transitioning to UI active state in design mode.  If
//              explicitly asked to UI activate the object in user mode,
//              we return E_NOTIMPL.
//
//----------------------------------------------------------------------------

HRESULT
CServer::DoUIActivateIfDesign(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    PFNDOVERB pfnDoVerb;
    BOOL      fUserMode;
    HRESULT   hr;

    fUserMode = pServer->GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);

    if (iVerb == OLEIVERB_UIACTIVATE && fUserMode)
    {
        hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
    }
    else
    {
        pfnDoVerb = fUserMode ? DoShow : DoUIActivate;
        hr = THR(pfnDoVerb(pServer,
                iVerb,
                lpmsg,
                pActiveSite,
                lindex,
                hwndParent,
                lprcPosRect));
    }

    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DoInPlaceActivateIfDesign, public
//
//  Synopsis:   If in design mode, transition to the inplace state.
//
//----------------------------------------------------------------------------

HRESULT
CServer::DoInPlaceActivateIfDesign(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    BOOL      fUserMode;
    HRESULT   hr;

    fUserMode = pServer->GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);

    Assert(iVerb == OLEIVERB_INPLACEACTIVATE);

    if (fUserMode)
    {
        hr = E_NOTIMPL;
    }
    else
    {
        hr = THR(DoInPlaceActivate(pServer,
                iVerb,
                lpmsg,
                pActiveSite,
                lindex,
                hwndParent,
                lprcPosRect));
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\sinpl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       sinpl.cxx
//
//  Contents:   Implementation of the CServer inplace functionality
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

DeclareTag(tagCServer, "Server", "Server base class stuff")
DeclareTag(tagRects,   "ServerRects", "Position rect, clip rect, extent")
MtDefine(CInPlace, CDoc, "CInPlace")

#ifndef NO_IME
extern BOOL DIMMHandleDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
#endif

#ifndef WS_EX_LAYOUTRTL // winuser.h defines this for WINVER >= 0x0500
#define WS_EX_LAYOUTRTL 0x00400000L //Right-to-left mirroring, as used in NT5
#endif

//  Size of in-place border

#define CX_IPBORDER     4
#define CY_IPBORDER     4
#define CX_HANDLEINSET  1
#define CY_HANDLEINSET  1


//+---------------------------------------------------------------------------
//
//  Function:   DrawUIActiveBorder
//
//  Synopsis:   Draw the UI Active border
//
//  Arguments:  hdcDraw     Draw into this dc.
//              prc         Draw border inside this rectangle.
//              fHatch      If true, draw hatch border
//              fHandles    If true, draw grab handles
//
//----------------------------------------------------------------------------

void
DrawUIActiveBorder(HDC hdcDraw, RECT * prc, BOOL fHatch, BOOL fHandles)
{
    int     i;
    GDIRECT    rc;
    HBRUSH  hbr;

    if (fHatch)
    {
        hbr = GetCachedBmpBrush(IDR_HATCHBMP);

        SetTextColor(hdcDraw, RGB(0, 0, 0));
        SetBkColor(hdcDraw, RGB(255, 255, 255));

        for (i = 0; i < 4; i++)
        {
            rc = *prc;

            switch (i)
            {
                case 0:  rc.right  = rc.left   + CX_IPBORDER; break;
                case 1:  rc.left   = rc.right  - CX_IPBORDER; break;
                case 2:  rc.bottom = rc.top    + CY_IPBORDER; break;
                case 3:  rc.top    = rc.bottom - CY_IPBORDER; break;
            }

            FillRect(hdcDraw, &rc, hbr);
        }
    }

    if (fHandles)
    {
        hbr = (HBRUSH) GetStockObject(BLACK_BRUSH);

        //
        // Grab handle rectangles:
        //
        //   +-----+------+----+------+-----+
        //   |  0  |      | 1  |      |  2  |
        //   +---+-+      +----+      +-+---+
        //   | 3 |                      | 4 |
        //   +---+                      +---+
        //   |                              |
        //   |                              |
        //   +---+                      +---+
        //   | 5 |                      | 6 |
        //   +---+                      +---+
        //   |                              |
        //   |                              |
        //   +---+                      +---+
        //   | 7 |                      | 8 |
        //   +---+-+      +----+      +-+---+
        //   |  9  |      | 10 |      | 11  |
        //   +-----+------+----+------+-----+
        //

        for (i = 0; i < 12; i++)
        {

            // Compute left and right of rectangle.

            switch (i)
            {
                case 3:
                case 5:
                case 7:
                    rc.left = prc->left;
                    rc.right = rc.left + CX_IPBORDER;
                    break;

                case 0:
                case 9:
                    rc.left = prc->left;
                    rc.right = rc.left + CX_IPBORDER + CX_HANDLEINSET;
                    break;

                case 1:
                case 10:
                    rc.left = (prc->left + prc->right - CX_IPBORDER) / 2;
                    rc.right = rc.left + CX_IPBORDER + CX_HANDLEINSET;
                    break;

                case 2:
                case 11:
                    rc.right = prc->right;
                    rc.left = rc.right - CX_IPBORDER - CX_HANDLEINSET;
                    break;

                case 4:
                case 6:
                case 8:
                    rc.right = prc->right;
                    rc.left = rc.right - CX_IPBORDER;
                    break;
            }

            // Compute top and bottom of rectangle.

            switch (i)
            {
                case 0:
                case 1:
                case 2:
                    rc.top = prc->top;
                    rc.bottom = rc.top + CY_IPBORDER;
                    break;

                case 3:
                case 4:
                    rc.top = prc->top + CY_IPBORDER;
                    rc.bottom = rc.top + CY_HANDLEINSET;
                    break;

                case 5:
                case 6:
                    rc.top = (prc->top + prc->bottom - CY_IPBORDER) / 2;
                    rc.bottom = rc.top + CY_IPBORDER + CY_HANDLEINSET;
                    break;

                case 7:
                case 8:
                    rc.top = prc->bottom - CY_IPBORDER - CY_HANDLEINSET;
                    rc.bottom = rc.top + CY_HANDLEINSET;
                    break;

                case 9:
                case 10:
                case 11:
                    rc.bottom = prc->bottom;
                    rc.top = rc.bottom - CY_IPBORDER;
                    break;
            }

            FillRect(hdcDraw, &rc, hbr);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CInPlace
//
//  Synopsis:   CInPlace object constructor
//
//  Arguments:  [pServer] -- CServer object that owns us
//
//----------------------------------------------------------------------------

CInPlace::CInPlace()
{
    _fUIDown        = TRUE;
    _fFrameActive   = TRUE;
    _fDocActive     = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInPlace
//
//  Synopsis:   CInPlace object destructor
//
//----------------------------------------------------------------------------

CInPlace::~CInPlace()
{
    ClearInterface(&_pInPlaceSite);
    ClearInterface(&_pFrame);
    ClearInterface(&_pDoc);
    ClearInterface(&_pDataObj);
    Assert(!_hwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureInPlaceObject, CServer
//
//  Synopsis:   Creates the InPlace object when needed.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

HRESULT
CServer::EnsureInPlaceObject()
{
    if (!_pInPlace)
    {
        _pInPlace = new CInPlace();
        if (!_pInPlace)
            RRETURN(E_OUTOFMEMORY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::ActivateInPlace, CServer
//
//  Synopsis:   In-place activates the object
//
//  Returns:    Success if we in-place activated properly
//
//  Notes:      This method implements the standard in-place activation
//              protocol and creates the in-place window.
//
//----------------------------------------------------------------------------

HRESULT
CServer::ActivateInPlace(LPMSG lpmsg)
{
    HRESULT     hr;
    HWND        hWndSite;
    RECT        rcPos;
    RECT        rcVisible;
    BOOL        fUsingWindowlessSite = FALSE;
    BOOL        fNoRedraw = FALSE;
    WORD        wLockFlags;

    if (!_pClientSite)
        RRETURN(E_UNEXPECTED);

    hr = THR(EnsureInPlaceObject());
    if (hr)
        RRETURN(hr);

    Assert(_pInPlace);
    Assert(_pInPlace->_fWindowlessInplace == FALSE);
    _pInPlace->_fDeactivating = FALSE;

    // If we were not handed an inplace site through the
    // docobj interfaces, then negotiate for one now.

    if (!_pInPlace->_pInPlaceSite)
    {
        if (OK(_pClientSite->QueryInterface(
                    IID_IOleInPlaceSiteWindowless,
                    (void **)&_pInPlace->_pInPlaceSite)))
        {
            fUsingWindowlessSite = TRUE;
            _pInPlace->_fUseExtendedSite = TRUE;
        }
        else if (OK(_pClientSite->QueryInterface(
                IID_IOleInPlaceSiteEx,
                (void **)&_pInPlace->_pInPlaceSite)))
        {
            _pInPlace->_fUseExtendedSite = TRUE;
        }
        else
        {
            hr = THR(_pClientSite->QueryInterface(
                    IID_IOleInPlaceSite,
                    (void **) &(_pInPlace->_pInPlaceSite)));
            if (hr)
                goto Error;
        }
    }

    Assert(_pInPlace->_pInPlaceSite != NULL);

    hr = THR(_pInPlace->_pInPlaceSite->CanInPlaceActivate());
    if (hr == S_FALSE)
    {
        TraceTag((tagError, "Container refused InPlace activation!"));

        hr = E_FAIL;
        goto Error;
    }
    else if (hr)
        goto Error;

    if (_fWindowless && fUsingWindowlessSite)
    {
        hr = ((IOleInPlaceSiteWindowless *)
                (_pInPlace->_pInPlaceSite))->CanWindowlessActivate();
        _pInPlace->_fWindowlessInplace = (hr == S_OK);
    }

    // get information about position, size etc.

    _pInPlace->_frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

    hr = THR(_pInPlace->_pInPlaceSite->GetWindowContext(
                                        &_pInPlace->_pFrame,
                                        &_pInPlace->_pDoc,
                                        ENSUREOLERECT(&_pInPlace->_rcPos),
                                        ENSUREOLERECT(&_pInPlace->_rcClip),
                                        &_pInPlace->_frameInfo));
    if (hr)
        goto Error;

    if (_fMsoDocMode)
    {
        // Our _sizel has to match our view rect

        SIZEL sizel;

        sizel.cx = HimetricFromHPix(_pInPlace->_rcPos.right - _pInPlace->_rcPos.left);
        sizel.cy = HimetricFromVPix(_pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top);

        SetExtent(DVASPECT_CONTENT, &sizel);
    }

    // Check for the container requesting an infinite scale factor.

    if ((_sizel.cx == 0 && _pInPlace->_rcPos.right - _pInPlace->_rcPos.left != 0) ||
        (_sizel.cy == 0 && _pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top != 0))
    {
        Assert(0 && "Host error: Infinite scale factor. Not a Forms error.");
        hr = E_FAIL;
        goto Error;
    }

    TraceTag((tagRects,
            "%08lx ActivateInPlace context pos=%ld %ld %ld %ld; clip=%ld %ld %ld %ld",
            this, _pInPlace->_rcPos, _pInPlace->_rcClip));

    DbgTrackItf(IID_IOleInPlaceFrame, "HostFrame", TRUE, (void **)&_pInPlace->_pFrame);

    TraceTag((tagRects, "%08lx ActivateInPlace extent=%ld %ld", this, _sizel.cx, _sizel.cy));

    if (!_pInPlace->_fWindowlessInplace)
    {
        rcPos = _pInPlace->_rcPos;

        _pInPlace->_ptWnd  = *(POINT *)&_pInPlace->_rcPos;
        OffsetRect(&_pInPlace->_rcPos,
                -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);
        OffsetRect(&_pInPlace->_rcClip,
                -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);

        hr = THR(_pInPlace->_pInPlaceSite->GetWindow(&hWndSite));
        if (hr)
            goto Error;

        TraceTag((tagRects, "%08lx ActivateInPlace > AttachWin %ld %ld %ld %ld", this, rcPos));

        hr = THR(AttachWin(hWndSite, &rcPos, &_pInPlace->_hwnd));
        if (hr)
            goto Error;

        IntersectRect(&rcVisible, &_pInPlace->_rcPos, &_pInPlace->_rcClip);
        if (!EqualRect(&rcVisible, &_pInPlace->_rcPos))
        {
            _pInPlace->_fUsingWindowRgn = TRUE;
            SetWindowRgn(_pInPlace->_hwnd, CreateRectRgnIndirect(&rcVisible), FALSE);
        }

    }
    else
    {
        _pInPlace->_ptWnd.x = _pInPlace->_ptWnd.y = 0;
    }

    //  Notify our container that we are going in-place active.
    //    Since the container may move us to some new state during
    //    the notification, we need to remember that we're already
    //    transitioning to OS_INPLACE.  If the container refuses
    //    the activation, then we unwind the partial transiton.

    _state = OS_INPLACE;

    wLockFlags = Unlock(SERVERLOCK_TRANSITION);

    if (_pInPlace->_fUseExtendedSite)
    {
        hr = THR(((IOleInPlaceSiteEx *)_pInPlace->_pInPlaceSite)->
                OnInPlaceActivateEx(&fNoRedraw,
                    _pInPlace->_fWindowlessInplace ? ACTIVATE_WINDOWLESS : 0));
    }
    else
    {
        hr = THR(_pInPlace->_pInPlaceSite->OnInPlaceActivate());
    }

    Relock(wLockFlags);

    if (hr)
    {
        if (_state == OS_INPLACE)
            _state = OS_RUNNING;

        goto Error;
    }

    if (!fNoRedraw)
    {
        InvalidateRect(NULL, TRUE);
    }

Cleanup:
    RRETURN(hr);

Error:
    IGNORE_HR(DeactivateInPlace());
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUpdateEnum
//
//  Synopsis:   Called from EnumChildWindows, used to determine if
//              there's an update region for a child window.
//
//----------------------------------------------------------------------------

static BOOL CALLBACK
GetUpdateEnum(HWND hwnd, LPARAM lparam)
{
    if (GetUpdateRect(hwnd, (RECT *)NULL, 0))
    {
        *(BOOL *)lparam = TRUE;
        return FALSE;
    }
    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::DeactivateInPlace, CServer
//
//  Synopsis:   In-place deactivates the object
//
//  Returns:    Success except for catastophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateInPlace
//              including destroying the inplace active window.
//
//---------------------------------------------------------------

HRESULT
CServer::DeactivateInPlace()
{
    IOleInPlaceSite *   pInPlaceSite;
    BOOL                fRedraw;
    WORD                wLockFlags;

    Assert(_pInPlace);

    if (_pInPlace->_fUseExtendedSite && _pInPlace->_hwnd)
    {
        Assert(IsWindow(_pInPlace->_hwnd));
        fRedraw = GetUpdateRect(_pInPlace->_hwnd, (RECT *)NULL, 0);
        if (!fRedraw)
        {
            EnumChildWindows(_pInPlace->_hwnd, GetUpdateEnum, (LPARAM)&fRedraw);
        }
        SetWindowPos(_pInPlace->_hwnd, NULL, 0, 0, 0, 0,
                SWP_HIDEWINDOW | SWP_NOMOVE | SWP_NOSIZE |
                SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
    }
    else
    {
        fRedraw = FALSE;
    }

    DetachWin();

    ClearInterface(&_pInPlace->_pFrame);
    ClearInterface(&_pInPlace->_pDoc);

    //  We use the in place site to send notification below, but
    //    we want to be fully deactivated before we make the call
    //    so that the container can reenter us.  To make this easier,
    //    we NULL out our member variable, but save the value for
    //    later use (and Release()'ing)

    pInPlaceSite = _pInPlace->_pInPlaceSite;

    //
    // Only do this if we were not activated as a docobject.
    // Is it ok to skip all the notifications down below?
    //
    
    if (!_fMsoDocMode)
    {
        _pInPlace->_pInPlaceSite = NULL;
    }

    _pInPlace->_fWindowlessInplace = FALSE;

    //  Notify our container that we're in-place deactivating

    Assert(_state == OS_INPLACE || _state == OS_RUNNING);
    if (_state == OS_INPLACE)
    {
        //  The container may reenter us, so need to remember that
        //    we've done almost all the transition to OS_RUNNING

        _state = OS_RUNNING;

        //  Errors from this notification are ignored (in the function
        //    which calls this one); we don't allow our container to stop
        //    us from in-place deactivating

        if (pInPlaceSite)
        {
            //  We allow the container to reenter us during this
            //    transition, so we need to unlock ourselves

            wLockFlags = Unlock(SERVERLOCK_TRANSITION);

            if (_pInPlace->_fUseExtendedSite)
            {
                IGNORE_HR(((IOleInPlaceSiteEx *)pInPlaceSite)->
                        OnInPlaceDeactivateEx(!fRedraw));
            }
            else
            {
                IGNORE_HR(pInPlaceSite->OnInPlaceDeactivate());
            }

            Relock(wLockFlags);
        }
    }

    if (!_fMsoDocMode)
    {
        ReleaseInterface(pInPlaceSite);
    }

    delete _pInPlace;
    _pInPlace = NULL;

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ActivateUI, CServer
//
//  Synopsis:   Notifies container of U.I. activation and installs our
//              U.I. elements.
//
//  Returns:    Success if our container granted permission to U.I. activate.
//
//  Notes:      Installing our U.I. (border toolbars, floating palettes,
//              adornments) is accomplished via a virtual call to InstallUI.
//
//---------------------------------------------------------------

HRESULT
CServer::ActivateUI(LPMSG lpmsg)
{
    HRESULT     hr;
    WORD        wLockFlags;

    Assert(_pInPlace);
    Assert(_pInPlace->_pInPlaceSite);

    //  We must remember we're in the process of UI Activating,
    //    since the container may move us to some new state
    //    in its notification method

    _state = OS_UIACTIVE;

    //  We allow the container to reenter us during this notification,
    //    so we need to unlock ourselves

    wLockFlags = Unlock(SERVERLOCK_TRANSITION);

    hr = THR(_pInPlace->_pInPlaceSite->OnUIActivate());

    Relock(wLockFlags);

    if (hr)
    {
        //  If the container fails the OnUIActivate call, then we
        //    give up and stay IPA

        if (_state == OS_UIACTIVE)
            _state = OS_INPLACE;

        goto Cleanup;
    }

    //  NOTE: this is almost (but not quite) robust enough.  If by
    //    some quirk of fate the container caused us to de-UIActivate,
    //    then re-UIActivate us in the OnUIActivate call, then we
    //    would mistakenly re-install our UI below

    if (_state == OS_UIACTIVE && !_pInPlace->_fChildActivating)
    {
        hr = THR(InstallUI());
        if (hr)
            goto Error;

        if (!_fMsoDocMode &&
            (GetAmbientBool(DISPID_AMBIENT_SHOWHATCHING, TRUE) ||
             GetAmbientBool(DISPID_AMBIENT_SHOWGRABHANDLES, TRUE)))
        {
            ShowUIActiveBorder(TRUE);
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    DeactivateUI();
    goto Cleanup;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DeactivateUI, CServer
//
//  Synopsis:   Removes any U.I. we have installed and notifies our container
//              that we are no longer U.I. active
//
//  Returns:    Success except for catastrophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateUI.
//              U.I. elements are removed via a virtual call to RemoveUI
//
//---------------------------------------------------------------

HRESULT
CServer::DeactivateUI(void)
{
    WORD wLockFlags;

    //  Remove any UI that is up

    RemoveUI();
    ShowUIActiveBorder(FALSE);

    Assert(_pInPlace);

    _state = OS_INPLACE;

    //  Notify our container that we have deactivated.  Note that
    //    we don't let our container prevent us from UI Deactivating

    //  We need to unlock ourselves in case the container wants
    //    to reenter us during the OnUIDeactivate notification

    wLockFlags = Unlock(SERVERLOCK_TRANSITION);

    IGNORE_HR(_pInPlace->_pInPlaceSite->OnUIDeactivate(FALSE));

    Relock(wLockFlags);

    return S_OK; 
}


//+---------------------------------------------------------------
//
//  Member:     CServer::InstallUI, CServer
//
//  Synopsis:   Installs previously created U.I. so it is displayed to
//              the user.
//
//  Notes:      This method will call the installframeUI and InstallDocUI
//              methods to install those U.I. elements, respectively.
//
//---------------------------------------------------------------

HRESULT
CServer::InstallUI(
    BOOL    fSetFocus)
{
    HRESULT hr = S_OK;

    if (!_pInPlace->_fChildActivating && !_pInPlace->_fDeactivating)
    {
        _pInPlace->_fUIDown = FALSE;

#ifndef NO_OLEUI
        hr = THR(InstallFrameUI());
        if (hr)
            goto Error;

        hr = THR(InstallDocUI());
        if (hr)
            goto Error;
#endif // NO_OLEUI

        // Set focus if requested
        // CONSIDER: This could perhaps be better tracked by watching the activation
        //         state of our container rather than passing flags into this routine.
        //         Unfortunately, tracking activation is difficult in the 96 code base.
        if (fSetFocus)
        {
            SetFocus(TRUE);
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    RemoveUI();
    goto Cleanup;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::RemoveUI, CServer
//
//  Synopsis:   Removes previously installed U.I. so it is hidden from the
//              the user.
//
//  Notes:      This method "undoes" everything done in InstallUI.  It calls
//              the RemoveFrameUI and RemoveDocUI methods.
//
//---------------------------------------------------------------

void
CServer::RemoveUI(void)
{
    if (!_pInPlace->_fUIDown)
    {
        _pInPlace->_fUIDown = TRUE;

#ifndef NO_OLEUI
        RemoveDocUI();
        RemoveFrameUI();
#endif // NO_OLEUI
    }
}

//+--------------------------------------------------------------
//
//  Member:     CServer::DetachWin, CServer
//
//  Synopsis:   Detaches the child's in-place
//              window from the current parent.
//
//  Notes:      This destroys the _hwnd of the server.
//              If the derived class does anything
//              other than create a Window on AttachWin,
//              it must over-ride this function.
//              If the derived class destroys the window
//              on detach, it must set _hwnd = NULL
//
//---------------------------------------------------------------

void
CServer::DetachWin()
{
    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        Assert(IsWindow(_pInPlace->_hwnd));
        Verify(DestroyWindow(_pInPlace->_hwnd));
        _pInPlace->_hwnd = NULL;
    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        // Do windowless equivalent of DestroyWindow here.

        if (_pInPlace->_fFocus)
        {
            IGNORE_HR(((IOleInPlaceSiteWindowless*)
                    (_pInPlace->_pInPlaceSite))->SetFocus(FALSE));
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     CServer::InstallFrameUI, CServer
//
//  Synopsis:   Installs the U.I. elements on the frame window.
//              This function assumes the server has does not
//              have any UI.  Derived classes should override
//              to provide their own UI.
//
//---------------------------------------------------------------

#ifndef NO_OLEUI
HRESULT
CServer::InstallFrameUI()
{
    THR_NOTRACE(_pInPlace->_pFrame->SetMenu(NULL, NULL, NULL));
    THR_NOTRACE(_pInPlace->_pFrame->SetBorderSpace(NULL));

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::RemoveFrameUI, CServer
//
//  Synopsis:   Removes the U.I. elements on the frame window
//
//  Notes:      This method "undoes" everything that was done in
//              InstallFrameUI -- it removes the shared menu from
//              the frame.
//
//              Servers that override the InstallFrameUI method will
//              also want to override this method.
//              This method is call by the RemoveUI method and on
//              document window deactivation for MDI-application purposes.
//
//---------------------------------------------------------------

void
CServer::RemoveFrameUI()
{
    if (_pInPlace->_pFrame)
    {
        IGNORE_HR(_pInPlace->_pFrame->SetMenu(NULL, NULL, NULL));
        THR_NOTRACE(_pInPlace->_pFrame->SetBorderSpace(NULL));
    };
}


//+---------------------------------------------------------------
//
//  Member:     CServer::InstallDocUI, protected
//
//  Synopsis:   Installs the U.I. elements on the document window
//
//  Notes:      This method notifies the document window that we are
//              the active object.  Otherwise, there are no standard U.I. elements
//              installed on the document window.
//
//              Servers that have document window tools should override this
//              method.
//
//---------------------------------------------------------------

HRESULT
CServer::InstallDocUI(void)
{
    HRESULT hr = S_OK;
    TCHAR   ach[MAX_USERTYPE_LEN + 1];
    IOleInPlaceActiveObject *pInPlaceActiveObject = NULL;

    Assert(_pInPlace);

    if (_pInPlace->_pDoc != NULL)
    {
        Verify(LoadString(
                GetResourceHInst(),
                IDS_USERTYPESHORT(BaseDesc()->_idrBase),
                ach,
                ARRAY_SIZE(ach)));

        hr = THR(PrivateQueryInterface(IID_IOleInPlaceActiveObject, (void **)&pInPlaceActiveObject));
        if (hr)
            goto Cleanup;

        hr = THR(_pInPlace->_pDoc->SetActiveObject(pInPlaceActiveObject, ach));
        if (hr)
            goto Error;

        IGNORE_HR(_pInPlace->_pDoc->SetBorderSpace(NULL));
    }

Cleanup:
    ReleaseInterface(pInPlaceActiveObject);
    RRETURN(hr);

Error:
    RemoveDocUI();
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::RemoveDocUI, protected
//
//  Synopsis:   Removes the U.I. elements from the document window.
//
//  Notes:      This method "undoes" everything done in the InstallDocUI
//              method.
//
//              Servers that override the InstallDocUI method should
//              also override this method.
//
//---------------------------------------------------------------

void
CServer::RemoveDocUI(void)
{
    Assert(_pInPlace);

    if (_pInPlace->_pDoc != NULL)
    {
        _pInPlace->_pDoc->SetActiveObject(NULL, NULL);
    }
}
#endif // NO_OLEUI


//+---------------------------------------------------------------
//
//  Member:     CServer::GetHWND()
//
//  Synopsis:   Get window used by this CServer.
//
//---------------------------------------------------------------

HWND
CServer::GetHWND()
{
    // WARNING:  This code is very sensitive to the code
    // generator.  The alaising in the last else of the
    // ladder avoids the problem.  If you change this code,
    // please test it by right-clicking a UIActive MPC on
    // the "tab" in a ship build during design mode.  The
    // context menu should appear in the correct place and
    // be functional.  <rodc>

    HWND    hwnd;

    if (State() < OS_INPLACE)
    {
        hwnd = NULL;
    }
    else if (_pInPlace->_hwnd)
    {
        hwnd = _pInPlace->_hwnd;
    }
    else
    {
        HWND *  phwndtmp = &hwnd;

        if (_pInPlace->_pInPlaceSite->GetWindow(phwndtmp))
            hwnd = NULL;
    }

    return hwnd;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetWindow, IOleWindow
//
//  Synopsis:   Method of IOleWindow interface
//
//---------------------------------------------------------------

HRESULT
CServer::GetWindow(HWND FAR* lphwnd)
{
    if (_pInPlace == NULL)
        RRETURN_NOTRACE(E_FAIL);

    *lphwnd = _pInPlace->_hwnd;

#ifdef _MAC
	if (*lphwnd == NULL)
		*lphwnd = GetHWND();

    RRETURN_NOTRACE((*lphwnd ? S_OK : E_FAIL));
#else
    RRETURN_NOTRACE((_pInPlace->_hwnd ? S_OK : E_FAIL));
#endif
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ContextSensitiveHelp, IOleWindow
//
//  Synopsis:   Method of IOleWindow interface
//
//  Notes:      This method sets or clears the _fCSHelpMode
//              member flag.  The window procedure needs to pay
//              attention to the value of this flag in implementing
//              context-sensitive help.
//
//---------------------------------------------------------------

HRESULT
CServer::ContextSensitiveHelp(BOOL fEnterMode)
{
    _pInPlace->_fCSHelpMode = fEnterMode;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::InPlaceDeactivate, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method transitions the object to the loaded state
//              if the object is in the InPlace or U.I. active state.
//
//---------------------------------------------------------------

HRESULT
CServer::InPlaceDeactivate(void)
{
    HRESULT hr = S_OK;

    if (State() == OS_INPLACE || State() == OS_UIACTIVE)
    {
        _pInPlace->_fDeactivating = TRUE;
        hr = THR(TransitionTo(OS_RUNNING));

        //  If the in-place object is still around, clear the
        //    flag.  Note that the in-place object may have been
        //    destroyed by the transition to the OS_RUNNING state,
        //    or may not if the container is caching a pointer to
        //    any of the in-place interfaces. (chrisz)


        if (_pInPlace)
        {
            _pInPlace->_fDeactivating = FALSE;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::UIDeactivate, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      The method transitions the object to the in-place state
//              if the object is in U.I. active state.
//
//---------------------------------------------------------------

HRESULT
CServer::UIDeactivate(void)
{
    HRESULT hr = S_OK; 
    if (State() == OS_UIACTIVE)
    {
        _pInPlace->_fDeactivating = TRUE;
        hr = TransitionTo(OS_INPLACE);
        _pInPlace->_fDeactivating = FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetObjectRects, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method does a Move window on the child
//              window to put it in its new position.
//
//---------------------------------------------------------------

HRESULT
CServer::SetObjectRects(LPCOLERECT prcPos, LPCOLERECT prcClip)
{
    HRESULT     hr = S_OK;
    RECT        rcWnd;
    RECT        rcVisible;

    if (!prcPos)
        RRETURN(E_INVALIDARG);

    Assert(State() >= OS_INPLACE);
    Assert(_pInPlace);
    Assert(_pInPlace->_pInPlaceSite);
    Assert(prcPos->left <= prcPos->right);
    Assert(prcPos->top <= prcPos->bottom);

    if (State() < OS_INPLACE)
        RRETURN(E_UNEXPECTED);

    // Handle bogus call from MFC container with NULL clip rectangle...
    if (!prcClip)
    {
        prcClip = prcPos;
    }

    TraceTag((tagRects,
            "%08lx SetObjectRects pos=%ld %ld %ld %ld; clip=%ld %ld %ld %ld",
            this, *prcPos, *prcClip));

    // Check for the container requesting an infinite scale factor.

    if ((_sizel.cx == 0 && prcPos->right - prcPos->left != 0) ||
        (_sizel.cy == 0 && prcPos->bottom - prcPos->top != 0))
    {
        Assert(0 && "Host error: Infinite scale factor. Not a Forms error.");
        RRETURN(E_FAIL);
    }

    //
    // Update the inplace RECTs and offsets
    //

    if (_pInPlace->_fWindowlessInplace)
    {
        CopyRect(&_pInPlace->_rcPos, prcPos);
        CopyRect(&_pInPlace->_rcClip,prcClip);
    }
    else
    {
        Assert(_pInPlace->_hwnd);

        // Because we set _pInPlace->_rcPos to match the extent
        // in IOleObject::SetExtent, a change in the size of the
        // positon rectangle here implies that the container is
        // scaling us.

/*
        if ((_pInPlace->_rcPos.right - _pInPlace->_rcPos.left !=
                prcPos->right - prcPos->left ||
            _pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top !=
                prcPos->bottom - prcPos->top))
        {
            // Handle change in scaling.
            //::InvalidateRect ( _pInPlace->_hwnd, NULL, TRUE );
            RedrawWindow(_pInPlace->_hwnd,
                (GDIRECT *)NULL, NULL, RDW_ERASE | RDW_ALLCHILDREN | RDW_INVALIDATE);
        }
*/

        _pInPlace->_ptWnd = *(POINT *)&prcPos->left;

        CopyRect(&_pInPlace->_rcPos, prcPos);
        OffsetRect(&_pInPlace->_rcPos,  -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);

        CopyRect(&_pInPlace->_rcClip, prcClip);
        OffsetRect(&_pInPlace->_rcClip, -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);

        CopyRect(&rcWnd, prcPos);
        if (_pInPlace->_fShowBorder)
        {
            InflateRect(&rcWnd, CX_IPBORDER, CY_IPBORDER);
        }

        IntersectRect(&rcVisible, &rcWnd, prcClip);
        if (EqualRect(&rcVisible, &rcWnd))
        {
            if (_pInPlace->_fUsingWindowRgn)
            {
                SetWindowRgn(_pInPlace->_hwnd, NULL, TRUE);
                _pInPlace->_fUsingWindowRgn = FALSE;
            }
        }
        else 
        {
            _pInPlace->_fUsingWindowRgn = TRUE;
            OffsetRect(&rcVisible, -rcWnd.left, -rcWnd.top);
            SetWindowRgn(_pInPlace->_hwnd,
                    CreateRectRgnIndirect(&rcVisible),
                    TRUE);
        }

        // we go to some trouble here to make sure we aren't calling SetWindowPos
        // with invalid area in our window, because Windows sends a WM_ERASEBKGND
        // message to our window and all child windows if it finds a completely
        // invalid window at the time that SetWindowPos is called.  This causes
        // truly disastrous flashing to occur when we are resizing the window.
        HRGN hrgnUpdate = ::CreateRectRgnIndirect(&g_Zero.rc);
        if (hrgnUpdate)
        {
            int result = ::GetUpdateRgn(_pInPlace->_hwnd, hrgnUpdate, FALSE);
            if (result != ERROR && result != NULLREGION)
            {
                ::ValidateRgn(_pInPlace->_hwnd, hrgnUpdate);
            }
            else
            {
                ::DeleteObject(hrgnUpdate);
                hrgnUpdate = NULL;
            }
        }

        TraceTag((tagRects, "%08lx SetObjectRects > SetWindowPos %ld %ld %ld %ld", this, rcWnd));
        
        SetWindowPos(_pInPlace->_hwnd, NULL, rcWnd.left, rcWnd.top,
                rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top,
                SWP_NOZORDER | SWP_NOACTIVATE);

        // restore previously invalid area
        if (hrgnUpdate)
        {
            // NOTE: The above call to SetWindowPos may have caused Trident to
            // be synchronously re-entered, and we may have transitioned to
            // not OS_INPLACE, which would leave _pInPlace NULL.  We have to
            // check it before using it again.
            if (_pInPlace && _pInPlace->_hwnd)
                ::InvalidateRgn(_pInPlace->_hwnd, hrgnUpdate, FALSE);
            ::DeleteObject(hrgnUpdate);
        }
    }

    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ReactivateAndUndo, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method activates us, but doesn't do anything else.
//              Anyone who supports undo should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::ReactivateAndUndo(void)
{
    HRESULT     hr;

    hr = THR(TransitionTo(OS_UIACTIVE));

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CServer::TranslateAccelerator, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceActiveObject interface
//
//---------------------------------------------------------------

HRESULT
CServer::TranslateAccelerator(LPMSG lpmsg)
{
    HRESULT hr = S_FALSE;
    CLock   Lock(this);
    VARIANT_BOOL    fEnabled;

    // if we are a form this will get called
    // because we are our own inplace object
    // but we want to bail out if we are disabled
    THR(GetEnabled(&fEnabled));
    if (!fEnabled)
    {
        // Call CServer::DoTranslateAccelerator to forward the key
        // up to the site.
        hr = THR(CServer::DoTranslateAccelerator(lpmsg));
    }
    else if (lpmsg->message >= WM_KEYFIRST && lpmsg->message <= WM_KEYLAST)
    {
        hr = THR_NOTRACE(DoTranslateAccelerator(lpmsg));
    }

    //
    // If we are merging menus, let the frame have a crack at 
    // translating accelerators.  The call to OleTranslateAccelerator
    // is necessary even though we're an in-proc server because 
    // the frame has no way of knowing where to route menu messages
    // otherwise.  Without this, things like Alt+E, C will not
    // work correctly.  (anandra)
    //
    
    if (S_FALSE == hr &&
        _pInPlace &&
        _pInPlace->_pFrame &&
        _pInPlace->_fMenusMerged)
    {
        hr = THR(OleTranslateAccelerator(
                _pInPlace->_pFrame, 
                &_pInPlace->_frameInfo, 
                lpmsg));
    }

    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoTranslateAccelerator, CServer
//
//  Synopsis:   Helper method for TranslateAccelerator.
//              Derived control classes should override this method
//              rather than TranslateAccelerator
//
//---------------------------------------------------------------

HRESULT
CServer::DoTranslateAccelerator(LPMSG lpmsg)
{
    HRESULT hr = S_FALSE;
    IOleControlSite * pCtrlSite;

    if (_pClientSite &&
        !THR_NOTRACE(_pClientSite->QueryInterface(
                IID_IOleControlSite,
                (void**) &pCtrlSite)))
    {
            hr = THR(pCtrlSite->TranslateAccelerator(lpmsg, VBShiftState()));
            pCtrlSite->Release();
    }

    RRETURN1_NOTRACE(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::OnFrameWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------

HRESULT
CServer::OnFrameWindowActivate(BOOL fActivate)
{
    if (_pInPlace)
    {
        if (fActivate && _state == OS_UIACTIVE && !_pInPlace->_fChildActive)
        {
            // Set focus unless a child window has focus already
            HWND hwndFocus = ::GetFocus();
            
            if (!(hwndFocus && _pInPlace->_hwnd && ::IsChild(_pInPlace->_hwnd, hwndFocus)))
            {
                SetFocus(TRUE);
            }
        }

        _pInPlace->_fFrameActive = fActivate;
    }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::OnDocWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method will install or remove the frame
//              U.I. elements using the InstallFrameUI or RemoveFrameUI
//              methods.  This is to properly handle the MDI application
//              case.  It also updates our shading color.
//
//---------------------------------------------------------------

HRESULT
CServer::OnDocWindowActivate(BOOL fActivate)
{
    HRESULT hr = S_OK;

#ifndef NO_OLEUI
    if (!_pInPlace)
        goto Cleanup;

    if (fActivate)
    {
        hr = THR(InstallFrameUI());
    }
    else
    {
        RemoveFrameUI();
    }
#endif // NO_OLEUI

    if (!hr)
    {
        Assert(_pInPlace);

        _pInPlace->_fDocActive = fActivate;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ResizeBorder, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      There are no standard border adornments so we do
//              nothing in this method.  Servers that have additional
//              U.I. elements that are installed on the frame or
//              document windows should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::ResizeBorder(
        LPCOLERECT lprc,
        LPOLEINPLACEUIWINDOW pUIWindow,
        BOOL fFrameWindow)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::EnableModeless, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------

HRESULT
CServer::EnableModeless(BOOL fEnable)
{
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::ShowUIActiveBorder
//
//  Synopsis:   Shows or hides the UI Active border for this object
//
//  Arguments:  [fShowBorder]   --  TRUE to show it
//
//-------------------------------------------------------------------------

void
CServer::ShowUIActiveBorder(BOOL fShowBorder)
{
    RECT    rc;

    Assert(State() >= OS_INPLACE);

    if (!_pInPlace->_hwnd)
        return;

    if (_pInPlace->_fShowBorder == (unsigned) fShowBorder)
        return;

    _pInPlace->_fShowBorder = fShowBorder;

    rc = _pInPlace->_rcPos;

    if (fShowBorder)
    {
        InflateRect(&rc, CX_IPBORDER, CY_IPBORDER);
    }

    TraceTag((tagRects, "%08lx ShowUIActiveBorder > SetWindowPos %ld %ld %ld %ld",
            this,
            rc.left + _pInPlace->_ptWnd.x,
            rc.top + _pInPlace->_ptWnd.y,
            rc.right - rc.left + _pInPlace->_ptWnd.x,
            rc.bottom - rc.top + _pInPlace->_ptWnd.y));

    SetWindowPos(
            _pInPlace->_hwnd,
            NULL,
            rc.left + _pInPlace->_ptWnd.x,
            rc.top + _pInPlace->_ptWnd.y,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnPaint
//
//  Synopsis:   Draws the client area when a window is present
//
//-------------------------------------------------------------------------

void
CServer::OnPaint()
{
    HDC hdc;
    PAINTSTRUCT ps;

    Assert(_pInPlace);
    Assert(_pInPlace->_hwnd);

    if (TestLock(SERVERLOCK_BLOCKPAINT))
        return;

    CLock Lock(this, SERVERLOCK_BLOCKPAINT);

    hdc = ::BeginPaint(_pInPlace->_hwnd, &ps);

    if (!hdc)
        return;

    GetPalette(hdc);

    // NOTE: Here we pass a NULL in for the rect.  This is done becuase
    // this control has a window and must be in place, and the convention
    // is that a NULL is passed in to have the control draw in place, as
    // opposed to drawing it in another view.

    IGNORE_HR(Draw(DVASPECT_CONTENT, -1, 0, 0, 0, hdc, NULL, 0, 0, 0));

    SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    EndPaint(_pInPlace->_hwnd, &ps);
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnEraseBkgnd
//
//  Synopsis:   Erases the background when a window is present
//
//-------------------------------------------------------------------------

BOOL
CServer::OnEraseBkgnd(HDC hdc)
{
    Assert( _pInPlace );
    Assert( _pInPlace->_hwnd );

    return TestLock(SERVERLOCK_BLOCKPAINT) ? TRUE : FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCSetCursor
//
//  Synopsis:   Set the cursor for the non-licent area.
//
//-------------------------------------------------------------------------

BOOL
CServer::OnNCSetCursor(HWND hwnd, int nHitTest, UINT msg)
{
    TCHAR * idc;

    // Set cursor for non-client area.  We don't let the default
    // window procedure handle this because it gives the container
    // a chance to override what we really want.

    if (hwnd != _pInPlace->_hwnd || msg != WM_MOUSEMOVE)
        return FALSE;

    switch (nHitTest)
    {
    case HTCAPTION:
        idc = IDC_SIZEALL;
        break;

    case HTLEFT:
    case HTRIGHT:
        idc = IDC_SIZEWE;
        break;

    case HTTOP:
    case HTBOTTOM:
        idc = IDC_SIZENS;
        break;

    case HTTOPLEFT:
    case HTBOTTOMRIGHT:
        idc = IDC_SIZENWSE;
        break;

    case HTTOPRIGHT:
    case HTBOTTOMLEFT:
        idc = IDC_SIZENESW;
        break;

    default:
        return FALSE;
    }

    SetCursorIDC(idc);

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCPaint
//
//  Synopsis:   Draws the non-client region for the given window
//
//  Arguments:  hWnd    Window to draw
//
//-------------------------------------------------------------------------

void
CServer::OnNCPaint()
{
    RECT        rcBorder;
    HDC         hdc;

    if (!_pInPlace->_fShowBorder)
        return;

    // Get rcPos and inflate it.  This rcPos is our client
    // coordinate system
    rcBorder = _pInPlace->_rcPos;
    InflateRect(&rcBorder, CX_IPBORDER, CY_IPBORDER);

    // Normalize rcBorder to our window coord. system.
    OffsetRect(&rcBorder, -rcBorder.left, -rcBorder.top);

    hdc = GetWindowDC(_pInPlace->_hwnd);

    DrawUIActiveBorder(
            hdc,
            &rcBorder,
            GetAmbientBool(DISPID_AMBIENT_SHOWHATCHING, TRUE),
            GetAmbientBool(DISPID_AMBIENT_SHOWGRABHANDLES, TRUE));

    ::ReleaseDC(_pInPlace->_hwnd, hdc);
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCHitTest
//
//  Synopsis:   Returns the hit code for the border part at the given
//              point.
//
//-------------------------------------------------------------------------

LONG
CServer::OnNCHitTest(POINTS pts)
{
    RECT    rc;
    POINT   pt;
    int     dwHitBits;
    int     d;

    pt.x = pts.x;
    pt.y = pts.y;

    //
    // If it clearly is in the client area, return that fact.
    //
    GetClientRect( _pInPlace->_hwnd , &rc );
    ScreenToClient(_pInPlace->_hwnd, &pt);
    if (PtInRect(&rc, pt))
        return HTCLIENT;

    //
    // If we have no hatch border to test against then we can
    // give no better information.
    //
    if (!_pInPlace->_fShowBorder)
        return HTNOWHERE;

    // Set bits in a DWORD based on horizontal and vertical position
    // of the mouse.

    dwHitBits = 0;

    d = (rc.left + rc.right - CX_IPBORDER) / 2;
    if (pt.x >= d && pt.x < d + CX_IPBORDER + CX_HANDLEINSET)
        dwHitBits |= 0x04;
    else if (pt.x < rc.left + CX_IPBORDER + CX_HANDLEINSET)
        dwHitBits |= 0x01;
    else if (pt.x >= rc.right - CX_IPBORDER - CX_HANDLEINSET)
        dwHitBits |= 0x02;

    d = (rc.top + rc.bottom - CY_IPBORDER) / 2;
    if (pt.y >= d && pt.y < d + CY_IPBORDER + CY_HANDLEINSET)
        dwHitBits |= 0x40;
    else if (pt.y < rc.top + CY_IPBORDER + CY_HANDLEINSET)
        dwHitBits |= 0x10;
    else if (pt.y >= rc.bottom - CY_IPBORDER - CY_HANDLEINSET)
        dwHitBits |= 0x20;

    // Convert bits to hit test codes.

    switch (dwHitBits)
    {
    case 0x11:
        return HTTOPLEFT;
    case 0x21:
        return HTBOTTOMLEFT;
    case 0x41:
        return HTLEFT;
    case 0x12:
        return HTTOPRIGHT;
    case 0x22:
        return HTBOTTOMRIGHT;
    case 0x42:
        return HTRIGHT;
    case 0x14:
        return HTTOP;
    case 0x24:
        return HTBOTTOM;
    }

    return HTCAPTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCLButtonDown
//
//  Synopsis:   Handle WM_NCLBUTTONDOWN
//
//-------------------------------------------------------------------------

BOOL
CServer::OnNCLButtonDown(int ht, POINTS pts, RECT * prcCurrent)
{
    HRESULT hr;
    XHDC    hdc;
    HWND    hwnd;
    RECT    rcStart;
    RECT    rcCurrent;
    RECT    rcClip;
    RECT    rc;
    MSG     msg;
    POINT   pt;
    POINT   ptStart;
    BOOL    fCallOnPosRectChange = FALSE;

    hr = THR(_pInPlace->_pInPlaceSite->GetWindow(&hwnd));
    if (hr)
        return FALSE;

    if (GetCapture() != NULL)
        return FALSE;

    if (!prcCurrent)
    {
        prcCurrent = &rcCurrent;
    }

    // Get container's window current and lock it so
    // the x-or drawing below will not be messed up.

    UpdateChildTree(hwnd);
    LockWindowUpdate(hwnd);

    // Get starting point in container window coordinates.

    ptStart.x = pts.x;
    ptStart.y = pts.y;
    ScreenToClient(hwnd, &ptStart);

    // Get clip rectangle in container window coordinates.

    rcClip = _pInPlace->_rcClip;
    OffsetRect(&rcClip, _pInPlace->_ptWnd.x, _pInPlace->_ptWnd.y);
    ::GetClientRect(hwnd, &rc);
    IntersectRect(&rcClip, &rcClip, &rc);

    // Get starting rectangle in container window coordinates.

    rcStart = _pInPlace->_rcPos;
    OffsetRect(&rcStart, _pInPlace->_ptWnd.x, _pInPlace->_ptWnd.y);

    // Setup DC for drawing.

    hdc = XHDC(GetDCEx(hwnd, NULL,
            DCX_CACHE |
            DCX_CLIPSIBLINGS |
            DCX_LOCKWINDOWUPDATE), NULL);
    IntersectClipRect(hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom);

    *prcCurrent = rcStart;

    ::SetCapture(hwnd);

    DrawDefaultFeedbackRect(hdc, prcCurrent);

    // Get messages until capture lost or cancelled/accepted

    for (;;)
    {
        ::SuspendCAP();

        GetMessage(&msg, NULL, 0, 0);

        ::ResumeCAP();

        if (::GetCapture() != hwnd)
            goto ExitLoop;

        switch (msg.message)
        {
        case WM_SETCURSOR:
            break;

        case WM_KEYDOWN:
            if (msg.wParam == VK_ESCAPE)
                goto ExitLoop;
            break;

        case WM_RBUTTONDOWN:
            goto ExitLoop;

        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:

            rc = *prcCurrent;
            *prcCurrent = rcStart;

            pts = MAKEPOINTS(msg.lParam);
            pt.x = pts.x;
            pt.y = pts.y;

            if (pt.x < rcClip.left)
                pt.x = rcClip.left;
            else if (pt.x > rcClip.right)
                pt.x = rcClip.right;

            if (pt.y < rcClip.top)
                pt.y = rcClip.top;
            else if (pt.y > rcClip.bottom)
                pt.y = rcClip.bottom;

            switch (ht)
            {
            case HTCAPTION:
                OffsetRect(prcCurrent, pt.x - ptStart.x, pt.y - ptStart.y);
                break;

            case HTLEFT:
            case HTTOPLEFT:
            case HTBOTTOMLEFT:
                prcCurrent->left += pt.x - ptStart.x;
                if (prcCurrent->left > rcStart.right)
                    prcCurrent->left = rcStart.right;
                break;

            case HTRIGHT:
            case HTTOPRIGHT:
            case HTBOTTOMRIGHT:
                prcCurrent->right += pt.x - ptStart.x;
                if (prcCurrent->right < rcStart.left)
                    prcCurrent->right = rcStart.left;
                break;
            }

            switch (ht)
            {
            case HTTOP:
            case HTTOPLEFT:
            case HTTOPRIGHT:
                prcCurrent->top += pt.y - ptStart.y;
                if (prcCurrent->top > rcStart.bottom)
                    prcCurrent->top = rcStart.bottom;
                break;

            case HTBOTTOM:
            case HTBOTTOMLEFT:
            case HTBOTTOMRIGHT:
                prcCurrent->bottom += pt.y - ptStart.y;
                if (prcCurrent->bottom < rcStart.top)
                    prcCurrent->bottom = rcStart.top;
                break;
            }

            if (memcmp(&prcCurrent, &rc, sizeof(rc)))
            {
                DrawDefaultFeedbackRect(hdc, &rc);
                DrawDefaultFeedbackRect(hdc, prcCurrent);
            }

            if (msg.message == WM_LBUTTONUP)
            {
                fCallOnPosRectChange = TRUE;
                goto ExitLoop;
            }

        default:

            // Anything can happen during DispatchMessage.
            // Insure that our feedback is not messed up.

            DrawDefaultFeedbackRect(hdc, prcCurrent);
            DispatchMessage(&msg);
            UpdateChildTree(hwnd);
            DrawDefaultFeedbackRect(hdc, prcCurrent);
            break;
        }
    }

ExitLoop:

    DrawDefaultFeedbackRect(hdc, prcCurrent);

    ::ReleaseDC(hwnd, hdc);
#if DBG==1
    Assert(!TLS(fHandleCaptureChanged));
#endif
    ReleaseCapture();
    LockWindowUpdate(NULL);

    return fCallOnPosRectChange;
}


//+---------------------------------------------------------------------------
//
//  Member:    CServer::OnDestroy
//
//  Synopsis:  Deregister Drag and Drop
//
//----------------------------------------------------------------------------

void
CServer::OnDestroy( )
{
    Assert(_pInPlace->_hwnd);
    RevokeDragDrop(_pInPlace->_hwnd);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnWindowMessage
//
//  Synopsis:   Handles windows messages.
//
//  Arguments:  msg     the message identifier
//              wParam  the first message parameter
//              lParam  the second message parameter
//
//  Returns:    LRESULT as in WNDPROCs
//
//----------------------------------------------------------------------------

HRESULT
CServer::OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr=S_OK;
    POINT pt;

    *plResult = 0;

    // We should always be stabilized when handling a window message.
    // This check insures that derived classes are doing the right thing.

    Assert(TestLock(SERVERLOCK_STABILIZED));

    // Events fired by the derived class implementation of OnWindowMessage
    // may have caused this object to leave the inplace state.  Bail out
    // here if it looks like this happened.  We check for _pInPlace instead
    // of _state < OS_INPLACE because the window procedure can be called
    // before we are officially in the inplace state.

    if (!_pInPlace)
    {
        return S_OK;
    }

    // Process the message.

    switch (msg)
    {
    case WM_DESTROY:
        OnDestroy();
        break;

// WINCEREVIEW -- senthilv - 01/30/97 ignoring all message handlers from nonclient area
#ifndef WINCE
    case WM_NCLBUTTONDOWN:
        OnNCLButtonDown(wParam, MAKEPOINTS(lParam));
        break;

    case WM_NCHITTEST:
        *plResult = OnNCHitTest(MAKEPOINTS(lParam));
        break;

    case WM_NCCALCSIZE:
        if (_pInPlace->_fShowBorder)
        {
            // Let the old client rect origin stay the same so shrink
            // incoming rectangle (which is total window size)
            InflateRect((RECT *)lParam, -CX_IPBORDER, -CY_IPBORDER);
        }

        if (wParam && TestServerDescFlag(SERVERDESC_INVAL_ON_RESIZE))
        {
            *plResult |= WVR_REDRAW;
        }
        break;

    case WM_NCPAINT:
        OnNCPaint();
        break;
#endif	// WINCE

    case WM_SETCURSOR:

        if (LOWORD(lParam) != HTCLIENT)
        {
            if (_pInPlace->_hwnd &&
                !OnNCSetCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam)))
            {
                *plResult = DefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam);
            }
        }
        else
        {
            HWND hwnd;

            GetCursorPos(&pt);

            hwnd = GetHWND();
            if (hwnd)
            {
                ScreenToClient(hwnd, &pt);

                // First chance at setting the cursor

                if (THR(OnInactiveSetCursor(
                        &_pInPlace->_rcPos,
                        pt.x, pt.y,
                        HIWORD(wParam),
                        FALSE)) == S_FALSE)
                {
                    // Give the container a chance to set the cursor.

                    IGNORE_HR(OnDefWindowMessage(msg,
                                                 wParam ? wParam : (WPARAM)hwnd,
                                                 lParam,
                                                 plResult ));

                    // If the container did not set the cursor, then use the built in
                    // cursor.  Note that we do this for our window only.

                    if (!*plResult && hwnd == (HWND)wParam && !_pInPlace->_fBubbleInsideOut)
                    {
                        *plResult = (THR(OnInactiveSetCursor(
                            &_pInPlace->_rcPos,
                            pt.x, pt.y,
                            HIWORD(wParam),
                            TRUE)) == S_FALSE) ? FALSE : TRUE;
                    }
                }
                else
                {
                    *plResult = TRUE;
                }
            }
        }
        break;

    case WM_MOUSEMOVE:
        hr = THR(OnInactiveMouseMove(
                &_pInPlace->_rcPos,
                MAKEPOINTS(lParam).x,
                MAKEPOINTS(lParam).y,
                wParam));
        break;

    case WM_ERASEBKGND:
        *plResult = OnEraseBkgnd((HDC)wParam);
        break;

    case WM_PAINT:
        OnPaint();
        break;

    case WM_SETFOCUS:
    case WM_KILLFOCUS:
        {
            IOleControlSite * pControlSite;

            _pInPlace->_fFocus = (msg == WM_SETFOCUS);

            if (OK(THR_NOTRACE(_pClientSite->QueryInterface(IID_IOleControlSite,
                    (void **)&pControlSite))))
            {
                pControlSite->OnFocus(msg == WM_SETFOCUS);
                pControlSite->Release();
            }
        }
        break;

    // OCX containers (e.g. VB4) will forward WM_PALETTECHANGED and WM_QUERYNEWPALETTE
    // on to us to properly realize our palette for controls in cases where they are
    // windowed.  This is semantically equivalent to the code in MinFrameWndProc in
    // minfr.cxx.
    case WM_PALETTECHANGED:
        Assert(_pInPlace);
        if ((HWND)wParam == _pInPlace->_hwnd)
            break;
        // **** FALL THRU ****
    case WM_QUERYNEWPALETTE:
        {
            HDC         hdc;

            Assert(_pInPlace);
            hdc = ::GetDC(_pInPlace->_hwnd);
            if (hdc)
            {
                BOOL        fInvalidate = FALSE;
                HPALETTE    hpal;

                hpal = GetPalette();
                if (hpal)
                {
                    HPALETTE hpalOld = SelectPalette(hdc, hpal, (msg == WM_PALETTECHANGED));
                    Assert(hpalOld);
                    fInvalidate = RealizePalette(hdc) || (msg == WM_PALETTECHANGED);
                    SelectPalette(hdc, hpalOld, TRUE);
                    
                    if (fInvalidate && (_state >= OS_INPLACE))
                    {
                        if (_pInPlace->_hwnd)
                            RedrawWindow(_pInPlace->_hwnd, (GDIRECT *)NULL, NULL,
                                         RDW_INVALIDATE | RDW_ALLCHILDREN);
                        else
                            InvalidateRect(NULL, TRUE);
                    }
                }
                ::ReleaseDC(_pInPlace->_hwnd, hdc);
                *plResult = !!hpal;
            }
            break;
        }

    default:
        hr = THR(OnDefWindowMessage(msg, wParam, lParam, plResult));
        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnDefWindowMessage
//
//  Synopsis:   Default handling for window messages.
//
//  Arguments:  msg      the message identifier
//              wParam   the first message parameter
//              lParam   the second message parameter
//              plResult return value from window proc
//
//----------------------------------------------------------------------------

HRESULT
CServer::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_OK;

    // Events fired by the derived class implementation of OnWindowMessage
    // may have caused this object to leave the inplace state.  Bail out
    // here if it looks like this happened.  We check for _pInPlace instead
    // of _state < OS_INPLACE because the window procedure can be called
    // before we are officially in the inplace state.

    if (!_pInPlace)
    {
        return S_OK;
    }

    if (_pInPlace->_fWindowlessInplace)
    {
        hr = THR(((IOleInPlaceSiteWindowless*)_pInPlace->_pInPlaceSite)->
                OnDefWindowMessage(msg, wParam, lParam, plResult));
    }
#ifndef NO_IME
    else if (DIMMHandleDefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam, plResult))
    {
        // WM_IME* messages routed through here, so let the imm hook get a chance at them
        // plResult set in call above.
        
        // Note we only bother to hook if !_pInPlace->_fWindowlessInPlace, that is if
        // we have our own window.
    }
#endif // ndef NO_IME
    else if (_pInPlace->_hwnd)
    {
        // Events fired by the derived class implementation of OnWindowMessage
        // may have caused this object to leave the inplace state.  Bail out
        // here if it looks like this happened.  We check for _pInPlace instead
        // of _state < OS_INPLACE because the window procedure can be called
        // before we are officially in the inplace state.

        *plResult = DefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam);
    }
    else
    {
        *plResult = 0;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::WndProc
//
//  Synopsis:   Window procedure for use by derived class.
//              This function maintains the relationship between
//              CServer and HWND and delegates all other functionality
//              to the CServer::OnWindowMessage virtual method.
//
//  Arguments:  hwnd     the window
//              msg      the message identifier
//              wParam   the first message parameter
//              lParam   the second message parameter
//              plResult the window procedure return value
//
//  Returns:    S_FALSE if caller should delegate to the default window proc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
CServer::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

#ifdef _M_IX86
    //automatic stack saver for Win9x. see declaration of this class for details.
    CWin9xStackSave stackSaver;
#endif //_M_IX86

    CServer *pServer;
    LRESULT lResult = 0;

    //
    // a-msadek; Trident window should not be mirrored if hosted by a mirrored process
    //

    if(msg == WM_NCCREATE)
    {
        DWORD dwExStyles;
        if ((dwExStyles = GetWindowLong(hwnd, GWL_EXSTYLE)) & WS_EX_LAYOUTRTL)
        {
             SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles &~ WS_EX_LAYOUTRTL);
        }
    }

    //
    // If creating, then establish the connection between the HWND and
    // the CServer.  Otherwise, fetch the pointer to the CServer.
    //

#if defined(WINCE) && !defined(WINCE_NT)
    if (msg == WM_CREATE)
#else
    if (msg == WM_NCCREATE)
#endif // WINCE
    {
        pServer = (CServer *) ((LPCREATESTRUCTW)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pServer);
        pServer->_pInPlace->_hwnd = hwnd; 
        pServer->PrivateAddRef();
    }
    else
    {
        pServer = (CServer *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    if (pServer)
    {
        Assert(pServer->_pInPlace);
        Assert(pServer->_pInPlace->_hwnd == hwnd);

        //
        // Give the derived class a chance to handle the window message.
        //

        IGNORE_HR(pServer->OnWindowMessage(msg, wParam, lParam, &lResult));

        //
        // If destroying, break the connection between the HWND and CServer.
        // The call to release might destroy the server, so it must come
        // after the OnWindowMessage virtual function call.
        //

#if defined(WINCE) && !defined(WINCE_NT)
        if (msg == WM_DESTROY)
#else
        if (msg == WM_NCDESTROY)
#endif // WINCE
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
            pServer->_pInPlace->_hwnd = NULL;
            pServer->PrivateRelease();
        }

    }
    // We should always calls DefWindowProc
    else
    {
        lResult = DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\alpha.asm ===
//----------------------------------------------------------------------------
 //
 // File:     alpha.asm
 //
 // Contains: Assembly code for the Alpha. Implements the dynamic vtable stuff
 //           and the tearoff code.
 //
 //----------------------------------------------------------------------------

.globl DynLinkFunc
.globl CallTornOffMethod

#include <dvtbl.h>

offsetof_pvObject         = 12  // Must be kept in sync with the source code
offsetof_apfn             = 16  // Ditto


rIndex    = $t0
rThis     = $a0

rTemp     = $t1
rTmp2     = $t2
rpFnTable = $t3

.align 3

 // Ensure that DynLinkFunc stays exactly how we expect
.set noreorder
.set nomacro

 //----------------------------------------------------------------------------
 //
 //  Function:  DynLinkFunc
 //
 //  Synopsis:  The code that is put into the dynamic vtable thunks
 //
 //  Notes:     The various 0x7000 constants are replaced on the fly with
 //             appropriate values by InitDynamicVtable.
 //
 //             NOTE: If the MSB of the low word of the offset is 1, then
 //             the high word of the offset must have 1 added to it, since
 //             these instructions sign extend the low word and add it to
 //             the high word.
 //
 //----------------------------------------------------------------------------
.ent DynLinkFunc

DynLinkFunc:

    lda  rIndex, 0x7000($zero) // Store the index (replace 7000 w/ index)
    ldl  rTemp,  0x0(rThis)    // Move vtable pointer into reg
    ldah rTemp,  0x7000(rTemp) // Add high word of offset to vtable ptr
    ldl  rTemp,  0x7000(rTemp) // Add (sign extended) low word of offset to the
                               //   vtable ptr & get the "handler" function ptr
    jmp  (rTemp)               // Call the "handler" function
                               // The offset is the offset between g_pvtbl
                               //   and g_apfnThunkers, computed and replaced
                               //   by InitDynamicVtable.
.end DynLinkFunc

.set macro
.set reorder

 //----------------------------------------------------------------------------
 //
 //  Function:  CallTornOffMethod
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------

.align 3


.ent CallTornOffMethod

CallTornOffMethod:

    // Value in rIndex was stored by DynLinkFunc

    ldl    rpFnTable, offsetof_apfn(rThis)          // Get table of functions

    // NOTE: Uncomment the following line if DVTBL_OFFSET_TEAROFF is nonzero.
    // subl   rIndex, DVTBL_OFFSET_TEAROFF, rIndex  // Adjust thunk index

    subl   rIndex, NUMBER_CTIUNKNOWN_METHODS, rTemp // Are we calling IUnknown?
    ldl    rTmp2,  offsetof_pvObject(rThis)         // Get object's this ptr
    s4addl rIndex, rpFnTable, rpFnTable             // Get the entry in table
    cmovge rTemp,  rTmp2, rThis                     // Store new this ptr if
                                                    //   not calling IUnknown
    ldl    rTemp, 0x0(rpFnTable)                    // Get the fn pointer
    jmp    (rTemp)                                  // Call function

.end CallTornOffMethod
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\assoc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       assoc.cxx
//
//  Contents:   String-indexed bag classses (associative-array)
//
//              CPtrBag   (case-sensitive)
//              CPtrBagCi (optionally case-insensitive)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#define ASSOC_HASH_MARKED ((CAssoc*)1)
#define ASSOCVTABLE_HASH_MARKED  ((CAssocVTable *)1)

#ifdef PDLPARSE
#include <stdio.h>
#include <tchar.h>
#define THR(x) x
#define RRETURN(x) return x
#else
MtDefine(CAssoc, PerProcess, "CAssoc")
#endif
//+---------------------------------------------------------------------------
//
//  Variable:   s_asizeAssoc
//
//              A list of primes for use as hashing modulii
//
//----------------------------------------------------------------------------
extern const DWORD s_asizeAssoc[];
const DWORD s_asizeAssoc[] = {/* 3,5,7,11,17,23, */ 37,59,89,139,227,359,577,929,
    1499,2423,3919,6337,10253,16573,26821,43391,70207,113591,183797,297377,
    481171,778541,1259701,2038217,3297913,5336129,8633983,13970093,22604069,
    36574151,59178199,95752333,154930511,250682837,405613333,656296153,
    1061909479,1718205583,2780115059};

// an alternate list (grows faster)
#if 0
const DWORD s_asizeAssoc[] = {/*3,5,7,13,*/23,43,83,163,317,631,1259,2503,5003,9973,
    19937,39869,79699,159389,318751,637499,1274989,2549951,5099893,10199767,
    20399531,40799041,81598067,163196129,326392249,652784471,1305568919,
    2611137817};
#endif


//+---------------------------------------------------------------------------
//
//  Function:   HashPtr
//
//              Computes a 32-bit hash for a ptr, in the manner compatible
//              with HasString and HashStringCi, starting with a given hash
//
// TODO asm version of this if anyone cares
//----------------------------------------------------------------------------

DWORD HashPtr(LPCVOID pvKey, DWORD hash)
{
    Assert (pvKey); // or else we won't calc hash at all

    while (pvKey)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += (DWORD)  ((DWORD_PTR)pvKey & 0x7F);
        pvKey = (LPCVOID) (((DWORD_PTR)pvKey & 0xffffffff) >> 7);
    }
    return hash;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashString
//
//              Computes a 32-bit hash value for a unicode string
//
//              asm version supplied so that we take advantage of ROR
//
//----------------------------------------------------------------------------
#if defined(_M_IX86)

#pragma warning(disable:4035) // implicit return value left in eax

DWORD HashString(const TCHAR *pch, DWORD len, DWORD hash)
{
    _asm {
        mov         ecx, len            ;   // ecx = len
        mov         ebx, pch            ;   // ebx = pch
        mov         eax, hash           ;   // eax = hash
        xor         edx, edx            ;   // edx = 0
        cmp         ecx, 0              ;   // while (!len)
        je          loop_exit           ;   // {
    loop_top:
        mov         dx, word ptr [ebx]  ;   //     ch = *pch
        ror         eax, 7              ;   //     hash = (hash >> 7) | (hash << (32-7))
        add         ebx, 2              ;   //     pch++
        add         eax, edx            ;   //     hash += ch
        dec         ecx                 ;   //     len--
        jnz         loop_top            ;   // }
    loop_exit:
    }                                       // result in eax
}

#pragma warning(default:4035)

#else

DWORD HashString(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += *pch; // Case-sensitive hash
        pch++;
        len--;
    }

    return hash;
}

#endif

#if !defined(PDLPARSE) && !defined(ASCPARSE)
// Takes a VTableDesc and maps it to a string.
inline const TCHAR *VTableDescToString(const VTABLEDESC *pVTableDesc)
{
    const PROPERTYDESC *pPropDesc = pVTableDesc->GetHashPropDesc();

    switch(pVTableDesc->uVTblEntry & PDLPARSE_MASK)
    {
    case PDLPARSE_BELONGSTOBOTH:
    case PDLPARSE_BELONGSTOOM:
        return pPropDesc->pstrExposedName ?
                    pPropDesc->pstrExposedName :
                    pPropDesc->pstrName;
    case PDLPARSE_BELONGSTOPARSE:
        return pPropDesc->pstrName ?
                    pPropDesc->pstrName :
                    pPropDesc->pstrExposedName;
    default:
        AssertSz(0, "Illegal value for VTable flags");
        return NULL;
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   HashStringCi
//
//              Computes a 32-bit hash value for a unicode string which
//              is case-insensitive for ASCII characters.
//
//              asm version supplied so that we take advantage of ROR
//
//              Not unicode safe
//
//----------------------------------------------------------------------------

#if defined(_M_IX86)

#pragma warning(disable:4035) // implicit return value left in eax

DWORD HashStringCi(const TCHAR *pch, DWORD len, DWORD hash)
{
    _asm {
        mov         ecx, len            ;   // ecx = len
        mov         ebx, pch            ;   // ebx = pch
        mov         eax, hash           ;   // eax = hash
        xor         edx, edx            ;   // edx = 0
        cmp         ecx, 0              ;   // while (!len)
        je          loop_exit           ;   // {
    loop_top:
        mov         dx, word ptr [ebx]  ;   //     *pch
        ror         eax, 7              ;   //     hash = (hash >> 7) | (hash << (32-7))
        add         ebx, 2              ;   //     pch++
        and         dx, ~(_T('a')-_T('A'))
        add         eax, edx            ;   //     hash += *pch
        dec         ecx                 ;   //     len--
        jnz         loop_top            ;   // }
    loop_exit:
    }                                       // result in eax
}

#pragma warning(default:4035)

#else

DWORD HashStringCi(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash
        pch++;
        len--;
    }

    return hash;
}

#endif

DWORD HashStringWordCi(const TCHAR *pch, DWORD hash)
{
    while (*pch)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash
        pch++;
    }

    return hash;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashStringCiTryW
//
//  Computes a hash value for a string.
//  Returns a sentinel value if string is unicode.
//
//  Unicode Safe
//
//----------------------------------------------------------------------------

#if defined(_M_IX86)

#pragma warning(disable:4035) // implicit return value left in eax

DWORD HashStringCiTryW(const TCHAR *pch, DWORD len, DWORD hash)
{
    _asm {
        mov         ecx, len            ;   // ecx = len
        mov         ebx, pch            ;   // ebx = pch
        mov         eax, hash           ;   // eax = hash
        xor         edx, edx            ;   // edx = 0
        cmp         ecx, 0              ;   // while (!len)
        je          zero_chk            ;   // {
    loop_top:
        mov         dx, word ptr [ebx]  ;   //     ch = *pch
        ror         eax, 7              ;   //     hash = (hash >> 7) | (hash << (32-7))
        add         ebx, 2              ;   //     pch++
        cmp         dx, 128                 //     if (128 < ch)
        jnl         sentinel_value          //          goto sentinel_value
        and         dx, ~(_T('a')-_T('A'))  //     ch = ch & (~(_T('a')-_T('A')))
        add         eax, edx            ;   //     hash += ch
        dec         ecx                 ;   //     len--
        jnz         loop_top            ;   // }
        jmp         zero_chk
    sentinel_value:
        mov         eax, SENTINEL_VALUE
        jmp         loop_exit
    zero_chk:
        cmp         eax, 0              ;   // if we have a 0 hash, return 1
        jnz         loop_exit
        mov         eax, 1
    loop_exit:
    }                                       // result in eax
}

#pragma warning(default:4035)

#else

DWORD HashStringCiTryW(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));

        if (*pch > 127)
            return SENTINEL_VALUE;

        hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash
        pch++;
        len--;
    }

    // We dont want to return a 0 (especially if we are using a hash table etc).
    if (hash == 0)
        return 1;

    return hash;
}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   HashStringCiW
//
//  Computes a hash value for all unicode strings.
//
//  Unicode safe
//
//----------------------------------------------------------------------------

DWORD HashStringCiW(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));
#if !defined(PDLPARSE) && !defined(ASCPARSE)
        if (*pch > 127)
            hash += (TCHAR)CharUpper((LPTSTR)((DWORD_PTR)(*pch)));
#else
        // NOTE: don't put anything unicode in pdl files
        if (*pch > 127)
            DebugBreak();
#endif
        else
            hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash

        pch++;
        len--;
    }

    // We dont want to return a 0 (especially if we are using a hash table etc).
    if (hash == 0)
        return 1;

    return hash;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashStringCiDetectW
//
//  Computes a hash value for all strings.
//
//  Unicode safe
//
//----------------------------------------------------------------------------

DWORD HashStringCiDetectW(const TCHAR *pch, DWORD len, DWORD hash)
{
    DWORD dwHash = HashStringCiTryW(pch, len, hash);

    if (dwHash == SENTINEL_VALUE)
        return HashStringCiW(pch, len, hash);
    else
        return dwHash;
}

//+---------------------------------------------------------------------------
//
//  Function:   _tcsnzequal
//
//              Tests equality of two strings, where the first is
//              specified by pch/cch, and the second is \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _tcsnzequal(const TCHAR *string1, DWORD cch, const TCHAR *string2)
{
    while (cch)
    {
        if (*string1 != *string2)
            return FALSE;

        string1 += 1;
        string2 += 1;
        cch --;
    }

    return (*string2) ? FALSE : TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   _7csnziequal
//
//              Tests 7-bit-case-insensitive equality of two strings, where
//              the first is specified by pch/cch, and the second is
//              \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _7csnziequal(const TCHAR *string1, DWORD cch, const TCHAR *string2)
{
    while (cch)
    {
        if (*string1 != *string2)
        {
            if ((*string1 ^ *string2) != _T('a') - _T('A'))
                return FALSE;

            if (((unsigned)(*string2 - _T('A')) > _T('Z') - _T('A')) &&
                ((unsigned)(*string2 - _T('a')) > _T('z') - _T('a')))
                return FALSE;
        }
        string1 += 1;
        string2 += 1;
        cch --;
    }

    return (*string2) ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   _tcsnzequalWord
//
//              Tests equality of two strings, where the first and
//              the second is \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _tcsnzequalWord(const TCHAR *string1, const TCHAR *string2)
{
    while (*string1)
    {
        if (*string1 != *string2)
            return FALSE;

        string1 += 1;
        string2 += 1;
    }

    return (*string2) ? FALSE : TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   _7csnziequal
//
//              Tests 7-bit-case-insensitive equality of two strings, where
//              the first and the second is \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _7csnziequalWord(const TCHAR *string1, const TCHAR *string2)
{
    while (*string1)
    {
        if (*string1 != *string2)
        {
            if ((*string1 ^ *string2) != _T('a') - _T('A'))
                return FALSE;

            if (((unsigned)(*string2 - _T('A')) > _T('Z') - _T('A')) &&
                ((unsigned)(*string2 - _T('a')) > _T('z') - _T('a')))
                return FALSE;
        }
        string1 += 1;
        string2 += 1;
    }

    return (*string2) ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::Init
//
//  Synopsis:   Initializes CAssocArray to _cHash = 1.
//              An initial size >0 is required to allow "hash % _mHash".
//
//              Note: to avoid memory allocation here,
//              _pAssocHash and _pAssocs are init'ed to point to a dummy
//              member _assocOne.
//
//  Arguments:  [pch] -- String to match the assoc
//              [hash]-- the result of HashAssocString(pch)
//
//  Returns:    CAssoc (possibly NULL)
//
//----------------------------------------------------------------------------
void CAssocArray::Init()
{
    // init hashtable
    _pHashTable   = &_pAssocOne;
    _pAssocOne    = NULL;
    _cHash        = 0;
    _mHash        = 1;
    _sHash        = 0;
    _maxHash      = 0;
    _iSize        = 0;

    Assert(!_fStatic);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::~CAssocArray
//
//  Synopsis:   Deletes all the assocs stored in the table and frees
//              the hash table memory.
//
//              Note: _pAssocHash is only freed if it does not point to _assocOne.
//
//  Arguments:  [pch] -- String to match the assoc
//              [hash]-- the result of HashAssocString(pch)
//
//  Returns:    CAssoc (possibly NULL)
//
//----------------------------------------------------------------------------
void CAssocArray::Deinit()
{
    Assert(!_fStatic);

    // CAUTION: we delete hash table and cast (const *) to (non-const *) because we know what we are doing.
    //          the hash table is sometimes initialized with static strings,
    //          but it is then marked as _fStatic, which we just have asserted

    CAssoc **ppn = VolatileHashTablePtr();

    for (int c = _mHash; c; ppn++, c--)
    {
        delete *ppn;
    }

    if (_pHashTable != &_pAssocOne)
    {
        // CAUTION: same as above
        MemFree(VolatileHashTablePtr());
        _pHashTable = &_pAssocOne;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::AddAssoc
//
//  Synopsis:   Adds a assoc (a string-number association) to the table.
//              Neither the string nor the number should previously appear.
//
//  Returns:    HRESULT (possibly E_OUTOFMEMORY)
//
//----------------------------------------------------------------------------
const CAssoc *CAssocArray::AddAssoc(DWORD_PTR number, const TCHAR *pch, DWORD len, DWORD hash)
{
    CAssoc *passoc;
    HRESULT hr;

    Assert(!_fStatic);
    Assert(!AssocFromString(pch, len, hash));

    // Step 1: create the new assoc
    passoc = new ((len+1)*sizeof(TCHAR)) CAssoc;
    if (!passoc)
        return NULL;

    passoc->Init(number, pch, len, hash);

    // Step 2: verify that the tables have enough room
    if (_cHash >= _maxHash)
    {
        hr = THR(ExpandHash());
        if (hr)
            goto Error;
    }

    // Step 3: insert the new assoc in the hash array
    SetHashTableEntry(EmptyHashIndex(hash), passoc);
    _cHash++;

    return passoc;

Error:
    delete passoc;

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::EmptyHashIndex
//
//  Synopsis:   Finds first empty hash index for the given hash value.
//
//----------------------------------------------------------------------------
DWORD CAssocArray::EmptyHashIndex(DWORD hash)
{
    DWORD i = hash % _mHash;
    DWORD s;

    if (!_pHashTable[i])
        return i;

    s = (hash & _sHash) + 1;

    do
    {
        if (i < s)
            i += _mHash;
        i -=s ;
    } while (_pHashTable[i]);

    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::HashIndexFromString
//
//  Synopsis:   Finds the place in the hash table in which the assoc with
//              the specified string lives. If no assoc with the string is
//              present, returns the place in the hash table where the
//              assoc would be.
//
//----------------------------------------------------------------------------
const CAssoc *CAssocArray::AssocFromString(const TCHAR *pch, DWORD cch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssoc  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::HashIndexFromStringCi
//
//  Synopsis:   Just like HashIndexFromString, but case-insensitive.
//
//----------------------------------------------------------------------------
const CAssoc *CAssocArray::AssocFromStringCi(const TCHAR *pch, DWORD cch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssoc  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _7csnziequal(pch, cch, passoc->String()))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _7csnziequal(pch, cch, passoc->String()))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::ExpandHash
//
//  Synopsis:   Expands the hash table, preserving order information
//              (so that colliding hash entries can be taken out in the
//              same order they were put in).
//
//----------------------------------------------------------------------------
HRESULT CAssocArray::ExpandHash()
{
    CAssoc **ppn;
    CAssoc **pHashTableOld;
    CAssoc **ppnMax;
    DWORD mHashOld;
    DWORD sHashOld;
    DWORD hash;
    DWORD i;
    DWORD s;

    Assert(_iSize < ARRAY_SIZE(s_asizeAssoc));
    Assert(!_fStatic);

    // allocate memory for expanded hash table
    ppn = (CAssoc**)MemAllocClear(Mt(CAssoc), sizeof(CAssoc*) * s_asizeAssoc[_iSize]);
    if (!ppn)
    {
        return E_OUTOFMEMORY;
    }

    // set new sizes
    pHashTableOld = VolatileHashTablePtr();
    mHashOld = _mHash;
    sHashOld = _sHash;
    _mHash = s_asizeAssoc[_iSize];
    _maxHash = _mHash/2;
    for (_sHash = 1; _sHash <= _maxHash; _sHash = _sHash << 1 | 1);
    Assert(_sHash < _mHash);
    _iSize++;
    SetHashTablePtr(ppn);

    // rehash - do per hash value to preserve the "order"
    if (_cHash)
    {
        Assert(_cHash < mHashOld);

        for (ppn = pHashTableOld, ppnMax = ppn+mHashOld; ppn < ppnMax; ppn++)
        {
            if (*ppn && *ppn != ASSOC_HASH_MARKED)
            {
                hash = (*ppn)->Hash();
                i = hash % mHashOld;
                s = (hash & sHashOld) + 1;

                // inner loop needed to preserve "hash order" for ci aliases
                while (pHashTableOld[i])
                {
                    if (pHashTableOld[i] != ASSOC_HASH_MARKED &&
                        pHashTableOld[i]->Hash() == hash)
                    {
                        SetHashTableEntry(EmptyHashIndex(hash), pHashTableOld[i]);
                        pHashTableOld[i] = ASSOC_HASH_MARKED;
                    }

                    if (i < s)
                        i += mHashOld;

                    i -= s;
                }
            }
        }
    }

    // free old memory
    if ((const CAssoc **) pHashTableOld != &_pAssocOne)
        MemFree(pHashTableOld);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::SetImpl
//
//  Synopsis:   Sets an association of the string to the void*, creating
//              a new association if needed.
//
//              TODO: remove associations if e==NULL.
//
//----------------------------------------------------------------------------
HRESULT CImplPtrBag::SetImpl(const TCHAR *pch, DWORD cch, DWORD hash, void *e)
{
    const CAssoc *passoc;

    Assert(!_fStatic);

    passoc = AssocFromString(pch, cch, hash);

    if (passoc)
        (const_cast<CAssoc *>(passoc))->_number = (DWORD_PTR)e;
    else
    {
        passoc = AddAssoc((DWORD_PTR)e, pch, cch, hash);
        if (!passoc)
            return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::GetImpl
//
//  Synopsis:   Returns the void* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
void *CImplPtrBag::GetImpl(const TCHAR *pch, DWORD cch, DWORD hash)
{
    const CAssoc *passoc;

    passoc = AssocFromString(pch, cch, hash);

    if (passoc)
        return (void*)passoc->_number;

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::SetCiImpl
//
//  Synopsis:   Sets an association of the string to the specified void*.
//              If there is no association which satisfies a case-insensitive
//              match, a new association is created.
//
//----------------------------------------------------------------------------
HRESULT CImplPtrBag::SetCiImpl(const TCHAR *pch, DWORD cch, DWORD hash, void *e)
{
    const CAssoc *passoc;

    Assert(!_fStatic);

    passoc = AssocFromStringCi(pch, cch, hash);

    if (passoc)
        (const_cast<CAssoc *>(passoc))->_number = (DWORD_PTR)e;
    else
    {
        passoc = AddAssoc((DWORD_PTR)e, pch, cch, hash);
        if (!passoc)
            return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::GetCiImpl
//
//  Synopsis:   Returns the void* associated with the given string or
//              a case-insensitive match, or NULL if none.
//
//----------------------------------------------------------------------------
void *CImplPtrBag::GetCiImpl(const TCHAR *pch, DWORD cch, DWORD hash)
{
    const CAssoc *passoc;

    passoc = AssocFromStringCi(pch, cch, hash);

    if (passoc)
        return (void*)passoc->_number;

    return NULL;
}



///////////////////////////////////////////////////////////////////////////////
//
// CStringTable
//
///////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable constructor
//
//----------------------------------------------------------------------------

CStringTable::CStringTable(CASESENSITIVITY caseSensitivity)
{
    Init();
    _fCaseSensitive = (CASESENSITIVE == caseSensitivity);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable destructor
//
//----------------------------------------------------------------------------

CStringTable::~CStringTable()
{
    Deinit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::Add
//
//----------------------------------------------------------------------------

HRESULT
CStringTable::Add (LPCTSTR pch, LONG cch, LPVOID pv, LPCVOID pvAdditionalKey, BOOL fOverride)
{
    HRESULT     hr;
    int         hash = 0;
    const CAssoc * pAssoc;

    Assert (0 < cch);
    Assert(!_fStatic);

    if (pvAdditionalKey)
    {
        hash = HashPtr(pvAdditionalKey, 0);
    }

    if (_fCaseSensitive)
    {
        hash   = HashString     (pch, cch, hash);
        pAssoc = AssocFromString(pch, cch, hash);
    }
    else
    {
        hash   = HashStringCiDetectW(pch, cch, hash);
        pAssoc = AssocFromStringCi  (pch, cch, hash);
    }

    if (pAssoc)
    {
        if (fOverride)
        {
            Assert(!_fStatic);
            (const_cast<CAssoc *>(pAssoc))->_number = (DWORD_PTR)pv;
        }

        hr = S_OK;
    }
    else
    {
        hr = AddAssoc((DWORD_PTR)pv, pch, cch, hash) ? S_OK : E_FAIL;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::Find
//
//----------------------------------------------------------------------------

HRESULT
CStringTable::Find(LPCTSTR pch, LONG cch, LPVOID * ppv, LPCVOID pvAdditionalKey, LPCTSTR *ppString)
{
    int         hash = 0;
    const CAssoc * pAssoc;

    Assert (0 < cch);

    if (pvAdditionalKey)
    {
        hash = HashPtr(pvAdditionalKey, 0);
    }

    if (_fCaseSensitive)
    {
        hash   = HashString     (pch, cch, hash);
        pAssoc = AssocFromString(pch, cch, hash);
    }
    else
    {
        hash   = HashStringCiDetectW(pch, cch, hash);
        pAssoc = AssocFromStringCi  (pch, cch, hash);
    }

    if (pAssoc)
    {
        if (ppv)
            *ppv = (LPVOID)pAssoc->_number;

        if (ppString)
            *ppString = pAssoc->String();

        RRETURN (S_OK);
    }
    else
    {
        if (ppv)
            *ppv = NULL;

        RRETURN (E_FAIL);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator constructor
//
//----------------------------------------------------------------------------

CStringTable::CIterator::CIterator(CStringTable * pTable)
{
    _pTable = pTable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::Start
//
//----------------------------------------------------------------------------

void
CStringTable::CIterator::Start(CStringTable * pTable)
{
    if (pTable)
        _pTable = pTable;

    Assert (_pTable);

    _idx = -1;
    Next();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::Next
//
//----------------------------------------------------------------------------

void
CStringTable::CIterator::Next()
{
    Assert (_pTable);

    _idx++;

    while (!End() && !_pTable->_pHashTable[_idx])
    {
        _idx++;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::End
//
//----------------------------------------------------------------------------

BOOL
CStringTable::CIterator::End() const
{
    Assert (_pTable);

    return _pTable->_mHash <= (DWORD)_idx;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::Item
//
//----------------------------------------------------------------------------

LPCVOID
CStringTable::CIterator::Item() const
{
    Assert (_pTable);

    return End() ? NULL : _pTable->_pHashTable[_idx];
}

#if !defined(PDLPARSE)
#if !defined(ASCPARSE)
//+---------------------------------------------------------------------------
//
//  Member:     CAssocArrayVTable::AssocFromString
//
//  Synopsis:   Finds the place in the hash table in which the assoc with
//              the specified string lives. If no assoc with the string is
//              present, returns the place in the hash table where the
//              assoc would be.
//
//----------------------------------------------------------------------------
const CAssocVTable *
CAssocArrayVTable::AssocFromString(const TCHAR *pch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssocVTable  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _tcsnzequalWord(pch, VTableDescToString(passoc->VTableDesc())))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _tcsnzequalWord(pch, VTableDescToString(passoc->VTableDesc())))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArrayVTable::AssocFromStringCi
//
//  Synopsis:   Finds the place in the hash table in which the assoc with
//              the specified string lives. If no assoc with the string is
//              present, returns the place in the hash table where the
//              assoc would be.
//
//----------------------------------------------------------------------------
const CAssocVTable *
CAssocArrayVTable::AssocFromStringCi(const TCHAR *pch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssocVTable  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _7csnziequalWord(pch, VTableDescToString(passoc->VTableDesc())))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _7csnziequalWord(pch, VTableDescToString(passoc->VTableDesc())))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBagVTable::GetImplCs
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CImplPtrBagVTable::GetImplCs(const TCHAR *pch, DWORD hash, VTABLEDESC_OWNERENUM owner) const
{
    const CAssocVTable *passoc;

    passoc = AssocFromString(pch, hash);

    if (passoc && passoc->VTableDesc()->SlowGetPropDesc(owner))
        return passoc->VTableDesc();

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBagVTable::GetImplCi
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CImplPtrBagVTable::GetImplCi(const TCHAR *pch, DWORD hash, VTABLEDESC_OWNERENUM owner) const
{
    const CAssocVTable *passoc;

    passoc = AssocFromStringCi(pch, hash);

    if (passoc && passoc->VTableDesc()->SlowGetPropDesc(owner))
        return passoc->VTableDesc();

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator constructor
//
//----------------------------------------------------------------------------
CPtrBagVTable::CIterator::CIterator(const CPtrBagVTable * pTable)
{
    _pTable = pTable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::Start
//
//----------------------------------------------------------------------------
void
CPtrBagVTable::CIterator::Start(VTABLEDESC_OWNERENUM owner, const CPtrBagVTable * pTable)
{
    if (pTable)
        _pTable = pTable;

    Assert (_pTable);

    _owner = owner;

    switch(_owner)
    {
    case VTABLEDESC_BELONGSTOOM:
        _idx = _pTable->_uOMWalker;
        break;
    case VTABLEDESC_BELONGSTOPARSE:
        _idx = _pTable->_uParserWalker;
        break;
    default:
        AssertSz(0, "Illegal Value for _owner");
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::Next
//
//----------------------------------------------------------------------------
void
CPtrBagVTable::CIterator::Next()
{
    Assert (_pTable);
    Assert (_pTable->_pHashTable[_idx]);
    Assert (!End());

    switch(_owner)
    {
    case VTABLEDESC_BELONGSTOOM:
        _idx = _pTable->_pHashTable[_idx]->VTableDesc()->GetOMWalker();
        break;
    case VTABLEDESC_BELONGSTOPARSE:
        _idx = _pTable->_pHashTable[_idx]->VTableDesc()->GetParserWalker();
        break;
    default:
        AssertSz(0, "Illegal Value for _owner");
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::End
//
//----------------------------------------------------------------------------
BOOL
CPtrBagVTable::CIterator::End() const
{
    Assert (_pTable);

    return _idx == 0x7FF;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::Item
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CPtrBagVTable::CIterator::Item() const
{
    Assert (_pTable);
    Assert (_pTable->_pHashTable[_idx]);

#ifdef _PREFIX_

    /*  
        VTableDesc() is guaranteed to return a pointer to a 
        valid object. However, since Prefix doesn't know this
        we'll throw in a special assert
    */

    const VTABLEDESC *pVTblDesc = NULL;

    pVTblDesc = _pTable->_pHashTable[idx]->VTableDesc();
    Assert(pVTableDesc);

    return pVTblDesc;

#endif

    return _pTable->_pHashTable[_idx]->VTableDesc();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator constructor
//
//----------------------------------------------------------------------------
CPtrBagVTableAggregate::CIterator::CIterator(const CPtrBagVTableAggregate * pAggregateTable)
{
    _pAggregateTable = pAggregateTable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::Start
//
//----------------------------------------------------------------------------
void
CPtrBagVTableAggregate::CIterator::Start(VTABLEDESC_OWNERENUM owner, const CPtrBagVTableAggregate * pAggregateTable)
{
    if (pAggregateTable)
        _pAggregateTable = pAggregateTable;

    Assert (_pAggregateTable);

    _owner = owner;
    _idx = 0;
    _vTableIterator.Start(owner, _pAggregateTable->_VTables[_idx]);
    // If we achieved the end of the aggregate, move onto the next one
    // and keep doing so until you get to one that has members
    while(_vTableIterator.End())
    {
        _idx++;
        if(_pAggregateTable->_VTables[_idx])
            _vTableIterator.Start(_owner, _pAggregateTable->_VTables[_idx]);
        else
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::Next
//
//----------------------------------------------------------------------------
void
CPtrBagVTableAggregate::CIterator::Next()
{
    Assert(_pAggregateTable);

    if(!End())
    {
        // Aggregate down to members
        _vTableIterator.Next();

        // If we achieved the end of the aggregate, move onto the next one
        // and keep doing so until you get to one that has members
        while(_vTableIterator.End())
        {
            _idx++;
            if(_pAggregateTable->_VTables[_idx])
                _vTableIterator.Start(_owner, _pAggregateTable->_VTables[_idx]);
            else
                break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::End
//
//----------------------------------------------------------------------------
BOOL
CPtrBagVTableAggregate::CIterator::End() const
{
    Assert (_pAggregateTable);

    return _pAggregateTable->_VTables[_idx] == NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::Item
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CPtrBagVTableAggregate::CIterator::Item() const
{
    Assert (_pAggregateTable);

    return End() ? NULL : _vTableIterator.Item();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::GetCi
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *CPtrBagVTableAggregate::GetCi(const TCHAR *pch,
                                                DWORD hash,
                                                VTABLEDESC_OWNERENUM owner) const
{
    const VTABLEDESC *retVal = NULL;

    // We know that we do not have any String Tables left if we get to a NULL
    // We also know that we have at least one string table, the one for
    // the current class
    for(int lcv = 0; !retVal && _VTables[lcv]; lcv++)
    {
        retVal = _VTables[lcv]->GetCi(pch, hash, owner);
    }
    return retVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::GetCs
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *CPtrBagVTableAggregate::GetCs(const TCHAR *pch,
                                                DWORD hash,
                                                VTABLEDESC_OWNERENUM owner) const
{
    const VTABLEDESC *retVal = NULL;

    // We know that we do not have any String Tables left if we get to a NULL
    // We also know that we have at least one string table, the one for
    // the current class
    for(int lcv = 0; !retVal && _VTables[lcv]; lcv++)
    {
        retVal = _VTables[lcv]->GetCs(pch, hash, owner);
    }
    return retVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::GetNumParserProps
//
//  Synopsis:   Gets the total number of ParserProperties in the aggregate
//              hash table
//
//----------------------------------------------------------------------------
DWORD CPtrBagVTableAggregate::GetNumParserProps() const
{
    DWORD nParserProps = 0;

    for(DWORD lcv = 0; _VTables[lcv]; lcv++)
    {
        nParserProps += _VTables[lcv]->_nParserProps;
    }
    return nParserProps;
}

#endif // !defined(ASCPARSE)
#else  // !defined(PDLPARSE)
// ASCPARSE includes this file, so specificially select this code for the PDLPARSE
#if defined(PDLPARSE)
//+---------------------------------------------------------------------------
//
//  Member:     CVTableHash::GetIndex
//
//  Synopsis:   Returns the hash table index that corresponds to the string
//
//----------------------------------------------------------------------------
BOOL
CVTableHash::GetIndex(const TCHAR *pch, DWORD cch, DWORD hash, DWORD *pIndex)
{
    Assert(pIndex)

    DWORD    s;
    const CAssoc *passoc;

    *pIndex = hash % _mHash;
    passoc = _pHashTable[*pIndex];

    if (!passoc)
        return FALSE;

    if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
        return TRUE;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (*pIndex < s)
            *pIndex += _mHash;

        *pIndex -= s;

        passoc = _pHashTable[*pIndex];

        if (!passoc)
            return FALSE;

        if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
            return TRUE;
    }
}

BOOL VTblIndexBelongsToParse(DWORD uVTblIndex)
{
    return uVTblIndex & PDLPARSE_BELONGSTOPARSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVTableHash::ComputeOMParseWalker
//
//  Synopsis:   Computes the walker for the Hash Table.  We use the walker
//              when we are iterating over the hash table entries.
//
//----------------------------------------------------------------------------
void
CVTableHash::ComputeOMParseWalker()
{
    DWORD uPrevOMWalker = 0x7FF;
    DWORD uPrevParserWalker = 0x7FF;

    for(DWORD lcv = 0; lcv < _mHash; lcv++)
    {
        const CAssoc *pAssoc = _pHashTable[lcv];
        if(pAssoc)
        {
            PropdescInfo *pPropDesc = (PropdescInfo *)pAssoc->Number();
            if(pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOPARSE)
            {
                if(uPrevParserWalker != 0x7FF)
                {
                    PropdescInfo *pPrevPropDesc =
                            (PropdescInfo *)_pHashTable[uPrevParserWalker]->Number();
                    pPrevPropDesc->_uOMParserWalker |= lcv;
                }
                uPrevParserWalker = lcv;
            }
            if(pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOOM)
            {
                if(uPrevOMWalker != 0x7FF)
                {
                    PropdescInfo *pPrevPropDesc =
                            (PropdescInfo *)_pHashTable[uPrevOMWalker]->Number();
                    pPrevPropDesc->_uOMParserWalker |= lcv << 11;
                }
                uPrevOMWalker = lcv;
            }
        }
    }
    // Set the last one to be "NULL"
    if(uPrevParserWalker != 0x7FF)
    {
        PropdescInfo *pPrevPropDesc =
                (PropdescInfo *)_pHashTable[uPrevParserWalker]->Number();
        pPrevPropDesc->_uOMParserWalker |= 0x7FF;
    }
    if(uPrevOMWalker != 0x7FF)
    {
        PropdescInfo *pPrevPropDesc =
                (PropdescInfo *)_pHashTable[uPrevOMWalker]->Number();
        pPrevPropDesc->_uOMParserWalker |= 0x7FF << 11;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVTableHash::ToFile
//
//  Synopsis:   Spits out the hash table
//
//----------------------------------------------------------------------------
HRESULT
CVTableHash::ToFile(FILE *file, LPTSTR className, int nParserEntries)
{
    DWORD lcvHashTable;
    DWORD uOMWalker = 0x7FF;
    DWORD uParserWalker = 0x7FF;

    if(_mHash > 1024)
        return E_FAIL;

    ComputeOMParseWalker();

	// Write out the entries in the hash table, skipping over the empty ones
	for(lcvHashTable = 0; lcvHashTable < _mHash; lcvHashTable++)
    {
        const CAssoc *pAssoc = _pHashTable[lcvHashTable];
        if(pAssoc)
        {
            PropdescInfo *pPropDesc = (PropdescInfo *)pAssoc->Number();
            DWORD uVTblIndex = pPropDesc->_uVTblIndex;

            // If the PropDesc belongs to the Parser, store the index
            if(VTblIndexBelongsToParse(uVTblIndex))
            {
                uVTblIndex |= nParserEntries << 19;
                nParserEntries++;
            }

            // Write out the hash table entry
            fprintf(file, "static const CAssocVTable s_AssocVTable%ls%d = { {(PROPERTYDESC *)&s_%sdesc%s%s, 0x%x, 0x%x}, 0x%x};\n",
    		        className, lcvHashTable,
                    pPropDesc->_fProperty ? "prop" : "meth",
                    pPropDesc->_szClass,
                    pPropDesc->_szPropName,
                    pPropDesc->_uOMParserWalker,
                    uVTblIndex,
                    pAssoc->Hash());
        }
    }

    // Next, we declare the Hash Table
    fprintf(file, "const CAssocVTable * const %ls::s_AssocVTablePtr [ ] = {\n", className);

    // Duplicate the Hash Table
    for(lcvHashTable = 0; lcvHashTable < _mHash; lcvHashTable++)
    {
        if(lcvHashTable > 0)
        {
            fprintf(file, ",\n");
        }
        if(!_pHashTable[lcvHashTable])
        {
            fprintf(file, "        NULL");
        }
        else
        {
            PropdescInfo *pPropDesc =
                    (PropdescInfo *)_pHashTable[lcvHashTable]->Number();

            fprintf(file, "        &s_AssocVTable%ls%d",
					className, lcvHashTable);

            // Set the start of the walker
            if((uOMWalker == 0x7FF) &&
                (pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOOM))
            {
                uOMWalker = lcvHashTable;
            }
            if((uParserWalker == 0x7FF) &&
                (pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOPARSE))
            {
                uParserWalker = lcvHashTable;
            }
        }
    }
    fprintf(file, "\n    };\n");

    // Write out the rest of the member variables
    fprintf(file, "const CAssocArrayVTable %ls::s_StringTable = {\n"
                  "    s_AssocVTablePtr,\n"
                  "    %d, // _cHash\n"
                  "    %d, // _mHash\n"
                  "    %d, // _sHash\n"
                  "    %d, // _maxHash\n"
                  "    %d, // _iSize\n"
                  "    %d, // _nParserProps\n"
                  "    0x%x, // _uOMWalker\n"
                  "    0x%x, // _uParserWalker\n"
                  "    TRUE // _fStatic\n"
                  "}; // End of StringTable\n",
                  className, _cHash, _mHash, _sHash, _maxHash, _iSize, nParserEntries,
                  uOMWalker, uParserWalker);

    return S_OK;
}
#endif  // defined(PDLPARSE)
#endif  // !defined(PDLPARSE)

//+---------------------------------------------------------------------------
//
//  DEBUG ONLY helper: TestStringTable
//
//----------------------------------------------------------------------------

#if DBG == 1
void TestStringTable()
{
    {
        int             c;
        LPVOID          pv;
        CStringTable    st;

        CStringTable::CIterator itr;

        st.Add(_T("foo"),     (LPVOID)1);
        st.Add(_T("foo2"),    (LPVOID)2);
        st.Add(_T("foo3"), 3, (LPVOID)3);
        st.Add(_T("bar"),     (LPVOID)4);
        st.Add(_T("zoo"),     (LPVOID)5);

        Assert (S_OK   == st.Find(_T("foo"),  &pv));
        Assert ((LPVOID)3 == pv);                       // (foo3,3) overrode foo
        Assert (S_OK   == st.Find(_T("foo2"), &pv));
        Assert ((LPVOID)2 == pv);
        Assert (S_OK   == st.Find(_T("bar"),  &pv));
        Assert ((LPVOID)4 == pv);
        Assert (S_OK   == st.Find(_T("zoo"),  &pv));
        Assert ((LPVOID)5 == pv);
        Assert (E_FAIL == st.Find(_T("baz"),  NULL));
        Assert (E_FAIL == st.Find(_T("fo"),   NULL));
        Assert (E_FAIL == st.Find(_T("foo3"), NULL));   // (foo3, 3) should have been added as foo

        c = 0;
        for (itr.Start(&st); !itr.End(); itr.Next())
        {
            c++;
        }
        Assert (4 == c);
    }
    {
        int             c;
        LPVOID          pv;
        CStringTable    st(CStringTable::CASEINSENSITIVE);

        CStringTable::CIterator itr;

        st.Add(_T("foo"),     (LPVOID)1);
        st.Add(_T("foo2"),    (LPVOID)2);
        st.Add(_T("foo3"), 3, (LPVOID)3);
        st.Add(_T("bar"),     (LPVOID)4);
        st.Add(_T("zoo"),     (LPVOID)5);
        st.Add(_T("Zoo"),     (LPVOID)6);

        Assert (S_OK == st.Find(_T("foo"),  &pv));
        Assert ((LPVOID)3 == pv);                       // (foo3,3) overrode foo
        Assert (S_OK == st.Find(_T("foo2"), &pv));
        Assert ((LPVOID)2 == pv);
        Assert (S_OK == st.Find(_T("bar"),  &pv));
        Assert ((LPVOID)4 == pv);
        Assert (S_OK == st.Find(_T("zoo"),  &pv));
        Assert ((LPVOID)6 == pv);
        Assert (S_OK == st.Find(_T("zOO"),  &pv));
        Assert ((LPVOID)6 == pv);                       // should be same as zoo
        Assert (E_FAIL == st.Find(_T("baz"),  NULL));
        Assert (E_FAIL == st.Find(_T("fo"),   NULL));
        Assert (E_FAIL == st.Find(_T("foo3"), NULL));   // (foo3, 3) should have made it as foo

        c = 0;
        for (itr.Start(&st); !itr.End(); itr.Next())
        {
            c++;
        }
        Assert (4 == c);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\border.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       border.cxx
//
//  Contents:   Border helper implementation
//
//  Functions:  DrawBorder
//
//  History:    18-Jul-95   SumitC      Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

// global const definitions

const int HAIRLINE_IN_HIMETRICS = 26;
const int BORDEREFFECT_IN_HIMETRICS = 52;


//+-------------------------------------------------------------------------
//
//  Method:     DrawEdge2
//
//  Synopsis:   This routine is functionally equivalent to the Win95
//              DrawEdge API, except the following are not supported:
//                  BF_SOFT, BF_ADJUST, BF_FLAT, BF_MONO, BF_DIAG*
//              Also, colors to be used are passed in by the "c3d"
//              (ThreeDColors object) reference, rather than assuming
//              and being limited to the system colors.
//
//              If BF_MONO flag is specified, only the inner border is
//              drawn. This is used to draw flat scrollbars.
//
//--------------------------------------------------------------------------

void DrawEdge2(XHDC hdc,
        LPRECT lprc,
        UINT edge,
        UINT flags,
        ThreeDColors & c3d,
        COLORREF colorBorder,
        UINT borderXWidth,
        UINT borderYWidth)
{
    COLORREF    colorTL;
    COLORREF    colorBR;
    RECT        rc;
    RECT        rc2;
    UINT        bdrMask;
    HBRUSH      hbrOld = NULL;
    COLORREF    crNow  = (COLORREF)0xFFFFFFFF;

    rc = *lprc;
    BOOL foutEffect = !(flags & BF_MONO); // No outer border if BF_MONO

    int XIn, XOut = 0, YIn, YOut = 0; //init XOut, YOut for retail build to pass

    if (foutEffect)
    {
        // border width can be odd number of pixels, so we divide it between
        // the inner and outer effect.

        XIn = borderXWidth / 2;
        XOut = borderXWidth - XIn;

        YIn = borderYWidth / 2;
        YOut = borderYWidth - YIn;
    }
    else
    {
        XIn = borderXWidth;
        YIn = borderYWidth;
    }

    Assert((BDR_OUTER == 0x0003) && (BDR_INNER == 0x000C));

    Assert(rc.left <= rc.right);
    Assert(rc.top <= rc.bottom);
    if (! (flags & BF_FLAT))
    {
        bdrMask = (foutEffect) ? BDR_OUTER : BDR_INNER;
        for (; bdrMask <= BDR_INNER; bdrMask <<= 2)
        {
            switch (edge & bdrMask)
            {
                case BDR_RAISEDOUTER:
                    colorTL = (flags & BF_SOFT) ? c3d.BtnHighLight() : c3d.BtnLight();
                    colorBR = c3d.BtnDkShadow();
                    break;

                case BDR_RAISEDINNER:
                    colorTL = (flags & BF_SOFT) ? c3d.BtnLight() : c3d.BtnHighLight();
                    colorBR = c3d.BtnShadow();
                    break;

                case BDR_SUNKENOUTER:
                    //fButton should be wndframe
                    colorTL = (flags & BF_SOFT) ? c3d.BtnDkShadow() : c3d.BtnShadow();
                    colorBR = c3d.BtnHighLight();
                    break;

                case BDR_SUNKENINNER:
                    if (flags & BF_MONO)
                    {
                        // inversion of BDR_RAISEDINNER
                        colorTL = c3d.BtnShadow();
                        colorBR = (flags & BF_SOFT) ? c3d.BtnLight() : c3d.BtnHighLight();
                    }
                    else
                    {
                        colorTL = (flags & BF_SOFT) ? c3d.BtnShadow() :  c3d.BtnDkShadow();
                        colorBR = c3d.BtnLight();
                    }
                    break;

                default:
                    return;
            }

            if (flags & (BF_RIGHT | BF_BOTTOM))
            {
                if (colorBR != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, colorBR, &hbrNew, &hbrOld, &crNow);
                }

                if (flags & BF_RIGHT)
                {
                    rc2 = rc;
                    rc2.left = (rc.right -= foutEffect ? XOut : XIn);
                    if (rc2.left < rc.left)
                        rc2.left = rc.left;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }

                if (flags & BF_BOTTOM)
                {
                    rc2 = rc;
                    rc2.top = (rc.bottom -= foutEffect ? YOut : YIn);
                    if (rc2.top < rc.top)
                        rc2.top = rc.top;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }
            }

            if (flags & (BF_LEFT | BF_TOP))
            {
                if (colorTL != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, colorTL, &hbrNew, &hbrOld, &crNow);
                }
    
                if (flags & BF_LEFT)
                {
                    rc2 = rc;
                    rc2.right = (rc.left += foutEffect ? XOut : XIn);
                    if (rc2.right > rc.right)
                        rc2.right = rc.right;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }

                if (flags & BF_TOP)
                {
                    rc2 = rc;
                    rc2.bottom = (rc.top += foutEffect ? YOut : YIn);
                    if (rc2.bottom > rc.bottom)
                        rc2.bottom = rc.bottom;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }
            }
            if (foutEffect)
                foutEffect = FALSE;
        }
    }
    else
    {
        if (colorBorder != crNow)
        {
            HBRUSH hbrNew;
            SelectCachedBrush(hdc, colorBorder, &hbrNew, &hbrOld, &crNow);
        }

        if (flags & BF_RIGHT)
        {
            rc2 = rc;
            rc2.left = (rc.right -= borderXWidth);
            if (rc2.left < rc.left)
                rc2.left = rc.left;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }

        if (flags & BF_BOTTOM)
        {
            rc2 = rc;
            rc2.top = (rc.bottom -= borderYWidth);
            if (rc2.top < rc.top)
                rc2.top = rc.top;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }

        if (flags & BF_LEFT)
        {
            rc2 = rc;
            rc2.right = (rc.left += borderXWidth);
            if (rc2.right > rc.right)
                rc2.right = rc.right;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }

        if (flags & BF_TOP)
        {
            rc2 = rc;
            rc2.bottom = (rc.top += borderYWidth);
            if (rc2.bottom > rc.bottom)
                rc2.bottom = rc.bottom;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }
    }

    if (flags & BF_MIDDLE)
    {
        if (c3d.BtnFace() != crNow)
        {
            HBRUSH hbrNew;
            SelectCachedBrush(hdc, c3d.BtnFace(), &hbrNew, &hbrOld, &crNow);
        }
        PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
            rc.bottom - rc.top, PATCOPY);
    }

    if (hbrOld)
        ReleaseCachedBrush((HBRUSH)SelectObject(hdc, hbrOld));
}

//+---------------------------------------------------------------------------
//
//  Function:   BRGetBorderWidth
//
//  Synopsis:   Return the border size in himetrics given border attributes
//
//  Arguments:  [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//
//  Returns:    int          -- -1 is an error value
//
//  History:    9-13-95 created [gideons]
//
//----------------------------------------------------------------------------

int
BRGetBorderWidth( fmBorderStyle BorderStyle )
{
    int uBorderWidth;

    // count for the beveled edge

    if (BorderStyle > fmBorderStyleSingle)
    {
        uBorderWidth = BORDEREFFECT_IN_HIMETRICS;
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        uBorderWidth = HAIRLINE_IN_HIMETRICS;
    }
    else
    if (BorderStyle == fmBorderStyleNone)
    {
        uBorderWidth = 0;
    }
    else
    {
        uBorderWidth = -1;
    }

    return uBorderWidth;
}






//+---------------------------------------------------------------------------
//
//  Function:   BRAdjustRectForBorder
//
//  Synopsis:   adjusts a given rectangle's client area given border attributes
//              taking zooming into account
//
//  Arguments:  [pDI]         -- CDrawInfo
//              [prcl]        -- rectangle to adjust
//              [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//
//  Returns:    HRESULT
//
//  History:    05-Sep-95   SumitC      Created
//              09-12-95    gideons     modified to support zooming
//
//----------------------------------------------------------------------------


HRESULT
BRAdjustRectForBorderActual(
        CDocScaleInfo * pdocScaleInfo,
        RECT *          prc,
        fmBorderStyle   BorderStyle,
        BOOL            fInflateForBorder)
{
    int uInflateXBy, uInflateYBy;
    UINT inflateUnit;

    Assert(prc);

    // count for the beveled edge

    if (BorderStyle > fmBorderStyleSingle)
    {
        // inflateUnit is 52 HiMetrics
        inflateUnit =  BORDEREFFECT_IN_HIMETRICS;
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        // inflateUnit = 26 HiMetrics.
        inflateUnit = HAIRLINE_IN_HIMETRICS;
    }
    else
        goto Cleanup;

    // compute the actually border dimentions
    uInflateXBy =  pdocScaleInfo->DeviceFromHimetricX(inflateUnit);
    uInflateYBy =  pdocScaleInfo->DeviceFromHimetricY(inflateUnit);

    // Border width can't go below 1 pixel
    if (uInflateXBy == 0)
        uInflateXBy = 1;

    if (uInflateYBy == 0)
        uInflateYBy = 1;

    // Compute border size with zooming.
    if (fInflateForBorder)
        InflateRect((RECT *)prc, uInflateXBy, uInflateYBy );
    else
        InflateRect((RECT *)prc, -uInflateXBy, -uInflateYBy );

   if (prc->left > prc->right)
        prc->left = prc->right;
    if (prc->top > prc->bottom)
        prc->top = prc->bottom;

Cleanup:
    return S_OK;
}

HRESULT
BRAdjustRectForBorder(
        CDocScaleInfo * pdocScaleInfo,
        RECT *          prc,
        fmBorderStyle   BorderStyle)
{
    return BRAdjustRectForBorderActual(
                    pdocScaleInfo,
                    prc,
                    BorderStyle,
                    FALSE);
}

HRESULT
BRAdjustRectForBorderRev(
        CDocScaleInfo * pdocScaleInfo,
        RECT *          prc,
        fmBorderStyle   BorderStyle)
{
    return BRAdjustRectForBorderActual(
                    pdocScaleInfo,
                    prc,
                    BorderStyle,
                    TRUE);
}






//+---------------------------------------------------------------------------
//
//  Function:   BRAdjustRectlForBorder
//
//  Synopsis:   adjusts a given rectangle's client area given border attributes
//              WITHOUT taking zooming into account
//
//  Arguments:  [prcl]        -- rectangle to adjust
//              [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//
//  Returns:    HRESULT
//
//  History:    05-Sep-95   SumitC      Created
//              09-12-95    gideons     modified to support zooming
//
//----------------------------------------------------------------------------

HRESULT
BRAdjustRectlForBorder
(
        RECTL * prcl,
        fmBorderStyle BorderStyle)
{

    if (BorderStyle > fmBorderStyleSingle)
    {
        // Compute border size with zooming.

        InflateRect((RECT *)prcl,
                    -BORDEREFFECT_IN_HIMETRICS, -BORDEREFFECT_IN_HIMETRICS);
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        // Compute border size with zooming.
        InflateRect((RECT *)prcl,
                    -HAIRLINE_IN_HIMETRICS, -HAIRLINE_IN_HIMETRICS );
    }


    return S_OK;
}





//+---------------------------------------------------------------------------
//
//  Function:   BRAdjustSizelForBorder
//
//  Synopsis:   adjusts a given rectangle's client area given border attributes
//              WITHOUT taking zooming into account
//
//  Arguments:  [psizel]      -- sizel to adjust
//              [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//              [fSubtractAdd]-- add or subtract borders from the size
//
//  Returns:    HRESULT
//
//  History:    09-19-95    gideons     created
//
//----------------------------------------------------------------------------

HRESULT
BRAdjustSizelForBorder
(
        SIZEL * psizel,
        fmBorderStyle BorderStyle,
        BOOL fSubtractAdd)
{

    int iSubtractAdd = fSubtractAdd? 1: -1;

    if (BorderStyle > fmBorderStyleSingle)
    {
        psizel->cx += iSubtractAdd * 2 * BORDEREFFECT_IN_HIMETRICS;
        psizel->cy += iSubtractAdd * 2 * BORDEREFFECT_IN_HIMETRICS;
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        psizel->cx += iSubtractAdd * 2 * HAIRLINE_IN_HIMETRICS;
        psizel->cy += iSubtractAdd * 2 * HAIRLINE_IN_HIMETRICS;
    }

    // Don't allow a negative size
    psizel->cx = max(psizel->cx, 0L);
    psizel->cy = max(psizel->cy, 0L);

    return S_OK;
}




void DrawEdge2(HDC hdc,
        LPRECT lprc,
        UINT edge,
        UINT flags,
        ThreeDColors & c3d,
        COLORREF colorBorder,
        UINT borderXWidth,
        UINT borderYWidth);






//+---------------------------------------------------------------------------
//
//  Function:   BRDrawBorder
//
//  Synopsis:   Draws a border for a Forms3 control, or the form
//
//  Arguments:  [pDI]         -- [in] CDrawInfo *
//              [prc]         -- [in,out] rect in pixels
//              [BorderStyle] -- border style
//              [Effect]      -- border effect
//              [colorBorder] -- color of Border
//              [dwFlags]     -- BRFLAGS_BUTTON: if set, use "hard" edges.  usually use "soft"
//                               BRFLAGS_ADJUSTRECT: if set, adjust the rect to reflect the
//                               border drawn.
//                               BRFLAGS_DEFAULT: if set draw default button retangle around
//                               drawing rect and insert everything else accordingly
//
//  Returns:    HRESULT
//
//  History:    05-Sep-95   SumitC      Created
//              09-12-95    gideons     modified to support zooming
//
//----------------------------------------------------------------------------


HRESULT
BRDrawBorder(
        CDrawInfo *pDI,
        RECT * prc,
        fmBorderStyle BorderStyle,
        COLORREF colorBorder,
        ThreeDColors * peffectColor,
        DWORD dwFlags)
{
    ThreeDColors    *ptdc;
    ThreeDColors    tdc;
    UINT            uBdrXWidth;
    UINT            uBdrYWidth;
    UINT            uEdgeStyle = 0, uEdgeFlags = 0;
    UINT            borderUnit;


    if (peffectColor == NULL)
    {
        ptdc = &tdc; // get the default colors
    }
    else
    {
        ptdc = peffectColor;
    }

    Assert(ptdc != NULL);
    AssertXHDC(pDI->_hdc);


    if(dwFlags & BRFLAGS_DEFAULT)
    {
        uBdrYWidth = pDI->DeviceFromHimetricY(HAIRLINE_IN_HIMETRICS);
        uBdrXWidth = pDI->DeviceFromHimetricX(HAIRLINE_IN_HIMETRICS);

        DrawEdge2(pDI->_hdc,
                  (RECT *)prc,
                  0,
                  BF_FLAT | BF_RECT,
                  *ptdc,
                  colorBorder,
                  uBdrXWidth,
                  uBdrYWidth);

        BRAdjustRectForBorder(pDI,
                              (RECT *) prc,
                              fmBorderStyleSingle);
    }

    // draw the beveled edge
    if (BorderStyle > fmBorderStyleSingle)
    {
        borderUnit =  (dwFlags & BRFLAGS_MONO) ?
                        HAIRLINE_IN_HIMETRICS :
                        BORDEREFFECT_IN_HIMETRICS;

        switch (BorderStyle)
        {
        case fmBorderStyleRaised:
            uEdgeStyle = EDGE_RAISED;
            break;

        case fmBorderStyleSunken:
            uEdgeStyle = EDGE_SUNKEN;
            break;

        case fmBorderStyleEtched:
            uEdgeStyle = EDGE_ETCHED;
            break;

        case fmBorderStyleBump:
            uEdgeStyle = EDGE_BUMP;
            break;

        default:
            Assert(0 && "CBorderHelper::Render, illegal effect value");
        }

        // Draw the border of the control

        uEdgeFlags = BF_RECT | ((dwFlags & BRFLAGS_BUTTON) ? BF_SOFT : 0);
        if (dwFlags & BRFLAGS_MONO)
        {
            uEdgeFlags |= BF_MONO;
        }
    }
    else if (BorderStyle == fmBorderStyleSingle)
    {
        borderUnit = HAIRLINE_IN_HIMETRICS;

        uEdgeFlags = BF_FLAT | BF_RECT;
    }
    else
        goto cleanup;   // nothing to do


    uBdrYWidth = pDI->DeviceFromHimetricY(borderUnit);
    uBdrXWidth = pDI->DeviceFromHimetricX(borderUnit);

    // border width can not go below 1 pixel
    if (uBdrYWidth == 0)
        uBdrYWidth = 1;

    if (uBdrXWidth == 0)
        uBdrXWidth = 1;

   //Draw the border
   //NOTE DrawEdge2  currently checks for underflow of prc
    DrawEdge2(pDI->_hdc,
              (RECT *)prc,
              uEdgeStyle,
              uEdgeFlags,
              *ptdc,
              colorBorder,
              uBdrXWidth,
              uBdrYWidth);

    if (dwFlags & BRFLAGS_ADJUSTRECT)
    {
        BRAdjustRectForBorder( pDI, prc, BorderStyle);
    }

cleanup:

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\baseprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       baseprot.cxx
//
//  Contents:   Implementation of a base class for pluggable protocols
//
//  History:    02-12-97    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_BASEPROT_HXX_
#define X_BASEPROT_HXX_
#include "baseprot.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::QueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IInternetProtocolInfo)
    {
        *ppv = (IInternetProtocolInfo *)this;
    }
    else
    {
        RRETURN(super::QueryInterface(riid, ppv));
    }

    Assert(*ppv);
    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    CStr    cstr;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (ParseAction == PARSE_DOMAIN)
    {
        BSTR bstrTemp;

        hr = THR(UnwrapSpecialUrl(pwzUrl, cstr));
        if (hr)
            goto Cleanup;

        *pcchResult = cstr.Length() + 1;
        
        if (cstr.Length() + 1 > cchResult)
        {
            // Not enough room
            hr = S_FALSE;
            goto Cleanup;
        }

        cstr.AllocBSTR(&bstrTemp);

        UrlGetPartW(bstrTemp, pwzResult, pcchResult, URL_PART_HOSTNAME, 0);  
        SysFreeString(bstrTemp);
    }

Cleanup:
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::CombineUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::CombineUrl(
    LPCWSTR     pwzBaseUrl,
    LPCWSTR     pwzRelativeUrl,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;
    // get the correct base url for navigating to a non-pluggable protocol from a
    // pluggable protocol. We get here from CoInternetCombineUrl if the base url is
    // a pluggable protocol. So, search for the last embedded \1 to extract the true
    // base url and if present, call the API again to combine the non-pluggable
    // protocol url properly. if not prest, just tell urlmon to do the default thing.
    if (pwzBaseUrl)
    {
        TCHAR *pchSrc = _tcsrchr(pwzBaseUrl, _T('\1'));
        if (pchSrc)
        {
            hr = THR(CoInternetCombineUrl(
                    ++pchSrc, 
                    pwzRelativeUrl, 
                    URL_ESCAPE_SPACES_ONLY, 
                    pwzResult, 
                    cchResult, 
                    pcchResult, 
                    0));
        }
    }

    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::CompareUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::CompareUrl(
    LPCWSTR     pwzUrl1,
    LPCWSTR     pwzUrl2,
    DWORD       dwFlags)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::QueryInfo
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::QueryInfo(
    LPCWSTR         pwzUrl,
    QUERYOPTION     QueryOption,
    DWORD           dwQueryFlags,
    LPVOID          pvBuffer,
    DWORD           cbBuffer,
    DWORD *         pcbBuffer,
    DWORD           dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    switch (QueryOption)
    {
    case QUERY_USES_NETWORK:
        {
            if (!pvBuffer || cbBuffer < sizeof(DWORD))
                return E_FAIL;

            if (pcbBuffer)
            {
                *pcbBuffer = sizeof(DWORD);
            }

            *(DWORD *)pvBuffer = FALSE;
            hr = S_OK;
        }
        break;

    case QUERY_IS_SECURE:
        {
            if (!pvBuffer || cbBuffer < sizeof(DWORD))
                return E_FAIL;

            if (pcbBuffer)
            {
                *pcbBuffer = sizeof(DWORD);
            }

            *(DWORD *)pvBuffer = HasSecureContext(pwzUrl);
            hr = S_OK;
        }
        break;
    }

    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}


//+---------------------------------------------------------------------------
//
//  Method:     UnwrapSpecialUrl
//
//  Synopsis:   Helper to unwrap a url by lopping off any stuff after \1
//
//----------------------------------------------------------------------------

HRESULT
UnwrapSpecialUrl(LPCWSTR pchUrl, CStr &cstrUnwrappedUrl)
{
    TCHAR * pchSpecial = NULL;
    HRESULT hr = S_OK;
    static TCHAR   ach[pdlUrlLen];
    DWORD   dwSize;
        
    hr = THR(CoInternetParseUrl(
            pchUrl, 
            PARSE_ENCODE, 
            0, 
            ach, 
            ARRAY_SIZE(ach), 
            &dwSize, 
            0));
    if (hr)
        goto Cleanup;

    pchSpecial = _tcsrchr(ach, _T('\1'));
    if (pchSpecial)
    {
        hr = THR(cstrUnwrappedUrl.Set(pchSpecial + 1));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(cstrUnwrappedUrl.Set(ach));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CBaseProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CBaseProtocol::CBaseProtocol(IUnknown *pUnkOuter) : super()
{
    _pUnkOuter = pUnkOuter ? pUnkOuter : PunkInner();
    _bscf = BSCF_FIRSTDATANOTIFICATION;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::~CBaseProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CBaseProtocol::~CBaseProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Passivate
//
//  Synopsis:   1st stage dtor
//
//----------------------------------------------------------------------------

void
CBaseProtocol::Passivate()
{
    ClearInterface(&_pStm);
    super::Passivate();
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::PrivateQueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        *ppv = PunkInner();
    }
    else if (riid == IID_IInternetProtocol || riid == IID_IInternetProtocolRoot)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }

    Assert(*ppv);
    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    PROTOCOLDATA    protdata;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;

    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;
    
    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //
    
    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // Always go async and return E_PENDING now.
    // Perform script execution when we get the Continue.
    //

    hr = E_PENDING;
    protdata.grfFlags = PI_FORCE_ASYNC;
    protdata.dwState = BIND_ASYNC;
    protdata.pData = NULL;
    protdata.cbData = 0;

    _pProtSink->Switch(&protdata);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    HRESULT hr = E_FAIL;

    if (_fAborted)
        return hr;

    Assert(!pStateInfoIn->pData && !pStateInfoIn->cbData && 
            pStateInfoIn->dwState == BIND_ASYNC);

    if (pStateInfoIn->dwState == BIND_ASYNC)
    {
        hr =  THR(ParseAndBind());
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Abort
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    _fAborted = TRUE;
    RRETURN(_pProtSink->ReportResult(E_ABORT, 0, 0));
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Terminate
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Terminate(DWORD dwOptions)
{
    ClearInterface(&_pOIBindInfo);
    ClearInterface(&_pProtSink);
    ReleaseBindInfo(&_bindinfo);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Suspend
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Suspend()
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Resume
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Resume()
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Read
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    HRESULT hr = S_OK;
    
    if (!_pStm)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = THR(_pStm->Read(pv, cb, pcbRead));
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Seek
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    HRESULT hr = S_OK;
    
    if (!_pStm)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = THR(_pStm->Seek(dlibMove, dwOrigin, plibNewPosition));
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::LockRequest
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::LockRequest(DWORD dwOptions)
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::UnlockRequest
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::UnlockRequest()
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::QueryService
//
//  Synopsis:   per IServiceProvider
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::QueryService(REFGUID rsid, REFIID riid, void ** ppv)
{
    HRESULT             hr = S_OK;
    IServiceProvider *  pSP = NULL;

    *ppv = NULL;

    hr = THR_NOTRACE(_pProtSink->QueryInterface(
            IID_IServiceProvider, (void **)&pSP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pSP->QueryService(rsid, riid, ppv));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pSP);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding.
//              Derived classes should just implement this one method
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::ParseAndBind()
{
    if (_pProtSink)
    {
        _pProtSink->ReportResult(E_UNEXPECTED, 0, 0);
    }
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     HasSecureContext
//
//  Synopsis:   Scans a \1-style URL to see if it should be treated as secure
//
//----------------------------------------------------------------------------
BOOL
HasSecureContext(const TCHAR *pchUrl)
{
    TCHAR *pchSpecial; 
    TCHAR *pchNext;
    TCHAR ach[pdlUrlLen]; 
    DWORD dwSize; 

    if (! THR(CoInternetParseUrl( 
        pchUrl, 
        PARSE_ENCODE, 
        0, 
        ach, 
        ARRAY_SIZE(ach), 
        &dwSize, 
        0))) 
    {
        // 1. scan for \1\1 - if present, we have mixed security somewhere along the way
        pchSpecial = ach;

        for (;;)
        {
            pchNext = _tcschr(pchSpecial, _T('\1'));
            
            if (!pchNext)
                break;
                
            pchSpecial = pchNext + 1;

            // Mixed security or missing context: not secure
            
            if (*pchSpecial == _T('\1') || *pchSpecial == _T('\0'))
                return FALSE;
        }
        
        // Last context is https: secure
        
        if (pchSpecial && URL_SCHEME_HTTPS == GetUrlScheme(pchSpecial)) 
            return TRUE; 
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\brush.cxx ===
//+------------------------------------------------------------------------
//
//  File:       brush.cxx
//
//  Contents:   Brush utilities.
//
//  History:    20-Oct-94   GaryBu  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

PerfDbgTag(tagBrushCache,        "BrushCache", "Trace BrushCache")
PerfDbgTag(tagDisableBrushCache, "BrushCache", "Disable Brush Cache")

MtDefine(THREADSTATE_pbcr, THREADSTATE, "THREADSTATE::_pbcr")

#define CBCR_MAX            16

struct BCR
{
    COLORREF    cr;
    int         refs;
    HBRUSH      hbr;
};


//+----------------------------------------------------------------------------
//
//  Function:   InitBrushCache
//
//  Synopsis:   Allocate brush cache array
//
//  Arguments:  pts - THREADSTATE of current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitBrushCache(
    THREADSTATE *   pts)
{
    Assert(pts);

    pts->pbcr = new(Mt(THREADSTATE_pbcr)) BCR[CBCR_MAX];
    if (!pts->pbcr)
        RRETURN(E_OUTOFMEMORY);

    MemSetName((pts->pbcr, "Brush Cache Data"));

    memset(pts->pbcr, 0, sizeof(BCR) * CBCR_MAX);

    pts->ibcrNext = -1;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   DeinitBrushCache
//
//  Synopsis:   Releases any brushes still stored in the cache
//
//----------------------------------------------------------------------------
void
DeinitBrushCache(
    THREADSTATE *   pts)
{
    int     c;
    BCR *   pbcr;

    Assert(pts);

    if (!pts->pbcr)
        return;

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        Assert(pbcr->refs == 0 && "Unreleased brush in cache at Deinit");
        if (pbcr->hbr)
            DeleteObject(pbcr->hbr);
    }

    delete [] pts->pbcr;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCachedBrush
//
//  Synopsis:   Returns a brush handle matching the given OLE Color.
//              A process-wide cache of brushes is maintained.  If this
//              function is called and a matching brush is found in the
//              cache, it is returned.  If no match is found, one of
//              the cached brushes is kicked out and a new one is
//              added.
//
//              ReleaseCachedBrush should be called to release the
//              brush handle when it is no longer needed.
//
//  Arguments:  clr   OLE Color of the brush
//
//  Returns:    Brush handle.
//
//  Notes:      THE ARGUMENT IS A *COLORREF*!! (Don't pass in an OLE_COLOR)
//
//----------------------------------------------------------------------------

HBRUSH
GetCachedBrush(COLORREF cr)
{
    THREADSTATE *   pts;
    int             c;
    BCR *           pbcr;
    HBRUSH          hbr;

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDisableBrushCache))
        return(CreateSolidBrush(cr));
#endif

    Assert((cr & 0x80000000) == 0);

    pts = GetThreadState();

    // Look for previously cached brush.

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        Assert(pbcr->hbr != NULL || pbcr->cr == 0);

        //  The brush cache initially starts out filled with zeros,
        //    but cr == 0 is a valid color, so we need to check for
        //    both the color matching AND having a valid brush.

        if (pbcr->cr == cr && pbcr->hbr != NULL)
        {
            pbcr->refs++;

            PerfDbgLog3(tagBrushCache, NULL, "GCB: found %x @ %d (%d)\r",
                    cr, pbcr - pts->pbcr, pbcr->refs);

            return pbcr->hbr;
        }
    }

    // Otherwise, create a new brush and add it to the cache.

    hbr = CreateSolidBrush(cr);
    if (!hbr)
    {
        TraceTag((tagError,
                "GCB: could not create brush, falling back to stock brush"));

        // QUESTION: Do we need to be careful sharing stock objects between threads?
        hbr = (HBRUSH)GetStockObject(BLACK_BRUSH);
    }

    // Handle case where the system returns the same
    // brush handle for different color values.

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        if (pbcr->hbr == hbr)
        {
            pbcr->refs++;

            PerfDbgLog3(tagBrushCache, NULL, "GCB: found dup of %x @ %d (%d)\r",
                    cr, pbcr - pts->pbcr, pbcr->refs);

            return hbr;
        }
    }

    pbcr = pts->pbcr + pts->ibcrNext;
    for (c = CBCR_MAX; c > 0; c--)
    {
        pbcr++;
        pts->ibcrNext++;
        if (pts->ibcrNext >= CBCR_MAX)
        {
            pts->ibcrNext = 0;
            pbcr = pts->pbcr;
        }

        Assert(0 <= pts->ibcrNext && pts->ibcrNext < CBCR_MAX);

        if (pbcr->refs == 0)
        {
            if (pbcr->hbr)
                DeleteObject(pbcr->hbr);

            pbcr->hbr = hbr;
            pbcr->cr = cr;
            pbcr->refs = 1;

            PerfDbgLog2(tagBrushCache, NULL, "GCB: new %x @ %d (1)\r", cr, pts->ibcrNext);

            return hbr;
        }

    }

    TraceTag((tagWarning, "GCB: cache full"));

    return hbr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseCachedBrush
//
//  Synopsis:   Releases a brush handle returned by GetCachedBrush.
//
//  Arguments:  hbr  Brush handle to release
//
//----------------------------------------------------------------------------

void
ReleaseCachedBrush(HBRUSH hbr)
{
    THREADSTATE *   pts;
    int             c;
    BCR *           pbcr;

    if (!hbr)
        return;

    pts = GetThreadState();

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        if (pbcr->hbr == hbr)
        {
            Assert(pbcr->refs > 0);
            pbcr->refs--;

            PerfDbgLog3(tagBrushCache, NULL, "GCB: released %x @ %d (%d)\r",
                pbcr->cr, pbcr - pts->pbcr, pbcr->refs);

            return;
        }
    }

    TraceTag((tagWarning, "RCB: Brush not found in cache, deleting anyway."));

    DeleteObject((HGDIOBJ)hbr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SelectCachedBrush
//
//  Synopsis:   Helper function to optimally select a cached brush into a DC
//
//  Arguments:  hdc         Device context
//              crNew       color of the brush
//              phbrNew     new brush
//              phbrOld     original brush from the hdc (init to NULL)
//              pcrNow      current cached brush color in the hdc (init to COLORREF_NONE)
//
//----------------------------------------------------------------------------

void SelectCachedBrush(XHDC hdc, COLORREF crNew, HBRUSH * phbrNew, HBRUSH * phbrOld, COLORREF * pcrNow)
{
    HBRUSH hbrNew, hbrOld;

    *phbrNew = *phbrOld;
    
    if (*pcrNow != crNew)
    {
        *phbrNew = hbrNew = GetCachedBrush(crNew);

        if (hbrNew)
        {
            hbrOld = (HBRUSH)SelectObject(hdc, hbrNew);

            if (hbrOld)
            {
                if (*phbrOld == NULL)
                    *phbrOld = hbrOld;
                else
                    ReleaseCachedBrush(hbrOld);

                *pcrNow = crNew;
            }
            else
            {
                ReleaseCachedBrush(hbrNew);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PatBltBrush
//
//  Synopsis:   Helper function for calling PatBlt with a given COLORREF
//
//  Arguments:  hdc         Device context
//              x,y         Point where painting starts
//              xWid,yHei   Size of paint rectangle
//              dwRop       Raster op
//              cr          COLORREF of color to use
//
//----------------------------------------------------------------------------

void PatBltBrush(XHDC hdc, LONG x, LONG y, LONG xWid, LONG yHei,
    DWORD dwRop, COLORREF cr)
{
    HBRUSH hbr = GetCachedBrush(cr);
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
    PatBlt(hdc, x, y, xWid, yHei, dwRop);
    SelectObject(hdc, hbrOld);
    ReleaseCachedBrush(hbr);
}

void PatBltBrush(XHDC hdc, RECT * prc, DWORD dwRop, COLORREF cr)
{
    PatBltBrush(hdc, prc->left, prc->top, prc->right - prc->left,
        prc->bottom - prc->top, dwRop, cr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\buffer.cxx ===
//      Buffer.cpp
//              Copyright 1996 Microsoft Corporation.  All rights reserved.
//
//              This file implements a class that provides a dynamically growing buffer.
//
//      1/5/96 created - Chris Wilson (cwilso@microsoft.com)
//      1/8/97 revised for Trident & converted to Unicode - cwilso

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BUFFER_HXX_
#define X_BUFFER_HXX_
#include "buffer.hxx"
#endif

MtDefine(CBuffer, Utilities, "CBuffer")
MtDefine(CBuffer2, Utilities, "CBuffer2")

#define INIT_BUFFER_COUNT     256   // # of characters for which space is initially alloc'd

//---------------------------------------------------------------------
//      CBuffer::CBuffer()
//              This function initializes the internal buffer to a default length
//  of 1024 characters.
//---------------------------------------------------------------------
CBuffer::CBuffer() :
    m_pszStringBuf(NULL), m_pszCurrChar(NULL), m_lBufSize(INIT_BUFFER_COUNT),
    m_lStringLen(0)
{
        // Allocate buffer space.
        m_pszStringBuf = m_pszCurrChar = (LPTSTR) MemAlloc(Mt(CBuffer),
            sizeof(TCHAR) * m_lBufSize);
        if ( m_pszStringBuf )
            *m_pszStringBuf = _T('\0');
}

//---------------------------------------------------------------------
//      CBuffer::~CBuffer()
//              The destructor for the CBuffer object frees the string buffer
//      (if initialized) and resets all internal member variables, just to
//      be safe.
//---------------------------------------------------------------------
CBuffer::~CBuffer()
{
        if ( m_pszStringBuf )
        {
                MemFree(m_pszStringBuf);
                m_pszStringBuf = m_pszCurrChar = NULL;
                m_lBufSize = m_lStringLen = 0;
        }
}


//---------------------------------------------------------------------
//      CBuffer::GrowBuffer()
//              This method grows the buffer by the specified amount +
//      INIT_BUFFER_COUNT.
//
//---------------------------------------------------------------------
BOOL CBuffer::GrowBuffer( const int iSize /*=1*/ )
{
        long lNewBufSize = m_lBufSize + iSize + INIT_BUFFER_COUNT;
        HRESULT hr = MemRealloc(Mt(CBuffer), (void **)&m_pszStringBuf, lNewBufSize * sizeof(TCHAR));
        if (hr)
            return FALSE;   // ERROR reallocating!  Maybe return hr?

        m_lBufSize = lNewBufSize;
        m_pszCurrChar = m_pszStringBuf + m_lStringLen;
        return TRUE;
}

//---------------------------------------------------------------------
//      CBuffer::TrimTrailingWhitespace()
//              This function trims any whitespace at the end of the string in 
//      the internal buffer, properly keeping track of the string length.
//---------------------------------------------------------------------
void CBuffer::TrimTrailingWhitespace( void )
{
        while ( --m_pszCurrChar > m_pszStringBuf )
        {
                m_lStringLen--;
                if ( !isspace( *m_pszCurrChar ) )
                {
                        m_pszCurrChar++;
                        m_lStringLen++;
                        return;
                }
                *m_pszCurrChar = _T('\0');
        }
}

//---------------------------------------------------------------------
//      CBuffer::SwapContents()
//              This method swaps the contents of two CBuffers.
//---------------------------------------------------------------------
void CBuffer::SwapContents( CBuffer & cBufOther )
{
    LPTSTR pszTemp;
    long lTemp;

    pszTemp = m_pszStringBuf;
    m_pszStringBuf = cBufOther.m_pszStringBuf;
    cBufOther.m_pszStringBuf = pszTemp;

    pszTemp = m_pszCurrChar;
    m_pszCurrChar = cBufOther.m_pszCurrChar;
    cBufOther.m_pszCurrChar = pszTemp;

    lTemp = m_lStringLen;
    m_lStringLen = cBufOther.m_lStringLen;
    cBufOther.m_lStringLen = lTemp;

    lTemp = m_lBufSize;
    m_lBufSize = cBufOther.m_lBufSize;
    cBufOther.m_lBufSize = lTemp;
}


//+------------------------------------------------------------------------
//
//  Class:      CBuffer2
//
//  Synopsis:   A sequence of exponentially growing buffers, used for
//              reducing MemAllocs (logarithmic) and eliminating
//              MemReallocs (complete) when accumulating long strings.
// 
//              A new CBuffer2 contains room for the first 1024 chars
//              without an extra allocation.
//
//-------------------------------------------------------------------------
CBuffer2::CBuffer2()
{
    _pchCur = NULL;
    _cchRemaining = 0;
    _cBuf = 0;
}

void
CBuffer2::Clear()
{
    int c;
    TCHAR **ppch;

    for (c = _cBuf, ppch = _apchBuf; c; c -= 1, ppch += 1)
        MemFree(*ppch);
        
    _pchCur = NULL;
    _cchRemaining = 0;
    _cBuf = 0;
}
       
CBuffer2::~CBuffer2()
{
    int c;
    TCHAR **ppch;

    for (c = _cBuf, ppch = _apchBuf; c; c -= 1, ppch += 1)
        MemFree(*ppch);
}


//+------------------------------------------------------------------------
//
//  Method:     Length
//
//  Synopsis:   return init * (2^buffers - 1) - slop
// 
//-------------------------------------------------------------------------
int
CBuffer2::Length()
{
    return (INIT_BUFFER2_SIZE * ((1 << _cBuf) - 1)) - _cchRemaining;
}

//+------------------------------------------------------------------------
//
//  Method:     SetCStr
//
//  Synopsis:   Do a single alloc on the cstr, then copy contents in
//              one buffer at a time.
// 
//-------------------------------------------------------------------------
HRESULT
CBuffer2::SetCStr(CStr *pcstr)
{
    HRESULT hr;
    int cch;
    int cBufFull;
    int cchCur;
    TCHAR **ppchCur;
    TCHAR *pchTo;

    cch = Length();
    
    hr = THR(pcstr->Set(NULL, Length()));
    if (hr)
        RRETURN(hr);

    if (!cch)
        return S_OK;

    Assert(_cBuf);
    
    pchTo = *pcstr;
    cBufFull = _cBuf - 1;
    cchCur = INIT_BUFFER2_SIZE;
    ppchCur = _apchBuf;

    while (cBufFull)
    {
        memcpy(pchTo, *ppchCur, sizeof(TCHAR) * cchCur);
        
        pchTo += cchCur;
        cchCur *= 2;
        ppchCur += 1;
        cBufFull -= 1;
    }

    cchCur -= _cchRemaining;
    
    memcpy(pchTo, *ppchCur, sizeof(TCHAR) * cchCur);
    
#if DBG == 1
    pchTo += cchCur;

    Assert(pchTo - *pcstr == Length());
#endif    

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Method:     Append
//
//  Synopsis:   Append new stuff to the sequence of buffers, allocating
//              exponentially larger new buffers as needed.
// 
//-------------------------------------------------------------------------
HRESULT
CBuffer2::Append(TCHAR *pch, int cch)
{
    int cchToCopy;
    
    while (cch)
    {
        if (!_cchRemaining)
        {
            int cchAlloc;
            
            // Note: because of exponential growth, we'll really run out of
            // memory long before we hit this condition.
            
            if (_cBuf >= MAX_BUFFER2_GROWTH)
                return E_OUTOFMEMORY;

            cchAlloc = INIT_BUFFER2_SIZE * (1 << _cBuf);
            
            _pchCur = (TCHAR *)MemAlloc(Mt(CBuffer2), sizeof(TCHAR) * cchAlloc);
            if (!_pchCur)
                return E_OUTOFMEMORY;

            _cBuf += 1;
            _apchBuf[_cBuf - 1] = _pchCur;
            _cchRemaining = cchAlloc;
        }

        Assert(_cchRemaining && _pchCur);

        cchToCopy = min(_cchRemaining, cch);

        memcpy(_pchCur, pch, sizeof(TCHAR) * cchToCopy);

        cch -= cchToCopy;
        pch += cchToCopy;
        _cchRemaining -= cchToCopy;
        _pchCur += cchToCopy;
    }

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Method:     Chop
//
//  Synopsis:   Removes the last cch chars from the buffer
// 
//-------------------------------------------------------------------------
void
CBuffer2::Chop(int cch)
{
    int cchBuffer;

    Assert(cch <= Length());

    if (!cch)
        return;

    Assert(_cBuf);
    
    cchBuffer = INIT_BUFFER2_SIZE * (1 << (_cBuf - 1));

    while (cch >= cchBuffer - _cchRemaining)
    {
        Assert(_cBuf > 0);
        
        cch -= cchBuffer - _cchRemaining;
        
        MemFree(_apchBuf[_cBuf - 1]);
        _cBuf -= 1;
        _cchRemaining = 0;
        cchBuffer /= 2;
    }

    _cchRemaining += cch;
    _pchCur = _cBuf ? _apchBuf[_cBuf - 1] + cchBuffer - _cchRemaining : NULL;

    Assert(_cBuf || _cchRemaining == 0);
}

//+------------------------------------------------------------------------
//
//  Method:     Chop
//
//  Synopsis:   Removes the last cch chars from the buffer
// 
//-------------------------------------------------------------------------
void
CBuffer2::TransferTo(CBuffer2 *pbuf)
{
    // copy over pointers
    if (pbuf != this)
    {
        memcpy(pbuf, this, sizeof(CBuffer2));
        memset(this, 0, sizeof(CBuffer2));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\atomtbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       atomtbl.cxx
//
//  History:    20-Sep-1996     AnandRa     Created
//
//  Contents:   CAtomTable implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_HASHATOMTBL_HXX_
#define X_HASHATOMTBL_HXX_
#include "hashatomtbl.hxx"
#endif

MtDefine(CAtomTable, Utilities, "CAtomTable")
MtDefine(CAtomTable_pv, CAtomTable, "CAtomTable::_pv")

HRESULT
CAtomTable::AddNameToAtomTable(LPCTSTR pch, long *plIndex)
{
    HRESULT hr = S_OK;

    // If we are in hash mode, use that
    if (_phat)
    {
        hr = _phat->AddNameToAtomTable(pch, plIndex);
    }
    else
    {
        long    lIndex;
        CStr *  pstr;
    
        for (lIndex = 0; lIndex < Size(); lIndex++)
        {
            pstr = (CStr *)Deref(sizeof(CStr), lIndex);
            if (_tcsequal(pch, *pstr))
                break;
        }
        if (lIndex == Size())
        {
            CStr cstr;

            if (lIndex >= ATOMTABLE_HASH_THRESHOLD)
            {
                hr = ConvertToHash();
                if (hr)
                    goto Cleanup;

                hr = _phat->AddNameToAtomTable(pch, plIndex);

                goto Cleanup;
            }
        
            //
            // Not found, so add element to array.
            //

            hr = THR(cstr.Set(pch));
            if (hr)
                goto Cleanup;
       
            hr = THR(AppendIndirect(&cstr));
            if (hr)
                goto Cleanup;

            // The array now owns the memory for the cstr, so take it away from
            // the cstr on the stack.

            cstr.TakePch();
        }

        if (plIndex)
        {
            *plIndex = lIndex;
        }
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CAtomTable::GetAtomFromName(LPCTSTR pch, long *plIndex, long *plId, BOOL fCaseSensitive /*= TRUE */,
                                    BOOL fStartFromGivenIndex /* = FALSE */)
{
    HRESULT hr = S_OK;

    if (!pch)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (_phat)
    {
        hr = _phat->GetAtomFromName(pch, plIndex, plId, fCaseSensitive, fStartFromGivenIndex);
    }
    else
    {
        long    lIndex;
        CStr *  pstr;

	if(fStartFromGivenIndex)
	{
            if (plIndex && *plIndex>=0)
            {
                  lIndex = *plIndex;
            }
            else
            {
                  hr = E_FAIL;
                  goto Cleanup;
            }
	}
        else
            lIndex = 0;
    
        for (; lIndex < Size(); lIndex++)
        {
            pstr = (CStr *)Deref(sizeof(CStr), lIndex);
            if(fCaseSensitive)
            {
                if (_tcsequal(pch, *pstr))
                    break;
            }
            else
            {
                if(_tcsicmp(pch, *pstr) == 0)
                    break;
            }
        }
    
        if (lIndex == Size())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        if (plIndex)
        {
            *plIndex = lIndex;
        }

        if (plId)
        {
            *plId = lIndex;
        }
    }

Cleanup:    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


HRESULT 
CAtomTable::GetNameFromAtom(long lIndex, LPCTSTR *ppch)
{
    HRESULT hr = S_OK;

    if (_phat)
    {
        hr = _phat->GetNameFromAtom( lIndex, ppch );
    }
    else
    {
        CStr *  pcstr;
    
        if (Size() <= lIndex)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        Assert(lIndex>=0 && lIndex < Size());
        pcstr = (CStr *)Deref(sizeof(CStr), lIndex);
        *ppch = (TCHAR *)*pcstr;
    }
    
Cleanup:    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

long    
CAtomTable::TableSize()
{
    if (_phat)
        return _phat->TableSize();
    
    return Size();
}

LPTSTR  
CAtomTable::TableItem(long lId)
{
    Assert(lId>=0 && lId < Size());
    if (_phat)
        return _phat->TableItem(lId);
    return Item(lId);
}

void
CAtomTable::Free()
{
    if (_phat)
    {
        _phat->Free();
        delete _phat;
        _phat = NULL;

        Assert( Size() == 0 );
    }
    else
    {
        FreeArray();
    }
}

HRESULT 
CAtomTable::ConvertToHash()
{
    HRESULT hr = S_OK;
    CStr *  pcstr;
    long    i;

    _phat = new CHashAtomTable();
    if (!_phat)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // NOTE: we should probably find a way to do this conversion
    // without reallocating the strings
    for (i=0; i < Size(); i++)
    {
        pcstr = (CStr *)Deref(sizeof(CStr), i);
        hr = _phat->AddNameWithID( *pcstr, i );
        if (hr)
            goto Cleanup;
    }

    FreeArray();

Cleanup:
    if (hr && _phat)
    {
        _phat->Free();
        delete _phat;
        _phat = NULL;
    }

    RRETURN(hr);
}

void
CAtomTable::FreeArray()
{
    CStr *  pcstr;
    long    i;
    
    for (i = 0; i < Size(); i++)
    {
        pcstr = (CStr *)Deref(sizeof(CStr), i);
        pcstr->Free();
    }
    DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\brushbmp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       brushbmp.cxx
//
//  Contents:   Bitmap brush utilities.
//
//  History:    6-Nov-95   RodC     Created
//
//-------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


struct BBCR
{
    int         resId;
    HBRUSH      hbr;
};

MtDefine(CAryBBCR, THREADSTATE, "CAryBBCR")
MtDefine(CAryBBCR_pv, THREADSTATE, "CAryBBCR::_pv")

// We have to do this because of the forward declare in thread state.
DECLARE_CDataAry(CAryBBCR, BBCR, Mt(CAryBBCR), Mt(CAryBBCR_pv))

//+----------------------------------------------------------------------------
//
//  Function:   InitBmpBrushCache
//
//  Synopsis:   Allocate bitmap brushes cache array
//
//  Arguments:  pts - THREADSTATE of current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitBmpBrushCache(
    THREADSTATE *   pts)
{
    Assert(pts);

    pts->paryBBCR = new CAryBBCR;
    if (!pts->paryBBCR)
        RRETURN(E_OUTOFMEMORY);

    MemSetName((pts->paryBBCR, "BmpBrushCache ary"));

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   DeinitBmpBrushCache
//
//  Synopsis:   Releases any bitmap brushes still stored in the cache.
//
//----------------------------------------------------------------------------
void
DeinitBmpBrushCache(
    THREADSTATE *   pts)
{
    Assert(pts);

    if (!pts->paryBBCR)
        return;

    int     c = (*pts->paryBBCR).Size();

    // Loop over all the brushes in the cache and delete them.
    while (c--)
    {
        Assert((*pts->paryBBCR)[c].hbr);
        DeleteObject((*pts->paryBBCR)[c].hbr);
    }

    (*pts->paryBBCR).DeleteAll();

    delete pts->paryBBCR;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCachedBmpBrush
//
//  Synopsis:   Returns a brush handle for the bitmap matching the resource
//              id. A process-wide cache of brushes is maintained.  If this
//              function is called and a matching brush is found in the
//              cache, it is returned.  If no match is found, a new one is
//              added.
//
//              No release is needed.  There are few enough bitmap brushes
//              that they will all be around until the detach.
//
//----------------------------------------------------------------------------

HBRUSH
GetCachedBmpBrush(int resId)
{
    THREADSTATE *   pts;
    HBITMAP         hbmp = NULL;
    HBRUSH          hbr = NULL;
    BBCR *          pbbcr;
    int             c;

    pts = GetThreadState();

    //
    // Look for previously cached bitmap brush.
    //
    for (c = (*pts->paryBBCR).Size(), pbbcr = (*pts->paryBBCR); c > 0; c--, pbbcr++)
    {
        Assert(pbbcr->hbr && pbbcr->resId);

        // Return brush if found.
        if (pbbcr->resId == resId)
        {
            hbr = pbbcr->hbr;
            goto Cleanup;
        }
    }

    //
    // If we didn't find the brush, we need to cook one up.
    //

    // Make sure we will have room for the brush.
    if ((*pts->paryBBCR).EnsureSize((*pts->paryBBCR).Size() + 1))
        goto Cleanup;

    // Load the bitmap resouce.
    hbmp = LoadBitmap(g_hInstCore, MAKEINTRESOURCE(resId)); // NOTE (lmollico): bitmaps are in mshtml.dll
    if (!hbmp)
        goto Cleanup;

    // Turn the bitmap into a brush.
    hbr = CreatePatternBrush(hbmp);
    if (!hbr)
        goto Cleanup;

    // Store the brush.
    (*pts->paryBBCR)[(*pts->paryBBCR).Size()].resId = resId;
    (*pts->paryBBCR)[(*pts->paryBBCR).Size()].hbr = hbr;
    (*pts->paryBBCR).SetSize((*pts->paryBBCR).Size() + 1);

Cleanup:
    if (hbmp)
        DeleteObject(hbmp);

    return hbr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\buttutil.cxx ===
//+------------------------------------------------------------------------
//
//  File:       dbbase.cxx
//
//  Contents:   Button Drawing routines common to scrollbar and dropbutton.
//
//  History:    15-Aug-95   t-vuil  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BUTTUTIL_HXX_
#define X_BUTTUTIL_HXX_
#include "buttutil.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifdef UNIX
#ifndef X_UNIXCTLS_HXX_
#define X_UNIXCTLS_HXX_
#include "unixctls.hxx"
#endif
#endif
//+------------------------------------------------------------------------
//
//  Function:   DrawRect
//
//  Synopsis:   Draws a rectangle in the current BG color
//
//  Notes:      Uses ExtTextOut because it has generally been highly
//              optimized for text rendering
//
//-------------------------------------------------------------------------

void
DrawRect (
    XHDC hdc, HBRUSH hbr, int x1, int y1, int x2, int y2,
    BOOL fReleaseBrush = TRUE )
{
    if (x2 > x1 && y2 > y1)
    {
        HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
        PatBlt( hdc, x1, y1, x2 - x1, y2 - y1, PATCOPY );
        SelectObject(hdc, hbrOld);
    }

    if (fReleaseBrush)
        ReleaseCachedBrush( hbr );
}

void
CUtilityButton::Invalidate(HWND hWnd, const RECT &rc, DWORD dwFlags)
{
    if (hWnd)
    {
        RedrawWindow(hWnd, &rc, NULL, RDW_INVALIDATE);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     DrawNull
//
//  Synopsis:   Draws nothing
//
//-------------------------------------------------------------------------

void
CUtilityButton::DrawNull (
    XHDC hdc, HBRUSH, BUTTON_GLYPH glyph,
    const RECT & rcBounds, const SIZEL & sizel )
{
}

//+------------------------------------------------------------------------
//
//  Member:     DrawDotDotDot
//
//  Synopsis:   Draws the Ellipses Glyph (dotdotdot) (used in dropbutton)
//
//-------------------------------------------------------------------------

void
CUtilityButton::DrawDotDotDot (
    XHDC hdc, HBRUSH hbr, BUTTON_GLYPH glyph,
    const RECT & rcBounds, const SIZEL & sizel )
{
    long xStart, yStart, width, height;
    
    Assert( rcBounds.right  > rcBounds.left );
    Assert( rcBounds.bottom > rcBounds.top );

        //
        // 106 is about 3 points, which is how far from the bottom
        // the dots starts.
        //
        // 53 is about 1.5 points, which the height/width of the dots
        //

    yStart = rcBounds.bottom -
        MulDiv( rcBounds.bottom - rcBounds.top, 106, sizel.cy );
    
    height = MulDiv( rcBounds.bottom - rcBounds.top, 53, sizel.cy );
    width  = MulDiv( rcBounds.right - rcBounds.left, 54, sizel.cx );

    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 2 / 13;
    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
    
    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 5 / 13;
    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
    
    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 8 / 13;
    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     DrawReduce
//
//  Synopsis:   Draws the under bar
//
//-------------------------------------------------------------------------

void
CUtilityButton::DrawReduce (
    XHDC hdc, HBRUSH hbr, BUTTON_GLYPH glyph,
    const RECT & rcBounds, const SIZEL & sizel )
{
    long xStart, yStart, width, height;
    
    Assert( rcBounds.right  > rcBounds.left );
    Assert( rcBounds.bottom > rcBounds.top );

        //
        // 106 is about 3 points, which is how far from the bottom
        // the bar starts.
        //
        // 53 is about 1.5 points, which the height of the bar
        //

    yStart = rcBounds.bottom -
        MulDiv( rcBounds.bottom - rcBounds.top, 108, sizel.cy );
    
    height = MulDiv( rcBounds.bottom - rcBounds.top, 54, sizel.cy );
    
    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 3 / 13;
    width  = (rcBounds.right - rcBounds.left) * 6 / 13;

    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
}

//+------------------------------------------------------------------------
//
//  Function:   DrawArrow
//
//  Synopsis:   Draws a scrollbar type arrow
//
//-------------------------------------------------------------------------

// NOTE: Use PolyLine when the arrow gets big.  This speeds up drawing,
//         and lets printing dither

void
CUtilityButton::DrawArrow (
    XHDC hdc, HBRUSH hbr, BUTTON_GLYPH dir,
    const RECT & rcBounds, const SIZEL & sizel )
{
    long i;

    Assert( rcBounds.right  > rcBounds.left );
    Assert( rcBounds.bottom > rcBounds.top );
    
    Assert(
        dir == BG_UP || dir == BG_DOWN || dir == BG_LEFT || dir == BG_RIGHT );

    if (dir == BG_UP || dir == BG_DOWN)
    {
            //
            // Determine the height of the arrow by computing the largest
            // arrows we allow for the given width and height, and then taking
            // the smaller of the two.  Also make sure it is non zero.
            //

        long arrow_height =
            max(
                (long)1,
                (long)min(
                    (rcBounds.bottom - rcBounds.top + 2) / 3,
                    ((rcBounds.right - rcBounds.left) * 5 / 8 + 1) / 2 ) );
        
            //
            // Locate where the top of the arrow starts and where it is
            // centered horizontally
            //
        
        long sy =
            rcBounds.top +
                (rcBounds.bottom - rcBounds.top + 1 - arrow_height) / 2;

        long cx =
            rcBounds.left + (rcBounds.right - rcBounds.left - 1) / 2;

            //
            // Draw the arrow from top to bottom in successive strips
            //
        
        for ( i = 0 ; i < arrow_height ; i++ )
        {
            long y = dir == BG_UP ? sy + i : sy + arrow_height - i - 1;

            DrawRect( hdc, hbr, cx - i, y, cx - i + 1 + i * 2, y + 1, FALSE );
        }
    }
    else    
    {
            //
            // Determine the width of the arrow by computing the largest
            // arrows we allow for the given width and height, and then taking
            // the smaller of the two.  Also make sure it iz non zero.
            //
        
        long arrow_width =
            max(
                (long)1,
                (long)min(
                    (rcBounds.right - rcBounds.left + 2) / 3,
                    ((rcBounds.bottom - rcBounds.top) * 5 / 8 + 1) / 2 ) );
        
            //
            // Locate where the left of the arrow starts and where it is
            // centered vertically
            //
        
        long sx =
            rcBounds.left +
                (rcBounds.right - rcBounds.left + 1 - arrow_width) / 2;
        
        long cy =
            rcBounds.top + (rcBounds.bottom - rcBounds.top) / 2;

            //
            // Draw the arrow from top to bottom in successive strips
            //

        for ( long i = 0 ; i < arrow_width ; i++ )
        {
            long x = dir == BG_LEFT ? sx + i : sx + arrow_width - i - 1;
            
            DrawRect( hdc, hbr, x, cy - i, x + 1, cy + i + 1, FALSE );
        }
    }
}

//+------------------------------------------------------------------------
//
//  Function:   DrawButton
//
//  Synopsis:   Draws a scrollbar type pushbutton
//
//-------------------------------------------------------------------------


void
CUtilityButton::DrawButton (
    CDrawInfo * pDI, HWND hWnd, BUTTON_GLYPH glyph,
    BOOL fPressed, BOOL fEnabled, BOOL focused,
    const RECT & rcBounds, const SIZEL & sizelExtent,
    unsigned long padding )
{
    if (hWnd)
    {
        Invalidate(hWnd, rcBounds);
    }
    else
    {
        void (CUtilityButton ::* pmfDraw) (
                                           XHDC, HBRUSH, BUTTON_GLYPH, const RECT &, const SIZEL & );

        ThreeDColors &  colors = GetColors();
        RECT            rcGlyph = rcBounds;
        SIZEL           sizelGlyph = sizelExtent;
        long            dx = 0, dy = 0, xOffset = 0, yOffset = 0;


        // must have at least hdc
        AssertXHDC(pDI->_hdc);
        // should come in initialized
        Assert(pDI->IsInitialized()); 


        //
        // First, draw the border around the glyph and the background.
        //

        if (fPressed && !_fFlat)
        {
            RECT rcFill = rcBounds;

            //
            // Draw a "single line" border then reduce rect by that size and
            // Fill the rest with the button background
            //
#ifdef UNIX // If it's a motif button, see below #ifdef UNIX codes
            if (!_bMotifScrollBarBtn)
            {
#endif
            IGNORE_HR(BRDrawBorder(
                                   pDI, 
                                   LPRECT(& rcBounds),
                                   fmBorderStyleSingle, 
                                   colors.BtnShadow(), 
                                   0, 
                                   0));

            IGNORE_HR(BRAdjustRectForBorder(
                                            pDI, 
                                            & rcFill, 
                                            fmBorderStyleSingle));

            DrawRect(
                     pDI->_hdc, colors.BrushBtnFace(),
                     rcFill.left, rcFill.top, rcFill.right, rcFill.bottom );

#ifdef UNIX // Draw motif button background
            }
            else
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = FALSE;
                switch (glyph)
                {
                    case BG_LEFT:
                        rcFill.right+=1; 
                        break;
                    case BG_RIGHT:
                        rcFill.left-=1;
                        break;
                    case BG_UP:
                        rcFill.bottom+=1;
                        break;
                    case BG_DOWN:
                        rcFill.top-=1;
                        break;
                }
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_LEFT || glyph==BG_UP) ?
                                    LeftTopThumbRect : RightBottomThumbRect,
                                    &rcFill,
                                    FALSE,
                                    &info);
                switch (glyph)
                {
                    case BG_LEFT:
                        rcFill.right-=1; 
                        break;
                    case BG_RIGHT:
                        rcFill.left+=1;
                        break;
                    case BG_UP:
                        rcFill.bottom-=1;
                        break;
                    case BG_DOWN:
                        rcFill.top+=1;
                        break;
                }
            }
#endif
            //
            // Now, compute the reduced rect as if a sunken border were drawn.
            // This leaves the glyph rect in rcGlyph
            //

#ifdef UNIX
            if (!_bMotifScrollBarBtn)
#endif
            IGNORE_HR(BRAdjustRectForBorder(
                                            pDI,
                                            & rcGlyph,
                                            fmBorderStyleRaised));
        }
        else
        {
#ifdef UNIX
            if (!_bMotifScrollBarBtn)
            {
#endif
            //
            // Draw the sunken border and fill the rest with the button bg.
            // This leaves the arrow rect in rcGlyph

            // If we come here with fPressed = TRUE, this must be a flat scrollbar

            IGNORE_HR( BRDrawBorder(
                                    pDI, LPRECT(& rcBounds), 
                                    (fPressed) ? fmBorderStyleSunken : fmBorderStyleRaised,
                                    0, 
                                    & colors, 
                                    (_fFlat) ? BRFLAGS_MONO : 0 ) );

            IGNORE_HR( BRAdjustRectForBorder(
                                             pDI, 
                                             & rcGlyph, 
                                             (_fFlat) ? fmBorderStyleSingle : fmBorderStyleRaised));

            DrawRect(
                     pDI->_hdc, colors.BrushBtnFace(),
                     rcGlyph.left, rcGlyph.top, rcGlyph.right, rcGlyph.bottom );
#ifdef UNIX
            }
            else
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = FALSE;
                switch (glyph)
                {
                    case BG_LEFT:
                        rcGlyph.right+=1; 
                        break;
                    case BG_RIGHT:
                        rcGlyph.left-=1;
                        break;
                    case BG_UP:
                        rcGlyph.bottom+=1;
                        break;
                    case BG_DOWN:
                        rcGlyph.top-=1;
                        break;
                }
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_LEFT || glyph==BG_UP) ?
                                    LeftTopThumbRect : RightBottomThumbRect,
                                    &rcGlyph,
                                    FALSE,
                                    &info);
                switch (glyph)
                {
                    case BG_LEFT:
                        rcGlyph.right-=1; 
                        break;
                    case BG_RIGHT:
                        rcGlyph.left+=1;
                        break;
                    case BG_UP:
                        rcGlyph.bottom-=1;
                        break;
                    case BG_DOWN:
                        rcGlyph.top+=1;
                        break;
                }
            }
#endif
        }

        //
        // See if we have a null rect.
        //

        if (rcGlyph.right <= rcGlyph.left || rcGlyph.bottom <= rcGlyph.top)
            goto Cleanup;

        //
        // Adjust the extent to reflect the border
        //

        BRAdjustSizelForBorder(
                               & sizelGlyph, fmBorderStyleSunken );

        //
        // A combo glyph looks like a down arrow
        //

        if (glyph == BG_COMBO)
            glyph = BG_DOWN;

        //
        // Select the draw member.  Default to arrow.
        //

        pmfDraw = & CUtilityButton::DrawArrow;

        switch ( glyph )
        {
            case BG_PLAIN :
                pmfDraw = & CUtilityButton::DrawNull;
                break;

                //
                // Adjust the rect for padding.
                //
                // TODO: the padding has not been zoomed....
                //

            case BG_DOWN  : rcGlyph.bottom -= padding; break;
            case BG_UP    : rcGlyph.top    += padding; break;
            case BG_LEFT  : rcGlyph.left   += padding; break;
            case BG_RIGHT : rcGlyph.right  -= padding; break;

            case BG_REFEDIT:
                pmfDraw = & CUtilityButton::DrawDotDotDot;
                break;

            case BG_REDUCE:
                pmfDraw = & CUtilityButton::DrawReduce;
                break;

            default:
                Assert( 0 && "Unknown glyph" );
                goto Cleanup;
        }

        // In the rest of the code, if the scrollbar is flat, ignore
        // fPressed (no offset even if the button is pressed)
        if (_fFlat)
            fPressed = FALSE;

        //
        // Now that the glyph draw member has been selected, use it to draw.
        //
        //
        // If we are pressed or disabled, we need to compute the offset
        // for pressing or the highlight offset version of the glyph.
        //
        // Also, if we have to draw a focus, we need to know how much to 
        // offset the focus rect from the border.
        //

        if (!fEnabled || fPressed || focused)
        {

            //
            // The offset is 27 HIMETRICS (~ 3/4 points).
            //


            xOffset = MulDiv( rcGlyph.right - rcGlyph.left, 27, sizelGlyph.cx );
            yOffset = MulDiv( rcGlyph.bottom - rcGlyph.top, 27, sizelGlyph.cy );

            if (!fEnabled || fPressed)
            {
                dx = xOffset;
                dy = yOffset;
            }
        }

        if (fEnabled)
        {
            RECT rc = rcGlyph;
            HBRUSH hbr = colors.BrushBtnText();

            if (fPressed)
            {
                rc.left   += dx;
                rc.right  += dx;
                rc.top    += dy;
                rc.bottom += dy;
            }

#ifdef UNIX
            if (_bMotifScrollBarBtn)
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = FALSE;
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_RIGHT || glyph==BG_DOWN) ?
                                    RightBottomButton : LeftTopButton,
                                    &rc,
                                    fPressed,
                                    &info);
            }
            else 
#endif                           
            CALL_METHOD(this,pmfDraw,( pDI->_hdc, hbr, glyph, rc, sizelGlyph ));

            ReleaseCachedBrush( hbr );
        }
        else
        {
            HBRUSH hbr;

            //
            // Here we draw the disabled glyph.  First, draw the lighter
            // back ground version, the the darker foreground version.
            //

            RECT rcBack = {
                rcGlyph.left + dx, rcGlyph.top + dy,
                rcGlyph.right + dx, rcGlyph.bottom + dy };

#ifdef UNIX
            if (_bMotifScrollBarBtn)
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = TRUE;
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_DOWN || glyph==BG_RIGHT) ?
                                    RightBottomButton : LeftTopButton,
                                    &rcGlyph,
                                    FALSE, //fPressed,
                                    &info);
            }
            else 
            {
#endif                           
                hbr = colors.BrushBtnHighLight();
                CALL_METHOD(this,pmfDraw,( pDI->_hdc, hbr, glyph, rcBack, sizelGlyph ));
                ReleaseCachedBrush( hbr );

                hbr = colors.BrushBtnShadow();
                CALL_METHOD(this,pmfDraw,( pDI->_hdc, hbr, glyph, rcGlyph, sizelGlyph ));
                ReleaseCachedBrush( hbr );
#ifdef UNIX
            }
#endif
        }

        //
        // Draw any focus rect
        //

        // TODO: This relies heavily on the assumption that the arrow which is
        //         drawn leaves alot of space around the edge so that the focus
        //         can be drawn there.  Also, the focus rect is not zoomed here.

        if (focused)
        {
            GDIRECT rcFocus = rcGlyph;

            rcFocus.left   += xOffset + dx;
            rcFocus.right  -= xOffset - dx;
            rcFocus.top    += yOffset + dy;
            rcFocus.bottom -= yOffset - dy;

            rcFocus.right  = max( rcFocus.right, rcFocus.right );
            rcFocus.bottom = max( rcFocus.bottom, rcFocus.top );

            if (rcFocus.right <= rcGlyph.right && rcFocus.bottom <= rcGlyph.bottom)
            {
                ::DrawFocusRect( pDI->_hdc, & rcFocus );
            }
        }
    }
Cleanup:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\cbufstr.cxx ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1997, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CBUFSTR.CXX
//
// Contents     Class implementation for a buffered, appendable string class
//
// Classes      CBufferedStr
//
//
//  History:
//              7-10-97     t-chrisr     created
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#define BUFFEREDSTR_SIZE 1024

MtDefine(CBufferedStr, Utilities, "CBufferedStr")
MtDefine(CBufferedStr_pchBuf, CBufferedStr, "CBufferedStr::_pchBuf")

//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::Set
//
//  Synopsis:   Initilizes a CBufferedStr
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::Set (const TCHAR* pch)
{
    HRESULT hr = S_OK;

    Free();

    _cchIndex = pch ? _tcslen (pch) : 0;
    _cchBufSize = _cchIndex > BUFFEREDSTR_SIZE ? _cchIndex : BUFFEREDSTR_SIZE;
    _pchBuf = new(Mt(CBufferedStr_pchBuf)) TCHAR [ _cchBufSize ];
    if (!_pchBuf)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pch)
    {
        _tcsncpy (_pchBuf, pch, _cchIndex);
    }

    _pchBuf[_cchIndex] = '\0';

    MemSetName((_pchBuf, "CBufferedStr text"));

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::QuickAppend
//
//  Parameters: pchNewStr   string to be added to _pchBuf
//
//  Synopsis:   Appends pNewStr into _pchBuf starting at
//              _pchBuf[uIndex].  Increments index to reference
//              new end of string.  If _pchBuf is not large enough,
//              reallocs _pchBuf and updates _cchBufSize.
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::QuickAppend (const TCHAR* pchNewStr, ULONG newLen)
{
    Assert (pchNewStr);
    HRESULT hr = S_OK;

    if (!_pchBuf)
    {
        hr = Set();
        if (hr)
            goto Cleanup;
    }

    if (_cchIndex + newLen >= _cchBufSize)    // we can't fit the new string in the current buffer
    {                                         // so allocate a new buffer, and copy the old string
        _cchBufSize += (newLen > BUFFEREDSTR_SIZE) ? newLen : BUFFEREDSTR_SIZE;
        TCHAR * pchTemp = new(Mt(CBufferedStr_pchBuf)) TCHAR [ _cchBufSize ];
        if (!pchTemp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcsncpy (pchTemp, _pchBuf, _cchIndex);

        Free();
        _pchBuf = pchTemp;
    }

    // append the new string
    _tcsncpy (_pchBuf + _cchIndex, pchNewStr, newLen);
    _cchIndex += newLen;
    _pchBuf[_cchIndex] = '\0';

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\cstr.cxx ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CSTR.CXX
//
// Contents     Class implementation for length prefix string class
//
// Classes      CStr
//
// Maintained by Istvanc
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CStr, Mem, "CStr")
MtDefine(CStr_pch, CStr, "CStr::_pch")
MtDefine(CStrGetAltStr, Utilities, "CStr::GetAltStr *ppch")

#ifdef _MAC
#   define MACONLYSIZEOFPTR     sizeof(BSTR *)
#   define INITMACONLYPTR(p)    *(BSTR *)p = 0

#else
#   define MACONLYSIZEOFPTR     0
#   define INITMACONLYPTR(p)
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates memory for a string and initializes it from a given
//              string.
//
//  Arguments:  [pch] -- String to initialize with. Can be NULL
//              [uc]  -- Number of characters to allocate.
//
//  Returns:    HRESULT
//
//  Notes:      The total number of characters allocated is uc+1, to allow
//              for a NULL terminator. If [pch] is NULL, then the string is
//              uninitialized except for the NULL terminator, which is at
//              character position [uc].
//
//  Mac note:   The total number of characters allocated is increased by the
//              size of a pointer.  This pointer, located prior to the length
//              field, will point to a memory allocation that contains the
//              CHAR or WCHAR string alternative to the _pch string.
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch, UINT uc)
{
    if (pch == _pch)
	{
        if (uc == Length())
			return S_OK;
        // when the ptrs are the same the length can only be
        // different if the ptrs are NULL.  this is a hack used
        // internally to implement realloc type expansion
        Assert(pch == NULL && _pch == NULL);
	}

    Free();

    BYTE * p = new(Mt(CStr_pch)) BYTE [sizeof(TCHAR) + sizeof(TCHAR) * uc + sizeof(UINT) + MACONLYSIZEOFPTR];
    if (p)
    {
        MemSetName((p, "CStr text"));

        INITMACONLYPTR(p);
        *(UINT *)(p + MACONLYSIZEOFPTR)  = uc * sizeof(TCHAR);
        _pch = (TCHAR *)(p + sizeof(UINT) + MACONLYSIZEOFPTR);
        if (pch)
        {
            _tcsncpy(_pch, pch, uc);
        }

        ((TCHAR *)_pch) [uc] = 0;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [pch] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch)
{
    RRETURN(Set(pch, pch ? _tcsclen(pch) : 0));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [cstr] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(const CStr &cstr)
{
    RRETURN(Set(cstr, cstr.Length()));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::TakeOwnership, public
//
//  Synopsis:   Takes the ownership of a string from another CStr class.
//
//  Arguments:  [cstr] -- Class to take string from
//
//  Notes:      This method just transfers a string from one CStr class to
//              another. The class which is the source of the transfer has
//              a NULL value at the end of the operation.
//
//----------------------------------------------------------------------------

void
CStr::TakeOwnership(CStr &cstr)
{
    _Free();
    _pch = cstr._pch;
    cstr._pch = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetBSTR, public
//
//  Synopsis:   Allocates a string and initializes it from a BSTR
//
//  Arguments:  [bstr] -- Initialization string
//
//  Notes:      This method is more efficient than Set(LPCWSTR pch) because
//              of the length-prefix on BSTRs.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetBSTR(const BSTR bstr)
{
    RRETURN(Set(bstr, bstr ? SysStringLen(bstr) : 0));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Length, public
//
//  Synopsis:   Returns the length of the string associated with this class
//
//----------------------------------------------------------------------------

UINT
CStr::Length() const
{
    if (_pch)
        return (((UINT *)_pch) [-1]) / sizeof(TCHAR);
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ReAlloc, public
//
//  Synopsis:   Reallocate the string to a different size buffer.
//              The length of the string is not affected, but it is allocated
//              within a larger (or maybe smaller) memory allocation.
//
//----------------------------------------------------------------------------

HRESULT
CStr::ReAlloc( UINT uc )
{
    HRESULT hr;
    TCHAR * pchOld;
    UINT    ubOld;

    Assert(uc >= Length());  // Disallowed to allocate a too-short buffer.

    if (uc)
    {
        pchOld = _pch;      // Save pointer to old string.
        _pch = 0;           // Prevent Set from Freeing the string.
        ubOld = pchOld ?    // Save old length
                    *(UINT *) (((BYTE *)pchOld) - sizeof(UINT))
                  : 0;

        hr = Set(pchOld, uc);                   // Alloc new; Copy old string.
        if (hr)
        {
            _pch = pchOld;
            RRETURN(hr);
        }
        *(UINT *)(((BYTE *)_pch) - sizeof(UINT)) = ubOld; // Restore length.

        if (pchOld )
        {
            delete [] (((BYTE *)pchOld) - sizeof(UINT) - MACONLYSIZEOFPTR);
        }
    }

    // else if uc == 0, then, since we have already checked that uc >= Length,
    // length must == 0.

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Append
//
//  Synopsis:   Append chars to the end of the string, reallocating & updating
//              its length.
//
//----------------------------------------------------------------------------

HRESULT
CStr::Append(LPCTSTR pch, UINT uc)
{
    HRESULT hr = S_OK;
    UINT ucOld, ucNew;
    BYTE *p;

    if (uc)
    {
        ucOld = Length();
        ucNew = ucOld + uc;
        hr = ReAlloc(ucNew);
        if (hr)
            goto Cleanup;
        _tcsncpy(_pch + ucOld, pch, uc);
        ((TCHAR *)_pch) [ucNew] = 0;
        p = ((BYTE*)_pch - sizeof(UINT));
        *(UINT *)p = ucNew * sizeof(TCHAR);
    }
Cleanup:
    RRETURN(hr);
}


HRESULT
CStr::Append(LPCTSTR pch)
{
    RRETURN(Append(pch, pch ? _tcsclen(pch) : 0));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetLengthNoAlloc, public
//
//  Synopsis:   Sets the internal length of the string. Note.  There is no
//              verification that the length that is set is within the allocated
//              range of the string. If the caller sets the length too large,
//              this blasts a null byte into memory.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetLengthNoAlloc( UINT uc )
{
    if (_pch)
    {
        BYTE * p = ( (BYTE *)_pch - sizeof(UINT));
        *(UINT *)p = uc * sizeof(TCHAR);    // Set the length prefix.
        ((TCHAR *)_pch) [uc] = 0;           // Set null terminator
        return S_OK;
    }
    else 
        return E_POINTER;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::AllocBSTR, public
//
//  Synopsis:   Allocates a BSTR and initializes it with the string that is
//              associated with this class.
//
//  Arguments:  [pBSTR] -- Place to put new BSTR. This pointer should not
//                         be pointing to an existing BSTR.
//
//
//  Mac note:   Mac BSTRs are ANSI so we need to convert before allocating the
//              BSTR.
//----------------------------------------------------------------------------

HRESULT
CStr::AllocBSTR(BSTR *pBSTR) const
{
    if (!_pch)
    {
        *pBSTR = 0;
        return S_OK;
    }

    *pBSTR = SysAllocStringLen(*this, Length());
    RRETURN(*pBSTR ? S_OK: E_OUTOFMEMORY);
}

/*
//+---------------------------------------------------------------------------
//
//  Member:     CStr::ReAllocBSTR, public
//
//  Synopsis:   Allocates a BSTR and initializes it with the string that is
//              associated with this class. Any existing BSTR pointed to by
//              [pBSTR] is freed.
//
//  Arguments:  [pBSTR] -- Place to put new BSTR. Can be pointing to another
//                         BSTR.
//
//----------------------------------------------------------------------------

HRESULT
CStr::ReAllocBSTR(BSTR *pBSTR)
{
    BSTR bstrTemp;

    Assert(pBSTR);

    HRESULT hr = AllocBSTR(&bstrTemp);
    if (!hr)
    {
        SysFreeString(*pBSTR);
        *pBSTR = bstrTemp;
    }
    RRETURN(hr);
}
*/

//+---------------------------------------------------------------------------
//
//  Member:     CStr::TrimTrailingWhitespace, public
//
//  Synopsis:   Removes any trailing whitespace in the string that is
//              associated with this class.
//
//  Arguments:  None.
//
//----------------------------------------------------------------------------

HRESULT CStr::TrimTrailingWhitespace()
{
    if (!_pch)
    	return S_OK;

    UINT ucNewLength = Length();

    for ( ; ucNewLength > 0; ucNewLength-- )
    {
        if ( !_istspace( ((TCHAR *)_pch)[ ucNewLength - 1 ] ) )
            break;
        ((TCHAR *)_pch)[ ucNewLength - 1 ] = (TCHAR) 0;
    }

    BYTE *p = ((BYTE*)_pch - sizeof(UINT));
    *(UINT *)p = ucNewLength * sizeof(TCHAR);
	return S_OK;
}

#ifdef _MAC
//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetAltStr
//
//  Synopsis:   Creates and returns ANSI version of string as a bstr
//
//  Mac note:   We save the pointer in the reserved space prior to the length
//              field.
//
//  Usage note: BEWARE - A second call to GetAltStr destroys the first call's
//                       returned LPSTR, so don't do this:
//                         foo(aStr.GetAltStr(),aStr.GetAltStr());
//----------------------------------------------------------------------------
LPSTR
CStr::GetAltStr()
{
    int     cchBufReq;
    LPSTR    pStr;
    LPSTR   *pach;

    if(NULL==_pch)
        return NULL;
    pach = (LPSTR*)((LPBYTE)_pch - sizeof(UINT) - MACONLYSIZEOFPTR);
    if(*pach)
    {
        delete [] (*pach - sizeof(UINT));
        *pach=0;
    }
    cchBufReq = Length() + sizeof(CHAR);
    // create a new pStr
    pStr = new(Mt(CStrGetAltStr)) CHAR[ cchBufReq + sizeof(UINT)];
    if(NULL != pStr)
    {
        // pretend we are a BSTR
        *(UINT *)pStr = cchBufReq;
        pStr += sizeof(LPSTR);
        // and fill 'er up

        cchBufReq = WideCharToMultiByte(
                        CP_ACP, 0, _pch, Length(), pStr, cchBufReq, NULL, NULL);
        // guarantee null term
        pStr[cchBufReq] = '\0';
    }
    *pach = pStr;
    return *pach;

}
#endif //#ifdef _MAC

//+---------------------------------------------------------------------------
//
//  Member:     CStr::_Free, private
//
//  Synopsis:   Frees any memory held onto by this class.
//
//----------------------------------------------------------------------------

void
CStr::_Free()
{
    if (_pch )
    {
#ifdef _MAC
        LPSTR *pach = (LPSTR*)(((LPBYTE)_pch) - sizeof(UINT) - MACONLYSIZEOFPTR);

        if (*pach)
        {
            delete [] (*pach - sizeof(UINT));
            *pach=0;
        }
#endif
        delete [] (((BYTE *)_pch) - sizeof(UINT) - MACONLYSIZEOFPTR);
    }
    _pch=0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Clone
//
//  Synopsis:   Make copy of current string
//
//----------------------------------------------------------------------------
HRESULT
CStr::Clone(CStr **ppCStr) const
{
    HRESULT hr;
    Assert(ppCStr);
    *ppCStr = new CStr;
    hr = *ppCStr?S_OK:E_OUTOFMEMORY;
    if (hr)
        goto Cleanup;
    MemSetName((*ppCStr, "Cloned CStr:%s", MemGetName(*this)));

    hr = THR( (*ppCStr)->Set(*this) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Compare
//
//  Synopsis:   Case insensitive comparison of 2 strings
//
//----------------------------------------------------------------------------
BOOL
CStr::Compare (const CStr *pCStr) const
{
    return (!_tcsicmp(*pCStr, *this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ComputeCrc
//
//  Synopsis:   Computes a hash of the string.
//
//----------------------------------------------------------------------------
#pragma warning(disable:4305)
WORD
CStr::ComputeCrc() const
{
    WORD wHash=0;
    const TCHAR* pch;
    int i;

    pch=*this;
    for(i = Length();i > 0;i--, pch++)
    {
        wHash = wHash << 7 ^ wHash >> (16-7) ^ (TCHAR)CharUpper((LPTSTR)((DWORD_PTR)(*pch)));
    }

    return wHash;
}
#pragma warning(default:4305)

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Load
//
//  Synopsis:   Initializes the CStr from a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Load(IStream * pstm)
{
    DWORD cch;
    HRESULT hr;

    hr = THR(pstm->Read(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch == 0xFFFFFFFF)
    {
        Free();
    }
    else
    {
        hr = THR(Set(NULL, cch));
        if (hr)
            goto Cleanup;

        if (cch)
        {
            hr = THR(pstm->Read(_pch, cch * sizeof(TCHAR), NULL));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Save
//
//  Synopsis:   Writes the contents of the CStr to a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Save(IStream * pstm) const
{
    DWORD   cch = _pch ? Length() : 0xFFFFFFFF;
    HRESULT hr;

    hr = THR(pstm->Write(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch && cch != 0xFFFFFFFF)
    {
        hr = THR(pstm->Write(_pch, cch * sizeof(TCHAR), NULL));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetSaveSize
//
//  Synopsis:   Returns the number of bytes which will be written by
//              CStr::Save
//
//----------------------------------------------------------------------------
ULONG
CStr::GetSaveSize() const
{
    return(sizeof(DWORD) + (_pch ? (Length() * sizeof(TCHAR)) : 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\color.cxx ===
//+------------------------------------------------------------------------
//
//  File:       color.cxx
//
//  Contents:   FormsTranslateColor
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CColorInfo, Utilities, "CColorInfo")

COLORREF g_acrSysColor[25];
BOOL     g_fSysColorInit = FALSE;
COLORREF g_crPaletteRelative = 0;
HPALETTE g_hpalHalftone = NULL;

#ifndef _MAC 		
// Inverse color table
BYTE * g_pInvCMAP = NULL;
#endif

RGBQUAD g_rgbHalftone[256];

#if !defined(_MAC)
LOGPAL256 g_lpHalftone;
#else
LOGPAL256 g_lpHalftone =
{
    0x0300, 256,
    {
        { 0x00, 0x00, 0x00, 0x00 },
        { 0x80, 0x00, 0x00, 0x00 },
        { 0x00, 0x80, 0x00, 0x00 },
        { 0x80, 0x80, 0x00, 0x00 },
        { 0x00, 0x00, 0x80, 0x00 },
        { 0x80, 0x00, 0x80, 0x00 },
        { 0x00, 0x80, 0x80, 0x00 },
        { 0xC0, 0xC0, 0xC0, 0x00 },
        { 0xC0, 0xDC, 0xC0, PC_NOCOLLAPSE },
        { 0xA6, 0xCA, 0xF0, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0xEF, 0xD6, 0xC6, PC_NOCOLLAPSE },
        { 0xAD, 0xA9, 0x90, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0xA5, 0x00, 0x21, PC_NOCOLLAPSE },
        { 0xD6, 0x00, 0x93, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x50, 0x50, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x7C, 0x80, PC_NOCOLLAPSE },
        { 0x04, 0x04, 0x04, PC_NOCOLLAPSE },
        { 0x08, 0x08, 0x08, PC_NOCOLLAPSE },
        { 0x0C, 0x0C, 0x0C, PC_NOCOLLAPSE },
        { 0x11, 0x11, 0x11, PC_NOCOLLAPSE },
        { 0x16, 0x16, 0x16, PC_NOCOLLAPSE },
        { 0x1C, 0x1C, 0x1C, PC_NOCOLLAPSE },
        { 0x22, 0x22, 0x22, PC_NOCOLLAPSE },
        { 0x29, 0x29, 0x29, PC_NOCOLLAPSE },
        { 0x39, 0x39, 0x39, PC_NOCOLLAPSE },
        { 0x42, 0x42, 0x42, PC_NOCOLLAPSE },
        { 0x4D, 0x4D, 0x4D, PC_NOCOLLAPSE },
        { 0x55, 0x55, 0x55, PC_NOCOLLAPSE },
        { 0x5F, 0x5F, 0x5F, PC_NOCOLLAPSE },
        { 0x77, 0x77, 0x77, PC_NOCOLLAPSE },
        { 0x86, 0x86, 0x86, PC_NOCOLLAPSE },
        { 0x96, 0x96, 0x96, PC_NOCOLLAPSE },
        { 0xB2, 0xB2, 0xB2, PC_NOCOLLAPSE },
        { 0xCB, 0xCB, 0xCB, PC_NOCOLLAPSE },
        { 0xD7, 0xD7, 0xD7, PC_NOCOLLAPSE },
        { 0xDD, 0xDD, 0xDD, PC_NOCOLLAPSE },
        { 0xE3, 0xE3, 0xE3, PC_NOCOLLAPSE },
        { 0xEA, 0xEA, 0xEA, PC_NOCOLLAPSE },
        { 0xF1, 0xF1, 0xF1, PC_NOCOLLAPSE },
        { 0xF8, 0xF8, 0xF8, PC_NOCOLLAPSE },
        { 0xE7, 0xE7, 0xD6, PC_NOCOLLAPSE },
        { 0xCC, 0xEC, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0xFB, 0xF0, PC_NOCOLLAPSE },
        { 0xA0, 0xA0, 0xA4, PC_NOCOLLAPSE },
        { 0x80, 0x80, 0x80, 0x00 },
        { 0xFF, 0x00, 0x00, 0x00 },
        { 0x00, 0xFF, 0x00, 0x00 },
        { 0xFF, 0xFF, 0x00, 0x00 },
        { 0x00, 0x00, 0xFF, 0x00 },
        { 0xFF, 0x00, 0xFF, 0x00 },
        { 0x00, 0xFF, 0xFF, 0x00 },
        { 0xFF, 0xFF, 0xFF, 0x00 },
    }
};
#endif

void CopyColorsFromPaletteEntries(RGBQUAD *prgb, const PALETTEENTRY *ppe,
    UINT uCount)
{
    while (uCount--)
    {
        prgb->rgbRed   = ppe->peRed;
        prgb->rgbGreen = ppe->peGreen;
        prgb->rgbBlue  = ppe->peBlue;
        prgb->rgbReserved = 0;

        prgb++;
        ppe++;
    }
}

void CopyPaletteEntriesFromColors(PALETTEENTRY *ppe, const RGBQUAD *prgb,
    UINT uCount)
{
    while (uCount--)
    {
        ppe->peRed   = prgb->rgbRed;
        ppe->peGreen = prgb->rgbGreen;
        ppe->peBlue  = prgb->rgbBlue;
        ppe->peFlags = 0;

        prgb++;
        ppe++;
    }
}

HRESULT
InitPalette()
{
    HDC hdc = GetDC(NULL);
    HRESULT hr = S_OK;

#if !defined(_MAC) 		
    g_hpalHalftone = SHCreateShellPalette(NULL);
    if (g_hpalHalftone)
    {
        g_lpHalftone.wCnt = (WORD)GetPaletteEntries(g_hpalHalftone, 0, 256, g_lpHalftone.ape);
        g_lpHalftone.wVer = 0x0300;
        CopyColorsFromPaletteEntries(g_rgbHalftone, g_lpHalftone.ape, g_lpHalftone.wCnt);
    }
    else
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
#else
    g_hpalHalftone = CreatePalette((LOGPALETTE *)&g_lpHalftone);
    if (g_hpalHalftone == NULL)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
    CopyColorsFromPaletteEntries(g_rgbHalftone, g_lpHalftone.ape, g_lpHalftone.wCnt);
#endif

#if !defined(_MAC)
        // Get the dithering table
        SHGetInverseCMAP((BYTE *)&g_pInvCMAP, sizeof(BYTE *));
        if (g_pInvCMAP == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
#endif

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
#if DBG==1
        PALETTEENTRY ape[20], * pe = g_lpHalftone.ape;

        GetSystemPaletteEntries(hdc, 0, 10, ape);
        GetSystemPaletteEntries(hdc, 246, 10, ape + 10);

        if (    memcmp(ape, pe, 10 * sizeof(PALETTEENTRY)) != 0
            ||  memcmp(ape + 10, pe + 246, 10 * sizeof(PALETTEENTRY)) != 0)
        {
            TraceTag((tagPerf, "InitPalette: Unexpected system colors detected"));
        }
#endif

#ifndef NO_PERFDBG
        // Make sure we are using an identity palette
// Disable for IDW build
//        Assert(IsIdentityPalette(g_hpalHalftone));
#endif

        // Generate the inverse mapping table

        g_crPaletteRelative = 0x02000000;
    }
    else
        g_crPaletteRelative = 0;

Cleanup:
    ReleaseDC(NULL, hdc);

    RRETURN(hr);
}

void
DeinitPalette()
{
    if (g_hpalHalftone)
    {
        DeleteObject(g_hpalHalftone);
        g_hpalHalftone = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDefaultPalette
//
//  Synopsis:   Returns a generic (halftone) palette, optionally selecting it
//              into the DC.
//
//              Where possible, use CDoc::GetPalette instead.
//
//----------------------------------------------------------------------------

HPALETTE
GetDefaultPalette(HDC hdc)
{
    HPALETTE hpal = NULL;

    if (g_crPaletteRelative)
    {
        hpal = g_hpalHalftone;
        if (hdc)
        {
#if DBG == 1
            Check(SelectPalette(hdc, hpal, TRUE));
#else
            SelectPalette(hdc, hpal, TRUE);
#endif

            RealizePalette(hdc);
        }
    }
    return hpal;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsHalftonePalette
//
//  Synopsis:   Returns TRUE if the passed palette exactly matches the
//              halftone palette.
//
//----------------------------------------------------------------------------

BOOL
IsHalftonePalette(HPALETTE hpal)
{
    int cColors;
    PALETTEENTRY ape[256];
    
    if (!hpal)
        return FALSE;

    if (hpal == g_hpalHalftone)
        return TRUE;

    cColors = GetPaletteEntries(hpal, 0, 0, NULL);

    // Right number of colors?
    if (cColors != ARRAY_SIZE(ape))
        return FALSE;
    
    if (!GetPaletteEntries(hpal, 0, cColors, ape))
        return FALSE;

    return (!memcmp(ape, g_lpHalftone.ape, sizeof(PALETTEENTRY) * ARRAY_SIZE(ape)));
}

//+---------------------------------------------------------------------------
//
//  Function:   InitColorTranslation
//
//  Synopsis:   Initialize system color translation table.
//
//----------------------------------------------------------------------------

void
InitColorTranslation()
{
    for (int i = 0; i < ARRAY_SIZE(g_acrSysColor); i++)
    {
                // WinCE redefines all the GetSysColor defines
#if defined(WINCE) && !defined(WINCE_NT)
        g_acrSysColor[i] = GetSysColor(i | COLOR_INDEX_MASK);
#else
        g_acrSysColor[i] = GetSysColor(i);
#endif
    }

    g_fSysColorInit = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSysColorQuick
//
//  Synopsis:   Looks up system colors from a cache.
//
//----------------------------------------------------------------------------

COLORREF GetSysColorQuick(int i)
{
    if (!g_fSysColorInit)
        InitColorTranslation();

    return g_acrSysColor[i];
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsTranslateColor
//
//  Synopsis:   Map OLE_COLORs to COLORREFs.
//              This API is identical to OleTranslateColor.
//
//----------------------------------------------------------------------------

STDAPI
FormsTranslateColor(OLE_COLOR clr, HPALETTE hpal, COLORREF * pcr)
{
    int syscolor;

    switch (clr & 0xff000000)
    {
    case 0x80000000:

        syscolor = clr & 0x00ffffff;

        if (syscolor >= ARRAY_SIZE(g_acrSysColor))
            RRETURN(E_INVALIDARG);

        clr = GetSysColorQuick(syscolor);

        break;

    case 0x01000000 :
        // check validity of index
        if (hpal)
        {
            PALETTEENTRY pe;
            // try to get palette entry, if it fails we assume index is invalid
            if (!GetPaletteEntries(hpal, (UINT)(clr & 0xffff), 1, &pe))
                RRETURN(E_INVALIDARG);        // CONSIDER : CDK uses CTL_E_OVERFLOW
        }
        break;

#ifdef UNIX
    case 0x04000000 :   // Motif System Color
#endif
    case 0x02000000 :
        break;

    case 0:
        if (hpal != NULL)
        {
            clr |= 0x02000000;
        }
        break;

    default :
        RRETURN(E_INVALIDARG);
    }

    if (pcr)
        *pcr = clr;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsOleColorValid
//
//  Synopsis:   Return true if the given OLE_COLOR is valid.
//
//----------------------------------------------------------------------------

BOOL
IsOleColorValid(OLE_COLOR clr)
{
    //
    // QUESTION -- Why aren't we calling OleTranslateColor?
    //
    return OK(FormsTranslateColor(clr, NULL, NULL));
}


//+---------------------------------------------------------------------------
//
//  Function:   ColorRefFromOleColor
//
//  Synopsis:   Map OLE_COLORs to COLORREFs.  This function does not contain
//              any error checking.   Callers should validate the color with
//              IsOleColorValid() before calling this function.
//
//----------------------------------------------------------------------------

COLORREF
ColorRefFromOleColor(OLE_COLOR clr)
{
// Under WinCE all the colors come in as invalid--starting with 0xC... instead of 0x8
#if defined(WINCE) && !defined(WINCE_NT)
        clr &= 0x80ffffff;
#endif // WINCE
    Assert(IsOleColorValid(clr));
    Assert((clr & 0x02000000) == 0);

    if ((long)clr < 0)
    {
        return GetSysColorQuick(clr & 0xff);
    }
    else
    {
#ifdef UNIX
        if ( CColorValue(clr).IsMotifColor() ) // Motif System Color
            return clr;
#endif

        return clr | g_crPaletteRelative;
    }
}

HDC GetMemoryDC()
{
    HDC hdcMem;

    hdcMem = CreateCompatibleDC(NULL);

    if (hdcMem)
    {
        SetStretchBltMode(hdcMem, COLORONCOLOR);
        GetDefaultPalette(hdcMem);
    }

    return(hdcMem);
}

CColorInfo::CColorInfo() : _dwDrawAspect(DVASPECT_CONTENT) , _lindex(-1), _pvAspect(NULL), _ptd(NULL), _hicTargetDev(NULL), _cColors(0) , _cColorsMax(256)
{
}

CColorInfo::CColorInfo(DWORD dwDrawAspect, LONG lindex, void FAR *pvAspect, DVTARGETDEVICE FAR *ptd, HDC hicTargetDev, unsigned cColorsMax) :
    _dwDrawAspect(dwDrawAspect), _lindex(lindex) , _pvAspect(pvAspect) , _ptd(ptd) , _hicTargetDev(hicTargetDev) , _cColors(0)
{
    _cColorsMax = max((unsigned)256, cColorsMax);
}

HRESULT
CColorInfo::AddColors(HPALETTE hpal)
{
    unsigned cColors = GetPaletteEntries(hpal, 0, 0, NULL);
    cColors = min(_cColorsMax - _cColors, cColors);

    if (cColors)
    {
        GetPaletteEntries(hpal, 0, cColors, &_aColors[_cColors]);
        _cColors += cColors;
    }
    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(LOGPALETTE *pLogPal)
{
    RRETURN(AddColors(pLogPal->palNumEntries, pLogPal->palPalEntry));
}

HRESULT
CColorInfo::AddColors(unsigned cColors, PALETTEENTRY *pColors)
{
    // The check for system colors assumes they occur in the same order as
    // the real system colors.  This is the simplest possible fix for now.

    // Remove any system colors at the end (do this first so that cColors makes sense)

    Assert(g_lpHalftone.wCnt == 256);
    Assert(sizeof(PALETTEENTRY) == sizeof(DWORD));

    DWORD *pSystem = (DWORD *)&g_lpHalftone.ape[g_lpHalftone.wCnt - 1];
    DWORD *pInput = (DWORD *)&pColors[cColors - 1];
    while (cColors && (*pSystem == *pInput))
    {
        pSystem--;
        pInput--;
        cColors--;
    }

    // Remove any system colors at the beginning
    pSystem = (DWORD *)(g_lpHalftone.ape);
    pInput = (DWORD *)pColors;
    while (cColors && (*pSystem == *pInput))
    {
        pSystem++;
        pInput++;
        cColors--;
    }
    pColors = (PALETTEENTRY *)pInput;

    cColors = min(_cColorsMax - _cColors, cColors);
    if (cColors)
    {
        memcpy(&_aColors[_cColors], pColors, cColors * sizeof(PALETTEENTRY));
        _cColors += cColors;
    }

    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(unsigned cColors, RGBQUAD *pColors)
{
    cColors = min(_cColorsMax - _cColors, cColors);
    if (cColors)
    {
        CopyPaletteEntriesFromColors(&_aColors[_cColors], pColors, cColors);
        _cColors += cColors;
    }

    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(unsigned cColors, COLORREF *pColors)
{
    cColors = min(_cColorsMax - _cColors, cColors);
    while (cColors)
    {
        _aColors[_cColors].peRed = GetRValue(*pColors);
        _aColors[_cColors].peGreen = GetGValue(*pColors);
        _aColors[_cColors].peBlue = GetBValue(*pColors);
        _aColors[_cColors].peFlags = 0;
        pColors++;
    }

    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(IViewObject *pVO)
{
    LPLOGPALETTE pColors = NULL;
    HRESULT hr = pVO->GetColorSet(_dwDrawAspect, _lindex, _pvAspect, _ptd, _hicTargetDev, &pColors);
    if (FAILED(hr))
    {
        hr = E_NOTIMPL;
    }
    else if (hr == S_OK && pColors)
    {
        AddColors(pColors);
        CoTaskMemFree(pColors);

    }

    RRETURN1(hr, S_FALSE);
}

BOOL
CColorInfo::IsFull()
{
    Assert(_cColors <= _cColorsMax);
    return _cColors >= _cColorsMax;
}

HRESULT
CColorInfo::GetColorSet(LPLOGPALETTE FAR *ppColors)
{
    *ppColors = 0;
    if (_cColors == 0)
        RRETURN1(S_FALSE, S_FALSE);

    LOGPALETTE *pColors;

    //
    // It's just easier to allocate 256 colors instead of messing about.
    //
    *ppColors = pColors = (LOGPALETTE *)CoTaskMemAlloc(sizeof(LOGPALETTE) + 255 * sizeof(PALETTEENTRY));

    if (!pColors)
        RRETURN(E_OUTOFMEMORY);

    // This will ensure that we have a reasonable set of colors, including
    // the system colors to start
    memcpy(pColors, &g_lpHalftone, sizeof(g_lpHalftone));

    unsigned cColors = min((unsigned)236, _cColors);

    // Notice that we avoid overwriting the beginning of the _aColors array.
    // The assumption is that the colors are in some kind of order.
    memcpy(pColors->palPalEntry + 10, _aColors, cColors * sizeof(PALETTEENTRY));

    for (unsigned i = 10 ; i < (cColors + 10); i++)
        pColors->palPalEntry[i].peFlags = PC_NOCOLLAPSE;

    RRETURN(S_OK);
}
#if DBG == 1

ExternTag(tagPalette);

void DumpPalette(CHAR *szName, unsigned cColors, PALETTEENTRY *pColors)
{
    if (pColors)
    {
        TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "DumpPalette: %s\n", szName));
        TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "idx r  g  b  flags"));
        for (unsigned i = 0 ; i < cColors ; i++)
        {
            TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "%02x: %02x %02x %02x %02x", i, pColors[i].peRed, pColors[i].peGreen, pColors[i].peBlue, pColors[i].peFlags));
            if (i % 8 == 0)
                TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "\n"));
        }
    }
    else
        TraceTag((tagPalette, "%s is NULL", szName));
}

void DumpPalette(CHAR *szName, LOGPALETTE *lp)
{
    if (lp)
        DumpPalette(szName, lp->palNumEntries, lp->palPalEntry);
    else
        TraceTag((tagPalette, "%s is NULL", szName));
}

void DumpPalette(CHAR *szName, HPALETTE hpal)
{
    if (hpal)
    {
        PALETTEENTRY ape[256];
        DumpPalette(szName, GetPaletteEntries(hpal, 0, 256, ape), ape);
    }
    else
        TraceTag((tagPalette, "%s is NULL", szName));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\csimutil.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CSIMUTIL_HXX_
#define X_CSIMUTIL_HXX_
#include "csimutil.hxx"
#endif

MtDefine(CPointAry, Utilities, "CPointAry")
MtDefine(CPointAry_pv, CPointAry, "CPointAry::_pv")

//=-----------------------------------------------------------------------=
//
// Function:    NextNum
// 
// Synopsis:    Helper function for parsing out the COORDS attribute - 
//              After an intial call to _tcstok to set the pointer to
//              the first token, each call will set *plNum to the number
//              pointed to by *ppch, and then update *ppch to point to
//              the next token.
//
// Arguments:   LONG *plNum - Pointer to LONG to store next num in
//              TCHAR **ppch - Pointer to location in string
//
//=-----------------------------------------------------------------------=
HRESULT
NextNum(LONG *plNum, TCHAR **ppch)
{
    HRESULT hr = S_FALSE;

    Assert(plNum);
    *plNum = 0;


    if(*ppch)
    {
        IGNORE_HR(ttol_with_error(*ppch, plNum));
        *ppch = _tcstok(NULL, DELIMS);
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}


//=-----------------------------------------------------------------------=
//
// Function:    PointInCircle
//
// Synopsis:    Returns TRUE if the point is contained within the circle.
//
// Arguments:   POINT pt - The point to be checked for containment
//
//=-----------------------------------------------------------------------=
BOOL
PointInCircle(POINT pt, LONG lx, LONG ly, LONG lradius)
{
    LONG lDistance;

    // Calculate the square of the distance to the center
    lDistance = (pt.x - lx) * (pt.x - lx) + (pt.y - ly) * (pt.y - ly);

    // Compare against the square of the radius
    if(lDistance <= lradius * lradius)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//=-----------------------------------------------------------------------=
//
// Function: Contains
//
// Synopsis: Returns TRUE if the area contains the given point,
//              false if it does not.
//
//=-----------------------------------------------------------------------=

BOOL
Contains(POINT pt, union CoordinateUnion coords, UINT nShapeType)
{
    switch(nShapeType)
    {
    case SHAPE_TYPE_RECT:
        return PtInRect(&(coords.Rect), pt);
        break;

    case SHAPE_TYPE_CIRCLE:
        return PointInCircle(pt, 
                             coords.Circle.lx, 
                             coords.Circle.ly, 
                             coords.Circle.lradius);
        break;

    case SHAPE_TYPE_POLY:
        return PtInRegion(coords.Polygon.hPoly, pt.x, pt.y);
        break;

    default:
        Assert(FALSE && "Undefined shape");

        return FALSE;
        break;
    }
}


//=-----------------------------------------------------------------------=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\cputil.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cputil.cxx
//
//  Contents:   Connection point utilities.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

const ZERO_STRUCTS g_Zero = {0};


//+---------------------------------------------------------------------------
//
//  Function:   ConnectSink
//
//  Synopsis:   Connects a sink to an object which fires to the sink through
//              a connection point.
//
//  Arguments:  [pUnkSource] -- The source object.
//              [iid]        -- The id of the connection point.
//              [pUnkSink]   -- The sink.
//              [pdwCookie]  -- Cookie that identifies the connection for
//                                  a later disconnect.  May be NULL.
//
//----------------------------------------------------------------------------

HRESULT
ConnectSink(
        IUnknown *  pUnkSource,
        REFIID      iid,
        IUnknown *  pUnkSink,
        DWORD *     pdwCookie)
{
    HRESULT                     hr;
    IConnectionPointContainer * pCPC;

    Assert(pUnkSource);
    Assert(pUnkSink);

    hr = THR(pUnkSource->QueryInterface(
            IID_IConnectionPointContainer, (void **) &pCPC));
    if (hr)
        RRETURN(hr);

    hr = THR(ConnectSinkWithCPC(pCPC, iid, pUnkSink, pdwCookie));
    pCPC->Release();
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ConnectSinkWithCPC
//
//  Synopsis:   Connects a sink to an object which fires to the sink through
//              a connection point.
//
//  Arguments:  [pCPC]       -- The source object as an
//                                  IConnectionPointContainer.
//
//              [iid]        -- The id of the connection point.
//              [pUnkSink]   -- The sink.
//              [pdwCookie]  -- Cookie that identifies the connection for
//                                  a later disconnect.  May be NULL.
//
//----------------------------------------------------------------------------

HRESULT
ConnectSinkWithCPC(
        IConnectionPointContainer * pCPC,
        REFIID                      iid,
        IUnknown *                  pUnkSink,
        DWORD *                     pdwCookie)
{
    HRESULT             hr;
    IConnectionPoint *  pCP;
    DWORD               dwCookie;

    Assert(pCPC);
    Assert(pUnkSink);

    hr = ClampITFResult(THR_NOTRACE(pCPC->FindConnectionPoint(iid, &pCP)));
    if (hr)
        RRETURN1(hr, E_NOINTERFACE);

    if (!pdwCookie)
    {
        //
        // The CDK erroneously fails to handle a NULL cookie, so
        // we pass in a dummy one.
        //

        pdwCookie = &dwCookie;
    }

    hr = ClampITFResult(THR(pCP->Advise(pUnkSink, pdwCookie)));
    pCP->Release();
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   DisconnectSink
//
//  Synopsis:   Disconnects a sink from a source.
//
//  Arguments:  [pUnkSource] -- The source object.
//              [iid]        -- The id of the connection point.
//              [pdwCookie]  -- Pointer to the cookie which identifies the
//                                  connection.
//
//  Modifies:   [*pdwCookie] - sets to 0 if disconnect is successful.
//
//----------------------------------------------------------------------------

HRESULT
DisconnectSink(
        IUnknown *  pUnkSource,
        REFIID      iid,
        DWORD *     pdwCookie)
{
    HRESULT                     hr;
    IConnectionPointContainer * pCPC    = NULL;
    IConnectionPoint *          pCP     = NULL;
    DWORD                       dwCookie;

    Assert(pUnkSource);
    Assert(pdwCookie);

    if (!*pdwCookie)
        return S_OK;

    hr = THR(pUnkSource->QueryInterface(
            IID_IConnectionPointContainer, (void **) &pCPC));
    if (hr)
        goto Cleanup;

    hr = ClampITFResult(THR(pCPC->FindConnectionPoint(iid, &pCP)));
    if (hr)
        goto Cleanup;

    //
    // Allow clients to use *pdwCookie as an indicator of whether
    // or not they are advised by setting it to zero before
    // calling Unadvise.  This prevents recursion in some
    // scenarios.
    //

    dwCookie = *pdwCookie;
    *pdwCookie = NULL;
    hr = ClampITFResult(THR(pCP->Unadvise(dwCookie)));
    if (hr)
    {
        *pdwCookie = dwCookie;
    }

Cleanup:
    ReleaseInterface(pCP);
    ReleaseInterface(pCPC);

    RRETURN(hr);
}



//
// Remove the #ifdev when this function is actually used.
//

#ifdef NEVER

//+---------------------------------------------------------------------------
//
//  Function:   DisconnectSinkWithoutCookie
//
//  Synopsis:   Disconnects a sink from a connection point without
//              using a cookie.
//
//  Arguments:  [pUnkSource] -- The connection point container.
//              [iid]        -- The IID of the connection point.
//
//----------------------------------------------------------------------------

HRESULT
DisconnectSinkWithoutCookie(
        IUnknown *  pUnkSource,
        REFIID      iid,
        IUnknown *  pUnkConnection)
{
    HRESULT                     hr;
    IConnectionPointContainer * pCPC    = NULL;
    IConnectionPoint *          pCP     = NULL;
    IEnumConnections *          pEC     = NULL;
    CONNECTDATA                 cd;

    Assert(pUnkSource);

    //
    // Find the connection point.
    //

    hr = THR(pUnkSource->QueryInterface(
            IID_IConnectionPointContainer, (void **) &pCPC));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pCPC->FindConnectionPoint(iid, &pCP));
    if (hr)
        goto Cleanup;

    //
    // Find this connection.
    //

    hr = ClampITFResult(THR(pCP->EnumConnections(&pEC)));
    if (hr)
        goto Cleanup;

    while ((hr = THR_NOTRACE(pEC->Next(1, &cd, NULL))) == S_OK)
    {
        cd.pUnk->Release();
        if (cd.pUnk == pUnkConnection)
            break;
    }

    if (hr)
    {
        if (hr == S_FALSE)
            hr = E_FAIL;

        goto Cleanup;
    }

    // Disconnect.
    hr = ClampITFResult(THR(pCP->Unadvise(cd.dwCookie)));

Cleanup:
    ReleaseInterface(pEC);
    ReleaseInterface(pCP);
    ReleaseInterface(pCPC);

    RRETURN(hr);
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   GetDefaultDispatchTypeInfo
//
//  Synopsis:   Gets a default typeinfo of a coclass.
//
//  Arguments:  [pPCI]    -- Object containing coclass typeinfo.
//              [fSource] -- Is interface a source?
//              [ppTI]    -- Resulting typeinfo.
//
//  Returns:    HRESULT.
//
//  Modifies:   [ppTI].
//
//----------------------------------------------------------------------------

HRESULT
GetDefaultDispatchTypeInfo(IProvideClassInfo * pPCI,  BOOL fSource, ITypeInfo ** ppTI)
{
    HRESULT     hr;
    ITypeInfo * pTI = NULL;
    TYPEATTR *  pTA = NULL;
    WORD        w;
    int         implTypeFlags;
    HREFTYPE    hrt;
    ITypeInfo * pTIRef;
    TYPEATTR *  pTARef;
    int         implTypeFlagsDesired;

    Assert(pPCI);
    Assert(ppTI);

    *ppTI = NULL;
    hr = THR(pPCI->GetClassInfo(&pTI));
    if (hr)
        goto Cleanup;

    hr = THR(pTI->GetTypeAttr(&pTA));
    if (hr)
        goto Cleanup;

    if (pTA->typekind != TKIND_COCLASS)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    implTypeFlagsDesired = IMPLTYPEFLAG_FDEFAULT;
    if (fSource)
    {
        implTypeFlagsDesired |= IMPLTYPEFLAG_FSOURCE;
    }

    for (w = 0; !hr && w < pTA->cImplTypes; w++)
    {
        pTIRef = NULL;
        pTARef = NULL;

        hr = THR(pTI->GetImplTypeFlags(w, &implTypeFlags));
        if (hr)
            goto LoopCleanup;

        if (implTypeFlags != implTypeFlagsDesired)
            goto LoopCleanup;

        hr = THR(pTI->GetRefTypeOfImplType(w, &hrt));
        if (hr)
            goto LoopCleanup;

        hr = THR(pTI->GetRefTypeInfo(hrt, &pTIRef));
        if (hr)
            goto LoopCleanup;

        hr = THR(pTIRef->GetTypeAttr(&pTARef));
        if (hr)
            goto LoopCleanup;

        if (pTARef->typekind & TKIND_DISPATCH)
        {
            pTIRef->ReleaseTypeAttr(pTARef);
            *ppTI = pTIRef;
            goto Cleanup;
        }

LoopCleanup:
        if (pTARef)
            pTIRef->ReleaseTypeAttr(pTARef);
        ReleaseInterface(pTIRef);
    }

    hr = E_UNEXPECTED;

Cleanup:
    if (pTA)
        pTI->ReleaseTypeAttr(pTA);

    ReleaseInterface(pTI);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\datastm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       datastm.cxx
//
//  Contents:   CDataStream IStream wrapper
//
//  History:    04-22-1997   DBau (David Bau)    Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DATASTM_HXX_
#define X_DATASTM_HXX_
#include "datastm.hxx"
#endif

#ifndef X_SUBSTM_HXX_
#define X_SUBSTM_HXX_
#include "substm.hxx"
#endif

DeclareTag(tagDataStream, "DataStream", "DataStream methods")
MtDefine(CDataStream, Utilities, "CDataStream")
MtDefine(CDataStream_aryLocations_pv, CDataStream, "CDataStream::_aryLocations::_pv")

// String lengths are written twice, once xor'ed with a cookie, in order to
// lower the probability that we read a huge length and run out of
// memory when the read stream doesn't match the written stream.

#define DWORD_STRING_COOKIE (0xABACADAB)
#define DWORD_CSTR_COOKIE   (0xC0FFEE25)


//+------------------------------------------------------------------------
//
//  Class:      CDataStream
//
//              For robust and convenient saving and loading on a stream.
//
//              SaveData/LoadData - persists a block of bytes of known size;
//                          unlike IStream::Read, CDataStream::LoadData never
//                          succeeds on a partial read.
//
//              SaveDataNow/SaveDataLater - like SaveData, but used to save
//                          out of order. SaveDataLater reserves a position in
//                          the stream, and SaveDataNow writes the data into
//                          a reserved position.
//
//              SaveString/LoadString - for saving and loading a null-
//                          terminated, MemAlloc'ed unicode string.
//
//              SaveCStr/LoadCStr - for saving and loading a CStr.
//
//              BeginSaveSubstream/EndSaveSubstream - creates a
//                          substream of the main stream for writing;
//                          (the substream correctly handles things like
//                          setsize, stat, and seek)
//                          After writing is finished, EndSaveSubstream
//                          detaches the substream from the main stream
//                          and saves the stream length.
//                          The substream must be released after use.
//
//              LoadSubstream - creates a read-only substream (a clone)
//                          which has the data previously saved by
//                          *SaveSubstream.
//                          The substream must be released after use.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveData
//
//  Synopsis:   Wrapper for IStream::Write
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveData(void *pv, ULONG cb)
{
    HRESULT hr;
    ULONG cbWritten;
    
    Assert(pv);
    Assert(!_pSubstream); // Cannot save data in the middle of a substream operation

    //
    // NOTE (lmollico) - for some reason on NT5 we are getting
    // here and _pStream is equal to 1, which is bad. This is IE5 b1 bug
    // #23145
    //
    if (!_pStream)
        return E_FAIL;

    hr = THR(_pStream->Write(pv, cb, &cbWritten));
    if (hr)
        RRETURN(hr);

    if (cb != cbWritten)
    {
        Assert(0); // malformed stream
        return E_FAIL;
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveDataLater
//
//  Synopsis:   Encapsulates the work of seeking back and
//              forth to save data.
//
//              NOTE: convenient, but not particularly efficient
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveDataLater(DWORD *pdwCookie, ULONG cb)
{
    HRESULT hr;
    LARGEINT ib;
    CLocation loc;
    
    Assert(pdwCookie);
    Assert(!_pSubstream);

    hr = THR(_aryLocations.EnsureSize(_aryLocations.Size()+1));
    if (hr)
        goto Cleanup;

    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &loc._ib.uli));
    if (hr)
        goto Cleanup;

    loc._cb = cb;
    loc._dwCookie = _aryLocations.Size() ? _aryLocations[_aryLocations.Size()-1]._dwCookie+1 : 0;

    *pdwCookie = loc._dwCookie;
    
    Verify(!_aryLocations.AppendIndirect(&loc));

    ib.i64 = cb;
    hr = THR(_pStream->Seek(ib.li, STREAM_SEEK_CUR, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveDataNow
//
//  Synopsis:   Wrapper for IStream::Write
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveDataNow(DWORD dwCookie, void *pv, ULONG cb)
{
    HRESULT hr = E_FAIL;
    LARGEINT ibCur;
    int c;

    Assert(pv);
    
    for (c = _aryLocations.Size(); c;)
    {
        c--;
        if (_aryLocations[c]._dwCookie == dwCookie)
        {
            hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur.uli));
            if (hr)
                goto Cleanup;
                
            hr = THR(_pStream->Seek(_aryLocations[c]._ib.li, STREAM_SEEK_SET, NULL));
            if (hr)
                goto Cleanup;
                
            Assert(_aryLocations[c]._cb == cb);
            _aryLocations.Delete(c);

            hr = THR(SaveData(pv, cb));
            if (hr)
                goto Cleanup;
                
            hr = THR(_pStream->Seek(ibCur.li, STREAM_SEEK_SET, NULL));
            if (hr)
                goto Cleanup;
                
            return S_OK;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadData
//
//  Synopsis:   Wrapper for IStream::Read. Fails rather than
//              reading an incomplete chunk of data.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadData(void *pv, ULONG cb)
{
    HRESULT hr;
    ULONG cbRead;

    Assert(pv);

    hr = THR(_pStream->Read(pv, cb, &cbRead));
    if (hr)
        RRETURN(hr);

    if (cb != cbRead)
    {
        return E_FAIL;
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SeekData
//
//  Synopsis:   Wrapper for IStream::Seek. 
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SeekData( ULONG cb)
{
    HRESULT hr;
    LARGE_INTEGER   li;
    li.LowPart  = cb;
    li.HighPart = 0;
    
    hr = THR(_pStream->Seek( li, STREAM_SEEK_CUR, NULL )); 
    if (hr)
        RRETURN(hr);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveString
//
//  Synopsis:   Saves a null-terminated string by prefixing
//              the length in the stream
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveString(TCHAR *pch)
{
    HRESULT hr;
    ULONG len;

    len = pch ? _tcslen(pch) : (DWORD)(-1);

    hr = THR(SaveDword(DWORD_STRING_COOKIE ^ len));
    if (hr)
        goto Cleanup;

    hr = THR(SaveDword(len));
    if (hr)
        goto Cleanup;

    if (pch)
    {
        hr = THR(SaveData(pch, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadString
//
//  Synopsis:   Loads and allocates a null-terminated string
//              that was previously saved by SaveString
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SeekString()
{
    HRESULT hr;
    ULONG len;
    DWORD dwCode;

    hr = THR(LoadDword(&dwCode));
    if (hr)
        goto Cleanup;

    hr = THR(LoadDword(&len));
    if (hr)
        goto Cleanup;

    if ((len ^ dwCode) != DWORD_STRING_COOKIE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(SeekData( sizeof(TCHAR) * len));
    if (hr)
        goto Cleanup;


Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadString
//
//  Synopsis:   Loads and allocates a null-terminated string
//              that was previously saved by SaveString
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadString(TCHAR **ppch)
{
    HRESULT hr;
    ULONG len;
    DWORD dwCode;

    Assert(ppch);

    hr = THR(LoadDword(&dwCode));
    if (hr)
        goto Cleanup;

    hr = THR(LoadDword(&len));
    if (hr)
        goto Cleanup;

    if ((len ^ dwCode) != DWORD_STRING_COOKIE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(MemRealloc(Mt(CDataStream), (void**)ppch, sizeof(TCHAR)*(len + 1)));
    if (hr)
        goto Cleanup;

    if (*ppch)
    {
        hr = THR(LoadData(*ppch, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;

        (*ppch)[len] = _T('\0');
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveCStr
//
//  Synopsis:   Saves a CStr into the stream
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveCStr(const CStr *pcstr)
{
    HRESULT hr;
    ULONG len;

    len = *pcstr ? pcstr->Length() : (DWORD)(-1);

    hr = THR(SaveDword(DWORD_CSTR_COOKIE ^ len));
    if (hr)
        goto Cleanup;

    hr = THR(SaveDword(len));
    if (hr)
        goto Cleanup;

    if (*pcstr)
    {
        hr = THR(SaveData(*pcstr, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadCStr
//
//  Synopsis:   Loads a CStr previously saved by SaveCStr
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadCStr(CStr *pcstr)
{
    HRESULT hr;
    ULONG len;
    ULONG dwCode;

    Assert(pcstr);

    hr = THR(LoadDword(&dwCode));
    if (hr)
        goto Cleanup;

    hr = THR(LoadDword(&len));
    if (hr)
        goto Cleanup;

    if ((len ^ dwCode) != DWORD_CSTR_COOKIE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (len == (DWORD)-1)
    {
        pcstr->Free();
    }
    else
    {
        pcstr->Set(NULL, len);
        
        hr = THR(LoadData(*pcstr, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::BeginSaveSubstream
//
//  Synopsis:   Returns a new sub-IStream into which arbitrary
//              data can be saved immediately. Once writes
//              into the substream are completed,
//              EndSaveSubstream must be called.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::BeginSaveSubstream(IStream **ppSubstream)
{
    HRESULT hr;
    
    Assert(!_pSubstream);

    hr = THR(SaveDataLater(&_dwLengthCookie, sizeof(LARGEINT)));
    if (hr)
        goto Cleanup;

    hr = THR(CreateWritableSubstream(&_pSubstream, _pStream));
    if (hr) 
        goto Cleanup;

    _pSubstream->AddRef();
    *ppSubstream = _pSubstream;
        
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::EndSaveSubstream
//
//  Synopsis:   Completes the write of a substream into the
//              main stream (the length of the substream is
//              prefixed).
//
//-------------------------------------------------------------------------
HRESULT CDataStream::EndSaveSubstream()
{
    HRESULT hr;
    LARGEINT cb;
    
    Assert(_pSubstream);

    // Ask substream to seek to its end
    hr = THR(_pSubstream->Seek(LI_ZERO.li, STREAM_SEEK_END, &cb.uli));
    if (hr)
        goto Cleanup;

    _pSubstream->Detach(); // Ensure no further writes
    ClearInterface(&_pSubstream);
    
    // Save length
    hr = THR(SaveDataNow(_dwLengthCookie, &cb, sizeof(LARGEINT)));
    if (hr) 
        goto Cleanup;
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadSubstream
//
//  Synopsis:   Returns a new substream out of which arbitrary
//              data can be read at any time.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadSubstream(IStream **pStreamOut)
{
    LARGEINT cb;
    CSubstream *psubstream = NULL;
    HRESULT hr;
    
    hr = THR(LoadData(&cb, sizeof(LARGEINT)));
    if (hr)
        goto Cleanup;

    hr = THR(CreateReadOnlySubstream(&psubstream, _pStream, cb.uli));
    if (hr)
        goto Cleanup;

    hr = THR(_pStream->Seek(cb.li, STREAM_SEEK_CUR, NULL));
    if (hr)
        goto Cleanup;

    *pStreamOut = psubstream;
    psubstream = NULL;

Cleanup:
    delete psubstream;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SeekSubstream
//
//  Synopsis:   Seek over a sub-stream.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SeekSubstream()
{
    LARGEINT cb;
    HRESULT hr;
    
    hr = THR(LoadData(&cb, sizeof(LARGEINT)));
    if (hr)
        goto Cleanup;


    hr = THR(_pStream->Seek(cb.li, STREAM_SEEK_CUR, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::DumpStreamInfo
//
//  Synopsis:   Dump stream information for debugging
//
//-------------------------------------------------------------------------

#if (DBG == 1)

void CDataStream::DumpStreamInfo()
{
    HRESULT     hr;
    LARGEINT    ib;
    STATSTG     stat = { 0 };
    BYTE      * pBytes = NULL;
    BOOL        fHaveCurrent = FALSE;

    IGNORE_HR(_pStream->Stat(&stat, 0));

    TraceTag((tagDataStream, "Dumping Stream at 0x%x", _pStream));
    TraceTag((tagDataStream, "    pwcsName=%ws", stat.pwcsName ? stat.pwcsName : L"<no name>"));
    TraceTag((tagDataStream, "    cbSize(LowPart)=0x%x, cbSize(HighPart)=0x%x", 
                    stat.cbSize.LowPart, stat.cbSize.HighPart));

    if (stat.pwcsName)
        CoTaskMemFree(stat.pwcsName);
    
    // Get the current position of the stream into ib
    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ib.uli));
    if (hr)
        goto Cleanup;
    fHaveCurrent = TRUE;

    // Reset the stream to the beginning
    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    // TOdO: use the metered memory functions.
    pBytes = (BYTE *) LocalAlloc(LPTR, stat.cbSize.LowPart);
    if (!pBytes)
        goto Cleanup;

    hr = THR(_pStream->Read(pBytes, stat.cbSize.LowPart, NULL));
    if (hr)
        goto Cleanup;

    TraceTag((tagDataStream, "    Data at start of stream: >>>%.80s<<<", pBytes));

    TraceTag((tagDataStream, "    Data at end of stream: >>>%.80s<<<", 
        max(pBytes + stat.cbSize.LowPart - 80, pBytes)));

Cleanup:
    // Restore the position of the stream
    if (fHaveCurrent)
        _pStream->Seek(ib.li, STREAM_SEEK_SET, NULL);

    if (pBytes)
        LocalFree(pBytes);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\cenum.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cenum.cxx
//
//  Contents:   Generic enumerator class.
//
//  Classes:    CBaseEnum
//              CEnumGeneric
//              CEnumVARIANT
//
//  History:    05-05-93    ChrisZ      Added class object caching
//              05-11-93    ChrisZ      Cleanup on CF caching
//              02-24-93    LyleC       Moved from forms directory
//              01-Sep-93   DonCl       new (NullOnFail)
//              08-Sep-93   LyleC       Changed Next() to accept NULL 3rd param
//              15-May-94   adams       Added CBaseEnum, CEnumVARIANT
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CEnumGeneric, ObjectModel, "CEnumGeneric")
MtDefine(CEnumVARIANT, ObjectModel, "CEnumVARIANT")

//  TODO reconcile with CEnumXX in stdenum.cxx


// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//+------------------------------------------------------------------------
//
//  CBaseEnum Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CBaseEnum::Init(CImplAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CImplAry *  paryCopy    = NULL;     // copied array

    Assert(pary);

    // Copy array if necessary.
    if (fCopy)
    {
        paryCopy = new CImplAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(paryCopy->Copy(_cb, *pary, _fAddRef));
        if (hr)
            goto Error;

        pary = paryCopy;
    }

    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete)
{
    _ulRefs     = 1;

    _cb         = cb;
    _pary       = NULL;
    _piid       = &iid;
    _i          = 0;
    _fAddRef    = fAddRef;
    _fDelete    = fDelete;

    IncrementObjectCount(&_dwObjCnt);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    _ulRefs     = 1;

    _cb         = benum._cb;
    _piid       = benum._piid;
    _pary       = benum._pary;
    _i          = benum._i;
    _fAddRef    = benum._fAddRef;
    _fDelete    = benum._fDelete;

    IncrementObjectCount(&_dwObjCnt);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::~CBaseEnum(void)
{
    if (_pary && _fDelete)
    {
        if ( _fAddRef )
        {
            IUnknown ** ppUnk;
            int         i;
            int         cSize = _pary->Size();
            
            for (i=0, ppUnk = (IUnknown **) Deref(0);
                 i < cSize;
                 i++, ppUnk++)
            {
                (*ppUnk)->Release();
            }
        }

        delete _pary;
    }

    DecrementObjectCount(&_dwObjCnt);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, _pary->Size() - _i);
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Reset(void)
{
    _i = 0;

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  CEnumGeneric Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//----------------------------------------------------------------------------

class CEnumGeneric : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumGeneric))

    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    //  CEnumGeneric methods
    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            REFIID          iid,
            BOOL            fAddRef,
            BOOL            fCopy,
            BOOL            fDelete,
            CEnumGeneric ** ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumGeneric::Create(
        size_t          cb,
        CImplAry *      pary,
        REFIID          iid,
        BOOL            fAddRef,
        BOOL            fCopy,
        BOOL            fDelete,
        CEnumGeneric ** ppenum)
{
    HRESULT         hr      = S_OK;
    CEnumGeneric *  penum;

    Assert(pary);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    *ppenum = NULL;
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete) :
        CBaseEnum(cb, iid, fAddRef, fDelete)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    IUnknown ** ppUnk;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }
    memcpy(reelt, (BYTE *) Deref(_i), c * _cb);
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumElements(_cb, *_piid, (void **) ppenum, _fAddRef));
    if (hr)
        RRETURN(hr);

    (**(CEnumGeneric **)ppenum)._i = _i;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    HRESULT hr;

    Assert(ppv);
    hr = CEnumGeneric::Create(
            cb,
            this,
            iid,
            fAddRef,
            fCopy,
            fDelete,
            (CEnumGeneric **) ppv);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  CEnumVARIANT Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

class CEnumVARIANT : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumVARIANT))

    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            VARTYPE         vt,
            BOOL            fCopy,
            BOOL            fDelete,
            IEnumVARIANT ** ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);
    ~CEnumVARIANT();

    HRESULT Init(CImplAry * pary, BOOL fCopy);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);

    VARTYPE     _vt;                    // type of element enumerated
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumVARIANT::Create(
        size_t          cb,
        CImplAry *      pary,
        VARTYPE         vt,
        BOOL            fCopy,
        BOOL            fDelete,
        IEnumVARIANT ** ppenum)
{
    HRESULT         hr          = S_OK;
    CEnumVARIANT *  penum;              // enumerator to return.

    Assert(pary);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));
    *ppenum = NULL;
    penum = new CEnumVARIANT(cb, vt, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = (IEnumVARIANT *) (void *) penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete) :
        CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    _vt         = vt;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    _vt     = enumv._vt;
}

//+------------------------------------------------------------------------
//  Function:   ~CEnumVARIANT
//
//  Synopsis:   destructor
//
//  History:    8-4-1998  ferhane   Created
//-------------------------------------------------------------------------
CEnumVARIANT::~CEnumVARIANT()
{

    // if VARIANT, and have an array, and asked to delete the data
    // when terminated
    if ( (_vt == VT_VARIANT) && _pary && _fDelete )
    {
        int         i; 
        int         cSize = _pary->Size();
        VARIANT *   pVar;
        
        for( i=0, pVar = (VARIANT *) Deref(0); 
             i < cSize;
             i++, pVar++ )
        {
            IGNORE_HR( VariantClear( pVar ) );
        }

        // to avoid the same loop executing in the base class destructor
        delete _pary;
        _pary = NULL;
    }

    // we leave the decrementing of the reference count to the base
    // class destructor.
}
//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE *      pb;
    VARIANT *   pvar;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    for (i = 0, pb = (BYTE *) Deref(_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += _cb, pvar++)
    {
        V_VT(pvar) = _vt;
        switch (_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == _cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == _cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == _cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == _cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == _cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == _cb);
            hr = THR((*(IUnknown **) pb)->QueryInterface(
                    IID_IDispatch, (void **) &V_DISPATCH(pvar)));
            if (hr)
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ((IDispatch **) reelt)[j]->Release();
                }

                RRETURN(hr);
            }
            break;
        
        case VT_VARIANT:
            Assert( sizeof(*pvar) == _cb );
            hr = THR( VariantCopy( pvar, (VARIANT *)pb ));
            if (hr)
            {
                //Cleanup
                j=i;
                while( --j >= 0)
                {
                    VariantClear( &(((VARIANT *)reelt)[j]) );
                }

                RRETURN(hr);
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    _i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumVARIANT(_cb, _vt, (IEnumVARIANT **)ppenum));
    if (hr)
        RRETURN(hr);

    (**(CEnumVARIANT **)ppenum)._i = _i;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    HRESULT hr;

    Assert(ppenum);
    hr = CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumvariant::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//              This implementation provides VT_VARIANT data type support
//              for the clone operation on this class.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    8-5-98   ferhane   Created
//
//----------------------------------------------------------------------------
HRESULT
CEnumVARIANT::Init(CImplAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CImplAry *  paryCopy    = NULL;     // copied array

    Assert(pary);

    // If the enumeration does not contains a VT_VARIANT array,
    // then use the base class Init() method.
    if ( _vt != VT_VARIANT )
    {
        hr = THR( CBaseEnum::Init( pary, fCopy) );
        goto Cleanup;
    }

    Assert( _cb == sizeof(VARIANT));

    // Copy array if requested.
    if (fCopy)
    {
        VARIANT *   pvarSource;
        VARIANT *   pvarTarget;
        int         cSize = pary->Size();

        paryCopy = new CImplAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // make sure we have enough room in the array.
        hr = THR( paryCopy->EnsureSize(_cb, cSize));
        if ( hr )
            goto Error;

        // Move pointers to the array beginning addresses and copy 
        // each array member.
        pvarSource = (VARIANT *)pary->Deref(_cb, 0);
        pvarTarget = (VARIANT *)paryCopy->Deref( _cb, 0);
        
        for( int i=0; 
             i < cSize;
             i++, pvarSource++, pvarTarget++ )
        {
            hr = THR( VariantCopy( pvarTarget, pvarSource ) );
            if ( hr )
            {
                while( --i >= 0)
                {
                    VariantClear( --pvarTarget );
                }
                goto Error;
            }
        }

        pary = paryCopy;
    }

    // either the new array created because of the copy, or 
    // use the array that is handed ( fCopy == FALSE )
    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\color3d.cxx ===
//+------------------------------------------------------------------------
//
//  File:       color3d.cxx
//
//  Contents:   Definitions of 3d color
//
//  History:    21-Mar-95   EricVas  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

    //
    // Colors
    //

static inline COLORREF
DoGetColor ( BOOL fUseSystem, COLORREF coColor, int lColorIndex )
{
    return fUseSystem ? GetSysColorQuick( lColorIndex ) : coColor;
}
            
COLORREF ThreeDColors::BtnFace ( void )
    { return DoGetColor( _fUseSystem, _coBtnFace, COLOR_BTNFACE ); }

COLORREF ThreeDColors::BtnLight ( void )
    { return DoGetColor( _fUseSystem, _coBtnLight, COLOR_3DLIGHT); }

COLORREF ThreeDColors::BtnShadow ( void )
    { return DoGetColor( _fUseSystem, _coBtnShadow, COLOR_BTNSHADOW ); }
    
COLORREF ThreeDColors::BtnHighLight ( void )
    { return DoGetColor( _fUseSystem, _coBtnHighLight, COLOR_BTNHIGHLIGHT ); }

COLORREF ThreeDColors::BtnDkShadow ( void )
    { return DoGetColor( _fUseSystem, _coBtnDkShadow, COLOR_3DDKSHADOW ); }
    
COLORREF ThreeDColors::BtnText ( void )
    { return DoGetColor( TRUE, 0, COLOR_BTNTEXT ); }


    //
    // Brushes
    //

HBRUSH ThreeDColors::BrushBtnFace ( void )
    { return GetCachedBrush(BtnFace()); }

HBRUSH ThreeDColors::BrushBtnLight ( void )
    { return GetCachedBrush(BtnLight());}

HBRUSH ThreeDColors::BrushBtnShadow ( void )
    { return GetCachedBrush(BtnShadow()); }
    
HBRUSH ThreeDColors::BrushBtnHighLight ( void )
    { return GetCachedBrush(BtnHighLight()); }
    
HBRUSH ThreeDColors::BrushBtnText ( void )
    { return GetCachedBrush(BtnText()); }



//***********************************************************************
// Start of HWB Functions
//***********************************************************************

//
// RGB to HWB transform
//
// RGB are each on [0, 1]. W and B are returned on [0, 1] and H is  
// returned on [0, 6]. Exception: H is returned UNDEFINED if W == 1 - B.  
//
void RGBtoHWB(HWBVAL *pDstHWB, const RGBVAL *pSrcRGB)
{
    // extract RGB components
    float R = pSrcRGB->red;
    float G = pSrcRGB->green;
    float B = pSrcRGB->blue;

    // find the high and low components
    float loRGB = R;            float hiRGB = R;
    if (loRGB > G) loRGB = G;   if (hiRGB < G) hiRGB = G;
    if (loRGB > B) loRGB = B;   if (hiRGB < B) hiRGB = B;

    // compute the hue
    float hue = UNDEFINED_HUE;
    if (hiRGB != loRGB)
    {
        float f, i;

        if (R == loRGB)
        {
            f = G - B;
            i = 3.0f;
        }
        else if (G == loRGB)
        {
            f = B - R;
            i = 5.0f;
        }
        else
        {
            f = R - G;
            i = 1.0f;
        }

        hue = i - (f / (hiRGB - loRGB));
    }

    // store the result
    pDstHWB->hue       = hue;
    pDstHWB->whiteness = loRGB;
    pDstHWB->blackness = 1 - hiRGB;
}


//
// HWB to RGB transform
//
// H is given on [0, 6] or UNDEFINED. W and B are given on [0, 1].
// RGB are each returned on [0, 1].
//
void HWBtoRGB(RGBVAL *pDstRGB, const HWBVAL *pSrcHWB)
{
    // extract RGB components
    float hue       = pSrcHWB->hue;
    float whiteness = pSrcHWB->whiteness;
    float blackness = pSrcHWB->blackness;

    // extract value;
    float value = 1 - blackness;

    // default R, G and B to value
    float R = value;
    float G = value;
    float B = value;

    // if there is hue then compute the individual components
    if (hue != UNDEFINED_HUE)
    {
        int i = (int)hue;  // floor (h is positive)

        float f = hue - i;
        if (i & 1)
            f = 1.0f - f;

        float mid = whiteness + f * (value - whiteness);

        switch (i)
        {
        case 6:
        case 0:
            G = mid;
            B = whiteness;
            break;

        case 1:
            R = mid;
            B = whiteness;
            break;

        case 2:
            R = whiteness;
            B = mid;
            break;

        case 3:
            R = whiteness;
            G = mid;
            break;

        case 4:
            R = mid;
            G = whiteness;
            break;

        case 5:
            G = whiteness;
            B = mid;
            break;
        }
    }

    // store the result
    pDstRGB->red   = R;
    pDstRGB->green = G;
    pDstRGB->blue  = B;
}


//
// converts a COLORREF to an HWB color value
//
void COLORREFtoHWB(HWBVAL *pDstHWB, COLORREF crColor)
{
    // convert to RGB
    RGBVAL rgb;
    rgb.red   = (float)GetRValue(crColor) / 255.0f;
    rgb.green = (float)GetGValue(crColor) / 255.0f;
    rgb.blue  = (float)GetBValue(crColor) / 255.0f;

    // convert to HWB
    RGBtoHWB(pDstHWB, &rgb);
}


//
// converts an HWB color value to a COLORREF
//
COLORREF HWBtoCOLORREF(const HWBVAL *pSrcHWB)
{
    // convert from HWB
    RGBVAL rgb;
    HWBtoRGB(&rgb, pSrcHWB);

    // convert to integer [0..255]
    int R = (int)((rgb.red   * 255) + 0.5f);
    int G = (int)((rgb.green * 255) + 0.5f);
    int B = (int)((rgb.blue  * 255) + 0.5f);

    // pack into COLORREF
    return RGB(R, G, B);
}


//
// clips an HWB color to make sure (W + B) < 1.0
//
// bias parameter allows caller to specify how overflows are corrected
//  0.0 -> whiteness is reduced
//  1.0 -> blackness is reduced
//  0.5 -> whiteness and blackness are reduced evenly
//  etc...
//
void ClipHWB(HWBVAL *phwb, float bias)
{
    //t clip the raw range for whiteness
    if (phwb->whiteness > 1.0f)
        phwb->whiteness = 1.0f;
    else if (phwb->whiteness < 0.0f)
        phwb->whiteness = 0.0f;

    // clip the raw range for blackness
    if (phwb->blackness > 1.0f)
        phwb->blackness = 1.0f;
    else if (phwb->blackness < 0.0f)
        phwb->blackness = 0.0f;

    // compute the total of whiteness and blackness
    float v = phwb->whiteness + phwb->blackness;

    // if it is valid then we're done
    if (v >= 1.0)
    {
        // there is no hue when we W+B is maxed
        phwb->hue = UNDEFINED_HUE;

        // is there overflow to deal with?
        if (v > 1.0)
        {
            // convert to overflow
            v -= 1.0f;

            // split the overflow into biased components
            float vB = v * bias;
            float vW = v - vB;

            // reduce whiteness according to bias
            phwb->whiteness -= vW;

            // reduce blackness according to bias
            phwb->blackness -= vB;
        }
    }
}


//
// copies an HWB color and calls ClipHWB on the destination
//
// se ClipHWB for more info
//
void CopyClipHWB(HWBVAL *pDst, const HWBVAL *pSrc, float bias)
{
    // copy the raw value
    pDst->hue       = pSrc->hue;
    pDst->whiteness = pSrc->whiteness;
    pDst->blackness = pSrc->blackness;

    // clip with the specified bias
    ClipHWB(pDst, bias);
}


const float afHFudge[] =
{
    0.865f, // hue==0.0 red
    0.870f, // hue==0.5 orange
    1.300f, // hue==1.0 yellow
    1.100f, // hue==1.5 lime
    1.100f, // hue==2.0 green
    1.200f, // hue==2.5 aqua
    1.300f, // hue==3.0 cyan
    0.825f, // hue==3.5 peacock
    0.845f, // hue==4.0 blue
    0.900f, // hue==4.5 purple
    1.000f, // hue==5.0 magenta
    0.900f, // hue==5.5 fuscia
};

#define WB_FUDGE_MIN    (0.40f)
#define WB_FUDGE_MAX    (0.90f)

#define LIGHTEN_BASE    (0.05f)
#define LIGHTEN_SCALE   (0.55f)

#define DARKEN_BASE     (0.00f)
#define DARKEN_SCALE    (0.40f)

static float 
GetHueHighlightFudge(float hue)
{
    if(hue == UNDEFINED_HUE)
        return 1.0f;

    // fetch the hue and scale it for indexing into the fudge array
    float v = 2.0f * hue;
    int step = (int)v;

    // extract the two nearest factors
    float f1 = afHFudge[step % 12];
    float f2 = afHFudge[(step + 1) % 12];

    // calculate the interpolant to use
    float blend = v - step;

    // return the interpolated fudge factor
    return (f1 * (1.0f - blend)) + (f2 * blend);
}


static float 
GetWhiteBlackHighlightFudge(float whiteness, float blackness)
{
    // compute raw fudge factor from 0 to 1
    float v = (1.0f + whiteness - blackness) / 2.0f;

    // scale to desired output range
    return WB_FUDGE_MIN + v * (WB_FUDGE_MAX - WB_FUDGE_MIN);
}


static float 
GetHighlightFudge(const HWBVAL *pSrc)
{
    // make a clipped copy of the value
    HWBVAL hwb;
    CopyClipHWB(&hwb, pSrc, 0.5f);

    // compute the hue-based component of the fudge factor, start with the hue
    float hFudge = GetHueHighlightFudge(hwb.hue);

    // compute a W/B fudge factor from 0 to 1
    float wbFudge = GetWhiteBlackHighlightFudge(hwb.whiteness, hwb.blackness);

    // blend describes how strongly the W and B channels influence the final fudge factor
    float blend = hwb.whiteness + hwb.blackness;

    // combine the hue fudge with the W/B fudge and return it
    return (hFudge * (1.0f - blend)) + (wbFudge * blend);
}


void 
LightenHWB(HWBVAL *pDst, const HWBVAL *pSrc, float factor)
{
    // lighten the value
    pDst->hue       = pSrc->hue;
    pDst->whiteness = pSrc->whiteness + factor * (LIGHTEN_BASE + ((1.0 - pSrc->whiteness) * LIGHTEN_SCALE)) * GetHighlightFudge(pSrc);
    pDst->blackness = pSrc->blackness - factor * (LIGHTEN_BASE + (pSrc->blackness * LIGHTEN_SCALE));

    // make sure we adjust any overflows to favor a lighter color
    ClipHWB(pDst, 1.0f);
}


void 
DarkenHWB(HWBVAL *pDst, const HWBVAL *pSrc, float factor)
{
    // darker the value
    pDst->hue       = pSrc->hue;
    pDst->whiteness = pSrc->whiteness - factor * (DARKEN_BASE + (pSrc->whiteness * DARKEN_SCALE));
    pDst->blackness = pSrc->blackness + factor * (DARKEN_BASE + ((1.0 - pSrc->blackness) * DARKEN_SCALE));

    // make sure we adjust any overflows to favor a darker color
    ClipHWB(pDst, 0.0f);
}


//+------------------------------------------------------------------------
//
//  Functions:  LightenColor & DarkenColor
//
//  Synopsis:   These take COLORREFs and return COLORREFs which are "lighter" or
//              "darker"
//
//-------------------------------------------------------------------------

COLORREF LightenColor(COLORREF cr, float factor /* = 1.0f*/, BOOL fSubstituteSysColors /* = TRUE */)
{
    HWBVAL hwbSrc, hwbDst;

    // check if we should use system colors when the face matches
    if (fSubstituteSysColors && (cr == GetSysColor(COLOR_3DFACE)))
        return GetSysColor(COLOR_3DLIGHT);

    // convert to HWB color space
    COLORREFtoHWB(&hwbSrc, cr);

    // lighten the color
    LightenHWB(&hwbDst, &hwbSrc, factor);

    // convert back to RGB
    return HWBtoCOLORREF(&hwbDst);
}


COLORREF DarkenColor(COLORREF cr, float factor /* = 1.0f*/, BOOL fSubstituteSysColors /* = TRUE */)
{
    HWBVAL hwbSrc, hwbDst;

    // check if we should use system colors when the face matches
    if (fSubstituteSysColors && (cr == GetSysColor(COLOR_3DFACE)))
        return GetSysColor(COLOR_3DSHADOW);

    // convert to HWB color space
    COLORREFtoHWB(&hwbSrc, cr);

    // darken the color
    DarkenHWB(&hwbDst, &hwbSrc, factor);

    // convert back to RGB
    return HWBtoCOLORREF(&hwbDst);
}


// End of HWB Functions
//***********************************************************************


//+------------------------------------------------------------------------
//
//  Member:     ThreeDColors::SetBaseColor
//
//  Synopsis:   This is called to reestablish the 3D colors, based on a
//              single color.
//
//-------------------------------------------------------------------------

void
ThreeDColors::SetBaseColor ( OLE_COLOR coBaseColor )
{
        //
        // Sentinal color (0xffffffff) means use default which is button face
        //

    _fUseSystem = (coBaseColor & 0x80ffffff) == DEFAULT_BASE_COLOR;
    
#ifdef UNIX
    _fUseSystem = ( _fUseSystem ||
                    (CColorValue(coBaseColor).IsUnixSysColor()));
#endif

    if (_fUseSystem)
        return;

        //
        // Ok, now synthesize some colors! 
        //
        // First, use the base color as the button face color
        //
    
    _coBtnFace = ColorRefFromOleColor( coBaseColor );

    _coBtnLight = _coBtnFace;
        //
        // Dark shadow is always black and button face
        // (or so Win95 seems to indicate)
        //

    _coBtnDkShadow = 0;
    
        //
        // Now, lighten/darken colors
        //

    _coBtnShadow = DarkenColor( _coBtnFace );

    XHDC *pxhdc;
    HWND hwnd = NULL;
    HDC  hdc = NULL;

    if(_pxhdc)
    {
        pxhdc = _pxhdc;
    }
    else
    {
        // Use the screen DC, used currently to return values to currentStyle 
        hwnd = GetDesktopWindow();
        hdc = GetDC(hwnd);
        if (!hdc)
            return;
        pxhdc = new XHDC(hdc, NULL);
    }

    if(!pxhdc)
        return;

    COLORREF coRealBtnFace = GetNearestColor( *pxhdc, _coBtnFace );

    _coBtnHighLight = LightenColor( _coBtnFace );

    if (GetNearestColor( *pxhdc, _coBtnHighLight ) == coRealBtnFace)
    {
        _coBtnHighLight = LightenColor( _coBtnHighLight );

        if (GetNearestColor( *pxhdc, _coBtnHighLight ) == coRealBtnFace)
            _coBtnHighLight = RGB( 255, 255, 255 );
    }

    _coBtnShadow = DarkenColor( _coBtnFace );

    if (GetNearestColor( *pxhdc, _coBtnShadow ) == coRealBtnFace)
    {
        _coBtnShadow = DarkenColor( _coBtnFace );

        if (GetNearestColor( *pxhdc, _coBtnShadow ) == coRealBtnFace)
            _coBtnShadow = RGB( 0, 0, 0 );
    }

    if(hdc)
    {
        Assert(_pxhdc == 0);
        ReleaseDC(hwnd, hdc);
        delete pxhdc;
    }
}
//
// Function: RGB2YIQ
//
// Parameter: c -- the color in RGB.
//
// Note: Converts RGB to YIQ. The standard conversion matrix obtained
//       from Foley Van Dam -- 2nd Edn.
//
// Returns: Nothing
//
inline void CYIQ::RGB2YIQ (COLORREF   c)
{
    int R = GetRValue(c);
    int G = GetGValue(c);
    int B = GetBValue(c);

    _Y = (30 * R + 59 * G + 11 * B + 50) / 100;
    _I = (60 * R - 27 * G - 32 * B + 50) / 100;
    _Q = (21 * R - 52 * G + 31 * B + 50) / 100;
}

//
// Function: YIQ2RGB
//
// Parameter: pc [o] -- the color in RGB.
//
// Note: Converts YIQ to RGB. The standard conversion matrix obtained
//       from Foley Van Dam -- 2nd Edn.
//
// Returns: Nothing
//
inline void CYIQ::YIQ2RGB (COLORREF *pc)
{
    int R, G, B;

    R = (100 * _Y +  96 * _I +  62 * _Q + 50) / 100;
    G = (100 * _Y -  27 * _I -  64 * _Q + 50) / 100;
    B = (100 * _Y - 111 * _I + 170 * _Q + 50) / 100;

    // Needed because of round-off errors
    if (R < 0) R = 0; else if (R > 255) R = 255;
    if (G < 0) G = 0; else if (G > 255) G = 255;
    if (B < 0) B = 0; else if (B > 255) B = 255;

    *pc = RGB(R,G,B);
}

//
// Function: Luminance
//
// Parameter: c -- The color whose luminance is to be returned
//
// Returns: The luminance value [0,255]
//
static inline int Luminance (COLORREF c)
{
    return CYIQ(c)._Y;
}

//
// Function: MoveColorBy
//
// Parameters: pcColor [i,o] The color to be moved
//             nLums         Move so that new color is this bright
//                           or darker than the original: a signed
//                           number whose abs value is betn 0 and 255
//
// Returns: Nothing
//
static void MoveColorBy (COLORREF *pcColor, int nLums)
{
    CYIQ yiq(*pcColor);
    int Y;

    Y = yiq._Y;
    
    if (Y + nLums > CYIQ::MAX_LUM)
    {
        // Cannot move more in the lighter direction.
        *pcColor = RGB(255,255,255);
    }
    else if (Y + nLums < CYIQ::MIN_LUM)
    {
        // Cannot move more in the darker direction.
        *pcColor = RGB(0,0,0);
    }
    else
    {
        Y += nLums;
        if (Y < 0)
            Y = 0;
        if (Y > 255)
            Y =255;

        yiq._Y = Y;
        yiq.YIQ2RGB (pcColor);
    }
}

//
// Function: ContrastColors
//
// Parameters: c1,c2 [i,o]: Colors to be contrasted
//             Luminance:   Contrast so that diff is luminance is atleast
//                          this much: A number in the range [0,255]
//
// IMPORTANT: If you change this function, make sure, not to change the order
//            of the colors because some callers depend it.  For example if
//            both colors are white, we need to guarantee that only the
//            first color (c1) is darkens and never the second (c2).
//
// Returns: Nothing
//
void ContrastColors (COLORREF &c1, COLORREF &c2, int LumDiff)
{
    COLORREF *pcLighter, *pcDarker;
    int      l1, l2, lLighter, lDarker;
    int      lDiff, lPullApartBy;

    Assert ((LumDiff >= CYIQ::MIN_LUM) && (LumDiff <= CYIQ::MAX_LUM));

    l1 = Luminance(c1);
    l2 = Luminance(c2);

    // If both the colors are black, make one slightly bright so
    // things work OK below ...
    if ((l1 == 0) && (l2 == 0))
    {
        c1 = RGB(1,1,1);
        l1 = Luminance (c1);
    }
    
    // Get their absolute difference
    lDiff = l1 < l2 ? l2 - l1 : l1 - l2;

    // Are they different enuf? If yes get out
    if (lDiff >= LumDiff)
        return;

    // Attention:  Don't change the order of the two colors as some callers
    // depend on this order. In case both colors are the same they need
    // to know which color is made darker and which is made lighter.
    if (l1 > l2)
    {
        // c1 is lighter than c2
        pcLighter = &c1;
        pcDarker = &c2;
        lDarker = l2;
    }
    else
    {
        // c1 is darker than c2
        pcLighter = &c2;
        pcDarker = &c1;
        lDarker = l1;
    }

    //
    // STEP 1: Move lighter color
    //
    // Each color needs to be pulled apart by this much
    lPullApartBy = (LumDiff - lDiff + 1) / 2;
    Assert (lPullApartBy > 0);
    // First pull apart the lighter color -- in +ve direction
    MoveColorBy (pcLighter, lPullApartBy);

    //
    // STEP 2: Move darker color
    //
    // Need to move darker color in the darker direction.
    // Note: Since the lighter color may not have moved enuf
    // we compute the distance the darker color should move
    // by recomuting the luminance of the lighter color and
    // using that to move the darker color.
    lLighter = Luminance (*pcLighter);
    lPullApartBy = lLighter - LumDiff - lDarker;
    // Be sure that we are moving in the darker direction
    Assert (lPullApartBy <= 0);
    MoveColorBy (pcDarker, lPullApartBy);

    //
    // STEP 3: If necessary, move lighter color again
    //
    // Now did we have enuf space to move in darker region, if not,
    // then move in the lighter region again
    lPullApartBy = Luminance (*pcDarker) + LumDiff - lLighter;
    if (lPullApartBy > 0)
    {
        MoveColorBy (pcLighter, lPullApartBy);
    }

#ifdef DEBUG    
    {
        int l1 = Luminance (c1);
        int l2 = Luminance (c2);
        int diff = l1 - l2; 
    }
#endif    

    return;
}


void
ThreeDColors::NoDither()
{
    _coBtnFace          |= 0x02000000;
    _coBtnLight			|= 0x02000000;
    _coBtnShadow        |= 0x02000000;
    _coBtnHighLight     |= 0x02000000;
    _coBtnDkShadow      |= 0x02000000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\disputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities used internally by Forms3
//              and by C++ language integration clients.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        FormsFreeString(pEI->bstrSource);
        FormsFreeString(pEI->bstrDescription);
        FormsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SetErrorInfoFromEXCEPINFO
//
//  Synopsis:   Set per thread error info using data from an EXCEPINFO
//
//----------------------------------------------------------------------------

HRESULT
SetErrorInfoFromEXCEPINFO(EXCEPINFO *pexcepinfo)
{
    ICreateErrorInfo *  pCEI = NULL;
    IErrorInfo *        pEI = NULL;
    HRESULT             hr;

    if (pexcepinfo->pfnDeferredFillIn)
    {
        hr = THR((*pexcepinfo->pfnDeferredFillIn)(pexcepinfo));
        if (hr)
            goto Cleanup;

        pexcepinfo->pfnDeferredFillIn = NULL;
    }

    hr = THR(CreateErrorInfo(&pCEI));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetSource(pexcepinfo->bstrSource));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetDescription(pexcepinfo->bstrDescription));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetHelpFile(pexcepinfo->bstrHelpFile));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetHelpContext(pexcepinfo->dwHelpContext));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->QueryInterface(IID_IErrorInfo, (void **)&pEI));
    if (hr)
        goto Cleanup;

    hr = SetErrorInfo(NULL, pEI);

Cleanup:
    ReleaseInterface(pEI);
    ReleaseInterface(pCEI);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   VARTYPEFromBYTE
//
//  Synopsis:   Converts a byte specification of the type of a variant to
//              a VARTYPE.
//
//----------------------------------------------------------------------------

VARTYPE
VARTYPEFromBYTE(BYTE b)
{
    VARTYPE vt;

    Assert(!(b & 0xB0));
    if (b & 0x40)
    {
        vt = (VARTYPE) ((UINT) b ^ (0x40 | VT_BYREF));
    }
    else
    {
        vt = b;
    }

    return vt;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsVariantOmitted
//
//  Synopsis:   Checks to see if variant was omitted in vb call
//
//  Arguments:  [pvarg] -- Variant tpo check
//
//  Returns:    BOOL: TRUE is omitted
//
//----------------------------------------------------------------------------

BOOL
IsVariantOmitted ( const VARIANT * pvarg )
{
    if (!pvarg)
        return TRUE;
    
    return pvarg &&
           V_VT(pvarg) == VT_ERROR && 
           V_ERROR(pvarg) == DISP_E_PARAMNOTFOUND;
}


// We don't want to include the CRuntime so we've built the routine here.

// IEEE format specifies these...
// +Infinity: 7FF00000 00000000
// -Infinity: FFF00000 00000000
//       NAN: 7FF***** ********
//       NAN: FFF***** ********

// We also test for these, because the MSVC 1.52 CRT produces them for things
// like log(0)...
// +Infinity: 7FEFFFFF FFFFFFFF
// -Infinity: FFEFFFFF FFFFFFFF


// returns true for non-infinite nans.
int isNAN(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG  rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return 0 == (~v.rgw[0] & 0x7FF0) &&
        ((v.rgw[0] & 0x000F) || v.rgw[1] || v.rglu[1]);
#else
    return 0 == (~v.rgw[3] & 0x7FF0) &&
        ((v.rgw[3] & 0x000F) || v.rgw[2] || v.rglu[0]);
#endif
}


// returns false for infinities and nans.
int isFinite(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return (~v.rgw[0] & 0x7FE0) ||
        0 == (v.rgw[0] & 0x0010) &&
        (~v.rglu[1] || ~v.rgw[1] || (~v.rgw[0] & 0x000F));
#else
    return (~v.rgw[3] & 0x7FE0) ||
        0 == (v.rgw[3] & 0x0010) &&
        (~v.rglu[0] || ~v.rgw[2] || (~v.rgw[3] & 0x000F));
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGChangeTypeSpecial
//
//  Synopsis:   Helper.
//              Converts a VARIANT of arbitrary type to a VARIANT of type VT,
//              using browswer specific conversion rules, which may differ from
//              standard OLE Automation conversion rules (usually because
//              of legacy browser compatibility ).
//
//              This was pulled out of VARIANTARGToCVar because its also called
//              from CheckBox databinding.
//  
//  Arguments:  [pVArgDest]     -- Destination VARIANT (should already be init'd).
//              [vt]            -- Type to convert to.
//              [pvarg]         -- Variant to convert.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    1-7-96  cfranks pulled out from VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
VariantChangeTypeSpecial(VARIANT *pVArgDest, VARIANT *pvarg, VARTYPE vt,IServiceProvider *pSrvProvider, DWORD dwFlags)
{
    HRESULT             hr;
    IVariantChangeType *pVarChangeType = NULL;

    if (pSrvProvider)
    {
        hr = THR(pSrvProvider->QueryService(SID_VariantConversion,
                                            IID_IVariantChangeType,
                                            (void **)&pVarChangeType));
        if (hr)
            goto OldWay;

        // Use script engine conversion routine.
    	hr = pVarChangeType->ChangeType(pVArgDest, pvarg, 0, vt);

        //Assert(!hr && "IVariantChangeType::ChangeType failure");
        if (!hr || hr == E_ACCESSDENIED)
            goto Cleanup;   // ChangeType suceeded we're done...
    }

    // Fall back to our tried & trusted type coercions
OldWay:

    hr = S_OK;

    if (vt == VT_BSTR && V_VT(pvarg) == VT_NULL)
    {
        // Converting a NULL to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        hr = THR(FormsAllocString( _T("null"),
            &V_BSTR(pVArgDest) ) );
        goto Cleanup;
    }
    else if (vt == VT_BSTR && V_VT(pvarg) == VT_EMPTY)
    {
        // Converting "undefined" to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        hr = THR(FormsAllocString( _T("undefined"),
            &V_BSTR(pVArgDest) ) );
        goto Cleanup;
    }
    else if (vt == VT_BOOL && V_VT(pvarg) == VT_BSTR)
    {
        // Converting from BSTR to BOOL
        // To match Navigator compatibility empty strings implies false when
        // assigned to a boolean type any other string implies true.
        V_VT(pVArgDest) = VT_BOOL;
        V_BOOL(pVArgDest) = FormsStringLen(V_BSTR(pvarg)) == 0 ? VB_FALSE : VB_TRUE;
        goto Cleanup;
    }
    else if (  V_VT(pvarg) == VT_BOOL && vt == VT_BSTR )
    {
        // Converting from BOOL to BSTR
        // To match Nav we either get "true" or "false"
        V_VT(pVArgDest) = VT_BSTR;
        hr = THR(FormsAllocString( V_BOOL(pvarg) == VB_TRUE ? _T("true") : _T("false"),
            &V_BSTR(pVArgDest) ) );
        goto Cleanup;
    }
    // If we're converting R4 or R8 to a string then we need special handling to
    // map Nan and +/-Inf.
    else if (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        double  dblValue = V_VT(pvarg) == VT_R8 ? V_R8(pvarg) : (double)(V_R4(pvarg));

        // Infinity or NAN?
        if (!isFinite(dblValue))
        {
            if (isNAN(dblValue))
            {
                // NAN
                hr = FormsAllocStringW(_T("NaN"), &(V_BSTR(pVArgDest)));
            }
            else
            {
                // Infinity
                hr = FormsAllocStringW((dblValue < 0) ? _T("-Infinity") : _T("Infinity"), &(V_BSTR(pVArgDest)));
            }
        }
        else
            goto DefaultConvert;


        // Any error from allocating string?
        if (hr)
           goto Cleanup;

        V_VT(pVArgDest) = vt;
        goto Cleanup;
    }


DefaultConvert:
    //
    // Default VariantChangeTypeEx.
    //

    // VARIANT_NOUSEROVERRIDE flag is undocumented flag that tells OLEAUT to convert to the lcid
    // given. Without it the conversion is done to user localeid
    hr = THR_NOTRACE(VariantChangeTypeEx(pVArgDest, pvarg, LCID_SCRIPTING, dwFlags|VARIANT_NOUSEROVERRIDE, vt));

    
    if (hr == DISP_E_TYPEMISMATCH  )
    {
        if ( V_VT(pvarg) == VT_NULL )
        {
            hr = S_OK;
            switch ( vt )
            {
            case VT_BOOL:
                V_BOOL(pVArgDest) = VB_FALSE;
                V_VT(pVArgDest) = VT_BOOL;
                break;

            // For NS compatability - NS treats NULL args as 0
            default:
                V_UNKNOWN(pVArgDest) = NULL;
                break;
            }
        }
        else if (V_VT(pvarg) == VT_DISPATCH )
        {
            // Nav compatability - return the string [object] or null 
            V_VT(pVArgDest) = VT_BSTR;
            hr = THR(FormsAllocString ( (V_DISPATCH(pvarg)) ? _T("[object]") : _T("null"), &V_BSTR(pVArgDest) ) );
        }
        else if (   V_VT(pvarg) == VT_BSTR 
                &&  (   V_BSTR(pvarg)  
                    &&  ((V_BSTR(pvarg))[0] == _T('\0')) 
                    ||  ! V_BSTR(pvarg) )
                &&  (  vt == VT_I4 || vt == VT_I2 
                    || vt == VT_UI2 || vt == VT_UI4 
                    || vt == VT_I8 || vt == VT_UI8 
                    || vt == VT_INT || vt == VT_UINT ) )
        {
            // Converting empty string to integer => Zero
            hr = S_OK;
            V_VT(pVArgDest) = vt;
            V_I4(pVArgDest) = 0;
            goto Cleanup;
        }    
    }
    else if (hr == DISP_E_OVERFLOW && vt == VT_I4 && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        // Nav compatability - return MAXLONG on overflow
        V_VT(pVArgDest) = VT_I4;
        V_I4(pVArgDest) = MAXLONG;
        hr = S_OK;
        goto Cleanup;
    }

    // To match Navigator change any scientific notation E to e.
    if (!hr && (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4)))
    {
        TCHAR *pENotation;

        pENotation = _tcschr(V_BSTR(pVArgDest), _T('E'));
        if (pENotation)
            *pENotation = _T('e');
    }

Cleanup:
    ReleaseInterface(pVarChangeType);

    RRETURN(hr);
}

HRESULT ClipVarString(VARIANT *pvarSrc, VARIANT *pvarDest, BOOL *pfAlloc, WORD wMaxstrlen)
{
    HRESULT hr = S_OK;
    if (wMaxstrlen && (V_VT(pvarSrc) == VT_BSTR) && FormsStringLen(V_BSTR(pvarSrc)) > wMaxstrlen)
    {
        hr = FormsAllocStringLen(V_BSTR(pvarSrc), wMaxstrlen, &V_BSTR(pvarDest));
        if (hr)
            goto Cleanup;

        *pfAlloc = TRUE;
        V_VT(pvarDest) = VT_BSTR;
    }
    else
        hr = S_FALSE;

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg]         -- Variant to convert.
//              [pfAlloc]       -- BSTR allocated during conversion caller is
//                                 now owner of this BSTR or IUnknown or IDispatch
//                                 object allocated needs to be released.
//              [vt]            -- Type to convert to.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8, VT_ERROR.
//----------------------------------------------------------------------------

HRESULT
VARIANTARGToCVar(VARIANT * pvarg, BOOL *pfAlloc, VARTYPE vt, void * pv, IServiceProvider *pSrvProvider, WORD wMaxstrlen)
{
    HRESULT         hr = S_OK;
    VARIANTARG     *pVArgCopy = pvarg;
    VARIANTARG      vargNew;                    // variant of new type
    BOOL            fAlloc;

    Assert(pvarg);
    Assert(pv);

    VariantInit(&vargNew);

    if (!pfAlloc)
        pfAlloc = &fAlloc;

    Assert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    // Assume no allocations yet.
    *pfAlloc = FALSE;

    if (vt & VT_BYREF)
    {
        // If the parameter is a variant pointer then everything is acceptable.

        if ((vt & VT_TYPEMASK) == VT_VARIANT)
        {
            switch (V_VT(pvarg))
            {
            case VT_VARIANT | VT_BYREF :
                hr = ClipVarString(pvarg->pvarVal, *(VARIANT **)pv, pfAlloc, wMaxstrlen);
                break;
            default:
                hr = ClipVarString(pvarg, *(VARIANT **)pv, pfAlloc, wMaxstrlen);
                break;
            }
            if (hr == S_FALSE)
            {
                hr = S_OK;
                *(PVOID *)pv = (PVOID)pvarg;
            }

            goto Cleanup;
        }

        if ((V_VT(pvarg) & VT_TYPEMASK) != (vt & VT_TYPEMASK))
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Type of both original and destination or same type (however, original
        // may not be a byref only the original.

        if (V_ISBYREF(pvarg))
        {
            // Destination and original are byref and same type just copy pointer.
            *(PVOID *)pv = V_BYREF(pvarg);
        }
        else
        {
            // Convert original to byref.
            switch (vt & VT_TYPEMASK)
            {
            case VT_BOOL:
                *(PVOID *)pv = (PVOID)&V_BOOL(pvarg);
                break;

            case VT_I2:
                *(PVOID *)pv = (PVOID)&V_I2(pvarg);
                break;

            case VT_ERROR:
            case VT_I4:
                *(PVOID *)pv = (PVOID)&V_I4(pvarg);
                break;

            case VT_I8:
                *(PVOID *)pv = (PVOID)&V_I8(pvarg);
                break;
                
            case VT_R4:
                *(PVOID *)pv = (PVOID)&V_R4(pvarg);
                break;

            case VT_R8:
                *(PVOID *)pv = (PVOID)&V_R8(pvarg);
                break;

            case VT_CY:
                *(PVOID *)pv = (PVOID)&V_CY(pvarg);
                break;

            // All pointer types.
            case VT_PTR:
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                *(PVOID *)pv = (PVOID)&V_UNKNOWN(pvarg);
                break;

            case VT_VARIANT:
                Assert("Dead code: shudn't have gotten here!");
                *(PVOID *)pv = (PVOID)pvarg;
                break;

            default:
                Assert(!"Unknown type in BYREF VARIANTARGToCVar().\n");
                hr = DISP_E_TYPEMISMATCH;
                goto Cleanup;
            }
        }

        goto Cleanup;
    }
    // If the c style parameter is the same type as the VARIANT then we'll just
    // move the data.  Also if the c style type is a VARIANT then there's
    // nothing to convert just copy the variant to the C parameter.
    else if ((V_VT(pvarg) & (VT_TYPEMASK | VT_BYREF)) != vt && (vt != VT_VARIANT))
    {
        // If the request type isn't the same as the variant passed in then we
        // need to convert.
        pVArgCopy = &vargNew;

        hr = VariantChangeTypeSpecial(pVArgCopy, pvarg, vt,pSrvProvider);

        if (hr)
            goto Cleanup;

        *pfAlloc = (vt == VT_BSTR) || (vt == VT_UNKNOWN) || (vt == VT_DISPATCH);
    }

    // Move the variant data to C style data.
    switch (vt)
    {
    case VT_BOOL:
        #if DBG==1
            if (V_BOOL(pVArgCopy) != VB_FALSE && V_BOOL(pVArgCopy) != VB_TRUE)
            {
                TraceTag((tagWarning, "Illegal VT_BOOL in VARIANTARGToCVar"));
            }
        #endif

        // convert VT_TRUE and any other non-zero values to TRUE
        *(VARIANT_BOOL *)pv = V_BOOL(pVArgCopy);
        break;

    case VT_I2:
        *(short *)pv = V_I2(pVArgCopy);
        break;

    case VT_ERROR:
    case VT_I4:
        *(long *)pv = V_I4(pVArgCopy);
        break;

    case VT_I8:
        *(LONGLONG *)pv = V_I8(pVArgCopy);
        break;
        
    case VT_R4:
        *(float *)pv = V_R4(pVArgCopy);
        break;

    case VT_R8:
        *(double *)pv = V_R8(pVArgCopy);
        break;

    case VT_CY:
        *(CY *)pv = V_CY(pVArgCopy);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
        if (wMaxstrlen && FormsStringLen(V_BSTR(pVArgCopy)) > wMaxstrlen)
        {
            hr = FormsAllocStringLen(V_BSTR(pVArgCopy), wMaxstrlen, (BSTR *)pv);
            if (hr)
                goto Cleanup;

            if (*pfAlloc)
                VariantClear(&vargNew);
            else
                *pfAlloc = TRUE;

            goto Cleanup;
        }
    case VT_PTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(pVArgCopy);
        break;

    case VT_VARIANT:
        hr = ClipVarString(pVArgCopy, (VARIANT *)pv, pfAlloc, wMaxstrlen);
        if (hr == S_FALSE)
        {
            hr = S_OK;
            // Copy entire variant to output parameter.
            *(VARIANT *)pv = *pVArgCopy;
        }

        break;

    default:
        Assert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        hr = DISP_E_TYPEMISMATCH;
        break;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToIndex
//
//  Synopsis:   Converts a VARIANT to an index of type long. Sets the index to
//              -1 if the VARIANT type is bad or empty.
//
//  Arguments:  [pvarg]         -- Variant to convert.
//              [plIndex        -- Location to place index.
//
//  Notes:      Useful special case of VARIANTARGToCVar for reading array
//              indices.
//----------------------------------------------------------------------------

HRESULT
VARIANTARGToIndex(VARIANT * pvarg, long * plIndex)
{
    HRESULT         hr = S_OK;
        
    Assert(pvarg);
    *plIndex = -1;

    // Quick return for the common case
    if(V_VT(pvarg) == VT_I4 || V_VT(pvarg) == (VT_I4 | VT_BYREF))
    {
        *plIndex = (V_VT(pvarg) == VT_I4) ? V_I4(pvarg) : *V_I4REF(pvarg);
        return S_OK;
    }

    if (V_VT(pvarg) == VT_ERROR || V_VT(pvarg) == VT_EMPTY)
    {
        return S_OK;
    }

    // Must perform type corecion
    CVariant varNum;
    hr = THR(VariantChangeTypeEx(&varNum, pvarg, LCID_SCRIPTING, 0, VT_I4));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varNum) == VT_I4 || V_VT(&varNum) == (VT_I4 | VT_BYREF));
    *plIndex = (V_VT(&varNum) == VT_I4) ? V_I4(&varNum) : *V_I4REF(&varNum);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8, VT_ERROR.
//
//----------------------------------------------------------------------------

void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    Assert(pv);
    Assert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        Assert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_ERROR:
    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    case VT_CY:
        V_CY(pvarg) = *(CY *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_PTR:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(void **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pb]         -- List of C parameter types.  May be NULL.
//                              Construct using EVENT_PARAM macro.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        const BYTE *    pb,
        va_list         va)
{
    Assert(pDispParams);
    Assert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    const BYTE *    pbCur;              // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    pDispParams->cArgs = strlen((char *) pb);
    Assert(pDispParams->cArgs < EVENTPARAMS_MAX);

    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    Assert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pbCur = pb; *pbCur; pbCur++)
    {
        pvargCur--;
        Assert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = VARTYPEFromBYTE(*pbCur);
        if (V_VT(pvargCur) & VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (V_VT(pvargCur))
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                Assert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_ERROR:
            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = (float) va_arg(va, double);
                // casting & change to double inserted to fix BUG 5005
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_PTR:
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, void **);
                break;

            case VT_VARIANT:
                *pvargCur = va_arg(va, VARIANT);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pb]  -- Array of types of C-params.  May be NULL.
//                       Construct using EVENT_PARAM macro.
//              [...] -- List of pointers to c-params to be converted to.
//              -1    -- Last parameter to signal end of parameter list.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

HRESULT
__cdecl DispParamsToCParams(
        IServiceProvider   *pSrvProvider,
        DISPPARAMS         *pDP,
        ULONG              *pAlloc,
        WORD                wMaxstrlen,
        VARTYPE            *pVT,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    UINT            cArgs;             // count of arguments.

    Assert(pDP);

    hr = S_OK;
    va_start(va, pVT);
    if (!pVT)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    for (cArgs = 0; cArgs < pDP->cArgs; cArgs++)
    {
        BOOL    fAlloc;

        // If the DISPID_THIS named argument is passed in skip it.
        if (pDP->cNamedArgs && (pDP->cArgs - cArgs <= pDP->cNamedArgs))
        {
            if (pDP->rgdispidNamedArgs[(pDP->cArgs - cArgs) - 1] == DISPID_THIS)
            {
                pvargCur--;
                continue;
            }
        }

        pv = va_arg(va, void *);

        // Done processing arguments?
        if (pv == (void *)-1)
            goto Cleanup;

        // Skip all byvalue variants custom invoke doesn't pass them.
        if (!((*pVT == VT_VARIANT) && (pv == NULL)))
        {
            hr = THR(VARIANTARGToCVar(pvargCur, &fAlloc, *pVT, pv, pSrvProvider, ((wMaxstrlen == pdlNoLimit) ? 0 : wMaxstrlen)));
            if (hr)
                goto Cleanup;

            // Any BSTRs or objects (IUnknow, IDispatch) allocated during
            // conversion to CVar then remember which param this occurred to so
            // we can de-allocate it when we're finished.
            if (pAlloc && fAlloc)
            {
                *pAlloc |= (1 << cArgs);
            }
        }

        pvargCur--;
        pVT++;
    }

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}

//----------------------------------------------------------------------
//
// Function: GetNamedProp
//
// Description: Gets a property by name.  Does all the work for you
//
//----------------------------------------------------------------------
HRESULT
GetNamedProp(IDispatch *pDispatch, BSTR bstrPropName, LCID lcid, VARIANT *pv, DISPID *pDispid, EXCEPINFO *pexecpinfo, BOOL fMethodCall, BOOL fCaseSensitive)
{
    HRESULT hr;
    DISPID dispid;
    IDispatchEx *pDEX = 0;
    DWORD flags = fMethodCall ? DISPATCH_METHOD : DISPATCH_PROPERTYGET;
    DISPPARAMS dp;
    UINT uiErr;

    if (pDispid == 0)
        pDispid = &dispid;
    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(pv);

    if (fCaseSensitive)
    {
        hr = THR(pDispatch->QueryInterface(IID_IDispatchEx, (LPVOID *) &pDEX));
        if (hr)
            goto Cleanup;

        hr = THR(pDEX->GetDispID(bstrPropName, fdexNameCaseSensitive , pDispid));
        if (hr)
            goto Cleanup;

        hr = THR(pDEX->InvokeEx(*pDispid, lcid, flags, &dp, pv, pexecpinfo, NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pDispatch->GetIDsOfNames(IID_NULL, &bstrPropName, 1, lcid, pDispid));
        if (hr)
            goto Cleanup;

        hr = THR(pDispatch->Invoke(*pDispid, IID_NULL, lcid, flags, &dp, pv, pexecpinfo, &uiErr));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pDEX);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//              [pexcepinfo] -- where caller wants exception info
//              [fMethodCall] -- a straight method call should be used,
//                               rather than property-specific mechanisms
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo,
        DWORD       dwFlags)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    Assert(pDisp);
    Assert(pvar);

    dwFlags = (dwFlags & DISPATCH_METHOD) ? DISPATCH_METHOD : DISPATCH_PROPERTYGET;
    
    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = THR_NOTRACE(pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            dwFlags,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr));


    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//              [pexcepinfo] -- where caller wants exception info
//              [fMethodCall] -- a straight method call should be used,
//                               rather than property-specific mechanisms
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo,
        DWORD           dwFlags)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    Assert(pDisp);
    Assert(pvarg);

    dp.rgvarg = pvarg;
    dp.cArgs = 1;
    
    if (dwFlags & DISPATCH_METHOD)
    {
        dwFlags = DISPATCH_METHOD;
        dp.cNamedArgs = 0;
        dp.rgdispidNamedArgs = NULL;
    }
    else
    {
        dwFlags = (dispid == DISPID_FONT || (dwFlags & DISPATCH_PROPERTYPUTREF))
                    ? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT;
        dp.cNamedArgs = 1;
        dp.rgdispidNamedArgs = &dispidPut;
    }
    hr = THR_NOTRACE(pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            dwFlags,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr));

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pbParams]  -- List of param types.  May be NULL.
//                             Construct using EVENT_PARAM macro.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
__cdecl CallDispMethod(
        IServiceProvider *pSrvProvider,
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        BYTE *      pbParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.
    EXCEPINFO   excepinfo;             // macnote: this is a required param to IDispatch->Invoke
    BOOL        fVariantClear = FALSE;
    IDispatchEx *pDispEx = NULL;

    Assert(pDisp);
    Assert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pbParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pbParams, va);
    va_end(va);
    memset(&excepinfo,0,sizeof(excepinfo));

    if (pvReturn)
        VariantInit(&varReturn);

    // use IDispatchEx, if available
    hr = pDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx);

    if (!hr && pDispEx)
    {
        hr = THR_NOTRACE(pDispEx->InvokeEx(
                dispid,
                lcid,
                DISPATCH_METHOD,
                &dp,
                pvReturn ? &varReturn : NULL,
                &excepinfo,
                pSrvProvider));
    }
    else
    {
        hr = THR_NOTRACE(pDisp->Invoke(
                dispid,
                IID_NULL,
                lcid,
                DISPATCH_METHOD,
                &dp,
                pvReturn ? &varReturn : NULL,
                &excepinfo,
                NULL));
    }
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = THR(VARIANTARGToCVar(&varReturn, &fVariantClear, vtReturn, pvReturn, pSrvProvider));
    if (fVariantClear)
        VariantClear(&varReturn);

Cleanup:
    FreeEXCEPINFO(&excepinfo);
    ReleaseInterface(pDispEx);
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !FormsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_PTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        Assert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}


//+------------------------------------------------------------------------
//  Function:   DispParamsToSAFEARRAY, public API
//
//  Synopsis:   Converts all arguments in dispparams to a SAFEARRAY
//              If the DISPPARAMS contains no arguments we should create
//              an empty SAFEARRAY.
//
//  Arguments:  [pdispparams] -- VARIANTARGs to add to safearray.
//
//  Returns:    If the DISPPARAMS contains no arguments we should create an
//              empty SAFEARRAY.  It is the responsibility of the caller to
//              call SafeArrayDestroy.
//-------------------------------------------------------------------------

SAFEARRAY *
DispParamsToSAFEARRAY (DISPPARAMS *pdispparams)
{
    SAFEARRAY  *psa = NULL;
    HRESULT     hr = S_OK;

    LONG saElemIdx;
    SAFEARRAYBOUND  sabounds;
    const LONG cArgsToArray = pdispparams->cArgs;
    const LONG cArgsNamed = pdispparams->cNamedArgs;

    sabounds.cElements = cArgsToArray;

    // If first named arg is DISPID_THIS then this parameter won't be part of
    // the safearray.
    if (cArgsNamed)
    {
        if (pdispparams->rgdispidNamedArgs[0] == DISPID_THIS)
            sabounds.cElements--;
    }

    sabounds.lLbound = 0;
    psa = SafeArrayCreate(VT_VARIANT, 1, &sabounds);
    if (psa == NULL)
        goto Cleanup;

    // dispparams are in right to left order.
    for( saElemIdx = 0; saElemIdx < cArgsToArray; saElemIdx++ )
    {
        // Don't process any DISPID_THIS named arguments.
        if (cArgsNamed && (cArgsToArray - saElemIdx <= cArgsNamed))
        {
            if (pdispparams->rgdispidNamedArgs[(cArgsToArray - saElemIdx) - 1] == DISPID_THIS)
                continue;
        }

        hr = SafeArrayPutElement(psa, &saElemIdx, pdispparams->rgvarg + (cArgsToArray - 1 - saElemIdx) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr && psa)
    {
        hr = SafeArrayDestroy(psa);
        psa = NULL;
    }

    return psa;
}

//+------------------------------------------------------------------------
//
//  Class:      CInvoke
//
//-------------------------------------------------------------------------

CInvoke::CInvoke()
{
    memset (this, 0, sizeof(*this));
}

CInvoke::CInvoke (IDispatchEx * pdispex)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(pdispex));
}

CInvoke::CInvoke (IDispatch * pdisp)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(pdisp));
}

CInvoke::CInvoke (IUnknown * punk)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(punk));
}

CInvoke::CInvoke (CBase * pBase)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(pBase));
}

CInvoke::~CInvoke()
{
    Clear();
}

HRESULT
CInvoke::Init(IDispatchEx * pdispex)
{
    ReplaceInterface (&_pdispex, pdispex);

    return S_OK;
};

HRESULT
CInvoke::Init(IDispatch * pdisp)
{
    ReplaceInterface (&_pdisp, pdisp);

    return S_OK;
};

HRESULT
CInvoke::Init(IUnknown * punk)
{
    HRESULT hr;

    hr = THR(punk->QueryInterface(IID_IDispatchEx, (void**)&_pdispex));
    if (hr)
    {
        _pdispex = NULL;

        hr = THR(punk->QueryInterface(IID_IDispatch, (void**)&_pdisp));
    }

    RRETURN (hr);
}

HRESULT
CInvoke::Init(CBase * pBase)
{
    HRESULT hr;

    hr = THR(pBase->PrivateQueryInterface(IID_IDispatchEx, (void**)&_pdispex));

    RRETURN (hr);
}

void
CInvoke::Clear()
{
    ClearInterface(&_pdispex);
    ClearInterface(&_pdisp);
    ClearArgs();
    ClearRes();
}

void
CInvoke::ClearArgs()
{
    UINT i;

    for (i = 0; i < _dispParams.cArgs; i++)
    {
        VariantClear(&_aryvarArg[i]);
    }
    _dispParams.cArgs  = 0;
    _dispParams.rgvarg = NULL;
}

void
CInvoke::ClearRes()
{
    VariantClear(&_varRes);
}

HRESULT
CInvoke::Invoke (DISPID dispid, WORD wFlags)
{
    HRESULT     hr;

    Assert (_pdispex || _pdisp);

    if (_pdispex)
    {
        hr = THR_NOTRACE(_pdispex->InvokeEx(
            dispid, g_lcidUserDefault, wFlags, &_dispParams, &_varRes, &_excepInfo, NULL));
    }
    else if (_pdisp)
    {
        UINT    nArgErr;

        hr = THR_NOTRACE(_pdisp->Invoke(
            dispid, IID_NULL, g_lcidUserDefault, wFlags, &_dispParams, &_varRes, &_excepInfo, &nArgErr));
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN (hr);
}

HRESULT
CInvoke::AddArg()
{
    HRESULT     hr = S_OK;

    if (ARRAY_SIZE(_aryvarArg) <= _dispParams.cArgs)
        RRETURN (E_NOTIMPL);

    if (0 == _dispParams.cArgs)
    {
        _dispParams.rgvarg = _aryvarArg;
    }

    _dispParams.cArgs++;

    RRETURN (hr);
}

HRESULT
CInvoke::AddArg(VARIANT * pvarArg)
{
    HRESULT     hr;

    hr = THR(AddArg());
    if (hr)
        goto Cleanup;

    VariantCopy(&_aryvarArg[_dispParams.cArgs - 1], pvarArg);

Cleanup:

    RRETURN (hr);
}

HRESULT
CInvoke::AddNamedArg(DISPID dispid)
{
    HRESULT     hr = S_OK;

    if (ARRAY_SIZE(_arydispidNamedArg) <= _dispParams.cNamedArgs)
        RRETURN (E_NOTIMPL);

    if (0 == _dispParams.cNamedArgs)
    {
        _dispParams.rgdispidNamedArgs = _arydispidNamedArg;
    }

    _dispParams.cNamedArgs++;

    _arydispidNamedArg[_dispParams.cNamedArgs - 1] = dispid;

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\disputl2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dsputil2.cxx
//
//  Contents:   More dispatch utilities.
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

DeclareTag(tagLoadTypeInfo, "TypeInfo", "Trace typeinfo load")
MtDefine(LoadTypeLib, PerfPigs, "Loading type-library MSHTML.TLB")

//+----------------------------------------------------------------------------
//
//  Member:     GetTypeInfoFromCoClass
//
//  Synopsis:   Return either the default dispinterface or default source
//              interface ITypeInfo from a coclass
//
//  Arguments:  pTICoClass - ITypeInfo for containing coclass
//              fSource    - Return either source (TRUE) or default (FALSE) interface
//              ppTI       - Location at which to return the interface (may be NULL)
//              piid       - Location at which to return ther interface IID (may be NULL)
//
//  Returns:    S_OK, E_xxxx
//
//-----------------------------------------------------------------------------
HRESULT
GetTypeInfoFromCoClass(
    ITypeInfo *     pTICoClass,
    BOOL            fSource,
    ITypeInfo **    ppTI,
    IID *           piid)
{
    ITypeInfo * pTI = NULL;
    TYPEATTR *  pTACoClass = NULL;
    TYPEATTR *  pTA = NULL;
    IID         iid;
    HREFTYPE    href;
    int         i;
    int         flags;
    HRESULT     hr;

    Assert(pTICoClass);

    if (!ppTI)
        ppTI = &pTI;
    if (!piid)
        piid = &iid;

    *ppTI = NULL;
    *piid = IID_NULL;

    hr = THR(pTICoClass->GetTypeAttr(&pTACoClass));
    if (hr)
        goto Cleanup;
    Assert(pTACoClass->typekind == TKIND_COCLASS);

    for (i = 0; i < pTACoClass->cImplTypes; i++)
    {
        hr = THR(pTICoClass->GetImplTypeFlags(i, &flags));
        if (hr)
            goto Cleanup;

        if ((flags & IMPLTYPEFLAG_FDEFAULT) &&
            ((fSource && (flags & IMPLTYPEFLAG_FSOURCE)) ||
             (!fSource && !(flags & IMPLTYPEFLAG_FSOURCE))))
        {
            hr = THR(pTICoClass->GetRefTypeOfImplType(i, &href));
            if (hr)
                goto Cleanup;

            hr = THR(pTICoClass->GetRefTypeInfo(href, ppTI));
            if (hr)
                goto Cleanup;

            hr = THR((*ppTI)->GetTypeAttr(&pTA));
            if (hr)
                goto Cleanup;

            *piid = pTA->guid;
            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:
    if (pTA)
    {
        Assert(*ppTI);
        (*ppTI)->ReleaseTypeAttr(pTA);
    }
    ReleaseInterface(pTI);
    if (pTACoClass)
    {
        Assert(pTICoClass);
        pTICoClass->ReleaseTypeAttr(pTACoClass);
    }
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//  
//  Function:   GetFormsTypeLibPath
//  
//  Synopsis:   Returns the path to a forms type library, either the
//              raw unadorned type library or the special merged
//              version, depending on dwFlags.
//  
//  Arguments:  [ach]       
//  
//  Returns:    HRESULT
//  
//-------------------------------------------------------------------------

void
GetFormsTypeLibPath(TCHAR * ach)
{
    _tcscpy(ach, g_achDLLCore);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetFormsTypeLib
//
//  Synopsis:   Get cached Forms3 type library.
//
//              Note: Not only does it seem like a good idea to
//              to cache the type library, it gets around a suspected
//              bug in LoadTypeLib.  I (garybu) have observed LoadTypeLib
//              returning a bogus object when called repeatedly.
//
//  Arguments:  ppTL        The type library
//              fNoCache    Don't cache the library
//
//----------------------------------------------------------------------------

HRESULT
GetFormsTypeLib(ITypeLib **ppTL, BOOL fNoCache)
{
    THREADSTATE *   pts;
    HRESULT         hr;
    TCHAR           ach[MAX_PATH];
    TCHAR *         pchName;

    pts = GetThreadState();

    if (pts->pTLCache)
    {
        *ppTL = pts->pTLCache;
        (*ppTL)->AddRef();
        return S_OK;
    }

    TraceTag((tagPerf, "Loading Trident Type Library."));

    //TODO (carled) again the crt library shutdown causes oleaut32 to leak memory
    // which is allocated on the very first call to GetFormsTypeLibPath. Remove this 
    // block once the crt libraries are no longer linked in.

    DbgMemoryTrackDisable(TRUE);

    GetFormsTypeLibPath(ach);
#ifndef UNIX // UNIX can use the dll name to find out thd tlb file.
    pchName = _tcsrchr(ach, '.');
    Assert(pchName);
    _tcscpy(pchName + 1, _T("tlb"));
#endif
    hr = THR(LoadTypeLib(ach, ppTL));

    DbgMemoryTrackDisable(FALSE);

    if (hr)
        goto Cleanup;

    MtAdd(Mt(LoadTypeLib), +1, 0);

    // Cache the library if requested and if our DllThreadPassivate will
    // execute (since it is through DllThreadPassivate the library is released)
    // (Some code, such as class initialization code, may load the type library
    //  before any objects have been created)
    if (!fNoCache && GetPrimaryObjectCount())
    {
        pts->pTLCache = *ppTL;
        (*ppTL)->AddRef();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   DeinitTypeLibCache
//
//  Synopsis:   Release the forms type lib cache.
//
//----------------------------------------------------------------------------

void
DeinitTypeLibCache(THREADSTATE *pts)
{
    Assert(pts);
    ClearInterface(&pts->pTLCache);

    // There is a known bug in NT 4.0 versions prior to Service Pack 3
    // (build 1381) with freeing the typelib for OLEAUT.  We purposely leak
    // the typelib in this case.

    extern DWORD g_dwPlatformServicePack;

    if (    g_dwPlatformID != VER_PLATFORM_WIN32_NT
        ||  HIWORD(g_dwPlatformVersion) != 4
        ||  LOWORD(g_dwPlatformVersion) != 0
        ||  g_dwPlatformServicePack >= 3)
    {
        // release these here although created in a different path
        ClearInterface(&pts->pTypInfoStdOLECache);
        ClearInterface(&pts->pTypLibStdOLECache);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}
//+----------------------------------------------------------------------------
//
//  Function    :   ReadyStateInvoke
//
//  Synopsis    :   This helper function is called by the various invokes for 
//      those classes that support the ready state property. this centralizes the
//      logic and code for handling this case.
//
//  RETURNS :   S_OK,           readyState-get and no errors
//              E_INVALIDARG    readystate-get and errors
//              S_FALSE         not readystate-get
//
//-----------------------------------------------------------------------------

HRESULT
ReadyStateInvoke(DISPID dispid, 
                 WORD wFlags, 
                 long lReadyState, 
                 VARIANT * pvarResult)
{
    HRESULT hr = S_FALSE;

    if (dispid == DISPID_READYSTATE )
    {
        if (pvarResult && (wFlags & DISPATCH_PROPERTYGET))
        {
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = lReadyState;
            hr =  S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   DispatchGetTypeInfo
//
//  Synopsis:   GetTypeInfo helper.
//
//--------------------------------------------------------------------------

HRESULT
DispatchGetTypeInfo(REFIID riid, UINT itinfo, LCID lcid, ITypeInfo ** ppTI)
{
    HRESULT hr;

    Assert(ppTI);
    *ppTI = NULL;
    if (itinfo > 0)
        RRETURN(DISP_E_BADINDEX);

    hr = THR_NOTRACE(LoadF3TypeInfo(riid, ppTI));
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DispatchGetTypeInfoCount
//
//  Synopsis:   GetTypeInfoCount helper.
//
//--------------------------------------------------------------------------

HRESULT
DispatchGetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   DispatchGetIDsOfNames
//
//  Synopsis:   GetIDsOfNames helper.
//
//--------------------------------------------------------------------------

HRESULT
DispatchGetIDsOfNames(
        REFIID riidInterface,
        REFIID riid,
        OLECHAR ** rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID * rgdispid)
{
    HRESULT     hr;
    ITypeInfo * pTI;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    hr = DispatchGetTypeInfo(riidInterface, 0, lcid, &pTI);
    if (hr)
        RRETURN(hr);

    hr = pTI->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTI->Release();
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEventSink::GetTypeInfoCount
//
//  Synopsis:   Returns E_NOTIMPL.
//
//  History:    2-16-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEventSink::GetTypeInfoCount(unsigned int *)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBaseEventSink::GetTypeInfo
//
//  Synopsis:   Returns E_NOTIMPL
//
//  History:    2-16-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEventSink::GetTypeInfo(
    unsigned int,
    LCID,
    ITypeInfo FAR* FAR*)
{
    RRETURN(E_NOTIMPL);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEventSink::GetIDsOfNames
//
//  Synopsis:   Returns E_NOTIMPL.
//
//  History:    12-28-93   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEventSink::GetIDsOfNames(
    REFIID,
    OLECHAR FAR* FAR*,
    unsigned int,
    LCID,
    DISPID FAR*)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadF3TypeInfo
//
//  Synopsis:   Loads a typeinfo from the Forms3 type library.
//
//  Arguments:  [clsid] -- The clsid of the typeinfo to load.
//              [ppTI]  -- The resulting typeinfo.
//
//----------------------------------------------------------------------------

HRESULT
LoadF3TypeInfo(REFCLSID clsid, ITypeInfo ** ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    hr = THR(GetFormsTypeLib(&pTL));
    if (hr)
        RRETURN(hr);

    hr = THR_NOTRACE(pTL->GetTypeInfoOfGuid(clsid,ppTI));
    pTL->Release();

#if DBG == 1
    if (IsTagEnabled(tagLoadTypeInfo))
    {
        if (!*ppTI)
        {
            TraceTag((tagLoadTypeInfo,
                      "Unable to load Forms^3 typeinfo %hr.", hr));
        }
        else
        {
            BSTR    bstr = NULL;
            (void) (*ppTI)->GetDocumentation(
                    MEMBERID_NIL, &bstr, NULL, NULL, NULL);

            TraceTag((tagLoadTypeInfo, "Loaded typeinfo %ls.", STRVAL(bstr)));
            FormsFreeString(bstr);
        }
    }
#endif

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::CCreateTypeInfoHelper
//
//---------------------------------------------------------------------------

CCreateTypeInfoHelper::CCreateTypeInfoHelper()
{
    memset (this, 0, sizeof(*this));
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::~CCreateTypeInfoHelper
//
//---------------------------------------------------------------------------

CCreateTypeInfoHelper::~CCreateTypeInfoHelper()
{
    ReleaseInterface(pTypLib);
    ReleaseInterface(pTypLibStdOLE);
    ReleaseInterface(pTypInfoStdOLE);
    ReleaseInterface(pTypInfoCoClass);
    ReleaseInterface(pTypInfoCreate);
    ReleaseInterface(pTIOut);
    ReleaseInterface(pTICoClassOut);
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::Start
//
//---------------------------------------------------------------------------

HRESULT
CCreateTypeInfoHelper::Start(REFIID riid)
{
    static GUID guidStdOle = {0x00020430,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46};

    HRESULT         hr;
    THREADSTATE *   pts;

    hr = THR(CreateTypeLib2(SYS_WIN32, _T(""), &pTypLib));
    if (hr)
        goto Cleanup;

    //
    // Initialize the typlib with some of the usual defaults.
    //

    hr = THR(pTypLib->SetGuid(g_Zero.guid));
    if (hr)
        goto Cleanup;

    hr = THR(pTypLib->SetVersion(1, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pTypLib->SetName(_T("Page")));
    if (hr)
        goto Cleanup;

    hr = THR(pTypLib->SetLcid(LOCALE_SYSTEM_DEFAULT));
    if (hr)
        goto Cleanup;

    pts = GetThreadState();

    if (pts->pTypLibStdOLECache)
    {
        pTypLibStdOLE = pts->pTypLibStdOLECache;
        pTypInfoStdOLE = pts->pTypInfoStdOLECache;
    }
    else
    {
        //
        // Get Information on the standard OLE IDispatch
        //

        hr = THR(LoadRegTypeLib(
            guidStdOle,
            STDOLE_MAJORVERNUM,
            STDOLE_MINORVERNUM,
            STDOLE_LCID,
            &pTypLibStdOLE));
        if (hr)
            goto Cleanup;

        hr = THR(pTypLibStdOLE->GetTypeInfoOfGuid(IID_IDispatch, &pTypInfoStdOLE));
        if (hr) 
            goto Cleanup;

        pts->pTypLibStdOLECache = pTypLibStdOLE;
        pts->pTypInfoStdOLECache = pTypInfoStdOLE;
    }
    pTypLibStdOLE->AddRef();
    pTypInfoStdOLE->AddRef();

    //
    // Now create the typeInfo for the objects.
    //

    hr = THR(pTypLib->CreateTypeInfo(_T("PageProps"), TKIND_DISPATCH, &pTypInfoCreate));
    if (hr)
        goto Cleanup;

    //
    // Again perform the standard initialization on the typeinfo.
    //

    hr = THR(pTypInfoCreate->SetGuid(riid));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->SetVersion(1, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->AddRefTypeInfo(pTypInfoStdOLE, &hreftype));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->AddImplType(0, hreftype));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::Finalize
//
//---------------------------------------------------------------------------

HRESULT
CCreateTypeInfoHelper::Finalize(LONG lImplTypeFlags)
{
    HRESULT hr;

    //
    // Finish off the type info.
    //

    hr = THR(pTypInfoCreate->LayOut());
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->QueryInterface(
        IID_ITypeInfo,
        (void **)&pTIOut));
    if (hr)
        goto Cleanup;

    //
    // Now we have to create a coclass for the interface
    //

    hr = THR(pTypLib->CreateTypeInfo(_T("Page"), TKIND_COCLASS, &pTypInfoCoClass));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->SetGuid(g_Zero.guid));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->SetVersion(1, 0));
    if (hr)
        goto Cleanup;

    // Add the Page Property dispinterface to coclass
    hr = THR(pTypInfoCoClass->AddRefTypeInfo(pTIOut, &hreftype));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->AddImplType(0, hreftype));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->SetImplTypeFlags(0, lImplTypeFlags));
    if (hr)
        goto Cleanup;

    //
    // Finish off the CoClass
    hr = THR(pTypInfoCoClass->LayOut());
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->QueryInterface(
        IID_ITypeInfo,
        (void **)&pTICoClassOut));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\errinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       errinfo.cxx
//
//  Contents:   CErrorInfo
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

const CLSID CLSID_CErrorInfo = { 0x44102920, 0xD5AA, 0x11ce, 0xB6, 0x56, 0x00, 0xAA, 0x00, 0x4C, 0xD6, 0xD8 };

extern HRESULT GetSolutionText(HRESULT hrError, LPTSTR pstr, int cch);

MtDefine(CErrorInfo, ObjectModel, "CErrorInfo")

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::CErrorInfo
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------

CErrorInfo::CErrorInfo()
{
    _ulRefs = 1;
    IncrementSecondaryObjectCount( 2 );
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::~CErrorInfo
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CErrorInfo::~CErrorInfo()
{
    int c;
    TCHAR **ppch;

    for (ppch = _apch, c = EPART_LAST; c > 0; ppch++, c--)
    {
        delete *ppch;
    }

    DecrementSecondaryObjectCount( 2 );
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::QueryInterface, IUnknown
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IErrorInfo ||
        iid == IID_IUnknown)
    {
        *ppv = (IErrorInfo *)this;
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else if (iid == CLSID_CErrorInfo)
    {
        *ppv = this;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::SetTextV/SetText
//
//  Synopsis:   Set text of error description.
//
//  Arguments:  epart   Part of error message, taken from EPART enum.
//              ids     String id of format string.
//              pvArgs  Arguments
//
//----------------------------------------------------------------------------

void
CErrorInfo::SetTextV(EPART epart, UINT ids, void *pvArgs)
{
    if (_apch[epart])
    {
        delete _apch[epart];
        _apch[epart] = NULL;
    }

    IGNORE_HR(VFormat(
            FMT_OUT_ALLOC, 
            &_apch[epart], 
            0, 
            MAKEINTRESOURCE(ids),
            pvArgs));
}

void __cdecl
CErrorInfo::SetText(EPART epart, UINT ids, ...)
{
    va_list arg;

    va_start(arg, ids);
    SetTextV(epart, ids, &arg);
    va_end(arg);    
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetGUID, IErrorInfo
//
//  Synopsis:   Return iid of interface defining error code.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetGUID(GUID *pguid)
{
    // Assume OS defined errors only.
    *pguid = g_Zero.clsid;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetSource, IErrorInfo
//
//  Synopsis:   Get progid of error source.
//
//----------------------------------------------------------------------------

extern "C" CLSID CLSID_CCDControl;

HRESULT
CErrorInfo::GetSource(BSTR *pbstrSource)
{
    HRESULT hr; 
    OLECHAR * pstrProgID = NULL;

    *pbstrSource = 0;
    if (_clsidSource == g_Zero.clsid)
        RRETURN(E_FAIL);

    hr = THR(ProgIDFromCLSID(_clsidSource, &pstrProgID));
    if (hr)
        goto Cleanup;

    hr = THR(FormsAllocString(pstrProgID, pbstrSource));

Cleanup:

    CoTaskMemFree(pstrProgID);
    RRETURN(hr);
}
        
//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetHelpFile, IErrorInfo
//
//  Synopsis:   Get help file describing error.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetHelpFile(BSTR *pbstrHelpFile)
{
    RRETURN(THR(FormsAllocString(GetFormsHelpFile(), pbstrHelpFile)));
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetHelpContext, IErrorInfo
//
//  Synopsis:   Get help context describing error.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetHelpContext(DWORD *pdwHelpContext)
{
    *pdwHelpContext = _dwHelpContext;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetDescription, IErrorInfo
//
//  Synopsis:   Get description of the error.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetDescription(BSTR *pbstrDescription)
{
    HRESULT hr;
    BSTR    bstrSolution = NULL;
    BSTR    bstrDescription = NULL;

    hr = THR(GetDescriptionEx(&bstrDescription, &bstrSolution));
    if (hr)
        goto Cleanup;

    if (bstrDescription && bstrSolution)
    {
        hr = THR(FormsAllocStringLen(
                (LPCTSTR)NULL, 
                FormsStringLen(bstrDescription) + 2 + FormsStringLen(bstrSolution),
                pbstrDescription));
        if (hr)
            goto Cleanup;

        _tcscpy(*pbstrDescription, bstrDescription);
        _tcscat(*pbstrDescription, TEXT("  "));         //  Review: FE grammar?
        _tcscat(*pbstrDescription, bstrSolution);
    }
    else
    {
        *pbstrDescription = bstrDescription;
        bstrDescription = NULL;
    }

Cleanup:
    FormsFreeString(bstrDescription);
    FormsFreeString(bstrSolution);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetMemberName
//
//  Synopsis:   Get name of member _dispidInvoke in interface _iidInvoke.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetMemberName(BSTR *pbstrName)
{
    HRESULT hr;
    ITypeInfo *pTI = NULL;

    hr = THR(LoadF3TypeInfo(_iidInvoke, &pTI));
    if (hr)
        goto Cleanup;

    hr = THR(pTI->GetDocumentation(_dispidInvoke, pbstrName, NULL, NULL, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pTI);
    RRETURN(hr);
   
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetDescriptionEx, IErrorInfo2
//
//  Synopsis:   
//
//  Arguments:  
//
//----------------------------------------------------------------------------

HRESULT 
CErrorInfo::GetDescriptionEx(
    BSTR *pbstrDescription,
    BSTR *pbstrSolution)
{
    HRESULT hr = S_OK;
    TCHAR   achBufAction[FORMS_BUFLEN];
    TCHAR   achBufError[FORMS_BUFLEN];
    TCHAR   achBufSolution[FORMS_BUFLEN];
    TCHAR * pchAction;
    TCHAR * pchError;
    TCHAR * pchSolution;
    BSTR    bstrMemberName = NULL;

    *pbstrDescription = NULL;
    *pbstrSolution = NULL;

    if (_apch[EPART_ACTION])
    {
        pchAction = _apch[EPART_ACTION];
    }
    else if (_invkind == INVOKE_PROPERTYPUT &&
            _hr == E_INVALIDARG)
    {
        pchAction = NULL;
    }
    else if (_invkind)
    {
        hr = THR(GetMemberName(&bstrMemberName));
        if (hr)
            goto Error;

        hr = THR(Format(
                0, 
                achBufAction, 
                ARRAY_SIZE(achBufAction),
                _invkind == INVOKE_PROPERTYPUT ? 
                    MAKEINTRESOURCE(IDS_EA_SETTING_PROPERTY) :
                (_invkind == INVOKE_PROPERTYGET ? 
                    MAKEINTRESOURCE(IDS_EA_GETTING_PROPERTY) :
                    MAKEINTRESOURCE(IDS_EA_CALLING_METHOD)),
                bstrMemberName));
        if (hr)
            goto Error;
        
        pchAction = achBufAction;
    }
    else
    {
        pchAction = NULL;
    }

    if (_apch[EPART_ERROR])
    {
        pchError = _apch[EPART_ERROR];
    }
    else if (_invkind == INVOKE_PROPERTYPUT && 
            _hr == E_INVALIDARG)
    {
        hr = THR(GetMemberName(&bstrMemberName));
        if (hr)
            goto Error;

        hr = THR(Format(
                0, 
                achBufError, 
                ARRAY_SIZE(achBufError),
                MAKEINTRESOURCE(IDS_EE_INVALID_PROPERTY_VALUE),
                bstrMemberName));
        if (hr)
            goto Error;

        pchError = achBufError;
    }
    else
    {
        hr = THR(GetErrorText(_hr, achBufError, ARRAY_SIZE(achBufError)));
        if (hr)
            goto Error;

        pchError = achBufError;
    }

    if (pchAction)
    {
        hr = FormsAllocStringLen(
                pchAction,
                _tcslen(pchAction) + _tcslen(pchError) + 2,
                pbstrDescription);
        if (!*pbstrDescription)
            goto MemoryError;
        _tcscat(*pbstrDescription, TEXT(" "));
        _tcscat(*pbstrDescription, pchError);
    }
    else
    {
        hr = FormsAllocString(pchError,pbstrDescription);
        if (!*pbstrDescription)
            goto MemoryError;
    }

    if (_apch[EPART_SOLUTION])
    {
        pchSolution = _apch[EPART_SOLUTION];
    }
    else
    {
        hr = THR(GetSolutionText(_hr, achBufSolution, ARRAY_SIZE(achBufSolution)));
        if (hr)
            goto Error;

        pchSolution = achBufSolution[0] ? achBufSolution : NULL;
    }

    hr = THR(FormsAllocString(pchSolution, pbstrSolution));
    if (hr)
        goto Error;

Cleanup:
    SysFreeString(bstrMemberName);
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    SysFreeString(*pbstrDescription);
    SysFreeString(*pbstrSolution);
    *pbstrDescription = NULL;
    *pbstrSolution = NULL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorInfo
//
//----------------------------------------------------------------------------

CErrorInfo * 
GetErrorInfo()
{
    THREADSTATE *   pts = GetThreadState();

    if (!pts->pEI)
    {
        pts->pEI = new CErrorInfo;
    }

    return pts->pEI;
}

//+---------------------------------------------------------------------------
//
//  Function:   ClearErrorInfo
//
//----------------------------------------------------------------------------

void         
ClearErrorInfo(
    THREADSTATE *   pts)
{
    if (!pts)
        pts = GetThreadState();
    ClearInterface(&(pts->pEI));
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseErrorInfo
//
//----------------------------------------------------------------------------

void
CloseErrorInfo(HRESULT hr, REFCLSID clsidSource)
{
    IErrorInfo *    pErrorInfo;

    Assert(FAILED(hr));
  
    if (GetErrorInfo() == NULL)
    {
        // There's an error, but we couldn't allocate
        // an error info object.  Release the global error
        // object so that our caller's caller will
        // not be confused.

        hr = GetErrorInfo(0, &pErrorInfo);
        if (!hr)
        {
            ReleaseInterface(pErrorInfo);
        }
    }
    else
    {
        THREADSTATE *   pts = GetThreadState();
        pts->pEI->_hr = hr;
        pts->pEI->_clsidSource = clsidSource;
        SetErrorInfo(NULL, pts->pEI);

        ClearInterface(&(pts->pEI));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PutErrorInfoText
//
//----------------------------------------------------------------------------

void
__cdecl PutErrorInfoText(EPART epart, UINT ids, ...)
{
    va_list arg;

    if (GetErrorInfo() != NULL)
    {
        va_start(arg, ids);
        TLS(pEI)->SetTextV(epart, ids, &arg);
        va_end(arg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\errtbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       errtbl.cxx
//
//  Contents:   Error table for GetErrorText
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include "olectl.h"
#endif

//
// Each entry in the table has the following format:
//     StartError, NumberOfErrorsToMap, ErrorMessageResourceID
//
// The last entry must be all 0s.
//

struct ERRTOMSG
{
    SCODE   error;                      // the starting error code
    USHORT  cErrors;                    // number of errors in range to map
    USHORT  ids;                        // the error msg string id
};

//
// Disable warning: Truncation of constant value.  There is
// no way to specify a short integer constant.
//

#pragma warning(disable:4305 4309)

const ERRTOMSG g_aetmError[] =
{
#ifdef PRODUCT_97
    FORMS_E_NOPAGESSPECIFIED,   1,  IDS_E_NOPAGESSPECIFIED,
    FORMS_E_NOPAGESINTERSECT,   1,  IDS_E_NOPAGESINTERSECT,
#endif
    E_UNEXPECTED,               1,  IDS_EE_UNEXPECTED,
    E_FAIL,                     1,  IDS_EE_FAIL,
    E_INVALIDARG,               1,  IDS_EE_INVALIDARG,
    CTL_E_CANTMOVEFOCUSTOCTRL,          1,  IDS_EE_CANTMOVEFOCUSTOCTRL,
    CTL_E_CONTROLNEEDSFOCUS,            1,  IDS_EE_CONTROLNEEDSFOCUS,
    CTL_E_INVALIDPICTURE,               1,  IDS_EE_INVALIDPICTURE,
    CTL_E_INVALIDPICTURETYPE,           1,  IDS_EE_INVALIDPICTURETYPE,
    CTL_E_INVALIDPROPERTYARRAYINDEX,    1,  IDS_EE_INVALIDPROPERTYARRAYINDEX,
    CTL_E_INVALIDPROPERTYVALUE,         1,  IDS_EE_INVALIDPROPERTYVALUE,
    CTL_E_METHODNOTAPPLICABLE,          1,  IDS_EE_METHODNOTAPPLICABLE,
    CTL_E_OVERFLOW,                     1,  IDS_EE_OVERFLOW,
    CTL_E_PERMISSIONDENIED,             1,  IDS_EE_PERMISSIONDENIED,
    CTL_E_SETNOTSUPPORTEDATRUNTIME,     1,  IDS_EE_SETNOTSUPPORTEDATRUNTIME,
    CTL_E_INVALIDPASTETARGET,           1,  IDS_EE_INVALIDPASTETARGET,
    CTL_E_INVALIDPASTESOURCE,           1,  IDS_EE_INVALIDPASTESOURCE,
    CTL_E_MISMATCHEDTAG,                1,  IDS_EE_MISMATCHEDTAG,
    CTL_E_INCOMPATIBLEPOINTERS,         1,  IDS_EE_INCOMPATIBLEPOINTERS,
    CTL_E_UNPOSITIONEDPOINTER,          1,  IDS_EE_UNPOSITIONEDPOINTER,
    CTL_E_UNPOSITIONEDELEMENT,          1,  IDS_EE_UNPOSITIONEDELEMENT,
    CLASS_E_NOTLICENSED,                1,  IDS_EE_NOTLICENSED,
    MSOCMDERR_E_NOTSUPPORTED,           1,  IDS_E_CMDNOTSUPPORTED,
    HRESULT_FROM_WIN32(ERROR_INTERNET_INVALID_URL),       1, IDS_EE_INTERNET_INVALID_URL,
    HRESULT_FROM_WIN32(ERROR_INTERNET_NAME_NOT_RESOLVED), 1, IDS_EE_INTERNET_NAME_NOT_RESOLVED,
    // Terminate table with nulls.
    0,                          0,  0,
};

const ERRTOMSG g_aetmSolution[] =
{

    // Terminate table with nulls.
    0,                          0,  0,
};


#pragma warning(default:4305 4309)

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorText
//
//  Synopsis:   Gets the text of an error from a message resource.
//
//  Arguments:  [hr]   --   The error.  Must not be 0.
//              [pstr] --   Buffer for the message.
//              [cch]  --   Size of the buffer in characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [*pstr]
//
//----------------------------------------------------------------------------

HRESULT
GetErrorText(HRESULT hrError, LPTSTR pstr, int cch)
{
    HRESULT     hr  = S_OK;
    const ERRTOMSG * petm;
    DWORD       dwFlags;
    LPCVOID     pvSource;
    BOOL        fHrCode = FALSE;
    

    Assert(pstr);
    Assert(cch >= 0);

    //
    // Check if we handle the message in our table.
    //

    for (petm = g_aetmError; petm->error; petm++)
    {
        if (petm->error <= hrError && hrError < petm->error + petm->cErrors)
        {


            if (!LoadString(GetResourceHInst(), petm->ids, pstr, cch))
                RRETURN(GetLastWin32Error());

            return S_OK;
        }
    }

    //
    // Check the system for the message.
    //

    if (hrError >= HRESULT_FROM_WIN32(INTERNET_ERROR_BASE) &&
        hrError <= HRESULT_FROM_WIN32(INTERNET_ERROR_LAST))
    {
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS;
        pvSource = GetModuleHandleA("wininet.dll");
        fHrCode = TRUE;
    }
    else if (hrError >= INET_E_ERROR_FIRST && hrError <= INET_E_ERROR_LAST)
    {
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS;
        pvSource = GetModuleHandleA("urlmon.dll");
    }
    else
    {
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;
        pvSource = NULL;
    }

    if (FormatMessage(
            dwFlags,
            pvSource,
            fHrCode ? HRESULT_CODE(hrError) : hrError,
            LANG_SYSTEM_DEFAULT,
            pstr,
            cch,
            NULL))
    {
        return S_OK;
    }

    //
    // Show the error string and the hex code.
    //

    hr = Format(0, pstr, cch, MAKEINTRESOURCE(IDS_UNKNOWN_ERROR), hrError);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSolutionText
//
//  Synopsis:   Gets the text of an error from a message resource.
//
//  Arguments:  [hr]   --   The error.  Must not be 0.
//              [pstr] --   Buffer for the message.
//              [cch]  --   Size of the buffer in characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [*pstr]
//
//----------------------------------------------------------------------------

HRESULT
GetSolutionText(HRESULT hrError, LPTSTR pstr, int cch)
{
    const ERRTOMSG *  petm;

    Assert(pstr);
    Assert(cch >= 0);

    //
    // Check if we handle the message in our table.
    //

    for (petm = g_aetmSolution; petm->error; petm++)
    {
        if (petm->error <= hrError && hrError < petm->error + petm->cErrors)
        {


            if (!LoadString(GetResourceHInst(), petm->ids, pstr, cch))
                RRETURN(GetLastWin32Error());

            return S_OK;
        }
    }

    *pstr = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\fatstg.cxx ===
//+---------------------------------------------------------------------
//
//  File:       fatstg.hxx
//
//  Contents:   IStream on top of a DOS (non-docfile) file
//
//	History:	
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//REVIEW: this file is substantially incomplete!
//REVIEW: this will either be completed or (hopefully) replaced!

//+---------------------------------------------------------------
//
//  Class:      FatStream
//
//  Purpose:    Provide an IStream interface to a DOS file
//
//---------------------------------------------------------------

MtDefine(FatStream, Utilities, "FatStream")

class FatStream: public IStream
{
    friend HRESULT CreateStreamOnFile(LPCTSTR, DWORD, LPSTREAM * ppstrm);
    friend HRESULT CloseStreamOnFile(LPSTREAM pStm);

public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(FatStream))
    DECLARE_FORMS_STANDARD_IUNKNOWN(FatStream);

    // *** IStream methods ***
    STDMETHOD(Read) (VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead);
    STDMETHOD(Write) (VOID const HUGEP *pv, ULONG cb, ULONG FAR *pcbWritten);
    STDMETHOD(Seek) (LARGE_INTEGER dlibMove, DWORD dwOrigin,
                                    ULARGE_INTEGER FAR *plibNewPosition);
    STDMETHOD(SetSize) (ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (IStream FAR *pstm, ULARGE_INTEGER cb,
                ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten);
    STDMETHOD(Commit) (DWORD grfCommitFlags);
    STDMETHOD(Revert) (void);
    STDMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                                                            DWORD dwLockType);
    STDMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                                                            DWORD dwLockType);
    STDMETHOD(Stat) (STATSTG FAR *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream FAR * FAR *ppstm);

private:
    FatStream()
        { _ulRefs = 1; _hfile = INVALID_HANDLE_VALUE; }
    ~FatStream();

    HRESULT Init(HANDLE hfile, LPCTSTR pchFile);

    HANDLE  _hfile;
    CStr    _cstrFileName;
};

inline 
FatStream::~FatStream()
{
    if (_hfile != INVALID_HANDLE_VALUE)
        CloseHandle(_hfile); 

    if (_cstrFileName.Length()) 
        DeleteFile(_cstrFileName);
}

//+---------------------------------------------------------------
//
//  Function:   CreateStreamOnFile, public
//
//  Synopsis:   Provides an IStream interface to a DOS file
//
//  Arguments:  [pchFile] -- the DOS file
//              [dwDesiredAccess] -- see CreateFile
//              [dwShareMode] -- see CreateFile
//              [dwCreationDistribution] -- see CreateFile
//              [ppstrm] -- where the opened stream is returned
//
//  Returns:    Success iff the stream interface could be provided
//
//----------------------------------------------------------------

HRESULT
CreateStreamOnFile(LPCTSTR pchFile, DWORD dwSTGM, LPSTREAM * ppstrm)
{
    DWORD       dwDesiredAccess = 0;
    DWORD       dwShareMode = 0;
    DWORD       dwCreationDistribution = 0;
    HANDLE      hfile;
    FatStream * pStmFat = NULL;
    HRESULT     hr = S_OK;

    Assert(pchFile != NULL && _tcsclen(pchFile) != 0);

    if (dwSTGM & STGM_READWRITE)
        dwDesiredAccess |= (GENERIC_READ|GENERIC_WRITE);
    else if (dwSTGM & STGM_WRITE)
        dwDesiredAccess |= GENERIC_WRITE;
    else
        dwDesiredAccess |= GENERIC_READ;

    if (dwSTGM & STGM_SHARE_DENY_NONE)
        dwShareMode |= (FILE_SHARE_READ|FILE_SHARE_WRITE);
    else if (dwSTGM & STGM_SHARE_DENY_WRITE)
        dwShareMode |= FILE_SHARE_READ;
    else if (dwSTGM & STGM_SHARE_DENY_READ)
        dwShareMode |= FILE_SHARE_WRITE;

    if (dwSTGM & STGM_CREATE)
        dwCreationDistribution |= CREATE_ALWAYS;
    else
        dwCreationDistribution |= OPEN_EXISTING;

    hfile = CreateFile(
            pchFile,
            dwDesiredAccess,
            dwShareMode,
            NULL,
            dwCreationDistribution,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hfile==INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    pStmFat = new FatStream();
    if (!pStmFat)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pStmFat->Init(
            hfile,
            dwSTGM & STGM_DELETEONRELEASE ? pchFile : NULL));
    if (hr)
        goto Error;

    *ppstrm = pStmFat;

Cleanup:
    RRETURN(hr);

Error:
    delete pStmFat;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     FatStream::Init
//
//  Synopsis:   Initialize the class.
//
//----------------------------------------------------------------

HRESULT
FatStream::Init(HANDLE hfile, LPCTSTR pchFile)
{
    HRESULT hr = S_OK;

    _hfile = hfile;

    if (pchFile)
        hr = THR(_cstrFileName.Set(pchFile));

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     FatStream::QueryInterface
//
//  Synopsis:   method from IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IStream)
    {
        *ppv = (IStream *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown FAR*) *ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     FatStream::Read
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Read(VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    ULONG   cbTemp;
    
    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    RRETURN(ReadFile(
        _hfile,
        pv,
        cb,
        pcbRead ? pcbRead : &cbTemp,
        NULL) ? S_OK : GetLastWin32Error());
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Write
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Write(VOID const HUGEP *pv,
        ULONG cb,
        ULONG FAR *pcbWritten)
{
    BOOL    fSuccess;
    DWORD   cbWritten;

    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    fSuccess = WriteFile(_hfile, pv, (DWORD) cb, &cbWritten, NULL);
    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

    RRETURN(fSuccess ? S_OK : GetLastWin32Error());
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Seek
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Seek(LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER FAR *plibNewPosition)
{
    DWORD   newpos;

    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    if (dlibMove.HighPart != 0 && dlibMove.HighPart != -1)
        RRETURN(E_FAIL);

    newpos = SetFilePointer(_hfile, (LONG) dlibMove.LowPart, NULL, (int) dwOrigin);

    if (plibNewPosition != NULL)
        ULISet32(*plibNewPosition, (LONG) newpos);

    RRETURN(newpos == -1 ? E_FAIL : S_OK);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::SetSize
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::SetSize(ULARGE_INTEGER libNewSize)
{
    DWORD   newpos;

    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    if (libNewSize.HighPart != 0)
        RRETURN(E_FAIL);

    newpos = SetFilePointer(_hfile, (LONG) libNewSize.LowPart, NULL, FILE_BEGIN);
    if (newpos == -1)
        RRETURN(GetLastWin32Error());

    if (!SetEndOfFile(_hfile))
        RRETURN(GetLastWin32Error());

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::CopyTo
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::CopyTo(IStream FAR *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER FAR *pcbRead,
        ULARGE_INTEGER FAR *pcbWritten)
{
    DWORDLONG   cbRequest = *(LONGLONG *) &cb;
    DWORDLONG   cbActual = 0;
    HRESULT     hr = S_OK;

    if (_hfile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    while (cbRequest)
    {
        BYTE    buf[4096];
        ULONG   cbAttempt = min(cbRequest, (DWORDLONG) sizeof(buf));
        ULONG   cbRead;

        hr = THR(Read(buf, cbAttempt, &cbRead));
        if (hr)
            goto Cleanup;

        hr = THR(pstm->Write(buf, cbRead, NULL));
        if (hr)
            goto Cleanup;

        cbActual += cbRead;
        cbRequest -= cbRead;

        if (cbAttempt > cbRead)
            break;
    }

    if (pcbRead)
        *pcbRead = *(ULARGE_INTEGER *) &cbActual;
    if (pcbWritten)
        *pcbWritten = *(ULARGE_INTEGER *) &cbActual;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Commit
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Commit(DWORD grfCommitFlags)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Revert
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Revert(void)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::LockRegion
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::LockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::UnlockRegion
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP FatStream::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Stat
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    HRESULT     hr = S_OK;

    if (_hfile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (pstatstg != NULL)
    {
        pstatstg->pwcsName = NULL;
        if (grfStatFlag != STATFLAG_NONAME) // if (grfStatFlag == STATFLAG_DEFAULT)
        {
            int cchFileName = _cstrFileName.Length();
            if (cchFileName)
            {
                pstatstg->pwcsName = (LPOLESTR) CoTaskMemAlloc (sizeof(TCHAR) * (cchFileName + 1));
                if (!pstatstg->pwcsName)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                _tcscpy(pstatstg->pwcsName, _cstrFileName);
            }
        }

        pstatstg->type = STGTY_STREAM;
        ULISet32(pstatstg->cbSize,(LONG) GetFileSize(_hfile, NULL));
        //pstatstg->mtime = fstatus.m_mtime;
        //pstatstg->ctime = fstatus.m_ctime;
        //pstatstg->atime = fstatus.m_atime;
        //pstatstg->grfMode = ;
        pstatstg->grfLocksSupported = 0;     // no locking supported
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Clone
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Clone(IStream FAR * FAR *ppstm)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CloseStreamOnFile(LPSTREAM pStm)
{
    HRESULT hr = S_OK;
    FatStream *pStmFat = DYNCAST(FatStream, pStm);

    if (pStmFat->_hfile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!CloseHandle(pStmFat->_hfile))
        hr = GetLastWin32Error();

    pStmFat->_hfile = INVALID_HANDLE_VALUE;

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\dvutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       dvutils.cxx
//
//  Contents:   Helper functions for implementing IDataObject and IViewObject
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//
//  Globals
//


// Names used to register the standard clipboard formats
//  Localization: Do not localize
static const char * const s_apstrClipName[] =
{
    "Embedded Object",
    "Embed Source",
    "Link Source",
    "Link Source Descriptor",
    "Object Descriptor",
    "MS Forms CLSID",
    "MS Forms Text",
};
// Array of common registered clip formats used in Forms^3
CLIPFORMAT g_acfCommon[ARRAY_SIZE(s_apstrClipName)];

HRESULT
CloneStgMedium(const STGMEDIUM *    pcstgmedSrc,
               STGMEDIUM *          pstgmedDest)
{
    HRESULT         hr;
    void *          pvDest;
    const void *    pcvSrc;
    DWORD           dwcbLen;
    HGLOBAL         hGlobalDest;

    memset(pstgmedDest, 0, sizeof(*pstgmedDest));

    // We only understand how to clone TYMED_HGLOBAL.
    if (pcstgmedSrc->tymed != TYMED_HGLOBAL)
    {
        hr = DV_E_TYMED;
        goto Cleanup;
    }

    hr = E_OUTOFMEMORY;
    pcvSrc = GlobalLock(pcstgmedSrc->hGlobal);
    if (!pcvSrc)
        goto Cleanup;


    dwcbLen = GlobalSize(pcstgmedSrc->hGlobal);
    if (dwcbLen == 0)
    {
        GlobalUnlock(pcstgmedSrc->hGlobal);
        goto Cleanup;
    }
    
    hGlobalDest = GlobalAlloc((GMEM_MOVEABLE | GMEM_SHARE), dwcbLen);
    if (!hGlobalDest)
    {
        GlobalUnlock(pcstgmedSrc->hGlobal);
        goto Cleanup;
    }


    pvDest = GlobalLock(hGlobalDest);
    if (!pvDest)
    {
        GlobalFree(hGlobalDest);
        GlobalUnlock(pcstgmedSrc->hGlobal);
        goto Cleanup;
    }

    memcpy(pvDest, pcvSrc, dwcbLen);

    pstgmedDest->tymed = TYMED_HGLOBAL;
    pstgmedDest->hGlobal = hGlobalDest;
    pstgmedDest->pUnkForRelease = pcstgmedSrc->pUnkForRelease;
    if (pstgmedDest->pUnkForRelease)
        (pstgmedDest->pUnkForRelease)->AddRef();

    GlobalUnlock(hGlobalDest);
    GlobalUnlock(pcstgmedSrc->hGlobal);
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


BOOL
DVTARGETDEVICEMatchesRequest(const DVTARGETDEVICE * pcdvtdRequest,
                             const DVTARGETDEVICE * pcdvtdActual)
{
    BOOL bMatch;

    /*
    * A NULL requested PCDVTARGETDEVICE matches any NULL or non-NULL actual
    * PCDVTARGETDEVICE.
    *
    * Any non-NULL requested PCDVTARGETDEVICE matches any NULL actual
    * PCDVTARGETDEVICE.
    *
    * A non-NULL requested PCDVTARGETDEVICE only matches a non-NULL actual
    * PCDVTARGETDEVICE if the actual CDVTARGETDEVICE is an exact binary copy of
    * the requested CDVTARGETDEVICE.
    */

    if (pcdvtdRequest && pcdvtdActual)
        bMatch = (memcmp(pcdvtdRequest, pcdvtdActual,
                         min(pcdvtdRequest->tdSize, pcdvtdActual->tdSize))
                  == 0);
    else
        bMatch = TRUE;

    return(bMatch);
}


BOOL
TYMEDMatchesRequest(TYMED tymedRequest, TYMED tymedActual)
{
    // The actual TYMED matches the requested TYMED if they have any flags set
    // in common.
    return(tymedRequest & tymedActual);
}


BOOL
FORMATETCMatchesRequest(const FORMATETC *   pcfmtetcRequest,
                        const FORMATETC *   pcfmtetcActual)
{
    // Don't check lindex. Strictly speaking, it should be ignored only
    // for DVASPECT_ICON and DVASPECT_THUMBNAIL, but our clients (notably
    // Athena) usually set it to 0 instead of the correct default -1.
    return(pcfmtetcRequest->cfFormat == pcfmtetcActual->cfFormat &&
           DVTARGETDEVICEMatchesRequest(pcfmtetcRequest->ptd,
                                        pcfmtetcActual->ptd) &&
           pcfmtetcRequest->dwAspect == pcfmtetcActual->dwAspect &&
           TYMEDMatchesRequest((TYMED)(pcfmtetcRequest->tymed),
                               (TYMED)(pcfmtetcActual->tymed)));
}


//+---------------------------------------------------------------
//
//  Function:   RegisterClipFormats
//
//  Synopsis:   Initialize g_acfCommon, an array of common
//              registered clip formats used in Forms^3.
//              This array is indexed by the ICF_xxx enumeration.
//
//----------------------------------------------------------------

void
RegisterClipFormats()
{
    // Mac note: clipboard formats need not be registered because we are using
    //          Mac OLE instead of WLM OLE; Mac OLE uses a 4 character ID
    int i;

    for (i = 0; i < ARRAY_SIZE(g_acfCommon); i++)
    {
        g_acfCommon[i] = (CLIPFORMAT)
                RegisterClipboardFormatA(s_apstrClipName[i]);
    }
}

//+---------------------------------------------------------------
//
//  Function:   SetCommonClipFormats
//
//  Synopsis:   Set FORMATETC::cfFormat initialzed by CF_COMMON()
//              macro to the true registered clip format.
//
//  Arguments:  pfmtetc Array of to modify
//              cfmtetc Number of elements in the array
//
//----------------------------------------------------------------

void
SetCommonClipFormats(FORMATETC *pfmtetc, int cfmtetc)
{
    for (; cfmtetc > 0; pfmtetc++, cfmtetc--)
    {
        if (pfmtetc->cfFormat >= CF_PRIVATEFIRST &&
            pfmtetc->cfFormat <= CF_PRIVATELAST)
        {
            Assert(pfmtetc->cfFormat - CF_PRIVATEFIRST < ARRAY_SIZE(g_acfCommon));
            pfmtetc->cfFormat = g_acfCommon[pfmtetc->cfFormat - CF_PRIVATEFIRST];
        }
    }
}

//+---------------------------------------------------------------
//
//  Function:   FindCompatibleFormat
//
//  Synopsis:   Searches a table of FORMATETC structures and
//              returns the index of the first entry that is
//              compatible with a specified FORMATETC.
//
//  Arguments:  [FmtTable] -- the table of FORMATETCs
//              [iSize] -- the number of entries in the format table
//              [formatetc] -- the FORMATETC we are comparing for compatibility
//
//  Returns:    The index into the table of the compatible format, or
//              -1 if no compatible format was found.
//
//  Notes:      This function is typically used in conjunction with
//              IDataObject methods that need to check if a requested format
//              is available.
//
//----------------------------------------------------------------

int
FindCompatibleFormat(const FORMATETC * FmtTable, int iSize, const FORMATETC& formatetc)
{
    // look through the table for a compatible format
    for (int i = 0; i < iSize; i++)
    {
        if (FORMATETCMatchesRequest(&formatetc, &FmtTable[i]))
            return i;
    }
    return -1;
}


//+---------------------------------------------------------------
//
//  Function:   GetObjectDescriptor
//
//  Synopsis:   Extracts an OBJECTDESCRIPTOR from an IDataObject,
//              if available.
//
//  Arguments:  [pDataObj] -- data object from which to extract an object descriptor
//              [pDescOut] -- object descriptor structure to fill in
//
//  Returns:    Success iff the object descriptor could be extracted.
//              This does not copy out the dwFullUserTypeName or
//              dwSrcOfCopy strings.
//
//
//  Attention: most containers (like Excel) do not support GetDataHere
//             therefore we use GetData (frankman, Bug 5889)
//
//----------------------------------------------------------------

HRESULT
GetObjectDescriptor(LPDATAOBJECT pDataObj, LPOBJECTDESCRIPTOR pDescOut)
{
    HRESULT r;
    FORMATETC formatetc =
        { g_acfCommon[ICF_OBJECTDESCRIPTOR],
            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    STGMEDIUM stgmedium;
    stgmedium.tymed = TYMED_HGLOBAL;
    stgmedium.hGlobal = 0;
    stgmedium.pUnkForRelease = NULL;

    if (OK(r = pDataObj->GetData(&formatetc, &stgmedium)))
    {
        if (pDescOut != NULL)
        {
            LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(stgmedium.hGlobal);
            if (pObjDesc == NULL)
            {
                r = E_OUTOFMEMORY;
            }
            else
            {
                // note: in the future we may wish to copy out the strings
                // into two out parameters.  This would be used in
                // implementing the Paste Special dialog box.
                *pDescOut = *pObjDesc;
                pDescOut->dwFullUserTypeName = 0;
                pDescOut->dwSrcOfCopy = 0;
                GlobalUnlock(stgmedium.hGlobal);
            }
        }
    }
    ReleaseStgMedium(&stgmedium);
    RRETURN(r);
}

//+---------------------------------------------------------------
//
//  Function:   UpdateObjectDescriptor
//
//  Synopsis:   Updates the pointl and dwDrawAspects of an OBJECTDESCRIPTOR
//              on a data object
//
//  Arguments:  [pDataObj] -- the data object to update
//              [ptl] -- the pointl to update in the object descriptor
//              [dwAspect] -- the draw aspect to update in the object descriptor
//
//  Returns:    Success iff the object descriptor could be updated
//
//  Notes:      This method is for IDataObjects used in drag-drop.
//              The object being dragged supplies the object descriptor but only
//              the container knows where the point that the mouse button went
//              down relative to the corner of the object, and what aspect
//              of the object the container is displaying.
//              The container uses this method to fill in that missing information.
//              This performs a GetDataHere on the object to get a filled-in
//              object descriptor.  It then updates the pointl and dwDrawAspect
//              fields and uses SetData to update the object.
//
//----------------------------------------------------------------

HRESULT
UpdateObjectDescriptor(LPDATAOBJECT pDataObj, POINTL& ptl, DWORD dwAspect)
{
    HRESULT r;
    FORMATETC formatetc =
        { g_acfCommon[ICF_OBJECTDESCRIPTOR],
            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    STGMEDIUM stgmedium;
    stgmedium.tymed = TYMED_HGLOBAL;
    stgmedium.hGlobal = 0;
    stgmedium.pUnkForRelease = NULL;
    if (OK(r = pDataObj->GetData(&formatetc, &stgmedium)))
    {
        LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(stgmedium.hGlobal);
        if (pObjDesc == NULL)
        {
            r = E_OUTOFMEMORY;
        }
        else
        {
            pObjDesc->pointl = ptl;
            pObjDesc->dwDrawAspect = dwAspect;
            r = pDataObj->SetData(&formatetc, &stgmedium, FALSE);
            GlobalUnlock(stgmedium.hGlobal);
        }
    }

    ReleaseStgMedium(&stgmedium);
    RRETURN(r);
}



//+-------------------------------------------------------------------------
//
//  Member:     FormSetClipboard(IDataObject *pdo)
//
//  Synopsis:   helper function to set the clipboard contents
//
//--------------------------------------------------------------------------
HRESULT
FormSetClipboard(IDataObject *pdo)
{
    HRESULT hr;
    hr = OleSetClipboard(pdo);
    
    if (!hr && !GetPrimaryObjectCount())
    {
        hr = THR(OleFlushClipboard());
    }
    else
    {
        ReplaceInterface(&TLS(pDataClip), pdo);
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Member:     FormClearClipboard(THREADSTATE * pts)
//
//  Synopsis:   Clear clipboard during shutdown
//
//--------------------------------------------------------------------------
HRESULT
FormClearClipboard(THREADSTATE * pts)
{
    if (pts->pDataClip)
    {
        if (!OleIsCurrentClipboard(pts->pDataClip))
        {
            WHEN_DBG(HRESULT hr =) THR(OleFlushClipboard());
            #if DBG==1
            if (hr)
            {
                 Assert(!pts->pDataClip && "Clipboard data should be flushed now");
            }
            #endif
        }

        ClearInterface(&pts->pDataClip);
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\file.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       file.cxx
//
//  Contents:   Import/export dialog helpers
//
//  History:    16-May-95   RobBear     Taken from formtool
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

CGlobalCriticalSection  g_csFile;
TCHAR                   g_achSavePath[MAX_PATH];

static HRESULT  SwitchToDirectory(LPTSTR lpwsz);

//+---------------------------------------------------------------------------
//
//  Function:   SwitchToDirectory
//
//  Synopsis:   Switches the current directory to that of the file.
//
//  Arguments:  [lptsz] -- The file whose directory we want to switch to.
//
//  Returns:    HRESULT.
//
//  History:    7-22-94   adams   Created
//
//----------------------------------------------------------------------------

static HRESULT
SwitchToDirectory(LPTSTR pstrFilePath)
{
    BOOL    fOK;
    TCHAR   path[_MAX_PATH];
    TCHAR * pch;

    _tcscpy(path, pstrFilePath);

    pch = _tcsrchr(path, _T(FILENAME_SEPARATOR));

    if (pch)
        *(pch + 1)= 0;

    fOK = SetCurrentDirectory(path);
    if (!fOK)
       RRETURN(GetLastWin32Error());

    return S_OK;
}


#ifndef NO_IME

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include <intlcore.hxx>
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

// Hook procedure for open file dialog.
UINT_PTR APIENTRY SaveOFNHookProc(HWND hdlg,
                              UINT uiMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    ULONG i, iCurSel;

    switch (uiMsg)
    {
        // Populate the dropdown.
        case WM_INITDIALOG:
        {
            LPOPENFILENAME pofn = (LPOPENFILENAME)lParam;
            IEnumCodePage * pEnumCodePage = NULL;
            CODEPAGE        codepageDefault = *(CODEPAGE *)pofn->lCustData;
            
            if (mlang().EnumCodePages(MIMECONTF_SAVABLE_BROWSER | MIMECONTF_VALID, &pEnumCodePage) == S_OK)
            {
                MIMECPINFO cpInfo;
                ULONG      ccpInfo;

                ZeroMemory(&cpInfo, sizeof(MIMECPINFO));

                if (   (mlang().GetCodePageInfo(codepageDefault, MLGetUILanguage(), &cpInfo) == S_OK) 
                    && !(cpInfo.dwFlags & MIMECONTF_SAVABLE_BROWSER))
                {
                    // If the codepage selected is not savable (eg JP_AUTO),
                    // use the family codepage.
                    codepageDefault = cpInfo.uiFamilyCodePage;
                }
                    
                // Can't have 4 billion languages.
                iCurSel = 0xffffffff;

                for (i = 0; pEnumCodePage->Next(1, &cpInfo, &ccpInfo) == S_OK; ++i)
                {
                    if (codepageDefault == cpInfo.uiCodePage)
                    {
                        iCurSel = i;
                    }

                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET_MSHTML,
                                       CB_ADDSTRING, 0,
                                       (LPARAM)cpInfo.wszDescription);
                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET_MSHTML,
                                       CB_SETITEMDATA, i,
                                       (LPARAM)cpInfo.uiCodePage);
                }
                if (iCurSel != 0xffffffff)
                    SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET_MSHTML, CB_SETCURSEL,
                                        (WPARAM)iCurSel, (LPARAM)0);
            }
            ReleaseInterface(pEnumCodePage);
            break;
        }

        case WM_NOTIFY:
        {
            LPOFNOTIFY phdr = (LPOFNOTIFY)lParam;
            if (phdr->hdr.code == CDN_FILEOK)
            {
                iCurSel = SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET_MSHTML, CB_GETCURSEL, 0, 0);
                *(CODEPAGE *)phdr->lpOFN->lCustData =
                    SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET_MSHTML, CB_GETITEMDATA,
                                         (WPARAM)iCurSel, (LPARAM)0);
            }
            break;
        }
    }
    return (FALSE);
}

#endif //!NO_IME


//+---------------------------------------------------------------------------
//
//  Function:   FormsGetFileName
//
//  Synopsis:   Gets a file name using either the GetOpenFileName or
//              GetSaveFileName functions.
//
//  Arguments:  [fSaveFile]   -- TRUE means use GetSaveFileName
//                               FALSE means use GetOpenFileName
//
//              [idFilterRes] -- The string resource specifying text in the
//                                  dialog box.  It must have the
//                                  following format:
//                            Note: the string has to be _one_ contiguous string.
//                                  The example is broken up to make it fit
//                                  on-screen. The verical bar ("pipe") characters
//                                  are changed to '\0'-s on the fly.
//                                  This allows the strings to be localized
//                                  using Espresso.
//
//          IDS_FILENAMERESOURCE, "Save Dialog As|         // the title
//                                 odg|                    // default extension
//                                 Forms3 Dialog (*.odg)|  // pairs of filter strings
//                                 *.odg|
//                                 Any File (*.*)|
//                                 *.*|"
//
//              [pstrFile]    -- Buffer for file name.
//              [cchFile]     -- Size of buffer in characters.
//
//  Modifies:   [pstrFile]
//
//----------------------------------------------------------------------------
#ifdef _MAC
extern "C" {
char * __cdecl _p2cstr(unsigned char *);
}
#endif

HRESULT
FormsGetFileName(
        BOOL fSaveFile,
        HWND hwndOwner,
        int idFilterRes,
        LPTSTR pstrFile,
        int cchFile,
        LPARAM lCustData,
        DWORD *pnFilterIndex)
{
    HRESULT         hr  = S_OK;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    LPTSTR          pstr;
    OPENFILENAME    ofn;
    TCHAR           achBuffer[4096];    //  Max. size of a string resource
    TCHAR *         cp;
    TCHAR *         pstrExt;
    int             cbBuffer;
    TCHAR           achInitialDir[MAX_PATH + 1];
    TCHAR *         pstrEndOfDir;
    TCHAR *         pstrEndOfPath = achInitialDir;

    // Check to make sure that we have a buffer and that it's NULL terminated
    Assert(pstrFile);
    pstrFile[cchFile - 1] = 0;

    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwndOwner;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = pstrFile;
    ofn.nMaxFile        = cchFile;
    ofn.lCustData       = lCustData;

#ifndef UNIX
#ifndef NO_IME
    // We add an extra control to the save file dialog.
    if (fSaveFile && lCustData)
    {
        ofn.Flags |= OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
        ofn.lpfnHook = SaveOFNHookProc;
        ofn.lpTemplateName = L"IDD_ADDTOSAVE_DIALOG_MSHTML";
        ofn.hInstance = GetResourceHInst();
    }
#endif
#endif // UNIX

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = pstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt >= pstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }
    if( pstrExt < pstrFile )
        pstrExt = NULL;

    // Load the filter spec.

    cbBuffer = ::LoadString(GetResourceHInst(),idFilterRes,achBuffer,ARRAY_SIZE(achBuffer));
    Assert(cbBuffer > 0);
    if ( ! cbBuffer )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ofn.lpstrTitle = achBuffer;

    for ( cp = achBuffer; *cp; cp++ )
    {
        if ( *cp == _T('|') )
        {
            *cp = _T('\0');
        }
    }

    Assert(ofn.lpstrTitle != NULL);

    // Default extension is second string.
    pstr = (LPTSTR) ofn.lpstrTitle;
    while (*pstr++)
    {
    }

    // N.B. (johnv) Here we assume that filter index one corresponds with the default
    //  extension, otherwise we would have to introduce a default filter index into
    //  the resource string.
    ofn.nFilterIndex    = ((pnFilterIndex)? *pnFilterIndex : 1);
    ofn.lpstrDefExt     = pstr;

    // Filter is third string.
    while(*pstr++)
    {
    }

    ofn.lpstrFilter = pstr;
    
    // Try to match the extension with an entry in the filter list
    // If we match, remove the extension from the incoming path string,
    //   set the default extension to the one we found, and appropriately
    //   set the filter index.

    if( pstrExt )
    {
        // N.B. (johnv) We are searching more than we need to.

        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

#ifndef UNIX // We need this extension for UNIX
                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');
#endif /* UNIX */

                break;
            }
            pSearch += _tcslen(pSearch);
            if( pSearch[1] == 0 )
            {
                ofn.lpstrDefExt  = NULL;
                break;
            }

            pSearch++;
            iIndex++;
        }
    }
       
    //
    // Figure out the initial directory from the given filename.
    // If an initial directory cannot be determined, then use the
    // saved directroy.
    // If an initial directory can be determined, then it will override
    // the saved directory.
    //

    // Copy the contentx of pstrFile into achInitialDir, but check the bounds.
    _tcsncpy(achInitialDir, pstrFile, MAX_PATH);
    achInitialDir[MAX_PATH] = 0;

    // Find the end of the filename
    while (*pstrEndOfPath)
    {
        pstrEndOfPath++;
    }
    pstrEndOfDir = pstrEndOfPath;

    // Move back until a backslash or colon is found
    while ((*pstrEndOfDir != _T('\\')) && (*pstrEndOfDir != _T(':')))
    {
        pstrEndOfDir--;
        if (pstrEndOfDir < achInitialDir)
        {
            // We're beyond the beginning, so bail out
            break;
        }
    }

    if (pstrEndOfDir >= achInitialDir)
    {
        TCHAR * pstrBeforeEnd = NULL;

        // A backslash or colon was found.
        if ((pstrEndOfDir - achInitialDir) > 0)
        {
            pstrBeforeEnd = pstrEndOfDir - 1;

            // Check for the \\ case
            if (*pstrBeforeEnd == _T('\\'))
            {
                // Move back to the end
                pstrEndOfDir = pstrEndOfPath;
            }
        }

        // Copy just the filename (without the directory)
        // into the filename buffer, but only if there
        // is a filename.
        if (pstrEndOfDir != pstrEndOfPath)
        {
            _tcscpy(pstrFile, pstrEndOfDir + 1);
        }
        else
        {
            *pstrFile = _T('\0');
        }

        // Separate the directory from the filename.
        if ((*pstrEndOfDir == _T(':')) ||
            (pstrBeforeEnd && (*pstrBeforeEnd == _T(':'))))
        {
            // We need to keep colons and we need to keep
            // the backslash in the c:\ case
            if (pstrEndOfDir != pstrEndOfPath)
            {
                *(pstrEndOfDir + 1) = _T('\0');
            }
        }
        else
        {
            *pstrEndOfDir = _T('\0');
        }
    }
    else
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(achInitialDir, g_achSavePath);
    }

    ofn.lpstrInitialDir = *achInitialDir ? achInitialDir : NULL;

    //
    // TODO -- The following call hides memory leaks in GetOpenFileName
    //

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (fOK)
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName = _tcsrchr(g_achSavePath, _T(FILENAME_SEPARATOR));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }

        if (pnFilterIndex)
            *pnFilterIndex = ofn.nFilterIndex;
    }
    else
    {
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
        }
        else
        {
            hr = S_FALSE;
        }
#else // WINCE
		hr = E_FAIL;
#endif // WINCE
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\fbstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       fbstr.cxx
//
//  Contents:   Wrappers around BSTR api to account for wierdness with NULL
//
//  Functions:  FormsAllocString
//              FormsAllocStringLen
//              FormsReAllocString
//              FormsReAllocStringLen
//              FormsFreeString
//              FormsStringLen
//              FormsStringByteLen
//              FormsStringCmp
//              FormsStringNCmp
//              FormsStringICmp
//              FormsStringNICmp
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+---------------------------------------------------------------------------
//
//  Function:   FormsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------
HRESULT
FormsAllocStringW(LPCWSTR pch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pch || !*pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    *pBSTR = SysAllocString(pch);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsAllocStringLen
//
//  Synopsis:   Allocs a BSTR of [uc] + 1 OLECHARS, and
//              initializes it from an optional string.  If [uc] == 0, the
//              resulting bstr is NULL.
//
//  Arguments:  [pch]   -- String to initialize.
//              [uc]    -- Count of characters of string.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
FormsAllocStringLenW(LPCWSTR pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (uc == 0)
    {
        *pBSTR = NULL;
        return S_OK;
    }

    *pBSTR = SysAllocStringLen(pch, uc);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsReAllocString
//
//  Synopsis:   Allocates a BSTR initialized from a string; if successful,
//              frees the original string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
FormsReAllocStringW(BSTR * pBSTR, LPCWSTR pch)
{
    Assert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = THR(FormsAllocStringW(pch, &bstrTmp));
    if (hr)
        RRETURN(hr);

    FormsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else  //DBG == 1
#  ifndef _MAC
    return SysReAllocString(pBSTR, pch) ? S_OK : E_OUTOFMEMORY;
#  else
    // mac note: Richedit text requires BSTRs that contain unicode strings
    //          so we will occasionally need to call this wide char version 
    return SysReAllocStringLen(pBSTR, (OLECHAR *)pch, wcslen(pch) * sizeof(WCHAR)) ? S_OK : E_OUTOFMEMORY;
#  endif

#endif //DBG == 1
}


//+---------------------------------------------------------------------------
//
//  Function:   FormsReAllocStringLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 OLECHARs and optionally
//              initializes it from a string; if successful, frees the original
//              string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//              [uc]    -- Count of characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
FormsReAllocStringLenW(BSTR * pBSTR, LPCWSTR pch, UINT uc)
{
    Assert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = THR(FormsAllocStringLen(pch, uc, &bstrTmp));
    if (hr)
        RRETURN(hr);

    FormsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else
    return SysReAllocStringLen(pBSTR, pch, uc) ? S_OK : E_OUTOFMEMORY;
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   FormsStringLen
//
//  Synopsis:   Returns the length of the BSTR.
//
//  History:    5-06-94   adams   Created
//              6-30-95   andrewl Changed BSTR to const BSTR
//
//----------------------------------------------------------------------------

UINT
FormsStringLen(const BSTR bstr)
{
    return bstr ? SysStringLen((BSTR)bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   FormsStringByteLen
//
//  Synopsis:   Returns the length of a BSTR in bytes.
//
//  History:    5-06-94   adams   Created
//              6-30-95   andrewl Changed BSTR to const BSTR
//
//----------------------------------------------------------------------------

UINT
FormsStringByteLen(const BSTR bstr)
{
    return bstr ? SysStringByteLen((BSTR)bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   FormsStringCmp
//
//  Synopsis:   As per _tcscmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

int
FormsStringCmp(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcscmp(STRVAL(bstr1), STRVAL(bstr2));
}
int
FormsStringCmpLoc(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcscmpLoc(STRVAL(bstr1), STRVAL(bstr2));
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsStringNCmp
//
//  Synopsis:   As per _tcsncmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

int
FormsStringNCmp(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsncmp(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}
int
FormsStringNCmpLoc(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsncmpLoc(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}



//+---------------------------------------------------------------------------
//
//  Function:   FormsStringICmp
//
//  Synopsis:   As per wcsicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsicmp to _tcsicmp
//
//----------------------------------------------------------------------------

int
FormsStringICmp(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}
int
FormsStringICmpLoc(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcsicmpLoc(STRVAL(bstr1), STRVAL(bstr2));
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsStringNICmp
//
//  Synopsis:   As per wcsnicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsnicmp to _tcsnicmp
//
//----------------------------------------------------------------------------

int
FormsStringNICmp(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsnicmp(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}
int
FormsStringNICmpLoc(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsnicmpLoc(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsStringCmpCase
//
//----------------------------------------------------------------------------

int
FormsStringCmpCase(LPCTSTR bstr1, LPCTSTR bstr2, BOOL fCaseSensitive)
{
    return (fCaseSensitive) ?
        _tcscmp (STRVAL(bstr1), STRVAL(bstr2)) :
        _tcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}
int
FormsStringCmpCaseLoc(LPCTSTR bstr1, LPCTSTR bstr2, BOOL fCaseSensitive)
{
    return (fCaseSensitive) ?
        _tcscmpLoc (STRVAL(bstr1), STRVAL(bstr2)) :
        _tcsicmpLoc(STRVAL(bstr1), STRVAL(bstr2));
}


//+-------------------------------------------------------------------------
// Function:    FormsSplitAtDelimiter
//
// Synopsis:    split a name into its head component (everything before the first
//              dot), and the tail component (the rest).
//
// Arguments:	bstrName    name to be split
//              pbstrHead   where to store head component
//              pbstrTail   where to store the rest
//              fFirst      TRUE - split at first delimiter, FALSE - at last
//              tchDelim    delimiter character (defaults to _T('.'))

void
FormsSplitAtDelimiter(LPCTSTR bstrName, BSTR *pbstrHead, BSTR *pbstrTail,
                            BOOL fFirst, TCHAR tchDelim)
{
    if (FormsIsEmptyString(bstrName))
    {
        *pbstrHead = NULL;
        *pbstrTail = NULL;
    }
    else
    {
        TCHAR *ptchDelim = fFirst ?  _tcschr(bstrName, tchDelim)
                                  : _tcsrchr(bstrName, tchDelim);

        if (ptchDelim)
        {
            FormsAllocStringLen(bstrName, ptchDelim - bstrName, pbstrHead);
            FormsAllocString(ptchDelim + 1, pbstrTail);
        }
        else if (fFirst)
        {
            FormsAllocString(bstrName, pbstrHead);
            *pbstrTail = NULL;
        }
        else
        {
            *pbstrHead = NULL;
            FormsAllocString(bstrName, pbstrTail);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\formsary.cxx ===
//+------------------------------------------------------------------------
//
//  File:   formsary.cxx
//
//  Contents:   Generic dynamic array class
//
//  Classes:    CImplAry
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

DeclareTag(CImplAryLock, "CImplAry", "Detect data array changing when lock is on.");

#define CFORMSARY_MAXELEMSIZE    128

MtDefine(CURLAry, Utilities, "CURLAry")
MtDefine(CURLAry_pv, CURLAry, "CURLAry::_pv")
MtDefine(CIPrintAry, Printing, "CIPrintAry")
MtDefine(CIPrintAry_pv, CIPrintAry, "CIPrintAry::_pv")
MtDefine(CPrintInfoFlagsAry, Printing, "CPrintInfoFlagsAry")
MtDefine(CPrintInfoFlagsAry_pv, CPrintInfoFlagsAry, "CPrintInfoFlagsAry::_pv")

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//+------------------------------------------------------------------------
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CImplAry::~CImplAry( )
{
    if (!UsingStackArray())
    {
        MemFree(PData());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is _cStack*cb if
//              we're still using the stack-allocated array.
//
//----------------------------------------------------------------------------

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }
    else
    {
        return MemGetSize(PData());
    }
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::EnsureSize ( size_t cb, long c )
{
    HRESULT  hr = S_OK;
    unsigned long cbAlloc;

    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        goto Cleanup;

    Assert( c >= 0 );

    cbAlloc = ((c < 8) ? c : ((c + 7) & ~7)) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((_c < 8) ? _c : ((_c + 7) & ~7))) && cbAlloc > MemGetSize(PData())))
    {
        Assert(!(_fCheckLock && IsTagEnabled(CImplAryLock)) && "CDataAry changing while CImplAryLock is on");

        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            
            void * pbDataOld = PData();
            int    cbOld     = GetAlloced( cb );

            PData() = MemAlloc( _mt, cbAlloc );
            
            if (!PData())
            {
                PData() = pbDataOld;

                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            memcpy( PData(), pbDataOld, cbOld );
        }
        else
        {
            hr = MemRealloc( _mt, (void **) & PData(), cbAlloc );
            
            if (hr)
                goto Cleanup;
        }

        _fDontFree = FALSE;

        MemSetName((PData(), "CImplAry data (%d elements)", c));
    }

Cleanup:
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (!hr)
    {
        SetSize(c);
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::AppendIndirect(size_t cb, void * pv, void ** ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, _c);
    }

    if (!pv)
    {
        memset(Deref(cb, _c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, _c), pv, cb);
    }

    _c++;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member: CImplAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::Delete(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)_c);

    Assert(!(_fCheckLock && IsTagEnabled(CImplAryLock)) && "CDataAry changing while CImplAryLock is on");

    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//-------------------------------------------------------------------------
BOOL
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        Delete(cb, i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)_c) && (end < (int)_c));
    Assert(end >= start);

    if ((unsigned)end < (_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (_c - end - 1) * cb);
    }

    _c -= (end - start) + 1;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteAll(void)
{
    Assert(!(_fCheckLock && IsTagEnabled(CImplAryLock)) && "CDataAry changing while CImplAryLock is on");

    if (!UsingStackArray())
    {
        MemFree(PData());

        if (_fStack)
        {
            PData() = GetStackPtr();
            _fDontFree = TRUE;
        }
        else
        {
            PData() = NULL;
        }
    }

    _c = 0;
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (_c - i ) * cb);

    if (!pv)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }
    _c++;
    return NOERROR;

}

#ifdef NEVER
//+------------------------------------------------------------------------
//
//  Member: CImplAry::BringToFront
//
//  Synopsis:   Moves the i'th element to the front of the array, shuffling
//              intervening elements to make room.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CImplAry::BringToFront(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    Assert(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + cb, PData(), i * cb);
    memcpy(PData(), rgb, cb);
}



//+------------------------------------------------------------------------
//
//  Member: CImplAry::SendToBack
//
//  Synopsis:   Moves the i'th element to the back of the array (that is,
//      the largest index less than the logical size.) Any intervening
//      elements are shuffled out of the way.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CImplAry::SendToBack(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    Assert(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    memcpy(((BYTE *) PData()) + ((_c - 1) * cb), rgb, cb);
}


//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Swap
//
//  Synopsis:   swap two members of array with each other.
//
//  Arguments:  cb  size of elements
//              i1  1st element
//              i2  2nd element
//----------------------------------------------------------------------------
void
CImplAry::Swap(size_t cb, int i1, int i2)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    Assert(cb <= CFORMSARY_MAXELEMSIZE);

    if ((unsigned)i1 >= _c)
        i1 = _c - 1;
    if ((unsigned)i2 >= _c)
        i2 = _c - 1;

    if (i1 != i2)
    {
        memcpy(rgb, ((BYTE *) PData()) + (i1 * cb), cb);
        memcpy(((BYTE *) PData()) + (i1 * cb), ((BYTE *) PData()) + (i2 * cb), cb);
        memcpy(((BYTE *) PData()) + (i2 * cb), rgb, cb);
    }
}
#endif // NEVER

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//----------------------------------------------------------------------------

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = _c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return _c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::CopyAppend
//
//  Synopsis:   Copies the entire contents of another CImplAry object and
//              appends it to the end of the array.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

#ifdef NEVER
HRESULT
CImplAry::CopyAppend(size_t cb, const CImplAry& ary, BOOL fAddRef)
{
    RRETURN(CopyAppendIndirect(cb, ary._c, ((CImplAry *)&ary)->PData(), fAddRef));
}


HRESULT
CImplAry::CopyAppendIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown ** ppUnk;                  // elem to addref

    if (EnsureSize(cb, _c + c))
        RRETURN(E_OUTOFMEMORY);

    if (pv)
    {
        memcpy((BYTE*) PData() + (_c * cb), pv, c * cb);
    }

    _c += c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) pv; c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}
#endif // NEVER

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, BOOL fAddRef)
{
    RRETURN(CopyIndirect(cb, ary._c, ((CImplAry *)&ary)->PData(), fAddRef));
}



//+------------------------------------------------------------------------
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown **     ppUnk;

    if (pv == PData())
        return S_OK;

    DeleteAll();
    if (pv)
    {
        if (EnsureSize(cb, c))
            RRETURN(E_OUTOFMEMORY);

        memcpy(PData(), pv, c * cb);
    }

    _c = c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//-------------------------------------------------------------------------

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
}

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
}

int
CImplPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CImplPtrAry::Delete(int i)
{
    CImplAry::Delete(sizeof(void *), i);
}

BOOL
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::Delete(sizeof(void *), i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
}

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown * pUnk;

    Assert(idx < (int)_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];

#if defined(UNIX) && defined(ux10)
    if (pUnk)
        (pUnk)->Release();

    Delete(idx);
#else
    Delete(idx);

    if (pUnk)
        (pUnk)->Release();
#endif
}


void
CImplPtrAry::ReleaseAll(void)
{
    int         i;
    IUnknown ** ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < _c; i++, ppUnk++)
    {
        if (*ppUnk)
            (*ppUnk)->Release();
    }

    DeleteAll();
}

#ifdef NEVER
void
CImplPtrAry::BringToFront(int i)
{
    CImplAry::BringToFront(sizeof(void *), i);
}


void
CImplPtrAry::SendToBack(int i)
{
    CImplAry::SendToBack(sizeof(void *), i);
}

void
CImplPtrAry::Swap(int i1, int i2)
{
    CImplAry::Swap(sizeof(void *), i1, i2);
}


HRESULT
CImplPtrAry::CopyAppendIndirect(int c, void * pv, BOOL fAddRef)
{
    return CImplAry::CopyAppendIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CImplPtrAry::CopyAppend(const CImplAry& ary, BOOL fAddRef)
{
    return CImplAry::CopyAppend(sizeof(void *), ary, fAddRef);
}
#endif // NEVER

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, BOOL fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, BOOL fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
}


HRESULT
CImplPtrAry::EnumElements(
        REFIID iid,
        void ** ppv,
        BOOL fAddRef,
        BOOL fCopy,
        BOOL fDelete)
{
    return CImplAry::EnumElements(
            sizeof(void *),
            iid,
            ppv,
            fAddRef,
            fCopy,
            fDelete);
}


HRESULT
CImplPtrAry::EnumVARIANT(
        VARTYPE vt,
        IEnumVARIANT ** ppenum,
        BOOL fCopy,
        BOOL fDelete)
{
    return CImplAry::EnumVARIANT(
            sizeof(void *),
            vt,
            ppenum,
            fCopy,
            fDelete);
}


CStackCStrAry::~CStackCStrAry()
{
    CStr *pcstr = (CStr*) PData();
    int iSize = Size();

    while (iSize--) 
    {
        pcstr->Free();
        pcstr++;
    }
}


CStackIPrintAry::~CStackIPrintAry()
{
    IPrint **ppPrint = (IPrint**) PData();
    int iSize = Size();

    while (iSize--) 
    {
        ClearInterface(ppPrint);
        ppPrint++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\format.cxx ===
//+------------------------------------------------------------------------
//
//  File:       format.cxx
//
//  Contents:   Formatting Swiss Army Knife
//
//  History:    20-Oct-94   GaryBu  Created from Sterling & Ren
//              5-22-95     kfl     converted WCHAR to TCHAR
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef UNIX
#ifndef X_MAINWIN_H_
#define X_MAINWIN_H_
#include "mainwin.h"
#endif
#endif

MtDefine(OutputStream_pch, Utilities, "Format OutputStream::_pch")

//
//  CONSIDER:  This file does not include support for simulated
//    failures.  It includes methods that can fail, but are called
//    once for each character in the output string--which would
//    produce an unwieldy number of failure points.
//
//    Should this be changed?
//

//+------------------------------------------------------------------------
//  Format and VFormat
//
//  Format and VFormat are similiar to the sprintf family.
//  Format fixes two problems exhibited by sprintf.  First, the
//  order of argument substitution in sprintf is specified by
//  function caller. To support localization, the order of argument
//  substitution should be specified in the format string.  Second,
//  the range of formatting options are limited and cannot be
//  extended.
//
//  A format string consists of characters to be copied to the
//  output string and argument substitutions.  Arguments can be
//  referenced more than once.  This allows for very nice handling
//  of plurals.  For example: "There <0p/are/is/> <0d> toaster<0p//s/>
//  flying across my screen."
//
//  BiDi consideration: Arabic has a "dual" case between singular
//                      and plural (separate conjugation for a pair
//                      of things). We should find out if that poses
//                      a problem for Format.
//
//  FORMAT SPECIFIERS
//
//   "<" arg format options ">"
//
//      arg     - A single digit specifying the argument number.
//      handler - A single character specifying argument
//                type and display format.
//      options - Formatting options specific to format type.
//
//  NOTES
//
//      Two '<' characters in a row will print out as one '<'
//      character and does not mark the beginning of a format
//      specification.  Ex.: "The symbol << means less than."
//
//
//  FORMATS
//
//  d   Format long as decimal.
//      Options:
//          u       Argument is unsigned.
//          <digit> Field width.
//
//  s   Format zero terminated TCHAR *.
//      Options:
//          <none>
//
//  p   Format long as plural.
//      Options:
//          delimiter singular delimiter plural delimiter.
//      Example:
//          "There <0p/is/are/> <0d> toaster<0p//s/> flying across my screen"
//
//  i   Format resource string. First argugment is HINSTANCE, second
//      argument is string id.
//      Options:
//          <none>
//
//  g   Format GUID.
//      Options:
//          <none>
//
//  x   Format long as 8 character hex.
//      Options:
//          <none>
//
//  c   Format long as 6 character lowercase hex.  Option is for color.
//      Options:
//          <none>
//
//  C   Format long as 3 character lowercase hex.  Option is for color.
//      Options:
//          <none>
//
//  CALLING SEQUENCE
//
//      HRESULT VFormat(DWORD dwOptions,
//          void *pvOutput, int cchOutput,
//          TCHAR *pchFmt,
//          void *pvArgs);
//
//      HRESULT Format(DWORD dwOptions,
//          void *pvOutput, int cchOutput,
//          TCHAR *pchFmt,
//          ...);
//
//          dwOptions
//              Flags taken from the FMT_OPTIONS enumeration.
//
//              FMT_OUT_ALLOC
//                  Specifies that the pvOutput parameter is a pointer
//                  to a TCHAR*, and that the cchOutput parameter specifies
//                  the minimum number of characters to allocate for an
//                  output message buffer. The function allocates a buffer
//                  large enough to hold the formatted message, and
//                  places a pointer to the allocated buffer at the address
//                  specified by pvOutput. The caller should use the
//                  delete [] operator to free the buffer when it is no
//                  longer needed.
//
//              FMT_ARG_ARRAY
//                  Specifies that the pvArg parameter is NOT a va_list
//                  structure, but instead is just a pointer to an array
//                  of 32-bit values that represent the arguments.
//
//              FMT_EXTRA_NULL_MASK
//                  Add (dwOptions & FMT_EXTRA_NULL_MASK) null terminators to
//                  the end of the string.  This is useful for parsing
//                  multi-part strings where each part is separated
//                  by a null character.
//
//          pvOutput
//              Points to a buffer for the formatted (and null-terminated)
//              string. If dwOptions includes FMT_OUT_ALLOC, the function
//              allocates a buffer via operator new, and places the
//              address of the buffer at the address specified in pvOutput.
//
//          cchOutput
//              If the FMT_OUT_ALLOC flag is not set, this parameter
//              specifies the maximum number of characters that can be
//              stored in the output buffer. If the FMT_OUT_ALLOC flag is
//              set, this parameter specifies the minimum number of
//              characters to allocate for an output buffer.
//
//          pchFmt
//              Specifies the format string. Use MAKEINTRESOURCE(ids) to
//              specify the id of a string resource.
//
//          pvArgs
//              Pointe to 32-bit values thare are used as insert values
//              in the formatted string. By default this parameter is of
//              type va_list *.  If FMT_ARG_ARRAY is set, then pvArgs
//              is a pointer to an array of 32-bit values.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Function:   LoadString
//
//  Synopsis:   Get pointer to string resource. The returned
//              pointer does not need to be freed and is not
//              null terminated.
//
//  Arguments:  [hinst] - load from this module.
//              [ids] - string id.
//              [pcch] - number of characters in string.
//              [ppsz] - the string
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
LoadString(HINSTANCE hinst, UINT ids, int *pcch, TCHAR **ppsz)
{
    BYTE *  pb;
    int     i;

    pb = (BYTE *)GetResource(hinst, MAKEINTRESOURCE(((ids / 16) + 1)), RT_STRING, NULL);

#ifndef _MAC
    if (pb)
    {
        for (i = ids & 0xF; --i >= 0; )
        {
            pb += *(WORD *)pb * sizeof(TCHAR) + sizeof(TCHAR);
        }

        *pcch = *(WORD *)pb;
        *ppsz = (TCHAR *)(pb + sizeof(TCHAR));
    }
    else
    {
        *pcch = 0;
        *ppsz = NULL;
    }
#else
    // count of the STRs in this STR#
    pb += sizeof(WORD);

    for (i = ids & 0xF; --i >= 0; )
    {
#ifdef _MAC
        pb += *(BYTE *)pb * sizeof(BYTE) + sizeof(BYTE);
#else
        pb += *(BYTE *)pb * sizeof(OLECHAR) + sizeof(BYTE);
#endif
    }

    *pcch = *(BYTE *)pb;
    *ppsz = MacConvertPStrToWSTR(pb);
#endif
    return *pcch != 0 ? S_OK : E_FAIL;
}


//+------------------------------------------------------------------------
//
//  Class:      OutputStream
//
//  Synopsis:   Abstracts writing to allocated buffer or fixed buffer.
//
//-------------------------------------------------------------------------

#define CCH_OUT_GROW 128
class OutputStream // tag: Output
{
private:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))
public:
    HRESULT Init(BOOL fFixed, void *pvOutput, int cchOutput);
    HRESULT Put(TCHAR ch);
    HRESULT Put(TCHAR *sz);
    void    Nuke();
private:
    int     _cch;
    int     _cchAlloc;
    BOOL    _fAlloc;
    TCHAR * _pch;
    union {
        TCHAR **_ppchAlloc;
        TCHAR *_pchBase;
    };
};

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Init
//
//  Synopsis:   Initialize the output stream.
//
//  Arguments:  fAlloc - true if should allocate output buffer.
//              pvOutput - if fAlloc then place to store output buffer pointer,
//                  else pointer to acutal buffer.
//              cchOutput - if fAlloc then minimum allocation size
//                  else size of outpu buffer.
//
//-------------------------------------------------------------------------
HRESULT
OutputStream::Init(BOOL fAlloc, void *pvOutput, int cchOutput)
{
    HRESULT hr = NOERROR;

    _fAlloc = fAlloc;
    if (fAlloc)
    {
        if (cchOutput <= 0)
            cchOutput = CCH_OUT_GROW;
        _ppchAlloc = (TCHAR **)pvOutput;
        _pch = *_ppchAlloc = (TCHAR *)MemAlloc(Mt(OutputStream_pch), sizeof(TCHAR)*cchOutput);
        if (_pch)
            _cch = _cchAlloc = cchOutput;
        else
        {
            _cch = 0;
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        _cch = cchOutput;
        _pch = _pchBase = (TCHAR *)pvOutput;
        _pch[_cch-1] = 0;
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Put
//
//  Synopsis:   Put a character on the output stream.
//
//-------------------------------------------------------------------------
HRESULT
OutputStream::Put(TCHAR ch)
{
    if (--_cch >= 0)
    {
        *_pch++ = ch;
    }
    else if (!_fAlloc)
    {
        Assert(0 && "Format: pvOutput too small.");
        return E_FAIL;
    }
    else
    {
        TCHAR *pch = *_ppchAlloc;
        *_ppchAlloc = (TCHAR *)MemAlloc(Mt(OutputStream_pch), sizeof(TCHAR)*(_cchAlloc + CCH_OUT_GROW));
        if (!*_ppchAlloc)
        {
            MemFree(pch);
            _cch = 0;
            return E_OUTOFMEMORY;
        }
        else
        {
            memcpy(*_ppchAlloc, pch, _cchAlloc * sizeof(TCHAR));
            MemFree(pch);
            _pch = *_ppchAlloc + _cchAlloc;
            _cchAlloc += CCH_OUT_GROW;
            _cch = CCH_OUT_GROW - 1;
            *_pch++ = ch;
        }
    }
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Put
//
//  Synopsis:   Put a string on the output stream.
//
//-------------------------------------------------------------------------
HRESULT
OutputStream::Put(TCHAR *sz)
{
    HRESULT hr = NOERROR;
    while (hr == NOERROR && *sz)
        hr = Put(*sz++);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Nuke
//
//  Synopsis:   Nuke the output stream. Called in case of error.
//
//-------------------------------------------------------------------------
void
OutputStream::Nuke()
{
    if (!_fAlloc)
        *_pchBase = 0;
    else if (*_ppchAlloc)
    {
        MemFree(*_ppchAlloc);
        *_ppchAlloc = 0;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   FormatDecimal
//
//  Synopsis:   Format adwArg[0] as decimal to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatDecimal(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    BOOL    fUnsigned = FALSE;
    TCHAR   szBuf[33];
    int     cWidth = 0;
    int     i;

    if (**ppchFmt == TEXT('u'))
    {
        fUnsigned = TRUE;
        *ppchFmt += 1;
    }
    if ( InRange( **ppchFmt, _T('0'), _T('9') ) )
    {
        cWidth = **ppchFmt - _T('0');
        *ppchFmt += 1;
    }
    
	// WINCETODO - these cruntime func don't seem to work on CE!
#ifdef WINCE
	{
		char	szFix[40];

		if (fUnsigned)
		{
			_ultoa(adwArg[0], szFix, 10);
		}
		else
		{
			_ltoa(adwArg[0], szFix, 10);
		}
		MultiByteToWideChar(CP_ACP, 0, szFix, -1, szBuf, 33);
	}
#else
    if (fUnsigned)
    {
        _ultot(adwArg[0], szBuf, 10);
    }
    else
    {
        _ltot(adwArg[0], szBuf, 10);
    }
#endif

    if (cWidth > 0)
    {
        for (i = cWidth - _tcslen(szBuf); --i >= 0;)
        {
            pOutput->Put(_T("0"));
        }
    }

    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatHex
//
//  Synopsis:   Format adwArg[0] as hex to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatHex(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR   szBuf[33];
    int     i;

    _ultot(adwArg[0], szBuf, 16);
    for (i = 8 - _tcsclen(szBuf); i > 0; i--)
        pOutput->Put(_T('0'));
    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatColor
//
//  Synopsis:   Format adwArg[0] as a 6-digit hex to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatColor(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR   szBuf[33];
    long    lRGB = (long)adwArg[0];
    long    lBGR = ((lRGB & 0xffL) << 16) |
                   (lRGB & 0xff00L) |
                   ((lRGB & 0xff0000L) >> 16);

    pOutput->Put(_T('#'));
    _ultot(lBGR, szBuf, 16);
#ifndef _MAC
    CharLower(szBuf);
#endif
    for (int i = 6 - _tcsclen(szBuf); i > 0; i--)
        pOutput->Put(_T('0'));
    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatPound3
//
//  Synopsis:   Format adwArg[0] as a 3-digit hex to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatPound3(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR   szBuf[33];
    long    lRGB = (long)adwArg[0];
    long    lBGR = ((lRGB&0xf) << 8) | ((lRGB&0xf00) >> 4) | ((lRGB&0xf0000) >> 16);

    pOutput->Put(_T('#'));
    _ultot(lBGR, szBuf, 16);
#ifndef _MAC
    CharLower(szBuf);
#endif
    for (int i = 3 - _tcsclen(szBuf); i > 0; i--)
    {
        pOutput->Put(_T('0'));
    }
    return pOutput->Put(szBuf);
}


//+------------------------------------------------------------------------
//
//  Function:   FormatString
//
//  Synopsis:   Format adwArg[0] as string ptr to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatString(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    return pOutput->Put((TCHAR *)adwArg[0]);
}


//+------------------------------------------------------------------------
//
//  Function:   FormatGuid
//
//  Synopsis:   Format adwArg[0] as guid ptr to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatGuid(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR szBuf[40];
    Verify(StringFromGUID2(*(CLSID *)adwArg[0], szBuf,
            ARRAY_SIZE(szBuf))>0);
    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatRsrc
//
//  Synopsis:   Format resource string to the output stream.
//              adwArg[0] is the HINSTANCE and adArg[1] is the string id.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatRsrc(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    HRESULT hr;
    int     cch;
#ifndef _MACUNICODE
    TCHAR * psz;

    hr = THR(LoadString((HINSTANCE)adwArg[0], adwArg[1], &cch, &psz));
    Assert(!hr);
    while (hr == NOERROR && --cch >= 0)
        hr = pOutput->Put(*psz++);
#else
    // Macs store resources as ansi so we can't use the LoadString helper
    //      function 'cuz it just returns a pointer to the string resource.
    CHAR    psz[MAX_PATH];

    cch = THR(LoadStringA((HINSTANCE)adwArg[0], adwArg[1], psz, MAX_PATH ));
    if( cch )
        hr = pOutput->Put(MAKEWSTR(psz));
    else
        return E_FAIL;
#endif
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   FormatPlural
//
//  Synopsis:   Format adwArg[0] as plural to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatPlural(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    HRESULT hr = NOERROR;
    TCHAR * pch = *ppchFmt;
    TCHAR   chDelim;
    TCHAR   ch;

    chDelim = *pch++;
    if (adwArg[0] == 1)
    {
        while (*pch && (ch = *pch++) != chDelim)
        {
            hr = pOutput->Put(ch);
            if (hr)
                return hr;

        }
        while (*pch && *pch++ != chDelim)
            ;
    }
    else
    {
        while (*pch && *pch++ != chDelim)
            ;
        while (*pch && (ch = *pch++) != chDelim)
        {
            hr = pOutput->Put(ch);
            if (hr)
                return hr;

        }
    }
    *ppchFmt = pch;
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Function:   Format
//
//  Synopsis:   Replacement for sprintf and its friends.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
HRESULT __cdecl
Format(DWORD dwOptions, void *pvOutput, int cchOutput, TCHAR *pchFmt,...)
{
    HRESULT hr;
    va_list arg;

    va_start(arg, pchFmt);
    hr = VFormat(dwOptions, pvOutput, cchOutput, pchFmt, &arg);
    va_end(arg);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   Format
//
//  Synopsis:   Replacement for vsprintf and its friends.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
HRESULT
VFormat(DWORD dwOptions, void *pvOutput, int cchOutput,
        TCHAR *pchFmt, void *pvArgs)
{
    HRESULT hr = NOERROR;
    int     i;
    int     cch;
    TCHAR * pchFmtEnd;            // pointer location past end of format string.
    DWORD_PTR * adwArg;           // pointer to argument array
    DWORD_PTR   adwArgBuf[10];    // buffer for va_list args
    HRESULT (*pfn)(TCHAR **, OutputStream *, DWORD_PTR*);
    OutputStream output;

    // Step 1: Setup argument array pointer, pdwArgs.

    if (dwOptions & FMT_ARG_ARRAY)
    {
        adwArg = (DWORD_PTR *)pvArgs;
    }
    else
    {
        // Fetch arguments from variable length argument list.
        // Two assumptons are made here that are not generally true
        // of floating point types:
        //  - sizeof(argument) == sizeof(DWORD_PTR)
        //  - va_arg(arg, DWORD_PTR) does the right thing for all types.

        adwArg = adwArgBuf;
        for (i = 0; i < ARRAY_SIZE(adwArgBuf); i++)
        {
            adwArgBuf[i] = va_arg(*(va_list *)pvArgs, DWORD_PTR);
        }
    }

    // Step 2: Setup source string pointers, pchFmt & pchFmtEnd.

    if (!IS_INTRESOURCE(pchFmt))
    {
        pchFmtEnd = pchFmt + _tcslen(pchFmt);
    }
    else
    {
        hr = THR(LoadString(GetResourceHInst(), (UINT)(UINT_PTR)pchFmt, &cch, &pchFmt));
        if (hr)
            return hr;

        pchFmtEnd = pchFmt + cch;
    }

    // Step 3: Do the formatting.

    hr = output.Init(dwOptions & FMT_OUT_ALLOC, pvOutput, cchOutput);
    if (hr)
        return hr;

    while (pchFmt < pchFmtEnd)
    {
        if (*pchFmt != TEXT('<'))
            {
            hr = output.Put(*pchFmt++);
            if (hr)
                goto Cleanup;
            }
        else
        {
            pchFmt += 1;
            if (!InRange( *pchFmt, _T('0'), _T('9') ))
            {
                hr = output.Put(*pchFmt++);
                if (hr)
                    goto Cleanup;
            }
            else
            {
                i = *pchFmt++ - TEXT('0');
                if ( InRange( *pchFmt, _T('0'), _T('9') ) )
                {
                    i = i * 10 + *pchFmt++ - TEXT('0');
                }
                Assert(i < ARRAY_SIZE(adwArgBuf));

                switch (*pchFmt++)
                {
                case 'd': pfn = FormatDecimal; break;
                case 's': pfn = FormatString;  break;
                case 'p': pfn = FormatPlural;  break;
                case 'i': pfn = FormatRsrc;    break;
                case 'g': pfn = FormatGuid;    break;
                case 'x': pfn = FormatHex;     break;
                case 'c': pfn = FormatColor;   break;
                case 'C': pfn = FormatPound3;  break;
                default:
                    Assert(0 && "Format: Unknown format type.");
                    hr = E_FAIL;
                    goto Cleanup;
                    break;
                }
                hr = pfn(&pchFmt, &output, &adwArg[i]);
                if (hr)
                    goto Cleanup;
                if (*pchFmt++ != TEXT('>'))
                {
                    Assert(0 && "Format: Unknown option.");
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
        }
    }

    for (i = dwOptions & FMT_EXTRA_NULL_MASK; i >= 0; i--)
    {
        hr = output.Put((TCHAR)0);
        if (hr)
            goto Cleanup;
    }

    return S_OK;

Cleanup:
    output.Nuke();
    return hr;
}

#if DBG==1

static int __cdecl Test1Format(HRESULT hrExpected, TCHAR *pszExpected,
        TCHAR *pszFmt, ...)
{
    HRESULT hr;
    int     cErrors = 0;
    va_list arg;
    TCHAR   szBuf[256];
    TCHAR * pszOutput;

    va_start(arg, pszFmt);
    hr = VFormat(0, szBuf, ARRAY_SIZE(szBuf), pszFmt, &arg);
    va_end(arg);
    if (hr != hrExpected)
    {
        cErrors += 1;
        TraceTag((tagError, "Error for buf '%ls'\n  "
                "Expected=%08x\n Actual  =%08x\n", pszFmt, hrExpected, hr));
    }
    else if (!hrExpected && _tcscmp(szBuf, pszExpected))
    {
        cErrors += 1;
        TraceTag((tagError, "Error for buf '%ls'\n  "
                "Expected '%ls'\n  Actual   '%ls'\n",
                pszFmt, pszExpected, szBuf));
    }

    va_start(arg, pszFmt);
    hr = VFormat(FMT_OUT_ALLOC, &pszOutput, 10, pszFmt,&arg);
    va_end(arg);
    if (hr != hrExpected)
    {
        cErrors += 1;
        TraceTag((tagError, "Error for alloc 'l%s'\n  "
                "Expected=%08x\n Actual  =%08x\n", pszFmt, hrExpected, hr));
    }
    else if (!hrExpected && _tcscmp(pszOutput, pszExpected))
    {
        cErrors += 1;
        TraceTag((tagError, "Error for alloc '%ls'\n  "
                "Expected '%ls'\n  Actual   '%ls'\n",
                pszFmt, pszExpected, pszOutput));
    }
    MemFree(pszOutput);
    return cErrors;
}

int TestFormat()
{
    int cErrors = 0;

    cErrors += Test1Format(0, TEXT("Now is the time."), TEXT("Now is the time."));

    cErrors += Test1Format(0, TEXT("1 2 3 4 5"),
        TEXT("<0d> <1d> <2d> <3d> <4d>"),
        (long)1, (long)2, (long)3, (long)4, (long)5);

    cErrors += Test1Format(0, TEXT("1 2 3 4 5"),
        TEXT("<0s> <1s> <2s> <3s> <4s>"),
        TEXT("1"), TEXT("2"), TEXT("3"), TEXT("4"), TEXT("5"));

    cErrors += Test1Format(0, TEXT("<0d>"),
        TEXT("<<<0d>d>"),
        (long)0);

    cErrors += Test1Format(0, TEXT("aba"),
        TEXT("<0s><1s><0s>"),
        TEXT("a"), TEXT("b"));

    cErrors += Test1Format(0, TEXT("-1 -2 -3 -4 -5"),
        TEXT("<0d> <1d> <2d> <3d> <4d>"),
        (long)-1, (long)-2, (long)-3, (long)-4, (long)-5);

    cErrors += Test1Format(0, TEXT("There is 1 toaster flying across my screen"),
            TEXT("There <0p/is/are/> <0d> toaster<0p//s/> flying across my screen"),
            (long)1);

    cErrors += Test1Format(0, TEXT("There are 2 toasters flying across my screen"),
            TEXT("There <0p/is/are/> <0d> toaster<0p//s/> flying across my screen"),
            (long)2);

    cErrors += Test1Format(E_FAIL, TEXT("-1 -2 -3 -4 -5"),
        TEXT("<0q> <1d> <2d> <3d> <4d>"),
        (long)-1, (long)-2, (long)-3, (long)-4, (long)-5);

    cErrors += Test1Format(E_FAIL, TEXT("-1 -2 -3 -4 -5"),
        TEXT("<0dfoobar> <1d> <2d> <3d> <4d>"),
        (long)-1, (long)-2, (long)-3, (long)-4, (long)-5);

    return cErrors;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\genutil.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       General control utility functions
//
//-------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CTRLUTIL_HXX_
#define X_CTRLUTIL_HXX_
#include "ctrlutil.hxx"
#endif

DWORD
FormsDrawDiagonalLine(HDC hdc, LPRECT lprc, int iDirection, int iThickness, UINT flags)
{
    RECT    rc;
    LPINT   py;
    int     cx;
    int     cy;
    int     dx;
    int     dy;
    LPINT   pc;
    int     cxBorder = GetSystemMetrics(SM_CXBORDER);
    int     cyBorder = GetSystemMetrics(SM_CYBORDER);

    if (IsRectEmpty(lprc))
        return(0L);

    CopyRect(&rc, lprc);

    //
    // We draw slopes < 1 by varying y instead of x.
    //
    --iThickness;

    // HACK HACK HACK. REMOVE THIS ONCE MARLETT IS AROUND
    cy = rc.bottom - rc.top;
    cx = rc.right - rc.left;

    if (!flags && (cy != cx))
        cy -= iThickness * cyBorder;

    if (cy >= cx)
    {
        // "slope" is >= 1, so vary x by 1
        cy /= cx;
        pc = &cy;

        cx = cxBorder;
    }
    else
    {
        // "slope" is < 1, so vary y by 1
        cx /= cy;
        pc = &cx;

        cy = cyBorder;
    }

    dx = cx;
    dy = iDirection * cy;

    *pc = (*pc + iThickness) * cyBorder;

    rc.right -= cx;
    rc.bottom -= cy;

    // For negative slopes, start from opposite side.
    if (iDirection < 0)
        py = (int *)&rc.top;
    else
        py = (int *)&rc.bottom;

    while ((rc.left <= rc.right) && (rc.top <= rc.bottom))
    {
        if (!(flags & BF_MIDDLE))
            PatBlt(hdc, rc.left, *py, cx, cy, PATCOPY);
        else
        {
            // Fill interior.  We can determine vertex in interior
            // by vector define.

            if (cy > cyBorder)
            {
                if (flags & BF_LEFT)
                    PatBlt(hdc, rc.left, lprc->top, cx, *py - lprc->top + cy, PATCOPY);
                else
                    PatBlt(hdc, rc.left, *py, cx, lprc->bottom - *py, PATCOPY);
            }
            else
            {
                if (flags & BF_TOP)
                    PatBlt(hdc, rc.left, *py, lprc->right - rc.left, cy, PATCOPY);
                else
                    PatBlt(hdc, lprc->left, *py, rc.left - lprc->left + cx, cy, PATCOPY);
            }
        }

        rc.left += dx;
        *py -= dy;
    }

    return(MAKELONG(cx, cy));
}


BOOL
FormsDrawCheckMark(HDC hdc, LPRECT lprc, int iThickness)
{
    int i = (lprc->right - lprc->left + 2) / 3;
    int saveRight = lprc->right;

    lprc->top += ((lprc->bottom - lprc->top - (i * 2)) / 2) + i - 1;
    lprc->bottom = lprc->top + i + (iThickness - 1);

    lprc->left += (lprc->right - lprc->left - ((i * 3) - 1)) / 2;

    lprc->right = lprc->left + i - 1;
    FormsDrawDiagonalLine(hdc, lprc, -1, iThickness, 0);
    lprc->top -= i;
    lprc->left = lprc->right;
    lprc->right = saveRight;
    FormsDrawDiagonalLine(hdc, lprc, 1, iThickness, 0);
    return(TRUE);
}


const int HAIRLINE_IN_HIMETRICS = 26;

BOOL
FormsDrawGlyph(CDrawInfo * pDI, LPGDIRECT prc, UINT wType, UINT wState)
{
    COLORREF crSaveBkColor=0;           // save background color
    COLORREF crSaveFrColor=0;           // save foreground color
    INT nTechnology     = GetDeviceCaps(pDI->_hdc, TECHNOLOGY);
    INT nNumColors      = GetDeviceCaps(pDI->_hdc, NUMCOLORS);
    DWORD dwDCObjType   = GetObjectType(pDI->_hdc);
    HDC     hdcMem      = NULL;
    HBITMAP hbmMem      = NULL;
    HBITMAP oldhbmMem   = NULL;

    int nHeight, nWidth;

    // this function only handles buttons...
    Assert (wType == DFC_BUTTON);


    nHeight = prc->bottom - prc->top;
    nWidth = prc->right - prc->left;

    switch (nTechnology)
    {
// WINCEREVIEW: no support for  DT_METAFILE:
#ifndef WINCE
    case DT_METAFILE:
        Assert(dwDCObjType == OBJ_ENHMETADC || dwDCObjType == OBJ_METADC);
#endif // WINCE
    case DT_RASPRINTER:
    case DT_PLOTTER:
        if (nNumColors == 2)                            // if this is a black and white printer
        {
            crSaveBkColor = GetBkColor(pDI->_hdc);      // save the back color
            crSaveFrColor = GetTextColor(pDI->_hdc);    // save the fore color
            SetBkColor(pDI->_hdc, RGB(255, 255, 255));
            SetTextColor(pDI->_hdc, RGB(0, 0, 0));
        }

        switch(dwDCObjType)
        {
        case    OBJ_ENHMETADC:
// WINCEREVIEW: no support for  DT_METAFILE:
#ifndef WINCE
        case    OBJ_METADC:
#endif // WINCE
            if (nNumColors == 2)                        // if this is a black and white printer
            {
                hdcMem = CreateCompatibleDC(TLS(hdcDesktop));
                if (hdcMem)
                {
                    hbmMem = CreateCompatibleBitmap(TLS(hdcDesktop), nWidth, nHeight);
                    if (hbmMem)
                    {
                        GDIRECT rcMem;

                        rcMem.top = rcMem.left = 0;
                        rcMem.right = nWidth;
                        rcMem.bottom = nHeight;

                        oldhbmMem = (HBITMAP)SelectObject(hdcMem, hbmMem);
                        BitBlt(hdcMem, 0, 0, nWidth, nHeight, hdcMem, 0, 0, WHITENESS);
// causes an assert in the bitBlt code....  why would we want to do this anyhow?
//                        BitBlt(pDI->_hdc, prc->left, prc->top,
//                                            nWidth, nHeight, pDI->_hdc, 0, 0, WHITENESS);
                        DrawFrameControl(hdcMem, &rcMem, wType, wState);

                        BitBlt(pDI->_hdc, prc->left, prc->top,
                                            nWidth, nHeight, XHDC(hdcMem, NULL), 0, 0, SRCCOPY);
                        SelectObject(hdcMem, oldhbmMem);
                        DeleteDC(hdcMem);
                        DeleteObject(hbmMem);
                        DeleteObject(oldhbmMem);
                        break;
                    }
                    DeleteDC(hdcMem);
                }
            }

            // if something wrong, fall through
        default:
            DrawFrameControl(pDI->_hdc, prc, wType, wState);
        }
        if (nNumColors == 2)                            // if this is a black and white printer
        {
          SetBkColor(pDI->_hdc, crSaveBkColor);       // restore the back color
          SetTextColor(pDI->_hdc, crSaveFrColor);     // restore the fore color
        }
        break;
    default:
        DrawFrameControl(pDI->_hdc, prc, wType, wState);
    } // end of swtich

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\gwnd.cxx ===
//+-------------------------------------------------------------------------
//
//  File:       gwnd.cxx
//
//  Contents:   Class implementation for CFormsGlobalWindow and helpers.
//
//--------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL     0x00400000L // Right to left mirroring
#else
#error "WS_EX_LAYOUTRTL is already defined in winuser.h"
#endif

PerfDbgTag(tagPerfWatch, "Perf", "PerfWatch: Trace MSHTML performance points")

MtDefine(THREADSTATE, PerThread, "THREADSTATE")
MtDefine(CTlsOptionAry, PerThread, "CTlsOptionAry::_pv")
MtDefine(CTlsDocAry, PerThread, "CTlsDocAry::_pv")
MtDefine(CTlsDocSvrAry, PerThread, "CTlsDocSvrAry::_pv")

#define WM_METHODCALL (WM_APP + 2)

extern void DwnCacheOnSettingsChange(WPARAM wParam, LPARAM lParam);

struct TIMERENTRY
{
    void *              pvObject;
    PFN_VOID_ONTICK     pfnOnTick;
    UINT                idTimer;
    UINT                idTimerAlias;
};


//this thing is for Win9x only, uses assumption that pointer and DWORD is the same size,
//so turn it off in compile for other platforms (like 64-bit)
#ifdef _M_IX86

/*
   Stack corruption protection for Win9x.

    16-bit code in Win9x GDI (and may be in User too) checks old 16-bit-world 
    assumption that at the very bottom of the stack (that can't be more then 64K 
    for this code) there is a "stack header" - 16-byte structure used to kep 
    local heep and atom table in 16-bit process...
    Of course when this code calls into 32-bit code and this 32-bit code eats 
    more then 64K of stack, it's possible to overwrite that "stack header" and, 
    depending on whether that area was overwritten, by what data and what 16-bit 
    code called us and some other things, we could get 16-bit GDI code to panic 
    about stack being trashed and bail and not to draw something.
    System seems to make an attempt to avoid such a problem (I can't tell for sure
    , but I think it's what I've seen in the debugger) in case when stack is not 
    yet commited into depth more then 64K. Then "stack header" is separated from 
    the stack by non-commited page(s) and system could see if that thing gets 
    overwritten. However if the stack was once quite extended, it could happen 
    that thunk will place "stack header" into a page that connects with stack by 
    contiguous range of commited pages so system doesn't get a chance to notice 16
    -bit stack overflow and can't correct it.
    The proposed fix is to save "stack header" on entry into our WindowProc and 
    restore it on exit. That involves walking 15 4K pages down starting from the 
    next page after the one pointed by ESP (we don't know where SS of 16-bit code is based) 
    and if any of them are commited - save 16bytes from the beginning into a buffer. 
    Restore on exit.

    The usage of this class - create an instance of it on stack on entry to WindProc
    and it will automatically do work in constructor/destructor.


    Note: the same is used in CServer::WndProc.
 */

CWin9xStackSave::CWin9xStackSave()
{
    if(VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        //start from the page that is next down the stack from the current one
        _startPageAddr = (((DWORD)this) - W95_PAGE_SIZE) & ~(W95_PAGE_SIZE-1);
        DWORD curPageAddr = _startPageAddr;
        for(int i=0; i<W95_STACK_MAX_PAGES; i++)
        {

            MEMORY_BASIC_INFORMATION pageInfo;
            if(    VirtualQuery((void*)curPageAddr, &pageInfo, sizeof(pageInfo))
                && pageInfo.Protect == PAGE_READWRITE
                && pageInfo.State == MEM_COMMIT
              )
            {
                memcpy(_buffer + i*W95_STACK_BUF_SIZE, (void*)curPageAddr, W95_STACK_BUF_SIZE);
                _fSaved[i] = true;
            }    
            else
                _fSaved[i] = false;
            
            curPageAddr -= W95_PAGE_SIZE;
        }
    }
}

CWin9xStackSave::~CWin9xStackSave()
{
    if(VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        //need two passes because first is calling into kernel and who knows
        //how much stack they consume so they can override what we are restoring.

        int i;
        DWORD curPageAddr = _startPageAddr;
        for(i=0; i<W95_STACK_MAX_PAGES; i++)
        {
            if(_fSaved[i])
            {
                //need to probe again because pages can become un-commited bacause 
                MEMORY_BASIC_INFORMATION pageInfo;
                if(    !VirtualQuery((void*)curPageAddr, &pageInfo, sizeof(pageInfo))
                    || pageInfo.Protect != PAGE_READWRITE
                    || pageInfo.State != MEM_COMMIT
                  )
                {
                    _fSaved[i] = false; //if page become not accessible, don't restore it
                }
            }
            curPageAddr -= W95_PAGE_SIZE;
        }

        curPageAddr = _startPageAddr;
        for(i=0; i<W95_STACK_MAX_PAGES; i++)
        {
            if(_fSaved[i])
            {
                memcpy((void*)curPageAddr, _buffer + i*W95_STACK_BUF_SIZE, W95_STACK_BUF_SIZE);
            }
            curPageAddr -= W95_PAGE_SIZE;
        }
    }
}

#endif

// We have to do this because of the forward declare in thread state.
MtDefine(CAryTimers, PerThread, "CAryTimers")
MtDefine(CAryTimers_pv, CAryTimers, "CAryTimers::_pv")
DECLARE_CDataAry(CAryTimers, TIMERENTRY, Mt(CAryTimers), Mt(CAryTimers_pv))

struct CALLENTRY
{
    void *              pvObject;
    PFN_VOID_ONCALL     pfnOnCall;
    DWORD_PTR           dwContext;
#if DBG==1 || defined(PERFTAGS)
    char *              pszOnCall;
#endif
};

// We have to do this because of the forward declare in thread state.

MtDefine(CAryCalls, PerThread, "CAryCalls")
MtDefine(CAryCalls_pv, CAryCalls, "CAryCalls::_pv")
DECLARE_CDataAry(CAryCalls, CALLENTRY, Mt(CAryCalls), Mt(CAryCalls_pv))

// Menu stuff

static void  *              s_pvCommand = NULL;
static PFN_VOID_ONCOMMAND   s_pfnOnCommand;

// Mouse capture

LRESULT CALLBACK GWMouseProc(int  nCode, WPARAM  wParam, LPARAM  lParam);

extern void                 DllUpdateSettings(UINT msg);

#if DBG==1 || defined(PERFTAGS)
char *
DecodeMessage(UINT msg)
{
    switch (msg)
    {
        case WM_NULL:               return("WM_NULL");
        case WM_CREATE:             return("WM_CREATE");
        case WM_DESTROY:            return("WM_DESTROY");
        case WM_MOVE:               return("WM_MOVE");
        case WM_SIZE:               return("WM_SIZE");
        case WM_ACTIVATE:           return("WM_ACTIVATE");
        case WM_SETFOCUS:           return("WM_SETFOCUS");
        case WM_KILLFOCUS:          return("WM_KILLFOCUS");
        case WM_ENABLE:             return("WM_ENABLE");
        case WM_SETREDRAW:          return("WM_SETREDRAW");
        case WM_SETTEXT:            return("WM_SETTEXT");
        case WM_GETTEXT:            return("WM_GETTEXT");
        case WM_GETTEXTLENGTH:      return("WM_GETTEXTLENGTH");
        case WM_PAINT:              return("WM_PAINT");
        case WM_CLOSE:              return("WM_CLOSE");
        case WM_QUERYENDSESSION:    return("WM_QUERYENDSESSION");
        case WM_QUERYOPEN:          return("WM_QUERYOPEN");
        case WM_ENDSESSION:         return("WM_ENDSESSION");
        case WM_QUIT:               return("WM_QUIT");
        case WM_ERASEBKGND:         return("WM_ERASEBKGND");
        case WM_SYSCOLORCHANGE:     return("WM_SYSCOLORCHANGE");
        case WM_THEMECHANGED :      return("WM_THEMECHANGED");
        case WM_SHOWWINDOW:         return("WM_SHOWWINDOW");
        case WM_WININICHANGE:       return("WM_WININICHANGE");
        case WM_DEVMODECHANGE:      return("WM_DEVMODECHANGE");
        case WM_ACTIVATEAPP:        return("WM_ACTIVATEAPP");
        case WM_FONTCHANGE:         return("WM_FONTCHANGE");
        case WM_TIMECHANGE:         return("WM_TIMECHANGE");
        case WM_CANCELMODE:         return("WM_CANCELMODE");
        case WM_SETCURSOR:          return("WM_SETCURSOR");
        case WM_MOUSEACTIVATE:      return("WM_MOUSEACTIVATE");
        case WM_CHILDACTIVATE:      return("WM_CHILDACTIVATE");
        case WM_QUEUESYNC:          return("WM_QUEUESYNC");
        case WM_GETMINMAXINFO:      return("WM_GETMINMAXINFO");
        case WM_PAINTICON:          return("WM_PAINTICON");
        case WM_ICONERASEBKGND:     return("WM_ICONERASEBKGND");
        case WM_NEXTDLGCTL:         return("WM_NEXTDLGCTL");
        case WM_SPOOLERSTATUS:      return("WM_SPOOLERSTATUS");
        case WM_DRAWITEM:           return("WM_DRAWITEM");
        case WM_MEASUREITEM:        return("WM_MEASUREITEM");
        case WM_DELETEITEM:         return("WM_DELETEITEM");
        case WM_VKEYTOITEM:         return("WM_VKEYTOITEM");
        case WM_CHARTOITEM:         return("WM_CHARTOITEM");
        case WM_SETFONT:            return("WM_SETFONT");
        case WM_GETFONT:            return("WM_GETFONT");
        case WM_SETHOTKEY:          return("WM_SETHOTKEY");
        case WM_GETHOTKEY:          return("WM_GETHOTKEY");
        case WM_QUERYDRAGICON:      return("WM_QUERYDRAGICON");
        case WM_COMPAREITEM:        return("WM_COMPAREITEM");
        case WM_COMPACTING:         return("WM_COMPACTING");
        case WM_COMMNOTIFY:         return("WM_COMMNOTIFY");
        case WM_WINDOWPOSCHANGING:  return("WM_WINDOWPOSCHANGING");
        case WM_WINDOWPOSCHANGED:   return("WM_WINDOWPOSCHANGED");
        case WM_POWER:              return("WM_POWER");
        case WM_COPYDATA:           return("WM_COPYDATA");
        case WM_CANCELJOURNAL:      return("WM_CANCELJOURNAL");
        case WM_NOTIFY:             return("WM_NOTIFY");
        case WM_INPUTLANGCHANGEREQUEST: return("WM_INPUTLANGCHANGEREQUEST");
        case WM_INPUTLANGCHANGE:    return("WM_INPUTLANGCHANGE");
        case WM_TCARD:              return("WM_TCARD");
        case WM_HELP:               return("WM_HELP");
        case WM_USERCHANGED:        return("WM_USERCHANGED");
        case WM_NOTIFYFORMAT:       return("WM_NOTIFYFORMAT");
        case WM_CONTEXTMENU:        return("WM_CONTEXTMENU");
        case WM_STYLECHANGING:      return("WM_STYLECHANGING");
        case WM_STYLECHANGED:       return("WM_STYLECHANGED");
        case WM_DISPLAYCHANGE:      return("WM_DISPLAYCHANGE");
        case WM_GETICON:            return("WM_GETICON");
        case WM_SETICON:            return("WM_SETICON");
        case WM_NCCREATE:           return("WM_NCCREATE");
        case WM_NCDESTROY:          return("WM_NCDESTROY");
        case WM_NCCALCSIZE:         return("WM_NCCALCSIZE");
        case WM_NCHITTEST:          return("WM_NCHITTEST");
        case WM_NCPAINT:            return("WM_NCPAINT");
        case WM_NCACTIVATE:         return("WM_NCACTIVATE");
        case WM_GETDLGCODE:         return("WM_GETDLGCODE");
        case WM_SYNCPAINT:          return("WM_SYNCPAINT");
        case WM_NCMOUSEMOVE:        return("WM_NCMOUSEMOVE");
        case WM_NCLBUTTONDOWN:      return("WM_NCLBUTTONDOWN");
        case WM_NCLBUTTONUP:        return("WM_NCLBUTTONUP");
        case WM_NCLBUTTONDBLCLK:    return("WM_NCLBUTTONDBLCLK");
        case WM_NCRBUTTONDOWN:      return("WM_NCRBUTTONDOWN");
        case WM_NCRBUTTONUP:        return("WM_NCRBUTTONUP");
        case WM_NCRBUTTONDBLCLK:    return("WM_NCRBUTTONDBLCLK");
        case WM_NCMBUTTONDOWN:      return("WM_NCMBUTTONDOWN");
        case WM_NCMBUTTONUP:        return("WM_NCMBUTTONUP");
        case WM_NCMBUTTONDBLCLK:    return("WM_NCMBUTTONDBLCLK");
        case WM_KEYDOWN:            return("WM_KEYDOWN");
        case WM_KEYUP:              return("WM_KEYUP");
        case WM_CHAR:               return("WM_CHAR");
        case WM_DEADCHAR:           return("WM_DEADCHAR");
        case WM_SYSKEYDOWN:         return("WM_SYSKEYDOWN");
        case WM_SYSKEYUP:           return("WM_SYSKEYUP");
        case WM_SYSCHAR:            return("WM_SYSCHAR");
        case WM_SYSDEADCHAR:        return("WM_SYSDEADCHAR");
        case WM_IME_STARTCOMPOSITION:   return("WM_IME_STARTCOMPOSITION");
        case WM_IME_ENDCOMPOSITION: return("WM_IME_ENDCOMPOSITION");
        case WM_IME_COMPOSITION:    return("WM_IME_COMPOSITION");
        case WM_INITDIALOG:         return("WM_INITDIALOG");
        case WM_COMMAND:            return("WM_COMMAND");
        case WM_SYSCOMMAND:         return("WM_SYSCOMMAND");
        case WM_TIMER:              return("WM_TIMER");
        case WM_HSCROLL:            return("WM_HSCROLL");
        case WM_VSCROLL:            return("WM_VSCROLL");
        case WM_INITMENU:           return("WM_INITMENU");
        case WM_INITMENUPOPUP:      return("WM_INITMENUPOPUP");
        case WM_MENUSELECT:         return("WM_MENUSELECT");
        case WM_MENUCHAR:           return("WM_MENUCHAR");
        case WM_ENTERIDLE:          return("WM_ENTERIDLE");
        case WM_CTLCOLORMSGBOX:     return("WM_CTLCOLORMSGBOX");
        case WM_CTLCOLOREDIT:       return("WM_CTLCOLOREDIT");
        case WM_CTLCOLORLISTBOX:    return("WM_CTLCOLORLISTBOX");
        case WM_CTLCOLORBTN:        return("WM_CTLCOLORBTN");
        case WM_CTLCOLORDLG:        return("WM_CTLCOLORDLG");
        case WM_CTLCOLORSCROLLBAR:  return("WM_CTLCOLORSCROLLBAR");
        case WM_CTLCOLORSTATIC:     return("WM_CTLCOLORSTATIC");
        case WM_MOUSEMOVE:          return("WM_MOUSEMOVE");
        case WM_LBUTTONDOWN:        return("WM_LBUTTONDOWN");
        case WM_LBUTTONUP:          return("WM_LBUTTONUP");
        case WM_LBUTTONDBLCLK:      return("WM_LBUTTONDBLCLK");
        case WM_RBUTTONDOWN:        return("WM_RBUTTONDOWN");
        case WM_RBUTTONUP:          return("WM_RBUTTONUP");
        case WM_RBUTTONDBLCLK:      return("WM_RBUTTONDBLCLK");
        case WM_MBUTTONDOWN:        return("WM_MBUTTONDOWN");
        case WM_MBUTTONUP:          return("WM_MBUTTONUP");
        case WM_MBUTTONDBLCLK:      return("WM_MBUTTONDBLCLK");
        case WM_MOUSEWHEEL:         return("WM_MOUSEWHEEL");
        case WM_PARENTNOTIFY:       return("WM_PARENTNOTIFY");
        case WM_ENTERMENULOOP:      return("WM_ENTERMENULOOP");
        case WM_EXITMENULOOP:       return("WM_EXITMENULOOP");
        case WM_NEXTMENU:           return("WM_NEXTMENU");
        case WM_SIZING:             return("WM_SIZING");
        case WM_CAPTURECHANGED:     return("WM_CAPTURECHANGED");
        case WM_MOVING:             return("WM_MOVING");
        case WM_POWERBROADCAST:     return("WM_POWERBROADCAST");
        case WM_DEVICECHANGE:       return("WM_DEVICECHANGE");
        case WM_MDICREATE:          return("WM_MDICREATE");
        case WM_MDIDESTROY:         return("WM_MDIDESTROY");
        case WM_MDIACTIVATE:        return("WM_MDIACTIVATE");
        case WM_MDIRESTORE:         return("WM_MDIRESTORE");
        case WM_MDINEXT:            return("WM_MDINEXT");
        case WM_MDIMAXIMIZE:        return("WM_MDIMAXIMIZE");
        case WM_MDITILE:            return("WM_MDITILE");
        case WM_MDICASCADE:         return("WM_MDICASCADE");
        case WM_MDIICONARRANGE:     return("WM_MDIICONARRANGE");
        case WM_MDIGETACTIVE:       return("WM_MDIGETACTIVE");
        case WM_MDISETMENU:         return("WM_MDISETMENU");
        case WM_ENTERSIZEMOVE:      return("WM_ENTERSIZEMOVE");
        case WM_EXITSIZEMOVE:       return("WM_EXITSIZEMOVE");
        case WM_DROPFILES:          return("WM_DROPFILES");
        case WM_MDIREFRESHMENU:     return("WM_MDIREFRESHMENU");
        case WM_IME_SETCONTEXT:     return("WM_IME_SETCONTEXT");
        case WM_IME_NOTIFY:         return("WM_IME_NOTIFY");
        case WM_IME_CONTROL:        return("WM_IME_CONTROL");
        case WM_IME_COMPOSITIONFULL:    return("WM_IME_COMPOSITIONFULL");
        case WM_IME_SELECT:         return("WM_IME_SELECT");
        case WM_IME_CHAR:           return("WM_IME_CHAR");
        case WM_IME_KEYDOWN:        return("WM_IME_KEYDOWN");
        case WM_IME_KEYUP:          return("WM_IME_KEYUP");
        case WM_MOUSEHOVER:         return("WM_MOUSEHOVER");
        case WM_MOUSELEAVE:         return("WM_MOUSELEAVE");
        case WM_CUT:                return("WM_CUT");
        case WM_COPY:               return("WM_COPY");
        case WM_PASTE:              return("WM_PASTE");
        case WM_CLEAR:              return("WM_CLEAR");
        case WM_UNDO:               return("WM_UNDO");
        case WM_RENDERFORMAT:       return("WM_RENDERFORMAT");
        case WM_RENDERALLFORMATS:   return("WM_RENDERALLFORMATS");
        case WM_DESTROYCLIPBOARD:   return("WM_DESTROYCLIPBOARD");
        case WM_DRAWCLIPBOARD:      return("WM_DRAWCLIPBOARD");
        case WM_PAINTCLIPBOARD:     return("WM_PAINTCLIPBOARD");
        case WM_VSCROLLCLIPBOARD:   return("WM_VSCROLLCLIPBOARD");
        case WM_SIZECLIPBOARD:      return("WM_SIZECLIPBOARD");
        case WM_ASKCBFORMATNAME:    return("WM_ASKCBFORMATNAME");
        case WM_CHANGECBCHAIN:      return("WM_CHANGECBCHAIN");
        case WM_HSCROLLCLIPBOARD:   return("WM_HSCROLLCLIPBOARD");
        case WM_QUERYNEWPALETTE:    return("WM_QUERYNEWPALETTE");
        case WM_PALETTEISCHANGING:  return("WM_PALETTEISCHANGING");
        case WM_PALETTECHANGED:     return("WM_PALETTECHANGED");
        case WM_HOTKEY:             return("WM_HOTKEY");
        case WM_PRINT:              return("WM_PRINT");
        case WM_PRINTCLIENT:        return("WM_PRINTCLIENT");
        case WM_USER:               return("WM_USER");
        case WM_USER+1:             return("WM_USER+1");
        case WM_USER+2:             return("WM_USER+2");
        case WM_USER+3:             return("WM_USER+3");
        case WM_USER+4:             return("WM_USER+4");
    }

    return("");
}

char *
DecodeWindowClass(HWND hwnd)
{
    static char ach[40];
    ach[0] = 0;
    GetClassNameA(hwnd, ach, sizeof(ach));
    return(ach);
}

#endif

//+-------------------------------------------------------------------------
//
//  Method:     ResetTimer
//
//  Synopsis:   Resets the timer identified by dwCookie.  ResetTimer
//              results in the timer setting being changed for the
//              given timer without allocating a new, unique timer id.
//
//--------------------------------------------------------------------------

static HRESULT
ResetTimer(void * pvObject, UINT idTimer, UINT uTimeout)
{
    TIMERENTRY *    pte;
    int             c;
    THREADSTATE *   pts = GetThreadState();

    // Windows NT rounds the time up to 10.  If time is less 
    // than 10, NT spews to the debugger.  Work around
    // this problem by rounding up to 10.

    if (uTimeout < 10)
        uTimeout = 10;

    for (c = pts->gwnd.paryTimers->Size(), pte = *pts->gwnd.paryTimers;
        c > 0;
        c--, pte++)
    {
        if ((pte->pvObject == pvObject) && (pte->idTimer == idTimer))
        {
            if (SetTimer(pts->gwnd.hwndGlobalWindow,
                    pte->idTimerAlias, uTimeout, NULL) == 0)
            {
                RRETURN(E_FAIL);
            }

            return S_OK;
        }
    }

    return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     OnTimer
//
//  Synopsis:   Handles timer event from the global window.
//
//--------------------------------------------------------------------------

static void  CALLBACK
OnTimer(HWND hwnd, UINT id)
{
    TIMERENTRY *    pte;
    int             c;
    THREADSTATE *   pts = GetThreadState();

    PerfDbgLog(tagPerfWatch, NULL, "+Gwnd OnTimer");

    for (c = pts->gwnd.paryTimers->Size(), pte = *pts->gwnd.paryTimers;
        c > 0;
        c--, pte++)
    {
        if (pte->idTimerAlias == id)
        {
            PerfDbgLog(tagPerfWatch, NULL, "+Gwnd OnTimer OnTick");

            CALL_METHOD((CVoid *)pte->pvObject,pte->pfnOnTick,(pte->idTimer));

            PerfDbgLog(tagPerfWatch, NULL, "-Gwnd OnTimer OnTick");

            break;
        }
    }

    PerfDbgLog(tagPerfWatch, NULL, "-Gwnd OnTimer");
}


//+-------------------------------------------------------------------------
//
//  Method:     OnCommand
//
//  Synopsis:   Handles menu commands.
//
//--------------------------------------------------------------------------

static void
OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (s_pvCommand != NULL)
    {
        CALL_METHOD((CVoid *)s_pvCommand, s_pfnOnCommand, (id, hwndCtl, codeNotify));
        s_pvCommand = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     GetUniqueID
//
//  Synopsis:   Fetches a unique timer ID by checking our sorted array
//              of used IDs for a new value.
//
//--------------------------------------------------------------------------

static UINT
GetUniqueID()
{
    THREADSTATE *   pts;
    int             c;
    TIMERENTRY *    pte;
    BOOL            fDone = FALSE;

    pts = GetThreadState();
    while (fDone == FALSE)
    {
        pts->gwnd.uID++;

        // Note: We don't use the range 0x0000 through 0x1FFF.  This is
        // reserved for hard-coded timer identifiers.  Compuserve incorrectly
        // intercepts timer id 0x000F, which is yet another reason for doing
        // this.

        if (pts->gwnd.uID < 0x2000)
        {
            pts->gwnd.uID = 0x2000;
        }

        fDone = TRUE;

        for (c = (*(pts->gwnd.paryTimers)).Size(), pte = *(pts->gwnd.paryTimers);
            c > 0;
            c--, pte++)
        {
            if (pts->gwnd.uID == pte->idTimerAlias)
            {
                fDone = FALSE;
                break;
            }
        }
    }

    return pts->gwnd.uID;
}

//+-------------------------------------------------------------------------
//
//  Function:   FormsSetTimer
//
//  Synopsis:   Sets a timer using the forms global window.
//
//  Arguments:  [pGWS]      Pointer to a timer sink
//              [idTimer]   Caller-specified id that will be passed back
//                          on a timer event.
//              [uTimeout]  Elapsed time between timer events
//
//--------------------------------------------------------------------------

HRESULT
FormsSetTimer(
        void *pvObject,
        PFN_VOID_ONTICK pfnOnTick,
        UINT idTimer, UINT uTimeout)
{
    THREADSTATE *   pts;
    UINT            idTimerAlias;
    HRESULT         hr;

    Assert(pvObject);

    pts = GetThreadState();

    if (pts->gwnd.hwndGlobalWindow == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Attempt to reset the timer.  If this fails, ie, no matching
    //  timer exists, continue on and set the timer.
    //

    hr = ResetTimer(pvObject, idTimer, uTimeout);
    if (hr == S_OK)
        goto Cleanup;

    hr = (*(pts->gwnd.paryTimers)).EnsureSize((*(pts->gwnd.paryTimers)).Size() + 1);
    if (hr)
        goto Cleanup;

    idTimerAlias = GetUniqueID();

    if (    g_dwPlatformID == VER_PLATFORM_WIN32_NT
        &&  g_dwPlatformVersion >= 0x00050000
        )
    {
        // NOTE
        // Windows NT 5.0 rounds the time up to 10.  If time is less 
        // than 10, it spews to the debugger.  Work around
        // this problem by rounding up to 10.

        if (uTimeout < 10)
            uTimeout = 10;
    }

    if (SetTimer(pts->gwnd.hwndGlobalWindow, idTimerAlias, uTimeout, NULL) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].pvObject = pvObject;
    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].pfnOnTick = pfnOnTick;
    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].idTimerAlias = idTimerAlias;
    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].idTimer = idTimer;
    (*(pts->gwnd.paryTimers)).SetSize((*(pts->gwnd.paryTimers)).Size() + 1);

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Function:   FormsKillTimer
//
//  Synopsis:   Kills a forms timer.
//
//  Arguments:  [dwCookie]  Cookie identifying the timer.  Obtained from
//                          FormsSetTimer.
//
//--------------------------------------------------------------------------

HRESULT
FormsKillTimer(void * pvObject, UINT idTimer)
{
    extern DWORD g_dwTls;
    THREADSTATE *   pts;
    TIMERENTRY *    pte;
    int             i, c;
    UINT            idTimerAlias;

    // Note: We do not use pts = GetThreadState() function because
    // this function is called from the DLL process detach
    // code after TlsGetValue() has ceased to function correctly.
    // This scenario is probably a result of a bug in Windows '95.
    pts = (THREADSTATE *)(TlsGetValue(g_dwTls));
    if (!pts || pts->gwnd.paryTimers == NULL)
        return S_FALSE;

    for (c = (*(pts->gwnd.paryTimers)).Size(), i = 0, pte = (*(pts->gwnd.paryTimers));
        c > 0;
        c--, i++, pte++)
    {
        if ((pte->pvObject == pvObject) && (pte->idTimer == idTimer))
        {
            idTimerAlias = pte->idTimerAlias;
            (*(pts->gwnd.paryTimers)).Delete(i);
            KillTimer(TLS(gwnd.hwndGlobalWindow), idTimerAlias);
            return S_OK;
        }
    }
    return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   FormsTrackPopupMenu
//
//  Synopsis:   Allows windowless controls to use the global window for
//              command routing of popup menu selection.
//
//--------------------------------------------------------------------------

HRESULT
FormsTrackPopupMenu(
        HMENU hMenu,
        UINT fuFlags,
        int x,
        int y,
        HWND hwndMessage,
        int *piSelection)
{
    BOOL    fAvail;
    HRESULT hr = S_OK;
    MSG     msg;
    HWND    hwnd;

    hwnd = (hwndMessage) ? (hwndMessage) : (TLS(gwnd.hwndGlobalWindow));

    if (::TrackPopupMenu(hMenu, fuFlags, x, y, 0, hwnd, (RECT *)NULL))
    {
        // The menu popped up and the item was chosen.  Peek messages
        // until the specified command was found.
        fAvail = PeekMessage(&msg,
            hwnd,
            WM_COMMAND,
            WM_COMMAND,
            PM_REMOVE);

        if (fAvail)
        {
            *piSelection = GET_WM_COMMAND_ID(msg.wParam, msg.lParam);
            hr = S_OK;
        }
        else
        {
            // No WM_COMMAND was available, so this means that the
            // menu was brought down
            hr = S_FALSE;
        }
    }
    else
    {
        hr = GetLastWin32Error();
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Function:   InvalidateProcessWindow
//
//--------------------------------------------------------------------------

static BOOL CALLBACK
InvalidateProcessWindow(HWND hwnd, LPARAM lparam)
{
    DWORD dwProcessId;

    GetWindowThreadProcessId(hwnd, &dwProcessId);
    if (dwProcessId == (DWORD)lparam && hwnd)
    {
        RedrawWindow(
            hwnd,
            NULL,
            NULL,
            RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
    }
    return TRUE;
}

void InvalidateProcessWindows()
{
    EnumWindows(InvalidateProcessWindow, GetCurrentProcessId());
}

//+-------------------------------------------------------------------------
//
//  Function:   _GWPostMethodCallEx
//
//  Synopsis:   Call given method on given object a later time.
//              It is the caller's responsiblity to insure that the
//              object remains valid until the call is made or the
//              posted call is killed.
//
//  Arguments:  pvObject    The object
//              pfnOnCall   Method to call.
//              dwContext   Context for method
//
//--------------------------------------------------------------------------

HRESULT _GWPostMethodCallEx(THREADSTATE * pts, void *pvObject,
    PFN_VOID_ONCALL pfnOnCall, DWORD_PTR dwContext, BOOL fIgnoreContext
#if DBG==1 || defined(PERFTAGS)
    , char * pszOnCall
#endif
    )
{
    HRESULT         hr;
    CALLENTRY *     pce;
    int             c;

    EnterCriticalSection(&pts->gwnd.cs);

    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject == pvObject &&
            pce->pfnOnCall == pfnOnCall &&
            pce->dwContext == dwContext &&
            !fIgnoreContext)
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    c = pts->gwnd.paryCalls->Size();

    hr = (*(pts->gwnd.paryCalls)).EnsureSize(c + 1);
    if (hr)
        goto Cleanup;

    (*(pts->gwnd.paryCalls)).SetSize(c + 1);

    pce = &(*(pts->gwnd.paryCalls))[c];

    pce->pvObject = pvObject;
    pce->pfnOnCall = pfnOnCall;
    pce->dwContext = dwContext;

#if DBG==1 || defined(PERFTAGS)
    pce->pszOnCall = pszOnCall;
#endif

    if (!pts->gwnd.fMethodCallPosted)
    {
        if (!PostMessage(pts->gwnd.hwndGlobalWindow, WM_METHODCALL, 0, 0))
        {
            hr = GetLastWin32Error();

            // If PostMessage failed, we need to remove the CALLENTRY we just added, or
            // someone's going to get a callback they're not expecting!
            (*(pts->gwnd.paryCalls)).SetSize(c);
            goto Cleanup;
        }

        pts->gwnd.fMethodCallPosted = TRUE;
    }

Cleanup:
    LeaveCriticalSection(&pts->gwnd.cs);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   GWKillMethodCallEx
//
//  Synopsis:   Kill method call posted with GWPostMethodCall.
//
//  Arguments:  pvObject    The object
//              pfnOnCall   Method to call.  If null, kills all calls
//                          for pvObject.
//              dwContext   Context.  If zero, kills all calls for pvObject
//                          and pfnOnCall.
//
//--------------------------------------------------------------------------

void
GWKillMethodCallEx(THREADSTATE * pts, void *pvObject, PFN_VOID_ONCALL pfnOnCall,
    DWORD_PTR dwContext)
{
    CALLENTRY *     pce;
    int             c;

    // Handle pts being NULL for
    Assert(pts);

    // check for no calls before entering critical sectcd ion
    if (!pts || !(pts->gwnd.paryCalls) || (pts->gwnd.paryCalls->Size() == 0))
        return;

    EnterCriticalSection(&pts->gwnd.cs);

    // Null pointer instead of deleting array element to
    // handle calls to this function when OnMethodCall
    // is iterating over the array.

    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject == pvObject)
        {
            if (pfnOnCall == NULL)
            {
                pce->pvObject = NULL;
            }
            else if (pce->pfnOnCall == pfnOnCall)
            {
                if (pce->dwContext == dwContext || dwContext == 0)
                {
                    pce->pvObject = NULL;
                }
            }
        }
    }

    LeaveCriticalSection(&pts->gwnd.cs);
}

void
GWKillMethodCall(void *pvObject, PFN_VOID_ONCALL pfnOnCall, DWORD_PTR dwContext)
{
    GWKillMethodCallEx(GetThreadState(), pvObject, pfnOnCall, dwContext);
}

#if DBG == 1

BOOL
GWHasPostedMethod( void *pvObject )
{
    extern DWORD    g_dwTls;
    THREADSTATE *   pts = (THREADSTATE *)(TlsGetValue(g_dwTls));
    CALLENTRY *     pce;
    int             c;
    BOOL            fRet = FALSE;

    if (!pts)
        return FALSE;

    EnterCriticalSection(&pts->gwnd.cs);

    // Null pointer instead of deleting array element to
    // handle calls to this function when OnMethodCall
    // is iterating over the array.

    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject == pvObject)
        {
            fRet = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&pts->gwnd.cs);

    return fRet;
}

#endif

//+-------------------------------------------------------------------------
//
//  Funciton:   GlobalWndOnMethodCall
//
//  Synopsis:   Handles deferred method calls.
//
//--------------------------------------------------------------------------

void
GlobalWndOnMethodCall()
{
    THREADSTATE *   pts = GetThreadState();
    CALLENTRY *     pce;
    CALLENTRY *     pceLive;
    int             i;
    int             c;

    PerfDbgLog(tagPerfWatch, NULL, "+Gwnd OnMethodCall");

    //
    // Re-enable posting of layout messages because the function call
    // could cause us to enter a modal loop and then OnMethodCall would
    // not process further messages.  This will happen if the function
    // call fires an event procedure that calls Userform.Show in VB.
    //

    EnterCriticalSection(&pts->gwnd.cs);

    pts->gwnd.fMethodCallPosted = FALSE;

    // Stress bug fix for bug # 31985.
    if (! pts->gwnd.paryCalls)
        goto Cleanup;

    for (i = 0; i < (*(pts->gwnd.paryCalls)).Size(); i++)
    {
        // Pointer into array is fetched at every iteration in order
        // to handle calls to GWPostMethodCall during the loop.

        pce = &(*(pts->gwnd.paryCalls))[i];
        if (pce->pvObject)
        {
            CALLENTRY ce = *pce;
            pce->pvObject = NULL;

            LeaveCriticalSection(&pts->gwnd.cs);

            PerfDbgLog1(tagPerfWatch, NULL, "+Gwnd OnMethodCall (%s)", ce.pszOnCall);

            CALL_METHOD((CVoid *)ce.pvObject, ce.pfnOnCall, (ce.dwContext));

            PerfDbgLog1(tagPerfWatch, NULL, "-Gwnd OnMethodCall (%s)", ce.pszOnCall);

            EnterCriticalSection(&pts->gwnd.cs);

            //
            // DO NOT USE pce after the method call - if the object calls
            // GWPostMethodCall it may cause gwnd.paryCalls to do a ReAlloc,
            // which invalidates pce!
            //

            // Stress bug fix for bug # 31985.  pts->gwnd.paryCalls could be
            // deleted during the method call above.
            if (! pts->gwnd.paryCalls)
                goto Cleanup;
        }
    }

    pceLive = (*(pts->gwnd.paryCalls));
    i = 0;
    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject)
        {
            *pceLive++ = *pce;
            i++;
        }
    }

    (*(pts->gwnd.paryCalls)).SetSize(i);

Cleanup:
    LeaveCriticalSection(&pts->gwnd.cs);

    PerfDbgLog(tagPerfWatch, NULL, "-Gwnd OnMethodCall");
}

//+-------------------------------------------------------------------------
//
//  Function:   GWSetCapture
//
//  Synopsis:   Capture the mouse.
//
//--------------------------------------------------------------------------

HRESULT
GWSetCapture(void *pvObject, PFN_VOID_ONMESSAGE pfnOnMouseMessage, HWND hwnd)
{
    THREADSTATE *   pts;

    Assert(pvObject);

    pts = GetThreadState();

    if (pvObject != pts->gwnd.pvCapture)
    {
        if (pts->gwnd.pvCapture)
            CALL_METHOD((CVoid *)pts->gwnd.pvCapture, pts->gwnd.pfnOnMouseMessage,
                        (WM_CAPTURECHANGED, 0, 0));
        pts->gwnd.pvCapture = pvObject;
        pts->gwnd.pfnOnMouseMessage = pfnOnMouseMessage;
        pts->gwnd.hwndCapture = hwnd;
    }

    if (GetCapture() != TLS(gwnd.hwndGlobalWindow))
    {
        SetCapture(TLS(gwnd.hwndGlobalWindow));

        if (((g_dwPlatformID == VER_PLATFORM_WIN32_NT) ||
             (g_dwPlatformID == VER_PLATFORM_WIN32_UNIX)) &&
            !pts->gwnd.hhookGWMouse)
        {
            pts->gwnd.hhookGWMouse = SetWindowsHookEx(
                                           WH_MOUSE,
                                           GWMouseProc,
                                           (HINSTANCE) NULL, GetCurrentThreadId());
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   GWReleaseCapture
//
//  Synopsis:   Release the mouse capture.
//
//--------------------------------------------------------------------------

void
GWReleaseCapture(void *pvObject)
{
    THREADSTATE *   pts;

    Assert(pvObject);

    pts = GetThreadState();

    if (pts->gwnd.pvCapture == pvObject)
    {
        CVoid * pvCapture = (CVoid *) pts->gwnd.pvCapture;
        pts->gwnd.pvCapture = NULL;
        CALL_METHOD(pvCapture,pts->gwnd.pfnOnMouseMessage,(WM_CAPTURECHANGED, 0, 0));

        if (((g_dwPlatformID == VER_PLATFORM_WIN32_NT) ||
             (g_dwPlatformID == VER_PLATFORM_WIN32_UNIX)) && 
            pts->gwnd.hhookGWMouse)
        {
            UnhookWindowsHookEx(pts->gwnd.hhookGWMouse);
            pts->gwnd.hhookGWMouse = NULL;
        }

        if (GetCapture() == TLS(gwnd.hwndGlobalWindow))
        {
#if DBG==1
            Assert(!TLS(fHandleCaptureChanged));
#endif DBG==1
            ReleaseCapture();
        }
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   GWGetCapture
//
//  Synopsis:   Return the object that has captured the mouse.
//
//--------------------------------------------------------------------------

BOOL
GWGetCapture(void * pvObject)
{
    if (GetCapture() == TLS(gwnd.hwndGlobalWindow))
        return pvObject == TLS(gwnd.pvCapture);
    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   GWMouseProc
//
//  Synopsis:   Mouse proc for the global window.  This mouse hook is installed
//              under WinNT when the global window has mouse capture and removed
//              when it releases capture.  Under windows 95, the global window
//              receives WM_CAPTURECHANGED messages and this hook isn't necessary.
//              Under WinNT this mouse proc simulates the WM_CAPTURECHANGED.
//
//  TODO - This global mouse proc should be modified  so that WM_CAPTURECHANGED
//           is sent to all forms3 windows when mouse capture changes.
//--------------------------------------------------------------------------

LRESULT CALLBACK 
GWMouseProc(int  nCode, WPARAM  wParam, LPARAM  lParam)
{
    if (nCode < 0)  /* do not process the message */
        return CallNextHookEx(TLS(gwnd.hhookGWMouse), nCode,
            wParam, lParam);

    if (nCode == HC_ACTION)
    {
        MOUSEHOOKSTRUCT *   pmh = (MOUSEHOOKSTRUCT *) lParam;

        if (wParam >= WM_MOUSEFIRST &&
            wParam <= WM_MOUSELAST &&
            TLS(gwnd.pvCapture) &&
            pmh->hwnd != TLS(gwnd.hwndGlobalWindow))
        {
            GWReleaseCapture(TLS(gwnd.pvCapture));
        }
    }

    // Stress scenario where we have already been shut down and the DLL is just leaving. GWReleaseCapture 
    // sends a capture update message before it unhooks the mouse hook, causing this code to execute at 
    // an inopportune time.
    if (GetThreadState())
    {
        return CallNextHookEx(TLS(gwnd.hhookGWMouse), nCode, wParam, lParam);
    }
    else
    {
        return 0;   // MSDN tells to return 0 if we are not delegating to the CallNextHookEx...
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   GlobalWndProc
//
//  Synopsis:   Window proc for the global window
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
GlobalWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PerfDbgLog4(tagPerfWatch, NULL, "+GlobalWndProc msg=%04lX (%s) hwnd=%lX (%s)",
                msg, DecodeMessage(msg), hwnd, DecodeWindowClass(hwnd));

#ifdef _M_IX86
    //stack corruption protection for Win9x. See definition of CWin9xStackSave.
    CWin9xStackSave stackSave;
#endif
/* 260 bytes - try 255 and it will break travel.js (bug 108309)
BYTE aryTest[sizeof(CWin9xStackSave)];
memset(aryTest,0xFF,sizeof(CWin9xStackSave));
*/

    extern DWORD g_dwTls;
    THREADSTATE *   pts;
    LRESULT         lRet = 0;
    LONG            lDllCount;
    BOOL            fCallDefWndProc = FALSE;

    // (paulnel) Turn off mirroring if the system supports it. This will *really* mess us up.
    if (msg == WM_NCCREATE)
    {
        DWORD dwExStyles;
        if ((dwExStyles = GetWindowLong(hwnd, GWL_EXSTYLE)) & WS_EX_LAYOUTRTL)
        {
            SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles &~ WS_EX_LAYOUTRTL);
        }
    }

    pts = (THREADSTATE *)TlsGetValue(g_dwTls);
    lDllCount = pts ? pts->dll.lObjCount : 0;

    // We need to guard against a Release() call made during
    // message processing causing the ref count to go to zero 
    // and the TLS getting blown away.  This will be done
    // by manually adjusting the counter (to be fast) and 
    // only call DecrementObjectCount if necessary.

    if (lDllCount)
        Verify(++pts->dll.lObjCount > 0);

#ifdef _MAC
    if ( msg == WM_MACINTOSH && LOWORD(wParam) == WLM_SETMENUBAR)
            // dont change the menu bar
                return TRUE;
    if ((msg >= WM_LBUTTONDOWN) && msg <= WM_LBUTTONDBLCLK)
    {
        // We only want to process the Left Button messages
        MacSimulateMouseButtons (msg, wParam);
    }
#endif

    if (WM_THEMECHANGED == msg)
    {
        TraceTag((tagError, "Processing theme change"));
        DllUpdateSettings(msg);
    }

    CHECK_HEAP();

    // Note: When adding new messages to this loop do the 
    //       following:
    //  - Handle the message
    //  - set lRet to be the lResult to return (if not 0)
    //  - set fCallDefWndProc to TRUE if DefWindowProc() should
    //    be called (default is to NOT call DefWindowProc())
    //  - use 'break' to exit the switch statement
    
    switch (msg)
    {
    case WM_TIMER:
        OnTimer(hwnd, (UINT)wParam);
        break;

    HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        
    case WM_METHODCALL:
        GlobalWndOnMethodCall();
        break;    

    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MBUTTONDBLCLK:
        if (pts && pts->gwnd.pvCapture)
        {
            POINT  pt;
            pt.x = MAKEPOINTS(lParam).x;
            pt.y = MAKEPOINTS(lParam).y;
            ScreenToClient(pts->gwnd.hwndCapture, &pt);
            lRet = CALL_METHOD((CVoid *)pts->gwnd.pvCapture, pts->gwnd.pfnOnMouseMessage,
                               (msg,
                                wParam,
                                MAKELONG(pt.x, pt.y)));
        }
        else
        {
            fCallDefWndProc = TRUE;
        }
        break;

    case WM_CAPTURECHANGED:
#if DBG==1
        TLS(fHandleCaptureChanged) = TRUE;
#endif DBG==1

        if (pts && pts->gwnd.pvCapture)
        {
            CVoid * pvCapture = (CVoid *) pts->gwnd.pvCapture;
#if DBG == 1
            BOOL fHasHook = pts->gwnd.hhookGWMouse != NULL ;
#endif

            lRet = CALL_METHOD(pvCapture, pts->gwnd.pfnOnMouseMessage,
                               (msg,
                                wParam,
                                lParam));

            pts->gwnd.pvCapture = 0;                                

            AssertSz( ! fHasHook || ! pts->gwnd.hhookGWMouse, 
                      "There's still a Mouse Proc on the thread state. But you don't have capture anymore.");
        }
        else
        {
            fCallDefWndProc = TRUE;
        }
#if DBG==1
        TLS(fHandleCaptureChanged) = FALSE;
#endif DBG==1
        break;

    // case WM_WININICHANGE: obsolete, should not be used anymore
    // replaced with WM_SETTINGCHANGE (which has the same ID, but uses wParam)    
    case WM_SETTINGCHANGE:
        DwnCacheOnSettingsChange(wParam, lParam);
        // Fall through
    case WM_SYSCOLORCHANGE:
    case WM_DEVMODECHANGE:
    case WM_FONTCHANGE:
#if(WINVER >= 0x0400)
    case WM_DISPLAYCHANGE:
#endif
    case WM_USER + 338:         // sent by properties change dialog
        TraceTag((tagError, "Processing system change %d", msg));
        DllUpdateSettings(msg);
        break;

    default:
        fCallDefWndProc = TRUE;
        goto Cleanup;
    }

    CHECK_HEAP();

Cleanup:

    if (lDllCount && pts->dll.lObjCount == 1)
    {
        // TLS about to go away.  Let the Passivates occur
        // and then say we handled the message.  Since
        // DecrementObjectCount plays with the secondary
        // count as well we need to increment it as well.

        IncrementSecondaryObjectCount( 3 );
        DecrementObjectCount(NULL);
        lRet = 0;
    }
    else
    {
        if (lDllCount)
            Verify(--pts->dll.lObjCount >= 0);
        if (fCallDefWndProc)
        {
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
        }
    }

    PerfDbgLog(tagPerfWatch, NULL, "-GlobalWndProc");

    return lRet;

}


//+-------------------------------------------------------------------------
//
//  Function:   DeinitGlobalWindow
//
//--------------------------------------------------------------------------

void
DeinitGlobalWindow(
    THREADSTATE *   pts)
{
    Assert(pts);

#if DBG==1
    if (pts->gwnd.paryTimers)
    {
        Assert((*(pts->gwnd.paryTimers)).Size() == 0);
    }
    if (pts->gwnd.paryCalls)
    {
        for (int i = 0; i < (*(pts->gwnd.paryCalls)).Size(); i++)
        {
            Assert((*(pts->gwnd.paryCalls))[i].pvObject == NULL);
        }
    }
#endif

    if (pts->gwnd.paryCalls)
        (*(pts->gwnd.paryCalls)).DeleteAll();

    // Delete per-thread dynamic arrays
    delete pts->gwnd.paryTimers;
    pts->gwnd.paryTimers = NULL;

    delete pts->gwnd.paryCalls;
    pts->gwnd.paryCalls = NULL;

    if (pts->gwnd.hwndGlobalWindow)
    {
#if !defined(_MAC)
        if (pts->dll.idThread == GetCurrentThreadId())
            Verify(DestroyWindow(pts->gwnd.hwndGlobalWindow));
#endif

        // NOTE: if we're on the wrong thread we can't destroy the window

        pts->gwnd.hwndGlobalWindow = NULL;

        DeleteCriticalSection(&pts->gwnd.cs);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   InitGlobalWindow
//
//  Synopsis:   Initializes and creates the global hwnd.
//
//--------------------------------------------------------------------------
extern ATOM GetWndClassAtom(UINT uIndex);
extern void SetWndClassAtom(UINT uIndex, ATOM atomWndClass);
extern enum WNDCLASS_TYPES;

HRESULT
InitGlobalWindow(
    THREADSTATE *   pts)
{
    HRESULT     hr = S_OK;
    TCHAR * pszBuf;

    Assert(pts);

#if !defined(_MAC) 
    // Create the per-thread "global" window
    if (!GetWndClassAtom(WNDCLASS_HIDDEN))
    {
        hr = THR(RegisterWindowClass(
                WNDCLASS_HIDDEN,
                GlobalWndProc,
                0,
                NULL,
                NULL));
        if (hr)
            goto Error;
    }
#endif // _MAC

#if defined(_MAC)
    TCHAR szBuf[128];
    GlobalGetAtomName(GetWndClassAtom(WNDCLASS_HIDDEN), szBuf, ARRAY_SIZE(szBuf));
    pszBuf = szBuf;
#else
    pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_HIDDEN); 
#endif

#if defined(_MAC) 
	pts->gwnd.hwndGlobalWindow = (HWND) GlobalWndProc;
#else
    pts->gwnd.hwndGlobalWindow = TW32(NULL, CreateWindow(
            pszBuf,
            NULL,
            WS_POPUP,
            0, 0, 0, 0,
            NULL,
            NULL,
            g_hInstCore,
            NULL));
    if (pts->gwnd.hwndGlobalWindow == NULL)
    {
        hr = GetLastWin32Error();
        goto Error;
    }
#endif // _MAC

    hr = HrInitializeCriticalSection(&pts->gwnd.cs);
    if (hr)
        goto Error;

    // Allocate per-thread dynamic arrays
    pts->gwnd.paryTimers = new CAryTimers;
    pts->gwnd.paryCalls  = new CAryCalls;
    if (!pts->gwnd.paryTimers || !pts->gwnd.paryCalls)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

Error:
    RRETURN(hr);
}

#ifdef _MAC // MACTODO:  don't think this function is necessary anymore ???
Boolean GWMouseCaptured(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
	Boolean Result = false;
	
	switch ( msg )
	{
		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
		 	if ( ::GetCapture() == TLS(gwnd.hwndGlobalWindow) )
		 	{
				(*plResult) = GlobalWndProc(nil, msg, wParam, lParam);
				Result = true;
			}
			break;
			
		default:
			break;
	}
	
	return Result;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\help.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       help.cxx
//
//  Contents:   Helpers for help
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

EXTERN_C const GUID LIBID_MSHTML;
EXTERN_C const GUID CLSID_HTMLDocument;

//+-------------------------------------------------------------------------
//
//  Function:   FormsHelp
//
//  Synopsis:   Helper for WinHelp
//
//  Arguments:  [uCmd]      type of help - see WinHelp
//              [dwData]    additional data - see WinHelp
//
//--------------------------------------------------------------------------

HRESULT
FormsHelp(TCHAR * szHelpFile, UINT uCmd, DWORD dwData)
{
    BOOL        fRet;

    fRet = WinHelp(
                TLS(gwnd.hwndGlobalWindow),
                szHelpFile,
                uCmd,
                dwData);

    RRETURN(fRet ? S_OK : E_FAIL);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetTypeInfoForCLSID
//
//  Synopsis:   Gets the TypeInfo for the CLSID by chasing through the
//              registry and into the TypeLib.
//
//--------------------------------------------------------------------------

HRESULT
GetTypeInfoForCLSID(HKEY hkRoot, REFCLSID clsid, ITypeInfo ** ppTI)
{
    OLECHAR       szGuidTyp[128];
    TCHAR       szVersion[128];
    TCHAR       szTypeLib[128];
    IID         iid;
    ITypeLib *  pTypeLib = NULL;
    ITypeInfo * pTypeInfo;
    long        cb;
    long        err;
    HKEY        hkType = NULL;
    HRESULT     hr;

    // Get TypeLib GUID.
    Format(0, szGuidTyp, ARRAY_SIZE(szGuidTyp), _T("<0g>\\TypeLib"), &clsid);
    cb = ARRAY_SIZE(szGuidTyp) * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkRoot, szGuidTyp, szGuidTyp, &cb));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Translate the guid from the registry into an iid.
    hr = THR(IIDFromString(szGuidTyp, &iid));
    if (hr)
        goto Cleanup;

    // See if this idd matches our TypeLib.
    if (IsEqualIID(iid, LIBID_MSHTML))
    {
        hr = THR(LoadF3TypeInfo(clsid, &pTypeInfo));
        if (!hr)
            goto Complete;

        goto Cleanup;
    }

    // Get Version.
    Format(0, szVersion, ARRAY_SIZE(szVersion), _T("<0g>\\Version"), &clsid);
    cb = ARRAY_SIZE(szVersion) * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkRoot, szVersion, szVersion, &cb));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Open TypeLib key.
    err = TW32_NOTRACE(1,RegOpenKey(HKEY_CLASSES_ROOT,TEXT("TypeLib"),&hkType));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // CONSIDER - At some point getting the localized TypeLib.  Here we always
    // get the default TypeLib. (rodc)
    //
    // Get TypeLib path and filename.
    Format(0, szTypeLib, ARRAY_SIZE(szTypeLib), _T("<0s>\\<1s>\\0\\win32"),
            szGuidTyp,
            szVersion);
    cb = ARRAY_SIZE(szTypeLib) * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkType, szTypeLib, szTypeLib, &cb));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Load the type library.
    hr = THR(LoadTypeLib(szTypeLib, &pTypeLib));
    if (hr)
        goto Cleanup;

    // Get the type info for this specific classid.
    hr = THR(pTypeLib->GetTypeInfoOfGuid(clsid, &pTypeInfo));
    if (hr)
        goto Cleanup;

Complete:
    *ppTI = pTypeInfo;

Cleanup:
    if (hkType)
        RegCloseKey(hkType);
    ReleaseInterface(pTypeLib);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetDocumentationForCLSID
//
//  Synopsis:   Gets the TypeInfo documentation for the CLSID.
//
//--------------------------------------------------------------------------

HRESULT
GetDocumentationForCLSID(
        HKEY hkRoot,
        REFCLSID clsid,
        BSTR * pbstrName,
        DWORD * pdwHelpContextId,
        BSTR * pbstrHelpFile)
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT     hr;

    // Get the TypeInfo for this specific classid.
    hr = THR_NOTRACE(GetTypeInfoForCLSID(hkRoot, clsid, &pTypeInfo));
    if (hr)
        goto Cleanup;

    // Get the documentation for this classid from the TypeInfo.
    hr = THR(pTypeInfo->GetDocumentation(
            MEMBERID_NIL,
            pbstrName,
            NULL,
            pdwHelpContextId,
            pbstrHelpFile));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pTypeInfo);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetNameForCLSID
//
//  Synopsis:   Gets the name for the CLSID.
//
//--------------------------------------------------------------------------

HRESULT
GetNameForCLSID(HKEY hkRoot, REFCLSID clsid, TCHAR * szName, int cch)
{
    TCHAR       szUser[128];
    BSTR        bstrName = NULL;
    long        cb;
    long        err;
    HRESULT     hr;

    Assert(szName);

    // Otherwise, try the name for this classid.
    hr = THR_NOTRACE(GetDocumentationForCLSID(
            hkRoot,
            clsid,
            &bstrName,
            NULL,
            NULL));
    if (!hr)
    {
        // If we got the name, copy it and get out.
        _tcsncpy(szName, bstrName, cch);
        goto Cleanup;
    }

    // Next, try to get the AuxUserType name.
    Format(0, szUser, ARRAY_SIZE(szUser), _T("<0g>\\AuxUserType\\2"), &clsid);
    cb = cch * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkRoot, szUser, szName, &cb));
    if (err == ERROR_SUCCESS)
    {
        // If we got the name, get out.
        hr = S_OK;
        goto Cleanup;
    }

    // Finally, if nothing else worked, load unknown.
    if (LoadString(GetResourceHInst(), IDS_UNKNOWN, szName, cch))
        hr = S_OK;
    else
        hr = GetLastWin32Error();

Cleanup:
    FormsFreeString(bstrName);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetHelpForCLSID
//
//  Synopsis:   Gets the help for the CLSID.
//
//--------------------------------------------------------------------------

HRESULT
GetHelpForCLSID(
        HKEY hkRoot,
        REFCLSID clsid,
        DWORD * pdwId,
        TCHAR * szHelpFile,
        int cch)
{
    BSTR        bstrHelp = NULL;
    HRESULT     hr;

    // Get the help info for this classid.
    hr = THR_NOTRACE(GetDocumentationForCLSID(
            hkRoot,
            clsid,
            NULL,
            pdwId,
            &bstrHelp));
    if (hr)
        goto Cleanup;

    // If we didn't get a help path\name, then get out.
    if (!bstrHelp || !FormsStringLen(bstrHelp))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // If we got the name, copy it and get out.
    _tcsncpy(szHelpFile, bstrHelp, cch);

Cleanup:
    FormsFreeString(bstrHelp);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     OnDialogHelp
//
//  Synopsis:   Display dialog box's help
//
//--------------------------------------------------------------------------

HRESULT
OnDialogHelp(
        CBase * pBase,
        HELPINFO * phi, 
        DWORD dwHelpContextID) 
{
    HRESULT     hr;
    TCHAR       szPath[_MAX_PATH];
    HKEY        hkRoot = NULL;

    // Get the key to the CLSID root.
    hr = THR(RegDbOpenCLSIDKey(&hkRoot));
    if (hr)
        goto Cleanup;

    // Get the help file name.
    hr = THR_NOTRACE(GetHelpForCLSID(
            hkRoot,
            CLSID_HTMLDocument,
            NULL,
            szPath,
            ARRAY_SIZE(szPath)));
    if (hr)
        goto Cleanup;

    _tcscat(szPath, _T(">LangRef"));

    BOOL    fRet;
    
    fRet = WinHelp(
            TLS(gwnd.hwndGlobalWindow), 
            szPath, 
            HELP_CONTEXT, 
            dwHelpContextID);
    hr = THR(fRet ? S_OK : E_FAIL);
Cleanup:
    if (hkRoot)
        Verify(RegCloseKey(hkRoot) == ERROR_SUCCESS);
    RRETURN(hr);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\hashatomtbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       hashatomtbl.cxx
//
//  History:    t-rajatg     Created
//
//  Contents:   CHashAtomTable implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HASHATOMTBL_HXX_
#define X_HASHATOMTBL_HXX_
#include "hashatomtbl.hxx"
#endif

MtDefine(CHashAtomTable, Utilities, "CHashAtomTable")
MtDefine(CHashAtomTable_pv, CHashAtomTable, "CHashAtomTable::_pv")
MtDefine(HashAtomTable, Mem, "CHashAtomTable")
MtDefine(Atom, HashAtomTable, "CHashAtomTable<SAtom>")
MtDefine(CIndexAtom_ary, HashAtomTable, "CIndexAtom_ary")
MtDefine(CHtEnt_ary, HashAtomTable, "CHtEnt_ary")

BOOL CHashAtomTable::CompareIt(const void *pObject, const void *pvKeyPassedIn, const void *pvVal2)
{
    CHtEnt *    pary;
    SAtom *     pAtom;
    SAtomProbe *pap;

    pap = (SAtomProbe*)pvKeyPassedIn;
    pary = (CHtEnt *)pvVal2;

    Assert( pary && pary->Size() );

    if (!pap->_fStatsComputed)
    {
        pap->_cch = CountWithAsciiCheck(pap->_pch, &(pap->_fAllAscii));
        pap->_fStatsComputed = TRUE;
    }

    pAtom = *((SAtom **)pary->Deref(sizeof(SAtom *), 0));

    if (    pAtom->_cch != pap->_cch
        ||  !!(BOOL)pAtom->_fAllAscii != !!(BOOL)pap->_fAllAscii)
        return FALSE;

    if (pap->_fAllAscii)
    {
        return !StrCmpNICW(pap->_pch, pAtom->_ach, pAtom->_cch);
    }
    else
    {
        return _tcsiequal(pAtom->_ach, pap->_pch);
    }
}
long 
CHashAtomTable::CountWithAsciiCheck(LPCTSTR pch, BOOL * pfAllAscii)
{
    WHEN_DBG( LPCTSTR pchOrig = pch );
    long cch = 0;
    *pfAllAscii = TRUE;

    while( *pch )
    {
        if (*pch > 0x7f)
            *pfAllAscii = FALSE;
        cch++;
        pch++;
    }

    Assert( (ULONG)cch == _tcslen(pchOrig) );

    return cch;
}

HRESULT
CHashAtomTable::AddNameToAtomTable(LPCTSTR pch, long *plId)
{
    HRESULT     hr = S_OK;
    long        lId = 0;
    long        cch;
    BOOL        fAllAscii;
    CHtEnt *    pPtrAry = NULL;
    SAtom *     pAtom = NULL;
    BOOL        fPtrAryNew = FALSE;

    Assert( pch );

    // Do a case sensitive search for the element
    if (GetAtomFromName(pch, NULL, &lId, TRUE, FALSE) != DISP_E_MEMBERNOTFOUND)
    {
        if (plId)
        {
            *plId = lId;
        }

        goto Cleanup;
    }

    //
    // Not found, so add element
    //
    Assert( _dwCacheHash != 0 );

    // Create the atom

    // count the string and look for ascii-ness
    cch = CountWithAsciiCheck(pch, &fAllAscii);

    pAtom = (SAtom *)MemAlloc(Mt(Atom), sizeof(SAtom) + sizeof(TCHAR)*(cch+1));
    if (!pAtom)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    Assert(lId == _aryId.Size());

    pAtom->_cch = cch;
    pAtom->_lId = lId;
    pAtom->_fAllAscii = fAllAscii;
    _tcsncpy(pAtom->_ach, pch, cch+1);

    // Add the atom to the id list
    hr = _aryId.Append(pAtom);
    if (hr)
        goto Error;

    // Add the atom to the case insensitive list
    {
        pPtrAry = _pHtCacheEnt;

        if (!pPtrAry)
        {
            pPtrAry = new CHtEnt;
            if (!pPtrAry)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
            fPtrAryNew = TRUE;
        }

        // Add new data to the end of Structure
        hr = pPtrAry->Append(pAtom);
        if (hr)
            goto Error;

        // Do insert
        if (fPtrAryNew)
        {
#if DBG==1
            SAtomProbe ap = {0};
            ap._pch = pch;
#endif

            hr = _htStr.Insert(ULongToPtr(_dwCacheHash), (void*)pPtrAry DBG_COMMA WHEN_DBG((void*)&ap) );
            if (hr)
                goto Error;
        }

    }

    if (plId)
    {
        *plId = lId;
    }

Cleanup:
    RRETURN(hr);

Error:
    // Clean up the atom
    delete pAtom;

    // Clean up _aryId
    _aryId.DeleteByValue(pAtom);

    // Clean up the pPtrAry
    if (fPtrAryNew)
    {
        delete pPtrAry;
    }
    else if (pPtrAry)
    {
        pPtrAry->DeleteByValue(pAtom);
    }

    // The hash table is the last thing we do, so no cleanup necessary

    goto Cleanup;
}

HRESULT
CHashAtomTable::AddNameWithID(LPCTSTR pch, long lId)
{
    HRESULT     hr = S_OK;
    SAtom *     pAtom = NULL;
    DWORD       dwCacheHash;
    BOOL        fAllAscii;
    CHtEnt *    pHtCacheEnt;
    BOOL        fHtEntNew = FALSE;
    long        cch;
    SAtomProbe	ap = {0};

    Assert( pch );

    // We shouldn't have this already in the table
    Assert( GetAtomFromName(pch, NULL, NULL, TRUE, FALSE) == DISP_E_MEMBERNOTFOUND );

    // The ID must be the next one in sequence
    Assert( lId == _aryId.Size() );

    dwCacheHash = HashStringCiDetectW(pch, _tcslen(pch), 0) << 2;
    if (dwCacheHash == 0)
        dwCacheHash = (1<<2);

    ap._pch = pch;

    if (S_OK != _htStr.LookupSlow(ULongToPtr(dwCacheHash), (void*)&ap, (void**)&pHtCacheEnt))
    {
        // We didn't find a case insensitive list in the hash table so add one
        pHtCacheEnt = new CHtEnt;
        if (!pHtCacheEnt)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        fHtEntNew = TRUE;

    }

    // Create the atom

    // count the string and look for ascii-ness
    cch = CountWithAsciiCheck(pch, &fAllAscii);

    pAtom = (SAtom *)MemAlloc(Mt(Atom), sizeof(SAtom) + sizeof(TCHAR)*(cch+1));
    if (!pAtom)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pAtom->_cch = cch;
    pAtom->_lId = lId;
    pAtom->_fAllAscii = fAllAscii;
    _tcsncpy(pAtom->_ach, pch, cch+1);

    // Append to the ID array
    hr = _aryId.Append(pAtom);
    if (hr)
        goto Error;

    // Append to the end of the case insensitive list
    hr = pHtCacheEnt->Append(pAtom);
    if (hr)
        goto Error;

    if (fHtEntNew)
    {
        // Do insert into hash table -- must come after pAtom is added to pHtCacheEnt
        hr = _htStr.Insert(ULongToPtr(dwCacheHash), (void*)pHtCacheEnt DBG_COMMA WHEN_DBG((void*)&ap) );
        if (hr)
            goto Error;
    }

Cleanup:
    RRETURN(hr);

Error:
    // Clean up pHtCacheEnt
    if (fHtEntNew)
    {
        // Make sure that _pHtCacheEnd is out of the hash table
        delete pHtCacheEnt;
    }
    else if (pHtCacheEnt)
    {
        pHtCacheEnt->DeleteByValue(pAtom);
    }

    // Clean up the atom
    delete pAtom;

    // Clean up _aryId
    _aryId.DeleteByValue(pAtom);

    // The hash table is the last thing we do, so no cleanup necessary

    goto Cleanup;
}

MtDefine(MHashAtomTable, Metrics, "Atom Table String Matching");
MtDefine(MHashAtomTableCsCmp, MHashAtomTable, "Atom Table Case Sensitive String Compares");
MtDefine(MHashAtomTableCsiCmp, MHashAtomTable, "Atom Table Case Insensitive String Compares");

/*************************************************************************************
 * GetAtomFromName
 *
 *************************************************************************************/
HRESULT
CHashAtomTable::GetAtomFromName(LPCTSTR pch, long *plIndex, /* Use this if fStartFromGivenIndex is needed */
                            long *plId, /* USE THIS to get the EXPANDO Index */
                            BOOL fCaseSensitive /*= TRUE */,
                            BOOL fStartFromGivenIndex /* = FALSE */)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;
    long        lId = _aryId.Size();
    BOOL        fFound = FALSE;
    SAtom *     patom = NULL;
    CHtEnt *    pPtrAry;

    Assert( pch );

    if (_aryId.Size() == 0)
    {
        _dwCacheHash = HashStringCiDetectW(pch, _tcslen(pch), 0) << 2;
        if (_dwCacheHash == 0)
            _dwCacheHash = (1<<2);

        _pHtCacheEnt = NULL;
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (fCaseSensitive && _fFound && _tcsequal(pch, _pchCache))
    {
        lId = _lId;
        lIndex = _lIndex;
        patom = _psaCache;
        fFound = TRUE;
        goto Cleanup;
    }

    _dwCacheHash = HashStringCiDetectW(pch, _tcslen(pch), 0) << 2;
    if (_dwCacheHash == 0)
        _dwCacheHash = (1<<2);

    {
        SAtomProbe ap = {0};
        ap._pch = pch;

        if (_htStr.LookupSlow(ULongToPtr(_dwCacheHash), (void*)&ap, (void**)&pPtrAry))
        {
            _pHtCacheEnt = NULL;
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
    }

    // We should have a case insensitive array at this point since
    // the lookup succeeded.
    Assert( pPtrAry );

    _pHtCacheEnt = pPtrAry;

    if (fStartFromGivenIndex)
    {
        // It doesn't make sence do iterate over
        // all case insensitive matches if fCaseSensitive
        // is passed in
        Assert(!fCaseSensitive);
        Assert( plIndex );

        lIndex = *plIndex;

        // Someone shouldn't initiate this loop with an index of 0
        Assert(lIndex > 0);

        if (lIndex >= pPtrAry->Size())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        patom = *((SAtom **)pPtrAry->Deref(sizeof(SAtom *), lIndex));

        Assert(_tcsiequal(patom->_ach, pch));

        lId = patom->_lId;
        fFound = TRUE;
    }
    else
    {
        if (fCaseSensitive)
        {
            for (int i = 0; i < pPtrAry->Size(); i += 1)
            {
                patom = *((SAtom **)pPtrAry->Deref(sizeof(SAtom *), i));

                if (_tcsequal(patom->_ach, pch))
                {
                    lId = patom->_lId;
                    lIndex = i;
                    fFound = TRUE;
                    break;
                }
            }
        }
        else
        {
            patom = *((SAtom **)pPtrAry->Deref(sizeof(SAtom *), 0));
            Assert(_tcsiequal(patom->_ach, pch));
            lId = patom->_lId;
            lIndex = 0;
            fFound = TRUE;
        }

        if (!fFound)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
    }

Cleanup:
    if (fFound && fCaseSensitive)
    {
        _fFound = TRUE;
        _lId = lId;
        _lIndex = lIndex;
        _pchCache = patom->_ach;
        _psaCache = patom;
    }
    else
        _fFound = FALSE;


    if (plIndex)
    {
        *plIndex = lIndex;
    }

    if (plId)
    {
        *plId = lId;
    }

    RRETURN(hr);
}

HRESULT
CHashAtomTable::GetNameFromAtom(long lId, LPCTSTR *ppch)
{
    HRESULT hr = S_OK;
    SAtom *  patom;

    if (_aryId.Size() <= lId)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    patom = (SAtom *)_aryId[lId];
    Assert(lId == patom->_lId);
    *ppch = (TCHAR *)patom->_ach;

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

void
CHashAtomTable::Free()
{
    SAtom *     patom;
    long        i;
    CHtEnt *    pary;
    UINT        iIndex;

    for (pary = (CHtEnt *)_htStr.GetFirstEntry(&iIndex);
         pary;
         pary = (CHtEnt *)_htStr.GetNextEntry(&iIndex))
    {
        Assert(pary);
        delete pary;
    }

    _htStr.ReInit();

    for (i = 0; i < _aryId.Size(); i++)
    {
        patom = _aryId[i];
        MemFree(patom);
    }
    _aryId.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\himetric.cxx ===
//+---------------------------------------------------------------------
//
//  File:       himetric.cxx
//
//  Contents:   Routines to convert Pixels to Himetric and vice versa
//
//              These routines assume the standard {96 x 96} screen logical pixel
//              sizes.  If this could ever be invalid (for a printer, a virtual device,
//              etc...), these should not be used.  CTransform provides a more
//              flexible, but more heavyweight, way of transforming pix <-> himetric.
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_HIMETRIC_HXX_
#define X_HIMETRIC_HXX_
#include "himetric.hxx"
#endif

// This is a resolution threshold. Above it we stop treating "OM pixels"
// as 1-to-1 corresponding to screen pixel and start treating them
// as 1/96th of an inch.
// We use hi-res units (~16K DPI) when we do layout for printing.
// In this case, we will compare the "document resolution" (~16K) with
// threshold and use FIXED_PIXELS_PER_INCH for conversions between
// physical length (inches, etc) to "OM pixels" and vice versa.
// "OM pixels" are "px" sizes in HTML/CSS and units in which OM
// sets/returns sizes of elements.
// Because we calculate layout in isotropic coordinates, we don't need
// separate x- and y- resolutions here.

extern BOOL g_fUseHR;
extern BOOL g_fHiResAware;

// check only X resolution - for consistency
inline BOOL IsLowRes(LONG sizeInchX, LONG sizeInchY) 
{
    if (!(g_fUseHR && g_fHiResAware))
        return (sizeInchX < RESOLUTION_THRESHOLD);
    else
        return FALSE;
}


#ifdef PRODUCT_96
void
PixelFromHMRect(RECT *prcDest, RECTL *prcSrc)
{
    prcDest->left = HPixFromHimetric(prcSrc->left);
    prcDest->top = VPixFromHimetric(prcSrc->top);
    prcDest->right = HPixFromHimetric(prcSrc->right);
    prcDest->bottom = VPixFromHimetric(prcSrc->bottom);
}
#endif

#ifdef PRODUCT_96
void
HMFromPixelRect(RECTL *prcDest, RECT *prcSrc)
{
    prcDest->left = HimetricFromHPix(prcSrc->left);
    prcDest->top = HimetricFromVPix(prcSrc->top);
    prcDest->right = HimetricFromHPix(prcSrc->right);
    prcDest->bottom = HimetricFromVPix(prcSrc->bottom);
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   StringToHimetric
//
//  Synopsis:   Converts a numeric string with units to a himetric value.
//              Expects a NULL-terminated string.  The contents of the
//              string may be altered.
//
//              Example: "72 pt" returns 2540 and UNITS_POINT
//
//  Arguments:  [szString]  String to convert
//              [pUnits]    Returns the original units found.  NULL ok.
//              [plValue]   Resulting himetric value
//
//  QUESTION - Is atof the right thing to use here?
//
//--------------------------------------------------------------------------

HRESULT
StringToHimetric(TCHAR * pstr, UNITS * punits, long * plValue)
{
    HRESULT hr;
    int     units;
    TCHAR * pstrT;
    float   flt;
    TCHAR   achUnits[UNITS_BUFLEN];

    *plValue = 0;

    // Convert all trailing spaces to nulls so they don't confuse
    // the units.

    for (pstrT = pstr; *pstrT; pstrT++);
    do { *pstrT-- = 0; } while (*pstrT == ' ');

    //  First, see if the user specified units in the string

    for (units = UNITS_MIN; units < UNITS_UNKNOWN; units++)
    {


        Verify(LoadString(
                    GetResourceHInst(),
                    IDS_UNITS_BASE + units,
                    achUnits,
                    ARRAY_SIZE(achUnits)));

        for (pstrT = pstr; *pstrT; pstrT++)
        {
            if (!_tcsicmp(pstrT, achUnits))
            {
                *pstrT = 0;
                goto FoundMatch;
            }
        }
    }

    //  If no units are specified, use the global default

    Assert(units == UNITS_UNKNOWN);

#if NEVER // we should use UNITS_POINT in Forms3 96.
    units = g_unitsMeasure;
#else // ! NEVER
    units = UNITS_POINT;
#endif // ! NEVER

FoundMatch:

    //  Use OleAuto to convert the string to a float; this assumes
    //    that the conversion will ignore "noise" like the units
    hr = THR(VarR4FromStr(pstr, g_lcidUserDefault, 0, &flt));
    if (hr)
        goto Cleanup;

    switch (units)
    {
    case UNITS_CM:
        *plValue = (long) (flt * 1000);
        break;

    case UNITS_UNKNOWN:
    case UNITS_POINT:
        *plValue = (long) ((flt * 2540) / 72);
        break;

    case UNITS_INCH:
        *plValue = (long) (flt * 2540);
        break;

    default:
        Assert(FALSE);
        break;
    }

Cleanup:

    *punits = (UNITS) units;

    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  Function:   HimetricToString
//
//  Synopsis:   Converts a himetric value to a numeric string of the
//              specified units.
//
//              Example:  2540 and UNITS_POINT returns "72 pt"
//
//  Arguments:  [lVal]      Value to convert
//              [units]     Units to convert to
//              [szRet]     Buffer for returned string
//              [cch]       Size of buffer
//
//--------------------------------------------------------------------------

HRESULT
HimetricToString(long lVal, UNITS units, TCHAR * szRet, int cch)
{
    HRESULT     hr;
    float       flt;
    BSTR        bstr = NULL;

    Assert(units == UNITS_POINT);

    flt = UserFromHimetric(lVal);

    hr = THR(VarBstrFromR4(flt, g_lcidUserDefault, 0, &bstr));
    if (hr)
        goto Cleanup;



    hr = Format(
            0,
            szRet,
            cch,
            _T("<0s> <1i>"),
            bstr,
            GetResourceHInst(), IDS_UNITS_BASE + units);

Cleanup:
    FormsFreeString(bstr);

    RRETURN(hr);
}



#if DBG == 1
BOOL
CheckFPConversion( )
{
    long    i;
    float   xf;
    float   xf2;

    for (i = 0; i < 72 * 20; i++)
    {
        xf = i / 20.0f;
        xf2 = UserFromHimetric(HimetricFromUser(xf));

        Assert(xf == xf2);
    }

    return TRUE;
}
#endif

StartupAssert(CheckFPConversion());

//+-------------------------------------------------------------------------
//
//  Function:   UserFromHimetric
//
//  Synopsis:   Converts a himetric long value to point size float.
//
//--------------------------------------------------------------------------

float
UserFromHimetric(long lValue)
{
    //  Rounds to the nearest .05pt.  This is about the maximum
    //    precision we can get keeping things in himetric internally

#if NEVER // Should not change the default unit in Forms3 96. Use UNITS_POINT.
          // Leave this code to roll back in 97.
    switch (g_unitsMeasure)
    {
    case UNITS_CM:
        return (float)lValue / (float)1000;

    case UNITS_POINT:
    default:
        return ((float) MulDivQuick(lValue, 72 * 20, 2540)) / 20;
    }

#else // ! NEVER

    return ((float) MulDivQuick(lValue, 72 * 20, 2540)) / 20;

#endif // ! NEVER

}


//+-------------------------------------------------------------------------
//
//  Function:   HimetricFromUser
//
//  Synopsis:   Converts a point size double to himetric long.  Rounds
//              to the nearest himetric value.
//
//--------------------------------------------------------------------------

long
HimetricFromUser(float xf)
{
    long lResult;

#if NEVER // Should not change the default unit in Forms3 96. Use UNITS_POINT.
          // Leave this code to roll back in 97.
    switch (g_unitsMeasure)
    {
    case UNITS_CM:
        xf = xf * (float)1000;
        break;
    case UNITS_POINT:
    default:
        xf = xf * ( ((float)2540) / 72 );
        break;
    }

#else // ! NEVER

    xf = xf * ( ((float)2540) / 72 );

#endif // ! NEVER

    if (xf > LONG_MAX)
        lResult = LONG_MAX;
    else if (xf > .0)
        lResult = long(xf + .5);
    else if (xf < LONG_MIN)
        lResult = LONG_MIN;
    else
        lResult = long(xf - .5);

    return lResult;
}

#if DBG == 1
#include <math.h>
#pragma intrinsic(fabs)
int MulDivQuick(int nMultiplicand, int nMultiplier, int nDivisor)
{
    int nResult = (!nDivisor-1) & MulDiv(nMultiplicand, nMultiplier, nDivisor);

    Assert(nDivisor);

#ifdef _M_IX86
#define F2I_PRECISION_24         0x000  //_PC_24  0x00020000
#define F2I_PRECISION_53         0x200  //_PC_53  0x00010000
#define F2I_PRECISION_64         0x300  //_PC_64  0x00000000
#define F2I_PRECISION_MASK       0x300  //_MCW_PC 0x00030000
        unsigned cw;
        _asm fstcw cw;
        unsigned cw_saved = cw & F2I_PRECISION_MASK;
        cw = cw & ~F2I_PRECISION_MASK | F2I_PRECISION_64;
        _asm fldcw cw;

	    double dv = double(nMultiplicand)*nMultiplier
	              - double(nDivisor)*nResult;

        _asm fstcw cw;
        cw = cw & ~F2I_PRECISION_MASK | cw_saved;
        _asm fldcw cw;

	    Assert (fabs(dv) <= fabs(nDivisor*.5));
#endif
    return nResult;
}
#endif

#ifndef _M_IX86
int CFloatlet::Mul(int x) const
{
    __int64 m = Int32x32To64(x, _mult);
    int r = int(m>>(_shift-1));
    return (r+1)>>1;
}

int _stdcall CFloatlet::MulCeil(int x) const
{
    __int64 m = Int32x32To64(-x, _mult);
    return -int(m>>_shift);
}
#else //_M_IX86
#pragma warning(disable:4035)
int _declspec(naked) CFloatlet::Mul(int x) const
{
    _asm
    {
        mov eax,[esp+4] //x
        imul [ecx]._mult
        mov ecx,[ecx]._shift
        shrd eax,edx,cl
        adc eax,0
        ret 4
    }
}

int _declspec(naked) CFloatlet::MulCeil(int x) const
{
    _asm
    {
        mov eax,[esp+4] //x
        neg eax
        imul [ecx]._mult
        mov ecx,[ecx]._shift
        shrd eax,edx,cl
        neg eax
        ret 4
    }
}

// calculate ceil((a<<31)/b)
inline int __MakeRatio(unsigned a, unsigned b)
{
    _asm
    {
        mov edx,a
        xor eax,eax
        shrd eax,edx,1
        shr edx,1
        mov ebx,b
        sub ebx,1
        add eax,ebx
        adc edx,0
        div b
    }
}

#pragma warning(default:4035)
#endif


void CFloatlet::MakeRatio(unsigned a, unsigned b)
{
    {
        // the following precautions were made to surpress
        // looping when incorrect arguments are supplied (see bug 32496).
        // This will not improve the bug case (that was observed just once
        // and never reproed) but at least we wouldn't hang (mikhaill 4/25/1)
        Assert(a < 0x80000000 && b != 0);

        if (a >= 0x80000000)
            a = 0x7FFFFFFF;
        
        if (b == 0)
            b = 1;
    }

    _shift = 31;
    while (b <= a)
    {
        b <<= 1;
        _shift--;
    }
#ifdef _M_IX86
    _mult = __MakeRatio(a,b);
#else
    __int64 p = __int64(a) << 31;
    p += b-1;	// force division to generate ceil() instead of floor()
    _mult = int(p/b);
#endif
}


CUnitInfo::CUnitInfo(int dpi_x, int dpi_y, int target_dpi_x, int target_dpi_y)
{
    _SetMainResolution(dpi_x, dpi_y);
    _SetTargetResolution(target_dpi_x, target_dpi_y);
}

void
CUnitInfo::SetResolution(int dpi_x, int dpi_y)
{
    _SetMainResolution(dpi_x, dpi_y);

    Assert(this == &g_uiDisplay || this == &g_uiVirtual);
    CUnitInfo& target = this == &g_uiDisplay ? g_uiVirtual : g_uiDisplay;

    SIZE const& thisRes = GetResolution();
    SIZE const& targetRes = target.GetResolution();

    _SetTargetResolution(targetRes.cx, targetRes.cy);
    target._SetTargetResolution(thisRes.cx, thisRes.cy);
}

void
CUnitInfo::_SetMainResolution(int dpi_x, int dpi_y)
{
    _sizeInch.cx = dpi_x;
    _sizeInch.cy = dpi_y;
    if (IsLowRes(_sizeInch.cx, _sizeInch.cy))
        _sizeDocRes = _sizeInch;
    else
        _sizeDocRes.cx = _sizeDocRes.cy = FIXED_PIXELS_PER_INCH;

    if (_sizeInch.cx >= TWIPS_PER_INCH)
        _sizeMax.cx = 0x3FFFFFFF - _sizeInch.cx/2;
    else
    {
        _sizeMax.cx = MulDiv(0x3FFFFFFF, _sizeInch.cx, TWIPS_PER_INCH);
        if (Int32x32To64(_sizeMax.cx, TWIPS_PER_INCH) > Int32x32To64(0x3FFFFFFF, _sizeInch.cx))
        _sizeMax.cx--;
    }

    if (_sizeInch.cy >= TWIPS_PER_INCH)
        _sizeMax.cy = 0x3FFFFFFF - _sizeInch.cy/2;
    else
    {
        _sizeMax.cy = MulDiv(0x3FFFFFFF, _sizeInch.cy, TWIPS_PER_INCH);
        if (Int32x32To64(_sizeMax.cy, TWIPS_PER_INCH) > Int32x32To64(0x3FFFFFFF, _sizeInch.cy))
            _sizeMax.cy--;
    }

    _flDeviceFromHimetricX.MakeRatio(_sizeInch.cx, HIMETRIC_PER_INCH);
    _flDeviceFromHimetricY.MakeRatio(_sizeInch.cy, HIMETRIC_PER_INCH);

    _flDeviceFromTwipsX.MakeRatio(_sizeInch.cx, TWIPS_PER_INCH);
    _flDeviceFromTwipsY.MakeRatio(_sizeInch.cy, TWIPS_PER_INCH);

    _flDeviceFromDocPixelsX.MakeRatio(_sizeInch.cx, _sizeDocRes.cx);
    _flDeviceFromDocPixelsY.MakeRatio(_sizeInch.cy, _sizeDocRes.cy);

    _flHimetricFromDeviceX.MakeRatio(HIMETRIC_PER_INCH, _sizeInch.cx);
    _flHimetricFromDeviceY.MakeRatio(HIMETRIC_PER_INCH, _sizeInch.cy);

    _flTwipsFromDeviceX.MakeRatio(TWIPS_PER_INCH, _sizeInch.cx);
    _flTwipsFromDeviceY.MakeRatio(TWIPS_PER_INCH, _sizeInch.cy);

    _flDocPixelsFromDeviceX.MakeRatio(_sizeDocRes.cx, _sizeInch.cx);
    _flDocPixelsFromDeviceY.MakeRatio(_sizeDocRes.cy, _sizeInch.cy);
}

void
CUnitInfo::_SetTargetResolution(int target_dpi_x, int target_dpi_y)
{
    _flTargetFromDeviceX.MakeRatio(target_dpi_x, _sizeInch.cx);
    _flTargetFromDeviceY.MakeRatio(target_dpi_y, _sizeInch.cy);
}


void CUnitInfo::DeviceFromHimetric(SIZE& result, int x, int y) const
{
    result.cx = DeviceFromHimetricX(x);
    result.cy = DeviceFromHimetricY(y);
}

void CUnitInfo::DeviceFromTwips(SIZE& result, int x, int y) const
{
    result.cx = DeviceFromTwipsX(x);
    result.cy = DeviceFromTwipsY(y);
}

void CUnitInfo::DeviceFromDocPixels(SIZE& result, int x, int y) const
{
    result.cx = DeviceFromDocPixelsX(x);
    result.cy = DeviceFromDocPixelsY(y);
}

void CUnitInfo::HimetricFromDevice(SIZE& result, int x, int y) const
{
    result.cx = HimetricFromDeviceX(x);
    result.cy = HimetricFromDeviceY(y);
}

void CUnitInfo::TwipsFromDevice(SIZE& result, int x, int y) const
{
    result.cx = TwipsFromDeviceX(x);
    result.cy = TwipsFromDeviceY(y);
}

void CUnitInfo::DocPixelsFromDevice(SIZE& result, int x, int y) const
{
    result.cx = DocPixelsFromDeviceX(x);
    result.cy = DocPixelsFromDeviceY(y);
}

void CUnitInfo::DocPixelsFromDevice(RECT& rcIn, RECT& rcOut) const
{
    rcOut.left   = DocPixelsFromDeviceX(rcIn.left);
    rcOut.right  = DocPixelsFromDeviceX(rcIn.right);
    rcOut.top    = DocPixelsFromDeviceY(rcIn.top);
    rcOut.bottom = DocPixelsFromDeviceY(rcIn.bottom);
}


void 
CUnitInfo::DocPixelsFromDevice(POINT *pPt) const
{
    pPt->x = DocPixelsFromDeviceX(pPt->x);
    pPt->y = DocPixelsFromDeviceY(pPt->y);
}

void 
CUnitInfo::DeviceFromDocPixels(POINT *pPt) const
{
    pPt->x = DeviceFromDocPixelsX(pPt->x);
    pPt->y = DeviceFromDocPixelsY(pPt->y);
}

void 
CUnitInfo::DocPixelsFromDevice(RECT *pRect) const
{
    pRect->left   = DocPixelsFromDeviceX(pRect->left);
    pRect->right  = DocPixelsFromDeviceX(pRect->right);
    pRect->top    = DocPixelsFromDeviceY(pRect->top);
    pRect->bottom = DocPixelsFromDeviceY(pRect->bottom);
}

void 
CUnitInfo::DeviceFromDocPixels(RECT *pRect) const
{
    pRect->left   = DeviceFromDocPixelsX(pRect->left);
    pRect->right  = DeviceFromDocPixelsX(pRect->right);
    pRect->top    = DeviceFromDocPixelsY(pRect->top);
    pRect->bottom = DeviceFromDocPixelsY(pRect->bottom);
}

//-----------------------------
//cross-device conversion: rounding to nearest
void CUnitInfo::_TargetFromDevice(SIZE & size, CUnitInfo const & cuiTarget) const
{
    Assert(this == &g_uiDisplay && &cuiTarget == &g_uiVirtual ||
           this == &g_uiVirtual && &cuiTarget == &g_uiDisplay);

    size.cx = _flTargetFromDeviceX.Mul(size.cx);
    size.cy = _flTargetFromDeviceY.Mul(size.cy);
}

void CUnitInfo::_TargetFromDevice(RECT & rc, CUnitInfo const & cuiTarget) const
{
    SIZE size;

    Assert(this == &g_uiDisplay && &cuiTarget == &g_uiVirtual ||
           this == &g_uiVirtual && &cuiTarget == &g_uiDisplay);

    size.cx     = _flTargetFromDeviceX.Mul(rc.right - rc.left);
    size.cy     = _flTargetFromDeviceY.Mul(rc.bottom - rc.top);

    rc.left     = _flTargetFromDeviceX.Mul(rc.left);
    rc.top      = _flTargetFromDeviceY.Mul(rc.top);

    rc.right    = rc.left + size.cx;
    rc.bottom   = rc.top + size.cy;
}

CUnitInfo g_uiDisplay(96, 96, 0x4000, 0x4000);  // will be reinited in InitSystemMetricValues()
CUnitInfo g_uiVirtual(0x4000, 0x4000, 96, 96);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\htpvpv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       htpvpv.cxx
//
//  Contents:   Hash table mapping PVOID to PVOID
//
//              CHtPvPv
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTPVPV_HXX_
#define X_HTPVPV_HXX_
#include "htpvpv.hxx"
#endif

DeclareTag(tagHtPvPvGrow, "Utils", "Trace CHtPvPv Grow/Shrink")
MtDefine(CHtPvPv, Elements, "CHtPvPv")
MtDefine(CHtPvPv_pEnt, CHtPvPv, "CHtPvPv::_pEnt")

// This is here because I don't have a .cxx file to put it in
MtDefine(CNCache, Elements, "CNCache")

// Definitions ----------------------------------------------------------------

#define HtKeyEqualFast(pvKey1, pvKey2)  (((void *)((DWORD_PTR)pvKey1 & ~1L)) == (pvKey2))
#define HtKeyInUse(pvKey)           ((DWORD_PTR)pvKey > 1L)
#define HtKeyTstFree(pvKey)         (pvKey == NULL)
#define HtKeyTstBridged(pvKey)      ((DWORD_PTR)pvKey & 1L)
#define HtKeySetBridged(pvKey)      ((void *)((DWORD_PTR)pvKey | 1L))
#define HtKeyClrBridged(pvKey)      ((void *)((DWORD_PTR)pvKey & ~1L))
#define HtKeyTstRehash(pvKey)       ((DWORD_PTR)pvKey & 2L)
#define HtKeySetRehash(pvKey)       ((void *)((DWORD_PTR)pvKey | 2L))
#define HtKeyClrRehash(pvKey)       ((void *)((DWORD_PTR)pvKey & ~2L))
#define HtKeyTstFlags(pvKey)        ((DWORD_PTR)pvKey & 3L)
#define HtKeyClrFlags(pvKey)        ((void *)((DWORD_PTR)pvKey & ~3L))

#define WRAPREADER(ret, fn, arglist, args)  \
ret CTsHtPvPv::fn arglist                   \
{                                           \
    ret retval;                             \
    AvoidThreadAssert();                    \
    rwLock.ReaderClaim();                   \
    retval = CHtPvPv::fn args;              \
    rwLock.ReaderRelease();                 \
    return retval;                          \
}

#define WRAPWRITER(ret, fn, arglist, args)  \
ret CTsHtPvPv::fn arglist                   \
{                                           \
    ret retval;                             \
    AvoidThreadAssert();                    \
    rwLock.WriterClaim();                   \
    retval = CHtPvPv::fn args;              \
    rwLock.WriterRelease();                 \
    return retval;                          \
}

#define WRAPUNSAFE(ret, fn, arglist, args)  \
ret CTsHtPvPv::fn##Unsafe arglist           \
{                                           \
    ret retval;                             \
    AvoidThreadAssert();                    \
    retval = CHtPvPv::fn args;              \
    return retval;                          \
}

WRAPREADER(void *, GetFirstEntry, (UINT * iIndex), (iIndex))
WRAPREADER(void *, GetNextEntry, (UINT * iIndex), (iIndex))
WRAPREADER(void *, GetKey, (UINT iIndex), (iIndex))
WRAPUNSAFE(void *, GetFirstEntry, (UINT * iIndex), (iIndex))
WRAPUNSAFE(void *, GetNextEntry, (UINT * iIndex), (iIndex))
WRAPUNSAFE(void *, GetKey, (UINT iIndex), (iIndex))
WRAPWRITER(HRESULT, Set, (UINT iIndex, void * pvKey, void * pvVal), (iIndex, pvKey, pvVal))
WRAPREADER(void *, Lookup, (void *pvKey) const, (pvKey))
#if DBG==1
WRAPWRITER(HRESULT, Insert, (void * pvKey, void * pvVal, const void *pvData), (pvKey, pvVal, pvData))
#else
WRAPWRITER(HRESULT, Insert, (void * pvKey, void * pvVal), (pvKey, pvVal))
#endif
WRAPREADER(HRESULT, LookupSlow, (void * pvKey, const void * pvData, void **ppvVal), (pvKey, pvData, ppvVal))
WRAPWRITER(void *, Remove, (void * pvKey, const void * pvData), (pvKey, pvData))
WRAPREADER(HRESULT, CloneMemSetting, (CHtPvPv **ppClone, BOOL fCreateNew), (ppClone, fCreateNew))


// Constructor / Destructor ---------------------------------------------------

void
CHtPvPv::Init()
{
    memset(this, 0, sizeof(CHtPvPv));
    _pEnt           = &_EntEmpty;
    _pEntLast       = &_EntEmpty;
    _cEntMax        = 1;
    _cStrideMask    = 1;
#if DBG==1
    _dwTidDbg       = GetCurrentThreadId();
#endif
}

HRESULT 
CTsHtPvPv::Init()
{
    HRESULT hr;
    CHtPvPv::Init();    
    hr = rwLock.Init();
    RRETURN(hr);
}

void
CHtPvPv::ReInit()
{
    AssertSz(_dwTidDbg == GetCurrentThreadId(), "Hash table accessed from wrong thread.  This will corrupt lookups");
    if (_pEnt != &_EntEmpty)
    {
        MemFree(_pEnt);
    }
    LPFNCOMPARE lpfnCompare = _lpfnCompare;
    void *pObject = _pObject;
    Init();
    SetCallBack(pObject, lpfnCompare);
}

void
CTsHtPvPv::ReInit()
{
    AvoidThreadAssert();
    rwLock.WriterClaim();
    CHtPvPv::ReInit();   
    rwLock.WriterRelease();
}


// Utilities ------------------------------------------------------------------

UINT
CHtPvPv::ComputeStrideMask(UINT cEntMax)
{
    UINT iMask;
    for (iMask = 1; iMask < cEntMax; iMask <<= 1);
    return((iMask >> 1) - 1);
}

// Private Methods ------------------------------------------------------------

HRESULT
CHtPvPv::Grow()
{
    HRESULT hr;
    const DWORD * pdw;
    UINT    cEntMax;
    UINT    cEntGrow;
    UINT    cEntShrink;
    HTENT * pEnt;

    extern const DWORD s_asizeAssoc[];

    for (pdw = s_asizeAssoc; *pdw <= _cEntMax; pdw++) ;

    cEntMax    = *pdw;
    cEntGrow   = cEntMax * 8L / 10L;
    cEntShrink = (pdw > s_asizeAssoc) ? *(pdw - 1) * 4L / 10L : 0;
    pEnt       = (_pEnt == &_EntEmpty) ? NULL : _pEnt;

    hr = MemRealloc(Mt(CHtPvPv_pEnt), (void **)&pEnt, cEntMax * sizeof(HTENT));

    if (hr == S_OK)
    {
        _pEnt           = pEnt;
        _pEntLast       = &_EntEmpty;
        _cEntGrow       = cEntGrow;
        _cEntShrink     = cEntShrink;
        _cStrideMask    = ComputeStrideMask(cEntMax);

        memset(&_pEnt[_cEntMax], 0, (cEntMax - _cEntMax) * sizeof(HTENT));

        if (_cEntMax == 1)
        {
            memset(_pEnt, 0, sizeof(HTENT));
        }

        Rehash(cEntMax);
    }

    TraceTag((tagHtPvPvGrow, "Growing to cEntMax=%ld (cEntShrink=%ld,cEnt=%ld,cEntGrow=%ld)",
        _cEntMax, _cEntShrink, _cEnt, _cEntGrow));

    RRETURN(hr);
}

void
CHtPvPv::Shrink()
{
    const DWORD * pdw;
    UINT    cEntMax;
    UINT    cEntGrow;
    UINT    cEntShrink;

    extern const DWORD s_asizeAssoc[];

    for (pdw = s_asizeAssoc; *pdw < _cEntMax; pdw++) ;

    cEntMax    = *--pdw;
    cEntGrow   = cEntMax * 8L / 10L;
    cEntShrink = (pdw > s_asizeAssoc) ? *(pdw - 1) * 4L / 10L : 0;

    Assert(_cEnt < cEntGrow);
    Assert(_cEnt > cEntShrink);

    _pEntLast       = &_EntEmpty;
    _cEntGrow       = cEntGrow;
    _cEntShrink     = cEntShrink;
    _cStrideMask    = ComputeStrideMask(cEntMax);

    Rehash(cEntMax);

    Verify(MemRealloc(Mt(CHtPvPv_pEnt), (void **)&_pEnt, cEntMax * sizeof(HTENT)) == S_OK);

    TraceTag((tagHtPvPvGrow, "Shrinking to cEntMax=%ld (cEntShrink=%ld,cEnt=%ld,cEntGrow=%ld)",
        _cEntMax, _cEntShrink, _cEnt, _cEntGrow));
}

void
CHtPvPv::Rehash(UINT cEntMax)
{
    UINT    iEntScan    = 0;
    UINT    cEntScan    = _cEntMax;
    HTENT * pEntScan    = _pEnt;
    UINT    iEnt;
    UINT    cEnt;
    HTENT * pEnt;

    _cEntDel = 0;
    _cEntMax = cEntMax;

    for (; iEntScan < cEntScan; ++iEntScan, ++pEntScan)
    {
        if (HtKeyInUse(pEntScan->pvKey))
            pEntScan->pvKey = HtKeyClrBridged(HtKeySetRehash(pEntScan->pvKey));
        else
            pEntScan->pvKey = NULL;
        Assert(!HtKeyTstBridged(pEntScan->pvKey));
    }

    iEntScan = 0;
    pEntScan = _pEnt;

    for (; iEntScan < cEntScan; ++iEntScan, ++pEntScan)
    {

    repeat:

        if (HtKeyTstRehash(pEntScan->pvKey))
        {
            pEntScan->pvKey = HtKeyClrRehash(pEntScan->pvKey);

            iEnt = ComputeProbe(pEntScan->pvKey);
            cEnt = ComputeStride(pEntScan->pvKey);

            for (;;)
            {
                pEnt = &_pEnt[iEnt];

                if (pEnt == pEntScan)
                    break;

                if (pEnt->pvKey == NULL)
                {
                    *pEnt = *pEntScan;
                    pEntScan->pvKey = NULL;
                    break;
                }

                if (HtKeyTstRehash(pEnt->pvKey))
                {
                    void * pvKey1 = HtKeyClrBridged(pEnt->pvKey);
                    void * pvKey2 = HtKeyClrBridged(pEntScan->pvKey);
                    void * pvVal1 = pEnt->pvVal;
                    void * pvVal2 = pEntScan->pvVal;

                    if (HtKeyTstBridged(pEntScan->pvKey))
                    {
                        pvKey1 = HtKeySetBridged(pvKey1);
                    }

                    if (HtKeyTstBridged(pEnt->pvKey))
                    {
                        pvKey2 = HtKeySetBridged(pvKey2);
                    }

                    pEntScan->pvKey = pvKey1;
                    pEntScan->pvVal = pvVal1;
                    pEnt->pvKey = pvKey2;
                    pEnt->pvVal = pvVal2;

                    goto repeat;
                }
            
                pEnt->pvKey = HtKeySetBridged(pEnt->pvKey);

                iEnt += cEnt;

                if (iEnt >= _cEntMax)
                    iEnt -= _cEntMax;
            }
        }
    }
}

// Public Methods -------------------------------------------------------------
void *
CHtPvPv::GetFirstEntry(UINT * iIndex)
{
    Assert(iIndex);

    *iIndex = 0;

    if (!_pEnt || !_cEnt)
        return NULL;

    while ((*iIndex < _cEntMax) && !HtKeyInUse(_pEnt[*iIndex].pvKey))
        ++(*iIndex);

    return (*iIndex >= _cEntMax) ? NULL : _pEnt[*iIndex].pvVal;

}

void *
CHtPvPv::GetNextEntry(UINT * iIndex)
{
    Assert(iIndex);

    ++(*iIndex);

    if (!_pEnt)
        return NULL;

    while ((*iIndex < _cEntMax) && !HtKeyInUse(_pEnt[*iIndex].pvKey))
        ++(*iIndex);

    return (*iIndex >= _cEntMax) ? NULL : _pEnt[*iIndex].pvVal;

}

void *
CHtPvPv::GetKey(UINT iIndex)
{
    return (iIndex >= _cEntMax) ? NULL : _pEnt[iIndex].pvKey;
}

HRESULT 
CHtPvPv::Set(UINT iIndex, void *pvKey, void *pvVal)
{
    if ( iIndex >= _cEntMax )
        return E_INVALIDARG;

    _pEnt[iIndex].pvKey = pvKey;
    _pEnt[iIndex].pvVal = pvVal;
    return S_OK;
}


//
// Clone a hash table with necessary memory space. However,
// the entries are not cloned! In the other word, the entries 
// are empty! To clone the entire hash table:
//
//      CloneMemSetting
//      GetFirstEntry/GetNextEntry/GetKey 
//      <Clone Key Val>
//      Set( Key, Val)
//
// This could be replaced with a single Clone function
// if we add a callback function that knows how to clone Key/Val
//

HRESULT 
CHtPvPv::CloneMemSetting(CHtPvPv **ppClone, BOOL fCreateNew)
{
    HRESULT  hr = S_OK;

    Assert( ppClone );
    if (fCreateNew)
    {
        *ppClone = new CHtPvPv();
        if (!*ppClone)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    Assert( *ppClone );

    (*ppClone)->_cEnt       = _cEnt;
    (*ppClone)->_cEntDel    = _cEntDel;
    (*ppClone)->_cEntGrow   = _cEntGrow;
    (*ppClone)->_cEntMax    = _cEntMax;
    (*ppClone)->_cStrideMask= _cStrideMask;
    if ( _pEnt != &_EntEmpty )
    {
        (*ppClone)->_pEnt = (HTENT *)MemAllocClear( Mt(CHtPvPv_pEnt),  _cEntMax * sizeof(HTENT) );
        if (! (*ppClone)->_pEnt )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    
Cleanup:
    if (hr)
    {
        if (!fCreateNew && (*ppClone))
        {
            delete (*ppClone);
            *ppClone = NULL;
        }
    }
    RRETURN(hr);
}




void *
CHtPvPv::Lookup(void *pvKey) const
{
    HTENT * pEnt;
    UINT        iEnt;
    UINT        cEnt;

    Assert(_lpfnCompare == NULL);
    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));
    AssertSz(_dwTidDbg == GetCurrentThreadId(), "Hash table accessed from wrong thread.  This will corrupt lookups");

    if (HtKeyEqualFast(_pEntLast->pvKey, pvKey))
    {
        return(_pEntLast->pvVal);
    }

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (HtKeyEqualFast(pEnt->pvKey, pvKey))
    {
        _pEntLast = pEnt;
        return(pEnt->pvVal);
    }

    if (!HtKeyTstBridged(pEnt->pvKey))
    {
        return(NULL);
    }

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (HtKeyEqualFast(pEnt->pvKey, pvKey))
        {
            _pEntLast = pEnt;
            return(pEnt->pvVal);
        }

        if (!HtKeyTstBridged(pEnt->pvKey))
        {
            return(NULL);
        }
    }
}

HRESULT
CHtPvPv::LookupSlow(void * pvKey, const void *pvData, void ** ppvVal)
{
    HTENT * pEnt;
    UINT        iEnt;
    UINT        cEnt;

    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));
    AssertSz(_dwTidDbg == GetCurrentThreadId(), "Hash table accessed from wrong thread.  This will corrupt lookups");

    if (HtKeyEqual(_pEntLast, pvKey, pvData))
    {
        *ppvVal = _pEntLast->pvVal;
        return S_OK;
    }

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (HtKeyEqual(pEnt, pvKey, pvData))
    {
        _pEntLast = pEnt;
        *ppvVal = pEnt->pvVal;
        return S_OK;
    }

    if (!HtKeyTstBridged(pEnt->pvKey))
    {
        return S_FALSE;
    }

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (HtKeyEqual(pEnt, pvKey, pvData))
        {
            _pEntLast = pEnt;
            *ppvVal = pEnt->pvVal;
            return S_OK;
        }

        if (!HtKeyTstBridged(pEnt->pvKey))
        {
            return S_FALSE;
        }
    }
}

HRESULT
#if DBG==1
CHtPvPv::Insert(void * pvKey, void * pvVal, const void *pvData)
#else
CHtPvPv::Insert(void * pvKey, void * pvVal)
#endif
{
    HTENT * pEnt;
    UINT    iEnt;
    UINT    cEnt;
    
    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));
    Assert(!IsPresent(pvKey, pvData));

    if (_cEnt + _cEntDel >= _cEntGrow)
    {
        if (_cEntDel > (_cEnt >> 2))
            Rehash(_cEntMax);
        else
        {
            HRESULT hr = Grow();

            if (hr)
            {
                RRETURN(hr);
            }
        }
    }

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (!HtKeyInUse(pEnt->pvKey))
    {
        goto insert;
    }

    pEnt->pvKey = HtKeySetBridged(pEnt->pvKey);

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (!HtKeyInUse(pEnt->pvKey))
        {
            goto insert;
        }

        pEnt->pvKey = HtKeySetBridged(pEnt->pvKey);
    }

insert:

    if (HtKeyTstBridged(pEnt->pvKey))
    {
        _cEntDel -= 1;
        pEnt->pvKey = HtKeySetBridged(pvKey);
    }
    else
    {
        pEnt->pvKey = pvKey;
    }

    pEnt->pvVal = pvVal;

    _pEntLast = pEnt;

    _cEnt += 1;

    return(S_OK);
}

void *
CHtPvPv::Remove(void * pvKey, const void * pvData)
{
    HTENT * pEnt;
    UINT    iEnt;
    UINT    cEnt;

    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (HtKeyEqual(pEnt, pvKey, pvData))
    {
        goto remove;
    }

    if (!HtKeyTstBridged(pEnt->pvKey))
    {
        return(NULL);
    }

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (HtKeyEqual(pEnt, pvKey, pvData))
        {
            goto remove;
        }

        if (!HtKeyTstBridged(pEnt->pvKey))
        {
            return(NULL);
        }
    }

remove:

    if (HtKeyTstBridged(pEnt->pvKey))
    {
        pEnt->pvKey = HtKeySetBridged(NULL);
        _cEntDel += 1;
    }
    else
    {
        pEnt->pvKey = NULL;
    }

    pvKey = pEnt->pvVal;

    _cEnt -= 1;

    if (_cEnt < _cEntShrink)
    {
        Shrink();
    }

    return(pvKey);
}

// Testing --------------------------------------------------------------------

#if 0

#define MAKE_HTKEY(i)   ((void *)((((DWORD)(i) * 4567) << 2) | 4))
#define MAKE_HTVAL(k)   ((void *)(~(DWORD)MAKE_HTKEY(k)))

CHtPvPv * phtable = NULL;

BOOL TestHTInsert(int i)
{
    void * pvKey = MAKE_HTKEY(i);
    void * pvVal = MAKE_HTVAL(i);
    Verify(phtable->Insert(pvKey, pvVal) == S_OK);
    Verify(phtable->Lookup(pvKey) == pvVal);
    return(TRUE);
}

BOOL TestHTRemove(int i)
{
    void * pvKey = MAKE_HTKEY(i);
    void * pvVal = MAKE_HTVAL(i);
    Verify(phtable->Remove(pvKey) == pvVal);
    Verify(phtable->Remove(pvKey) == NULL);
    return(TRUE);
}

BOOL TestHTVerify(int i, int n)
{
    void * pvKey;
    void * pvVal; 
    int    j;

    Verify((int)phtable->GetCount() == (n - i));

    for (j = i; j < n; ++j)
    {
        pvKey = MAKE_HTKEY(j);
        pvVal = MAKE_HTVAL(j);
        Verify(phtable->Lookup(pvKey) == pvVal);
    }

    return(TRUE);
}

HRESULT TestHtPvPv()
{
    CHtPvPv *   pht = new CHtPvPv;
    int         cLim, cEntMax;
    int         i, j;

    // Insufficient memory, don't crash.
    if (!pht)
        return S_FALSE;

//  printf("---- Begin testing CHashTable implementation\n\n");

    cLim    = 256;
    cEntMax = 383;
    phtable = pht;

    // Insert elements from 0 to cLim
//  printf("  Inserting from %3d to %3d\n", 0, cLim); fflush(stdout);
    for (i = 0; i < cLim; ++i) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(0, i + 1)) return(S_FALSE);
    }

    // Remove elements from 0 to cLim
//  printf("  Removing  from %3d to %3d\n", 0, cLim); fflush(stdout);
    for (i = 0; i < cLim; ++i) {
        if (!TestHTRemove(i)) return(S_FALSE);
        if (!TestHTVerify(i + 1, cLim)) return(S_FALSE);
    }

    // Rehash and make sure number of deleted entries is now zero
    phtable->Rehash(phtable->GetMaxCount());
    Verify(phtable->GetDelCount() == 0);
    if (!TestHTVerify(0, 0)) return(S_FALSE);

    // Insert elements from 0 to cLim/2
//  printf("  Inserting from %3d to %3d\n", 0, cLim / 2); fflush(stdout);
    for (i = 0; i < cLim/2; ++i) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(0, i + 1)) return(S_FALSE);
    }

    // Insert elements from cLim/2 to cLim and remove elements from 0 to cLim/2
//  printf("  Inserting from %3d to %3d, removing from %3d to %3d\n", cLim / 2, cLim, 0, cLim / 2); fflush(stdout);
    for (i = cLim/2, j = 0; i < cLim; ++i, ++j) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(j, i + 1)) return(S_FALSE);
        if (!TestHTRemove(j)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 1)) return(S_FALSE);
    }

    // Insert two elements from cLim to cLim*2, remove one element from cLim/2 to cLim
//  printf("  Inserting from %3d to %3d, removing from %3d to %3d\n", cLim, cLim*2, cLim / 2, cLim);
    for (i = cLim, j = cLim / 2; i < cLim*2; i += 2, ++j) {
        if (!TestHTRemove(j)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i)) return(S_FALSE);
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 1)) return(S_FALSE);
        if (!TestHTInsert(i + 1)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 2)) return(S_FALSE);
    }

    // Rehash and make sure number of deleted entries is now zero
    phtable->Rehash(phtable->GetMaxCount());
    Verify(phtable->GetDelCount() == 0);

    if (!TestHTVerify(cLim, cLim*2)) return(S_FALSE);

    // Insert elements from cLim*2, remove two elements from cLim
//  printf("  Inserting from %3d to %3d, removing from %3d to %3d\n", cLim*2, cLim*3, cLim, cLim*3);
    for (i = cLim*2, j = cLim; i < cLim*3; ++i, j += 2) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(j, i + 1)) return(S_FALSE);
        if (!TestHTRemove(j)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 1)) return(S_FALSE);
        if (!TestHTRemove(j + 1)) return(S_FALSE);
        if (!TestHTVerify(j + 2, i + 1)) return(S_FALSE);
    }

    // Rehash and make sure number of deleted entries is now zero
    phtable->Rehash(phtable->GetMaxCount());
    Verify(phtable->GetDelCount() == 0);
    if (!TestHTVerify(0, 0)) return(S_FALSE);

    delete pht;

    return(S_OK);
}

#endif

// Reader/writer lock implementation -------------------------------------------------------------------
//
// There are two important synchronization primitives involved in this implementation:
// the group event (_hGroupEvent) and the reader critical section (csReader)
//
// Group Event - 
//
// The group mutex is held by either the collective readers or by one writer, 
// and allows threads of that group to be active. The group mutex is not 
// manually reset - when it is released, one thread waiting on it will 
// automatically be activated. Therefore only one reader should be waiting on 
// this mutex at any given time. The first reader gets this mutex before 
// proceeding, and the last reader releases it when it is finished. Writers 
// are slightly different: each writer is treated separately to ensure that 
// only one writer is active at a time. Therefore any number of writers can 
// block on this event, and only one will be activated at a time.
//
// Reader Critical Section - 
//
// This critical section ensures that only one reader blocks on the group
// event at a time. When the readers collectively have the group event,
// all readers are allowed to pass through until the last reader leaves,
// at which time the group event is reset. This critical section also
// serves to protect the reader count.

CRWLock::CRWLock()
{
    _cReaders = 0;   
    _hGroupEvent = NULL;    
}


CRWLock::~CRWLock()
{
    if (_hGroupEvent)
        CloseHandle(_hGroupEvent);    
}

HRESULT
CRWLock::Init()
{
    HRESULT hr = S_OK;
    
    hr = csReader.Init();
    if (hr)
        goto Cleanup;

    _hGroupEvent = CreateEvent(NULL, FALSE, TRUE, NULL);        

    if (!_hGroupEvent)
        hr = E_FAIL;
    
Cleanup:
    RRETURN(hr);
}

void
CRWLock::WriterClaim()
{    
    WaitForSingleObject(_hGroupEvent, INFINITE);    
}

void 
CRWLock::WriterRelease()
{    
    SetEvent(_hGroupEvent); 
}

void 
CRWLock::ReaderClaim()
{

    csReader.Enter();
    
    if (++_cReaders == 1)
    {
        WaitForSingleObject(_hGroupEvent, INFINITE);       
    }
    
    csReader.Leave();           
}

void CRWLock::ReaderRelease()
{
    csReader.Enter();
    
    if (--_cReaders == 0)
    {        
        SetEvent(_hGroupEvent);
    }
    
    csReader.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\identpal.cxx ===
//+------------------------------------------------------------------------
//
//  File:       identpal.cxx
//
//  Contents:   Debug routines for faster BitBlt to palette devices
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

DeclareTag(tagIdentity, "Performance", "Warn if non-identity palette, BitBlt");

BOOL 
IsSameAsPhysicalPalette(HPALETTE hpal)
{
    BOOL fIdentityPalette = TRUE;

    if ((GetDeviceCaps(TLS(hdcDesktop), RASTERCAPS) & RC_PALETTE) &&
        GetDeviceCaps(TLS(hdcDesktop), BITSPIXEL) * GetDeviceCaps(TLS(hdcDesktop), PLANES) == 8)
    {
        PALETTEENTRY apeSystem[256];
        PALETTEENTRY apePalette[256];

        GetSystemPaletteEntries(TLS(hdcDesktop), 0, ARRAY_SIZE(apeSystem), apeSystem);
        GetPaletteEntries(hpal, 0, ARRAY_SIZE(apePalette), apePalette);

        for (int i = 256; --i >= 0; )
        {
            if (apePalette[i].peRed != apeSystem[i].peRed ||
                apePalette[i].peGreen != apeSystem[i].peGreen ||
                apePalette[i].peBlue != apeSystem[i].peBlue)
            {
                fIdentityPalette = FALSE;
                break;
            }
        }
    }

    return fIdentityPalette;
}

/****************************************************************************

 IsIdentityPalette

    handy debug code to determine if a palette has a 1:1 logical to
    foreground translate (ie is a identity palette)

    Identity palettes are very important for windows apps using DIBs,
    DIBSections, WinGBitmaps in order to get the fastest possible
    speed out of BitBlt.

    it might be a good idea to put a Assert(IsIdentityPalette(hpal))
    in your app if you care about Blt speed.

    further reading....

        WinG help file (on MSDN) - great discusion of Identity palettes
        why you need them, how to get them etc...

        Win32 Animation techniques, Nigel Thompson

        MSDN search for identity

    03/02/95    ToddLa

 ****************************************************************************/


BOOL 
IsIdentityPalette(HPALETTE hpal)
{
    BOOL fIdentityPalette = TRUE;
    HDC hdcS;

    hdcS = GetDC(NULL);

    if ((GetDeviceCaps(hdcS, RASTERCAPS) & RC_PALETTE) &&
        GetDeviceCaps(hdcS, BITSPIXEL) * GetDeviceCaps(hdcS, PLANES) == 8)
    {
        int n=0;
        int i;
        BYTE xlat[256];
        HBITMAP hbm;
        HDC hdcM;

        GetObject(hpal, sizeof(n), &n);

        hdcM = CreateCompatibleDC(hdcS);
        if (hdcM)
        {
            hbm = CreateCompatibleBitmap(hdcS, 256, 1);
            if (hbm)
            {
                SelectObject(hdcM, hbm);

                Verify(SelectPalette(hdcM, hpal, TRUE));
                RealizePalette(hdcM);
                for (i=0; i<n; i++)
                {
                    SetPixel(hdcM, i, 0, PALETTEINDEX(i));
                }
                GetBitmapBits(hbm, sizeof(xlat), xlat);
                SelectPalette(hdcM, (HPALETTE)GetStockObject(DEFAULT_PALETTE), FALSE);

                DeleteObject(hbm);

                for (i=0; i<n; i++)
                {
                    if (xlat[i] != i)
                    {
                        TraceTag((tagIdentity, "Using non-identity palette"));
                        fIdentityPalette = FALSE;
                        break;
                    }
                }
            }
            DeleteDC(hdcM);
        }
    }

    ReleaseDC(NULL, hdcS);

    return fIdentityPalette;
}

/****************************************************************************

 IsIdentityBlt

    handy debug code to determine if a DibSection Blt is 1:1

  hdcS  - screen DC
  hdcD  - DIBSection DC
  xWid  - row width of hdcD
    
    03/02/95    ToddLa

 ****************************************************************************/

BOOL 
IsIdentityBlt(HDC hdcS, HDC hdcD, int xWid)
{
    BOOL fIdentityBlt = TRUE;

    if (    xWid > 0
        &&  (GetDeviceCaps(hdcS, RASTERCAPS) & RC_PALETTE)
        &&  GetDeviceCaps(hdcS, BITSPIXEL) * GetDeviceCaps(hdcS, PLANES) == 8)
    {
        int i, j, xSpan;
        BYTE xlat[256];
        HBITMAP hbm;
        HDC hdcM;
        COLORREF argb[256];
        HPALETTE hpal;

        hpal = (HPALETTE)GetCurrentObject(hdcS, OBJ_PAL);

        hdcM = CreateCompatibleDC(hdcS);
        if (hdcM)
        {
            hbm = CreateCompatibleBitmap(hdcS, 256, 1);
            if (hbm)
            {
                SelectObject(hdcM, hbm);

                Verify(SelectPalette(hdcM, hpal, TRUE));
                RealizePalette(hdcM);

                if (xWid > 256)
                    xWid = 256;

                for (i=0; i<xWid; i++)
                {
                    argb[i] = GetPixel(hdcD, i, 0);
                }

                for (j=0; j<256; j += xWid)
                {
                    xSpan = min(xWid, 256 - j);

                    for (i = 0; i < xSpan; i++)
                    {
                        SetPixel(hdcD, i, 0, PALETTEINDEX(j + i));
                    }

                    BitBlt(hdcM, 0, 0, xSpan, 1, hdcD, 0, 0, SRCCOPY);

                    GetBitmapBits(hbm, xSpan, xlat);

                    for (i=0; i < xSpan; i++)
                    {
                        if (xlat[i] != j + i)
                        {
                            TraceTag((tagIdentity, "Performing non-identity BitBlt"));
                            fIdentityBlt = FALSE;
                            break;
                        }
                    }

                    if (!fIdentityBlt)
                        break;
                }

                SelectPalette(hdcM, (HPALETTE)GetStockObject(DEFAULT_PALETTE), FALSE);
                DeleteObject(hbm);
            }
            DeleteDC(hdcM);
        }

        for (i=0; i<xWid; i++)
        {
            SetPixel(hdcD, i, 0, argb[i]);
        }
    }    

    return fIdentityBlt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\memutils.cxx ===
//+------------------------------------------------------------------------
//
//  File:       memutil.cxx
//
//  Contents:   Memory utilities
//
//  History:    30-Oct-94   GaryBu  Consolidated from places far & wide.
//              06-Jul-95   PaulG   Macintosh compiles now use Global instead
//                                  of Heap memory functions
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_VMEM_HXX_
#define X_VMEM_HXX_
#include "vmem.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#if TIMEHEAP
#define HeapBegTimer(x) SwitchesBegTimer(x)
#define HeapEndTimer(x) SwitchesEndTimer(x)
#else
#define HeapBegTimer(x)
#define HeapEndTimer(x)
#endif

MtDefine(PerfPigs, NULL, "MSHTML Performance Pigs")
MtDefine(Metrics, NULL, "MSHTML Metrics")
MtDefine(WorkingSet, NULL, "MSHTML Working Set")
MtDefine(Mem, WorkingSet, "MemAlloc")
MtDefine(OpNew, Mem, "operator new")
MtDefine(Locals, Mem, "Per Function Local")
MtDefine(PerThread, Mem, "Per Thread Global")
MtDefine(PerProcess, Mem, "Per Process Global")
MtDefine(Layout, Mem, "Layout")
MtDefine(ObjectModel, Mem, "Object Model")
MtDefine(Utilities, Mem, "Utilities")
MtDefine(Printing, Mem, "Printing")
MtDefine(Tree, Mem, "Tree")
MtDefine(Edit, Mem, "Edit")
MtDefine(Behaviors, Mem, "Behaviors")

EXTERN_C HANDLE g_hProcessHeap;

#if !defined(UNIX) && !defined(_MAC) && !defined(_M_AMD64) && !defined(_M_IA64) && !defined(SLOWALLOC)
#define SMALLBLOCKHEAP 1
#endif

// DbgExCheckHeap -------------------------------------------------------------

#if DBG==1

DeclareTag(tagNoCheckHeap, "!Memory", "Disable CHECK_HEAP() macro");

void WINAPI
DbgExCheckHeap()
{
    if (!DbgExIsTagEnabled(tagNoCheckHeap))
    {
        AssertSz(DbgExValidateInternalHeap(), "Internal heap is corrupt!");
        AssertSz(CheckSmallBlockHeap(), "Small block heap is corrupt!");
    }
}

#endif

//+------------------------------------------------------------------------
// Allocation functions not implemented in this file:
//
//      CDUTIL.HXX
//          operator new
//          operator delete
//
//      OLE's OBJBASE.H
//          CoTaskMemAlloc, CoTaskMemFree
//
//-------------------------------------------------------------------------

#if SMALLBLOCKHEAP

DeclareTag(tagSmallBlockHeap, "!Memory", "Check small block heap every time")
DeclareTag(tagSmallBlockHeapDisable, "!Memory", "Disable small block heap");

#define _CRTBLD 1
#include "winheap.h"
EXTERN_C CRITICAL_SECTION g_csHeap;

#if DBG == 1
#define CHECKSBH if (IsTagEnabled(tagSmallBlockHeap)) {Assert(CheckSmallBlockHeap() && "Small block heap corrupt");};
BOOL IsSmallBlockHeapEnabled()
{
    static int g_fSmallBlockHeap = -1;
    if (g_fSmallBlockHeap == -1)
        g_fSmallBlockHeap = IsTagEnabled(tagSmallBlockHeapDisable) ? 0 : 1;
    return(g_fSmallBlockHeap == 1);
}
BOOL CheckSmallBlockHeap()
{
    if (IsSmallBlockHeapEnabled())
    {
        EnterCriticalSection(&g_csHeap);
        BOOL f = __sbh_heap_check() >= 0;
        LeaveCriticalSection(&g_csHeap);
        return f;
    }
    return TRUE;
}
#else
#define CHECKSBH
#endif

#else

#if DBG == 1
BOOL CheckSmallBlockHeap()
{
    return TRUE;
}
#endif

#endif SMALLBLOCKHEAP

#if DBG==1

static BOOL  g_fVMemInit    = FALSE;
static BOOL  g_fVMemEnable  = FALSE;
static DWORD g_dwFlagsVMem  = 0;

BOOL
IsVMemEnabled()
{
    if (!g_fVMemInit)
    {
        g_fVMemEnable = IsTagEnabled(tagMemoryStrict);

        if (IsTagEnabled(tagMemoryStrictTail))
        {
            g_dwFlagsVMem |= VMEM_BACKSIDESTRICT;

            if (IsTagEnabled(tagMemoryStrictAlign))
            {
                g_dwFlagsVMem |= VMEM_BACKSIDEALIGN8;
            }
        }

        g_fVMemInit = TRUE;
    }

    return(g_fVMemEnable);
}

#define VMEM

#elif defined(PERFTAGS) && !defined(PERFMETER)

PerfTag(tgMemoryStrict,        "!Memory", "Use VMem for MemAlloc")
PerfTag(tgMemoryStrictHead,    "!Memory", "VMem strict at beginning (vs end)")
PerfTag(tgMemoryStrictAlign,   "!Memory", "VMem pad to quadword at end")

static BOOL  g_fVMemInit   = FALSE;
static BOOL  g_fVMemEnable = FALSE;
static DWORD g_dwFlagsVMem = 0;

BOOL
IsVMemEnabled()
{
    if (!g_fVMemInit)
    {
        g_fVMemEnable = IsPerfEnabled(tgMemoryStrict);

        if (!IsPerfEnabled(tgMemoryStrictHead))
        {
            g_dwFlagsVMem |= VMEM_BACKSIDESTRICT;

            if (IsPerfEnabled(tgMemoryStrictAlign))
            {
                g_dwFlagsVMem |= VMEM_BACKSIDEALIGN8;
            }
        }

        g_fVMemInit = TRUE;
    }

    return(g_fVMemEnable);
}

#define VMEM

#elif defined(USE_VMEM_FOR_MEMALLOC)

#ifdef VMEM_FOR_MEMALLOC_FLAGS
#define g_dwFlagsVMem   VMEM_FOR_MEMALLOC_FLAGS
#else
#define g_dwFlagsVMem   VMEM_BACKSIDESTRICT
#endif

BOOL
IsVMemEnabled()
{
    return(TRUE);
}

#define VMEM

#endif

//+------------------------------------------------------------------------
//
//  Function:   _MemGetSize
//
//  Synopsis:   Get size of block allocated with MemAlloc/MemRealloc.
//
//              Note that MemAlloc/MemRealloc can allocate more than
//              the requested number of bytes. Therefore the size returned
//              from this function is possibly greater than the size
//              passed to MemAlloc/Realloc.
//
//  Arguments:  [pv] - Return size of this block.
//
//  Returns:    The size of the block, or zero of pv == NULL.
//
//-------------------------------------------------------------------------
ULONG
_MemGetSize(void *pv)
{
    if (pv == NULL)
        return 0;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemGetSize(pv));
    }
#endif

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;
        __map_t *           pmap;

        EnterCriticalSection(&g_csHeap);

        HeapBegTimer(SWITCHES_TIMER_SBHEAP_GETSIZE);

        if ((pmap = __sbh_find_block(DbgPreGetSize(pv), &preg, &ppage)) != NULL )
        {
            Assert(*pmap != 0);
            size_t s = DbgPostGetSize(((size_t)(*pmap)) << _PARASHIFT);

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_GETSIZE);

            LeaveCriticalSection(&g_csHeap);

            return s;
        }

        HeapEndTimer(SWITCHES_TIMER_SBHEAP_GETSIZE);

        LeaveCriticalSection(&g_csHeap);
    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_GETSIZE);

    ULONG cbRet = DbgPostGetSize(HeapSize(g_hProcessHeap, 0, DbgPreGetSize(pv)));

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_GETSIZE);

    return cbRet;
}

//+------------------------------------------------------------------------
//
//  Function:   _MemAlloc
//
//  Synopsis:   Allocate block of memory.
//
//              The contents of the block are undefined.  If the requested size
//              is zero, this function returns a valid pointer.  The returned
//              pointer is guaranteed to be suitably aligned for storage of any
//              object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAlloc(ULONG cb)
{
    AssertSz (cb, "Requesting zero sized block.");
    void * pvRet;

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemAlloc(cb, g_dwFlagsVMem));
    }
#endif


    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;

            EnterCriticalSection(&g_csHeap);

            HeapBegTimer(SWITCHES_TIMER_SBHEAP_ALLOC);

            pvRet = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_ALLOC);

            LeaveCriticalSection(&g_csHeap);
            Assert(!pvRet || _MemGetSize(pvRet) >= cb);
            if (pvRet)
            {
                return pvRet;
            }

        }
    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_ALLOC);

    pvRet = DbgPostAlloc(HeapAlloc(g_hProcessHeap, 0, DbgPreAlloc(cb)));

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_ALLOC);

    return pvRet;
}


//+------------------------------------------------------------------------
//  Function:   _MemAllocClear
//
//  Synopsis:   Allocate a zero filled block of memory.
//
//              If the requested size is zero, this function returns a valid
//              pointer. The returned pointer is guaranteed to be suitably
//              aligned for storage of any object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAllocClear(ULONG cb)
{
    AssertSz (cb, "Allocating zero sized block.");

    void * pvRet;

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemAllocClear(cb, g_dwFlagsVMem));
    }
#endif

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;


            EnterCriticalSection(&g_csHeap);

            HeapBegTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);

            pvRet = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);

            LeaveCriticalSection(&g_csHeap);
            Assert(!pvRet || _MemGetSize(pvRet) >= cb);
            if (pvRet)
            {
                HeapBegTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);
                memset(pvRet, 0, cb);
                HeapEndTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);

                return pvRet;
            }

        }
    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_ALLOCCLEAR);

    pvRet = DbgPostAlloc(HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY,
                         DbgPreAlloc(cb)));

    // In debug, DbgPostAlloc set the memory so we need to clear it again.
    // On the Mac, HpAlloc doesn't support HEAP_ZERO_MEMORY.

#if DBG==1 || defined(_MAC)
    if (pvRet)
    {
        memset(pvRet, 0, cb);
    }
#endif

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_ALLOCCLEAR);

    return pvRet;
}

//+------------------------------------------------------------------------
//
//  Function:   _MemFree
//
//  Synopsis:   Free a block of memory allocated with MemAlloc,
//              MemAllocFree or MemRealloc.
//
//  Arguments:  [pv] - Pointer to block to free.  A value of zero is
//              is ignored.
//
//-------------------------------------------------------------------------

void
_MemFree(void *pv)
{
    // The null check is required for HeapFree.
    if (pv == NULL)
        return;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        VMemFree(pv);
        return;
    }
#endif

    Assert(g_hProcessHeap);

#if DBG == 1
    pv = DbgPreFree(pv);
#endif

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *preg;
        __sbh_page_t *  ppage;
        __map_t *       pmap;

        CHECKSBH;

        EnterCriticalSection(&g_csHeap);

        HeapBegTimer(SWITCHES_TIMER_SBHEAP_FREE);

        if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL ) {
            Assert(*pmap != 0);
            __sbh_free_block(preg, ppage, pmap);

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_FREE);

            LeaveCriticalSection(&g_csHeap);
            DbgPostFree();

            return;
        }

        HeapEndTimer(SWITCHES_TIMER_SBHEAP_FREE);

        LeaveCriticalSection(&g_csHeap);

    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_FREE);

    HeapFree(g_hProcessHeap, 0, pv);

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_FREE);

    DbgPostFree();
}

//+------------------------------------------------------------------------
//  Function:   _MemRealloc
//
//  Synopsis:   Change the size of an existing block of memory, allocate a
//              block of memory, or free a block of memory depending on the
//              arguments.
//
//              If cb is zero, this function always frees the block of memory
//              and *ppv is set to zero.
//
//              If cb is not zero and *ppv is zero, then this function allocates
//              cb bytes.
//
//              If cb is not zero and *ppv is non-zero, then this function
//              changes the size of the block, possibly by moving it.
//
//              On error, *ppv is left unchanged.  The block contents remains
//              unchanged up to the smaller of the new and old sizes.  The
//              contents of the block beyond the old size is undefined.
//              The returned pointer is guaranteed to be suitably aligned for
//              storage of any object type.
//
//              The signature of this function is different than thy typical
//              realloc-like function to avoid the following common error:
//                  pv = realloc(pv, cb);
//              If realloc fails, then null is returned and the pointer to the
//              original block of memory is leaked.
//
//  Arguments:  [cb] - Requested size in bytes. A value of zero always frees
//                  the block.
//              [ppv] - On input, pointer to existing block pointer or null.
//                  On output, pointer to new block pointer.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemRealloc(void **ppv, ULONG cb)
{
    void *  pv;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemRealloc(ppv, cb, g_dwFlagsVMem));
    }
#endif

    Assert(g_hProcessHeap);

    if (cb == 0)
    {
        _MemFree(*ppv);
        *ppv = 0;
    }
    else if (*ppv == NULL)
    {
        *ppv = _MemAlloc(cb);
        if (*ppv == NULL)
            return E_OUTOFMEMORY;
    }
    else
    {
    #if DBG == 1
    	#if SMALLBLOCKHEAP
    	    ULONG cbReq = cb;
    	#endif
        cb = DbgPreRealloc(*ppv, cb, &pv);
    #else
        pv = *ppv;
    #endif

    #if SMALLBLOCKHEAP
    #if DBG==1
        if (IsSmallBlockHeapEnabled())
    #endif
        {
            __sbh_region_t *preg;
            __sbh_page_t *  ppage;
            __map_t *       pmap;
            ULONG           cbr;
            void *          pvNew;

            cbr = (cb + _PARASIZE - 1) & ~(_PARASIZE - 1);

            CHECKSBH;

            EnterCriticalSection(&g_csHeap);

            HeapBegTimer(SWITCHES_TIMER_SBHEAP_REALLOC);

            if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL )
            {
                Assert(*pmap != 0);

                pvNew = NULL;
                /*
                 * If the new size falls below __sbh_threshold, try to
                 * carry out the reallocation within the small-block
                 * heap.
                 */
                if ( cbr < __sbh_threshold ) {
                    if ( __sbh_resize_block(preg, ppage, pmap, cbr >> _PARASHIFT))
                    {
                        pvNew = pv;
                    }
                    else if ((pvNew = __sbh_alloc_block(cbr >> _PARASHIFT)) != NULL)
                    {
                        ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                        memcpy(pvNew, pv, min(cbOld, cb));
                        __sbh_free_block(preg, ppage, pmap);
                    }
                }

                HeapEndTimer(SWITCHES_TIMER_SBHEAP_REALLOC);

                /*
                 * If the reallocation has not been (successfully)
                 * performed in the small-block heap, try to allocate a
                 * new block with HeapAlloc.
                 */
                HeapBegTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

                if ((pvNew == NULL) && ((pvNew = HeapAlloc(g_hProcessHeap, 0, cb)) != NULL))
                {
                    ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                    memcpy(pvNew, pv, min(cbOld, cb));

                    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

                    __sbh_free_block(preg, ppage, pmap);
                }

                HeapEndTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

                LeaveCriticalSection(&g_csHeap);
                pv = DbgPostRealloc(pvNew);
                if (pv == NULL)
                {
                    return E_OUTOFMEMORY;
                }
                else
                {
#if DBG ==1
                    Assert(_MemGetSize(pv) >= cbReq);
#endif
                    *ppv = pv;
                    return S_OK;
                }
            }
            else
            {
                HeapEndTimer(SWITCHES_TIMER_SBHEAP_REALLOC);

                LeaveCriticalSection(&g_csHeap);
            }
        }

    #endif

        HeapBegTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

        void *pvTemp = DbgPostRealloc(HeapReAlloc(g_hProcessHeap, 0, pv, cb));

        HeapEndTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

        if (pvTemp == NULL)
            return E_OUTOFMEMORY;

        // if HeapReAlloc fails and returns NULL, *ppv is supposed to remain unchanged,
        // so only set it after checking if the realloc succeeds
        *ppv = pvTemp;

    }

    return S_OK;
}

#if DBG==1

char *
_MemGetName(void * pv)
{
    return(DbgExMemGetName(pv));
}

void __cdecl
_MemSetName(void * pv, char * szFmt, ...)
{
    if (!IsVMemEnabled())
    {
        char szBuf[1024];
        va_list va;

        va_start(va, szFmt);
        wvsprintfA(szBuf, szFmt, va);
        va_end(va);

        DbgExMemSetName(pv, "%s", szBuf);
    }
}

void
_MemSetHeader(void * pv, ULONG cb, PERFMETERTAG mt)
{
#ifdef PERFMETER
    if (!IsVMemEnabled())
    {
        DbgExMemSetHeader(pv, cb, mt);
    }
#endif
}

#else

#define _MemSetHeader(pv, cb, mt)

#endif

// Metered Memory -------------------------------------------------------------

#ifdef PERFMETER

struct MTMEMBLK
{
    PERFMETERTAG    mt;
    ULONG           cb;
};

void *
_MtMemAlloc(PERFMETERTAG mt, ULONG cb)
{
    if (MtSimulateOutOfMemory(mt, -1))
    {
        return NULL;
    }

    MTMEMBLK * pmb = (MTMEMBLK *)_MemAlloc(sizeof(MTMEMBLK) + cb);

    if (pmb)
    {
        _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);
        pmb->mt = mt;
        pmb->cb = cb;
        MtAdd(mt, 1, (LONG)cb);
        return(pmb + 1);
    }
    else
    {
        return(NULL);
    }
}

void *
_MtMemAllocClear(PERFMETERTAG mt, ULONG cb)
{
    if (MtSimulateOutOfMemory(mt, -1))
    {
        return NULL;
    }

    MTMEMBLK * pmb = (MTMEMBLK *)_MemAllocClear(sizeof(MTMEMBLK) + cb);

    if (pmb)
    {
        _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);
        pmb->mt = mt;
        pmb->cb = cb;
        MtAdd(mt, 1, (LONG)cb);
        return(pmb + 1);
    }
    else
    {
        return(NULL);
    }
}

HRESULT
_MtMemRealloc(PERFMETERTAG mt, void ** ppv, ULONG cb)
{
    if (cb == 0)
    {
        _MtMemFree(*ppv);
        *ppv = 0;
        return(S_OK);
    }

    if (*ppv == NULL)
    {
        *ppv = _MtMemAlloc(mt, cb);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }

    MTMEMBLK *  pmb = (MTMEMBLK *)*ppv - 1;
    HRESULT     hr = _MemRealloc((void **)&pmb, sizeof(MTMEMBLK) + cb);

    if (hr == S_OK)
    {
        _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);

        if (pmb->mt == mt)
        {
            MtAdd(mt, 0, (LONG)cb - (LONG)pmb->cb);
        }
        else
        {
            MtAdd(pmb->mt, -1, -(LONG)pmb->cb);
            pmb->mt = mt;
            MtAdd(pmb->mt, +1, +(LONG)cb);
        }

        pmb->cb = cb;

        *ppv = pmb + 1;
    }

    return(hr);
}

ULONG
_MtMemGetSize(void * pv)
{
    if (pv == NULL)
        return(0);
    else
        return(_MemGetSize((MTMEMBLK *)pv - 1) - sizeof(MTMEMBLK));
}

void
_MtMemFree(void * pv)
{
    if (pv)
    {
        MTMEMBLK * pmb = (MTMEMBLK *)pv - 1;
        MtAdd(pmb->mt, -1, -(LONG)pmb->cb);
        _MemFree(pmb);
    }
}

HRESULT
_MtMemAllocString(PERFMETERTAG mt, LPCTSTR pchSrc, LPTSTR * ppchDst)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDst = pch = (TCHAR *)_MtMemAlloc(mt, cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}

HRESULT
_MtMemAllocString(PERFMETERTAG mt, ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)MemAlloc(mt, cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

HRESULT
_MtMemReplaceString(PERFMETERTAG mt, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MtMemAllocString(mt, pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MtMemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

#if DBG==1

char *
_MtMemGetName(void * pv)
{
    return(DbgExMemGetName((MTMEMBLK *)pv - 1));
}

void __cdecl
_MtMemSetName(void * pv, char * szFmt, ...)
{
    if (pv && !IsVMemEnabled())
    {
        char szBuf[1024];
        va_list va;

        va_start(va, szFmt);
        wvsprintfA(szBuf, szFmt, va);
        va_end(va);

        DbgExMemSetName((MTMEMBLK *)pv - 1, "%s", szBuf);
    }
}

#endif

int
_MtMemGetMeter(void * pv)
{
    return(((MTMEMBLK *)pv - 1)->mt);
}

void
_MtMemSetMeter(void * pv, PERFMETERTAG mt)
{
    if (pv)
    {
        MTMEMBLK * pmb = (MTMEMBLK *)pv - 1;

        if (pmb->mt != mt)
        {
            MtAdd(pmb->mt, -1, -(LONG)pmb->cb);
            pmb->mt = mt;
            MtAdd(pmb->mt, +1, +(LONG)pmb->cb);
            _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);
        }
    }
}

#endif

#ifdef PERFMETER

DeclareTag(tagUseMeterOpNew, "!Memory", "Trap invalid operator new calls")

void * __cdecl UseOperatorNewWithMemoryMeterInstead(size_t cb)
{
    AssertSz(!IsTagEnabled(tagUseMeterOpNew), "Invalid use of global operator new.  "
        "Use the version which requires a meter tag instead.");

    return(MemAlloc(Mt(OpNew), cb));
}

#endif

// MEMGUARD -------------------------------------------------------------------

#if defined(MEMGUARD)

#define MGGUARDDATA 0xF0F0BAAD

struct MGGUARD
{
    MGGUARD *pNext;
    DWORD    dw;
};

MGGUARD * g_pMemList = NULL;

void
_MgMemValidate()
{
    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    while (pg)
    {
        if (pg->dw != MGGUARDDATA)
        {
            DebugBreak();
        }

        pg = pg->pNext;
    }

    LeaveCriticalSection(&g_csHeap);
}

void
_MgRemove(MGGUARD *pmg)
{
    if (!pmg)
        return;

    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    if (pmg == pg)
    {
        g_pMemList = pg->pNext;
        goto Cleanup;
    }

    while (pg)
    {
        if (pg->pNext == pmg)
        {
            pg->pNext = pg->pNext->pNext;
            break;
        }

        pg = pg->pNext;
    }

Cleanup:
    LeaveCriticalSection(&g_csHeap);

}

void
_MgAdd(MGGUARD *pmg)
{
    EnterCriticalSection(&g_csHeap);

    pmg->pNext = g_pMemList;
    g_pMemList = pmg;

    LeaveCriticalSection(&g_csHeap);
}

void *
_MgMemAlloc(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAlloc(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }

}

void *
_MgMemAllocClear(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAllocClear(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }
}

HRESULT
_MgMemRealloc(void ** ppv, ULONG cb)
{
    _MgMemValidate();

    if (cb == 0)
    {
        _MgMemFree(*ppv);
        *ppv = 0;
        return(S_OK);
    }

    if (*ppv == NULL)
    {
        *ppv = _MgMemAlloc(cb);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }

    MGGUARD *  pmg = (MGGUARD *)*ppv - 1;

    _MgRemove(pmg);

    HRESULT    hr = _MemRealloc((void **)&pmg, sizeof(MGGUARD) + cb);

    if (hr == S_OK)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        *ppv = pmg + 1;
    }

    return(hr);
}

ULONG
_MgMemGetSize(void * pv)
{
    _MgMemValidate();

    if (pv == NULL)
        return(0);
    else
        return(_MemGetSize((MGGUARD *)pv - 1) - sizeof(MGGUARD));
}

void
_MgMemFree(void * pv)
{
    _MgMemValidate();

    if (pv)
    {
        MGGUARD * pmg = (MGGUARD *)pv - 1;
        if (pmg->dw != MGGUARDDATA)
        {
            // The memory guard DWORD was overwritten! Bogus!
#ifdef _M_IX86
            _asm int 3  // To get a proper stacktrace.
#else
            DebugBreak();
#endif
        }
        _MgRemove(pmg);

        _MemFree(pmg);
    }
}

HRESULT
_MgMemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDst = pch = (TCHAR *)_MgMemAlloc(cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}

HRESULT
_MgMemAllocString(ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)_MgMemAlloc(cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

HRESULT
_MgMemReplaceString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MgMemAllocString(pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MgMemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

#endif // MEMGUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MAKE_UNALIGNED_TYPE( LONG, 4 );

#if DBG == 1
//
// Global vars for use by the DYNCAST macro
//
char g_achDynCastMsg[200];
char *g_pszDynMsg = "Invalid Static Cast -- Attempt to cast object "
                    "of type %s to type %s.";
char *g_pszDynMsg2 = "Dynamic Cast Attempted ---  "
                     "Attempt to cast between two base classes of %s. "
                     "The cast was to class %s from some other base class "
                     "pointer. This cast will not succeed in a retail build.";
#endif

DeclareTag(tagAccess, "Accessibility", "Accessibility traces")

//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
}


//+------------------------------------------------------------------------
//
//  Function:   _MemAllocString
//
//  Synopsis:   Allocates a string copy using MemAlloc.
//
//              The inline function MemFreeString is provided for symmetry.
//
//  Arguments:  pchSrc    String to copy
//              ppchDest  Copy of string is returned in *ppch
//                        NULL is stored on error
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemAllocString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDest = pch = (TCHAR *)_MemAlloc(cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}



//+------------------------------------------------------------------------
//
//  Function:   _MemAllocString
//
//  Synopsis:   Allocates a string copy using MemAlloc.  Doesn't require
//              null-terminated input string.
//
//              The inline function MemFreeString is provided for symmetry.
//
//  Arguments:  cch       number of characters in input string,
//                        not including any trailing null character
//              pchSrc    pointer to source string
//              ppchDest  Copy of string is returned in *ppch
//                        NULL is stored on error
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemAllocString(ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)_MemAlloc(cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   _MemReplaceString
//
//  Synopsis:   Allocates a string using MemAlloc, replacing and freeing
//              another string on success.
//
//  Arguments:  pchSrc    String to copy. May be NULL.
//              ppchDest  On success, original string is freed and copy of
//                        source string is returned here
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemReplaceString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MemAllocString(pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:   TaskAllocString
//
//  Synopsis:   Allocates a string copy that can be passed across an interface
//              boundary, using the standard memory allocation conventions.
//
//              The inline function TaskFreeString is provided for symmetry.
//
//  Arguments:  pstrSrc    String to copy
//              ppstrDest  Copy of string is returned in *ppstr
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

#if !defined(_MACUNICODE) || defined(_MAC) 
HRESULT
TaskAllocString(const TCHAR *pstrSrc, TCHAR **ppstrDest)
{
    TCHAR *pstr;
    size_t cb;

    cb = (_tcsclen(pstrSrc) + 1) * sizeof(TCHAR);
    *ppstrDest = pstr = (TCHAR *)CoTaskMemAlloc(cb);
    if (!pstr)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pstr, pstrSrc, cb);
        return S_OK;
    }
}
#else
HRESULT
TaskAllocString(const OLECHAR *pstrSrc, OLECHAR **ppstrDest)
{
    OLECHAR *pstr;
    size_t cb;

    cb = (strlen(pstrSrc) + 1) * sizeof(OLECHAR);
    *ppstrDest = pstr = (OLECHAR *)CoTaskMemAlloc(cb);
    if (!pstr)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pstr, pstrSrc, cb);
        return S_OK;
    }
}
#endif

//+------------------------------------------------------------------------
//
//  Function:   TaskReplaceString
//
//  Synopsis:   Replaces a string copy that can be passed across an interface
//              boundary, using the standard memory allocation conventions.
//
//              The inline function TaskFreeString is provided for symmetry.
//
//  Arguments:  pstrSrc    String to copy. May be NULL.
//              ppstrDest  Copy of string is returned in *ppstrDest,
//                         previous string is freed on success
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT TaskReplaceString(const TCHAR * pstrSrc, TCHAR **ppstrDest)
{
    TCHAR *pstr;
    HRESULT hr;

    if (pstrSrc)
    {
        hr = THR(TaskAllocString(pstrSrc, &pstr));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pstr = NULL;
    }

    CoTaskMemFree(*ppstrDest);
    *ppstrDest = pstr;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   MulDivQuick
//
//  Synopsis:   Mutiply two signed 32-bit values and then divide the
//              64-bit result by a third unsigned 32-bit value.
//              The return value is rounded up or down to the nearest
//              integer.  If the multiplier and divisor are both zero,
//              this function returns 0.
//
//  Arguments:  nMultiplicand   Specifies the multiplicand.
//              nMultiplier     Specifies the multiplier.
//              nDivisor        Specifies the number by which the result of
//                              the multiplication (nMultiplicand * nMultiplier)
//                              is to be divided.
//
//----------------------------------------------------------------------------

// The OS routines are almost as fast (no inlining) and more robust, so
// this routine is no longer used...

#if 0

#pragma warning(disable: 4035)

int __declspec(naked) __stdcall
MulDivQuick(int nMultiplicand, int nMultiplier, int nDivisor)
{
    __asm
    {
        mov eax, 8[esp]
        test eax, eax
        je  L0
        mov ecx, 4[esp]
        imul ecx
        mov ecx, 12[esp]
        shr ecx, 1
        test edx, edx
        jl  L1
        add eax, ecx
        adc edx, 0
        mov ecx, 12[esp]
        idiv ecx
L0:
        ret 12
L1:
        sub eax, ecx
        sbb edx, 0
        mov ecx, 12[esp]
        idiv ecx
        ret 12
    }
}

#pragma warning(default: 4035)

#endif

//+-------------------------------------------------------------------------
//
//  Function:   InitSystemMetricValues
//
//  Synopsis:   Initializes globals holding system metric values.
//
//--------------------------------------------------------------------------

LONG        g_cMetricChange = 0;

SIZE        g_sizeDragMin;
SIZE        g_sizeScrollButton;
SIZEL       g_sizelScrollbar;
SIZEL       g_sizelScrollButton;
SIZEL       g_sizelScrollThumb;
LONG        g_lScrollGutterRatio;

LONG        g_alHimetricFrom8Pixels[2] = {0, 0};
SIZE        g_sizeSystemChar;

  // Locale Information
LCID        g_lcidUserDefault = 0;
LCID        g_lcidLocalUserDefault = 0;

UINT        g_cpDefault;

// hold for number shaping used by system: 0 = Context, 1 = None, 2 = Native
NUMSHAPE    g_iNumShape;
DWORD       g_uLangNationalDigits;

//  Accessibility information

BOOL g_fHighContrastMode = FALSE;
BOOL g_fScreenReader = FALSE;


HRESULT
InitSystemMetricValues(
    THREADSTATE *   pts)
{

    HIGHCONTRAST hc;
    HFONT       hfontOld;
    TEXTMETRIC  tm;
    SIZEL       sizeScrollbar;

    InterlockedIncrement(&g_cMetricChange);

    if (!pts->hdcDesktop)
    {
        pts->hdcDesktop = CreateCompatibleDC(NULL);
        if (!pts->hdcDesktop)
            RRETURN(E_OUTOFMEMORY);
    }


    {
        int logPixelsX = GetDeviceCaps(pts->hdcDesktop, LOGPIXELSX);
        int logPixelsY = GetDeviceCaps(pts->hdcDesktop, LOGPIXELSY);

        // The following Assert was added for bug 32496.
        // Seems like GetDeviceCaps once returned zero here.
        // Since the bug does'n want to repro, let's keep the assertion here
        // (mikhaill 4/25/1)
        Assert(logPixelsX > 0 && logPixelsY > 0);

        g_uiDisplay.SetResolution(logPixelsX, logPixelsY);
    }


#if defined(_MAC)
    // Width and height, in pixels, of a rectangle centered on a drag point
    // to allow for limited movement of the mouse pointer before a drag operation
    // begins. This allows the user to click and release the mouse button easily
    // without unintentionally starting a drag operation
    //
    g_sizeDragMin.cx = 3;
    g_sizeDragMin.cy = 3;
#else
    g_sizeDragMin.cx = GetSystemMetrics(SM_CXDRAG);
    g_sizeDragMin.cy = GetSystemMetrics(SM_CYDRAG);
#endif

    sizeScrollbar.cx = GetSystemMetrics(SM_CXVSCROLL);
    sizeScrollbar.cy = GetSystemMetrics(SM_CYHSCROLL);
    g_sizelScrollbar.cx = HimetricFromHPix(sizeScrollbar.cx);
    g_sizelScrollbar.cy = HimetricFromVPix(sizeScrollbar.cy);

    g_sizeScrollButton.cx  = GetSystemMetrics(SM_CXHSCROLL);
    g_sizeScrollButton.cy  = GetSystemMetrics(SM_CYVSCROLL);
    g_sizelScrollButton.cx = HimetricFromHPix(g_sizeScrollButton.cx);
    g_sizelScrollButton.cy = HimetricFromVPix(g_sizeScrollButton.cy);

    g_sizelScrollThumb.cx = HimetricFromHPix(GetSystemMetrics(SM_CXHTHUMB));
    g_sizelScrollThumb.cy = HimetricFromVPix(GetSystemMetrics(SM_CYVTHUMB));

    g_lScrollGutterRatio =  (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
                            ? 8 : 2;    // NT5 uses 8, NT4/W9x uses 2
    
    g_alHimetricFrom8Pixels[0] = HimetricFromHPix(8);
    g_alHimetricFrom8Pixels[1] = HimetricFromVPix(8);

    //
    // System font info
    //

    hfontOld = (HFONT)SelectObject(pts->hdcDesktop, GetStockObject(SYSTEM_FONT));
    if(hfontOld)
    {
        GetTextMetrics(pts->hdcDesktop, &tm);

        g_sizeSystemChar.cx = tm.tmAveCharWidth;
        g_sizeSystemChar.cy = tm.tmHeight;

        SelectObject(pts->hdcDesktop, hfontOld);
    }
    else
    {
        g_sizeSystemChar.cx =
        g_sizeSystemChar.cy = 10;
    }


    //
    // Locale info
    //

    g_cpDefault = GetACP();

    // TODO - PaulNel - g_lcidUserDefault needs to be evaluated to determine if
    //                    the desired intent is to use the User's default or that
    //                    of the System
    g_lcidUserDefault = GetSystemDefaultLCID(); //Set Global Locale ID
    g_lcidLocalUserDefault = GetUserDefaultLCID(); //Set Global Locale ID

    GetSystemNumberSettings(&g_iNumShape, &g_uLangNationalDigits);

#if !defined(UNIX)
    //
    //  Accessibility info
    //

    SystemParametersInfo(SPI_GETSCREENREADER, 0, &g_fScreenReader, FALSE);

    memset(&hc, 0, sizeof(HIGHCONTRAST));
    hc.cbSize = sizeof(HIGHCONTRAST);
    if (SystemParametersInfo(
                SPI_GETHIGHCONTRAST,
                sizeof(HIGHCONTRAST),
                &hc,
                0))
    {
        g_fHighContrastMode = !!(hc.dwFlags & HCF_HIGHCONTRASTON);
    }
    else
    {
        TraceTag((tagAccess, "SPI failed with error %x", GetLastError()));
    }
#endif

     RRETURN(S_OK);
 }

//+-------------------------------------------------------------------------
//
//  Function:   DeinitSystemMetricValues
//
//  Synopsis:   Deinitializes globals holding system metric values.
//
//--------------------------------------------------------------------------

void
DeinitSystemMetricValues(
    THREADSTATE *   pts)
{
   if(pts->hdcDesktop)
   {
       Verify(DeleteDC(pts->hdcDesktop));
#ifdef _MAC
    // Mac note: We need to recreate the hdcDesktop on a WM_SYSCOLORCHANGE
       pts->hdcDesktop = NULL;
#endif
   }

}

//+-------------------------------------------------------------------------
//
//  Function:   GetNumberOfSize
//              SetNumberOfSize
//
//  Synopsis:   Helpers to get/set an integer value of given byte size
//              by dereferencing a pointer
//
//              pv - pointer to dereference
//              cb - size (1, 2 or 4)
//
//--------------------------------------------------------------------------

long
GetNumberOfSize (void * pv, int cb)
{
    switch(cb)
    {
        case 1:
            return *(BYTE*) pv;

        case 2:
            return *(SHORT*) pv;

        case 4:
            return *(LONG*) pv;

        default:
            Assert(FALSE);
            return 0;
    }
}

void
SetNumberOfSize (void * pv, int cb, long i)
{
    switch(cb)
    {
        case 1:
            Assert((char)i >= SCHAR_MIN && (char)i <= SCHAR_MAX);
            * (BYTE*) pv = BYTE(i);
            break;

        case 2:
            Assert(i >= SHRT_MIN && i <= SHRT_MAX);
            * (SHORT*) pv  = SHORT(i);
            break;

        case 4:
            * (LONG*) pv = i;
            break;

        default:
            Assert(FALSE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetNumberOfType
//              SetNumberOfType
//
//  Synopsis:   Helpers to get/set an integer value of given variant type
//              by dereferencing a pointer
//
//              pv - pointer to dereference
//              vt - variant type
//
//--------------------------------------------------------------------------

// NOTE: The VC 5 compiler flags this as an error because VT_BOOL4 is not
// a valid VARENUM value.  Disable the warning for now.
#pragma warning(disable:4063)       // case '254' is not a valid value for switch of enum 'VARENUM'

long
GetNumberOfType (void * pv, VARENUM vt)
{
    switch(vt)
    {
        case VT_I2:
        case VT_BOOL:
            return * (SHORT*) pv;

        case VT_I4:
        case VT_BOOL4:
            return * (LONG*) pv;

        default:
            Assert(FALSE);
            return 0;
    }
}

void
SetNumberOfType (void * pv, VARENUM vt, long l)
{
    switch(vt)
    {
        case VT_BOOL:
            l = l ? VB_TRUE : VB_FALSE;
            //  vvvvvvvvvvv  FALL THROUGH vvvvvvvvvvvvv

        case VT_I2:
            Assert(l >= SHRT_MIN && l <= SHRT_MAX);
            * (SHORT*) pv = SHORT(l);
            break;

        case VT_BOOL4:
            l = l ? VB_TRUE : VB_FALSE;
            //  vvvvvvvvvvv  FALL THROUGH vvvvvvvvvvvvv

        case VT_I4:
            * (LONG_UNALIGNED *) pv = l;
            break;

        default:
            Assert(FALSE);
    }
}

#pragma warning(default:4063)


//+---------------------------------------------------------------------------
//
//  Function:   TextConvert
//
//  Synopsis:   Converts the text for a multiline/singleline textbox
//              Parameters:
//                  pszTextIn: current/passed in text
//                  pBstrOut: out parameter allocated in method
//                          will only be used in cased of Glyph->CR/LF/FF
//                          otherwise, conversion in place
//                  fToGlyph: force conversion to glyph case (used
//                      when multiline property is changed
//                  returns S_FALSE when no conversion happened
//
//----------------------------------------------------------------------------
#pragma warning(disable:4706)   // assignment within conditional expression
HRESULT
TextConvert(LPTSTR pszTextIn, BSTR *pBstrOut, BOOL fToGlyph)
{

    HRESULT hr = S_FALSE;

    LPTSTR  pszWrite;
    BOOL    fCRAndLF;
    const   int k_GlyphChar = 182;
    int     iHowManyGlyphs=0;

    if (!pszTextIn)
        goto Cleanup;

    if (fToGlyph)
    {
        TCHAR   ch;

        // so we are multiline and need to convert to the glyph representation
        pszWrite = pszTextIn;
        while ((ch = *pszTextIn))
        {
            if (ch != '\n' && ch != '\r' && ch != '\f')
            {
                *pszWrite++ = *pszTextIn++;
                continue;
            }

            fCRAndLF = (ch) == '\n';
            hr = S_OK;
            *pszWrite++ = k_GlyphChar;
            pszTextIn++;

            // NOTE: If we encountered a <FF> then map the <FF> to a <CR/LF> and
            // continue.  If this isn't done we could get into a nasty condition
            // if a <CR> or <LF> followed the <FF> then we would treat the
            // <FF><LF> as one CR/LF combination.  We don't want to do that the
            // <FF> by itself is one CR/LF combination.
            if (ch == '\f')
                continue;

            // the following part of the code tries to cover all the cases
            // of multiple presentations of CR/LF, like CR/LF, LF/CR, or
            // just LF or just CR. This is done by advancing the input pointer
            // and testing the next character to be the companion.
            if (*pszTextIn)
            {
                if (*pszTextIn == '\n' && !fCRAndLF)
                {
                    pszTextIn++;
                }
                else if (*pszTextIn == '\r' && fCRAndLF)
                {
                    pszTextIn++;
                }
            }

        }
        while (pszWrite != pszTextIn)
        {
            *pszWrite++ = 0;
        }
    }
    else if (pszTextIn)
    {
#ifdef _MAC
        CStr str;
        int  cStr;
#endif
        // scan the text first to check if memory allocation
        // and conversion is needed.Count the number of glyphs
        // to make a smart allocation
        pszWrite = pszTextIn;
        while (*pszWrite)
        {
            if (*pszWrite==k_GlyphChar)
            {
                iHowManyGlyphs++;
            }
            pszWrite++;
        }

        if (!iHowManyGlyphs)
            goto Cleanup;

        // so we are singleline and need to get rid of the glyphs...
        // first allocate a new and bigger buffer
#ifdef _MAC
        *pBstrOut = NULL;

        cStr = _tcslen(pszTextIn) + iHowManyGlyphs;
        str.ReAlloc(cStr);
        pszWrite = (LPTSTR)str;
#else
        *pBstrOut = SysAllocStringLen(0, (_tcslen(pszTextIn)+iHowManyGlyphs));
        pszWrite = (TCHAR*)*pBstrOut;
#endif

        if (!pszWrite)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        while (*pszTextIn)
        {
            if (*pszTextIn == k_GlyphChar)
            {
                hr = S_OK;
                *pszWrite++ = '\r';
                *pszWrite++ = '\n';
                pszTextIn++;
            }
            else
            {
                *pszWrite++ = *pszTextIn++;
            }
        }
        *pszWrite = 0;

#ifdef _MAC
        str.SetLengthNoAlloc(cStr);
        hr = str.AllocBSTR(pBstrOut);
#endif
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}
#pragma warning(default:4706)   // assignment within conditional expression


// Coerce pArgFrom into this instance from anyvariant to a given type
HRESULT CVariant::CoerceVariantArg ( VARIANT *pArgFrom, WORD wCoerceToType)
{
    HRESULT hr = S_OK;
    VARIANT *pvar;

    if( V_VT(pArgFrom) == (VT_BYREF | VT_VARIANT) )
        pvar = V_VARIANTREF(pArgFrom);
    else
        pvar = pArgFrom;

    if ( !(pvar->vt == VT_EMPTY || pvar->vt == VT_ERROR ) )
    {
        hr = THR(VariantChangeTypeSpecial ( (VARIANT *)this, pvar,  wCoerceToType ));
    }
    else
    {
        return S_FALSE;
    }
    RRETURN(hr);
}

// Coerce current variant into itself
HRESULT CVariant::CoerceVariantArg (WORD wCoerceToType)
{
    HRESULT hr = S_OK;

    if ( !(vt == VT_EMPTY || vt == VT_ERROR ) )
    {
        hr = THR(VariantChangeTypeSpecial ( (VARIANT *)this, (VARIANT *)this, wCoerceToType ));
    }
    else
    {
        return S_FALSE;
    }
    RRETURN(hr);
}


// Coerce any numeric (VT_I* or  VT_UI*) into a VT_I4 in this instance
BOOL CVariant::CoerceNumericToI4 ()
{
    switch (vt)
    {
    case VT_I1:
    case VT_UI1:
        lVal = 0x000000FF & (DWORD)bVal;
        break;
    
    case VT_UI2:
    case VT_I2:
        lVal = 0x0000FFFF & (DWORD)iVal;
        break;
    
    case VT_UI4:
    case VT_I4:
    case VT_INT: 
    case VT_UINT:
        break;

    case VT_R8:
        lVal = (LONG)dblVal;
        break;

    case VT_R4:
        lVal = (LONG)fltVal;
        break;

    default:
        return FALSE;
    }

    vt = VT_I4;
    return TRUE;
}
//+------------------------------------------------------------------------
//
//  Binary search routine
//      pb - Pointer to array
//      c  - Number of entries in the array
//      l  - Value for which to search (expressed as a long)
//      cb - Size of an array entry (defaults to 4 bytes)
//      ob - Offset within entry of comparison value (defaults to 0)
//
//-------------------------------------------------------------------------
int BSearch(const BYTE * pb, const int c, const unsigned long l, const int cb,
            const int ob)
{
    int i = 0;

    if (c)
    {
        int iLow  = 0;
        int iHigh = c;

        while (iLow < iHigh)
        {
            i = (iLow + iHigh) >> 1;

            if ((*((unsigned long *)(pb + (cb * i) + ob))) < l)
                iLow = i + 1;

            else
                iHigh = i;
        }

        i = iLow;
    }

    return i;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetBStrFromStream
//
//  Synopsis:   Given a stream, this function allocates and returns a bstr
//              representing its contents.
//
//----------------------------------------------------------------------------

HRESULT
GetBStrFromStream(IStream * pIStream, BSTR * pbstr, BOOL fStripTrailingCRLF)
{
    HRESULT  hr;
    HGLOBAL  hHtmlText = 0;
    TCHAR *  pstrWide = NULL;

    *pbstr = NULL;
    
    hr = THR(GetHGlobalFromStream(pIStream, &hHtmlText));
    if (hr)
        goto Cleanup;

    pstrWide = (TCHAR *) GlobalLock( hHtmlText );

    if (!pstrWide)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fStripTrailingCRLF)
    {
        // Remove trailing cr/lf's
        
        TCHAR * pstr = pstrWide + _tcslen(pstrWide);

        while (pstr-- > pstrWide && (*pstr == '\r' || *pstr == '\n'))
            ;

        *(pstr + 1) = 0;
    }
                
    hr = FormsAllocString(pstrWide, pbstr);

    GlobalUnlock(hHtmlText);
    
Cleanup:
    
    RRETURN(hr);
}

BOOL MakeThisTopBrowserInProcess(HWND hwnd)
{
    HWND hwndThisBrowser = NULL;
    HWND hwndTopMostBrowser = NULL;
    DWORD pid, thisPid = 0;
    TCHAR achClassName[126];

    // return if a window in the called thread has the keyboard focus
    if (::GetFocus() != NULL)
        return FALSE;

    // get top-level browser window for which the alert was called
    while(hwnd)
    {
        hwndThisBrowser = hwnd;
        hwnd = ::GetParent(hwnd);
    }

    // if found, get the pid of this one and the next top-level window above this one
    if (hwndThisBrowser)
    {
        hwnd = ::GetNextWindow(hwndThisBrowser, GW_HWNDPREV);
        ::GetWindowThreadProcessId(hwndThisBrowser, &thisPid);
    }

    // see if any of the top-level windows above this one are browser windows
    while (hwnd && thisPid)
    {
        ::GetWindowThreadProcessId(hwnd, &pid);
        // if the pids are same then it could be a browser window
        if (pid == thisPid)
        {
            ::GetClassName(hwnd, achClassName, ARRAY_SIZE(achClassName));
            // IEFrame is the classname for normally launched browsers and CabinetWClass is the
            // classname for browsers launched with window.open(). Check for both!
            if(!_tcscmp(achClassName, _T("IEFrame")) || !_tcscmp(achClassName, _T("CabinetWClass")))
                hwndTopMostBrowser = hwnd;
        }

        hwnd = ::GetNextWindow(hwnd, GW_HWNDPREV);
    }

    // if top browser window found, get the next top-level window just above it in
    // the z-order, so that this browser window can be inserted just before it (so
    // that it now becomes the top browser window).
    if (hwndTopMostBrowser)
    {
        // if there is a top browser above us and it is the currently active window, then
        // make ourselves active instead
        if (::GetForegroundWindow() == hwndTopMostBrowser)
        {
            ::SetForegroundWindow(hwndThisBrowser);
            return FALSE;
        }
        else    // else, just insert ourselves above the top browser, w/o activating
        {
            hwndTopMostBrowser = ::GetNextWindow(hwndTopMostBrowser, GW_HWNDPREV);
            if (hwndTopMostBrowser)
            {
                ::SetWindowPos(hwndThisBrowser, hwndTopMostBrowser, 0, 0, 0, 0,
                               SWP_SHOWWINDOW|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
            }
        }
    }

    return TRUE;
}


#ifndef LANG_TIBETAN
#define LANG_TIBETAN     0x51
#endif
#ifndef LANG_LAO
#define LANG_LAO         0x54
#endif

void GetSystemNumberSettings(
    NUMSHAPE * piNumShape,
    DWORD * plangNationalDigits)
{
    NUMSHAPE iNumShape = NUMSHAPE_NONE;
    DWORD langDigits = LANG_NEUTRAL;
    HKEY hkey = NULL;
    DWORD dwType;
    DWORD cbData;
    char achBufferData[41]; // Max Size user can fit in our variables edit field
    WCHAR achDigits[16];

    Assert(piNumShape != NULL && plangNationalDigits != NULL);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\International"), 0L, KEY_READ, &hkey))
    {
        goto Cleanup;
    }

    Assert(hkey != NULL);

    cbData = sizeof(achBufferData);
    if (RegQueryValueExA(hkey, "NumShape",
        0L, &dwType, (LPBYTE) achBufferData, &cbData) == ERROR_SUCCESS &&
        achBufferData[0] != TEXT('\0') && (dwType & REG_SZ) && !(dwType & REG_NONE))
    {
        iNumShape = (NUMSHAPE) max(min(atoi(achBufferData), (int) NUMSHAPE_NATIVE), (int) NUMSHAPE_CONTEXT);
    }

    RegCloseKey(hkey);

    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SNATIVEDIGITS, achDigits, 16))
    {
        switch (achDigits[4])
        {
        case 0x664: // Arabic-Indic digits
            langDigits = LANG_ARABIC;
            break;
        case 0x6F4: // Eastern Arabic-Indic digits
            langDigits = LANG_FARSI;
            break;
        case 0x96A: // Devanagari digits
            langDigits = LANG_HINDI;
            break;
        case 0x9EA: // Bengali digits
            langDigits = LANG_BENGALI;
            break;
        case 0xA6A: // Gurmukhi digits
            langDigits = LANG_PUNJABI;
            break;
        case 0xAEA: // Gujarati digits
            langDigits = LANG_GUJARATI;
            break;
        case 0xB6A: // Oriya digits
            langDigits = LANG_ORIYA;
            break;
        case 0xBEA: // Tamil digits
            langDigits = LANG_TAMIL;
            break;
        case 0xC6A: // Telugu digits
            langDigits = LANG_TELUGU;
            break;
        case 0xCEA: // Kannada digits
            langDigits = LANG_KANNADA;
            break;
        case 0xD6A: // Malayalam digits
            langDigits = LANG_MALAYALAM;
            break;
        case 0xE54: // Thai digits
            langDigits = LANG_THAI;
            break;
        case 0xED4: // Lao digits
            langDigits = LANG_LAO;
            break;
        case 0xF24: // Tibetan digits
            langDigits = LANG_TIBETAN;
            break;
        default:
            langDigits = LANG_NEUTRAL;
            break;
        }
    }
    else
    {
        // Work from the platform's locale.
        langDigits = PRIMARYLANGID(GetUserDefaultLangID());
    }
    if (langDigits != LANG_ARABIC &&
        langDigits != LANG_FARSI &&
        langDigits != LANG_HINDI &&
        langDigits != LANG_BENGALI &&
        langDigits != LANG_PUNJABI &&
        langDigits != LANG_GUJARATI &&
        langDigits != LANG_ORIYA &&
        langDigits != LANG_TAMIL &&
        langDigits != LANG_TELUGU &&
        langDigits != LANG_KANNADA &&
        langDigits != LANG_MALAYALAM &&
        langDigits != LANG_THAI &&
        langDigits != LANG_LAO &&
        langDigits != LANG_TIBETAN)
    {
        langDigits = LANG_NEUTRAL;
        iNumShape = NUMSHAPE_NONE;
    }

Cleanup:
    *piNumShape = iNumShape;
    *plangNationalDigits = langDigits;
}

HINSTANCE EnsureMLLoadLibrary()
{
#ifndef UNIX
    HINSTANCE hInst = MLLoadLibrary(_T("shdoclc.dll"), g_hInstCore, ML_CROSSCODEPAGE);
#else
    HINSTANCE hInst = MLLoadLibrary(_T("shdocvw.dll"), g_hInstCore, ML_CROSSCODEPAGE);
#endif
    if (hInst)
    {
        LOCK_GLOBALS;

        if (!g_hInstResource)
        {
            g_hInstResource = hInst;
            hInst = NULL;
        }
    }

    if (hInst)
        MLFreeLibrary(hInst);

    Assert(g_hInstResource && "Resource DLL is not loaded!");

    return g_hInstResource;
}

DWORD
CreateRandomNum(void)
{
    GUID guid;
    DWORD dw;

    CoCreateGuid(&guid);
    HashData((LPBYTE)&guid, sizeof(guid), (LPBYTE)&dw, sizeof(dw));

    return dw;
}

//+---------------------------------------------------------------------------
//
//  Function:   GCD
//
//  Synopsis:   greatest common divisor
//----------------------------------------------------------------------------
int GCD(int w1, int w2)
{
    w1 = abs(w1);
    w2 = abs(w2);

    if (w2 > w1)
    {
        int wT = w1;
            w1 = w2;
            w2 = wT;
    }
    
    if (w2 == 0)
    {
        AssertSz(0, "GCD(x,0): return 1");
        return 1;
    }

    for (;;)
    {
        if ((w1 %= w2) == 0)
            return w2;

        if ((w2 %= w1) == 0)
            return w1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\offscrn.cxx ===
//+------------------------------------------------------------------------
//
//  File:       offscrn.cxx
//
//  Contents:   OffScreen drawing utilities.
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include <coreguid.h>
#endif

#ifdef PRODUCT_PROF_FERG
// for PROFILING perposes only
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall SuspendCAP(void);
#endif

DeclareTag(tagOscStats,         "OffScreen stats",    "OffScreen statistics")
DeclareTag(tagOscClear,         "OffScreen clear",    "pre-clear offscreen buffer with green")
PerfDbgTag(tagOscCacheDisable,  "OffScreen caching",  "Disable OffScreen caching")
PerfDbgTag(tagOscUseDD,         "OffScreen DD",       "Force DirectDraw OffScreen usage")
PerfDbgTag(tagOscFullsize,      "OffScreen full size","Allow cache of a fullsize screen buffer")
PerfDbgTag(tagOscTinysize,      "OffScreen tiny size","Allow cache of a tiny screen buffer")

MtDefine(COffScreenContext, Locals, "COffScreenContext")

#if !defined(NODD)

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include <ddraw.h>
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif

// QUESTION: can we get these GUIDs from a lib from DDEx??

#define DEFINE_DD_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_DD_GUID(CLSID_DirectDrawFactory, 
0x4fd2a832, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_DD_GUID(IID_IDirectDrawFactory, 
0x4fd2a833, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_DD_GUID(IID_IDirectDraw3, 
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

IDirectDraw*        g_pDirectDraw = NULL;
HRESULT             g_hrDirectDraw = S_OK;

extern const PALETTEENTRY g_pal16[];
const PALETTEENTRY g_pal16[] = // maps to 16 colors for standard 4-bpp palette
{
//    Red   Green Blue  Flags
    { 0x00, 0x00, 0x00, 0x00 },
    { 0x80, 0x00, 0x00, 0x00 },
    { 0x00, 0x80, 0x00, 0x00 },
    { 0x80, 0x80, 0x00, 0x00 },
    { 0x00, 0x00, 0x80, 0x00 },
    { 0x80, 0x00, 0x80, 0x00 },
    { 0x00, 0x80, 0x80, 0x00 },
    { 0xC0, 0xC0, 0xC0, 0x00 },
    { 0x80, 0x80, 0x80, 0x00 },
    { 0xFF, 0x00, 0x00, 0x00 },
    { 0x00, 0xFF, 0x00, 0x00 },
    { 0xFF, 0xFF, 0x00, 0x00 },
    { 0x00, 0x00, 0xFF, 0x00 },
    { 0xFF, 0x00, 0xFF, 0x00 },
    { 0x00, 0xFF, 0xFF, 0x00 },
    { 0xFF, 0xFF, 0xFF, 0x00 }
};

extern const PALETTEENTRY g_pal2[];
const PALETTEENTRY g_pal2[] = // maps to 2 colors for standard 1-bpp palette
{
//    Red   Green Blue  Flags
    { 0x00, 0x00, 0x00, 0x00 },
    { 0xFF, 0xFF, 0xFF, 0x00 }
};

#endif // !defined(NODD)

CGlobalCriticalSection    g_csOscCache;

#define DEFAULT_HEIGHT 150

struct
{
    SIZE        _sizeTgt;
    long        _areaTgt;
    SIZE        _size;
    long        _cHits;
    long        _cMisses;
    HDC         _hdcMem;
    HPALETTE    _hpal;
    long        _cBitsPixel;
    BOOL        _fInUse;
    HBITMAP     _hbmMem;
    HBITMAP     _hbmOld;
#if !defined(NODD)
    BOOL        _fUseDD;
    BOOL        _fUse3D;
    IDirectDrawSurface* _pDDSurface;
#endif // !defined(NODD)
} g_OscCache = { 0, DEFAULT_HEIGHT };

DeclareTag(tagPalette, "Palette", "Trace Palette and ColorSet behaviour");

long GetCacheAreaTgt()
{
#if DBG==1 || defined(PERFTAGS)

    if (IsPerfDbgEnabled(tagOscFullsize))
        g_OscCache._sizeTgt.cy = GetSystemMetrics(SM_CYSCREEN);
    else if (IsPerfDbgEnabled(tagOscTinysize))
        g_OscCache._sizeTgt.cy = 8;
    else 
        g_OscCache._sizeTgt.cy = DEFAULT_HEIGHT;

    g_OscCache._sizeTgt.cx = 0;

#endif // DBG==1 || defined(PERFTAGS)
    if (g_OscCache._sizeTgt.cx == 0)
    {
        g_OscCache._sizeTgt.cx = GetSystemMetrics(SM_CXSCREEN);
        g_OscCache._areaTgt = g_OscCache._sizeTgt.cx * g_OscCache._sizeTgt.cy;
    }
    return g_OscCache._areaTgt;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::COffScreenContext
//
//  Synopsis:   Setup a DD surface or DDB for offscreen drawing.
//
//-------------------------------------------------------------------------

COffScreenContext::COffScreenContext(HDC hdcWnd, long width, long height, HPALETTE hpal, DWORD dwFlags)
{
#if !defined(NODD)
    _fUseDD = !!(dwFlags & (OFFSCR_SURFACE | OFFSCR_3DSURFACE | OFFSCR_BPP));
    _fUse3D = !!(dwFlags & OFFSCR_3DSURFACE);

#if DBG==1 || defined(PERFTAGS)
    _fUseDD |= !!IsPerfDbgEnabled(tagOscUseDD);
#endif // DBG==1 || defined(PERFTAGS)
#endif // !defined(NODD)

    GetCacheAreaTgt();

    Assert(hdcWnd);
    _hdcWnd = hdcWnd;
    _hdcMem = NULL;

    _nSavedDC = 0;
    _fOffScreen = FALSE;
    _hbmMem = NULL;
#if !defined(NODD)
    _pDDSurface = NULL; 
#endif // !defined(NODD)

    // zero width means use default cache dimensions
    if (width == 0)
    {
        _widthActual  = g_OscCache._sizeTgt.cx;
        _heightActual = g_OscCache._sizeTgt.cy;
    }
    else
    {
        _widthActual  = width;
        _heightActual = height;
    }

#if DBG == 1
    extern void DumpPalette(CHAR *sz, HPALETTE hpal);

    DumpPalette("Destination DC", (HPALETTE)GetCurrentObject(hdcWnd, OBJ_PAL));
    DumpPalette("Offscreen buffer", hpal);
#endif

    _fCaret = !!(dwFlags & OFFSCR_CARET);

    _cBitsPixel = dwFlags & OFFSCR_BPP;
    switch (_cBitsPixel)
    {
    case 1:
    case 4:
    case 8:
    case 16:
    case 24:
    case 32:
        break;
    default:
        // if the hdc could be an OBJ_MEMDC we'd have to GetCurrentObject(HBITMAP)
        // and GetObject() to get the cBitsPixel
        //NOTE GetObjectType throws first change exceptions. Turn off to clean up dbg output.
        //Assert(GetObjectType(_hdcWnd) == OBJ_DC);

        // here we handle poorly-specified cases, but especially
        // (from the bufferDepth property):
        //       0 - which means DEFAULT DDB buffering at the screen depth
        //      -1 - which means EXPLICIT DD surface buffering at the screen depth
        _cBitsPixel = GetDeviceCaps(_hdcWnd, PLANES) * GetDeviceCaps(_hdcWnd, BITSPIXEL);
        break;
    }

#if !defined(NODD)
    TraceTag((tagOscStats, "OffScreen construct - DD: %d width: %d height: %d BitsPixel: %d",
            _fUseDD, _widthActual, _heightActual, _cBitsPixel));
#endif

    if (_cBitsPixel == 8)
    {
        if (hpal == NULL)
        {
            Assert(g_hpalHalftone);
            hpal = g_hpalHalftone;
        }
    }
    else
    {
        hpal = NULL;
    }

#if !defined(NODD)
    // we either need to use one or we already have one (frankman)
    if (_fUseDD || g_OscCache._pDDSurface)
    {
        _fUseDD = TRUE; 
	    if (!GetDDSurface(hpal))
            return;
    }
    else
#endif // !defined(NODD)
    {
	    if (!GetDDB(hpal))
            return;
    }

    // We have succesfully created the offscreen context.

    _fOffScreen = TRUE;

    // set palette
    if (hpal)
    {
        Verify(SelectPalette(_hdcMem, hpal, TRUE));
        RealizePalette(_hdcMem);
    }

    TraceTag((tagOscStats, "OffScreen Cache - hits: %d misses: %d widthTgt: %d heightTgt: %d",
            g_OscCache._cHits, g_OscCache._cMisses,
            g_OscCache._sizeTgt.cx, g_OscCache._sizeTgt.cy));

    return;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::GetDC
//
//  Synopsis:   Get the DC and establish view parameters.
//
//-------------------------------------------------------------------------

HDC COffScreenContext::GetDC(RECT *prc)
{
    if (_fOffScreen)
    {
        _rc = *prc;
        _nSavedDC = SaveDC(_hdcMem);
        Assert(_nSavedDC);
#if DBG==1
        if (IsTagEnabled(tagOscClear))
        {
            HBRUSH  hbr;
            RECT    rc;

            // Fill the rect with green
            hbr = GetCachedBrush(RGB(0,255,0));
            SetRect(&rc, 0, 0, _widthActual, _heightActual);
            FillRect(_hdcMem, &rc, hbr);
            ReleaseCachedBrush(hbr);
        }
#endif
        SetViewportOrgEx(_hdcMem, -_rc.left, -_rc.top, (POINT *)NULL);
        return _hdcMem;
    }
    return _hdcWnd;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::ReleaseDC
//
//  Synopsis:   If painting offscreen, blt the bits to the screen.
//
//-------------------------------------------------------------------------

HDC COffScreenContext::ReleaseDC(HWND hwnd, BOOL fDraw /* = TRUE */ )
{
    if (_fOffScreen)
    {
        if (fDraw)
        {
            if (_fCaret)
            {
                ::HideCaret(hwnd);
            }
            
            BitBlt(_hdcWnd, _rc.left, _rc.top, _rc.right - _rc.left, _rc.bottom - _rc.top,
                _hdcMem, _rc.left, _rc.top,
                SRCCOPY);
            
            if (_fCaret)
            {
                ::ShowCaret(hwnd);
            }
        }

        if (_nSavedDC)
        {
            Verify(RestoreDC(_hdcMem, _nSavedDC));
            _nSavedDC = 0;
        }
    }
    return _hdcWnd;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::~COffScreenContext()
//
//  Synopsis:   Release resources used by this class.
//
//-------------------------------------------------------------------------

COffScreenContext::~COffScreenContext()
{
    _fOffScreen = FALSE;
    if (_nSavedDC)
    {
        // restore the DC for the cached case
        Verify(RestoreDC(_hdcMem, _nSavedDC));
        _nSavedDC = 0;
    }

	// Put back a reasonable palette so ours can be deleted safely
	Verify(SelectPalette(_hdcMem, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE));

#if !defined(NODD)
    if (_fUseDD)
    {
        ReleaseDDSurface();
    }
    else
#endif // !defined(NODD)
    {
        ReleaseDDB();
    }
}

#if !defined(NODD)
//+------------------------------------------------------------------------
//
//  Function:   ClearSurfaceCache()
//
//  Synopsis:   Free the cached DD surface, if any.
//
//-------------------------------------------------------------------------

void ClearSurfaceCache()
{
    // Quick test without entering critical section, then retest afterwards in case it
    // changes.

    if (!g_OscCache._fInUse && g_OscCache._fUseDD && g_OscCache._pDDSurface != NULL)
    {
        LOCK_SECTION(g_csOscCache);

        if (!g_OscCache._fInUse && g_OscCache._fUseDD && g_OscCache._pDDSurface != NULL)
        {
            TraceTag((tagOscStats, "surface cache deleted"));
            if (g_OscCache._hdcMem)
            {
                Verify(SelectPalette(g_OscCache._hdcMem, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE));
                Verify(g_OscCache._pDDSurface->ReleaseDC(g_OscCache._hdcMem) == DD_OK);
                g_OscCache._hdcMem = NULL;
            }
            ClearInterface(&g_OscCache._pDDSurface);
            g_OscCache._fUseDD = FALSE;
        }
    }
}
#endif // !defined(NODD)

//+------------------------------------------------------------------------
//
//  Function:   ClearDDBCache()
//
//  Synopsis:   Free the cached DDD, if any.
//
//-------------------------------------------------------------------------

void ClearDDBCache()
{
    if (!g_OscCache._fInUse && 
#if !defined(NODD)
        !g_OscCache._fUseDD &&
#endif // !defined(NODD)
        g_OscCache._hbmMem != NULL)
    {
        TraceTag((tagOscStats, "DDB cache deleted"));
        if (g_OscCache._hdcMem)
        {
            if (g_OscCache._hbmOld)
                SelectObject(g_OscCache._hdcMem, g_OscCache._hbmOld);
            g_OscCache._hbmOld = NULL;
            DeleteDC(g_OscCache._hdcMem);
            g_OscCache._hdcMem = NULL;
        }
        DeleteObject(g_OscCache._hbmMem);
        g_OscCache._hbmMem = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   InitSurface
//
//  Synopsis:   Allocate DirectDraw object which is used to create surfaces
//              for offscreen rendering
//
//-----------------------------------------------------------------------------

HRESULT InitSurface()
{
#if !defined(NODD)

    if (g_hrDirectDraw || g_pDirectDraw)  // DD already initialized (or failed)
        return(g_hrDirectDraw);

#ifdef PRODUCT_PROF_FERG
    // for PROFILING perposes only
    ::SuspendCAP();
#endif

    LOCK_SECTION(g_csOscCache);

    // Check again after obtaining the lock
    // (since another thread could have made the attempt while we waited)
    if (g_hrDirectDraw || g_pDirectDraw)
        return (g_hrDirectDraw);

    IDirectDrawFactory* pDDFactory = NULL;
    // create the DDFactory used to create the DirectDraw object
    g_hrDirectDraw = THR(CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC_SERVER,
                           IID_IDirectDrawFactory, (void **)&pDDFactory));
    if (SUCCEEDED(g_hrDirectDraw))
    {
        // DirectDraw will put up annoying UI if the bpp is less than 8.
        // Low bpp video cards are simply not support.  Force DirectDraw to
        // silently quietly fail under this circumstance.
        DWORD dwMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        // create the actual DirectDraw object from which we can create surfaces later
        g_hrDirectDraw = THR(pDDFactory->CreateDirectDraw(NULL, GetDesktopWindow(),
                                            DDSCL_NORMAL, 0, NULL, &g_pDirectDraw));
        SetErrorMode( dwMode );

        // release the factory
        ReleaseInterface((IUnknown*)pDDFactory);
    }
#ifdef PRODUCT_PROF_FERG
    // for PROFILING perposes only
    ::ResumeCAP();
#endif

    RRETURN(g_hrDirectDraw);
#else
    return S_OK;
#endif // !defined(NODD)
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitSurface
//
//  Synopsis:   Release the DirectDraw surface factory and all our cached surfaces.
//
//-----------------------------------------------------------------------------

void DeinitSurface()
{
    LOCK_SECTION(g_csOscCache);
#if !defined(NODD)
    ClearSurfaceCache();
    ClearInterface(&g_pDirectDraw);
#endif // !defined(NODD)
    ClearDDBCache();
    TraceTag((tagOscStats, "OffScreen Cache - hits: %d misses: %d widthTgt: %d heightTgt: %d",
            g_OscCache._cHits, g_OscCache._cMisses,
            g_OscCache._sizeTgt.cx, g_OscCache._sizeTgt.cy));
}

#if !defined(NODD)
// NOTE: can't be const, modified by PixelFormat()
DDPIXELFORMAT aPixelFormats[] =
{
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED1, 0, 1, 0, 0, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED4, 0, 4, 0, 0, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED8, 0, 8, 0, 0, 0, 0}, 
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x0000F800, 0x000007E0, 0x0000001F, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0x00FF0000, 0x0000FF00, 0x000000FF, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0}
};

//+------------------------------------------------------------------------
//
//  Function:   PixelFormat()
//
//  Synopsis:   Return a pointer to the DDPIXELFORMAT structure compatible
//              with the specified bits-per-pixel (and HDC, if 16-bpp).
//
//-------------------------------------------------------------------------

DDPIXELFORMAT* PixelFormat(HDC hdc, long cBitsPixel)
{
    static BOOL fMaskInit = FALSE;

    DDPIXELFORMAT* pPF = NULL;
    for (int i = 0; i < ARRAY_SIZE(aPixelFormats); i++)
    {
        if (aPixelFormats[i].dwRGBBitCount == (DWORD)cBitsPixel)
        {
            pPF = &aPixelFormats[i];
            break;
        }
    }

    if (cBitsPixel == 16 && !fMaskInit)
    {
        // for 16-bit displays we need to decide if we're 555 or 565
        // cacheing this answer assumes we're only dealing with 16-bit
        // screen displays and that the bit format won't change on the fly
        fMaskInit = TRUE;
        HBITMAP hbm;
        struct
        {
            BITMAPINFOHEADER bih;
            DWORD            bf[3];
        }   bi;
        hbm = CreateCompatibleBitmap(hdc, 1, 1);
        if (!hbm)
            return NULL;
        memset(&bi, 0, sizeof(bi));
        bi.bih.biSize = sizeof(BITMAPINFOHEADER);

        // first call will fill in the optimal biBitCount
        GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
        if (bi.bih.biBitCount == 16)
        {
            // we'll default to the preset 5-6-5 if screen is not in 16-bit mode
            // second call will get the optimal bitfields
            GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
            // Win95 only supports 5-5-5 and 5-6-5
            // For NT we'll assume this covers the majority cases too
            pPF->dwRBitMask = bi.bf[0]; // red mask
            pPF->dwGBitMask = bi.bf[1]; // green mask
            pPF->dwBBitMask = bi.bf[2]; // blue mask
        }
        else
        {
            Assert(0 && "invalid biBitCount");
        }
        DeleteObject(hbm);
    }
    return pPF;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::CreateDDSurface
//
//  Synopsis:   Create a DD surface with the specified dimensions and palette.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::CreateDDSurface(long width, long height, HPALETTE hpal)
{
    HRESULT hr = InitSurface();
    if (FAILED(hr))
        return FALSE;

    DDPIXELFORMAT* pPF = PixelFormat(_hdcWnd, _cBitsPixel);
    if (!pPF)
        return FALSE;

    DDSURFACEDESC	ddsd;

	ddsd.dwSize = sizeof(ddsd);
    ddsd.ddpfPixelFormat = *pPF;
	ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	ddsd.ddsCaps.dwCaps = DDSCAPS_DATAEXCHANGE | DDSCAPS_OWNDC;
    if (_fUse3D)
        ddsd.ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
	ddsd.dwWidth = width;
	ddsd.dwHeight = height;
	hr = THR(g_pDirectDraw->CreateSurface(&ddsd, &_pDDSurface, NULL));
    if (FAILED(hr))
        return FALSE;

    // set color table
    if (_cBitsPixel <= 8)
    {
        IDirectDrawPalette* pDDPal;
        const PALETTEENTRY* pPal;
        PALETTEENTRY        pal256[256];
        long                cEntries;
        DWORD		        pcaps;
        
        if (_cBitsPixel == 8)
        {
            cEntries = GetPaletteEntries(hpal, 0, 256, pal256);
            pPal = pal256;
            pcaps = DDPCAPS_8BIT;
        }
        else if (_cBitsPixel == 4)
        {
            cEntries = 16;
            pPal = g_pal16;
            pcaps = DDPCAPS_4BIT;
        }
        else if (_cBitsPixel == 1)
        {
            cEntries = 2;
            pPal = g_pal2;
            pcaps = DDPCAPS_1BIT;
        }
        else
        {
            Assert(0 && "invalid cBitsPerPixel");
            return FALSE;
        }
        
        // create and initialize a new DD palette
        hr = THR(g_pDirectDraw->CreatePalette(pcaps | DDPCAPS_INITIALIZE, (LPPALETTEENTRY) pPal, &pDDPal, NULL));
        if (SUCCEEDED(hr))
        {
            // attach the DD palette to the DD surface
            hr = THR(_pDDSurface->SetPalette(pDDPal));
            pDDPal->Release();
        }
        if (FAILED(hr))
            return FALSE;
    }


    hr = THR(_pDDSurface->GetDC(&_hdcMem));
    return SUCCEEDED(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::GetDDSurface
//
//  Synopsis:   Create a suitable DD surface or get one from the cache.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::GetDDSurface(HPALETTE hpal)
{
    HRESULT hr;

    LOCK_SECTION(g_csOscCache);

    if (!g_OscCache._fInUse
#if DBG==1 || defined(PERFTAGS)
         && !IsPerfDbgEnabled(tagOscCacheDisable)
#endif
         )
    {
        ClearDDBCache();    // don't allow both DD & DDB in the cache

        if (g_OscCache._pDDSurface != NULL)
        {
            Assert(g_OscCache._fUseDD);
            if (_widthActual > g_OscCache._size.cx
                || _heightActual > g_OscCache._size.cy
                || _cBitsPixel != g_OscCache._cBitsPixel
                || (_fUse3D && !g_OscCache._fUse3D))
            {
                ++g_OscCache._cMisses;
                ClearSurfaceCache();
            }
            else
            {
                ++g_OscCache._cHits;
                g_OscCache._fInUse = TRUE;
                _pDDSurface   = g_OscCache._pDDSurface;
                _pDDSurface->AddRef();
                _hdcMem       = g_OscCache._hdcMem;
                _widthActual  = g_OscCache._size.cx;
                _heightActual = g_OscCache._size.cy;
            }
        }
        if (g_OscCache._pDDSurface == NULL)
        {
            // use max area allowed for the cache, so we get max reuse potential
            // favor width over height for those wide text runs
            // also adjust the max size in a growing fashion based on former allocations
            
            g_OscCache._size.cx  = max(g_OscCache._size.cx, max(min(g_OscCache._areaTgt / _heightActual, g_OscCache._sizeTgt.cx), _widthActual));
            g_OscCache._size.cy = max(g_OscCache._size.cy , max(g_OscCache._areaTgt / g_OscCache._size.cx, _heightActual));
            if (!CreateDDSurface(g_OscCache._size.cx, g_OscCache._size.cy, hpal))
                return FALSE;
            TraceTag((tagOscStats, "surface cache created"));
            g_OscCache._fInUse     = TRUE;
            g_OscCache._fUseDD     = TRUE;
            g_OscCache._fUse3D     = _fUse3D;
            g_OscCache._pDDSurface = _pDDSurface;
            g_OscCache._pDDSurface->AddRef();        // addref the global surface
            g_OscCache._cBitsPixel = _cBitsPixel;
            g_OscCache._hdcMem     = _hdcMem;
            g_OscCache._hpal       = hpal;
            _widthActual           = g_OscCache._size.cx;
            _heightActual          = g_OscCache._size.cy;
        }
    }
    else
    {
        TraceTag((tagOscStats, "surface cache in use"));
    }

    if (_pDDSurface == NULL)
    {
        if (!CreateDDSurface(_widthActual, _heightActual, hpal))
            return FALSE;
    }

    // reset the color table when using cache
    if (_cBitsPixel == 8
        && _pDDSurface == g_OscCache._pDDSurface
        && hpal != g_OscCache._hpal
        && hpal != g_hpalHalftone)
    {
        IDirectDrawPalette* pDDPal;
        PALETTEENTRY        pal256[256];
        long                cEntries;
        
        cEntries = GetPaletteEntries(hpal, 0, 256, pal256);
        
        // get the DD palette and set entries
        hr = THR(_pDDSurface->GetPalette(&pDDPal));
        if (SUCCEEDED(hr))
        {
            hr = THR(pDDPal->SetEntries(0, 0, cEntries, pal256));
            pDDPal->Release();
            if (SUCCEEDED(hr))
            {
                g_OscCache._hpal = hpal;
            }
        }
    }

    return TRUE;
}
    
//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::ReleaseDDSurface
//
//  Synopsis:   Release the DD surface or return it to the cache.
//
//-------------------------------------------------------------------------

void COffScreenContext::ReleaseDDSurface()
{
    if (_pDDSurface == NULL)
        return;
    
    if (_pDDSurface == g_OscCache._pDDSurface)
    {
        // keep the surface cache; mark as available
        LOCK_SECTION(g_csOscCache);

        Assert(g_OscCache._fInUse);
        g_OscCache._fInUse = FALSE; 
        
        // If some rogue client left the surface locked we could be locked out for a long time.
        // So, to be more robust, we attempt to lock the surface and if we fail, we discard the
        // cache so we can start fresh next time.
        DDSURFACEDESC desc;
        desc.dwSize = sizeof(desc);

        HRESULT hr = _pDDSurface->Lock(NULL, &desc, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
        if (hr == S_OK)
        {
            _pDDSurface->Unlock(NULL);
        }
        else
        {
            Assert(0 && "DD surface left locked!");
            // release the surface cache
            ClearSurfaceCache();
        }
        _pDDSurface->Release();

    }
    else
    {
        // free the non-cached surface
        if (_hdcMem)
        {
            _pDDSurface->ReleaseDC(_hdcMem);
            _hdcMem = NULL;
        }
        _pDDSurface->Release();
    }
    _pDDSurface = NULL;
}
#endif // !defined(NODD)


//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::CreateDDB
//
//  Synopsis:   Create a DDB with the specified dimensions.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::CreateDDB(long width, long height)
{
    _hbmMem = CreateCompatibleBitmap(_hdcWnd, width, height);
    if (!_hbmMem)
        return FALSE;

    _hdcMem = CreateCompatibleDC(_hdcWnd);
    if (!_hdcMem)
        return FALSE;

    _hbmOld = (HBITMAP)SelectObject(_hdcMem, _hbmMem);
    if (!_hbmOld)
        return FALSE;

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::GetDDB
//
//  Synopsis:   Create a suitable DDB or get one from the cache.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::GetDDB(HPALETTE hpal)
{
    LOCK_SECTION(g_csOscCache);

    if (!g_OscCache._fInUse
#if DBG==1 || defined(PERFTAGS)
         && !IsPerfDbgEnabled(tagOscCacheDisable)
#endif
         )
    {
#if !defined(NODD)
        ClearSurfaceCache();    // don't allow both DD & DDB in the cache
#endif // !defined(NODD)

        if (g_OscCache._hbmMem != NULL)
        {
            if (_widthActual > g_OscCache._size.cx
                || _heightActual > g_OscCache._size.cy
                || _cBitsPixel != g_OscCache._cBitsPixel)
            {
                ++g_OscCache._cMisses;
                ClearDDBCache();
            }
            else
            {
                ++g_OscCache._cHits;
                g_OscCache._fInUse = TRUE;
                _hbmMem       = g_OscCache._hbmMem;
                _hdcMem       = g_OscCache._hdcMem;
                _widthActual  = g_OscCache._size.cx;
                _heightActual = g_OscCache._size.cy;
            }
        }
        if (g_OscCache._hbmMem == NULL
            && _widthActual * _heightActual <= g_OscCache._areaTgt)
        {
            // use max area allowed for the cache, so we get max reuse potential
            // favor width over height for those wide text runs
            g_OscCache._size.cx  = max(min(g_OscCache._areaTgt / _heightActual, g_OscCache._sizeTgt.cx), _widthActual);
            g_OscCache._size.cy = max(g_OscCache._areaTgt / g_OscCache._size.cx, _heightActual);
            if (!CreateDDB(g_OscCache._size.cx, g_OscCache._size.cy))
                return FALSE;
            TraceTag((tagOscStats, "DDB cache created"));
            g_OscCache._fInUse     = TRUE;
            g_OscCache._hbmMem     = _hbmMem;
            g_OscCache._hbmOld     = _hbmOld;
            g_OscCache._cBitsPixel = _cBitsPixel;
            g_OscCache._hdcMem     = _hdcMem;
            g_OscCache._hpal       = hpal;
            _widthActual           = g_OscCache._size.cx;
            _heightActual          = g_OscCache._size.cy;
        }
    }
    else
    {
        TraceTag((tagOscStats, "DDB cache in use"));
    }

    if (_hbmMem == NULL)
    {
        if (!CreateDDB(_widthActual, _heightActual))
            return FALSE;
    }

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::ReleaseDDB
//
//  Synopsis:   Release the DDB or return it to the cache.
//
//-------------------------------------------------------------------------

void COffScreenContext::ReleaseDDB()
{
    if (_hbmMem == NULL)
        return;

    if (_hbmMem == g_OscCache._hbmMem)
    {
        // keep the DDB cache; mark as available
        LOCK_SECTION(g_csOscCache);
        Assert(g_OscCache._fInUse);
        g_OscCache._fInUse = FALSE;
    }
    else
    {
        // Prevent Windows from RIPing when we delete our palette later on
        Verify(SelectPalette(_hdcMem, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE));

        // free the non-cached DDB
        if (_hbmOld)
            SelectObject(_hdcMem, _hbmOld);
        _hbmOld = NULL;
        DeleteDC(_hdcMem);
        _hdcMem = NULL;
        DeleteObject(_hbmMem);
    }
    _hbmMem = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\hlink16.cxx ===
//+------------------------------------------------------------------------
//
//  File:       chlink.cxx
//  Created :   27th June 1997
//  Contents:   Implementing IHlink.
//              Done for storing and retrieving the 
//              bookmark fragment of an URL
//              Constructor - initializes the bookmark "_szLocation"
//              GetMonikerReference - Currently used for retrieving the bookmark
//              HlinkCreateFromMoniker - Instantiates the CHlink class   
//-------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HLINK_H_
#define X_HLINK_X_
#include "hlink.h"        // for std hyperlink object
#endif

class CHlink : public IHlink
{
public:
    CHlink();
    CHlink(IMoniker* pmk, LPCTSTR pszLocation, LPCSTR pszFriedlyName);
    ~CHlink();

    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE  QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual ULONG STDMETHODCALLTYPE AddRef(void) ;
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // *** IOleWindow methods ***
        virtual HRESULT STDMETHODCALLTYPE SetHlinkSite( 
            /* [unique][in] */ IHlinkSite __RPC_FAR *pihlSite,
            /* [in] */ DWORD dwSiteData) ;
        
        virtual HRESULT STDMETHODCALLTYPE GetHlinkSite( 
            /* [out] */ IHlinkSite __RPC_FAR *__RPC_FAR *ppihlSite,
            /* [out] */ DWORD __RPC_FAR *pdwSiteData) ;

        virtual HRESULT STDMETHODCALLTYPE GetMonikerReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppimkTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation);

        virtual HRESULT STDMETHODCALLTYPE GetStringReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ LPWSTR __RPC_FAR *ppwzTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation);

        virtual HRESULT STDMETHODCALLTYPE GetFriendlyName( 
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ LPWSTR __RPC_FAR *ppwzFriendlyName);

            virtual HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ LPBC pibc,
            /* [unique][in] */ IBindStatusCallback __RPC_FAR *pibsc,
            /* [unique][in] */ IHlinkBrowseContext __RPC_FAR *pihlbc);

  
    virtual HRESULT STDMETHODCALLTYPE SetMonikerReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ IMoniker __RPC_FAR *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation) ;
        
    virtual HRESULT STDMETHODCALLTYPE SetStringReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ LPCWSTR pwzTarget,
            /* [unique][in] */ LPCWSTR pwzLocation) ;
                
    virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [unique][in] */ LPCWSTR pwzFriendlyName) ;
        
        
    virtual HRESULT STDMETHODCALLTYPE SetTargetFrameName( 
            /* [unique][in] */ LPCWSTR pwzTargetFrameName) ;
        
    virtual HRESULT STDMETHODCALLTYPE GetTargetFrameName( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzTargetFrameName) ;
        
    virtual HRESULT STDMETHODCALLTYPE GetMiscStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
    virtual HRESULT STDMETHODCALLTYPE SetAdditionalParams( 
            /* [unique][in] */ LPCWSTR pwzAdditionalParams) ;
        
    virtual HRESULT STDMETHODCALLTYPE GetAdditionalParams( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzAdditionalParams);


protected:
    UINT	_cRef;
    IHlinkSite* _pihlSite;
    IMoniker*   _pmk;
    TCHAR	_szLocation[MAX_PATH];
};

CHlink::CHlink(IMoniker* pmk, LPCTSTR pszLocation, LPCSTR pszFriedlyName)
		    : _cRef(1), _pihlSite(NULL), _pmk(pmk)
{
    if (_pmk) {
	_pmk->AddRef();
    }
    if (pszLocation) {
	lstrcpy(_szLocation, pszLocation);
    } else {
	_szLocation[0] = '\0';
    }
}


CHlink::~CHlink()
{
    if (_pmk) {
	_pmk->Release();
    }

    if (_pihlSite) {
	_pihlSite->Release();
    }
}

HRESULT CHlink::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
     if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IHlink))
    {
        *ppvObj = (IHlink *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
    
}

ULONG CHlink::AddRef(void)
{
    return ++_cRef;
}

ULONG CHlink::Release(void)
{
    if (--_cRef > 0) {
	return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CHlink::SetHlinkSite( 
            /* [unique][in] */ IHlinkSite __RPC_FAR *pihlSite,
            /* [in] */ DWORD dwSiteData) 
{
    if (_pihlSite) {
	_pihlSite->Release();
    }

    _pihlSite = pihlSite;

    if (_pihlSite) {
	_pihlSite->AddRef();
    }

    return S_OK;
}

HRESULT CHlink::GetHlinkSite( 
            /* [out] */ IHlinkSite __RPC_FAR *__RPC_FAR *ppihlSite,
            /* [out] */ DWORD __RPC_FAR *pdwSiteData) 
{
    *ppihlSite = _pihlSite;
    if (_pihlSite) {
	_pihlSite->AddRef();
    }

    return S_OK;
}

HRESULT CHlink::GetMonikerReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ IMoniker **ppimkTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation)
{
    if (ppimkTarget) {
	*ppimkTarget = _pmk;
	if (_pmk) {
	    _pmk->AddRef();
	}
    }

    if (ppwzLocation) 
    {
        *ppwzLocation = SysAllocString ( _szLocation ) ;
    }
    
    return S_OK;
}

HRESULT CHlink::GetStringReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ LPWSTR __RPC_FAR *ppwzTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation)
{
    return E_NOTIMPL;
}

HRESULT CHlink::GetFriendlyName( 
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ LPWSTR __RPC_FAR *ppwzFriendlyName){
    return E_NOTIMPL;
}

HRESULT CHlink::Navigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ LPBC pibc,
            /* [unique][in] */ IBindStatusCallback __RPC_FAR *pibsc,
            /* [unique][in] */ IHlinkBrowseContext __RPC_FAR *pihlbc)
{
       return E_NOTIMPL ;
}


HRESULT CHlink::SetMonikerReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ IMoniker __RPC_FAR *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation)
{
 return E_NOTIMPL ;   
}
        
HRESULT CHlink::SetStringReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ LPCWSTR pwzTarget,
            /* [unique][in] */ LPCWSTR pwzLocation)
{
    return E_NOTIMPL ;
}
                
HRESULT CHlink::SetFriendlyName( 
            /* [unique][in] */ LPCWSTR pwzFriendlyName)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::SetTargetFrameName( 
            /* [unique][in] */ LPCWSTR pwzTargetFrameName)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::GetTargetFrameName( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzTargetFrameName)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::GetMiscStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::SetAdditionalParams( 
            /* [unique][in] */ LPCWSTR pwzAdditionalParams)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::GetAdditionalParams( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzAdditionalParams)
{
    return E_NOTIMPL ;
}

STDAPI HlinkCreateFromMoniker(
             IMoniker * pimkTrgt,
             LPCWSTR pwzLocation,
             LPCWSTR pwzFriendlyName,
             IHlinkSite * pihlsite,
             DWORD dwSiteData,
             IUnknown * piunkOuter,
             REFIID riid,
             void ** ppvObj)
               
{
    if ( pimkTrgt == NULL)
        return E_FAIL;
                          
		CHlink *ptemp = NULL;
        
        ptemp = new CHlink ( pimkTrgt, pwzLocation, pwzFriendlyName) ; 
        if ( !ptemp )
        	return E_OUTOFMEMORY ;

        *ppvObj = NULL ;                          

        *ppvObj = (void * )ptemp ;
        

    return S_OK ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\misccom.cxx ===
//+------------------------------------------------------------------------
//
//  File:       misccom.cxx
//
//  Contents:   Misc COM object helper functions.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)



//+------------------------------------------------------------------------
//
//  Function:   ClearInterfaceFn
//
//  Synopsis:   Sets an interface pointer to NULL, after first calling
//              Release if the pointer was not NULL initially
//
//  Arguments:  [ppUnk]     *ppUnk is cleared
//
//-------------------------------------------------------------------------

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ClearClassFn
//
//  Synopsis:   Nulls a pointer to a class, releasing the class via the
//              provided IUnknown implementation if the original pointer
//              is non-NULL.
//
//  Arguments:  [ppv]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ClearClassFn(void ** ppv, IUnknown * pUnk)
{
    *ppv = NULL;
    if (pUnk)
        pUnk->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReplaceInterfaceFn
//
//  Synopsis:   Replaces an interface pointer with a new interface,
//              following proper ref counting rules:
//
//              = *ppUnk is set to pUnk
//              = if *ppUnk was not NULL initially, it is Release'd
//              = if pUnk is not NULL, it is AddRef'd
//
//              Effectively, this allows pointer assignment for ref-counted
//              pointers.
//
//  Arguments:  [ppUnk]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk)
{
    IUnknown * pUnkOld = *ppUnk;

    *ppUnk = pUnk;

    //  Note that we do AddRef before Release; this avoids
    //    accidentally destroying an object if this function
    //    is passed two aliases to it

    if (pUnk)
        pUnk->AddRef();

    if (pUnkOld)
        pUnkOld->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReleaseInterface
//
//  Synopsis:   Releases an interface pointer if it is non-NULL
//
//  Arguments:  [pUnk]
//
//-------------------------------------------------------------------------

void
ReleaseInterface(IUnknown * pUnk)
{
    if (pUnk)
        pUnk->Release();
}


//+---------------------------------------------------------------
//
// Function:    IsSameObject
//
// Synopsis:    Checks for COM identity
//
// Arguments:   pUnkLeft, pUnkRight
//
//+---------------------------------------------------------------

BOOL
IsSameObject(IUnknown *pUnkLeft, IUnknown *pUnkRight)
{
    IUnknown *pUnk1, *pUnk2;

    if (pUnkLeft == pUnkRight)
        return TRUE;

    if (pUnkLeft == NULL || pUnkRight == NULL)
        return FALSE;

    if (SUCCEEDED(pUnkLeft->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk1)))
    {
        pUnk1->Release();
        if (pUnk1 == pUnkRight)
            return TRUE;
        if (SUCCEEDED(pUnkRight->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk2)))
        {
            pUnk2->Release();
            return pUnk1 == pUnk2;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------
//
//  Function:   GetResource
//
//  Synopsis:   Loads any kind of resource.
//
//  Arguments:  [hinst] -- instance of the module with the resource
//              [lpstrId] -- the identifier of the resource
//              [lpstrType] -- the identifier of the resource type
//              [pcbSize] -- points to the out param: the number of bytes of resource data to load
//
//  Returns:    lpvBuf if the resource was successfully loaded, NULL otherwise
//
//  Notes:      This function combines Windows' FindResource, LoadResource,
//              LockResource.
//
//----------------------------------------------------------------

LPVOID
GetResource(HINSTANCE hinst,
            LPCTSTR lpstrId,
            LPCTSTR lpstrType,
            ULONG * pcbSize)
{
    LPVOID  lpv;
    HGLOBAL hgbl;
    HRSRC   hrsrc;

    hrsrc = FindResource(hinst, lpstrId, lpstrType);
    if (!hrsrc)
        return NULL;

    hgbl = LoadResource(hinst, hrsrc);
    if (!hgbl)
        return NULL;

    lpv = LockResource(hgbl);
    if ( pcbSize )
    {
        *pcbSize = lpv ? ::SizeofResource(hinst, hrsrc) : 0;
    }

#if !defined(_MAC) && !defined(UNIX)
    //  Win95 is said to need this
    FreeResource(hgbl);
#endif

    return lpv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\perfdbg.cxx ===
//+------------------------------------------------------------------------
//
//  File:       perfdbg.cxx
//
//  Contents:   PerfDbgLogFn
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#if DBG==1

static CGlobalCriticalSection s_csPerfDbg;

int __cdecl PerfDbgLogFn(int tag, void * pvObj, char * pchFmt, ...)
{
    static char ach[1024];

    if (IsPerfDbgEnabled(tag))
    {
        LOCK_SECTION(s_csPerfDbg);

        va_list vl;
        va_start(vl, pchFmt);
        ach[0] = 0;
        wsprintfA(ach, "[%lX] %8lX ", GetCurrentThreadId(), pvObj);
        wvsprintfA(ach + lstrlenA(ach), pchFmt, vl);
        TraceTag((tag, "%s", ach));
        va_end(vl);
    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    CClassFactory
//              CStaticCF
//              CDynamicCF
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_CLSFAC3_HXX_
#define X_CLSFAC3_HXX_
#include "clsfac3.hxx"
#endif


//+---------------------------------------------------------------
//
//  Member:     CClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CClassFactory::AddRef
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CClassFactory::AddRef()
{
    IncrementSecondaryObjectCount( 4 );
    return 1;
}


//+---------------------------------------------------------------
//
//  Member:     CClassFactory::Release
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CClassFactory::Release(void)
{
    DecrementSecondaryObjectCount( 4 );
    return 1;
}


//+---------------------------------------------------------------
//
//  Member:     CClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface.
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
CClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        IncrementSecondaryObjectCount(4);
    else
        DecrementSecondaryObjectCount(4);

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CStaticCF::CreateInstance, public
//
//  Synopsis:   Method of IClassFactory interface.
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticCF::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID iid,
    void **ppv)
{
    HRESULT hr;
    IUnknown *pUnk = 0;

    *ppv = NULL;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;

    if (pUnkOuter && iid != IID_IUnknown)
        return E_INVALIDARG;

    if (!_pfnCreate)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR((*_pfnCreate)(pUnkOuter, &pUnk));
    if (hr)
        goto Cleanup;

    if (pUnkOuter)
    {
        *ppv = pUnk;
    }
    else 
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::CDynamicCF
//
//  Synopsis:   Constructor.
//
//----------------------------------------------------------------------------

CDynamicCF::CDynamicCF()
{
    _ulRefs = 1;
    IncrementSecondaryObjectCount( 5 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::~CDynamicCF
//
//  Synopsis:   Destructor.
//
//----------------------------------------------------------------------------

CDynamicCF::~CDynamicCF()
{
    DecrementSecondaryObjectCount( 5 );
}


//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDynamicCF::AddRef()
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDynamicCF::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }
    return _ulRefs;
}


BEGIN_TEAROFF_TABLE_(CStaticCF3, IClassFactoryEx)
    TEAROFF_METHOD(CStaticCF3, CreateInstance, createinstance, (IUnknown *punkOuter, REFIID riid, void **ppvObject))
    TEAROFF_METHOD(CStaticCF3, LockServer, lockserver, (BOOL fLock))
    TEAROFF_METHOD(CStaticCF3, CreateInstanceWithContext, createinstancewithcontext, (IUnknown *punkContext, IUnknown *punkOuter, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()


STDMETHODIMP
CStaticCF3::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IClassFactory)
    QI_TEAROFF(this, IClassFactoryEx, NULL)
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}


STDMETHODIMP
CStaticCF3::CreateInstance(IUnknown *pUnkOuter, REFIID iid, void **ppv)
{
    return CreateInstanceWithContext(NULL, pUnkOuter, iid, ppv);
}

//+---------------------------------------------------------------
//
//  Member:     CStaticCF3::CreateInstanceWithContext, public
//
//  Synopsis:   Method of IClassFactoryEx interface.
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticCF3::CreateInstanceWithContext(
    IUnknown *punkContext,
    IUnknown *pUnkOuter,
    REFIID iid,
    void **ppv)
{
    HRESULT hr;
    IUnknown *pUnk = 0;

    *ppv = NULL;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;

    if (pUnkOuter && iid != IID_IUnknown)
        return E_INVALIDARG;

    hr = THR((*_pfnCreate)(punkContext, pUnkOuter, &pUnk));
    if (hr)
        goto Cleanup;

    if (pUnkOuter)
    {
        *ppv = pUnk;
    }
    else 
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\regdbhlp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       regdbhlp.cxx
//
//  Contents:   Registration helper functions
//
//  History:    20-Oct-94   GaryBu  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+------------------------------------------------------------------------
//
//  Function:    RegDbDeleteKey
//
//  Synopsis:   Recursively delete registry key given key name.
//
//  Arguments:  [hkeyParent] - Parent of the key to delete.
//              [szDelete] - Name of key to delete.
//
//-------------------------------------------------------------------------
void
RegDbDeleteKey(HKEY hkeyParent, const TCHAR *pszDelete)
{
    DWORD   dwResult;
    HKEY    hkeyDelete;

    dwResult = RegOpenKey(hkeyParent, pszDelete, &hkeyDelete);
    if (dwResult != ERROR_SUCCESS)
        goto Error;
#ifndef _MAC
    // Mac note: RegDeleteKey deletes all subkeys
    {
        TCHAR   szSubKey[256];
        while (RegEnumKey(hkeyDelete, 0, szSubKey, ARRAY_SIZE(szSubKey))
                == ERROR_SUCCESS)
        {
            RegDbDeleteKey(hkeyDelete, szSubKey);
        }
    }
#endif

    Verify(RegCloseKey(hkeyDelete) == ERROR_SUCCESS);

    dwResult = RegDeleteKey(hkeyParent, pszDelete);
Error:
    Assert((dwResult == ERROR_SUCCESS) || (dwResult == ERROR_BADKEY) ||
        (dwResult == ERROR_FILE_NOT_FOUND));

}

//+------------------------------------------------------------------------
//
//  Function:    RegDbOpenCLSIDKey
//
//  Synopsis:   Open HKEY_CLASSES_ROOT\CLISD.
//
//  Arguments:  [phkeyCLISD] - Address at which to return the HKEY
//
//-------------------------------------------------------------------------
HRESULT
RegDbOpenCLSIDKey(HKEY *phkeyCLSID)
{
    return RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), phkeyCLSID) ==
            ERROR_SUCCESS ? NOERROR : REGDB_E_READREGDB;
}

//+------------------------------------------------------------------------
//
//  Function:    RegDbDSetValues
//
//  Synopsis:   Add key and values to registry.
//
//              The keys and values are described by a string
//              and an array of arguments for substitution into
//              the string. The string consists of alternating
//              key and value format strings separted by nulls.
//              These format strings are in the format described
//              by the Format function (see CORE\FORMAT.CXX).
//              The string is terminated with two nulls.
//              The first key-value pair is treated as a parent
//              for the remaining keys.
//
//  Arguments:  [hkeyParent] - Add key/value pairs to this key.
//              [szFmt] - String describing values to add to registry.
//                  See description above.
//              [adwArgs] - Values to insert into format string.
//
//-------------------------------------------------------------------------
HRESULT
RegDbSetValues(HKEY hkeyParent, TCHAR *szFmt, DWORD_PTR *adwArgs)
{
    HRESULT hr          = S_OK;
    LONG    lError;
    HKEY    hkeySubkey;
    TCHAR   szKey[128];
    TCHAR   szSubkey[128];
    TCHAR   szValue[MAX_PATH];
    BOOL    fNamedSubkey;
    BOOL    fFirstTime  = TRUE;

    Assert(szFmt && *szFmt);

    hkeySubkey   = NULL;
    fNamedSubkey = FALSE;
    while (*szFmt)
    {
        // First, extract the major key
        // (Only cause of key format error is programmer error.)
        Verify(VFormat(FMT_ARG_ARRAY,
                szKey, ARRAY_SIZE(szKey), szFmt, adwArgs) == S_OK);
        szFmt += _tcslen(szFmt) + 1;

        // Then, write each subkey/value pair
        do
        {
            //  If it is a named subkey (rather than a value on the major key),
            //  format the subkey
            //  (Default values, those associated directly with the major
            //   key, use the name of the major key)
            if (*szFmt)
            {
                fNamedSubkey = TRUE;
                Verify(VFormat(FMT_ARG_ARRAY,
                        szSubkey, ARRAY_SIZE(szSubkey), szFmt, adwArgs) == S_OK);
            }
            szFmt += _tcslen(szFmt) + 1;

            // Format the value
            hr = THR(VFormat(FMT_ARG_ARRAY,
                    szValue, ARRAY_SIZE(szValue), szFmt, adwArgs));
            if (hr)
                goto Cleanup;

            szFmt += _tcslen(szFmt) + 1;

            //  Open (and use) the key if writing a named subkey beneath it
            //  (The key must have already been created...this assumes that
            //   all keys have default values which, when set, will create
            //   the key)
            if (fNamedSubkey && !hkeySubkey)
            {
                if (RegOpenKey(hkeyParent, szKey, &hkeySubkey) != ERROR_SUCCESS)
                {
                    hr = REGDB_E_WRITEREGDB;
                    goto Cleanup;
                }
            }

            // Write the key and value
            if (!fNamedSubkey)
            {
                lError = RegSetValue(hkeyParent, szKey, REG_SZ, szValue,0);
            }
            else
            {
                Assert(hkeySubkey);
                lError = RegSetValueEx(hkeySubkey, szSubkey, 0, REG_SZ,
                                        (CONST BYTE *)szValue,
                                        (sizeof(TCHAR)*_tcslen(szValue))+1);
            }
            if (lError != ERROR_SUCCESS)
            {
                hr = REGDB_E_WRITEREGDB;
                goto Cleanup;
            }

        }
        while (*szFmt);
        szFmt += _tcslen(szFmt) + 1;    // Skip over the subkey/value pair terminator

        // If an HKEY was opened for the key itself, close it before continuing
        if (hkeySubkey)
        {
            Assert(fNamedSubkey);
            Verify(RegCloseKey(hkeySubkey) == ERROR_SUCCESS);
            hkeySubkey   = NULL;
            fNamedSubkey = FALSE;
        }

        // If further major keys exist, write them as children of the first major key
        if (fFirstTime && *szFmt)
        {
            if (RegOpenKey(hkeyParent, szKey, &hkeyParent) != ERROR_SUCCESS)
            {
                hr = REGDB_E_WRITEREGDB;
                goto Cleanup;
            }
            fFirstTime = FALSE;
        }
    }

Cleanup:
    if (hkeySubkey)
    {
        Verify(RegCloseKey(hkeySubkey) == ERROR_SUCCESS);
    }

    if (!fFirstTime)
    {
        Verify(RegCloseKey(hkeyParent) == ERROR_SUCCESS);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\stdenum.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdenum.cxx
//
//  Contents:   Standard implementations of common enumerators
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+---------------------------------------------------------------
//
//  Class:      CEnumXXX
//
//  Synopsis:   Base class for enumerators.
//
//----------------------------------------------------------------

class CEnumXXX : public IUnknown
{
private:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))
public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(CEnumXXX);

    //*** IEnumX methods ***
    STDMETHOD(Next) (ULONG c, void * pv, ULONG * pcFetched);
    STDMETHOD(Skip) (ULONG c);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (void ** ppEnumXXX) = 0;

protected:
    CEnumXXX(REFIID iid, int c, int i);
    virtual ~CEnumXXX();

    virtual HRESULT FetchElements(int c, void *pv) = 0;

    REFIID _iid;
    int  _c;
    int  _i;

#ifdef OBJCNTCHK
    DWORD _dwObjCnt;
#endif

};

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::CEnumXXX
//
//  Synopsis:   Constructor.
//
//  Arguments:  iid     iid for this enumerator.
//              c       count of elements
//              i       starting index
//
//----------------------------------------------------------------

CEnumXXX::CEnumXXX(REFIID iid, int c, int i)
    : _iid(iid)
{
    _c = c;
    _i = i;
    _ulRefs = 1;
    IncrementObjectCount(&_dwObjCnt);
}

CEnumXXX::~CEnumXXX()
{
    DecrementObjectCount(&_dwObjCnt);
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::QueryInterface, IUnknown
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::QueryInterface(REFIID iid, void ** ppvObj)
{
    if (IsEqualIID(iid,IID_IUnknown) || IsEqualIID(iid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Next(ULONG c, void *pv, ULONG *pcFetched)
{
    int   cFetched;
    HRESULT hr;

    cFetched = c;
    if (cFetched > _c - _i)
        cFetched = _c - _i;

    Assert(cFetched >= 0);

    hr = THR(FetchElements(cFetched, pv));
    if (hr)
        goto Error;

    _i += cFetched;
    hr = cFetched == (int)c ? S_OK : S_FALSE;

Cleanup:
    if (pcFetched)
    {
        *pcFetched = cFetched;
    }

    RRETURN1(hr, S_FALSE);

Error:
    cFetched = 0;
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Skip(ULONG c)
{
    _i += c;
    if (_i > _c)
        _i = c;

    return _i == _c ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Reset()
{
    _i = 0;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Class:      StdEnumOLEVERB
//
//  Purpose:    Standard enumerator of OLEVERB tables
//
//---------------------------------------------------------------

MtDefine(CEnumOLEVERB, ObjectModel, "CEnumOLEVERB")

class CEnumOLEVERB: public CEnumXXX
{
    friend HRESULT CreateOLEVERBEnum(OLEVERB const *, ULONG, LPENUMOLEVERB FAR*);

public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumOLEVERB))
    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

private:
    CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iVerb);

    OLEVERB const * _pOleVerb;
};

//+---------------------------------------------------------------
//
//  Member:     CEnumOLEVERB::CEnumOLEVERB, private
//
//  Synopsis:   Constructor for CEnumOLEVERB objects
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [iOleVerb] -- starting index for enumerator.
//
//  Notes:      OLEVERB enumerators should be constructed using the
//              CreateOLEVERBEnum function.
//
//----------------------------------------------------------------

inline
CEnumOLEVERB::CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iOleVerb)
    : CEnumXXX(IID_IEnumOLEVERB, cOleVerb, iOleVerb)
{
    _pOleVerb = pOleVerb;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
CEnumOLEVERB::FetchElements(int c, void *pv)
{
    HRESULT   hr = S_OK;
    int       i;
    LPOLEVERB pOleVerb = (LPOLEVERB)pv;

    for (i = 0; i < c; i++)
    {
        pOleVerb[i] = _pOleVerb[i + _i];
        if (pOleVerb[i].lpszVerbName)
        {
            hr = TaskAllocString(pOleVerb[i].lpszVerbName,
                    &pOleVerb[i].lpszVerbName);
            if (hr)
                goto Error;
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    while (--i >= 0)
    {
        TaskFreeString(pOleVerb[i].lpszVerbName);
    }
    memset(pv, 0, sizeof(OLEVERB) * c);
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumOLEVERB::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new CEnumOLEVERB(_pOleVerb, _c, _i);
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateOLEVERBEnum, public
//
//  Synopsis:   Creates a standard enumerator over OLEVERB arrays
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [ppEnum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IOleObject::EnumVerbs
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateOLEVERBEnum(OLEVERB const * pOleVerb, ULONG cOleVerb, LPENUMOLEVERB * ppEnum)
{
    *ppEnum = (LPENUMOLEVERB)new CEnumOLEVERB(pOleVerb, cOleVerb, 0);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Class:      StdEnumFORMATETC
//
//  Purpose:    Standard enumerator of FORMATETC tables
//
//---------------------------------------------------------------

MtDefine(_CEnumFORMATETC, ObjectModel, "_CEnumFormatETC")

class _CEnumFORMATETC: public CEnumXXX
{
    friend HRESULT CreateFORMATETCEnum(LPFORMATETC, ULONG, LPENUMFORMATETC FAR*, BOOL fDeleteOnExit);
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(_CEnumFORMATETC))
    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

    _CEnumFORMATETC  *_pClonedFrom;

protected:
    virtual ~_CEnumFORMATETC();

private:
    _CEnumFORMATETC(LPFORMATETC pFmt, int cFmt, int iFmt, BOOL fDeleteOnExit);

    LPFORMATETC     _pFmtEtc;
    BOOL            _fDeleteOnExit;

};

//+---------------------------------------------------------------
//
//  Member:     _CEnumFORMATETC::_CEnumFORMATETC, private
//
//  Synopsis:   Constructor for _CEnumFORMATETC objects
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [iFmtEtc] -- starting position for enumerator.
//
//  Notes:      Static enumerators should be constructed using the
//              CreateFORMATETCEnum function.
//
//----------------------------------------------------------------

inline
_CEnumFORMATETC::_CEnumFORMATETC(LPFORMATETC pFmtEtc, int cFmtEtc, int iFmtEtc, BOOL fDeleteOnExit)
    : CEnumXXX(IID_IEnumFORMATETC, cFmtEtc, iFmtEtc)
{
    _pFmtEtc = pFmtEtc;
    _fDeleteOnExit = fDeleteOnExit;
    _pClonedFrom = 0;
}

_CEnumFORMATETC::~_CEnumFORMATETC()
{
    if (_fDeleteOnExit)
    {
        delete [] _pFmtEtc;
    }
    ReleaseInterface(_pClonedFrom);
}

//+---------------------------------------------------------------
//
//  Member:     _CEnumFORMATETC::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
_CEnumFORMATETC::FetchElements(int c, void *pv)
{
    HRESULT     hr = S_OK;
    int         i;
    LPFORMATETC pFmtEtc = (LPFORMATETC)pv;

    for (i = 0; i < c; i++)
    {
        pFmtEtc[i] = _pFmtEtc[i + _i];
        if (pFmtEtc[i].ptd)
        {
            pFmtEtc[i].ptd = (DVTARGETDEVICE *)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));
            if (!pFmtEtc[i].ptd)
                goto MemoryError;
            *(pFmtEtc[i].ptd) = *(_pFmtEtc[i + _i].ptd);
        }
    }

Cleanup:
    RRETURN(hr);

MemoryError:
    while (--i >= 0)
    {
        CoTaskMemFree(pFmtEtc[i].ptd);
    }
    memset(pv, 0, sizeof(FORMATETC) * c);
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     _CEnumFORMATETC::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
_CEnumFORMATETC::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new _CEnumFORMATETC(_pFmtEtc, _c, _i, FALSE);
    if (*ppEnumXXX && _fDeleteOnExit)
    {
        ((_CEnumFORMATETC*)*ppEnumXXX)->_pClonedFrom = this;
        AddRef();
    }
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateFORMATETCEnum, public
//
//  Synopsis:   Creates a standard enumerator over FORMATETC arrays
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IDataObject::EnumFormatetc
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateFORMATETCEnum(LPFORMATETC pFmtEtc, ULONG cFmtEtc, LPENUMFORMATETC * ppEnum, BOOL fDeleteOnExit)
{
    *ppEnum = (IEnumFORMATETC *)new _CEnumFORMATETC(pFmtEtc, cFmtEtc, 0, fDeleteOnExit);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}


#if 0   // this maybe useful later but is not currently used.

//+---------------------------------------------------------------
//
//  Class:      StdStaticEnum
//
//  Purpose:    Enumerates over a static array
//
//  Notes:      This may not be used to enumerate over structures
//              that are "deep".  For instance, it cannot be used
//              to enumerate over an array of FORMATETCs because such
//              an enumerator needs to deep copy the ptd field
//              and the enumerator client frees these allocated ptd.
//              Similarly for the OLEVERB structure where the verb
//              name string must be deep copied.
//
//---------------------------------------------------------------

class StdStaticEnum: public IUnknown
{
    friend HRESULT CreateStaticEnum(REFIID, LPVOID, ULONG, ULONG, LPVOID FAR*);

public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(StdStaticEnum);

    //*** IEnumerator methods ***
    STDMETHOD(Next) (ULONG celt, LPVOID pArrayObjs, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (LPSTDSTATICENUM FAR* ppenm);

private:
    // constructor/destructor
    StdStaticEnum(REFIID riid, LPVOID pStart, ULONG cSize, ULONG cCount);
    ~StdStaticEnum(void);

    IID _iid;
    LPVOID _pStart;
    ULONG _cSize;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::StdStaticEnum, private
//
//  Synopsis:   Constructor for StdStaticEnum objects
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateStaticEnum function.
//
//----------------------------------------------------------------

StdStaticEnum::StdStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount)
{
    _ulRefs = 1;
    _iid = riid;
    _pStart = pStart;
    _cSize = cSize;
    _cCount = cCount;
    _cCurrent = 0;

    TraceTag((tagStdEnum, "StdStaticEnum constructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdStaticEnum::~StdStaticEnum(void)
{
    TraceTag((tagStdEnum, "StdStaticEnum destructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Next(ULONG celt,
        LPVOID pArrayObjs,
        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = min(celt, _cCount-_cCurrent);

    // calculate the number of bytes to copy
    if (celtFetched != 0 && _cSize > (UINT_MAX/celtFetched))
    {
        return E_FAIL;         // overflow!
    }

    UINT count = (UINT) (celtFetched*_cSize);
    _fmemcpy(pArrayObjs, (LPBYTE)_pStart+_cCurrent*_cSize, count);
    _cCurrent += celtFetched;
    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }
    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Clone(LPSTDSTATICENUM FAR* ppenm)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    _iid,
                                                    _pStart,
                                                    _cSize,
                                                    _cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
        r = NOERROR;
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStaticEnum, public
//
//  Synopsis:   Creates a standard enumerator over static arrays
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//----------------------------------------------------------------

HRESULT
CreateStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount,
        LPVOID FAR* ppenum)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    riid,
                                                    pStart,
                                                    cSize,
                                                    cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\rostm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       rostm.cxx
//
//  Contents:   CROStmOnBuffer
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

MtDefine(CROStmOnBuffer, Utilities, "CROStmOnBuffer")
MtDefine(CROStmOnHGlobal, Utilities, "CROStmOnHGlobal")
MtDefine(CROStmOnBuffer_pbBuf, CROStmOnBuffer, "CROStmOnBuffer::_pbBuf")

//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::CROStmOnBuffer
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------

CROStmOnBuffer::CROStmOnBuffer()
{
    _ulRefs = 1;
    _pbSeekPtr = NULL;
    _pbBuf = NULL;
    _cbBuf = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::~CROStmOnBuffer
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CROStmOnBuffer::~CROStmOnBuffer()
{
    if (_pbBuf)
    {
        delete _pbBuf;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Init
//
//  Synopsis:   Initializer
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Init(BYTE *pb, long cb)
{
    HRESULT hr = S_OK;
    
    _cbBuf = cb;
    if (cb)
    {
        _pbBuf = new(Mt(CROStmOnBuffer_pbBuf)) BYTE[cb];
        if (!_pbBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        memcpy((void *)_pbBuf, pb, cb);
        _pbSeekPtr = _pbBuf;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::QueryInterface
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (riid == IID_IStream || riid == IID_IUnknown)
    {
        *ppvObj = (IStream *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::AddRef
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

ULONG
CROStmOnBuffer::AddRef()
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Release
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

ULONG
CROStmOnBuffer::Release()
{
    ULONG   ulRefs = _ulRefs;
    
    if (--_ulRefs == 0)
    {
        delete this;
    }

    return ulRefs - 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Read
//
//  Synopsis:   per IStream
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Read(void HUGEP * pv, ULONG cb, ULONG * pcbRead)
{
    HRESULT hr = S_OK;
    
    if (!pv)
    {
        hr = STG_E_INVALIDPOINTER;
        goto Cleanup;
    }
    
    //
    // Catch the case where a read might go beyond the end
    // of the buffer
    //
    
    if (_pbBuf + _cbBuf < _pbSeekPtr + cb)
    {
        cb = _pbBuf + _cbBuf - _pbSeekPtr;
    }

    memcpy(pv, (void *)_pbSeekPtr, cb);
    _pbSeekPtr += cb;
    
    if (pcbRead)
    {
        *pcbRead = cb;
    }

    if (cb == 0)
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Seek
//
//  Synopsis:   per IStream
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Seek(
    LARGE_INTEGER dlibMove, 
    DWORD dwOrigin, 
    ULARGE_INTEGER * plibNewPosition)
{
    HRESULT     hr  = S_OK;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        if (dlibMove.HighPart != 0)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            _pbSeekPtr = _pbBuf + dlibMove.LowPart;
        }
        break;

    case STREAM_SEEK_CUR:
        if (dlibMove.HighPart != 0 && dlibMove.HighPart != -1)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            _pbSeekPtr += (int) dlibMove.LowPart;
        }
        break;

    case STREAM_SEEK_END:
        if (dlibMove.HighPart != -1 && dlibMove.HighPart != 0)
        {
            hr = STG_E_ACCESSDENIED;
        }
        else
        {
            _pbSeekPtr = _pbBuf + _cbBuf + (int) dlibMove.LowPart;
        }
        break;

    default:
        hr = STG_E_INVALIDFUNCTION;
        break;
    }

    if (_pbSeekPtr < _pbBuf)
    {
        _pbSeekPtr = _pbBuf;
        hr = E_INVALIDARG;
    }
    else if (_pbSeekPtr > _pbBuf + _cbBuf)
    {
        _pbSeekPtr = _pbBuf + _cbBuf;
        hr = STG_E_ACCESSDENIED;
    }

    if (plibNewPosition)
    {
        plibNewPosition->LowPart = _pbSeekPtr - _pbBuf;
        plibNewPosition->HighPart = 0;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::CopyTo
//
//  Synopsis:   per IStream
//
//      As far as I know this routine is only used during the
//      FullWindowEmbed IHistory saving scenario.  This scenario
//      copies only a view bytes so this routine is not very optimized.
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::CopyTo(
     IStream * pstm,
     ULARGE_INTEGER cb,
     ULARGE_INTEGER * pcbRead,
     ULARGE_INTEGER * pcbWritten)
{
    ULONG   ulWritten, ulToWrite, ulAvailable;
    HRESULT hr = S_OK;

    ulToWrite = cb.LowPart;
    if( cb.HighPart != 0 )
        return( E_INVALIDARG );  // sorry guy.

    ulAvailable = (_pbBuf + _cbBuf) - _pbSeekPtr;
    if( ulToWrite > ulAvailable )
        ulToWrite = ulAvailable;

    hr = pstm->Write( _pbSeekPtr, ulToWrite, &ulWritten );

    _pbSeekPtr += ulWritten;  // advance past what was written.
    
    if( pcbRead != NULL )
    {
        pcbRead->LowPart = ulWritten;
        pcbRead->HighPart = 0;
    }
    if( pcbWritten != NULL )
    {
        pcbWritten->LowPart = ulWritten;
        pcbWritten->HighPart = 0;
    }

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Stat
//
//  Synopsis:   per IStream
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    if (pstatstg)
    {
        memset(pstatstg, 0, sizeof(STATSTG));
        pstatstg->type = STGTY_STREAM;
        ULISet32(pstatstg->cbSize, _cbBuf);
        pstatstg->grfMode = STGM_READ;
    }

    return S_OK;
}


//
// CROStmOnHGlobal derived class
//
// Most implementation is same as CROStmOnBuffer.  Main difference is that
// _pbBuf is initialized to the return value of GlobalLock instead of 
// copying off some other buffer.
//

CROStmOnHGlobal::CROStmOnHGlobal()
{
    _hGlobal = NULL;
}

CROStmOnHGlobal::~CROStmOnHGlobal()
{
    if( _pbBuf )
    {
        Assert( _hGlobal != NULL );
        GlobalUnlock( _hGlobal );
        _pbBuf = NULL;
    }
}

HRESULT
CROStmOnHGlobal::Init( HGLOBAL hGlobal, long cb )
{
    HRESULT hr = S_OK;

    _cbBuf = cb;
    if( _cbBuf )
    {
        _pbBuf = (BYTE *)GlobalLock( hGlobal );
        if( !_pbBuf )
        {
            _cbBuf = 0;
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        _hGlobal = hGlobal;
        _pbSeekPtr = _pbBuf;
    }
Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\proppage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       proppage.cxx
//
//  Contents:   Display property dialog.
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PROPPAGE_HXX_
#define X_PROPPAGE_HXX_
#include "proppage.hxx"
#endif

const CBase::CLASSDESC CPropertyPage::s_classdesc = 
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
    NULL,                               // _apClsidPages
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    NULL,                               // _piidDispinterface
    NULL,                               // _apHdlDesc
};


//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Passivate
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

void
CPropertyPage::Passivate()
{
    // clean up our window.
    //
    if (_hwnd)
    {
        SetWindowLong(_hwnd, DWL_USER, 0xffffffff);
        DestroyWindow(_hwnd);
    }

    // release all the objects we're holding on to.
    //
    ReleaseAllObjects();

    // release the site
    //
    ClearInterface(&_pPropertyPageSite);
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::QueryInterface
//
//  Synopsis:   we support IPP and IPP2.
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyPage::PrivateQueryInterface(REFIID iid, void **ppvObj)
{
    *ppvObj = NULL;

    if ( IsEqualIID(iid, IID_IPropertyPage) )
    {
        *ppvObj = (IPropertyPage *)this;
    }
    else if ( IsEqualIID(iid, IID_IPropertyPage2) )
    {
        *ppvObj = (IPropertyPage2 *)this;
    }
    else
    {
        RRETURN(super::PrivateQueryInterface(iid, ppvObj));
    }

    ((IUnknown*)(*ppvObj))->AddRef();

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Init
//
//  Synopsis:   Init.
//
//  Note:       Load up the descriptor strings
//
//-------------------------------------------------------------------------

HRESULT
CPropertyPage::Init(void)
{
    HRESULT hr;
    int cch;
    TCHAR * pch;

    hr = LoadString(GetResourceHInst(), ProppageDesc()->wTitleId, &cch, &pch);
    if ( hr )
        goto Cleanup;

    hr = _cstrTitle.Set(pch, cch);
    if ( hr )
        goto Cleanup;

    hr = LoadString(GetResourceHInst(), ProppageDesc()->wDocStringId, &cch, &pch);
    if ( hr )
        goto Cleanup;

    hr = _cstrDocString.Set(pch, cch);
    if ( hr )
        goto Cleanup;


Cleanup:
    RRETURN(hr);
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::SetPageSite
//
//  Synopsis:   Set the proppage site on the proppage dialog
//
//  Arguments:  pPropertyPageSite  - [in] new site.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::SetPageSite(IPropertyPageSite *pPropertyPageSite)
{
    if ( pPropertyPageSite && _pPropertyPageSite )
        return E_UNEXPECTED;

    ReplaceInterface(&_pPropertyPageSite, pPropertyPageSite);

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Activate
//
//  Synopsis:   instructs the page to create its
//              display window as a child of hwndparent
//              and to position it according to prc
//
//  Arguments:  hwndParent      the parent window
//              prcBounds       the rect to use for display
//              fModal          or not
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Activate(HWND    hwndParent,
                        LPCRECT prcBounds,
                        BOOL    fModal)
{
    HRESULT hr = S_OK;
    BOOL fActivating = _fActivating;

    _fActivating = TRUE;

    // first make sure the dialog window is loaded and created.
    //
    if (_hwnd)
        goto Cleanup;

    _hwnd = CreateDialogParam(GetResourceHInst(),
                              MAKEINTRESOURCE(GetProppageDesc()->wDlgResourceId),
                              hwndParent,
                              &CPropertyPage::DlgProc,
                              (LPARAM)this);
    if ( ! _hwnd )
        goto Win32Error;

    _fActive = TRUE;

    THR_NOTRACE(ConnectObjects());

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);

Cleanup:
    _fActivating = fActivating;
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Deactivate
//
//  Synopsis:   instructs the page to destroy the window created in activate
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Deactivate(void)
{
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
    }

    _hwnd = NULL;
    _fActive = FALSE;

    Disconnect();

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::GetPageInfo
//
//  Synopsis:   asks the page to fill a PROPPAGEINFO structure
//
//  Arguments:  pPropPageInfo - [out] where to put info.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::GetPageInfo(PROPPAGEINFO * pPropPageInfo)
{
    HRESULT hr = S_OK;
    RECT rc;

    if ( ! pPropPageInfo )
        return E_POINTER;


    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));
    pPropPageInfo->cb = sizeof(PROPPAGEINFO);

    hr = TaskAllocString(_cstrTitle, &pPropPageInfo->pszTitle);
    if ( hr )
        goto Cleanup;

    TaskAllocString(_cstrDocString, &pPropPageInfo->pszDocString);
    TaskAllocString(ProppageDesc()->szHelpFile, &pPropPageInfo->pszHelpFile);
    pPropPageInfo->dwHelpContext = ProppageDesc()->dwHelpContextId;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (_hwnd)
    {
        GetWindowRect(_hwnd, &rc);
        pPropPageInfo->size.cx = rc.right - rc.left;
        pPropPageInfo->size.cy = rc.bottom - rc.top;
    }
    else
    {
        DLGTEMPLATE * pdt;

        pdt = (DLGTEMPLATE *)GetResource(GetResourceHInst(),
                                         MAKEINTRESOURCE(ProppageDesc()->wDlgResourceId),
                                         RT_DIALOG,
                                         NULL);

        if ( pdt )
        {
            hr = ComputeDialogSize(pdt, &pPropPageInfo->size);
        }
    }


Cleanup:
    RRETURN(hr);

}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::SetObjects
//
//  Synopsis:   provides the page with the objects being affected by the changes.
//
//  Arguments:  cObjects        - [in] count of objects.
//              ppUnkObjects    - [in] objects.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::SetObjects(ULONG       cObjects,
                          IUnknown ** ppUnkObjects)
{
    HRESULT hr = S_OK;
    ULONG   i;
    IUnknown * pUnk;

    ReleaseAllObjects();

    if (!cObjects)
        goto Cleanup;

    // now go and set up the new ones.
    //

    hr = _aryUnk.EnsureSize(cObjects);
    if ( hr )
        goto Cleanup;


    //  Loop through and copy over all the objects.
    //  Get only those supporting our requested primary interface

    for (i = 0; i < cObjects; i++)
    {
        if ( ppUnkObjects[i] &&
             OK(ppUnkObjects[i]->QueryInterface(*GetProppageDesc()->piidPrimary, (void**)&pUnk)) )
        {
            hr = _aryUnk.Append(pUnk);
            if ( hr )
                goto Cleanup;
        }

    }


    _fDirty = FALSE;


Cleanup:
    RRETURN(hr);
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Show
//
//  Synopsis:   asks the page to show or hide its window
//
//  Arguments:  nCmdShow    - [in] whether to show or hide
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Show(UINT nCmdShow)
{
    if ( ! _hwnd )
        return E_UNEXPECTED;

    ShowWindow(_hwnd, nCmdShow);

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Move
//
//  Synopsis:   asks the page to relocate and resize itself
//              to a position other than what was specified through Activate
//
//  Arguments:  prcBounds    - [in] new position and size
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Move(LPCRECT prcBounds)
{
    if ( ! _hwnd )
    {
        return E_UNEXPECTED;
    }

    MoveWindow(_hwnd,
               prcBounds->left,
               prcBounds->top,
               prcBounds->right - prcBounds->left,
               prcBounds->bottom - prcBounds->top,
               TRUE);

    return S_OK;
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::IsPageDirty
//
//  Synopsis:   asks the page whether it has changed its state
//
//  Returns:    S_OK    dirty
//              S_FALSE not dirty
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::IsPageDirty(void)
{
    return _fDirty ? S_OK : S_FALSE;
}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Apply
//
//  Synopsis:   instructs the page to send its changes
//              to all the objects passed through SetObjects()
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Apply(void)
{
    HRESULT hr = S_OK;

    if (_fDirty)
    {
        _fDirty = FALSE;
        if (_pPropertyPageSite)
        {
            _pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    }

    RRETURN(hr);
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Help
//
//  Synopsis:   instructs the page that the help button was clicked.
//
//  Arguments:  pszHelpDir  - [in] help directory
//
//  Note:       Default implementation bounces back with E_NOTIMPL
//              forcing caller to use help info from GetPageInfo.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Help(LPCOLESTR pszHelpDir)
{
    if ( _hwnd )
        return E_UNEXPECTED;

    return E_NOTIMPL;   //  force prop sheet to use GetPageInfo.
}








//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::TranslateAccelerator
//
//  Synopsis:   informs the page of keyboard events,
//              allowing it to implement its own keyboard interface.
//
//  Arguments:  pmsg   - [in] message that triggered this
//
//  Returns:    S_OK    if consumed
//              S_FALSE if not processed
//              E_xxxx  if error
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::TranslateAccelerator(LPMSG pmsg)
{
    Assert(_hwnd && "How can we get a TranslateAccelerator call if we're not visible?");
    Assert(_pPropertyPageSite);

    // just pass this message on to the dialog proc and see if they want it.
    //
    RRETURN1(_pPropertyPageSite->TranslateAccelerator(pmsg),S_FALSE);
}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::EditProperty
//
//  Synopsis:   instructs the page to set the focus
//              to the property matching the dispid.
//
//  Arguments:  dispid   - [in] dispid of property to set focus to.
//
//  Note:       Derived should overload
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::EditProperty(DISPID dispid)
{
    return E_NOTIMPL;
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::ReleaseAllObjects, protected
//
//  Synopsis:   releases all the objects that we're working with
//
//  Note:       Derived class can overload to catch the action
//
//-------------------------------------------------------------------------

void
CPropertyPage::ReleaseAllObjects(void)
{
    //  Be robust. Objects are disconnected in Deactivate but
    //  we want ot be able to survive the lack of it

    Disconnect();
    _aryUnk.ReleaseAll();
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::ComputeDialogSize, protected
//
//  Synopsis:   releases all the objects that we're working with
//
//  Note:       Derived class can overload to catch the action
//
//-------------------------------------------------------------------------

HRESULT
CPropertyPage::ComputeDialogSize(DLGTEMPLATE * pdt, SIZE * psize)
{
    HRESULT hr = S_OK;
    int i;
    SIZE sizeBaseUnit = {0,0};
    IFont *pFont = 0;

    Assert(pdt);
    Assert(psize);

    if ( pdt->style & DS_SETFONT )
    {
        short * ps;
        int iFontSize;
        TCHAR * pszFontName;

        //  Walk the dialog template to get at the specified font

        ps = (short*)((char*)pdt + sizeof(DLGTEMPLATE));

        //  Skip the menu and class descriptors
        for ( i = 0; i < 2; i++ )
        {
            switch (*ps)
            {
                case 0:
                    //  Non-existent
                    ps++;
                    break;

                case 0xffff:
                    //  Specified via resourceID/atom,
                    //  next short is the ID
                    ps += 2;
                    break;

                default:
                    //  Null-terminated Unicode string
                    while (*ps++);
                    break;
            }
        }

        while(*ps++);

        iFontSize = *ps++;
        pszFontName = (TCHAR *)ps;

        //  Get the font

        if ( iFontSize && pszFontName )
        {
            FONTDESC fd;
            TEXTMETRICOLE tm;

            memset(&fd, 0, sizeof(fd));
            fd.cbSizeofstruct = sizeof(fd);
            fd.lpstrName = pszFontName;
            fd.cySize.Hi = iFontSize;

            hr = OleCreateFontIndirect(&fd, IID_IFont, (void**)&pFont);
            if ( hr )
                goto Cleanup;

            hr = pFont->QueryTextMetrics(&tm);
            if ( hr )
                goto Cleanup;

            sizeBaseUnit.cx = tm.tmAveCharWidth;
            sizeBaseUnit.cy = tm.tmHeight;
        }
    }
    else
    {
        DWORD dwBaseUnits;

        dwBaseUnits = GetDialogBaseUnits();
        sizeBaseUnit.cx = LOWORD(dwBaseUnits);
        sizeBaseUnit.cy = HIWORD(dwBaseUnits);
    }

    psize->cx = ( pdt->cx * sizeBaseUnit.cx) / 4;
    psize->cy = ( pdt->cy * sizeBaseUnit.cy) / 8;


Cleanup:
    ReleaseInterface(pFont);
    RRETURN(hr);
}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::PropPageDlgProc
//
//  Synopsis:   static global helper dialog proc
//              that gets called before we pass the message on to anybody
//
//  Arguments:  Like a Dialog Proc. See Win32
//
//-------------------------------------------------------------------------

BOOL CALLBACK
CPropertyPage::DlgProc(HWND    hwnd,
                       UINT    msg,
                       WPARAM  wParam,
                       LPARAM  lParam)
{
    BOOL rc = TRUE;
    CPropertyPage *pPropertyPage = (CPropertyPage *)GetWindowLong(hwnd, DWL_USER);

    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLong(hwnd, DWL_USER, lParam);
            pPropertyPage = (CPropertyPage *)lParam;
            return pPropertyPage->OnInitDialog(hwnd);
            break;

#if NEVER
        case WM_CLOSE:
            pPropertyPage->Close();
            break;

        case WM_NOTIFY:
            pPropertyPage->OnNotify((int)wParam, (LPNMHDR)lParam);
            break;

        case WM_COMMAND:
            pPropertyPage->OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                                     GET_WM_COMMAND_ID(wParam, lParam), 
                                     GET_WM_COMMAND_HWND(wParam, lParam));
            break;
#endif

        default:
            rc = pPropertyPage ? pPropertyPage->DialogProc(hwnd, msg, wParam, lParam) : FALSE;
            break;
    }

    return rc;
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::MakeDirty
//
//  Synopsis:   marks a page as dirty.
//
//-------------------------------------------------------------------------

void
CPropertyPage::MakeDirty(void)
{
    if ( ! _fActivating )
    {
        _fDirty = TRUE;
        if (_pPropertyPageSite)
            _pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
    }
}





//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::ConnectObjects
//
//  Synopsis:   Connection to current selected objectes
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CPropertyPage::ConnectObjects(void)
{
    HRESULT         hr;
    int             i;
    IUnknown **     ppUnk = NULL;
    DWORD *         pdw;

    Disconnect();   //  the old ones

    // Get space for connection IDs.
    hr = _aryAdvise.EnsureSize(_aryUnk.Size());
    if (hr)
        goto Cleanup;

    // Register as sink to each object.
    ppUnk = _aryUnk;
    pdw = _aryAdvise;

    for (i = 0, ppUnk = _aryUnk;
         i < _aryUnk.Size();
         i++, ppUnk++)
    {
        //  Ignore errors
        IGNORE_HR(ConnectSink(*ppUnk, IID_IPropertyNotifySink, &_PropertyPagePNS, pdw));

        // Next object.
        pdw++;
    }

    //  Set the correct count on the cookie array
    _aryAdvise.SetSize(_aryUnk.Size());

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Disconnect
//
//  Synopsis:   Disconnect to current selected objected
//
//-------------------------------------------------------------------------
void
CPropertyPage::Disconnect(void)
{
    HRESULT         hr = S_OK;
    int             i;
    IUnknown **     ppUnk = NULL;
    DWORD *         pdw;

    //
    // Revoke as property notify sink from each object.
    //

    for (i = 0, ppUnk = _aryUnk, pdw = _aryAdvise;
         i < min ( _aryUnk.Size(), _aryAdvise.Size() );
         i++, ppUnk++)
    {
        IGNORE_HR(DisconnectSink(*ppUnk, IID_IPropertyNotifySink, pdw));

        // Next object.
        pdw++;
    }

    _aryAdvise.SetSize(0);
}




//+------------------------------------------------------------------------
//
//  CPropertyPagePNS implementation.
//
//-------------------------------------------------------------------------


IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CPropertyPage::CPropertyPagePNS, CPropertyPage, _PropertyPagePNS)


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::CPropertyPagePNS::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::CPropertyPagePNS::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyNotifySink))
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::CPropertyPagePNS::OnChanged
//
//  Synopsis:   Refreshes property page.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::CPropertyPagePNS::OnChanged(DISPID dispid)
{
    if (MyCPropertyPage()->_fInApply)
        return S_OK;

    //  TODO: Need to implement this functionality

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::CPropertyPagePNS::OnRequestEdit
//
//  Synopsis:   Does nothing.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::CPropertyPagePNS::OnRequestEdit(DISPID dispid)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\specpage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       specpage.cxx
//
//  Contents:   AddPages()
//
//  Classes:    None.
//
//  Functions:  AddPages -- adds property pages to those provided by an
//                  implementation of ISpecifyPropertyPages::GetPages.
//
//  History:    5-02-94   adams   Created
//              27-Jul-94 doncl   MemAlloc->CoTaskMemAlloc
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------------------
//
//  Function:   AddPages
//
//  Synopsis:   Adds property pages to those provided by an implementation of
//              ISpecifyPropertyPages::GetPages.
//
//  Arguments:  [pUnk]     -- Implementation of GetPages.  May be NULL.
//              [apUUID]   -- Array of pages to add.
//              [pCAUUID]  -- Result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pcauuid].
//
//----------------------------------------------------------------------------

STDAPI
AddPages(
        IUnknown *          pUnk,
        const UUID * const  apuuid[],
        CAUUID *            pcauuid)
{
    HRESULT                 hr      = S_OK;
    ISpecifyPropertyPages * pSPP;           // spp iface of agg
    CAUUID                  cauuid;         // pSPP's property pages
    ULONG                   ul;             // counter
    UUID *                  puuidDest;      // copy destination
    const UUID * const *    ppuuidSrc;      // copy source
    UUID *                  puuid;          // search
    ULONG                   c;
    ULONG                   ulcPages;

    if (!apuuid)
    {
        ulcPages = 0;
    }
    else
    {
        for (ulcPages = 0; apuuid[ulcPages]; ulcPages++)
            ;
    }

    //  NOTE that this routine accepts requests to add zero
    //    pages, in which case ulcPages == 0 and apuuid == NULL

    pcauuid->cElems = 0;
    pcauuid->pElems = NULL;

    // Get source propery pages.
    cauuid.cElems = 0;
    cauuid.pElems = NULL;
    if (pUnk)
    {
        if (!THR(pUnk->QueryInterface(
                IID_ISpecifyPropertyPages,
                (void **) &pSPP)))
        {
            hr = THR(pSPP->GetPages(&cauuid));
            pSPP->Release();

            if (hr)
                goto Cleanup;
        }
    }

    // Alloc space for combined array of pages.
    pcauuid->pElems =
        (UUID *) CoTaskMemAlloc((cauuid.cElems + ulcPages) * sizeof(UUID));
    if (!pcauuid->pElems)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Copy pages to new array.
    memcpy(
            pcauuid->pElems,
            cauuid.pElems,
            (UINT) (cauuid.cElems * sizeof(UUID)));

    ppuuidSrc = apuuid;
    puuidDest = pcauuid->pElems + cauuid.cElems;
    for (ul = 0; ul < ulcPages; ul++)
    {
        //  Make sure we don't add any duplicate pages
        for (c = cauuid.cElems, puuid = cauuid.pElems;
             c > 0;
             c--, puuid++)
        {
            if (**ppuuidSrc == *puuid)
                goto NextUUID;
        }

        *puuidDest++ = **ppuuidSrc;

NextUUID:
        ppuuidSrc++;
    }

    pcauuid->cElems = puuidDest - pcauuid->pElems;

Cleanup:
    if (cauuid.pElems)
        CoTaskMemFree(cauuid.pElems);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\stgutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stgutils.hxx
//
//  Contents:   IStorage and IStream Helper functions
//
//
//	History:	
//				5-22-95		kfl		converted WCHAR to TCHAR
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------
//
//  Function:   GetMonikerDisplayName
//
//  Synopsis:   Retrieves the display name of a moniker
//
//  Arguments:  [pmk] -- the moniker for which the display name is requested
//              [ppstr] -- the place where the display name is returned
//
//  Returns:    Success iff the display name could be retrieved
//
//  Notes:      The display name string is allocated using the task allocator
//              and should be freed by the same.
//
//----------------------------------------------------------------

HRESULT
GetMonikerDisplayName(LPMONIKER pmk, LPTSTR FAR* ppstr)
{
    HRESULT hr;
    LPBC    pbc;

    hr = THR(CreateBindCtx(0, &pbc));
    if (!hr)
    {
#ifndef _MACUNICODE
        hr = THR(pmk->GetDisplayName(pbc, NULL, ppstr));
#else
        LPOLESTR    szName;
        CStr        str;
        hr = THR(pmk->GetDisplayName(pbc, NULL, &szName));
        str.Set(szName);
        *ppstr = (LPTSTR)CoTaskMemAlloc (str.Length()*sizeof(TCHAR) + sizeof(TCHAR));
        if (*ppstr == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
            _tcscpy( *ppstr, str);
        CoTaskMemFree(szName);
#endif
        pbc->Release();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Function:   CreateStorageOnHGlobal
//
//  Synopsis:   Creates an IStorage on a global memory handle
//
//  Arguments:  [hgbl] -- memory handle to create storage on
//              [ppStg] -- where the storage is returned
//
//  Returns:    Success iff the storage could be successfully created
//              on the memory handle.
//
//  Notes:      This helper function combines CreateILockBytesOnHGlobal
//              and StgCreateDocfileOnILockBytes.  hgbl may be NULL in
//              which case a global memory handle will be automatically
//              allocated.
//
//----------------------------------------------------------------

HRESULT
CreateStorageOnHGlobal(HGLOBAL hgbl, LPSTORAGE FAR* ppStg)
{
    HRESULT     hr;
    LPLOCKBYTES pLockBytes;

#ifndef _MAC
    hr = THR(CreateILockBytesOnHGlobal(hgbl, TRUE, &pLockBytes));
#else
    {
        Handle hv = NULL;

        if(!hgbl || GetWrapperHandle (hgbl,&hv))
        {

            hr = THR(CreateILockBytesOnHGlobal(hv, TRUE, &pLockBytes));
        }
        else
        {
            Assert ( 0&& "Failed to GetWrapperHandle");
            hr = E_INVALIDARG;
        }
    }
#endif

    if (!hr)
    {
        //REVIEW: should be use STGM_DELETEONRELEASE when hgbl == NULL?
        hr = THR(StgCreateDocfileOnILockBytes(
                pLockBytes,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                ppStg));
        pLockBytes->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\stmbuff.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stmbuff.cxx
//
//  Contents:   Useful OLE helper functions
//
//----------------------------------------------------------------------

#ifdef UNIX
#  ifdef MW_MSCOMPATIBLE_LI
#    undef MW_MSCOMPATIBLE_LI
#  endif
#endif

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

const LARGE_INTEGER LINULL = {0, 0};

//+---------------------------------------------------------------------------
//
//  Class:      CStreamBuffered 
//
//  Purpose:    IStream wrapper with a small internal cache for buffering read
//              operations
//
//  Interface:  CStreamBuffered             -- Constructor
//
//----------------------------------------------------------------------------

MtDefine(CStreamBuffered, Utilities, "CStreamBuffered")

class CStreamBuffered : public IStream
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CStreamBuffered))
    CStreamBuffered(IStream * pStream);
    ~CStreamBuffered();

    // IUnknown methods
    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void) ;
    STDMETHOD_(ULONG, Release) (void);

    // IStream methods
    STDMETHOD(Read)(
         void * pv,
         ULONG cb,
         ULONG * pcbRead);

    STDMETHOD(Write)(
         const void * pv,
         ULONG cb,
         ULONG * pcbWritten);

    STDMETHOD(Seek)(
         LARGE_INTEGER dlibMove,
         DWORD dwOrigin,
         ULARGE_INTEGER * plibNewPosition);

    STDMETHOD(SetSize)(
         ULARGE_INTEGER libNewSize);

    STDMETHOD(CopyTo)(
         IStream * pstm,
         ULARGE_INTEGER cb,
         ULARGE_INTEGER * pcbRead,
         ULARGE_INTEGER * pcbWritten);

    STDMETHOD(Commit)(
         DWORD grfCommitFlags);

    STDMETHOD(Revert)( void);

    STDMETHOD(LockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(UnlockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(Stat)(
         STATSTG * pstatstg,
         DWORD grfStatFlag);

    STDMETHOD(Clone)(
         IStream ** ppstm);

#define STREAMBUFSIZE 4096

    ULONG       _ulRefs;
    IStream *   _pStm;
    BYTE    _ab[STREAMBUFSIZE];
    ULONG   _ulPos;                 // position in buffer
    ULONG   _ulSize;                // size filled in buffer
    ULARGE_INTEGER _uliSeekPos;     // seek position
};

//+------------------------------------------------------------------------
//
//  Return buffered stream if created or the original stream
//
//-------------------------------------------------------------------------

IStream *
BufferStream(IStream * pStm)
{
    CStreamBuffered * pStream = new CStreamBuffered(pStm);
    return pStream ? pStream : pStm;
}

//+------------------------------------------------------------------------
//
//  CStreamBuffered implementation.
//
//-------------------------------------------------------------------------

CStreamBuffered::CStreamBuffered(IStream * pStm)
{
    _pStm = pStm;
    _ulRefs = 1;
    _ulPos = 0;
    _ulSize = 0;
#ifndef _MAC
    _uliSeekPos.QuadPart = 0;
#else
    _uliSeekPos.LowPart = 0;
    _uliSeekPos.HighPart = 0;
#endif
    IncrementSecondaryObjectCount( 6 );
}

CStreamBuffered::~CStreamBuffered()
{
    DecrementSecondaryObjectCount( 6 );
}

STDMETHODIMP
CStreamBuffered::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IStream))
    {
        *ppvObj = (IStream *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CStreamBuffered::AddRef(void)
{
    ++_ulRefs;
    return _pStm->AddRef();
}

STDMETHODIMP_(ULONG)
CStreamBuffered::Release(void)
{
    ULONG   ul;

    ul = _pStm->Release();
    if (--_ulRefs == 0)
    {
        delete this;
    }

    return ul;
}

#if DBG == 1
static BOOL s_fThru = FALSE;
#endif

STDMETHODIMP
CStreamBuffered::Read(
     void * pv,
     ULONG cb,
     ULONG * pcbRead)
{
    HRESULT hr;
    ULONG ul;
    ULONG ulRead;

#if DBG == 1
    if (s_fThru)
    {
        return _pStm->Read(pv, cb, pcbRead);
    }
#endif
    hr = S_OK;
    ulRead = 0;

    while (cb > 0 && !hr)
    {
        if (_ulPos == _ulSize)
        {
            //  If we need to read more bytes than will fit in our
            //    buffer, then read directly to the stream rather
            //    than trying to buffer.

            if (cb > sizeof(_ab))
            {
                hr = THR(_pStm->Read(pv, cb, &ul));
                ulRead += ul;

                goto Cleanup;
            }

            hr = THR(_pStm->Read(_ab, sizeof(_ab), &ul));

            // get current seek position
            hr = _pStm->Seek(LINULL, STREAM_SEEK_CUR, &_uliSeekPos);

            _ulPos = 0;
            _ulSize = ul;

            if (hr)
            {
                //  We may have attempted to read more bytes from the
                //    stream than actually exist.  If this happens, but
                //    we still read enough bytes to satisfy the user
                //    request, then report success from this call.

                if (ul >= cb)
                {
                    hr = S_OK;
                }
            }
            else
            {
                //  We may hit the end of the stream, and read less than
                //    the necessary number of bytes without getting an
                //    error code back.  In this case, we force an exit
                //    from the loop, but return S_OK as per docfiles.

                if (ul < cb)
                {
                    cb = ul;
                }
            }
        }

        ul = _ulSize - _ulPos;
        if (ul > cb)
        {
            ul = cb;
        }

        memcpy(pv, &_ab[_ulPos], ul);
        pv = (BYTE *)pv + ul;
        cb -= ul;

        _ulPos += ul;
        ulRead += ul;
    }

Cleanup:
    if (pcbRead)
    {
        *pcbRead = ulRead;
    }

    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CStreamBuffered::Write(
     const void * pv,
     ULONG cb,
     ULONG * pcbWritten)
{
    if (pcbWritten)
    {
        *pcbWritten = 0;
    }
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::Seek(
     LARGE_INTEGER dlibMove,
     DWORD dwOrigin,
     ULARGE_INTEGER * plibNewPosition)
{

    // NOTE this is the fast solution but cost a call to get seek pos
    // at read (istvanc)
#ifndef _MAC
    // if buffer is not empty use our position
    if (_ulPos != _ulSize && dwOrigin != STREAM_SEEK_END)
    {
        if (dwOrigin == STREAM_SEEK_CUR)
        {
            dlibMove.QuadPart += (LONG)_ulPos - (LONG)_ulSize;
        }
        else   // dwOrigin == STREAM_SEEK_SET
        {
            dlibMove.QuadPart -= (LONGLONG)_uliSeekPos.QuadPart;
            dwOrigin = STREAM_SEEK_CUR;
        }
        if (dlibMove.QuadPart < 0 && dlibMove.QuadPart >= -(LONG)_ulSize)
        {
            _ulPos = (LONG)_ulSize + (LONG)dlibMove.QuadPart;
            if (plibNewPosition)
            {
                plibNewPosition->QuadPart = _uliSeekPos.QuadPart + dlibMove.QuadPart;
            }
            return S_OK;
        }
    }
#else
// MACTODO - Someone please check this block! - is it right?

    // if buffer is not empty use our position
    if (_ulPos != _ulSize && dwOrigin != STREAM_SEEK_END)
    {
        if (dwOrigin == STREAM_SEEK_CUR)
        {
            dlibMove.LowPart += (LONG)_ulPos - (LONG)_ulSize;
            if((LONG) dlibMove.LowPart < 0)
                dlibMove.HighPart = -1;
            else
                dlibMove.HighPart = 0;
        }
        else   // dwOrigin == STREAM_SEEK_SET
        {
            dlibMove.LowPart -= _uliSeekPos.LowPart;
            if((LONG) dlibMove.LowPart < 0)
                dlibMove.HighPart = -1;
            else
                dlibMove.HighPart = 0;
            dwOrigin = STREAM_SEEK_CUR;
        }
        if (dlibMove.HighPart < 0 && (LONG)dlibMove.LowPart >= -(LONG)_ulSize)
        {
            _ulPos = (LONG)_ulSize + (LONG)dlibMove.LowPart;
            if (plibNewPosition)
            {
                plibNewPosition->LowPart = _uliSeekPos.LowPart + (LONG)dlibMove.LowPart;
                plibNewPosition->HighPart = 0;
            }
            return S_OK;
        }
    }
#endif
    // mark buffer empty
    _ulPos = _ulSize;
    RRETURN(THR(_pStm->Seek(dlibMove, dwOrigin, plibNewPosition)));
}

STDMETHODIMP
CStreamBuffered::SetSize(
     ULARGE_INTEGER libNewSize)
{
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::CopyTo(
     IStream * pstm,
     ULARGE_INTEGER cb,
     ULARGE_INTEGER * pcbRead,
     ULARGE_INTEGER * pcbWritten)
{
    if (pcbWritten)
    {
#ifndef _MAC
        pcbWritten->QuadPart = 0;
#else
        pcbWritten->LowPart = 0;
        pcbWritten->HighPart = 0;
#endif
    }
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::Commit(
     DWORD grfCommitFlags)
{
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::Revert( void)
{
    // mark buffer empty
    _ulPos = _ulSize;
    RRETURN(THR(_pStm->Revert()));
}

STDMETHODIMP
CStreamBuffered::LockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    RRETURN(THR(_pStm->LockRegion(libOffset, cb, dwLockType)));
}

STDMETHODIMP
CStreamBuffered::UnlockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    RRETURN(THR(_pStm->UnlockRegion(libOffset, cb, dwLockType)));
}

STDMETHODIMP
CStreamBuffered::Stat(
     STATSTG * pstatstg,
     DWORD grfStatFlag)
{
    RRETURN(THR(_pStm->Stat(pstatstg, grfStatFlag)));
}

STDMETHODIMP
CStreamBuffered::Clone(
     IStream ** ppstm)
{
#if 1
    // TODO fix later, fail for now (istvanc)
    *ppstm = NULL;
    return E_FAIL;
#else
    HRESULT hr;

    //  TODO the underlying stream's current pos may not match the
    //    buffering layer's position (chrisz)

    hr = THR(_pStm->Clone(ppstm));
    if (hr)
        goto Cleanup;

    //
    // Don't wrap if already wrapped. We can determine
    // if it is wrapped by looking at the vtable pointer.
    //

    if (**(DWORD**)ppstm == *(DWORD *)this)
        goto Cleanup;

    *ppstm = BufferStream(*ppstm);

Cleanup:
    RRETURN(hr);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\strtype3.cxx ===
//+------------------------------------------------------------------------
//
//  File:       strtype3.c
//
//  Contents:   widechar character type function (CT_CTYPE3)
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRTYPE_HXX_
#define X_STRTYPE_HXX_
#include "strtype.hxx"
#endif

static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}
aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};

BOOL _stdcall
GetStringType3Ex(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPBYTE  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        BYTE bCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                bCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                bCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                bCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                bCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    bCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    bCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = bCharType;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\substm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       substm.hxx
//
//  Contents:   Substream implementation
//
//  History:    04-22-1997   DBau (David Bau)    Created
//
//-------------------------------------------------------------------------

#ifdef UNIX
#  ifdef MW_MSCOMPATIBLE_LI
#    undef MW_MSCOMPATIBLE_LI
#  endif
#endif

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SUBSTM_HXX_
#define X_SUBSTM_HXX_
#include "substm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

MtDefine(CSubstream, Dwn, "CSubstream")

//+------------------------------------------------------------------------
//
//  Function:   CreateReadOnlySubstream
//
//  Synopsis:   Constructs and intializes a read-only substream.
//
//              The substream begins at the current seek pointer in
//              the source stream, and stores its data in the next
//              cb bytes. The source stream's seek pointer is not
//              affected by a read only substream.
//
//-------------------------------------------------------------------------
HRESULT CreateReadOnlySubstream(CSubstream **ppStreamOut, IStream *pStreamSource, ULARGE_INTEGER cb)
{
    HRESULT hr;
    CSubstream *pSubstream = NULL;

    pSubstream = new CSubstream();
    if (!pSubstream)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pSubstream->InitRead(pStreamSource, cb));
    if (hr)
        goto Cleanup;
    
    *ppStreamOut = pSubstream;
    pSubstream = NULL;
    
Cleanup:
    ReleaseInterface(pSubstream);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CreateWritableSubstream
//
//  Synopsis:   Constructs and intializes a writable substream.
//
//              The substream begins at the current seek pointer in
//              the source stream, and grows as data is written. The
//              source stream's seek pointer is used directly by
//              the substream, so no operations should be done directly
//              on the source while the substream is in use.
//
//-------------------------------------------------------------------------
HRESULT CreateWritableSubstream(CSubstream **ppStreamOut, IStream *pStreamSource)
{
    HRESULT hr;
    CSubstream *pSubstream = NULL;

    pSubstream = new CSubstream();
    if (!pSubstream)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pSubstream->InitWrite(pStreamSource));
    if (hr)
        goto Cleanup;

    *ppStreamOut = pSubstream;
    pSubstream = NULL;
    
Cleanup:
    ReleaseInterface(pSubstream);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CSubstream::ctor
//
//  Synopsis:   Maintains a secondary object count for the object
//
//-------------------------------------------------------------------------
CSubstream::CSubstream()
{
    IncrementSecondaryObjectCount(10);
    _ulRefs = 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::dtor
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------
CSubstream::~CSubstream()
{
    Detach();
    DecrementSecondaryObjectCount(10);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Detach
//
//  Synopsis:   Detaches a substream from the original stream.
//              Useful for ensuring no further writes to the
//              real stream after a substream is leaked.
//
//-------------------------------------------------------------------------
void CSubstream::Detach()
{
    if (_pOrig && _pOrig != this)
    {
        _pOrig->Release();
        _pOrig = this;
    }
    
    ClearInterface(&_pStream);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::InitRead
//
//  Synopsis:   Initializes a fixed-size, read-only substream
//              object at the current seek pointer in the
//              source stream.
//
//-------------------------------------------------------------------------
HRESULT CSubstream::InitRead(IStream *pStream, ULARGE_INTEGER cb)
{
    IStream *pClone = NULL;
    HRESULT hr;
    
    Assert(!_pStream && !_pOrig); // Init can only be called once

    _pOrig = this;
    _fWritable = FALSE;
    
    hr = THR(pStream->Clone(&pClone));
    if (hr)
        goto Cleanup;
    
    hr = THR(pClone->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &_ibStart));
    if (hr)
        goto Cleanup;
        
    _ibEnd.QuadPart = _ibStart.QuadPart + cb.QuadPart;

    _pStream = pClone;
    pClone = NULL;

Cleanup:
    ReleaseInterface(pClone);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::InitWrite
//
//  Synopsis:   Initializes a zero-size, writable substream
//              object at the current seek pointer in the
//              source stream.
//
//-------------------------------------------------------------------------
HRESULT CSubstream::InitWrite(IStream *pStream)
{
    HRESULT hr;
    
    Assert(!_pStream && !_pOrig); // Init can only be called once

    _pOrig = this;
    _fWritable = TRUE;
    
    pStream->AddRef();
    _pStream = pStream;

    hr = THR(pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &_ibStart));
    if (hr)
        goto Cleanup;
        
    _ibEnd.QuadPart = _ibStart.QuadPart; // begin as zero-sized substream
    
Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::InitClone
//
//  Synopsis:   Initializes a clone of an existing substream.
//
//-------------------------------------------------------------------------
HRESULT CSubstream::InitClone(CSubstream *pOrig)
{
    HRESULT hr;
    
    Assert(!_pStream && !_pOrig); // Init can only be called once
    
    Assert(pOrig->_pOrig);
    
    hr = THR(pOrig->_pStream->Clone(&_pStream));
    if (hr)
        goto Cleanup;
        
    pOrig->_pOrig->AddRef();
    _pOrig = pOrig->_pOrig;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::QueryInterface
//
//  Synopsis:   QI implementation
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IStream)
        QI_INHERITS(this, IStream)
    default:
        return(E_NOINTERFACE);
    }
    
    ((IUnknown *) *ppv)->AddRef();

    DbgTrackItf(iid, "CSubstream", FALSE, ppv);
    
    return(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Read, IStream
//
//  Synopsis:   Read wrapper, guards against reading beyond
//              the boundaries of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Read(void HUGEP *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;
    ULARGE_INTEGER ibCur;
    
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
    if (hr)
        goto Cleanup;
        
    Assert(_pOrig->_ibEnd.QuadPart >= ibCur.QuadPart);

    if (cb > _pOrig->_ibEnd.QuadPart - ibCur.QuadPart)
        cb = _pOrig->_ibEnd.QuadPart - ibCur.QuadPart;
        
    hr = THR(_pStream->Read(pv, cb, pcbRead));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Write, IStream
//
//  Synopsis:   Write wrapper, expands stream if needed when
//              writing beyond the end.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Write(const void HUGEP *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;
    ULARGE_INTEGER ibCur;
    
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);
        
    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
    if (hr)
        goto Cleanup;
        
    if (cb + ibCur.QuadPart > _pOrig->_ibEnd.QuadPart)
        _pOrig->_ibEnd.QuadPart = ibCur.QuadPart + cb;
        
    hr = THR(_pStream->Write(pv, cb, pcbRead));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Seek, IStream
//
//  Synopsis:   Seek wrapper, expands stream if needed when
//              seeking beyond the end.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Seek(LARGE_INTEGER cbMove, DWORD dwOrigin, ULARGE_INTEGER *pibNewPosition)
{
    LARGE_INTEGER cbSeek;
    ULARGE_INTEGER ibCur;
    
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    switch (dwOrigin)
    {
    default:
    case STREAM_SEEK_SET:
        cbSeek.QuadPart = _pOrig->_ibStart.QuadPart + cbMove.QuadPart;
        break;
    case STREAM_SEEK_CUR:
        hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
        if (hr)
            goto Cleanup;
        cbSeek.QuadPart = ibCur.QuadPart + cbMove.QuadPart;
        break;
    case STREAM_SEEK_END:
        cbSeek.QuadPart = _pOrig->_ibEnd.QuadPart + cbMove.QuadPart;
        break;
    }

    if ((unsigned)cbSeek.QuadPart < _pOrig->_ibStart.QuadPart)
        return(STG_E_ACCESSDENIED);
        
    if ((unsigned)cbSeek.QuadPart > _pOrig->_ibEnd.QuadPart)
    {
        if (!_pOrig->_fWritable)
            return(STG_E_ACCESSDENIED);
        _pOrig->_ibEnd.QuadPart = cbSeek.QuadPart;
    }
 
    hr = THR(_pStream->Seek(cbSeek, STREAM_SEEK_SET, &ibCur));
    if (hr)
        goto Cleanup;

    Assert((unsigned)cbSeek.QuadPart == ibCur.QuadPart);

    if (pibNewPosition)
        pibNewPosition->QuadPart = ibCur.QuadPart - _pOrig->_ibStart.QuadPart;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::SetSize, IStream
//
//  Synopsis:   SetSize wrapper, delegates to source stream's
//              SetSize implementation.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::SetSize(ULARGE_INTEGER cbNewSize)
{
    ULARGE_INTEGER cbSourceNewSize;
    HRESULT hr;
   
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);

    cbSourceNewSize.QuadPart = _pOrig->_ibStart.QuadPart + cbNewSize.QuadPart;
        
    hr = THR(_pStream->SetSize(cbSourceNewSize));
    if (hr)
        goto Cleanup;
        
    _pOrig->_ibEnd.QuadPart = cbSourceNewSize.QuadPart;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::CopyTo, IStream
//
//  Synopsis:   CopyTo wrapper, guards against reading beyond
//              the boundaries of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::CopyTo(IStream *pStream, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    ULARGE_INTEGER ibCur;
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
    if (hr)
        goto Cleanup;
        
    Assert(_pOrig->_ibEnd.QuadPart >= ibCur.QuadPart);

    if (cb.QuadPart > _pOrig->_ibEnd.QuadPart - ibCur.QuadPart)
        cb.QuadPart = _pOrig->_ibEnd.QuadPart - ibCur.QuadPart;

    hr = THR(_pStream->CopyTo(pStream, cb, pcbRead, pcbWritten));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Commit, IStream
//
//  Synopsis:   Commit wrapper.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Commit(DWORD dwFlags)
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);

    RRETURN(THR(_pStream->Commit(dwFlags)));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Revert, IStream
//
//  Synopsis:   Revert wrapper.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Revert()
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);

    RRETURN(THR(_pStream->Revert()));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::LockRegion, IStream
//
//  Synopsis:   LockRegion wrapper, guards against locking
//              beyond the boundary of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::LockRegion(ULARGE_INTEGER ibOffset, ULARGE_INTEGER cb, DWORD dwFlags)
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    ibOffset.QuadPart += _pOrig->_ibStart.QuadPart;
    
    if (ibOffset.QuadPart < _pOrig->_ibStart.QuadPart || ibOffset.QuadPart + cb.QuadPart > _pOrig->_ibEnd.QuadPart)
        return STG_E_ACCESSDENIED;

    RRETURN(_pStream->LockRegion(ibOffset, cb, dwFlags));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::UnlockRegion, IStream
//
//  Synopsis:   UnlockRegion wrapper, guards against unlocking
//              beyond the boundary of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::UnlockRegion(ULARGE_INTEGER ibOffset, ULARGE_INTEGER cb, DWORD dwFlags)
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    ibOffset.QuadPart += _pOrig->_ibStart.QuadPart;
    
    if (ibOffset.QuadPart < _pOrig->_ibStart.QuadPart || ibOffset.QuadPart + cb.QuadPart > _pOrig->_ibEnd.QuadPart)
        return STG_E_ACCESSDENIED;

    RRETURN(_pStream->LockRegion(ibOffset, cb, dwFlags));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Stat, IStream
//
//  Synopsis:   Stat wrapper, reports the size of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Stat(STATSTG *pstatstg, DWORD dwFlags)
{
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    hr = THR(_pStream->Stat(pstatstg, dwFlags));
    if (hr)
        goto Cleanup;

    pstatstg->cbSize.QuadPart = _pOrig->_ibEnd.QuadPart - _pOrig->_ibStart.QuadPart;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Clone, IStream
//
//  Synopsis:   Clone wrapper, creates a new instance of
//              CSubstream pointing to the same IStream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Clone(IStream **ppStream)
{
    CSubstream *pSubstream;
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    pSubstream = new CSubstream();
    if (!pSubstream)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = THR(pSubstream->InitClone(this));
    if (hr)
        goto Cleanup;

    *ppStream = pSubstream;
    pSubstream = NULL;

Cleanup:
    ReleaseInterface(pSubstream);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\strtype1.cxx ===
//+------------------------------------------------------------------------
//
//  File:       strtype1.c
//
//  Contents:   widechar character type function (CT_CTYPE1)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRTYPE_HXX_
#define X_STRTYPE_HXX_
#include "strtype.hxx"
#endif

DWORD adwData[218] =
{
#if 0
    0x00000000, 0x7fffffe0, 0xfffffeff, 0xffffffff,  // 0x00-0x03
    0xfffffd3f, 0xffffff00, 0x0000ffff, 0xff800000,  // 0x04-0x07
    0x02ebffff, 0xdfffffff, 0xfffefe2a, 0xbffff000,  // 0x08-0x0b
    0x7ffbffff, 0xffff7ffb, 0xd000ffff, 0xf998ffff,  // 0x0c-0x0f
    0xfff3fdd0, 0x00007fff, 0xfffffe00, 0x7fffffff,  // 0x10-0x13
    0xff000000, 0xffe0e000, 0x7fe00000, 0xffffff3e,  // 0x14-0x17
    0xfffef400, 0x07ffffff, 0xffffffd0, 0x000000ff,  // 0x18-0x1b
    0xd0000000, 0x07f99fff, 0xffbfa3d0, 0x0000000d,  // 0x1c-0x1f
    0xd000d000, 0x07e19fff, 0xffbfb6d0, 0x0000007a,  // 0x20-0x23
    0x07f5dfff, 0xffbfb7d0, 0x80000000, 0xffbfb3d0,  // 0x24-0x27
    0x07e3bd6b, 0x18e3fdd0, 0x07fbbfff, 0xffbff7d0,  // 0x28-0x2b
    0x00000002, 0xffbfffd0, 0xfffeb000, 0xfd000000,  // 0x2c-0x2f
    0x69a40f7f, 0x75360000, 0x0000000d, 0xfd00ffff,  // 0x30-0x33
    0xffffffd1, 0xe0ffffff, 0xffffffe0, 0xfffffdfd,  // 0x34-0x37
    0xfdfdff55, 0xfffffffd, 0xfffffbf8, 0x3bf8f3f0,  // 0x38-0x3b
    0xfff83bf8, 0x0000000f, 0xffd00000, 0x04000000,  // 0x3c-0x3f
    0xfffff81e, 0xffffffee, 0xfff87fff, 0xfffe0000,  // 0x40-0x43
    0xf0000000, 0xfffd0000, 0xfe001f01, 0xfffffefa,  // 0x44-0x47
    0xdbffffff, 0xffffd000, 0x00001fff, 0xffbfffff,  // 0x48-0x4b
    0xbfffffff, 0xffff3fff, 0x0000fff0, 0xfffffff8,  // 0x4c-0x4f
    0x03ffffff, 0x7ffffffe, 0x3f3f3f38, 0x007d0000,  // 0x50-0x53
    0xfff00000, 0x00000001, 0x7fff003f, 0x8000001f,  // 0x54-0x57
    0x8000001e, 0x00000100, 0x00002000, 0xfffffffe,  // 0x58-0x5b
    0xd0000d22, 0x0d000000, 0x3e000000, 0x0000007f,  // 0x5c-0x5f
    0x00400000, 0x00001800, 0x00080011, 0x801fe000,  // 0x60-0x63
    0x003d8000, 0x00000bff, 0x70000000, 0xfffdf800,  // 0x64-0x67
    0x3d008000, 0x0000000b, 0xf99d0100, 0x30003fe0,  // 0x68-0x6b
    0x20000000, 0xe19d0000, 0x0000f800, 0xfddd8000,  // 0x6c-0x6f
    0xf19d0300, 0x00008000, 0x30000000, 0x00000003,  // 0x70-0x73
    0xe3bd0100, 0xfbbd0600, 0xf3bd0100, 0x00014fe1,  // 0x74-0x77
    0x03ff0030, 0x0001ffdd, 0xfafd0000, 0x00000010,  // 0x78-0x7b
    0x00000007, 0xd0070007, 0x00070006, 0xfffeffff,  // 0x7c-0x7f
    0xfe000000, 0x003f003f, 0x003e0000, 0xffffff80,  // 0x80-0x83
    0xe000ffff, 0xffe00000, 0xf8000000, 0xfffffd00,  // 0x84-0x87
    0xfffbffff, 0xffff0000, 0xfffff03f, 0x7bdfffff,  // 0x88-0x8b
    0xff7fffff, 0xfff5e2fe, 0x7f0003ff, 0xfffff8ff,  // 0x8c-0x8f
    0xffff7ffe, 0xffffff01, 0x0000007e, 0x0000001e,  // 0x90-0x93
    0xfffffff1, 0xffff8000, 0xfff0ffff, 0xfffffe1f,  // 0x94-0x97
    0xf000ffff, 0xf87fefff, 0xfef0ebff, 0x7d008000,  // 0x98-0x9b
    0xfefe0000, 0x0000ffd0, 0x00003040, 0x03ff0000,  // 0x9c-0x9f
    0x01ffe000, 0x00008fd0, 0x7e000000, 0xfffffefe,  // 0xa0-0xa3
    0xaaaaaaaa, 0xaaaaaa55, 0x552aaaaa, 0xaaaaaad4,  // 0xa4-0xa7
    0x6b73db8d, 0xa94b7588, 0x0db55552, 0xaaaa682a,  // 0xa8-0xab
    0xaaaaaa00, 0x02eb7fff, 0xdff00000, 0x0000382a,  // 0xac-0xaf
    0xaaaa0000, 0x8000aaaa, 0x5110aaaa, 0xaaa2a880,  // 0xb0-0xb3
    0xaaaaa800, 0xaaaaaa80, 0x00ff00fd, 0x00ff00ff,  // 0xb4-0xb7
    0x00fd0055, 0x00ff0000, 0x00ff00f8, 0x00f800f0,  // 0xb8-0xbb
    0x00f800f8, 0x000003ff, 0x55555555, 0x555555aa,  // 0xbc-0xbf
    0xaad55555, 0x5555552b, 0x948d2472, 0x54948a64,  // 0xc0-0xc3
    0x06daaaad, 0x5555b415, 0x55555500, 0xdfdff5ff,  // 0xc4-0xc7
    0x3ffef026, 0x9f800000, 0x000fffff, 0xfffed600,  // 0xc8-0xcb
    0x1555f000, 0x40005555, 0x28885555, 0x55515440,  // 0xcc-0xcf
    0x555557e0, 0x55555540, 0xff00fd00, 0xff00ff00,  // 0xd0-0xd3
    0xfd00ff00, 0xff00fffd, 0xff00fb00, 0x3b00f300,  // 0xd4-0xd7
    0xff003b00, 0xfe001f00
#else
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
#endif
};

BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL FormsIsCharSpace(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }

#if 0   
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
   
    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL FormsIsCharXDigit(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
#if 0
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
}

#ifdef NEVER
// unused
BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};
#endif // NEVER

BOOL FormsIsCharCntrl(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL FormsIsCharBlank(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}

BOOL FormsIsCharAlphaNumeric(WCHAR wch)
{
    return FormsIsCharAlpha(wch) || FormsIsCharDigit(wch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\taskman.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       taskman.cxx
//
//  Contents:   Lightweight task manager
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

//+---------------------------------------------------------------------------
//  Trace Tags
//----------------------------------------------------------------------------

PerfDbgTag(tagTaskMan, "TaskMan", "Trace lightweight task manager")

//+---------------------------------------------------------------------------
//  Definitions
//----------------------------------------------------------------------------

#define TASKMAN_TIMERID     1000
#define TIMER_INFINITE      0x7FFFFFFF

//+---------------------------------------------------------------------------
//
//  Member:     InitTaskManager
//
//  Synopsis:   Initializes the lightweight task manager
//
//----------------------------------------------------------------------------

HRESULT InitTaskManager(THREADSTATE * pts)
{
    PerfDbgLog(tagTaskMan, 0, "+InitTaskManager");

    pts->task.dwTickRun   = 200;
    pts->task.dwTickTimer = TIMER_INFINITE;

    PerfDbgLog(tagTaskMan, 0, "-InitTaskManager");
    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     DeinitTaskManager
//
//----------------------------------------------------------------------------

void DeinitTaskManager(THREADSTATE * pts)
{
    PerfDbgLog(tagTaskMan, 0, "+DeinitTaskManager");

    CTask * ptask;

    Assert(pts->task.ptaskHead == NULL && "Active tasks remain at shutdown");
    Assert(pts->task.ptaskCur == NULL);

    while ((ptask = pts->task.ptaskHead) != NULL)
    {
        Assert(!ptask->TestFlag(TASKF_INRUN));
        ptask->Terminate();
        ptask->Release();
    }

    FormsKillTimer(InitTaskManager, TASKMAN_TIMERID);

    PerfDbgLog(tagTaskMan, 0, "-DeinitTaskManager");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanResetTimer
//
//  Synopsis:   Sets the timer to the minimum interval of all unblocked
//              tasks.
//
//----------------------------------------------------------------------------

void CTask::TaskmanResetTimer()
{
    PerfDbgLog(tagTaskMan, 0, "+CTask::TaskmanResetTimer");

    THREADSTATE * pts = GetThreadState();
    CTask * ptask;
    DWORD   dwMin;
    DWORD   dwCurTick = GetTickCount();
    DWORD   dwFromLastTick;

    if (pts->task.fSuspended)
    {
        dwMin = TIMER_INFINITE;
    }
    else if (pts->task.cInterval > 0)
    {
        dwMin = TIMER_INFINITE;

        for (ptask = pts->task.ptaskHead; ptask; ptask = ptask->_ptaskNext)
        {
            if (!ptask->TestFlag(TASKF_BLOCKED | TASKF_TERMINATED))
            {
                // Check for smallest interal
                if (dwMin > ptask->_dwTickInterval)
                    dwMin = ptask->_dwTickInterval;

                dwFromLastTick = dwCurTick - ptask->_dwTickLast;

                // Check if a task needs to run earlier then that
                if (dwMin > dwFromLastTick)
                    dwMin = dwFromLastTick;
            }
        }
    }
    else if (pts->task.cUnblocked > 0)
    {
        dwMin = 0;
    }
    else
    {
        dwMin = TIMER_INFINITE;
    }

    TaskmanSetTimer(dwMin);

    PerfDbgLog(tagTaskMan, 0, "-CTask::TaskmanResetTimer");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanSetTimer
//
//  Synopsis:   Sets timer if new interval is different then existing one
//
//----------------------------------------------------------------------------

void
CTask::TaskmanSetTimer(DWORD dwTimeOut)
{
    THREADSTATE * pts = GetThreadState();

    if (dwTimeOut != pts->task.dwTickTimer)
    {
        PerfDbgLog1(tagTaskMan, 0, "CTask::TaskmanSetTimer %ld", dwTimeOut);

        IGNORE_HR(FormsSetTimer(InitTaskManager,
            ONTICK_METHOD(CTask, OnTaskTick, ontasktick), TASKMAN_TIMERID, dwTimeOut));

        pts->task.dwTickTimer = dwTimeOut;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanEnqueue
//
//  Synopsis:   Adds a task to the list of tasks
//
//----------------------------------------------------------------------------

void CTask::TaskmanEnqueue(CTask * ptask)
{
    PerfDbgLog(tagTaskMan, ptask, "+CTask::TaskmanEnqueue");

    THREADSTATE * pts = GetThreadState();
    CTask ** pptask, * ptaskT;

    Assert(!ptask->TestFlag(TASKF_ENQUEUED));
    Assert(!ptask->TestFlag(TASKF_TERMINATED));

    for (pptask = &pts->task.ptaskHead; (ptaskT = *pptask) != NULL;
            pptask = &ptaskT->_ptaskNext)
        ;
    *pptask = ptask;
    ptask->_ptaskNext = NULL;
    ptask->SetFlag(TASKF_ENQUEUED);

    if (!ptask->TestFlag(TASKF_BLOCKED))
    {
        pts->task.cUnblocked += 1;
    }

    if (ptask->_dwTickInterval > 0)
    {
        pts->task.cInterval += 1;
    }

    TaskmanResetTimer();

    PerfDbgLog(tagTaskMan, ptask, "-CTask::TaskmanEnqueue");
}

//+---------------------------------------------------------------------------
//
//  Member:     CTaskManager::Dequeue
//
//  Synopsis:   Removes a task from the list of tasks
//
//----------------------------------------------------------------------------

void CTask::TaskmanDequeue(CTask * ptask)
{
    PerfDbgLog(tagTaskMan, ptask, "+CTask::TaskmanDequeue");

    THREADSTATE * pts;
    CTask ** pptask, * ptaskT;

    if (!ptask->TestFlag(TASKF_ENQUEUED))
        goto exit;

    pts = GetThreadState();

    for (pptask = &pts->task.ptaskHead; (ptaskT = *pptask) != NULL;
            pptask = &ptaskT->_ptaskNext)
    {
        if (ptaskT == ptask)
        {
            if (pts->task.ptaskNext == ptask)
                pts->task.ptaskNext = ptask->_ptaskNext;

            if (pts->task.ptaskNextInLoop == ptask)
                pts->task.ptaskNextInLoop = ptask->_ptaskNext;


            *pptask = ptask->_ptaskNext;

            ptask->ClearFlag(TASKF_ENQUEUED);

            if (!ptask->TestFlag(TASKF_BLOCKED))
            {
                pts->task.cUnblocked -= 1;
            }

            if (ptask->_dwTickInterval > 0)
            {
                pts->task.cInterval -= 1;
            }

            TaskmanResetTimer();

            goto exit;
        }
    }

    AssertSz(FALSE, "Task not found on task manager queue");

exit:
    PerfDbgLog(tagTaskMan, ptask, "-CTask::TaskmanDequeue");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanRunTask
//
//  Synopsis:   Calls the OnRun method of the given task
//
//----------------------------------------------------------------------------

void CTask::TaskmanRunTask(THREADSTATE * pts, DWORD dwTick, CTask * ptask)
{
    PerfDbgLog(tagTaskMan, ptask, "+CTask::TaskmanRunTask");

    // Don't allow more than one task to run at the same time

    if (pts->task.ptaskCur)
        goto exit;

    ptask->SetFlag(TASKF_INRUN);
    pts->task.ptaskCur = ptask;
    ptask->_dwTickLast = dwTick;
    ptask->OnRun(dwTick + pts->task.dwTickRun);

    if (ptask->TestFlag(TASKF_DOTERM))
    {
        ptask->OnTerminate();
        TaskmanDequeue(ptask);
    }

    pts->task.ptaskCur = NULL;
    ptask->ClearFlag(TASKF_INRUN);

    if (pts->task.fSuspended)
    {
        PerfDbgLog(tagTaskMan, 0, "CTask::TaskmanRunTask (resume taskman)");
        pts->task.fSuspended = FALSE;
        TaskmanResetTimer();
    }

    if (ptask->TestFlag(TASKF_DODESTRUCT))
        delete ptask;

exit:
    PerfDbgLog(tagTaskMan, ptask, "-CTask::TaskmanRunTask");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanRun
//
//  Synopsis:   Finds the next available task and calls it's OnRun method
//
//----------------------------------------------------------------------------

void CTask::TaskmanRun()
{
    PerfDbgLog(tagTaskMan, 0, "+CTask::TaskmanRun");

    THREADSTATE * pts = GetThreadState();
    CTask *  ptask;
    DWORD    dwTick;
    DWORD    dwNewInterval = 0;
    DWORD    dwFromLast;

    if (!pts->task.ptaskHead)
        goto exit;

    if (pts->task.ptaskCur)
    {
        if (!pts->task.fSuspended)
        {
            PerfDbgLog(tagTaskMan, 0, "CTask::TaskmanRun (suspend taskman)");
            pts->task.fSuspended = TRUE;
            TaskmanResetTimer();
        }
        goto exit;
    }

    if (pts->task.ptaskNext == NULL)
        pts->task.ptaskNext = pts->task.ptaskHead;

    ptask  = pts->task.ptaskNext;
    dwTick = GetTickCount();

    // Run one 0-interval  task first
    for (;;)
    {
        if (    !ptask->TestFlag(TASKF_BLOCKED | TASKF_TERMINATED)
            &&  0 == ptask->_dwTickInterval)
        {
            pts->task.ptaskNext = ptask->_ptaskNext;

            TaskmanRunTask(pts, dwTick, ptask);

            break;
        }

        ptask = ptask->_ptaskNext;

        if (ptask == NULL)
            ptask = pts->task.ptaskHead;

        if (ptask == pts->task.ptaskNext)
            break;
    }

    if (pts->task.cInterval)
    {
        // Now run all interval tasks that need to run
        ptask = pts->task.ptaskHead;

        // We cache the next task in the thread task, so we can fix it
        // when tasks are destroyed as result of being run.
        //pptaskNext = &pts->task.ptaskNextInLoop;

        for (;;)
        {
            // Before we run the task we should get the next task, since TaskmanRunTask
            // might delete any task on the chain including ptask. If the next task is deleted
            // as result of calling TaskmanRunTask, pts->task.ptaskNextInLoop will be updated.
            pts->task.ptaskNextInLoop = ptask->_ptaskNext;//*pptaskNext = ptask->_ptaskNext;

            // skip 0 tasks
            if (    !ptask->TestFlag(TASKF_BLOCKED | TASKF_TERMINATED)
                &&  0 != ptask->_dwTickInterval)
            {

                if (0 == ptask->_dwTickLast)
                {
                    // Force first run
                    dwFromLast = ptask->_dwTickInterval;
                }
                else
                {
                    dwFromLast = dwTick - ptask->_dwTickLast;
                }

                // If we are 10 ticks or less from running this task run it now
                if (dwFromLast + 10>= ptask->_dwTickInterval)
                {
                    TaskmanRunTask(pts, dwTick, ptask);
                }
                else
                {
                    if (dwFromLast < dwNewInterval)
                    {
                        dwNewInterval = dwFromLast;
                    }
                }
            }

        
            // grab the next task
            ptask = pts->task.ptaskNextInLoop;

            if (ptask == NULL )
            {
                break;
            }

        }

        if (dwNewInterval)
        {
            TaskmanSetTimer(dwNewInterval);
        }
 
    }

exit:
    PerfDbgLog(tagTaskMan, 0, "-CTask::TaskmanRun");
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::CTask
//
//  Synopsis:   Constructor.
//
//----------------------------------------------------------------------------

CTask::CTask(BOOL fBlocked)
{
    #if DBG==1
    _dwThreadId = GetCurrentThreadId();
    #endif

    _ulRefs = 1;

    if (fBlocked)
        SetFlag(TASKF_BLOCKED);
    
    TaskmanEnqueue(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::~CTask
//
//  Synopsis:   Destructor.
//
//----------------------------------------------------------------------------

CTask::~CTask()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    TaskmanDequeue(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::AddRef
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTask::AddRef()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    return(++_ulRefs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::Release
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTask::Release()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (--_ulRefs == 0)
    {
        Terminate();

        if (TestFlag(TASKF_INRUN))
            SetFlag(TASKF_DODESTRUCT);
        else
            delete this;

        return(0);
    }

    return(_ulRefs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::SetInterval
//
//  Synopsis:   Sets the periodic interval for this task
//
//----------------------------------------------------------------------------

void CTask::SetInterval(DWORD dwTick)
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (dwTick != _dwTickInterval)
    {
        if (!TestFlag(TASKF_BLOCKED) && !!dwTick != !!_dwTickInterval)
        {
            THREADSTATE * pts = GetThreadState();

            if (dwTick == 0)
                pts->task.cInterval -= 1;
            else
                pts->task.cInterval += 1;
        }

        _dwTickInterval = dwTick;

        TaskmanResetTimer();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::SetBlocked
//
//  Synopsis:   Blocks or unblocks the task
//
//----------------------------------------------------------------------------

void CTask::SetBlocked(BOOL fBlocked)
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (!!fBlocked != !!TestFlag(TASKF_BLOCKED))
    {
        THREADSTATE * pts = GetThreadState();

        if (fBlocked)
        {
            SetFlag(TASKF_BLOCKED);
            pts->task.cUnblocked -= 1;

            if (_dwTickInterval > 0)
                pts->task.cInterval -= 1;
        }
        else
        {
            ClearFlag(TASKF_BLOCKED);
            pts->task.cUnblocked += 1;

            if (_dwTickInterval > 0)
                pts->task.cInterval += 1;
        }

        TaskmanResetTimer();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::Terminate
//
//  Synopsis:   Requests that task be terminated.  As soon as possible,
//              the task's OnTerminate method will be called (typically
//              before this method returns).  Actual object destruction
//              doesn't happen until all references are released.
//
//----------------------------------------------------------------------------

void CTask::Terminate()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (!TestFlag(TASKF_TERMINATED))
    {
        if (TestFlag(TASKF_INRUN))
            SetFlag(TASKF_DOTERM);
        else
        {
            OnTerminate();
            TaskmanDequeue(this);
        }

        SetFlag(TASKF_TERMINATED);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::OnTerminate
//
//  Synopsis:   Base implementation.  Does nothing.
//
//----------------------------------------------------------------------------

void CTask::OnTerminate()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::OnTaskTick
//
//  Synopsis:   Callback timer procedure.
//
//----------------------------------------------------------------------------

HRESULT CTask::OnTaskTick(UINT idTimer)
{
    TaskmanRun();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\tearoff.cxx ===
//+------------------------------------------------------------------------
//
//  File:       toff.cxx
//
//  Contents:   Tear off interfaces.
//
//  History:
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

MtDefine(TearOff, PerProcess, "TearOff Thunk")
DeclareTag(tagNoTearoffCache, "Tearoff", "Disable tearoff cache")
DeclareTag(tagLeakTearoffs, "Tearoff", "Leak all tearoffs on purpose")
DeclareTag(tagZapTearoffs, "Tearoff", "Zap contents of tearoffs on release")
DeclareTag(tagTearoffSymbols, "!Memory", "Leaks: Stacktraces and Symbols for Tearoffs")

typedef HRESULT (FNQI)(void *pv, REFIID iid, void **ppv);
typedef ULONG   (FNAR)(void *pv);

#if defined(_M_IX86) && !defined(_MAC)

#define THUNK_IMPLEMENT_COMPARE(n)\
void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n()\
{                                           \
    /* this = thisArg                   */  \
    __asm mov eax, [esp + 4]                \
    /* save original this               */  \
    __asm push eax                          \
    /*  if this->_dwMask & 1 << n       */  \
    __asm test dword ptr [eax + 28], 1<<n   \
    /* jmp if < to Else */                  \
    __asm je $+9                            \
    /* increment offset to pvObject2    */  \
    __asm add eax, 8                        \
    /* increment offset to pvObject1    */  \
    __asm add eax, 12                       \
    /* pvObject = this->_pvObject       */  \
    __asm mov ecx, [eax]                    \
    /* thisArg = pvObject2              */  \
    __asm mov [esp + 8], ecx                \
    /* apfnObject = this->_apfnVtblObj  */  \
    __asm mov ecx, [eax + 4]                \
    /* pfn = apfnObject[n]              */  \
    __asm mov ecx, [ecx + (4 * n)]          \
    /* set eax back to the tearoff      */  \
    __asm pop eax                           \
    /* remember vtbl index of method    */  \
    __asm mov dword ptr [eax + 32], n       \
    /* jump....                         */  \
    __asm jmp ecx                           \
}

#define THUNK_IMPLEMENT_SIMPLE(n)\
void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n()\
{                                           \
    /* this = thisArg                   */  \
    __asm mov eax, [esp + 4]                \
    /* remember vtbl index of method    */  \
    __asm mov dword ptr [eax + 32], n       \
    /* pvObject = this->_pvObject       */  \
    __asm mov ecx, [eax + 12]               \
    /* thisArg = pvObject               */  \
    __asm mov [esp + 4], ecx                \
    /* apfnObject = this->_apfnVtblObj  */  \
    __asm mov ecx, [eax + 16]               \
    /* pfn = apfnObject[n]              */  \
    __asm mov ecx, [ecx + (4 * n)]          \
    /* jump....                         */  \
    __asm jmp ecx                           \
}

// Single step a few times for the function you are calling.

THUNK_ARRAY_3_TO_15(IMPLEMENT_COMPARE);
THUNK_ARRAY_16_AND_UP(IMPLEMENT_SIMPLE);

#elif defined(_MAC)

#define offsetof_pvObject    12      // Keep in sync w/ TOFF.CXX
#define offsetof_apfn        16
#define offsetof_Mask        28

//* ON ENTRY
//*
//*      r3  - this
//*      The stack frame is of the original caller.
//*
//* REGISTER USAGE
//*
//*      r11 - temp
//*
//* ON EXIT
//*
//*      r3 - this
//*      r12 - The transition vector address (thunk function being called)
//*      r31 - address of thunk

#define THUNK_IMPLEMENT_COMPARE(n)\
asm void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n()\
{                                           \
       stw     r3,-4(SP);                /* save this pointer on stack */ \
       li      r12, 1;                  /* load 1 into r12, and... */\
       slwi    r12, r12, n;             /* ...shift left by the index */\
       lwz     r11, offsetof_Mask(r3);  /* load mask dword into r11 */\
       and     r11, r11, r12;           \
       cmpli   cr1, 0, r11, 0;            /* compare */\
       li      r12, n;                  /* Put the method # in r12 */\
       stw     r12, 32(r3);             /* save method # in thunk */ \
       bc      12, 6, Obj;          \
       addi    r3, r3, 8;               /* add for object 1 */\
Obj:   addi    r3, r3, 12;             /* add offset */\
                        /* r3 is now the pvObject ptr, i.e. the intermediate 'this' ptr */\
       lwz     r11, 0x4(r3);            /* Copy this->apfn to r11 */\
       lwz     r3,0(r3);                    /* set r3 to object pointer */\
       lwz     r0,0(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,tear;                /* bne - tearoff non virtual */\
       lwz     r0,8(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,realvt;                /* bne - c++ vtable */\
tear:  li      r12, (n*12);             /* Put the method # * 12 in r12 */\
       add     r12,r12,r11  ;                   /* r12 points to correct tearoff vtbl entry */\
       lwz     r11,4(r12);                  /* get vtbl offset / flag */\
       lwz     r12,8(r12);                  /* get address in non virtual */\
       cmpi    crf0,0,r11,0;                    /* check if virtual */\
       bc      12, 0, Non;                      /* branch if not virtual */\
       lwz     r12,0(r3);               \
       lwzx    r12,r12,r11;                 /* get function vector address */\
Non:   lwz     r0,0(r12);                   /* get function address */\
       mtctr   r0;  \
       lwz     r2,4(r12);                   /* load new toc */ \
       lwz     r11,-4(SP);              /* restore this pointer */\
       bctr;                            /* branch to counter */\
realvt: li     r12,(n*4+4);             /* offset into c++ vtable */\
       lwzx    r12,r11,r12;              /* get vtable entry */\
       b       Non;                     \
}

/*
Checking for type of vtable works as follows
long               0      2
_______________________________
tearoff virtual    0      0
tearoff non virt   -1     non 0
c++ vtable         0      non 0
*/

#define THUNK_IMPLEMENT_SIMPLE(n)\
asm void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n() \
{                                                \
       li      r12, n;         /* Put the method # in r12 */    \
       stw     r12, 32(r3);    /* save method # in thunk */ \
       stw     r3,-4(SP);                /* save this pointer on stack */ \
       lwz     r11, offsetof_apfn(r3);      /* Copy this->apfn to r11 */\
       lwz     r3,offsetof_pvObject(r3);                    /* set r3 to object pointer */\
       lwz     r0,0(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,tear;                /* bne - tearoff non virtual */\
       lwz     r0,8(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,realvt;                /* bne - c++ vtable */\
tear:  li      r12, (n*12);             /* Put the method # * 12 in r12 */\
       add     r12,r12,r11  ;                   /* r12 points to correct tearoff vtbl entry */\
       lwz     r11,4(r12);                  /* get vtbl offset / flag */\
       lwz     r12,8(r12);                  /* get address in non virtual */\
       cmpi    crf0,0,r11,0;                    /* check if virtual */\
       bc      12, 0, Non;                      /* branch if not virtual */\
       lwz     r12,0(r3);               \
       lwzx    r12,r12,r11;                 /* get function vector address */\
Non:   lwz     r0,0(r12);                   /* get function address */\
       mtctr   r0;  \
       lwz     r2,4(r12);                   /* load new toc */ \
       lwz     r11,-4(SP);              /* restore this pointer */\
       bctr;                                /* branch to counter */\
realvt: li     r12,(n*4+4);             /* offset into c++ vtable */\
       lwzx    r12,r11,r12;              /* get vtable entry */\
       b       Non;                     \
}

#pragma require_prototypes off

THUNK_ARRAY_3_TO_15(IMPLEMENT_COMPARE);
THUNK_ARRAY_16_TO_101(IMPLEMENT_SIMPLE);
THUNK_ARRAY_102_TO_145(IMPLEMENT_SIMPLE);
THUNK_ARRAY_146_AND_UP(IMPLEMENT_SIMPLE);

#pragma require_prototypes reset
asm TEAROFF_THUNK* GetThunk()
{
    addi    r3,r11,0        // return the saved thunk pointer
    blr
}


#endif

#ifdef WIN16
void TearoffCheck()
#else
void STDMETHODCALLTYPE TearoffCheck()
#endif
{
    AssertSz( 0, "Tearoff table too small" );
}

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv)
{
    void *pv;
    const void *apfnVtbl;
    IID const * const * ppIID;

    for (ppIID = pthunk->apIID; *ppIID; ppIID++)
    {
        if (**ppIID == iid)
        {
            *ppv = pthunk;
            pthunk->ulRef += 1;
            return S_OK;
        }
    }

    if (pthunk->dwMask & 1)
    {
        pv = pthunk->pvObject2;
        apfnVtbl = pthunk->apfnVtblObject2;
    }
    else
    {
        pv = pthunk->pvObject1;
        apfnVtbl = pthunk->apfnVtblObject1;
    }

#ifdef _MAC
	typedef HRESULT ( IUnknown::*const tFunc)(REFIID iid, void **ppv) ;
	

	if(((long*)apfnVtbl)[0] || (((long*)apfnVtbl)[2] == 0))
	{
		tFunc	qi = ((tFunc*)apfnVtbl)[0];
		
	    return (((IUnknown*)pv)->*qi)(iid, ppv);
	}
	else
    	return ((FNQI *)((void **)apfnVtbl)[1])(pv, iid, ppv);
	
#else
    return ((FNQI *)((void **)apfnVtbl)[0])(pv, iid, ppv);
#endif // _MAC
}


ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk)
{
    if (pthunk->dwMask & CACHEDTEAROFF_MASK)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & 2) == 0)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject1)[1])(pthunk->pvObject1);
        }
        if (pthunk->pvObject2)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject2)[1])(pthunk->pvObject2);
        }
    }
    return ++pthunk->ulRef;
}

static void * s_pvCache1 = NULL;
static void * s_pvCache2 = NULL;

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk)
{
    WHEN_DBG(static long l = 0; l++;)

    Assert( pthunk->ulRef > 0 );

    if (--pthunk->ulRef == 0)
    {
#ifdef _MAC    
	    void *pv;
        const void *apfnVtbl;
    
	    if (pthunk->dwMask & 4)
	    {
	        pv = pthunk->pvObject2;
     	    apfnVtbl = pthunk->apfnVtblObject2;
	    }
	    else
	    {
	        pv = pthunk->pvObject1;
  	        apfnVtbl = pthunk->apfnVtblObject1;
	    }

		typedef unsigned long ( IUnknown::*const tFunc)(void) ;
		
		// if no null entry, vtable is tearoff
		if(((long*)apfnVtbl)[0] || (((long*)apfnVtbl)[2] == 0))
		{
			tFunc	rel = ((tFunc*)apfnVtbl)[2];
			
	    	return (((IUnknown*)pv)->*rel)();
		}
		else	// must be c++ vtable
            ((FNAR *)((void **)apfnVtbl)[3])(pv);
	    	
#else
        if (!(pthunk->dwMask & CACHEDTEAROFF_MASK))
        {
            if (pthunk->pvObject1 && (pthunk->dwMask & 4) == 0)
            {
                ((FNAR *)((void **)pthunk->apfnVtblObject1)[2])(pthunk->pvObject1);
            }
            if (pthunk->pvObject2)
            {
                ((FNAR *)((void **)pthunk->apfnVtblObject2)[2])(pthunk->pvObject2);
            }
        }
#endif

#if DBG==1
        if (IsTagEnabled(tagNoTearoffCache) || IsTagEnabled(tagTearoffSymbols))
        {
            MemFree(pthunk);
            return(0);
        }
        else
        {
            if (IsTagEnabled(tagZapTearoffs))
            {
                memset(pthunk, 0xFE, sizeof(TEAROFF_THUNK));
            }

            if (IsTagEnabled(tagLeakTearoffs))
            {
                return(0);
            }
        }
#endif

#ifdef SLOWALLOC
        MemFree(pthunk);
        return (0);
#else

        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, pthunk );

        if (pthunk)
        {
            pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, pthunk );

            if (pthunk)
            {
                MemFree( pthunk );
            }
        }

        return 0;
#endif
    }
    else if (pthunk->dwMask & CACHEDTEAROFF_MASK)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & 4) == 0)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject1)[2])(pthunk->pvObject1);
        }
        if (pthunk->pvObject2)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject2)[2])(pthunk->pvObject2);
        }
    }

    return pthunk->ulRef;
}

typedef void (STDMETHODCALLTYPE *PFNVOID)();

#if defined(_M_IX86)
#define THUNK_EXTERN(n) extern void STDMETHODCALLTYPE TearoffThunk##n();
#else
#define THUNK_EXTERN(n) EXTERN_C void TearoffThunk##n();
#endif

THUNK_ARRAY_3_TO_15(EXTERN)
#ifdef _MAC
THUNK_ARRAY_16_TO_101(EXTERN)
THUNK_ARRAY_102_TO_145(EXTERN)
THUNK_ARRAY_146_AND_UP(EXTERN)
#else
THUNK_ARRAY_16_AND_UP(EXTERN)
#endif // _MAC

#define THUNK_ADDRESS(n) & TearoffThunk##n,

static void (STDMETHODCALLTYPE *s_apfnPlainTearoffVtable[])() =
{
#ifdef _MAC
    PFNVOID( NULL ),
#endif
    PFNVOID( & PlainQueryInterface ),
    PFNVOID( & PlainAddRef ),
    PFNVOID( & PlainRelease ),
    THUNK_ARRAY_3_TO_15(ADDRESS)
#ifdef _MAC
    THUNK_ARRAY_16_TO_101(ADDRESS)
    THUNK_ARRAY_102_TO_145(ADDRESS)
    THUNK_ARRAY_146_AND_UP(ADDRESS)
#else
    THUNK_ARRAY_16_AND_UP(ADDRESS)
#endif
#if DBG==1
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck
#endif
};

void DeinitTearOffCache()
{
    MemFree(s_pvCache1);
    MemFree(s_pvCache2);
}


//+------------------------------------------------------------------------
//
//  Function:   CreateTearOffThunk
//
//  Synopsis:   Create a tearoff interface thunk. The returned object
//              must be AddRef'ed by the caller.
//
//  Arguments:  pvObject    Delegate to this object using...
//              apfnObject    ...this array of pointers to member functions.
//              pUnkOuter   Delegate IUnknown methods to this object.
//              ppvThunk    The returned thunk.
//              pvObject2   Delegate to this object instead...
//              apfnObject2   ... this array of pointers to functions...
//              dwMask        ... when the index of the method call is
//                            marked in this mask.
//
//  Notes:      The basic implementation here consists of a thunk with
//              a pointer to two different objects.  If the second object
//              is NULL, it is assumed to be the first object.  This
//              is the logic of the thunks:
//
//                  i is the index of the method that is called.
//
//                  if (i < 16)
//                  {
//                      if (dwMask & 2^i)
//                      {
//                          Delegate to pvObject2 using apfnObject2
//                      }
//                  }
//                  Delegate to pvObject1 using apfnObject1
//
//-------------------------------------------------------------------------

#ifdef DEBUG_TEAROFFS
BOOL g_fDoneTearoffCompression = FALSE;
DEBUG_TEAROFF_NOTE *g_pnoteFirst = NULL;
#endif

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      pvObject2,
        void *      apfn2,
        DWORD       dwMask,
        const IID * const * apIID,
        void *      appropdescsInVtblOrder)
{
    TEAROFF_THUNK * pthunk;

    Assert(ppvThunk);
    Assert(apfn1);
    Assert((!pvObject2 && !apfn2) || (pvObject2 && apfn2));
    Assert(!(dwMask & 0xFFFE0000) && "Only 16 overrides and CACHEDTEAROFF_MASK allowed");
    Assert(!dwMask || (dwMask && pvObject2));
    Assert(!pUnkOuter || (dwMask == 0 && pvObject2 == 0));
    Assert((dwMask & (2|4)) == 0 || (dwMask & (2|4)) == (2|4));

#ifdef DEBUG_TEAROFFS
    Assert(g_fDoneTearoffCompression);
    Assert(((DWORD**)apfn1)[1] && "Tearoff compression not yet done!");
    Assert(!apfn2 || ((DWORD**)apfn2)[1] && "Tearoff compression not yet done!");
#endif

    if (pUnkOuter)
    {
        pvObject2 = pUnkOuter;
        apfn2 = *(void **)pUnkOuter;
        dwMask = 1;
    }

    pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, NULL);

    if (!pthunk)
    {
        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, NULL);

        if (!pthunk)
        {
#if DBG==1
            #define LEAKS_TRACE_TAG "Leaks: Stacktraces & symbols"
            AssertSz(DbgExFindTag(LEAKS_TRACE_TAG), "Please update the LEAKS_TRACE_TAG definition"); 
            BOOL fEnabled = FALSE;
            if (IsTagEnabled(tagTearoffSymbols))
            {
                fEnabled = DbgExEnableTag(DbgExFindTag(LEAKS_TRACE_TAG), TRUE);
            }
#endif

            pthunk = (TEAROFF_THUNK *) MemAlloc(Mt(TearOff), sizeof(TEAROFF_THUNK));

            MemSetName((pthunk, "Tear-Off Thunk - owner=%08x", pvObject1));

#if DBG==1
            if (IsTagEnabled(tagTearoffSymbols))
            {
                DbgExEnableTag(DbgExFindTag(LEAKS_TRACE_TAG), fEnabled);
            }
#endif

        }
    }

    if (!pthunk)
    {
        *ppvThunk = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    pthunk->papfnVtblThis = s_apfnPlainTearoffVtable;
    pthunk->ulRef = 0;
    pthunk->pvObject1 = pvObject1;
    pthunk->apfnVtblObject1 = apfn1;
    pthunk->pvObject2 = pvObject2;
    pthunk->apfnVtblObject2 = apfn2;
    pthunk->dwMask = dwMask;
    pthunk->apIID = apIID ? apIID : (const IID * const *)&g_Zero;
    pthunk->apVtblPropDesc = appropdescsInVtblOrder;

#ifdef _MAC
	((IUnknown*)pthunk)->AddRef();
#else
    if (dwMask & CACHEDTEAROFF_MASK)
    {
        pthunk->ulRef++;
    }
    else
    {
        if (pvObject1 && (dwMask & 2) == 0)
        {
            Assert(((void**)apfn1)[1]);

            ((FNAR *)((void**)apfn1)[1])(pvObject1);
        }
        if (pvObject2)
        {
            Assert(((void**)apfn2)[1]);

            ((FNAR *)((void**)apfn2)[1])(pvObject2);
        }
    }
#endif // _MAC
    *ppvThunk = pthunk;

    return S_OK;
}

// Short argument list version saves space in calling functions.

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      appropdescsInVtblOrder)
{
    return CreateTearOffThunk(
            pvObject1, 
            apfn1, 
            pUnkOuter, 
            ppvThunk, 
            NULL, 
            NULL, 
            0, 
            NULL,
            appropdescsInVtblOrder);
}

HRESULT
InstallTearOffObject(void * pvthunk, void * pvObject, void *apfn, DWORD dwMask)
{
    TEAROFF_THUNK *pthunk = (TEAROFF_THUNK*)pvthunk;

    Assert(pthunk);
    Assert(!pthunk->pvObject2);
    Assert(!pthunk->apfnVtblObject2);
    Assert(!pthunk->dwMask);

    pthunk->pvObject2 = pvObject;
    pthunk->apfnVtblObject2 = apfn;
    pthunk->dwMask = dwMask;

    if (pvObject)
    {
        ((FNAR *)((void**)apfn)[1])(pvObject);
    }

    return S_OK;
}


#ifdef DEBUG_TEAROFFS

//+------------------------------------------------------------------------
//
// DEBUG_TEAROFFs check for multiple inheritance problems with tearoffs.
//
// With multiple inheritance with MSVC on Win32/X86 the calling
// convention for a virtual function in vtable X is to adjust the
// "this" pointer to point to offset in the object containing the
// pointer to vtable X before doing the call. Since the offset is
// needed to make the call correctly, a pointer to a method of a
// class with virtual methods and multiple inheritance is stored
// as two DWORDs: the first is the function pointer for the method,
// and the second is the offset to apply to the "this" pointer.
//
// Tearoffs tables are a table of ordinary function pointers to
// methods. The function pointers are obtained from full method
// pointers using a cast that truncates a possible 8-byte value
// to its first 4 bytes.
//
// Since any information about the "this" offset is lost when casting
// a method pointer down to a single-DWORD function pointer, tearoffs
// assume that the adjustment to "this" is zero. This means that
// tearoffs cannot refer to virtual methods which appear in multiple-
// inheritance vtables; only nonvirtual methods and methods in the
// primary vtable work.
//
// The DEBUG_TEAROFFS code verifies that multiple-inheritance problems
// do not occur by construcing actual 8-byte method pointers for every
// tearoff method and asserting that the second DWORD (the "this"
// offset) is zero.  While the check is being done, the table is
// compressed down to a table of 4-byte function pointers as required
// by the rest of the tearoff code.
//
//-------------------------------------------------------------------------


// Note: The check must be deferred until ProcessAttach time because at
// VC Runtime init time, method pointers are not initialized yet and
// cannot be read.

int DeferDebugCheckTearoffTable(DEBUG_TEAROFF_NOTE *pnote, void *apfn, char *string)
{
    pnote->pnoteNext = g_pnoteFirst;
    g_pnoteFirst = pnote;
    pnote->apfn = apfn;
    pnote->pchDebug = string;

    return 1;
}

void DebugCheckAllTearoffTables()
{
    Assert(!g_fDoneTearoffCompression);

    DEBUG_TEAROFF_NOTE *pnote;

    DEBUG_TEAROFF_METHOD<CVoid> *pfnFrom;
    DWORD *pfnTo;
    
    for (pnote=g_pnoteFirst; pnote; pnote=pnote->pnoteNext)
    {
        pfnFrom = (DEBUG_TEAROFF_METHOD<CVoid>*)(pnote->apfn);
        pfnTo = (DWORD*)pnote->apfn;

        while (pfnFrom->d.fn)
        {
            AssertSz(!pfnFrom->d.off, pnote->pchDebug);
            *pfnTo = pfnFrom->d.fn;
            pfnFrom++;
            pfnTo++;
        }
    }
    
    g_fDoneTearoffCompression = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\themehlp.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       Themehlp.cxx
//
//  Contents:   Theme helper
//
//  Classes:    CThemeHelper
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_UXTHEME_H
#undef _UXTHEME_
#define _UXTHEME_
#define X_UXTHEME_H
#include "uxtheme.h"
#endif

#ifndef X_CDUTIL_HXX
#define X_CDUTIL_HXX
#include "cdutil.hxx"
#endif

#ifndef X_THEMEHLP_HXX
#define X_THEMEHLP_HXX
#include "themehlp.hxx"
#endif

DeclareTag(tagTheme, "Theme", "Theme helper methods");

#define ARRAYSIZE(a) ( sizeof(a) / sizeof(a[0]) )

HANDLE      g_hActCtx = INVALID_HANDLE_VALUE;
HINSTANCE   g_hinstCC = NULL;
extern BOOL g_fThemedPlatform;
struct THEMEINFO
{
    TCHAR * pchName;
    BOOL    fInit;
    HTHEME  hTheme;
};

static THEMEINFO g_aryThemeInfo[] =
{
    {_T("button"),              FALSE, NULL},
    {_T("edit"),                FALSE, NULL},
    {_T("scrollbar"),           FALSE, NULL},
    {_T("combobox"),            FALSE, NULL},
};

// The following functions are ported from shfusion.lib
// They help us load comctl32 version 6 so we theme
// things correctly.


//+------------------------------------------------------------------------
//
//  Function:   SHActivateContext
//
//  Synopsis:   Shell helper function: activates fusion context
//
//-------------------------------------------------------------------------

BOOL SHActivateContext(ULONG_PTR * pdwCookie)
{
    if (g_hActCtx != INVALID_HANDLE_VALUE)
        return ActivateActCtx(g_hActCtx, pdwCookie);

    return TRUE;        // Default to success in activation for down level.
}

//+------------------------------------------------------------------------
//
//  Function:   SHDeactivateContext
//
//  Synopsis:   Shell helper function: deactivates fusion context
//
//-------------------------------------------------------------------------

void SHDeactivateContext(ULONG_PTR dwCookie)
{
    if (dwCookie != 0)
        DeactivateActCtx(0, dwCookie);
}

//+------------------------------------------------------------------------
//
//  Function:   SHFusionLoadLibrary
//
//  Synopsis:   Shell helper function: loads the appropriate version of a 
//              the library as determined by g_hActCtx
//
//-------------------------------------------------------------------------

HMODULE SHFusionLoadLibrary(LPCTSTR lpLibFileName)
{
    HMODULE hmod = NULL;
    ENTERCONTEXT(NULL)
    hmod = LoadLibrary(lpLibFileName);
    LEAVECONTEXT

    return hmod;
}

//+------------------------------------------------------------------------
//
//  Function:   DelayLoadCC
//
//  Synopsis:   Shell helper function: Loads appropriate common controls
//
//-------------------------------------------------------------------------

BOOL DelayLoadCC()
{
    if (g_hinstCC == NULL)
    {
        g_hinstCC = SHFusionLoadLibrary(TEXT("comctl32.dll"));

        if (g_hinstCC == NULL)
        {
            SHFusionUninitialize();     // Unable to get v6, don't try to use a manifest
            g_hinstCC = LoadLibrary(TEXT("comctl32.dll"));
        }
    }
    return g_hinstCC != NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   SHFusionInitialize
//
//  Synopsis:   Shell helper function: activates fusioned common controls
//              if they're available
//
//-------------------------------------------------------------------------

BOOL SHFusionInitialize()
{
    
    if (g_hActCtx == INVALID_HANDLE_VALUE)
    {
        TCHAR szPath[MAX_PATH];

        if ( !Wrap_GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath)) )
        {
            return FALSE;
        }

        //GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath));
        //GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
        //ensure there is enough space in the buffer 
        if (int(ARRAYSIZE(szPath))-lstrlen(szPath) <= lstrlen(TEXT("\\WindowsShell.manifest")))
        {
        	return FALSE;
        } 
        StrCat(szPath, TEXT("\\WindowsShell.manifest"));

        ACTCTX act;
        act.cbSize = sizeof(act);
        act.dwFlags = 0;
        act.lpSource = szPath;

        g_hActCtx = CreateActCtx(&act);
    }


#ifndef NOCOMCTL32
    DelayLoadCC();
#endif

    return g_hActCtx != INVALID_HANDLE_VALUE;
    
    //return FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   SHFusionUninitialize
//
//  Synopsis:   Shell helper function: releases the context created for use 
//              with fusioned common controls
//
//-------------------------------------------------------------------------

void SHFusionUninitialize()
{
    if (g_hActCtx != INVALID_HANDLE_VALUE)
    {
        ReleaseActCtx(g_hActCtx);
        g_hActCtx = INVALID_HANDLE_VALUE;
    }
}



//+------------------------------------------------------------------------
//
//  Function:   GetThemeHandle
//
//  Synopsis:   Get Theme handle using its class id
//              If the Theme is not in cach, create the theme
//
//-------------------------------------------------------------------------

HTHEME
GetThemeHandle(HWND hwnd, THEMECLASSID id)
{
    DWORD  dwFlags = 0;

    if (id < THEME_FIRST || id > THEME_LAST)
        return NULL;

    if (g_aryThemeInfo[id].fInit)
        return g_aryThemeInfo[id].hTheme;
    
    if (id != THEME_SCROLLBAR)
        dwFlags |= OTD_FORCE_RECT_SIZING;

    g_aryThemeInfo[id].hTheme = OpenThemeDataEx(hwnd, g_aryThemeInfo[id].pchName, dwFlags);
    g_aryThemeInfo[id].fInit = TRUE;

    return g_aryThemeInfo[id].hTheme;
}

//+---------------------------------------------------------------
//
//  Member:     DeinitTheme
//
//  Synopsis:   Deinit Theme.
//
//---------------------------------------------------------------

void
DeinitTheme()
{
    int i;

    if (g_fThemedPlatform)
        SHFusionUninitialize();

    for (i = THEME_FIRST; i <= THEME_LAST; i++)
    {
        if (g_aryThemeInfo[i].hTheme)
        {
            IGNORE_HR(CloseThemeData(g_aryThemeInfo[i].hTheme));                   
        }
        g_aryThemeInfo[i].hTheme = NULL;
        g_aryThemeInfo[i].fInit = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\tearunix.cxx ===
//+------------------------------------------------------------------------
//
//  File:       utearoff.cxx
//
//  Contents:   Tear off interfaces.
//
//  History:
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

typedef HRESULT (FNQI)(void *pv, REFIID iid, void **ppv);
typedef ULONG   (FNAR)(void *pv);

void TearoffCheck()
{
    AssertSz( 0, "Tearoff table too small" );
}

typedef HRESULT (STDMETHODCALLTYPE *PFNQI)(TEAROFF_THIS, REFIID, void **);

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv);

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk);

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk);

typedef void (*PFNVOID)();

#define THUNK_EXTERN(n) EXTERN_C void TearoffThunk##n(TEAROFF_THIS, ...);

THUNK_EXTERN(0) // QI
THUNK_EXTERN(1) // ADDREF
THUNK_EXTERN(2) // RELEASE

THUNK_ARRAY_3_TO_15(EXTERN)
THUNK_ARRAY_16_AND_UP(EXTERN)

#define TEAROFFCHECK_THUNK NONVIRTUAL_METHOD(TearoffCheck, (TEAROFF_THIS))
#define THUNK_ADDRESS(n) NONVIRTUAL_METHOD(TearoffThunk##n, (TEAROFF_THIS))

NONVIRTUAL_VTABLE_ENTRY s_unixTearOffVtable[] = {
    NULL_METHOD,
    THUNK_ADDRESS(0)
    NONVIRTUAL_METHOD(PlainAddRef, (TEAROFF_THIS))
    NONVIRTUAL_METHOD(PlainRelease, (TEAROFF_THIS))
    THUNK_ARRAY_3_TO_15(ADDRESS)
    THUNK_ARRAY_16_AND_UP(ADDRESS)
#if DBG==1
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK
#endif
};

static void * s_pvCache1 = NULL;
static void * s_pvCache2 = NULL;

void DeinitTearOffCache()
{
    MemFree(s_pvCache1);
    MemFree(s_pvCache2);
}

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk)
{
    return ++pthunk->ulRef;
}

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk)
{
    WHEN_DBG(static long l = 0; l++;)

    Assert( pthunk->ulRef > 0 );

    if (--pthunk->ulRef == 0)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & METHOD_MASK( METHOD_RELEASE )) == 0)
        {
            CALL_VTBL_METHOD( pthunk->pvObject1, pthunk->apfnVtblObject1, 2 /*METHOD_RELEASE*/, (CALL_METHOD_THIS));
        }
        if (pthunk->pvObject2)
        {
            CALL_VTBL_METHOD( pthunk->pvObject2, pthunk->apfnVtblObject2, 2 /*METHOD_RELEASE*/, (CALL_METHOD_THIS));
        }

        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, pthunk );

        if (pthunk)
        {
            pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, pthunk );

            if (pthunk)
            {
                MemFree( pthunk );
            }
        }

        return 0;
    }

    return pthunk->ulRef;
}


//+------------------------------------------------------------------------
//
//  Function:   CreateTearOffTunk
//
//  Synopsis:   Create a tearoff interface thunk. The returned object
//              must be AddRef'ed by the caller.
//
//  Arguments:  pvObject    Delegate to this object using...
//              apfnObject    ...this array of pointers to member functions.
//              pUnkOuter   Delegate IUnknown methods to this object.
//              ppvThunk    The returned thunk.
//              pvObject2   Delegate to this object instead...
//              apfnObject2   ... this array of pointers to functions...
//              dwMask        ... when the index of the method call is
//                            marked in this mask.
//
//  Notes:      The basic implementation here consists of a thunk with
//              a pointer to two different objects.  If the second object
//              is NULL, it is assumed to be the first object.  This
//              is the logic of the thunks:
//
//                  i is the index of the method that is called.
//
//                  if (i < 16)
//                  {
//                      if (dwMask & 2^i)
//                      {
//                          Delegate to pvObject2 using apfnObject2
//                      }
//                  }
//                  Delegate to pvObject1 using apfnObject1
//
//-------------------------------------------------------------------------

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void *apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      pvObject2,
        void *      apfn2,
        DWORD       dwMask,
        const IID * const * apIID)
{
#   define ADD_REL_MASK (METHOD_MASK( METHOD_ADDREF ) || METHOD_MASK( METHOD_RELEASE ))

    TEAROFF_THUNK * pthunk;

    Assert(ppvThunk);
    Assert(apfn1);
    Assert((!pvObject2 && !apfn2) || (pvObject2 && apfn2));
    Assert(!(dwMask & 0xFFFF0000) && "Only 16 overrides allowed");
    Assert(!dwMask || (dwMask && pvObject2));
    Assert(!pUnkOuter || (dwMask == 0 && pvObject2 == 0));
    Assert((dwMask & ADD_REL_MASK) == 0 || ((dwMask & ADD_REL_MASK) == ADD_REL_MASK));

    if (pUnkOuter)
    {
        pvObject2 = pUnkOuter;
        apfn2 = *(void **)pUnkOuter;
        dwMask = METHOD_MASK( METHOD_QI );
    }

    pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, NULL);

    if (!pthunk)
    {
        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, NULL);

        if (!pthunk)
        {
            pthunk = (TEAROFF_THUNK *) MemAlloc(sizeof(TEAROFF_THUNK));

            MemSetName((pthunk, "Tear-Off Thunk - owner=%08x", pvObject1));
        }
    }

    if (!pthunk)
    {
        *ppvThunk = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    pthunk->papfnVtblThis = s_unixTearOffVtable;
    pthunk->ulRef = 0;
    pthunk->pvObject1 = pvObject1;
    pthunk->apfnVtblObject1 = apfn1;
    pthunk->pvObject2 = pvObject2;
    pthunk->apfnVtblObject2 = apfn2;
    pthunk->dwMask = dwMask;
    pthunk->apIID = apIID ? apIID : (const IID * const *)&g_Zero;

    if (pvObject1 && (dwMask & METHOD_MASK( METHOD_ADDREF )) == 0)
    {
        CALL_VTBL_METHOD( pthunk->pvObject1, pthunk->apfnVtblObject1, 1 /*METHOD_ADDREF*/, (CALL_METHOD_THIS));
    }
    if (pvObject2)
    {
        CALL_VTBL_METHOD( pthunk->pvObject2, pthunk->apfnVtblObject2, 1 /*METHOD_ADDREF*/, (CALL_METHOD_THIS));
    }
    *ppvThunk = pthunk;

    return S_OK;
}

// Short argument list version saves space in calling functions.

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk)
{
    return CreateTearOffThunk(
            pvObject1, 
            apfn1, 
            pUnkOuter, 
            ppvThunk, 
            NULL, 
            NULL, 
            0, 
            NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\thunks_c.h ===
// THUNK_C_<line number> ( <n> ), where linenum is 1-30 and n is 3-15

THUNK_GT_1
THUNK_GT_2
THUNK_GT_3
THUNK_GT_4
THUNK_GT_5
THUNK_GT_6
THUNK_GT_7
THUNK_GT_8
THUNK_GT_9

THUNK_C_1(3)
THUNK_C_2(3)
THUNK_C_3(3)
THUNK_C_4(3)
THUNK_C_5(3)
THUNK_C_6(3)
THUNK_C_7(3)
THUNK_C_8(3)
THUNK_C_9(3)
THUNK_C_10(3)
THUNK_C_11(3)
THUNK_C_12(3)
THUNK_C_13(3)
THUNK_C_14(3)
THUNK_C_15(3)
THUNK_C_16(3)
THUNK_C_17(3)
THUNK_C_18(3)
THUNK_C_19(3)
THUNK_C_20(3)
THUNK_C_21(3)
THUNK_C_22(3)
THUNK_C_23(3)
THUNK_C_24(3)
THUNK_C_25(3)
THUNK_C_26(3)
THUNK_C_27(3)
THUNK_C_28(3)
THUNK_C_29(3)
THUNK_C_30(3)
THUNK_C_1(4)
THUNK_C_2(4)
THUNK_C_3(4)
THUNK_C_4(4)
THUNK_C_5(4)
THUNK_C_6(4)
THUNK_C_7(4)
THUNK_C_8(4)
THUNK_C_9(4)
THUNK_C_10(4)
THUNK_C_11(4)
THUNK_C_12(4)
THUNK_C_13(4)
THUNK_C_14(4)
THUNK_C_15(4)
THUNK_C_16(4)
THUNK_C_17(4)
THUNK_C_18(4)
THUNK_C_19(4)
THUNK_C_20(4)
THUNK_C_21(4)
THUNK_C_22(4)
THUNK_C_23(4)
THUNK_C_24(4)
THUNK_C_25(4)
THUNK_C_26(4)
THUNK_C_27(4)
THUNK_C_28(4)
THUNK_C_29(4)
THUNK_C_30(4)
THUNK_C_1(5)
THUNK_C_2(5)
THUNK_C_3(5)
THUNK_C_4(5)
THUNK_C_5(5)
THUNK_C_6(5)
THUNK_C_7(5)
THUNK_C_8(5)
THUNK_C_9(5)
THUNK_C_10(5)
THUNK_C_11(5)
THUNK_C_12(5)
THUNK_C_13(5)
THUNK_C_14(5)
THUNK_C_15(5)
THUNK_C_16(5)
THUNK_C_17(5)
THUNK_C_18(5)
THUNK_C_19(5)
THUNK_C_20(5)
THUNK_C_21(5)
THUNK_C_22(5)
THUNK_C_23(5)
THUNK_C_24(5)
THUNK_C_25(5)
THUNK_C_26(5)
THUNK_C_27(5)
THUNK_C_28(5)
THUNK_C_29(5)
THUNK_C_30(5)
THUNK_C_1(6)
THUNK_C_2(6)
THUNK_C_3(6)
THUNK_C_4(6)
THUNK_C_5(6)
THUNK_C_6(6)
THUNK_C_7(6)
THUNK_C_8(6)
THUNK_C_9(6)
THUNK_C_10(6)
THUNK_C_11(6)
THUNK_C_12(6)
THUNK_C_13(6)
THUNK_C_14(6)
THUNK_C_15(6)
THUNK_C_16(6)
THUNK_C_17(6)
THUNK_C_18(6)
THUNK_C_19(6)
THUNK_C_20(6)
THUNK_C_21(6)
THUNK_C_22(6)
THUNK_C_23(6)
THUNK_C_24(6)
THUNK_C_25(6)
THUNK_C_26(6)
THUNK_C_27(6)
THUNK_C_28(6)
THUNK_C_29(6)
THUNK_C_30(6)
THUNK_C_1(7)
THUNK_C_2(7)
THUNK_C_3(7)
THUNK_C_4(7)
THUNK_C_5(7)
THUNK_C_6(7)
THUNK_C_7(7)
THUNK_C_8(7)
THUNK_C_9(7)
THUNK_C_10(7)
THUNK_C_11(7)
THUNK_C_12(7)
THUNK_C_13(7)
THUNK_C_14(7)
THUNK_C_15(7)
THUNK_C_16(7)
THUNK_C_17(7)
THUNK_C_18(7)
THUNK_C_19(7)
THUNK_C_20(7)
THUNK_C_21(7)
THUNK_C_22(7)
THUNK_C_23(7)
THUNK_C_24(7)
THUNK_C_25(7)
THUNK_C_26(7)
THUNK_C_27(7)
THUNK_C_28(7)
THUNK_C_29(7)
THUNK_C_30(7)
THUNK_C_1(8)
THUNK_C_2(8)
THUNK_C_3(8)
THUNK_C_4(8)
THUNK_C_5(8)
THUNK_C_6(8)
THUNK_C_7(8)
THUNK_C_8(8)
THUNK_C_9(8)
THUNK_C_10(8)
THUNK_C_11(8)
THUNK_C_12(8)
THUNK_C_13(8)
THUNK_C_14(8)
THUNK_C_15(8)
THUNK_C_16(8)
THUNK_C_17(8)
THUNK_C_18(8)
THUNK_C_19(8)
THUNK_C_20(8)
THUNK_C_21(8)
THUNK_C_22(8)
THUNK_C_23(8)
THUNK_C_24(8)
THUNK_C_25(8)
THUNK_C_26(8)
THUNK_C_27(8)
THUNK_C_28(8)
THUNK_C_29(8)
THUNK_C_30(8)
THUNK_C_1(9)
THUNK_C_2(9)
THUNK_C_3(9)
THUNK_C_4(9)
THUNK_C_5(9)
THUNK_C_6(9)
THUNK_C_7(9)
THUNK_C_8(9)
THUNK_C_9(9)
THUNK_C_10(9)
THUNK_C_11(9)
THUNK_C_12(9)
THUNK_C_13(9)
THUNK_C_14(9)
THUNK_C_15(9)
THUNK_C_16(9)
THUNK_C_17(9)
THUNK_C_18(9)
THUNK_C_19(9)
THUNK_C_20(9)
THUNK_C_21(9)
THUNK_C_22(9)
THUNK_C_23(9)
THUNK_C_24(9)
THUNK_C_25(9)
THUNK_C_26(9)
THUNK_C_27(9)
THUNK_C_28(9)
THUNK_C_29(9)
THUNK_C_30(9)
THUNK_C_1(10)
THUNK_C_2(10)
THUNK_C_3(10)
THUNK_C_4(10)
THUNK_C_5(10)
THUNK_C_6(10)
THUNK_C_7(10)
THUNK_C_8(10)
THUNK_C_9(10)
THUNK_C_10(10)
THUNK_C_11(10)
THUNK_C_12(10)
THUNK_C_13(10)
THUNK_C_14(10)
THUNK_C_15(10)
THUNK_C_16(10)
THUNK_C_17(10)
THUNK_C_18(10)
THUNK_C_19(10)
THUNK_C_20(10)
THUNK_C_21(10)
THUNK_C_22(10)
THUNK_C_23(10)
THUNK_C_24(10)
THUNK_C_25(10)
THUNK_C_26(10)
THUNK_C_27(10)
THUNK_C_28(10)
THUNK_C_29(10)
THUNK_C_30(10)
THUNK_C_1(11)
THUNK_C_2(11)
THUNK_C_3(11)
THUNK_C_4(11)
THUNK_C_5(11)
THUNK_C_6(11)
THUNK_C_7(11)
THUNK_C_8(11)
THUNK_C_9(11)
THUNK_C_10(11)
THUNK_C_11(11)
THUNK_C_12(11)
THUNK_C_13(11)
THUNK_C_14(11)
THUNK_C_15(11)
THUNK_C_16(11)
THUNK_C_17(11)
THUNK_C_18(11)
THUNK_C_19(11)
THUNK_C_20(11)
THUNK_C_21(11)
THUNK_C_22(11)
THUNK_C_23(11)
THUNK_C_24(11)
THUNK_C_25(11)
THUNK_C_26(11)
THUNK_C_27(11)
THUNK_C_28(11)
THUNK_C_29(11)
THUNK_C_30(11)
THUNK_C_1(12)
THUNK_C_2(12)
THUNK_C_3(12)
THUNK_C_4(12)
THUNK_C_5(12)
THUNK_C_6(12)
THUNK_C_7(12)
THUNK_C_8(12)
THUNK_C_9(12)
THUNK_C_10(12)
THUNK_C_11(12)
THUNK_C_12(12)
THUNK_C_13(12)
THUNK_C_14(12)
THUNK_C_15(12)
THUNK_C_16(12)
THUNK_C_17(12)
THUNK_C_18(12)
THUNK_C_19(12)
THUNK_C_20(12)
THUNK_C_21(12)
THUNK_C_22(12)
THUNK_C_23(12)
THUNK_C_24(12)
THUNK_C_25(12)
THUNK_C_26(12)
THUNK_C_27(12)
THUNK_C_28(12)
THUNK_C_29(12)
THUNK_C_30(12)
THUNK_C_1(13)
THUNK_C_2(13)
THUNK_C_3(13)
THUNK_C_4(13)
THUNK_C_5(13)
THUNK_C_6(13)
THUNK_C_7(13)
THUNK_C_8(13)
THUNK_C_9(13)
THUNK_C_10(13)
THUNK_C_11(13)
THUNK_C_12(13)
THUNK_C_13(13)
THUNK_C_14(13)
THUNK_C_15(13)
THUNK_C_16(13)
THUNK_C_17(13)
THUNK_C_18(13)
THUNK_C_19(13)
THUNK_C_20(13)
THUNK_C_21(13)
THUNK_C_22(13)
THUNK_C_23(13)
THUNK_C_24(13)
THUNK_C_25(13)
THUNK_C_26(13)
THUNK_C_27(13)
THUNK_C_28(13)
THUNK_C_29(13)
THUNK_C_30(13)
THUNK_C_1(14)
THUNK_C_2(14)
THUNK_C_3(14)
THUNK_C_4(14)
THUNK_C_5(14)
THUNK_C_6(14)
THUNK_C_7(14)
THUNK_C_8(14)
THUNK_C_9(14)
THUNK_C_10(14)
THUNK_C_11(14)
THUNK_C_12(14)
THUNK_C_13(14)
THUNK_C_14(14)
THUNK_C_15(14)
THUNK_C_16(14)
THUNK_C_17(14)
THUNK_C_18(14)
THUNK_C_19(14)
THUNK_C_20(14)
THUNK_C_21(14)
THUNK_C_22(14)
THUNK_C_23(14)
THUNK_C_24(14)
THUNK_C_25(14)
THUNK_C_26(14)
THUNK_C_27(14)
THUNK_C_28(14)
THUNK_C_29(14)
THUNK_C_30(14)
THUNK_C_1(15)
THUNK_C_2(15)
THUNK_C_3(15)
THUNK_C_4(15)
THUNK_C_5(15)
THUNK_C_6(15)
THUNK_C_7(15)
THUNK_C_8(15)
THUNK_C_9(15)
THUNK_C_10(15)
THUNK_C_11(15)
THUNK_C_12(15)
THUNK_C_13(15)
THUNK_C_14(15)
THUNK_C_15(15)
THUNK_C_16(15)
THUNK_C_17(15)
THUNK_C_18(15)
THUNK_C_19(15)
THUNK_C_20(15)
THUNK_C_21(15)
THUNK_C_22(15)
THUNK_C_23(15)
THUNK_C_24(15)
THUNK_C_25(15)
THUNK_C_26(15)
THUNK_C_27(15)
THUNK_C_28(15)
THUNK_C_29(15)
THUNK_C_30(15)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\timer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       Timer.cxx
//
//  Contents:   Class implementation for CTimerMan, CTimer,
//              and CTimerSink, which support non-Windows based timers
//              for better service and granularity.
//              Timer runs on separate thread, posting messages to main
//              window proc. Message is not WM_TIMER, however, so that
//              there won't be any delay in posting the message.
//              See Timers and Synchronization spec for details.
//
//  Created:    Dec. 5, 1996
//
//--------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TIMER_HXX_
#define X_TiMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

DeclareTag( tagExtTimer, "Timer trace", "Trace External Trident Timer" );
DeclareTag( tagExtTimerReentrant, "Timer reentrancy", "Test Timer code reentrancy" );
DeclareTag( tagExtTimerThrottle, "Timer Throttle", "Trace timer throttling" );

MtDefine(Timers, Mem, "Timer Manager")
MtDefine(CTimer, Timers, "CTimer")
MtDefine(CTimer_aryAdvises_pv, CTimer, "CTimer::_aryAdvises::_pv")
MtDefine(CTimerAdvise, Timers, "CTimerAdvise")
MtDefine(CTimerCtx, Timers, "CTimerCtx")
MtDefine(CTimerCtx_aryAdvises_pv, CTimerCtx, "CTimerCtx::_aryAdvises")
MtDefine(CTimerCtx_aryNamedTimers_pv, CTimerCtx, "CTimerCtx::_aryNamedTimers")
MtDefine(CTimerMan, Timers, "CTimerMan")
MtDefine(CTimerMan_aryTimerThreadAdvises_pv, CTimerMan, "CTimerMan::_aryTimerThreadAdvises::_pv")
MtDefine(CTimerSink, Timers, "CTimerSink")
MtDefine(CTimerSetRefTimer_arydw_pv, Locals, "CTimer::SetRefTimer arydw::_pv")

HRESULT VariantToTime(VARIANT *pvtime, DWORD *pdw)
{
    HRESULT hr = S_OK;

    Assert(pvtime);
    Assert(pdw);

    if (V_VT(pvtime) == VT_UI4)
    {
        *pdw = V_UI4(pvtime);
    }
    else
    {
        VARIANT vtimeOut;
        vtimeOut.vt = VT_EMPTY;
        hr = VariantChangeType(&vtimeOut, pvtime, 0, VT_UI4);
        if (SUCCEEDED(hr))
            *pdw = V_UI4(&vtimeOut);
    }
    RRETURN(hr);
}

#define DECLARE_VARIANT_INIT(name, dwInit)  \
    VARIANT name;           \
    VariantInit(&name);     \
    V_VT(&name) = VT_UI4;   \
    V_UI4(&name) = dwInit;

//+------------------------------------------------------------------------
//  Globals
//-------------------------------------------------------------------------

CGlobalCriticalSection    g_csTimerMan;
// CONSIDER: w/ g_pTimerMan, why have a _pTimerMan for each CTimerCtx?
CTimerMan          *g_pTimerMan = NULL;

HRESULT GetTimerManager( CTimerMan **ppTimerMan )
{
    HRESULT         hr = S_OK;

    USE_FAST_TASK_GLOBALS;

    // both writing and reading g_pTimerMan need to be in cs
    LOCK_SECTION(g_csTimerMan);

    if (FAST_TASK_GLOBAL(g_pTimerMan) == NULL)
    {
        FAST_TASK_GLOBAL(g_pTimerMan) = new CTimerMan;   // _ulRefs starts as 1

        if (FAST_TASK_GLOBAL(g_pTimerMan) == NULL)
            RRETURN(E_OUTOFMEMORY);

        hr = FAST_TASK_GLOBAL(g_pTimerMan)->Init();
        if (hr)
        {
            delete FAST_TASK_GLOBAL(g_pTimerMan);
            FAST_TASK_GLOBAL(g_pTimerMan) = NULL;
            goto Cleanup;
        }
    }
    else
    {
        FAST_TASK_GLOBAL(g_pTimerMan)->AddRef();
    }

    *ppTimerMan = FAST_TASK_GLOBAL(g_pTimerMan);

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   DeinitTimerCtx
//
//  Synopsis:   Delete Timer Context
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void
DeinitTimerCtx(THREADSTATE *pts)
{
    TraceTag((tagExtTimer, "DeinitTimerCtx"));
    Assert(pts);
    if ( pts->pTimerCtx )
    {
        pts->pTimerCtx->Release();
        pts->pTimerCtx = NULL;
    }
}

/******************************************************************************
                CTimerMan
******************************************************************************/

CTimerMan::CTimerMan()
    : CExecFT(_cs.GetPcs()), _aryTimerThreadAdvises(Mt(CTimerMan_aryTimerThreadAdvises_pv))
{
    Assert(!TASK_GLOBAL(g_pTimerMan));    // only one per process should exist
    _iFirstFree         = -1;
    _fIsLaunched        = FALSE;
    _fShutdown          = FALSE;
    _hevCheckAdvises    = NULL;
}

CTimerMan::~CTimerMan()
{
    TraceTag((tagExtTimer, "~CTimerMan"));
    TASK_GLOBAL(g_pTimerMan) = NULL;     // only one per process should exist
}


HRESULT
CTimerMan::Init()
{
    RRETURN(_cs.Init());
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   IUnknown implementation, with a twist. This object should
//              exist during the life time of the thread, but is also doled
//              out as a COM object. Therefore, pointers to the outside
//              world are ref counted, but not the internally used object,
//              which treats this as a regular class object (i.e. uses the
//              TLS macro to obtain object). This allows the secondary object
//              count to be correct during shutdown
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimerMan::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimerService *)this, IUnknown)
        QI_INHERITS(this, ITimerService)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CreateTimer         [ITimerService]
//
//  Synopsis:   Creates a CTimer object
//
//  Arguments:  pReferenceTimer - Timer to base new timer off of. This is so
//                                the behavior of the new timer is effected
//                                by the reference timer. E.g., if reference
//                                timer is frozen, so will the new timer.
//                                Can be NULL, to use default timer.
//              ppNewTimer      - Returned timer.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_POINTER
//              E_INVALIDARG
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::CreateTimer( ITimer *pReferenceTimer, ITimer **ppNewTimer )
{
    CTimer *pTimer;
    HRESULT hr;

    TraceTag((tagExtTimer, "CTimerMan::CreateTimer"));

    if ( !ppNewTimer )
        RRETURN( E_POINTER );

    hr = THR(CreateCTimer( pReferenceTimer, &pTimer ));
    *ppNewTimer = (ITimer *)pTimer;
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     CreateCTimer
//
//  Synopsis:   Workshorse for CreateTimer and GetNamedTimer. 
//
//  Arguments:  pReferenceTimer - Timer to base new timer off of. This is so
//                                the behavior of the new timer is effected
//                                by the reference timer. E.g., if reference
//                                timer is frozen, so will the new timer.
//                                Can be NULL, to use default timer.
//              ppNewTimer      - Returned timer class object.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_POINTER
//              E_INVALIDARG
//
//  Note: Assumes that GetNamedTimer will call this with a NULL ref timer. 
//        Otherwise, CTimerCtx needs to be ensured regardless of RefTimer.
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::CreateCTimer( ITimer *pReferenceTimer, CTimer **ppNewTimer,
                         REFGUID rguidName )
{
    ITimer *pTmp = NULL;

    TraceTag((tagExtTimer, "CTimerMan::CreateCTimer"));
    Assert( ppNewTimer );

    *ppNewTimer = NULL;

    // make sure Timer is set up properly for this thread 
    // CTimerCtx handles all thread specific portions of the timer mgr
    THREADSTATE *pts = GetThreadState();
    if ( !pts->pTimerCtx )
    {
        pts->pTimerCtx = new CTimerCtx( this, _cs.GetPcs() );   // _ulRefs starts as 1
        if ( !pts->pTimerCtx )
            RRETURN( E_OUTOFMEMORY );
    }
    
    if ( pReferenceTimer )
    {
        pReferenceTimer->QueryInterface( IID_ITimer, (void **)&pTmp );
        if ( !pTmp )
            RRETURN( E_INVALIDARG );
        pTmp->Release();

        *ppNewTimer = new CTimer( pReferenceTimer, pts->pTimerCtx, _cs.GetPcs(), 
                                  rguidName );
    }
    else
    {
        *ppNewTimer = new CTimer( pts->pTimerCtx, pts->pTimerCtx, _cs.GetPcs(), 
                                  rguidName );
    }

	if ( NULL == *ppNewTimer )
        RRETURN( E_OUTOFMEMORY );

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     GetNamedTimer           [ITimerService]
//
//  Synopsis:   Returns a named timer. This enables several controls to obtain
//              the same timer without passing it back and forth among 
//              themselves. This allows easier synchronization among disparate
//              controls. Also, Trident will use a timer called "Draw" for
//              Trident painting, so controls can request that one if they
//              want to be synchronized with Trident's painting.
//
//  Arguments:  pszName         - Name of the timer to return. 
//              ppNewTimer      - Returned timer.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_POINTER
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::GetNamedTimer( REFGUID rguidName, ITimer **ppNewTimer)
{
    THREADSTATE        *pts = GetThreadState();
    CTimer             *pTimer = NULL;
    HRESULT             hr = S_OK;

    TraceTag((tagExtTimer, "CTimerMan::GetNamedTimer"));
    if ( !ppNewTimer )
        RRETURN( E_POINTER );

    if ( rguidName == GUID_NULL ) 
        RRETURN( E_INVALIDARG );

    EnterCriticalSection();

    *ppNewTimer = NULL;

    // check with current timers to see if we already have this one
    if ( pts->pTimerCtx )
    {
        hr = pts->pTimerCtx->GetNamedCTimer( rguidName, &pTimer );
        if ( SUCCEEDED(hr) )
        {
            *ppNewTimer = (ITimer *)pTimer;
            (*ppNewTimer)->AddRef();
            goto cleanup;
        }
    }

    // didn't find a timer by that name, so let's create a new one
    hr = THR(CreateCTimer( NULL, &pTimer, rguidName ));
    if ( FAILED(hr) )
        goto error;

    hr = THR(pts->pTimerCtx->AddNamedCTimer( rguidName, pTimer ));
    if ( FAILED(hr) )
        goto error;

    *ppNewTimer = (ITimer *)pTimer;

cleanup:
    LeaveCriticalSection();
    RRETURN(hr);
error:
    if ( pTimer )
        delete pTimer;
    goto cleanup;
}

//+----------------------------------------------------------------------------
//
//  Method:     SetNamedTimerReference      [ITimerService]
//
//  Synopsis:   Sets the reference timer for the named timer. All advises that
//              were on the existing reference timer for the named timer are
//              moved to the new reference timer.
//
//  Arguments:  pszName         - Name of the timer whose reference timer will 
//                                change
//              pTimer          - New reference timer
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::SetNamedTimerReference( REFGUID rguidName, ITimer *pRefTimer )
{
    THREADSTATE        *pts = GetThreadState();
    CTimer             *pTimer = NULL;
    HRESULT             hr = S_OK;

    TraceTag((tagExtTimer, "CTimerMan::SetNamedTimerReference"));

    if ( !pts->pTimerCtx || 
         FAILED(pts->pTimerCtx->GetNamedCTimer( rguidName, &pTimer )) )
        RRETURN( E_INVALIDARG );

    if ( pTimer == pRefTimer )      // single-step circular ref check.
        RRETURN( E_INVALIDARG );    // Warning: does not check complete chain

    // avoid work if new ref timer is the same as existing ref timer.
    if ( pTimer->GetRefTimer() == pRefTimer || 
         (!pRefTimer && 
          pTimer->GetRefTimer() == static_cast<ITimer *>(pts->pTimerCtx)) )
        RRETURN( S_OK );

    if ( !pRefTimer )
        // reset to default ref clock
        pRefTimer = static_cast<ITimer *>(pts->pTimerCtx);

    // Get the timer to move its advises over
    hr = pTimer->SetRefTimer( pRefTimer );

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     AddAdvise
//
//  Synopsis:   Adds an advisement to the timer thread. Also sets cookie
//              to TimerAdvise passed in, using the array index.
//
//  Arguments:  pTimerAdvise - pointer of TimerAdvise to add
//              fRescheduling - TRUE if Adding the advise for next interval
//                              of a periodic advise
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::AddAdvise( CTimerAdvise *pTimerAdvise, CTimerCtx *pTimerCtx,
                      BOOL fRescheduling )
{
    HRESULT             hr = S_OK;
    PTIMERTHREADADVISE  pTTA;
    int                 index;

    Assert( pTimerAdvise && pTimerCtx );

    hr = EnsureTimerThread();
    if ( FAILED(hr) )
        goto error;

    EnterCriticalSection();
    TraceTag((tagExtTimer, "CTimerMan::AddAdvise %s", fRescheduling?"Rescheduling":" "));
    if ( fRescheduling )
    {
        // update advise
        DWORD index = pTimerAdvise->GetCookie()-1;      // convert back to index
        _aryTimerThreadAdvises[index].timeFire = pTimerAdvise->GetNextTick();
    }
    else
    {
        if ( _iFirstFree >= 0 )
        {
            // Free cells in the array point to the next free cell to use with
            // their NextFree element. -1 indicate there are no more free cells
            // within the array. A free cell is one which causes a discontinuity
            // between the first array element and the last one in use, i.e., the
            // tail end of the part of the array being used is not considered a
            // free cell. It is considered virgin array space to be appended onto.
            // _iFirstFree points to the first free cell in the list
            index = _iFirstFree;
            pTTA = &_aryTimerThreadAdvises[index];
            _iFirstFree = pTTA->NextFree;
        }
        else
        {
            index = _aryTimerThreadAdvises.Size();
            hr = THR(_aryTimerThreadAdvises.AppendIndirect(NULL, &pTTA));
        }

        if ( SUCCEEDED(hr) )
        {
            pTTA->timeFire = pTimerAdvise->GetNextTick();
            pTTA->timeExpire = pTimerAdvise->GetTimeMax();
            pTTA->NextFree = -1;
            pTTA->fIsFree = FALSE;
            pTTA->pTimerCtx = pTimerCtx;
            pTimerAdvise->SetCookie( index+1 );     // zero is an invalid cookie value
        }
    }
    LeaveCriticalSection();

    if ( FAILED(hr) )
        goto error;

cleanup:
    RRETURN(hr);
error:
    goto cleanup;

}

//+----------------------------------------------------------------------------
//
//  Method:     RemoveAdvise
//
//  Synopsis:   Removes an advisement from the array of advisement.
//
//  Arguments:  index - which one to remove
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::RemoveAdvise( int index )
{
    EnterCriticalSection();
    Assert( _aryTimerThreadAdvises.Size() > 0 );       // otherwise, we should have shut down
    Assert( index < _aryTimerThreadAdvises.Size() && index >= 0 );

    TraceTag((tagExtTimer, "CTimerMan::RemoveAdvise"));

    if ( !_aryTimerThreadAdvises[index].fIsFree )
    {
        _aryTimerThreadAdvises[index].fIsFree = TRUE;
        _aryTimerThreadAdvises[index].NextFree = _iFirstFree;
        _iFirstFree = index;
    }
    LeaveCriticalSection();
}

//+----------------------------------------------------------------------------
//
//  Method:     EnsureTimerThread
//
//  Synopsis:   Makes sure the Timer thread is up and running
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::EnsureTimerThread()
{
    HRESULT             hr = S_OK;

    // make sure timer thread is active
    if ( !_fIsLaunched )
    {
        TraceTag((tagExtTimer, "CTimerMan::EnsureTimerThread. Launching..."));

        EnterCriticalSection();
        if (!_fIsLaunched)
        {
            _hevCheckAdvises = CreateEventA( NULL, FALSE, FALSE, NULL );
            if ( !_hevCheckAdvises )
            {
                hr = GetLastError();
            }
            if (hr == S_OK)
            {
                hr = THR(Launch(FALSE));
            }
            if (hr == S_OK)
                _fIsLaunched = TRUE;
        }
        LeaveCriticalSection();
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//    Methods which run on the Timer Thread
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:     ThreadInit
//
//  Synopsis:   Initializes Event object used to signal timer thread
//
//  Arguments:  none
//
//  Returns:    result from CreateEvent
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::ThreadInit( )
{
    TraceTag((tagExtTimer, "CTimerMan::ThreadInit"));

    // Name this thread for IceCAP
    NameThread("TimerMan");

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     ThreadExec
//
//  Synopsis:   Timer on separate thread, the real workhorse. The thread has
//              an event schedule, which is its own array of single shot advises.
//              Periodic timers should reschedule their advises to this thread
//              as they are processed by the TimerCtx on the UI threads.
//              This thread sleeps until the earliest advise should
//              be fired, or until there is something that changes its
//              scheduling queue. Each advise gets fired off, even if they occur
//              at the same time as other events. The signaling method
//              prevents undue notifications.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::ThreadExec( )
{
    DWORD              timeWait, timeNow;
    TIMERTHREADADVISE *pTTA;
    int                cTTA;

    TraceTag((tagExtTimer, "CTimerMan::ThreadExec"));
    Assert( _hevCheckAdvises );

    while ( !_fShutdown )
    {
        timeWait = INFINITE;

        // Get the next advise to fire off
        EnterCriticalSection();
        if ( _aryTimerThreadAdvises.Size() > 0 )
        {
            timeNow = GetCurrentTime();

            // loop through to see if we have any that can be fired off now.
            // and in the mean time keep track of the closest one to timeNow
            // that should be scheduled
            for ( cTTA=_aryTimerThreadAdvises.Size(), pTTA=_aryTimerThreadAdvises;
                  cTTA;
                  cTTA--, pTTA++)
            {
                if ( !(pTTA->fIsFree) )
                {
                    if ( pTTA->timeFire <= timeNow )
                    {
                        // fire off advise, even if it has expired to
                        // clear _aryAdvises of dead Advises
                        pTTA->pTimerCtx->Signal();
                    }
                    else
                    {
                        if ( pTTA->timeFire - timeNow < timeWait )
                        {
                            timeWait = pTTA->timeFire - timeNow;
                        }
                    }
                }
            }
        }
        LeaveCriticalSection();

        // wait until its either time to process the advise scheduled or until
        // the event has been set because _aryTimerThreadAdvises has changed
        WaitForSingleObject( _hevCheckAdvises, timeWait );
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     ThreadTerm
//
//  Synopsis:   Closes Event object
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::ThreadTerm( )
{
    TraceTag((tagExtTimer, "CTimerMan::ThreadTerm"));
}

//+----------------------------------------------------------------------------
//
//  Method:     Passivate
//
//  Synopsis:   Frees all references held by our timer
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::Passivate( )
{
    TraceTag((tagExtTimer, "CTimerMan Passivate (Enter)"));

    Shutdown();
    super::Passivate();
    CloseEvent( _hevCheckAdvises );

    TraceTag((tagExtTimer, "CTimerMan Passivate (Leave)"));
}

//+----------------------------------------------------------------------------
//
//  Method:     Shutdown
//
//  Synopsis:   takes down timer thread
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::Shutdown( )
{
    TraceTag((tagExtTimer, "CTimerMan Shutdown (Enter)"));

    _fShutdown = TRUE;
    if ( _hevCheckAdvises )
        SetEvent( _hevCheckAdvises );   // tell timer thread to shutdown
    super::Shutdown();

    TraceTag((tagExtTimer, "CTimerMan Shutdown (Leave)"));
}

/******************************************************************************
                CTimerCtx
******************************************************************************/
CTimerCtx::CTimerCtx( CTimerMan *pTimerMan, CRITICAL_SECTION *pcs )
    : CBaseFT(pcs)
    , _aryAdvises(Mt(CTimerCtx_aryAdvises_pv))
    , _aryNamedTimers(Mt(CTimerCtx_aryNamedTimers_pv))
{
    TraceTag((tagExtTimer, "CTimerCtx::CTimerCtx"));
    _pTimerMan =            pTimerMan;
    _pTimerMan->AddRef();
    _pts =                  GetThreadState();
    _cFreezes =             0;
    _fProcessingAdvise =    FALSE;
    _fPendingUnadvise =     FALSE;
    _fPosting =             FALSE;
    _fSetTimer =            FALSE;
    _fSignalManager =       FALSE;
    _uTimerID =             0;
    _aryAdvises.EnsureSize(3);
#if DBG==1
    _threadID =             GetCurrentThreadId();
#endif
}

CTimerCtx::~CTimerCtx()
{
    TraceTag((tagExtTimer, "CTimerCtx::~CTimerCtx"));
    Assert( _pTimerMan );
    TraceTag(( tagExtTimer, "~CTimerCtx deleting %d advises", _aryAdvises.Size() ));
    for ( int i=0; i<_aryAdvises.Size(); i++ )
    {
        delete _aryAdvises[i];
    }
    GWKillMethodCallEx( _pts, this, NULL, 0 );
    if ( _uTimerID )
        FormsKillTimer( this, _uTimerID );
    _pTimerMan->Release();

}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   The typical IUnknown implementation.
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimerCtx::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimer *)this, IUnknown)
        QI_INHERITS(this, ITimer)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     Unadvise         [ITimer]
//
//  Synopsis:   Removes an advisement from the array of advisement by cookie.
//
//  Arguments:  dwCookie - cookie identifying which advise
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::Unadvise( DWORD dwCookie )
{
    HRESULT hr = E_INVALIDARG;
#if DBG==1
    // make sure unadvise is happening on the same thread timectx was created on
    Assert(_threadID == GetCurrentThreadId() );
#endif

    TraceTag((tagExtTimer, "CTimerCtx::Unadvise (Cookie=%d)", dwCookie));
    // loop thru to find cookie match. Cookie comes from CTimerMan, so cookies
    // may not be contiguous.
    int iArySize = _aryAdvises.Size();
    for ( int i=0; i<iArySize; i++ )
    {
        if ( _aryAdvises[i]->GetCookie() == dwCookie )
        {
            if ( _fProcessingAdvise )
            {
                _fPendingUnadvise = TRUE;
                _aryAdvises[i]->SetPendingDelete();
            }
            else
            {
                delete _aryAdvises[i];
                _aryAdvises.Delete(i);
                _pTimerMan->RemoveAdvise( dwCookie-1 );   // CTimerMan passes back index+1 as cookie
            }
            hr = S_OK;
            break;
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     Freeze (and Thaw)         [ITimer]
//
//  Synopsis:   Halts the flow of time for this timer. No events fire until
//              a freze is "thawed". Freezes can be nested. Must be matched
//              by a call that thaws the clock.
//
//  Arguments:  fFreeze - Whether to freeze or thaw the clock.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::Freeze( BOOL fFreeze )
{
    TraceTag((tagExtTimer, "CTimerCtx::Freeze %s", fFreeze?"On":"Off"));

    HRESULT hr = S_OK;

    if ( fFreeze )
    {
        if ( 0 == _cFreezes++ )
        {
            VARIANT v;
            VariantInit(&v);

            hr = GetTime(&v);
            Assert(SUCCEEDED(hr));
            Assert(V_VT(&v) == VT_UI4);
            _timeFrozen = V_UI4(&v);
        }
    }
    else if ( _cFreezes > 0 )
    {
        if ( 0 == --_cFreezes )
        {
            hr = ProcessAdvise();
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetTime                 [ITimer]
//
//  Synopsis:   returns the current time in milliseconds.
//
//  Arguments:  pTime - returned time
//
//  Returns:    S_OK
//              E_POINTER
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::GetTime( VARIANT *pvTime )
{
    TraceTag((tagExtTimer, "CTimerCtx::GetTime"));

    if ( !pvTime )
        RRETURN(E_POINTER);

    VariantClear(pvTime);

    V_VT(pvTime) = VT_UI4;
    if ( _cFreezes > 0 || _fProcessingAdvise )
        V_UI4(pvTime) = _timeFrozen;
    else
        V_UI4(pvTime) = ::GetCurrentTime();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     Advise
//
//  Synopsis:   Does the actual setting of the Advise. Parameter checks done
//              by other Advise* calls.
//
//  Arguments:  timeMin - event will not be fired before this time
//              timeMax - event will not be fired after this time (discarded)
//                        if set to zero (translated to TIME_MAX), this is 
//                        never discarded
//              timeInterval - the minimum time before the next event is fired
//              dwFlags - Hint Flags:
//                        TIMER_HINT_KEYFRAME -
//                        TIMER_HINT_INVALIDATE - Sink will cause a paint. Timer
//                                                should be frozen when container
//                                                paints, or at least event shouldn't
//                                                fire during a paint
//              pTimerSink - method to call when event fires
//              pdwCookie - cookie returned for call to Unadvise
//
//  Returns:    S_OK
//              E_POINTER
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              DISP_E_OVERFLOW
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::Advise( VARIANT vtimeMin, VARIANT vtimeMax, VARIANT vtimeInterval,
                      DWORD dwFlags, ITimerSink *pTimerSink, DWORD *pdwCookie )
{
    TraceTag((tagExtTimer, "CTimerCtx::Advise"));

    if ( !pTimerSink || !pdwCookie )
        RRETURN(E_POINTER);

    HRESULT             hr;
    CTimerAdvise       *pTA = NULL;


    DWORD timeMin, timeMax, timeInterval;

    hr = VariantToTime(&vtimeMin, &timeMin);
    if (FAILED(hr))
        RRETURN(hr);

    hr = VariantToTime(&vtimeMax, &timeMax);
    if (FAILED(hr))
        RRETURN(hr);
    //
    // REVIEW - michaelw: if someone uses a different type to pass in 0xffffffff
    //                    we really shouldn't treat it as MAX_TIME.
    if (timeMax == MAX_TIME)
        RRETURN(DISP_E_OVERFLOW);
    else if (timeMax == 0)
        timeMax = MAX_TIME;

    if (timeMax < timeMin)
        RRETURN(E_INVALIDARG);

    hr = VariantToTime(&vtimeInterval, &timeInterval);
    if (FAILED(hr))
        RRETURN(hr);

    // add advise to UI thread, which adds advise Timer-thread's list
    pTA = new CTimerAdvise( pTimerSink, timeMin, timeMax, timeInterval, dwFlags );
    if ( !pTA )
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = _aryAdvises.Append( pTA );
    if ( FAILED(hr) )
        goto error;

    // put this on the timer thread as well
    hr = _pTimerMan->AddAdvise( pTA, this );
    if ( FAILED(hr) )
        goto error;

    if ( _fProcessingAdvise )   
        _fSignalManager = TRUE;         // defer signalling to ProcessAdvise
    else
        _pTimerMan->SignalChanges();    // tell timerman to pick this up now

    *pdwCookie = pTA->GetCookie();
    TraceTag((tagExtTimer, "CTimerCtx::Advise cookie = %d", *pdwCookie));

cleanup:
    RRETURN(hr);

error:
    delete pTA;
    goto cleanup;

}

void
CTimerCtx::Signal()
{
    TraceTag((tagExtTimer, "CTimerCtx::Signal"));
    TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal"));
    if ( _fPosting || _cFreezes > 0 || _fSetTimer )
    {
#if DBG==1  
        if ( IsTagEnabled(tagExtTimerThrottle) ) {
            if(_fPosting)
                TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal Skipped, still posting the old one"));
            if(_cFreezes > 0)
                TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal Skipped, _cFreezes > 0"));
            if(_fSetTimer > 0)
                TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal Skipped, _fSetTimer WM_TIMER has not arrived"));
        }
#endif
        return;
    }

    EnterCriticalSection();
    if ( _fProcessingAdvise )
    {
        TraceTag((tagExtTimerThrottle, "_fProcessingAdvise set, setting _fSetTime=TRUE"));
        _fSetTimer = TRUE;
        LeaveCriticalSection();
        return;
    }
    LeaveCriticalSection();

    TraceTag((tagExtTimer, "Signal got through"));
    TraceTag((tagExtTimerThrottle, "Signal got through"));
    _fPosting = TRUE;
    GWPostMethodCallEx( _pts, (void *)this,
                        ONCALL_METHOD(CTimerCtx, OnMethodCall, onmethodcall),
                        0, FALSE, "CTimerCtx::OnMethodCall");

}

//+----------------------------------------------------------------------------
//
//  Method:     OnMethodCall
//
//  Synopsis:   The Callback from the Global Window Proc after posting our
//              request. In turn, fires off OnTimer calls to clients who
//              have posted advises with this reference timer.
//
//  Arguments:  dwContext - not used
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerCtx::OnMethodCall( DWORD_PTR dwContext )
{
    TraceTag((tagExtTimer, "CTimerCtx::OnMethodCall"));
    _fPosting = FALSE;
    if ( _cFreezes > 0 )
        return;

    WHEN_DBG(HRESULT hr =) ProcessAdvise();
    Assert(SUCCEEDED(hr));
}

//+----------------------------------------------------------------------------
//
//  Method:     ProcessAdvise
//
//  Synopsis:   Goes through advises and sees if they should notify clients
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::ProcessAdvise()
{
    TraceTag((tagExtTimer, "CTimerCtx::ProcessAdvise"));

    DWORD timeNow, timeMax, timeSink, timeInt;
    BOOL fSetTimer;
    HRESULT hr;

    if ( _cFreezes > 0 )
        RRETURN(S_OK);

    if ( _fProcessingAdvise ) {
        // oh man, aux msg pump driving timer. Defer until later
        _fSignalManager = TRUE;
        RRETURN(S_OK);
    }

    VARIANT vtimeNow;
    VariantInit(&vtimeNow);
	
	hr = GetTime( &vtimeNow );
	if ( FAILED(hr) )
		RRETURN(hr);
	
    hr = VariantToTime( &vtimeNow, &timeNow );
    if ( FAILED(hr) )
        RRETURN(hr);

    _timeFrozen = timeNow;
    _fProcessingAdvise = TRUE;
    int i = _aryAdvises.Size()-1;
    while ( i >= 0)
    {
        CTimerAdvise *pTA = _aryAdvises[i];
        if ( (timeMax = pTA->GetTimeMax()) < timeNow )
        {
            _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );
            delete _aryAdvises[i];
            _aryAdvises.Delete(i);
        }
        else if ( (timeSink = pTA->GetNextTick()) <= timeNow )
        {
            if ( 0 == (timeInt = pTA->GetTimeInterval()) )
            {
                DECLARE_VARIANT_INIT(vtimeSink, timeSink);

                pTA->GetTimerSink()->OnTimer( vtimeSink );
#if DBG==1  
                if ( IsTagEnabled(tagExtTimerReentrant) ) {
                    // make like a modal dialog came up, or something
                    ProcessAdvise();
                }
#endif
                _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );
                delete _aryAdvises[i];  // trash advise if this was not periodic
                _aryAdvises.Delete(i);
            }
            else
            {
                // make sure we give the latest interval to the sink call
                timeSink += ((timeNow - timeSink)/timeInt) * timeInt;

                DECLARE_VARIANT_INIT(vtimeSink, timeSink);

                pTA->GetTimerSink()->OnTimer( vtimeSink );

                // schedule next period
                if ( MAX_TIME == timeMax || timeSink + timeInt < timeMax )
                {
                    // reset pTA in case memory moved from growing during OnTimer call 
                    CTimerAdvise *pTA = _aryAdvises[i];
                    pTA->SetNextTick( timeSink + timeInt );
                    _pTimerMan->AddAdvise( pTA, this, TRUE );
                    _fSignalManager = TRUE;
                }
                else
                {
                    _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );
                    delete _aryAdvises[i];  // trash it, advise expired
                    _aryAdvises.Delete(i);
                }
            }
        }
        i--;
    }

    // Process any Unadvises that came as a result of calling OnTimer on our sinks.
    if ( _fPendingUnadvise )
    {
        for ( i=_aryAdvises.Size()-1; i>=0; i-- )
        {
            if ( _aryAdvises[i]->GetPendingDelete() )
            {
                _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );  // CTimerMan passes back index+1 as cookie
                delete _aryAdvises[i];
                _aryAdvises.Delete(i);
            }
        }
        _fPendingUnadvise = FALSE;
    }

    // Now it's time to tell the Timer Manager to wake up and notices the changes
    if ( _fSignalManager ) {
        _pTimerMan->SignalChanges();
        _fSignalManager = FALSE;
    }

    // If processing advises took longer than the interval in which we are 
    // notified to process the advises, then we need to yield to other msgs
    // in the Windows msg queue, so we'll set up a timer to let things happen
    EnterCriticalSection();
    fSetTimer =  _fSetTimer;
    _fProcessingAdvise = FALSE;
    LeaveCriticalSection();

    if ( fSetTimer )
    {
        hr = THR(FormsSetTimer( this, ONTICK_METHOD(CTimerCtx, TimerCallback, timercallback),
                 ++_uTimerID, 0 ));
        TraceTag((tagExtTimerThrottle, "Setting up Windows Timer, ID=%d", _uTimerID));
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     TimerCallback   
//
//  Synopsis:   Function Windows calls when processing a WM_Timer for CTimerCtx
//
//  Arguments:  uTimerID        - ID of Windows timer
//
//  Returns:    S_OK
//              E_FAIL          - no timer by this name
//
//-----------------------------------------------------------------------------
HRESULT BUGCALL
CTimerCtx::TimerCallback( UINT uTimerID )
{
    TraceTag((tagExtTimerThrottle, "TimerCallback _ID=%d  ID=%d", _uTimerID, uTimerID));
    Assert( _uTimerID == uTimerID );
    Verify(FormsKillTimer( this, uTimerID ) == S_OK);
    _fSetTimer = FALSE;
    _uTimerID = 0;
    return ProcessAdvise();
}

//+----------------------------------------------------------------------------
//
//  Method:     GetNamedCTimer
//
//  Synopsis:   Returns a named timer. 
//
//  Arguments:  rguidName       - GUID name of the timer to return. 
//              ppNewTimer      - Returned CTimer object.
//
//  Returns:    S_OK
//              E_FAIL          - no timer by this name
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::GetNamedCTimer( REFGUID rguidName, CTimer **ppNewTimer)
{
    TraceTag((tagExtTimer, "CTimerCtx::GetNamedCTimer"));
    Assert( ppNewTimer );

    *ppNewTimer = NULL;

    for ( int i=0; i<_aryNamedTimers.Size(); i++ ) 
    { 
        if ( _aryNamedTimers[i].guidName == rguidName )
        {
            *ppNewTimer = _aryNamedTimers[i].pTimer;
            return S_OK;
        }
    }
    return E_FAIL;
}

//+----------------------------------------------------------------------------
//
//  Method:     AddNamedCTimer
//
//  Synopsis:   Adds a timer and Name to the array of named timers
//
//  Arguments:  rguidName       - GUID name of the timer 
//              pTimer          - timer.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::AddNamedCTimer( REFGUID rguidName, CTimer *pTimer)
{
    PTIMERNAMEDTIMER pNT;
    HRESULT hr;

    TraceTag((tagExtTimer, "CTimerCtx::AddNamedCTimer"));
    Assert( pTimer );

    hr = THR(_aryNamedTimers.AppendIndirect(NULL, &pNT));
    if ( FAILED(hr) )
        RRETURN(hr);

    pNT->guidName = rguidName;
    pNT->pTimer = pTimer;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     RemoveNamedCTimer
//
//  Synopsis:   Removes the name and corresponding timer from the array of 
//              named timers
//
//  Arguments:  rguidName       - GUID name of the timer 
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerCtx::RemoveNamedCTimer( REFGUID rguidName )
{
    TraceTag((tagExtTimer, "CTimerCtx::RemoveNamedCTimer"));

    for ( int i=_aryNamedTimers.Size()-1; i >= 0; i-- )
    {
        if ( _aryNamedTimers[i].guidName == rguidName )
        {
            _aryNamedTimers.Delete(i);
            break;
        }
    }
}

/******************************************************************************
                CTimer
******************************************************************************/
CTimer::CTimer( ITimer *pRefTimer, CTimerCtx *pTimerCtx, 
                CRITICAL_SECTION *pcs, REFGUID rguidName )
    : CBaseFT(pcs), _aryAdvises(Mt(CTimer_aryAdvises_pv))
{
    TraceTag((tagExtTimer, "CTimer::CTimer"));
    _dwCurrentCookie    = 1;
    _cFreezes           = 0; 
    _fProcessingAdvise  = FALSE; 
    _fPendingUnadvise   = FALSE;
    _pTimerSink         = NULL;
    _guidName           = rguidName;
    _pTimerCtx          = pTimerCtx;
    _pTimerCtx->AddRef();
    _pRefTimer          = pRefTimer;
    _pRefTimer->AddRef();
    IncrementObjectCount(&_dwObjCnt);
}

CTimer::~CTimer()
{
    TraceTag((tagExtTimer, "CTimer::~CTimer"));
    if ( _pTimerSink )                  // timer sink is on its own
    {
        _pTimerSink->_pTimer = NULL;
    }

    if ( GUID_NULL != _guidName ) 
        _pTimerCtx->RemoveNamedCTimer( _guidName );
    _pTimerCtx->Release();

    for ( int i=0; i<_aryAdvises.Size(); i++ )
    {
        _pRefTimer->Unadvise(_aryAdvises[i]->GetRefCookie());
        delete _aryAdvises[i];
    }
    _pRefTimer->Release();
    DecrementObjectCount(&_dwObjCnt);
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   class QueryInterface impl
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimer::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimer *)this, IUnknown)
        QI_INHERITS(this, ITimer)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     Unadvise         [ITimer]
//
//  Synopsis:   Removes a schedule event
//
//  Arguments:  dwCookie - cookie identifying which advise
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::Unadvise( DWORD dwCookie )
{
    TraceTag((tagExtTimer, "CTimer::Unadvise (Cookie=%d)", dwCookie));
    HRESULT hr = E_INVALIDARG;
    for ( int i=0; i<_aryAdvises.Size(); i++ )
    {
        if ( _aryAdvises[i]->GetCookie() == dwCookie )
        {
            if ( _fProcessingAdvise )
            {
                _fPendingUnadvise = TRUE;
                _aryAdvises[i]->SetPendingDelete();
            }
            else
            {
                RemoveAdvise( i );
            }
            hr = S_OK;
            break;
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     Freeze (and Thaw)         [ITimer]
//
//  Synopsis:   Halts the flow of time for this timer. No events fire until
//              a freze is "thawed". Freezes can be nested. Must be matched
//              by a call that thaws the clock.
//
//  Arguments:  fFreeze - Whether to freeze or thaw the clock.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::Freeze( BOOL fFreeze )
{
    TraceTag((tagExtTimer, "CTimer::Freeze"));

    HRESULT hr = S_OK;

    if ( fFreeze ) {
        if ( 0 == _cFreezes )
        {
            VARIANT vtimeNow;
            VariantInit(&vtimeNow);

            hr = _pRefTimer->GetTime( &vtimeNow );
            if (SUCCEEDED(hr))
            {
                hr = VariantToTime(&vtimeNow, &_timeFrozen);
                if (SUCCEEDED(hr))
                    _cFreezes++;
            }
        }
        else
            _cFreezes++;
    }
    else if ( _cFreezes > 0 )
    {
        if ( 0 == --_cFreezes )
        {
            hr = ProcessAdvise();
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetTime             [ITimer]
//
//  Synopsis:   returns the current time in miliseconds.
//
//  Arguments:  pTime - returned time
//
//  Returns:    S_OK
//              E_POINTER
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::GetTime( VARIANT *pvTime )
{
    TraceTag((tagExtTimer, "CTimer::GetTime"));
    if ( !pvTime )
        RRETURN( E_POINTER );

    if ( _fProcessingAdvise || _cFreezes > 0 )
    {
        VariantClear(pvTime);
        V_VT(pvTime) = VT_UI4;
        V_UI4(pvTime) = _timeFrozen;
        return( S_OK );
    }
    RRETURN(_pRefTimer->GetTime( pvTime ));
}

//+----------------------------------------------------------------------------
//
//  Method:     Advise
//
//  Synopsis:   Does the actual setting of the Advise. Parameter checks done
//              by other Advise* calls.
//
//  Arguments:  timeMin - event will not be fired before this time
//              timeMax - event will not be fired after this time (discarded)
//                        if set to zero (translated to MAX_TIME), this is 
//                        never discarded
//              timeInterval - the minimum time before the next event is fired
//              dwFlags - Hint Flags:
//                        TIMER_HINT_KEYFRAME -
//                        TIMER_HINT_INVALIDATE - Sink will cause a paint. Timer
//                                                should be frozen when container
//                                                paints, or at least event shouldn't
//                                                fire during a paint
//              pTimerSink - method to call when event fires
//              pdwCookie - cookie returned for call to Unadvise
//
//  Returns:    S_OK
//              E_POINTER
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              E_FAIL
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::Advise( VARIANT vtimeMin, VARIANT vtimeMax, VARIANT vtimeInterval, 
                   DWORD dwFlags, ITimerSink *pTimerSink, DWORD *pdwCookie )
{
    HRESULT         hr;
    CTimerAdvise   *pTA = NULL;
    DWORD           dwCookie;
    DWORD timeMin, timeMax, timeInterval;

    if ( !pTimerSink)
        RRETURN(E_POINTER);

    hr = VariantToTime(&vtimeMin, &timeMin);
    if (FAILED(hr))
        RRETURN(hr);

    hr = VariantToTime(&vtimeMax, &timeMax);
    if (FAILED(hr))
        RRETURN(hr);
    //
    // REVIEW - michaelw: if someone uses a different type to pass in 0xffffffff
    //                    we really shouldn't treat it as MAX_TIME.
    if (timeMax == MAX_TIME)
        RRETURN(DISP_E_OVERFLOW);
    else if (timeMax == 0)
        timeMax = MAX_TIME;

    if (timeMax < timeMin)
        RRETURN(E_INVALIDARG);

    hr = VariantToTime(&vtimeInterval, &timeInterval);
    if (FAILED(hr))
        RRETURN(hr);

    // create our sink object if not already there
    if ( !_pTimerSink )
    {
        _pTimerSink = new CTimerSink( this );
        if ( !_pTimerSink )
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    // create advise and add advise to our list
    pTA = new CTimerAdvise( pTimerSink, timeMin, timeMax, timeInterval, dwFlags );
    if ( !pTA )
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // ask reference timer to tell us when to process this advise
    hr = _pRefTimer->Advise(vtimeMin, vtimeMax, vtimeInterval, dwFlags, (ITimerSink *)_pTimerSink, &dwCookie);
    if ( FAILED(hr) )
        goto error;

    // add advisement to our own list
    hr = _aryAdvises.Append( pTA );
    if ( FAILED(hr) )
        goto error;

    // set cookies. Need separate cookies because ref timer can be switched midstream.
    pTA->SetRefCookie( dwCookie );
    pTA->SetCookie( _dwCurrentCookie );

    if ( pdwCookie )
        *pdwCookie = _dwCurrentCookie;
    _dwCurrentCookie++;

    TraceTag((tagExtTimer, "CTimer::Advise cookie = %d", *pdwCookie));

cleanup:
    RRETURN(hr);

error:
    TraceTag((tagExtTimer, "CTimer::Advise ERROR"));
    delete pTA;
    goto cleanup;

}

/*-------------------------------Helper Functions----------------------------*/

//+----------------------------------------------------------------------------
//
//  Method:     RemoveAdvise
//
//  Synopsis:   Removes an advisement from the array of advisement.
//
//  Arguments:  index - which one to remove
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimer::RemoveAdvise( int index )
{
    TraceTag((tagExtTimer, "CTimer::RemoveAdvise"));
    Assert( index < _aryAdvises.Size() && index >= 0 );

    _pRefTimer->Unadvise( _aryAdvises[index]->GetRefCookie() );
    delete _aryAdvises[index];
    _aryAdvises.Delete(index);
}

//+----------------------------------------------------------------------------
//
//  Method:     ProcessAdvise
//
//  Synopsis:   Goes through advises and sees if they should notify clients
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::ProcessAdvise()
{
    TraceTag((tagExtTimer, "CTimer::ProcessAdvise"));

    DWORD timeNow, timeMax, timeSink, timeInt;
    HRESULT hr;

    if ( _cFreezes > 0 )
        RRETURN(S_OK);

    VARIANT vtimeNow;
    VariantInit(&vtimeNow);
	
	hr = GetTime( &vtimeNow );
	if ( FAILED(hr) )
		RRETURN(hr);
	
    hr = VariantToTime( &vtimeNow, &timeNow );
    if ( FAILED(hr) )
        RRETURN(hr);

    _timeFrozen = timeNow;
    AddRef();                   // protect against releases to zero
    if(_fProcessingAdvise == TRUE)
    {
        goto done;
    }
    _fProcessingAdvise = TRUE;  // protect against unadvises

    // Check all advises
    int i = _aryAdvises.Size()-1;
    while ( i >= 0)
    {
        CTimerAdvise *pTA = _aryAdvises[i];
        if ( (timeMax = pTA->GetTimeMax()) < timeNow )
        {
            RemoveAdvise( i );
        }
        else if ( (timeSink = pTA->GetNextTick()) <= timeNow )
        {
            VARIANT vtimeSink;
            VariantInit(&vtimeSink);
            V_VT(&vtimeSink) = VT_UI4;

            if ( 0 == (timeInt = pTA->GetTimeInterval()) )
            {
                V_UI4(&vtimeSink) = timeSink;

                pTA->GetTimerSink()->OnTimer(vtimeSink);
                RemoveAdvise( i );      // trash advise if this was a one off
            }
            else
            {
                // make sure we give the latest interval to the sink call
                timeSink += ((timeNow - timeSink)/timeInt) * timeInt;
                V_UI4(&vtimeSink) = timeSink;

                pTA->GetTimerSink()->OnTimer( vtimeSink );

                // schedule next period
                if ( MAX_TIME == timeMax || timeSink + timeInt < timeMax )
                    (_aryAdvises[i])->SetNextTick( timeSink + timeInt );
                else
                    RemoveAdvise( i );      // trash it, advise expired
            }
        }
        i--;
    }
    _fProcessingAdvise = FALSE;

    // Process any Unadvises that came as a result of calling OnTimer on our sinks.
    if ( _fPendingUnadvise )
    {
        for ( i=_aryAdvises.Size()-1; i>=0; i-- )
        {
            if ( _aryAdvises[i]->GetPendingDelete() )
                RemoveAdvise( i );
        }
        _fPendingUnadvise = FALSE;
    }
done:
    Release();

    RRETURN(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Method:     SetRefTimer
//
//  Synopsis:   Set the reference timer. Advises on the old reference timer
//              are removed and replaced onto the new reference timer.
//
//  Arguments:  pRefTimer - new reference timer
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------

HRESULT
CTimer::SetRefTimer( ITimer *pRefTimer )
{
    CTimerAdvise    *pTA;
    DWORD           dwCookie;
    DWORD           timeOldRef, timeNewRef, timeDiff=0;
    DWORD           timeMin, timeMax;
    int             cAdvises = _aryAdvises.Size();
    CStackPtrAry<DWORD_PTR, 12> arydw(Mt(CTimerSetRefTimer_arydw_pv));
    HRESULT         hr;

    TraceTag((tagExtTimer, "CTimer::SetRefTimer: moving %d advises", cAdvises));

    pRefTimer->AddRef();
    Freeze( TRUE );

    // account for different starting points in reference timers
    VARIANT v;
    VariantInit(&v);
    hr = THR(pRefTimer->GetTime( &v ));
    if (FAILED(hr))
        goto error;

    hr = VariantToTime(&v, &timeNewRef);
    if (FAILED(hr))
        goto error;

    hr = GetTime(&v);
    if (FAILED(hr))
        goto error;

    hr = VariantToTime(&v, &timeOldRef);
    if (FAILED(hr))
        goto error;

    timeDiff = timeNewRef - timeOldRef;

    if ( cAdvises > 0 )
    {
        // first move all advises to new ref timer before trashing old one
        hr = THR(arydw.EnsureSize(cAdvises));
        if ( FAILED(hr) )
            goto error;

        int i;
        for ( i=0; i<cAdvises; i++ )
        {
            pTA = _aryAdvises[i];
            timeMin = pTA->GetTimeMin() + timeDiff;
            if ( pTA->GetTimeMax() != MAX_TIME )
                timeMax = pTA->GetTimeMax() + timeDiff;
            else 
                timeMax = 0;    // this is treated as MAX_TIME from the interface standpoint

            DECLARE_VARIANT_INIT(vtimeMin, timeMin);
            DECLARE_VARIANT_INIT(vtimeMax, timeMax);
            DECLARE_VARIANT_INIT(vtimeInterval, pTA->GetTimeInterval());

            hr = pRefTimer->Advise( vtimeMin, vtimeMax, vtimeInterval,
                                    pTA->GetHintFlags(),
                                    pTA->GetTimerSink(),
                                    &dwCookie);
            if ( FAILED(hr) )
                goto error;

            arydw[i] = dwCookie;
        }

        // everything safely on new ref timer, 
        // - get rid of advises on old timer, 
        // - adjust min and max time accordingly, 
        // - and expunge expired advises
        for ( i=cAdvises-1; i>=0; i-- )
        {
            pTA = _aryAdvises[i];

            _pRefTimer->Unadvise( pTA->GetRefCookie() );
            
            if ( 0 == arydw[i] )
            {
                delete _aryAdvises[i];
                _aryAdvises.Delete(i);
            }
            else
            {
                pTA->SetTimeMin( pTA->GetTimeMin() + timeDiff );
                if ( pTA->GetTimeMax() != MAX_TIME )
                    pTA->SetTimeMax( pTA->GetTimeMax() + timeDiff );
                pTA->SetRefCookie( (DWORD)arydw[i] );
            }
        }
    }
    _pRefTimer->Release();
    _pRefTimer = pRefTimer;     // already AddRef'ed above


cleanup:
    Freeze( FALSE );
    RRETURN(hr);

error:
    Assert( 0 && "Error in SetRefTimer" );
    pRefTimer->Release();
    goto cleanup;
}

/******************************************************************************
                CTimerSink
******************************************************************************/
CTimerSink::CTimerSink( CTimer *pTimer )
{
    TraceTag((tagExtTimer, "CTimerSink::CTimerSink"));
    _pTimer = pTimer;
    _ulRefs = 0;
}

CTimerSink::~CTimerSink( )
{
    TraceTag((tagExtTimer, "CTimerSink on it's way out!"));
    if ( _pTimer )
        _pTimer->_pTimerSink = NULL;
}

ULONG
CTimerSink::AddRef()
{
    return ++_ulRefs;
}

ULONG
CTimerSink::Release()
{
    TraceTag((tagExtTimer, "CTimerSink::Release(); New ref count = %d", _ulRefs-1));
    if ( 0 == --_ulRefs )
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   IUnknown implementation.
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimerSink::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimerSink *)this, IUnknown)
        QI_INHERITS(this, ITimerSink)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     OnTimer             [ITimerSink]
//
//  Synopsis:   Get notified of an event which we requested through CTimer's
//              ITimer::Advise*
//
//  Arguments:  timeAdvie - the time that the advise was set.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimerSink::OnTimer( VARIANT vtimeAdvise )
{
    TraceTag((tagExtTimer, "CTimerSink::OnTimer"));
    if ( _pTimer )
        _pTimer->ProcessAdvise();
    return S_OK;
}


/******************************************************************************
                CTimerAdvise
******************************************************************************/
CTimerAdvise::CTimerAdvise()
{
    memset( this, 0, sizeof(CTimerAdvise) );
}

CTimerAdvise::CTimerAdvise( ITimerSink *pTimerSink, DWORD timeMin, DWORD timeMax,
                            DWORD timeInterval, DWORD dwHintFlags )
{
    Assert( pTimerSink );
    _timeMin            = timeMin;
    _timeMax            = timeMax;
    _timeInterval       = timeInterval;
    _NextTick           = timeMin;
    _dwHintFlags        = dwHintFlags;
    _pTimerSink         = pTimerSink;
    _pTimerSink->AddRef();
    _dwCookie           = 0;
    _dwRefCookie        = 0;
    _fDeleteMe          = FALSE;

}

CTimerAdvise::~CTimerAdvise()
{
    int  i;
    i = _pTimerSink->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\triapi.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_TRIAPI_HXX_
#define X_TRIAPI_HXX_
#include "triapi.hxx"
#endif

MtDefine(CTridentAPI, ObjectModel, "CTridentAPI")


HRESULT InternalShowModalDialog( HTMLDLGINFO * pdlgInfo );

CTridentAPI::CTridentAPI()
{
    _ulRefs = 1;
}

STDMETHODIMP CTridentAPI::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    
    if ((IID_IHostDialogHelper == riid) || (IID_IUnknown == riid))
    {
        *ppvObj = (IHostDialogHelper *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObj = NULL;
    }

    return hr;
}

STDMETHODIMP CTridentAPI::ShowHTMLDialog(
                                         HWND hwndParent,
                                         IMoniker *pMk,
                                         VARIANT *pvarArgIn,
                                         WCHAR *pchOptions,
                                         VARIANT *pvarArgOut,
                                         IUnknown *punkHost
                                         )
{
    HTMLDLGINFO dlginfo;
    VARIANT     varOptionStr;

    dlginfo.hwndParent = hwndParent;
    dlginfo.pmk = pMk;
    dlginfo.pvarArgIn = pvarArgIn;

    dlginfo.pvarOptions = &varOptionStr;
    V_BSTR(dlginfo.pvarOptions) = pchOptions;       // fake the variant.
    V_VT(dlginfo.pvarOptions) = VT_BSTR;

    dlginfo.pvarArgOut = pvarArgOut;
    dlginfo.fModeless = FALSE;
    dlginfo.punkHost = punkHost;


    // create modal and trusted dialog
    return InternalShowModalDialog( &dlginfo );  
}


//+------------------------------------------------------------------------
//
//  Function:   CreateTridentAPI
//
//  Synopsis:   Creates a new Trident API helper object to avoid lots of
//              pesky exports.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CreateTridentAPI(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    HRESULT hr;
    
    if (NULL == pUnkOuter)
    {
        CTridentAPI *pTriAPI = new CTridentAPI;

        *ppUnk = pTriAPI;

        hr = pTriAPI ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        *ppUnk = NULL;
        hr = CLASS_E_NOAGGREGATION;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\wndclass.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       wndclass.cxx
//
//  Contents:   Window class utilities
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

static ATOM s_aatomWndClass[WNDCLASS_MAXTYPE];
const TCHAR aszWndClassNames[WNDCLASS_MAXTYPE][32] = {_T("Hidden"),
                                                      _T("Server"),
                                                      _T("TridentDlgFrame"),
                                                      _T("Overlay"),
                                                      _T("TridentCmboBx"),
                                                      _T("TridentLstBox"),
                                                      _T("ActiveMovie") };

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void 
SetWndClassAtom( UINT uIndex, ATOM atomWndClass)
{
    s_aatomWndClass[uIndex] = atomWndClass;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
ATOM
GetWndClassAtom(UINT uIndex)
{
    return s_aatomWndClass[uIndex];
}

//+---------------------------------------------------------------------------
//
//  Function:   Register window class
//
//  Synopsis:   Register a window class.
//
//  Arguments:  wndClassType Type of the window class
//              pfnWndProc   The window procedure.
//              style        Window style flags.
//              pstrBase     Base class name, can be null.
//              ppfnBase     Base class window proc, can be null.
//              patom        Name of registered class.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
RegisterWindowClass(
    UINT      wndClassType,
    LRESULT   (CALLBACK *pfnWndProc)(HWND, UINT, WPARAM, LPARAM),
    UINT      style,
    TCHAR *   pstrBase,
    WNDPROC * ppfnBase,
    HICON     hIconSm /* = NULL */ )
{
    TCHAR       achClass[64];
    WNDCLASSEX  wc;
    ATOM        atom;

    LOCK_GLOBALS;           // Guard access to globals (the passed atom and the atom array)

    // In case another thread registered before this one, we should return with success code
    // although we don't register in here.
    if (GetWndClassAtom(wndClassType))
        return S_OK;

    Verify(OK(Format(0,
            achClass,
            ARRAY_SIZE(achClass),
            _T("Internet Explorer_<0s>"),
            aszWndClassNames[wndClassType])));

    if (pstrBase)
    {
        wc.cbSize = sizeof(wc);

        if (!GetClassInfoEx(NULL, pstrBase, &wc))
            goto Error;

        *ppfnBase = wc.lpfnWndProc;
    }
    else
    {
        memset(&wc, 0, sizeof(wc));
//        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    }

    wc.cbSize = sizeof(wc);
    wc.lpfnWndProc = pfnWndProc;
    wc.lpszClassName = achClass;
    wc.style |= style;
    wc.hInstance = g_hInstCore;
    wc.hIconSm = hIconSm;
#ifdef _MAC
    if (g_fJapanSystem)
    {
        wc.cbWndExtra = sizeof(HIMC);
    } 
#endif

    atom = RegisterClassEx(&wc);
    if (!atom)
        goto Error;

#if defined(_MAC)
    atom = GlobalAddAtom(achClass);
#endif

    // set the entry in the array
    SetWndClassAtom(wndClassType, atom);

    return S_OK;

Error:
    DWORD dwErr = GetLastWin32Error();
    AssertSz(FALSE, "Could not register window class");
    RRETURN(dwErr);
}

#if DBG == 1
extern int g_lSecondaryObjCountCallers[15];
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DeinitWindowClasses
//
//  Synopsis:   Unregister any window classes we have registered.
//
//----------------------------------------------------------------------------

void
DeinitWindowClasses()
{
    int nIndex = WNDCLASS_MAXTYPE;
    
    while (--nIndex >= 0)
    {
#if !defined(_MAC)
        if (GetWndClassAtom(nIndex))
        {
            if (UnregisterClass((TCHAR *)(DWORD_PTR)GetWndClassAtom(nIndex), g_hInstCore))
            {
                // since we unregistered, the value can go now.
                SetWndClassAtom(nIndex, NULL);
            }
#if DBG == 1
            else
            {
                DWORD dwErr;

                dwErr = GetLastWin32Error();

                AssertSz((g_lSecondaryObjCountCallers[9] > 1), "Unable to unregister window class");
            }
#endif
        }
#else
        TCHAR szClassName[255];
        Verify(GlobalGetAtomName(s_aatomWndClass[nIndex], szClassName, sizeof(szClassName)));
        if (UnregisterClass(szClassName, g_hInstCore))
        {
            SetWndClassAtom(nIndex, NULL);
        }
        GlobalDeleteAtom(s_aatomWndClass[nIndex]);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\vmem.cxx ===
//+------------------------------------------------------------------------
//
//  File:       vmem.cxx
//
//  Contents:   Strict memory allocation utilities
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_VMEM_HXX_
#define X_VMEM_HXX_
#include "vmem.hxx"
#endif

//
// VMem allocates memory using the operating system's low-level virtual allocator. It arranges for an
// allocation to start at the very beginning of a page, with a non-accessable page just before it,
// or for it to end at the very end of a page, with a non-accessible page just after it.  The idea is
// to catch memory overwrites quickly.
//
// The layout of an allocation is as follows:
//
//  +--- page VMEMINFO structure
//  |
//  |                 +--- pv if using front-side-strict memory allocations
//  |                 |
//  |                 |                   +--- filled with pattern to detect back-side overwrite
//  v                 v                   v
// +--------+--------+--------+--------+--------+--------+
// |VMEMINFO|   NO   |[User's memory area]XXXXXX|   NO   |
// |        | ACCESS |XXXXXX[User's memory area]| ACCESS |
// +--------+--------+--------+--------+--------+--------+
//                    ^     ^
//                    |     +--- pv if using back-side-strict memory allocations
//                    |
//                    +--- filled with pattern to detect front-side overwrite
//
//

#if defined(SPARC)
#define PAGE_SIZE       8192
#else
#define PAGE_SIZE       4096
#endif

DWORD
VMemQueryProtect(void * pv, DWORD cb)
{
    MEMORY_BASIC_INFORMATION mbi = { 0 };
    VirtualQuery(pv, &mbi, sizeof(mbi));
    return (mbi.Protect ? mbi.Protect : mbi.AllocationProtect);
}

VMEMINFO *
VMemIsValid(void * pv)
{
    VMEMINFO * pvmi;
    BYTE * pb;
    UINT cb;

    if (pv == NULL)
    {
        return NULL;
    }

    pvmi = (VMEMINFO *)(((DWORD_PTR)pv & ~(PAGE_SIZE - 1)) - PAGE_SIZE * 2);

    if (VMemQueryProtect(pvmi, PAGE_SIZE) != PAGE_READONLY)
    {
        AssertSz(FALSE, "VMemIsValid - VMEMINFO page is not marked READONLY");
        return NULL;
    }

    if (pv != pvmi->pv)
    {
        AssertSz(FALSE, "VMemIsValid - VMEMINFO doesn't point back to pv");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE, PAGE_SIZE) != PAGE_NOACCESS)
    {
        AssertSz(FALSE, "VMemIsValid - can't detect first no-access page");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2, pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2) != PAGE_READWRITE)
    {
        AssertSz(FALSE, "VMemIsValid - user memory block is not all writable");
        return NULL;
    }

    if (pvmi->cbFill1)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2;
        cb = pvmi->cbFill1;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x1A)
            {
                AssertSz(FALSE, "VMemIsValid - detected user memory pre-data overwrite");
                return NULL;
            }
        }
    }

    if (pvmi->cbFill2)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb;
        cb = pvmi->cbFill2;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x3A)
            {
                AssertSz(FALSE, "VMemIsValid - detected user memory post-data overwrite");
                return NULL;
            }
        }
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2, PAGE_SIZE) != PAGE_NOACCESS)
    {
        AssertSz(FALSE, "VMemIsValid - can't detect second no-access page");
        return NULL;
    }

    return(pvmi);
}

void *
VMemAlloc(size_t cb, DWORD dwFlags, void * pvUser)
{
    void * pv1, * pv2, * pv3;
    size_t cbUser, cbPage;
    DWORD dwOldProtect;
    VMEMINFO * pvmi;

    if (cb == 0)
    {
        cb = 1;
    }

    if (    (dwFlags & VMEM_BACKSIDESTRICT)
        &&  (dwFlags & VMEM_BACKSIDEALIGN8))
        cbUser = (cb + 7) & ~7;
    else
        cbUser = cb;

    cbPage = (cbUser + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

	pv1 = VirtualAlloc(0, cbPage + PAGE_SIZE * 3, MEM_RESERVE, PAGE_NOACCESS);

    if (pv1 == NULL)
    {
        return(NULL);
    }

	pv2 = VirtualAlloc(pv1, PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

    if (pv2 == NULL)
    {
        return(NULL);
    }

    pvmi          = (VMEMINFO *)pv2;
    pvmi->cb      = cb;
    pvmi->dwFlags = dwFlags;
    pvmi->pvUser  = pvUser;

    pv3 = VirtualAlloc((BYTE *)pv1 + PAGE_SIZE * 2, cbPage, MEM_COMMIT, PAGE_READWRITE);

    if (pv3 == NULL)
    {
        return(NULL);
    }

    if (dwFlags & VMEM_BACKSIDESTRICT)
    {
        pvmi->cbFill1 = cbPage - cbUser;
        pvmi->cbFill2 = cbUser - cb;
    }
    else
    {
        pvmi->cbFill1 = 0;
        pvmi->cbFill2 = cbPage - cbUser;
    }

    Assert(pvmi->cbFill1 + cb + pvmi->cbFill2 == cbPage);

    if (pvmi->cbFill1)
    {
        memset((BYTE *)pv3, 0x1A, pvmi->cbFill1);
    }

    memset((BYTE *)pv3 + pvmi->cbFill1, 0x2A, cb);

    if (pvmi->cbFill2)
    {
        memset((BYTE *)pv3 + pvmi->cbFill1 + cb, 0x3A, pvmi->cbFill2);
    }

    pvmi->pv = (BYTE *)pv3 + pvmi->cbFill1;

    VirtualProtect(pv1, PAGE_SIZE, PAGE_READONLY, &dwOldProtect);

    Assert(VMemIsValid(pvmi->pv));

    return(pvmi->pv);
}

void *
VMemAllocClear(size_t cb, DWORD dwFlags, void * pvUser)
{
    void * pv = VMemAlloc(cb, dwFlags, pvUser);

    if (pv)
    {
        memset(pv, 0, cb);
    }

    return(pv);
}

HRESULT
VMemRealloc(void ** ppv, size_t cb, DWORD dwFlags, void * pvUser)
{
    if (cb == 0)
    {
        VMemFree(*ppv);
        return S_OK;
    }
    else if (*ppv == NULL)
    {
        *ppv = VMemAlloc(cb, dwFlags, pvUser);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }
    else
    {
        void *     pvOld    = *ppv;
        VMEMINFO * pvmiOld  = VMemIsValid(pvOld);
        void *     pvNew;

        if (pvmiOld == NULL)
        {
            return E_OUTOFMEMORY;
        }

        pvNew = VMemAlloc(cb, dwFlags, pvUser);

        if (pvNew == NULL)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(pvNew, pvOld, min(cb, pvmiOld->cb));

        VMemFree(pvOld);

        *ppv = pvNew;
        return S_OK;
    }
}

void
VMemFree(void * pv)
{
    VMEMINFO * pvmi = VMemIsValid(pv);

    if (pvmi)
    {
        Verify(VirtualFree(pvmi, 0, MEM_RELEASE));
    }
}

size_t
VMemGetSize(void * pv)
{
    VMEMINFO * pvmi = VMemIsValid(pv);
    return(pvmi ? pvmi->cb : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\tooltip.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       Tooltip.cxx
//
//  Contents:   Tooltip
//
//  Classes:    CTooltip
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#ifndef X_TOOLTIP_HXX_
#define X_TOOLTIP_HXX_
#include "tooltip.hxx"
#endif

#ifdef UNIX
#  include <windows.h>
#  include <mainwin.h>
#endif

DeclareTag(tagTooltip, "Tooltips", "Tooltip methods");
MtDefine(CTooltip, Utilities, "CTooltip")

//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::CTooltip
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CTooltip::CTooltip()
{
    TraceTag((tagTooltip, "CTooltip::CTooltip"));
}

//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::~CTooltip
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CTooltip::~CTooltip()
{
    TraceTag((tagTooltip, "CTooltip::~CTooltip"));

    if (_hwnd != NULL)
    {
        // NOTE: the presence of some third party controls (see 6383)
        // kill the tooltip window ahead of time.  hence we are conservative
        // here by ensuring that the window still is one.
        Verify(!IsWindow(_hwnd) || DestroyWindow(_hwnd));
        _hwnd = NULL;
    }

}


//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::Init
//
//  Synopsis:   2nd phase constructor
//
//--------------------------------------------------------------------------

HRESULT
CTooltip::Init(HWND hwnd)
{
    HRESULT     hr = S_OK;
    BOOL        fTopMost = GetWindowExStyle(hwnd) & WS_EX_TOPMOST;

    TraceTag((tagTooltip, "CTooltip::Init"));

    InitCommonControls();

    //
    // we only use WS_EX_TOPMOST when trident is in a TOPMOST window
    //

    _hwnd = CreateWindowEx(
#ifdef UNIX
                WS_EX_MW_UNMANAGED_WINDOW,
#else
                fTopMost ? WS_EX_TOPMOST : 0,
#endif
                TOOLTIPS_CLASS,
                NULL,
                fTopMost ? WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP : TTS_NOPREFIX,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                10,
                10,
                hwnd,
                NULL,
                g_hInstCore,
                NULL);

    if (_hwnd == NULL)
    {
        TraceTag((tagTooltip, "CTooltip::Init failed (%x)", hwnd));
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    SendMessage(_hwnd, TTM_SETMAXTIPWIDTH, 0, (LPARAM) (INT) 3*g_uiDisplay.GetResolution().cx);

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::Show
//
//  Synopsis:   Displays the Tooltip.
//
//  Arguments:  szText      Text to display in the Tooltip
//              hwnd        Owner hwnd
//              msg         Message passed to tooltip for precessing
//              prc         Coords of rectangle in which the mouse
//                          should reside to display the Tooltip.  If the
//                          mouse moves out of this rect, the Tooltip will
//                          be brought down.
//              dwCookie    Any value that is used to identify a tooltip
//                          source.  If subsequent calls to FormsShowTooltip
//                          have the same dwCookie, the tooltip isn't
//                          redisplayed (avoiding flashing).  This value
//                          could be a pointer to the source's this ptr,
//                          an index, etc.
//              fRTL        COMPLEXSCRIPT flag indicating if the element
//                          lays out weak/neutral characters right to left
//
//--------------------------------------------------------------------------

void
CTooltip::Show(
    TCHAR * szText,
    HWND hwnd,
    MSG msg,
    RECT * prc,
    DWORD_PTR dwMarkupCookie,
    DWORD_PTR dwCookie,
    BOOL fRTL) // COMPLEXSCRIPT - text is right-to-left reading
{
    TraceTag((tagTooltip, "CTooltip::Show (_hwndOwner:%x; hwnd:%x; dwCookie:%x; msg:%x)", _hwndOwner, hwnd, dwCookie, msg.message));

    // If owner window is diffrent, 
    // create new tooltip window
    if (_hwndOwner != hwnd)
    {
        TraceTag((tagTooltip, "Creating new window _hwndOwner:%x; hwnd:%x; msg:%x", _hwndOwner, hwnd, msg.message));

        if (IsWindow(_hwnd))
            DestroyWindow(_hwnd);

        if (Init(hwnd) != S_OK)
            return;
    }

    // if tool source is different, cookie is different,
    // tooltip text is different, or rectangle is different,
    // delete old tool and create new tool.
    // NOTE: Since pElement is used as the cookie, and multiline elements
    // have disjoint rects, the tooltip will disappear between lines.
    // This doesn't look too annoying. (jbeda)
    if (   _hwndOwner != hwnd
        || _dwCookie != dwCookie 
        || _tcscmp(_cstrText, szText)
        || !EqualRect(prc, &_ti.rect))
    {
        if (_ti.cbSize == sizeof(_ti))
        {
#ifdef UNIX
            SendMessageA(_hwnd, TTM_DELTOOLA, 0, (LPARAM)&_ti);
#else
            SendMessage(_hwnd, TTM_DELTOOL, 0, (LPARAM)&_ti);
#endif
        }

        memset(&_ti, 0, sizeof(_ti));

        // Update text
        _cstrText.Set(szText, _tcslen(szText));

        _ti.cbSize = sizeof(_ti);
        _ti.uFlags = (fRTL ? TTF_RTLREADING | TTF_RIGHT : 0);
        _ti.hwnd = hwnd;
        _ti.uId = (UINT_PTR)dwCookie;
        _ti.rect.left = prc->left;
        _ti.rect.top = prc->top;
        _ti.rect.right = prc->right;
        _ti.rect.bottom = prc->bottom;

#ifdef UNIX
        _ti.lpszText = new char[_tcslen(szText) + 1];

        if ( NULL == _ti.lpszText )
            return;

        WideCharToMultiByte(CP_ACP, NULL, 
                            szText, -1, 
                            _ti.lpszText, _tcslen(szText), 
                            NULL, NULL);
        _ti.lpszText[_tcslen(szText)] = '\0';
        SendMessageA(_hwnd, TTM_ADDTOOLA, 0, (LPARAM)&_ti);

        delete []_ti.lpszText;
        _ti.lpszText = NULL;
#else
        _ti.lpszText = _cstrText;
        SendMessage(_hwnd, TTM_ADDTOOL, 0, (LPARAM)&_ti);
#endif
    }

    SendMessage(_hwnd, TTM_RELAYEVENT, 0, (LPARAM)&msg);
    SendMessage(_hwnd, TTM_ACTIVATE, (WPARAM) (BOOL) TRUE, 0);

    _hwndOwner      = hwnd;
    _dwMarkupCookie = dwMarkupCookie;
    _dwCookie       = dwCookie;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::Hide
//
//  Synopsis:   Hides the Tooltip window.
//
//--------------------------------------------------------------------------

void
CTooltip::Hide(DWORD_PTR dwMarkupCookie /* = NULL */)
{
    if (!dwMarkupCookie || (_dwMarkupCookie == dwMarkupCookie) )
    {
        TraceTag((tagTooltip, "CTooltip::Hide"));
        SendMessage(_hwnd, TTM_ACTIVATE, (WPARAM) (BOOL) FALSE, 0);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   EnsureInit
//
//  Synopsis:   Static helper for initializing the tooltip code.
//
//--------------------------------------------------------------------------

static HRESULT
EnsureInit(void)
{
    THREADSTATE *   pts;
    HRESULT         hr = S_OK;

    pts = GetThreadState();

    if (pts->pTT == NULL)
    {
        pts->pTT = new CTooltip;
        if (!pts->pTT)
        {
            Assert(0 && "Failed to create Tooltip object.");
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     FormsShowTooltip
//
//  Synopsis:   Displays the Tooltip.
//
//  Arguments:  szText      Text to display in the Tooltip
//              hwnd        Owner hwnd
//              msg         Message passed to tooltip for precessing
//              prc         Coords of rectangle in which the mouse
//                          should reside to display the Tooltip.  If the
//                          mouse moves out of this rect, the Tooltip will
//                          be brought down.
//              dwCookie    Any value that is used to identify a tooltip
//                          source.  If subsequent calls to FormsShowTooltip
//                          have the same dwCookie, the tooltip isn't
//                          redisplayed (avoiding flashing).  This value
//                          could be a pointer to the source's this ptr,
//                          an index, etc.
//              fRTL        COMPLEXSCRIPT flag indicating if the element
//                          lays out weak/neutral characters right to left
//
//--------------------------------------------------------------------------

void
FormsShowTooltip(
    TCHAR * szText,
    HWND hwnd,
    MSG msg,
    RECT * prc,
    DWORD_PTR dwMarkupCookie,
    DWORD_PTR dwCookie,
    BOOL fRTL)
{
    HRESULT hr;

    hr = EnsureInit();
    if (hr)
        return;

    TLS(pTT)->Show(szText, hwnd, msg,  prc, dwMarkupCookie, dwCookie, fRTL);
}


//+-------------------------------------------------------------------------
//
//  Method:     FormsHideTooltip
//
//  Synopsis:   Forces the Tooltip to be brought down.
//
//  Arguments:  [fReset]    If true, cause the tooltip code to reset
//                          the cookie value.  Use FALSE, for example, when
//                          you dismiss the tooltip due to a click.  In this
//                          case you wouldn't want the tooltip to reappear
//                          if the mouse is still in the region.
//
//--------------------------------------------------------------------------

void
FormsHideTooltip(DWORD_PTR dwMarkupCookie /* = NULL */)
{
    if (TLS(pTT))
    {
        TLS(pTT)->Hide(dwMarkupCookie);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     FormsTooltipMessage
//
//  Synopsis:   Allows the tooltip code to dismiss the tooltip based on
//              a window message.  Centralizing the code here keeps clients
//              from having to remember the dismissal rules themselves.
//
//  Returns:    TRUE if the message type is one that would dismiss the
//              tooltip.
//
//--------------------------------------------------------------------------

BOOL
FormsTooltipMessage(UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHide = FALSE;

    switch (msg)
    {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:

    case WM_KEYUP:
    case WM_KEYDOWN:
    case WM_CONTEXTMENU:
#if !defined(UNIX)
    case WM_MOUSEWHEEL:
#endif 
        fHide = TRUE;
        break;

    case WM_SETCURSOR:
        switch (HIWORD(lParam))
        {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            fHide = TRUE;
            break;

        default:
            break;
        }

    default:
        break;
    }

    if (fHide)
    {
        TraceTag((tagTooltip, "FormsTooltipMessage (msg:%x)", msg));
        FormsHideTooltip();
    }

    return fHide;
}



//+-------------------------------------------------------------------------
//
//  Function:   DeinitTooltip
//
//--------------------------------------------------------------------------
void
DeinitTooltip(
    THREADSTATE *   pts)
{
    Assert(pts);

    if (pts->pTT)
    {
        delete pts->pTT;
        pts->pTT = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\thunks_s.h ===
// THUNK_S_<line number> ( <n> ), where linenum is 1-20 and n is 16-199

THUNK_S_1(16)
THUNK_S_2(16)
THUNK_S_3(16)
THUNK_S_4(16)
THUNK_S_5(16)
THUNK_S_6(16)
THUNK_S_7(16)
THUNK_S_8(16)
THUNK_S_9(16)
THUNK_S_10(16)
THUNK_S_11(16)
THUNK_S_12(16)
THUNK_S_13(16)
THUNK_S_14(16)
THUNK_S_15(16)
THUNK_S_16(16)
THUNK_S_17(16)
THUNK_S_18(16)
THUNK_S_19(16)
THUNK_S_20(16)
THUNK_S_1(17)
THUNK_S_2(17)
THUNK_S_3(17)
THUNK_S_4(17)
THUNK_S_5(17)
THUNK_S_6(17)
THUNK_S_7(17)
THUNK_S_8(17)
THUNK_S_9(17)
THUNK_S_10(17)
THUNK_S_11(17)
THUNK_S_12(17)
THUNK_S_13(17)
THUNK_S_14(17)
THUNK_S_15(17)
THUNK_S_16(17)
THUNK_S_17(17)
THUNK_S_18(17)
THUNK_S_19(17)
THUNK_S_20(17)
THUNK_S_1(18)
THUNK_S_2(18)
THUNK_S_3(18)
THUNK_S_4(18)
THUNK_S_5(18)
THUNK_S_6(18)
THUNK_S_7(18)
THUNK_S_8(18)
THUNK_S_9(18)
THUNK_S_10(18)
THUNK_S_11(18)
THUNK_S_12(18)
THUNK_S_13(18)
THUNK_S_14(18)
THUNK_S_15(18)
THUNK_S_16(18)
THUNK_S_17(18)
THUNK_S_18(18)
THUNK_S_19(18)
THUNK_S_20(18)
THUNK_S_1(19)
THUNK_S_2(19)
THUNK_S_3(19)
THUNK_S_4(19)
THUNK_S_5(19)
THUNK_S_6(19)
THUNK_S_7(19)
THUNK_S_8(19)
THUNK_S_9(19)
THUNK_S_10(19)
THUNK_S_11(19)
THUNK_S_12(19)
THUNK_S_13(19)
THUNK_S_14(19)
THUNK_S_15(19)
THUNK_S_16(19)
THUNK_S_17(19)
THUNK_S_18(19)
THUNK_S_19(19)
THUNK_S_20(19)
THUNK_S_1(20)
THUNK_S_2(20)
THUNK_S_3(20)
THUNK_S_4(20)
THUNK_S_5(20)
THUNK_S_6(20)
THUNK_S_7(20)
THUNK_S_8(20)
THUNK_S_9(20)
THUNK_S_10(20)
THUNK_S_11(20)
THUNK_S_12(20)
THUNK_S_13(20)
THUNK_S_14(20)
THUNK_S_15(20)
THUNK_S_16(20)
THUNK_S_17(20)
THUNK_S_18(20)
THUNK_S_19(20)
THUNK_S_20(20)
THUNK_S_1(21)
THUNK_S_2(21)
THUNK_S_3(21)
THUNK_S_4(21)
THUNK_S_5(21)
THUNK_S_6(21)
THUNK_S_7(21)
THUNK_S_8(21)
THUNK_S_9(21)
THUNK_S_10(21)
THUNK_S_11(21)
THUNK_S_12(21)
THUNK_S_13(21)
THUNK_S_14(21)
THUNK_S_15(21)
THUNK_S_16(21)
THUNK_S_17(21)
THUNK_S_18(21)
THUNK_S_19(21)
THUNK_S_20(21)
THUNK_S_1(22)
THUNK_S_2(22)
THUNK_S_3(22)
THUNK_S_4(22)
THUNK_S_5(22)
THUNK_S_6(22)
THUNK_S_7(22)
THUNK_S_8(22)
THUNK_S_9(22)
THUNK_S_10(22)
THUNK_S_11(22)
THUNK_S_12(22)
THUNK_S_13(22)
THUNK_S_14(22)
THUNK_S_15(22)
THUNK_S_16(22)
THUNK_S_17(22)
THUNK_S_18(22)
THUNK_S_19(22)
THUNK_S_20(22)
THUNK_S_1(23)
THUNK_S_2(23)
THUNK_S_3(23)
THUNK_S_4(23)
THUNK_S_5(23)
THUNK_S_6(23)
THUNK_S_7(23)
THUNK_S_8(23)
THUNK_S_9(23)
THUNK_S_10(23)
THUNK_S_11(23)
THUNK_S_12(23)
THUNK_S_13(23)
THUNK_S_14(23)
THUNK_S_15(23)
THUNK_S_16(23)
THUNK_S_17(23)
THUNK_S_18(23)
THUNK_S_19(23)
THUNK_S_20(23)
THUNK_S_1(24)
THUNK_S_2(24)
THUNK_S_3(24)
THUNK_S_4(24)
THUNK_S_5(24)
THUNK_S_6(24)
THUNK_S_7(24)
THUNK_S_8(24)
THUNK_S_9(24)
THUNK_S_10(24)
THUNK_S_11(24)
THUNK_S_12(24)
THUNK_S_13(24)
THUNK_S_14(24)
THUNK_S_15(24)
THUNK_S_16(24)
THUNK_S_17(24)
THUNK_S_18(24)
THUNK_S_19(24)
THUNK_S_20(24)
THUNK_S_1(25)
THUNK_S_2(25)
THUNK_S_3(25)
THUNK_S_4(25)
THUNK_S_5(25)
THUNK_S_6(25)
THUNK_S_7(25)
THUNK_S_8(25)
THUNK_S_9(25)
THUNK_S_10(25)
THUNK_S_11(25)
THUNK_S_12(25)
THUNK_S_13(25)
THUNK_S_14(25)
THUNK_S_15(25)
THUNK_S_16(25)
THUNK_S_17(25)
THUNK_S_18(25)
THUNK_S_19(25)
THUNK_S_20(25)
THUNK_S_1(26)
THUNK_S_2(26)
THUNK_S_3(26)
THUNK_S_4(26)
THUNK_S_5(26)
THUNK_S_6(26)
THUNK_S_7(26)
THUNK_S_8(26)
THUNK_S_9(26)
THUNK_S_10(26)
THUNK_S_11(26)
THUNK_S_12(26)
THUNK_S_13(26)
THUNK_S_14(26)
THUNK_S_15(26)
THUNK_S_16(26)
THUNK_S_17(26)
THUNK_S_18(26)
THUNK_S_19(26)
THUNK_S_20(26)
THUNK_S_1(27)
THUNK_S_2(27)
THUNK_S_3(27)
THUNK_S_4(27)
THUNK_S_5(27)
THUNK_S_6(27)
THUNK_S_7(27)
THUNK_S_8(27)
THUNK_S_9(27)
THUNK_S_10(27)
THUNK_S_11(27)
THUNK_S_12(27)
THUNK_S_13(27)
THUNK_S_14(27)
THUNK_S_15(27)
THUNK_S_16(27)
THUNK_S_17(27)
THUNK_S_18(27)
THUNK_S_19(27)
THUNK_S_20(27)
THUNK_S_1(28)
THUNK_S_2(28)
THUNK_S_3(28)
THUNK_S_4(28)
THUNK_S_5(28)
THUNK_S_6(28)
THUNK_S_7(28)
THUNK_S_8(28)
THUNK_S_9(28)
THUNK_S_10(28)
THUNK_S_11(28)
THUNK_S_12(28)
THUNK_S_13(28)
THUNK_S_14(28)
THUNK_S_15(28)
THUNK_S_16(28)
THUNK_S_17(28)
THUNK_S_18(28)
THUNK_S_19(28)
THUNK_S_20(28)
THUNK_S_1(29)
THUNK_S_2(29)
THUNK_S_3(29)
THUNK_S_4(29)
THUNK_S_5(29)
THUNK_S_6(29)
THUNK_S_7(29)
THUNK_S_8(29)
THUNK_S_9(29)
THUNK_S_10(29)
THUNK_S_11(29)
THUNK_S_12(29)
THUNK_S_13(29)
THUNK_S_14(29)
THUNK_S_15(29)
THUNK_S_16(29)
THUNK_S_17(29)
THUNK_S_18(29)
THUNK_S_19(29)
THUNK_S_20(29)
THUNK_S_1(30)
THUNK_S_2(30)
THUNK_S_3(30)
THUNK_S_4(30)
THUNK_S_5(30)
THUNK_S_6(30)
THUNK_S_7(30)
THUNK_S_8(30)
THUNK_S_9(30)
THUNK_S_10(30)
THUNK_S_11(30)
THUNK_S_12(30)
THUNK_S_13(30)
THUNK_S_14(30)
THUNK_S_15(30)
THUNK_S_16(30)
THUNK_S_17(30)
THUNK_S_18(30)
THUNK_S_19(30)
THUNK_S_20(30)
THUNK_S_1(31)
THUNK_S_2(31)
THUNK_S_3(31)
THUNK_S_4(31)
THUNK_S_5(31)
THUNK_S_6(31)
THUNK_S_7(31)
THUNK_S_8(31)
THUNK_S_9(31)
THUNK_S_10(31)
THUNK_S_11(31)
THUNK_S_12(31)
THUNK_S_13(31)
THUNK_S_14(31)
THUNK_S_15(31)
THUNK_S_16(31)
THUNK_S_17(31)
THUNK_S_18(31)
THUNK_S_19(31)
THUNK_S_20(31)
THUNK_S_1(32)
THUNK_S_2(32)
THUNK_S_3(32)
THUNK_S_4(32)
THUNK_S_5(32)
THUNK_S_6(32)
THUNK_S_7(32)
THUNK_S_8(32)
THUNK_S_9(32)
THUNK_S_10(32)
THUNK_S_11(32)
THUNK_S_12(32)
THUNK_S_13(32)
THUNK_S_14(32)
THUNK_S_15(32)
THUNK_S_16(32)
THUNK_S_17(32)
THUNK_S_18(32)
THUNK_S_19(32)
THUNK_S_20(32)
THUNK_S_1(33)
THUNK_S_2(33)
THUNK_S_3(33)
THUNK_S_4(33)
THUNK_S_5(33)
THUNK_S_6(33)
THUNK_S_7(33)
THUNK_S_8(33)
THUNK_S_9(33)
THUNK_S_10(33)
THUNK_S_11(33)
THUNK_S_12(33)
THUNK_S_13(33)
THUNK_S_14(33)
THUNK_S_15(33)
THUNK_S_16(33)
THUNK_S_17(33)
THUNK_S_18(33)
THUNK_S_19(33)
THUNK_S_20(33)
THUNK_S_1(34)
THUNK_S_2(34)
THUNK_S_3(34)
THUNK_S_4(34)
THUNK_S_5(34)
THUNK_S_6(34)
THUNK_S_7(34)
THUNK_S_8(34)
THUNK_S_9(34)
THUNK_S_10(34)
THUNK_S_11(34)
THUNK_S_12(34)
THUNK_S_13(34)
THUNK_S_14(34)
THUNK_S_15(34)
THUNK_S_16(34)
THUNK_S_17(34)
THUNK_S_18(34)
THUNK_S_19(34)
THUNK_S_20(34)
THUNK_S_1(35)
THUNK_S_2(35)
THUNK_S_3(35)
THUNK_S_4(35)
THUNK_S_5(35)
THUNK_S_6(35)
THUNK_S_7(35)
THUNK_S_8(35)
THUNK_S_9(35)
THUNK_S_10(35)
THUNK_S_11(35)
THUNK_S_12(35)
THUNK_S_13(35)
THUNK_S_14(35)
THUNK_S_15(35)
THUNK_S_16(35)
THUNK_S_17(35)
THUNK_S_18(35)
THUNK_S_19(35)
THUNK_S_20(35)
THUNK_S_1(36)
THUNK_S_2(36)
THUNK_S_3(36)
THUNK_S_4(36)
THUNK_S_5(36)
THUNK_S_6(36)
THUNK_S_7(36)
THUNK_S_8(36)
THUNK_S_9(36)
THUNK_S_10(36)
THUNK_S_11(36)
THUNK_S_12(36)
THUNK_S_13(36)
THUNK_S_14(36)
THUNK_S_15(36)
THUNK_S_16(36)
THUNK_S_17(36)
THUNK_S_18(36)
THUNK_S_19(36)
THUNK_S_20(36)
THUNK_S_1(37)
THUNK_S_2(37)
THUNK_S_3(37)
THUNK_S_4(37)
THUNK_S_5(37)
THUNK_S_6(37)
THUNK_S_7(37)
THUNK_S_8(37)
THUNK_S_9(37)
THUNK_S_10(37)
THUNK_S_11(37)
THUNK_S_12(37)
THUNK_S_13(37)
THUNK_S_14(37)
THUNK_S_15(37)
THUNK_S_16(37)
THUNK_S_17(37)
THUNK_S_18(37)
THUNK_S_19(37)
THUNK_S_20(37)
THUNK_S_1(38)
THUNK_S_2(38)
THUNK_S_3(38)
THUNK_S_4(38)
THUNK_S_5(38)
THUNK_S_6(38)
THUNK_S_7(38)
THUNK_S_8(38)
THUNK_S_9(38)
THUNK_S_10(38)
THUNK_S_11(38)
THUNK_S_12(38)
THUNK_S_13(38)
THUNK_S_14(38)
THUNK_S_15(38)
THUNK_S_16(38)
THUNK_S_17(38)
THUNK_S_18(38)
THUNK_S_19(38)
THUNK_S_20(38)
THUNK_S_1(39)
THUNK_S_2(39)
THUNK_S_3(39)
THUNK_S_4(39)
THUNK_S_5(39)
THUNK_S_6(39)
THUNK_S_7(39)
THUNK_S_8(39)
THUNK_S_9(39)
THUNK_S_10(39)
THUNK_S_11(39)
THUNK_S_12(39)
THUNK_S_13(39)
THUNK_S_14(39)
THUNK_S_15(39)
THUNK_S_16(39)
THUNK_S_17(39)
THUNK_S_18(39)
THUNK_S_19(39)
THUNK_S_20(39)
THUNK_S_1(40)
THUNK_S_2(40)
THUNK_S_3(40)
THUNK_S_4(40)
THUNK_S_5(40)
THUNK_S_6(40)
THUNK_S_7(40)
THUNK_S_8(40)
THUNK_S_9(40)
THUNK_S_10(40)
THUNK_S_11(40)
THUNK_S_12(40)
THUNK_S_13(40)
THUNK_S_14(40)
THUNK_S_15(40)
THUNK_S_16(40)
THUNK_S_17(40)
THUNK_S_18(40)
THUNK_S_19(40)
THUNK_S_20(40)
THUNK_S_1(41)
THUNK_S_2(41)
THUNK_S_3(41)
THUNK_S_4(41)
THUNK_S_5(41)
THUNK_S_6(41)
THUNK_S_7(41)
THUNK_S_8(41)
THUNK_S_9(41)
THUNK_S_10(41)
THUNK_S_11(41)
THUNK_S_12(41)
THUNK_S_13(41)
THUNK_S_14(41)
THUNK_S_15(41)
THUNK_S_16(41)
THUNK_S_17(41)
THUNK_S_18(41)
THUNK_S_19(41)
THUNK_S_20(41)
THUNK_S_1(42)
THUNK_S_2(42)
THUNK_S_3(42)
THUNK_S_4(42)
THUNK_S_5(42)
THUNK_S_6(42)
THUNK_S_7(42)
THUNK_S_8(42)
THUNK_S_9(42)
THUNK_S_10(42)
THUNK_S_11(42)
THUNK_S_12(42)
THUNK_S_13(42)
THUNK_S_14(42)
THUNK_S_15(42)
THUNK_S_16(42)
THUNK_S_17(42)
THUNK_S_18(42)
THUNK_S_19(42)
THUNK_S_20(42)
THUNK_S_1(43)
THUNK_S_2(43)
THUNK_S_3(43)
THUNK_S_4(43)
THUNK_S_5(43)
THUNK_S_6(43)
THUNK_S_7(43)
THUNK_S_8(43)
THUNK_S_9(43)
THUNK_S_10(43)
THUNK_S_11(43)
THUNK_S_12(43)
THUNK_S_13(43)
THUNK_S_14(43)
THUNK_S_15(43)
THUNK_S_16(43)
THUNK_S_17(43)
THUNK_S_18(43)
THUNK_S_19(43)
THUNK_S_20(43)
THUNK_S_1(44)
THUNK_S_2(44)
THUNK_S_3(44)
THUNK_S_4(44)
THUNK_S_5(44)
THUNK_S_6(44)
THUNK_S_7(44)
THUNK_S_8(44)
THUNK_S_9(44)
THUNK_S_10(44)
THUNK_S_11(44)
THUNK_S_12(44)
THUNK_S_13(44)
THUNK_S_14(44)
THUNK_S_15(44)
THUNK_S_16(44)
THUNK_S_17(44)
THUNK_S_18(44)
THUNK_S_19(44)
THUNK_S_20(44)
THUNK_S_1(45)
THUNK_S_2(45)
THUNK_S_3(45)
THUNK_S_4(45)
THUNK_S_5(45)
THUNK_S_6(45)
THUNK_S_7(45)
THUNK_S_8(45)
THUNK_S_9(45)
THUNK_S_10(45)
THUNK_S_11(45)
THUNK_S_12(45)
THUNK_S_13(45)
THUNK_S_14(45)
THUNK_S_15(45)
THUNK_S_16(45)
THUNK_S_17(45)
THUNK_S_18(45)
THUNK_S_19(45)
THUNK_S_20(45)
THUNK_S_1(46)
THUNK_S_2(46)
THUNK_S_3(46)
THUNK_S_4(46)
THUNK_S_5(46)
THUNK_S_6(46)
THUNK_S_7(46)
THUNK_S_8(46)
THUNK_S_9(46)
THUNK_S_10(46)
THUNK_S_11(46)
THUNK_S_12(46)
THUNK_S_13(46)
THUNK_S_14(46)
THUNK_S_15(46)
THUNK_S_16(46)
THUNK_S_17(46)
THUNK_S_18(46)
THUNK_S_19(46)
THUNK_S_20(46)
THUNK_S_1(47)
THUNK_S_2(47)
THUNK_S_3(47)
THUNK_S_4(47)
THUNK_S_5(47)
THUNK_S_6(47)
THUNK_S_7(47)
THUNK_S_8(47)
THUNK_S_9(47)
THUNK_S_10(47)
THUNK_S_11(47)
THUNK_S_12(47)
THUNK_S_13(47)
THUNK_S_14(47)
THUNK_S_15(47)
THUNK_S_16(47)
THUNK_S_17(47)
THUNK_S_18(47)
THUNK_S_19(47)
THUNK_S_20(47)
THUNK_S_1(48)
THUNK_S_2(48)
THUNK_S_3(48)
THUNK_S_4(48)
THUNK_S_5(48)
THUNK_S_6(48)
THUNK_S_7(48)
THUNK_S_8(48)
THUNK_S_9(48)
THUNK_S_10(48)
THUNK_S_11(48)
THUNK_S_12(48)
THUNK_S_13(48)
THUNK_S_14(48)
THUNK_S_15(48)
THUNK_S_16(48)
THUNK_S_17(48)
THUNK_S_18(48)
THUNK_S_19(48)
THUNK_S_20(48)
THUNK_S_1(49)
THUNK_S_2(49)
THUNK_S_3(49)
THUNK_S_4(49)
THUNK_S_5(49)
THUNK_S_6(49)
THUNK_S_7(49)
THUNK_S_8(49)
THUNK_S_9(49)
THUNK_S_10(49)
THUNK_S_11(49)
THUNK_S_12(49)
THUNK_S_13(49)
THUNK_S_14(49)
THUNK_S_15(49)
THUNK_S_16(49)
THUNK_S_17(49)
THUNK_S_18(49)
THUNK_S_19(49)
THUNK_S_20(49)
THUNK_S_1(50)
THUNK_S_2(50)
THUNK_S_3(50)
THUNK_S_4(50)
THUNK_S_5(50)
THUNK_S_6(50)
THUNK_S_7(50)
THUNK_S_8(50)
THUNK_S_9(50)
THUNK_S_10(50)
THUNK_S_11(50)
THUNK_S_12(50)
THUNK_S_13(50)
THUNK_S_14(50)
THUNK_S_15(50)
THUNK_S_16(50)
THUNK_S_17(50)
THUNK_S_18(50)
THUNK_S_19(50)
THUNK_S_20(50)
THUNK_S_1(51)
THUNK_S_2(51)
THUNK_S_3(51)
THUNK_S_4(51)
THUNK_S_5(51)
THUNK_S_6(51)
THUNK_S_7(51)
THUNK_S_8(51)
THUNK_S_9(51)
THUNK_S_10(51)
THUNK_S_11(51)
THUNK_S_12(51)
THUNK_S_13(51)
THUNK_S_14(51)
THUNK_S_15(51)
THUNK_S_16(51)
THUNK_S_17(51)
THUNK_S_18(51)
THUNK_S_19(51)
THUNK_S_20(51)
THUNK_S_1(52)
THUNK_S_2(52)
THUNK_S_3(52)
THUNK_S_4(52)
THUNK_S_5(52)
THUNK_S_6(52)
THUNK_S_7(52)
THUNK_S_8(52)
THUNK_S_9(52)
THUNK_S_10(52)
THUNK_S_11(52)
THUNK_S_12(52)
THUNK_S_13(52)
THUNK_S_14(52)
THUNK_S_15(52)
THUNK_S_16(52)
THUNK_S_17(52)
THUNK_S_18(52)
THUNK_S_19(52)
THUNK_S_20(52)
THUNK_S_1(53)
THUNK_S_2(53)
THUNK_S_3(53)
THUNK_S_4(53)
THUNK_S_5(53)
THUNK_S_6(53)
THUNK_S_7(53)
THUNK_S_8(53)
THUNK_S_9(53)
THUNK_S_10(53)
THUNK_S_11(53)
THUNK_S_12(53)
THUNK_S_13(53)
THUNK_S_14(53)
THUNK_S_15(53)
THUNK_S_16(53)
THUNK_S_17(53)
THUNK_S_18(53)
THUNK_S_19(53)
THUNK_S_20(53)
THUNK_S_1(54)
THUNK_S_2(54)
THUNK_S_3(54)
THUNK_S_4(54)
THUNK_S_5(54)
THUNK_S_6(54)
THUNK_S_7(54)
THUNK_S_8(54)
THUNK_S_9(54)
THUNK_S_10(54)
THUNK_S_11(54)
THUNK_S_12(54)
THUNK_S_13(54)
THUNK_S_14(54)
THUNK_S_15(54)
THUNK_S_16(54)
THUNK_S_17(54)
THUNK_S_18(54)
THUNK_S_19(54)
THUNK_S_20(54)
THUNK_S_1(55)
THUNK_S_2(55)
THUNK_S_3(55)
THUNK_S_4(55)
THUNK_S_5(55)
THUNK_S_6(55)
THUNK_S_7(55)
THUNK_S_8(55)
THUNK_S_9(55)
THUNK_S_10(55)
THUNK_S_11(55)
THUNK_S_12(55)
THUNK_S_13(55)
THUNK_S_14(55)
THUNK_S_15(55)
THUNK_S_16(55)
THUNK_S_17(55)
THUNK_S_18(55)
THUNK_S_19(55)
THUNK_S_20(55)
THUNK_S_1(56)
THUNK_S_2(56)
THUNK_S_3(56)
THUNK_S_4(56)
THUNK_S_5(56)
THUNK_S_6(56)
THUNK_S_7(56)
THUNK_S_8(56)
THUNK_S_9(56)
THUNK_S_10(56)
THUNK_S_11(56)
THUNK_S_12(56)
THUNK_S_13(56)
THUNK_S_14(56)
THUNK_S_15(56)
THUNK_S_16(56)
THUNK_S_17(56)
THUNK_S_18(56)
THUNK_S_19(56)
THUNK_S_20(56)
THUNK_S_1(57)
THUNK_S_2(57)
THUNK_S_3(57)
THUNK_S_4(57)
THUNK_S_5(57)
THUNK_S_6(57)
THUNK_S_7(57)
THUNK_S_8(57)
THUNK_S_9(57)
THUNK_S_10(57)
THUNK_S_11(57)
THUNK_S_12(57)
THUNK_S_13(57)
THUNK_S_14(57)
THUNK_S_15(57)
THUNK_S_16(57)
THUNK_S_17(57)
THUNK_S_18(57)
THUNK_S_19(57)
THUNK_S_20(57)
THUNK_S_1(58)
THUNK_S_2(58)
THUNK_S_3(58)
THUNK_S_4(58)
THUNK_S_5(58)
THUNK_S_6(58)
THUNK_S_7(58)
THUNK_S_8(58)
THUNK_S_9(58)
THUNK_S_10(58)
THUNK_S_11(58)
THUNK_S_12(58)
THUNK_S_13(58)
THUNK_S_14(58)
THUNK_S_15(58)
THUNK_S_16(58)
THUNK_S_17(58)
THUNK_S_18(58)
THUNK_S_19(58)
THUNK_S_20(58)
THUNK_S_1(59)
THUNK_S_2(59)
THUNK_S_3(59)
THUNK_S_4(59)
THUNK_S_5(59)
THUNK_S_6(59)
THUNK_S_7(59)
THUNK_S_8(59)
THUNK_S_9(59)
THUNK_S_10(59)
THUNK_S_11(59)
THUNK_S_12(59)
THUNK_S_13(59)
THUNK_S_14(59)
THUNK_S_15(59)
THUNK_S_16(59)
THUNK_S_17(59)
THUNK_S_18(59)
THUNK_S_19(59)
THUNK_S_20(59)
THUNK_S_1(60)
THUNK_S_2(60)
THUNK_S_3(60)
THUNK_S_4(60)
THUNK_S_5(60)
THUNK_S_6(60)
THUNK_S_7(60)
THUNK_S_8(60)
THUNK_S_9(60)
THUNK_S_10(60)
THUNK_S_11(60)
THUNK_S_12(60)
THUNK_S_13(60)
THUNK_S_14(60)
THUNK_S_15(60)
THUNK_S_16(60)
THUNK_S_17(60)
THUNK_S_18(60)
THUNK_S_19(60)
THUNK_S_20(60)
THUNK_S_1(61)
THUNK_S_2(61)
THUNK_S_3(61)
THUNK_S_4(61)
THUNK_S_5(61)
THUNK_S_6(61)
THUNK_S_7(61)
THUNK_S_8(61)
THUNK_S_9(61)
THUNK_S_10(61)
THUNK_S_11(61)
THUNK_S_12(61)
THUNK_S_13(61)
THUNK_S_14(61)
THUNK_S_15(61)
THUNK_S_16(61)
THUNK_S_17(61)
THUNK_S_18(61)
THUNK_S_19(61)
THUNK_S_20(61)
THUNK_S_1(62)
THUNK_S_2(62)
THUNK_S_3(62)
THUNK_S_4(62)
THUNK_S_5(62)
THUNK_S_6(62)
THUNK_S_7(62)
THUNK_S_8(62)
THUNK_S_9(62)
THUNK_S_10(62)
THUNK_S_11(62)
THUNK_S_12(62)
THUNK_S_13(62)
THUNK_S_14(62)
THUNK_S_15(62)
THUNK_S_16(62)
THUNK_S_17(62)
THUNK_S_18(62)
THUNK_S_19(62)
THUNK_S_20(62)
THUNK_S_1(63)
THUNK_S_2(63)
THUNK_S_3(63)
THUNK_S_4(63)
THUNK_S_5(63)
THUNK_S_6(63)
THUNK_S_7(63)
THUNK_S_8(63)
THUNK_S_9(63)
THUNK_S_10(63)
THUNK_S_11(63)
THUNK_S_12(63)
THUNK_S_13(63)
THUNK_S_14(63)
THUNK_S_15(63)
THUNK_S_16(63)
THUNK_S_17(63)
THUNK_S_18(63)
THUNK_S_19(63)
THUNK_S_20(63)
THUNK_S_1(64)
THUNK_S_2(64)
THUNK_S_3(64)
THUNK_S_4(64)
THUNK_S_5(64)
THUNK_S_6(64)
THUNK_S_7(64)
THUNK_S_8(64)
THUNK_S_9(64)
THUNK_S_10(64)
THUNK_S_11(64)
THUNK_S_12(64)
THUNK_S_13(64)
THUNK_S_14(64)
THUNK_S_15(64)
THUNK_S_16(64)
THUNK_S_17(64)
THUNK_S_18(64)
THUNK_S_19(64)
THUNK_S_20(64)
THUNK_S_1(65)
THUNK_S_2(65)
THUNK_S_3(65)
THUNK_S_4(65)
THUNK_S_5(65)
THUNK_S_6(65)
THUNK_S_7(65)
THUNK_S_8(65)
THUNK_S_9(65)
THUNK_S_10(65)
THUNK_S_11(65)
THUNK_S_12(65)
THUNK_S_13(65)
THUNK_S_14(65)
THUNK_S_15(65)
THUNK_S_16(65)
THUNK_S_17(65)
THUNK_S_18(65)
THUNK_S_19(65)
THUNK_S_20(65)
THUNK_S_1(66)
THUNK_S_2(66)
THUNK_S_3(66)
THUNK_S_4(66)
THUNK_S_5(66)
THUNK_S_6(66)
THUNK_S_7(66)
THUNK_S_8(66)
THUNK_S_9(66)
THUNK_S_10(66)
THUNK_S_11(66)
THUNK_S_12(66)
THUNK_S_13(66)
THUNK_S_14(66)
THUNK_S_15(66)
THUNK_S_16(66)
THUNK_S_17(66)
THUNK_S_18(66)
THUNK_S_19(66)
THUNK_S_20(66)
THUNK_S_1(67)
THUNK_S_2(67)
THUNK_S_3(67)
THUNK_S_4(67)
THUNK_S_5(67)
THUNK_S_6(67)
THUNK_S_7(67)
THUNK_S_8(67)
THUNK_S_9(67)
THUNK_S_10(67)
THUNK_S_11(67)
THUNK_S_12(67)
THUNK_S_13(67)
THUNK_S_14(67)
THUNK_S_15(67)
THUNK_S_16(67)
THUNK_S_17(67)
THUNK_S_18(67)
THUNK_S_19(67)
THUNK_S_20(67)
THUNK_S_1(68)
THUNK_S_2(68)
THUNK_S_3(68)
THUNK_S_4(68)
THUNK_S_5(68)
THUNK_S_6(68)
THUNK_S_7(68)
THUNK_S_8(68)
THUNK_S_9(68)
THUNK_S_10(68)
THUNK_S_11(68)
THUNK_S_12(68)
THUNK_S_13(68)
THUNK_S_14(68)
THUNK_S_15(68)
THUNK_S_16(68)
THUNK_S_17(68)
THUNK_S_18(68)
THUNK_S_19(68)
THUNK_S_20(68)
THUNK_S_1(69)
THUNK_S_2(69)
THUNK_S_3(69)
THUNK_S_4(69)
THUNK_S_5(69)
THUNK_S_6(69)
THUNK_S_7(69)
THUNK_S_8(69)
THUNK_S_9(69)
THUNK_S_10(69)
THUNK_S_11(69)
THUNK_S_12(69)
THUNK_S_13(69)
THUNK_S_14(69)
THUNK_S_15(69)
THUNK_S_16(69)
THUNK_S_17(69)
THUNK_S_18(69)
THUNK_S_19(69)
THUNK_S_20(69)
THUNK_S_1(70)
THUNK_S_2(70)
THUNK_S_3(70)
THUNK_S_4(70)
THUNK_S_5(70)
THUNK_S_6(70)
THUNK_S_7(70)
THUNK_S_8(70)
THUNK_S_9(70)
THUNK_S_10(70)
THUNK_S_11(70)
THUNK_S_12(70)
THUNK_S_13(70)
THUNK_S_14(70)
THUNK_S_15(70)
THUNK_S_16(70)
THUNK_S_17(70)
THUNK_S_18(70)
THUNK_S_19(70)
THUNK_S_20(70)
THUNK_S_1(71)
THUNK_S_2(71)
THUNK_S_3(71)
THUNK_S_4(71)
THUNK_S_5(71)
THUNK_S_6(71)
THUNK_S_7(71)
THUNK_S_8(71)
THUNK_S_9(71)
THUNK_S_10(71)
THUNK_S_11(71)
THUNK_S_12(71)
THUNK_S_13(71)
THUNK_S_14(71)
THUNK_S_15(71)
THUNK_S_16(71)
THUNK_S_17(71)
THUNK_S_18(71)
THUNK_S_19(71)
THUNK_S_20(71)
THUNK_S_1(72)
THUNK_S_2(72)
THUNK_S_3(72)
THUNK_S_4(72)
THUNK_S_5(72)
THUNK_S_6(72)
THUNK_S_7(72)
THUNK_S_8(72)
THUNK_S_9(72)
THUNK_S_10(72)
THUNK_S_11(72)
THUNK_S_12(72)
THUNK_S_13(72)
THUNK_S_14(72)
THUNK_S_15(72)
THUNK_S_16(72)
THUNK_S_17(72)
THUNK_S_18(72)
THUNK_S_19(72)
THUNK_S_20(72)
THUNK_S_1(73)
THUNK_S_2(73)
THUNK_S_3(73)
THUNK_S_4(73)
THUNK_S_5(73)
THUNK_S_6(73)
THUNK_S_7(73)
THUNK_S_8(73)
THUNK_S_9(73)
THUNK_S_10(73)
THUNK_S_11(73)
THUNK_S_12(73)
THUNK_S_13(73)
THUNK_S_14(73)
THUNK_S_15(73)
THUNK_S_16(73)
THUNK_S_17(73)
THUNK_S_18(73)
THUNK_S_19(73)
THUNK_S_20(73)
THUNK_S_1(74)
THUNK_S_2(74)
THUNK_S_3(74)
THUNK_S_4(74)
THUNK_S_5(74)
THUNK_S_6(74)
THUNK_S_7(74)
THUNK_S_8(74)
THUNK_S_9(74)
THUNK_S_10(74)
THUNK_S_11(74)
THUNK_S_12(74)
THUNK_S_13(74)
THUNK_S_14(74)
THUNK_S_15(74)
THUNK_S_16(74)
THUNK_S_17(74)
THUNK_S_18(74)
THUNK_S_19(74)
THUNK_S_20(74)
THUNK_S_1(75)
THUNK_S_2(75)
THUNK_S_3(75)
THUNK_S_4(75)
THUNK_S_5(75)
THUNK_S_6(75)
THUNK_S_7(75)
THUNK_S_8(75)
THUNK_S_9(75)
THUNK_S_10(75)
THUNK_S_11(75)
THUNK_S_12(75)
THUNK_S_13(75)
THUNK_S_14(75)
THUNK_S_15(75)
THUNK_S_16(75)
THUNK_S_17(75)
THUNK_S_18(75)
THUNK_S_19(75)
THUNK_S_20(75)
THUNK_S_1(76)
THUNK_S_2(76)
THUNK_S_3(76)
THUNK_S_4(76)
THUNK_S_5(76)
THUNK_S_6(76)
THUNK_S_7(76)
THUNK_S_8(76)
THUNK_S_9(76)
THUNK_S_10(76)
THUNK_S_11(76)
THUNK_S_12(76)
THUNK_S_13(76)
THUNK_S_14(76)
THUNK_S_15(76)
THUNK_S_16(76)
THUNK_S_17(76)
THUNK_S_18(76)
THUNK_S_19(76)
THUNK_S_20(76)
THUNK_S_1(77)
THUNK_S_2(77)
THUNK_S_3(77)
THUNK_S_4(77)
THUNK_S_5(77)
THUNK_S_6(77)
THUNK_S_7(77)
THUNK_S_8(77)
THUNK_S_9(77)
THUNK_S_10(77)
THUNK_S_11(77)
THUNK_S_12(77)
THUNK_S_13(77)
THUNK_S_14(77)
THUNK_S_15(77)
THUNK_S_16(77)
THUNK_S_17(77)
THUNK_S_18(77)
THUNK_S_19(77)
THUNK_S_20(77)
THUNK_S_1(78)
THUNK_S_2(78)
THUNK_S_3(78)
THUNK_S_4(78)
THUNK_S_5(78)
THUNK_S_6(78)
THUNK_S_7(78)
THUNK_S_8(78)
THUNK_S_9(78)
THUNK_S_10(78)
THUNK_S_11(78)
THUNK_S_12(78)
THUNK_S_13(78)
THUNK_S_14(78)
THUNK_S_15(78)
THUNK_S_16(78)
THUNK_S_17(78)
THUNK_S_18(78)
THUNK_S_19(78)
THUNK_S_20(78)
THUNK_S_1(79)
THUNK_S_2(79)
THUNK_S_3(79)
THUNK_S_4(79)
THUNK_S_5(79)
THUNK_S_6(79)
THUNK_S_7(79)
THUNK_S_8(79)
THUNK_S_9(79)
THUNK_S_10(79)
THUNK_S_11(79)
THUNK_S_12(79)
THUNK_S_13(79)
THUNK_S_14(79)
THUNK_S_15(79)
THUNK_S_16(79)
THUNK_S_17(79)
THUNK_S_18(79)
THUNK_S_19(79)
THUNK_S_20(79)
THUNK_S_1(80)
THUNK_S_2(80)
THUNK_S_3(80)
THUNK_S_4(80)
THUNK_S_5(80)
THUNK_S_6(80)
THUNK_S_7(80)
THUNK_S_8(80)
THUNK_S_9(80)
THUNK_S_10(80)
THUNK_S_11(80)
THUNK_S_12(80)
THUNK_S_13(80)
THUNK_S_14(80)
THUNK_S_15(80)
THUNK_S_16(80)
THUNK_S_17(80)
THUNK_S_18(80)
THUNK_S_19(80)
THUNK_S_20(80)
THUNK_S_1(81)
THUNK_S_2(81)
THUNK_S_3(81)
THUNK_S_4(81)
THUNK_S_5(81)
THUNK_S_6(81)
THUNK_S_7(81)
THUNK_S_8(81)
THUNK_S_9(81)
THUNK_S_10(81)
THUNK_S_11(81)
THUNK_S_12(81)
THUNK_S_13(81)
THUNK_S_14(81)
THUNK_S_15(81)
THUNK_S_16(81)
THUNK_S_17(81)
THUNK_S_18(81)
THUNK_S_19(81)
THUNK_S_20(81)
THUNK_S_1(82)
THUNK_S_2(82)
THUNK_S_3(82)
THUNK_S_4(82)
THUNK_S_5(82)
THUNK_S_6(82)
THUNK_S_7(82)
THUNK_S_8(82)
THUNK_S_9(82)
THUNK_S_10(82)
THUNK_S_11(82)
THUNK_S_12(82)
THUNK_S_13(82)
THUNK_S_14(82)
THUNK_S_15(82)
THUNK_S_16(82)
THUNK_S_17(82)
THUNK_S_18(82)
THUNK_S_19(82)
THUNK_S_20(82)
THUNK_S_1(83)
THUNK_S_2(83)
THUNK_S_3(83)
THUNK_S_4(83)
THUNK_S_5(83)
THUNK_S_6(83)
THUNK_S_7(83)
THUNK_S_8(83)
THUNK_S_9(83)
THUNK_S_10(83)
THUNK_S_11(83)
THUNK_S_12(83)
THUNK_S_13(83)
THUNK_S_14(83)
THUNK_S_15(83)
THUNK_S_16(83)
THUNK_S_17(83)
THUNK_S_18(83)
THUNK_S_19(83)
THUNK_S_20(83)
THUNK_S_1(84)
THUNK_S_2(84)
THUNK_S_3(84)
THUNK_S_4(84)
THUNK_S_5(84)
THUNK_S_6(84)
THUNK_S_7(84)
THUNK_S_8(84)
THUNK_S_9(84)
THUNK_S_10(84)
THUNK_S_11(84)
THUNK_S_12(84)
THUNK_S_13(84)
THUNK_S_14(84)
THUNK_S_15(84)
THUNK_S_16(84)
THUNK_S_17(84)
THUNK_S_18(84)
THUNK_S_19(84)
THUNK_S_20(84)
THUNK_S_1(85)
THUNK_S_2(85)
THUNK_S_3(85)
THUNK_S_4(85)
THUNK_S_5(85)
THUNK_S_6(85)
THUNK_S_7(85)
THUNK_S_8(85)
THUNK_S_9(85)
THUNK_S_10(85)
THUNK_S_11(85)
THUNK_S_12(85)
THUNK_S_13(85)
THUNK_S_14(85)
THUNK_S_15(85)
THUNK_S_16(85)
THUNK_S_17(85)
THUNK_S_18(85)
THUNK_S_19(85)
THUNK_S_20(85)
THUNK_S_1(86)
THUNK_S_2(86)
THUNK_S_3(86)
THUNK_S_4(86)
THUNK_S_5(86)
THUNK_S_6(86)
THUNK_S_7(86)
THUNK_S_8(86)
THUNK_S_9(86)
THUNK_S_10(86)
THUNK_S_11(86)
THUNK_S_12(86)
THUNK_S_13(86)
THUNK_S_14(86)
THUNK_S_15(86)
THUNK_S_16(86)
THUNK_S_17(86)
THUNK_S_18(86)
THUNK_S_19(86)
THUNK_S_20(86)
THUNK_S_1(87)
THUNK_S_2(87)
THUNK_S_3(87)
THUNK_S_4(87)
THUNK_S_5(87)
THUNK_S_6(87)
THUNK_S_7(87)
THUNK_S_8(87)
THUNK_S_9(87)
THUNK_S_10(87)
THUNK_S_11(87)
THUNK_S_12(87)
THUNK_S_13(87)
THUNK_S_14(87)
THUNK_S_15(87)
THUNK_S_16(87)
THUNK_S_17(87)
THUNK_S_18(87)
THUNK_S_19(87)
THUNK_S_20(87)
THUNK_S_1(88)
THUNK_S_2(88)
THUNK_S_3(88)
THUNK_S_4(88)
THUNK_S_5(88)
THUNK_S_6(88)
THUNK_S_7(88)
THUNK_S_8(88)
THUNK_S_9(88)
THUNK_S_10(88)
THUNK_S_11(88)
THUNK_S_12(88)
THUNK_S_13(88)
THUNK_S_14(88)
THUNK_S_15(88)
THUNK_S_16(88)
THUNK_S_17(88)
THUNK_S_18(88)
THUNK_S_19(88)
THUNK_S_20(88)
THUNK_S_1(89)
THUNK_S_2(89)
THUNK_S_3(89)
THUNK_S_4(89)
THUNK_S_5(89)
THUNK_S_6(89)
THUNK_S_7(89)
THUNK_S_8(89)
THUNK_S_9(89)
THUNK_S_10(89)
THUNK_S_11(89)
THUNK_S_12(89)
THUNK_S_13(89)
THUNK_S_14(89)
THUNK_S_15(89)
THUNK_S_16(89)
THUNK_S_17(89)
THUNK_S_18(89)
THUNK_S_19(89)
THUNK_S_20(89)
THUNK_S_1(90)
THUNK_S_2(90)
THUNK_S_3(90)
THUNK_S_4(90)
THUNK_S_5(90)
THUNK_S_6(90)
THUNK_S_7(90)
THUNK_S_8(90)
THUNK_S_9(90)
THUNK_S_10(90)
THUNK_S_11(90)
THUNK_S_12(90)
THUNK_S_13(90)
THUNK_S_14(90)
THUNK_S_15(90)
THUNK_S_16(90)
THUNK_S_17(90)
THUNK_S_18(90)
THUNK_S_19(90)
THUNK_S_20(90)
THUNK_S_1(91)
THUNK_S_2(91)
THUNK_S_3(91)
THUNK_S_4(91)
THUNK_S_5(91)
THUNK_S_6(91)
THUNK_S_7(91)
THUNK_S_8(91)
THUNK_S_9(91)
THUNK_S_10(91)
THUNK_S_11(91)
THUNK_S_12(91)
THUNK_S_13(91)
THUNK_S_14(91)
THUNK_S_15(91)
THUNK_S_16(91)
THUNK_S_17(91)
THUNK_S_18(91)
THUNK_S_19(91)
THUNK_S_20(91)
THUNK_S_1(92)
THUNK_S_2(92)
THUNK_S_3(92)
THUNK_S_4(92)
THUNK_S_5(92)
THUNK_S_6(92)
THUNK_S_7(92)
THUNK_S_8(92)
THUNK_S_9(92)
THUNK_S_10(92)
THUNK_S_11(92)
THUNK_S_12(92)
THUNK_S_13(92)
THUNK_S_14(92)
THUNK_S_15(92)
THUNK_S_16(92)
THUNK_S_17(92)
THUNK_S_18(92)
THUNK_S_19(92)
THUNK_S_20(92)
THUNK_S_1(93)
THUNK_S_2(93)
THUNK_S_3(93)
THUNK_S_4(93)
THUNK_S_5(93)
THUNK_S_6(93)
THUNK_S_7(93)
THUNK_S_8(93)
THUNK_S_9(93)
THUNK_S_10(93)
THUNK_S_11(93)
THUNK_S_12(93)
THUNK_S_13(93)
THUNK_S_14(93)
THUNK_S_15(93)
THUNK_S_16(93)
THUNK_S_17(93)
THUNK_S_18(93)
THUNK_S_19(93)
THUNK_S_20(93)
THUNK_S_1(94)
THUNK_S_2(94)
THUNK_S_3(94)
THUNK_S_4(94)
THUNK_S_5(94)
THUNK_S_6(94)
THUNK_S_7(94)
THUNK_S_8(94)
THUNK_S_9(94)
THUNK_S_10(94)
THUNK_S_11(94)
THUNK_S_12(94)
THUNK_S_13(94)
THUNK_S_14(94)
THUNK_S_15(94)
THUNK_S_16(94)
THUNK_S_17(94)
THUNK_S_18(94)
THUNK_S_19(94)
THUNK_S_20(94)
THUNK_S_1(95)
THUNK_S_2(95)
THUNK_S_3(95)
THUNK_S_4(95)
THUNK_S_5(95)
THUNK_S_6(95)
THUNK_S_7(95)
THUNK_S_8(95)
THUNK_S_9(95)
THUNK_S_10(95)
THUNK_S_11(95)
THUNK_S_12(95)
THUNK_S_13(95)
THUNK_S_14(95)
THUNK_S_15(95)
THUNK_S_16(95)
THUNK_S_17(95)
THUNK_S_18(95)
THUNK_S_19(95)
THUNK_S_20(95)
THUNK_S_1(96)
THUNK_S_2(96)
THUNK_S_3(96)
THUNK_S_4(96)
THUNK_S_5(96)
THUNK_S_6(96)
THUNK_S_7(96)
THUNK_S_8(96)
THUNK_S_9(96)
THUNK_S_10(96)
THUNK_S_11(96)
THUNK_S_12(96)
THUNK_S_13(96)
THUNK_S_14(96)
THUNK_S_15(96)
THUNK_S_16(96)
THUNK_S_17(96)
THUNK_S_18(96)
THUNK_S_19(96)
THUNK_S_20(96)
THUNK_S_1(97)
THUNK_S_2(97)
THUNK_S_3(97)
THUNK_S_4(97)
THUNK_S_5(97)
THUNK_S_6(97)
THUNK_S_7(97)
THUNK_S_8(97)
THUNK_S_9(97)
THUNK_S_10(97)
THUNK_S_11(97)
THUNK_S_12(97)
THUNK_S_13(97)
THUNK_S_14(97)
THUNK_S_15(97)
THUNK_S_16(97)
THUNK_S_17(97)
THUNK_S_18(97)
THUNK_S_19(97)
THUNK_S_20(97)
THUNK_S_1(98)
THUNK_S_2(98)
THUNK_S_3(98)
THUNK_S_4(98)
THUNK_S_5(98)
THUNK_S_6(98)
THUNK_S_7(98)
THUNK_S_8(98)
THUNK_S_9(98)
THUNK_S_10(98)
THUNK_S_11(98)
THUNK_S_12(98)
THUNK_S_13(98)
THUNK_S_14(98)
THUNK_S_15(98)
THUNK_S_16(98)
THUNK_S_17(98)
THUNK_S_18(98)
THUNK_S_19(98)
THUNK_S_20(98)
THUNK_S_1(99)
THUNK_S_2(99)
THUNK_S_3(99)
THUNK_S_4(99)
THUNK_S_5(99)
THUNK_S_6(99)
THUNK_S_7(99)
THUNK_S_8(99)
THUNK_S_9(99)
THUNK_S_10(99)
THUNK_S_11(99)
THUNK_S_12(99)
THUNK_S_13(99)
THUNK_S_14(99)
THUNK_S_15(99)
THUNK_S_16(99)
THUNK_S_17(99)
THUNK_S_18(99)
THUNK_S_19(99)
THUNK_S_20(99)
THUNK_S_1(100)
THUNK_S_2(100)
THUNK_S_3(100)
THUNK_S_4(100)
THUNK_S_5(100)
THUNK_S_6(100)
THUNK_S_7(100)
THUNK_S_8(100)
THUNK_S_9(100)
THUNK_S_10(100)
THUNK_S_11(100)
THUNK_S_12(100)
THUNK_S_13(100)
THUNK_S_14(100)
THUNK_S_15(100)
THUNK_S_16(100)
THUNK_S_17(100)
THUNK_S_18(100)
THUNK_S_19(100)
THUNK_S_20(100)
THUNK_S_1(101)
THUNK_S_2(101)
THUNK_S_3(101)
THUNK_S_4(101)
THUNK_S_5(101)
THUNK_S_6(101)
THUNK_S_7(101)
THUNK_S_8(101)
THUNK_S_9(101)
THUNK_S_10(101)
THUNK_S_11(101)
THUNK_S_12(101)
THUNK_S_13(101)
THUNK_S_14(101)
THUNK_S_15(101)
THUNK_S_16(101)
THUNK_S_17(101)
THUNK_S_18(101)
THUNK_S_19(101)
THUNK_S_20(101)
THUNK_S_1(102)
THUNK_S_2(102)
THUNK_S_3(102)
THUNK_S_4(102)
THUNK_S_5(102)
THUNK_S_6(102)
THUNK_S_7(102)
THUNK_S_8(102)
THUNK_S_9(102)
THUNK_S_10(102)
THUNK_S_11(102)
THUNK_S_12(102)
THUNK_S_13(102)
THUNK_S_14(102)
THUNK_S_15(102)
THUNK_S_16(102)
THUNK_S_17(102)
THUNK_S_18(102)
THUNK_S_19(102)
THUNK_S_20(102)
THUNK_S_1(103)
THUNK_S_2(103)
THUNK_S_3(103)
THUNK_S_4(103)
THUNK_S_5(103)
THUNK_S_6(103)
THUNK_S_7(103)
THUNK_S_8(103)
THUNK_S_9(103)
THUNK_S_10(103)
THUNK_S_11(103)
THUNK_S_12(103)
THUNK_S_13(103)
THUNK_S_14(103)
THUNK_S_15(103)
THUNK_S_16(103)
THUNK_S_17(103)
THUNK_S_18(103)
THUNK_S_19(103)
THUNK_S_20(103)
THUNK_S_1(104)
THUNK_S_2(104)
THUNK_S_3(104)
THUNK_S_4(104)
THUNK_S_5(104)
THUNK_S_6(104)
THUNK_S_7(104)
THUNK_S_8(104)
THUNK_S_9(104)
THUNK_S_10(104)
THUNK_S_11(104)
THUNK_S_12(104)
THUNK_S_13(104)
THUNK_S_14(104)
THUNK_S_15(104)
THUNK_S_16(104)
THUNK_S_17(104)
THUNK_S_18(104)
THUNK_S_19(104)
THUNK_S_20(104)
THUNK_S_1(105)
THUNK_S_2(105)
THUNK_S_3(105)
THUNK_S_4(105)
THUNK_S_5(105)
THUNK_S_6(105)
THUNK_S_7(105)
THUNK_S_8(105)
THUNK_S_9(105)
THUNK_S_10(105)
THUNK_S_11(105)
THUNK_S_12(105)
THUNK_S_13(105)
THUNK_S_14(105)
THUNK_S_15(105)
THUNK_S_16(105)
THUNK_S_17(105)
THUNK_S_18(105)
THUNK_S_19(105)
THUNK_S_20(105)
THUNK_S_1(106)
THUNK_S_2(106)
THUNK_S_3(106)
THUNK_S_4(106)
THUNK_S_5(106)
THUNK_S_6(106)
THUNK_S_7(106)
THUNK_S_8(106)
THUNK_S_9(106)
THUNK_S_10(106)
THUNK_S_11(106)
THUNK_S_12(106)
THUNK_S_13(106)
THUNK_S_14(106)
THUNK_S_15(106)
THUNK_S_16(106)
THUNK_S_17(106)
THUNK_S_18(106)
THUNK_S_19(106)
THUNK_S_20(106)
THUNK_S_1(107)
THUNK_S_2(107)
THUNK_S_3(107)
THUNK_S_4(107)
THUNK_S_5(107)
THUNK_S_6(107)
THUNK_S_7(107)
THUNK_S_8(107)
THUNK_S_9(107)
THUNK_S_10(107)
THUNK_S_11(107)
THUNK_S_12(107)
THUNK_S_13(107)
THUNK_S_14(107)
THUNK_S_15(107)
THUNK_S_16(107)
THUNK_S_17(107)
THUNK_S_18(107)
THUNK_S_19(107)
THUNK_S_20(107)
THUNK_S_1(108)
THUNK_S_2(108)
THUNK_S_3(108)
THUNK_S_4(108)
THUNK_S_5(108)
THUNK_S_6(108)
THUNK_S_7(108)
THUNK_S_8(108)
THUNK_S_9(108)
THUNK_S_10(108)
THUNK_S_11(108)
THUNK_S_12(108)
THUNK_S_13(108)
THUNK_S_14(108)
THUNK_S_15(108)
THUNK_S_16(108)
THUNK_S_17(108)
THUNK_S_18(108)
THUNK_S_19(108)
THUNK_S_20(108)
THUNK_S_1(109)
THUNK_S_2(109)
THUNK_S_3(109)
THUNK_S_4(109)
THUNK_S_5(109)
THUNK_S_6(109)
THUNK_S_7(109)
THUNK_S_8(109)
THUNK_S_9(109)
THUNK_S_10(109)
THUNK_S_11(109)
THUNK_S_12(109)
THUNK_S_13(109)
THUNK_S_14(109)
THUNK_S_15(109)
THUNK_S_16(109)
THUNK_S_17(109)
THUNK_S_18(109)
THUNK_S_19(109)
THUNK_S_20(109)
THUNK_S_1(110)
THUNK_S_2(110)
THUNK_S_3(110)
THUNK_S_4(110)
THUNK_S_5(110)
THUNK_S_6(110)
THUNK_S_7(110)
THUNK_S_8(110)
THUNK_S_9(110)
THUNK_S_10(110)
THUNK_S_11(110)
THUNK_S_12(110)
THUNK_S_13(110)
THUNK_S_14(110)
THUNK_S_15(110)
THUNK_S_16(110)
THUNK_S_17(110)
THUNK_S_18(110)
THUNK_S_19(110)
THUNK_S_20(110)
THUNK_S_1(111)
THUNK_S_2(111)
THUNK_S_3(111)
THUNK_S_4(111)
THUNK_S_5(111)
THUNK_S_6(111)
THUNK_S_7(111)
THUNK_S_8(111)
THUNK_S_9(111)
THUNK_S_10(111)
THUNK_S_11(111)
THUNK_S_12(111)
THUNK_S_13(111)
THUNK_S_14(111)
THUNK_S_15(111)
THUNK_S_16(111)
THUNK_S_17(111)
THUNK_S_18(111)
THUNK_S_19(111)
THUNK_S_20(111)
THUNK_S_1(112)
THUNK_S_2(112)
THUNK_S_3(112)
THUNK_S_4(112)
THUNK_S_5(112)
THUNK_S_6(112)
THUNK_S_7(112)
THUNK_S_8(112)
THUNK_S_9(112)
THUNK_S_10(112)
THUNK_S_11(112)
THUNK_S_12(112)
THUNK_S_13(112)
THUNK_S_14(112)
THUNK_S_15(112)
THUNK_S_16(112)
THUNK_S_17(112)
THUNK_S_18(112)
THUNK_S_19(112)
THUNK_S_20(112)
THUNK_S_1(113)
THUNK_S_2(113)
THUNK_S_3(113)
THUNK_S_4(113)
THUNK_S_5(113)
THUNK_S_6(113)
THUNK_S_7(113)
THUNK_S_8(113)
THUNK_S_9(113)
THUNK_S_10(113)
THUNK_S_11(113)
THUNK_S_12(113)
THUNK_S_13(113)
THUNK_S_14(113)
THUNK_S_15(113)
THUNK_S_16(113)
THUNK_S_17(113)
THUNK_S_18(113)
THUNK_S_19(113)
THUNK_S_20(113)
THUNK_S_1(114)
THUNK_S_2(114)
THUNK_S_3(114)
THUNK_S_4(114)
THUNK_S_5(114)
THUNK_S_6(114)
THUNK_S_7(114)
THUNK_S_8(114)
THUNK_S_9(114)
THUNK_S_10(114)
THUNK_S_11(114)
THUNK_S_12(114)
THUNK_S_13(114)
THUNK_S_14(114)
THUNK_S_15(114)
THUNK_S_16(114)
THUNK_S_17(114)
THUNK_S_18(114)
THUNK_S_19(114)
THUNK_S_20(114)
THUNK_S_1(115)
THUNK_S_2(115)
THUNK_S_3(115)
THUNK_S_4(115)
THUNK_S_5(115)
THUNK_S_6(115)
THUNK_S_7(115)
THUNK_S_8(115)
THUNK_S_9(115)
THUNK_S_10(115)
THUNK_S_11(115)
THUNK_S_12(115)
THUNK_S_13(115)
THUNK_S_14(115)
THUNK_S_15(115)
THUNK_S_16(115)
THUNK_S_17(115)
THUNK_S_18(115)
THUNK_S_19(115)
THUNK_S_20(115)
THUNK_S_1(116)
THUNK_S_2(116)
THUNK_S_3(116)
THUNK_S_4(116)
THUNK_S_5(116)
THUNK_S_6(116)
THUNK_S_7(116)
THUNK_S_8(116)
THUNK_S_9(116)
THUNK_S_10(116)
THUNK_S_11(116)
THUNK_S_12(116)
THUNK_S_13(116)
THUNK_S_14(116)
THUNK_S_15(116)
THUNK_S_16(116)
THUNK_S_17(116)
THUNK_S_18(116)
THUNK_S_19(116)
THUNK_S_20(116)
THUNK_S_1(117)
THUNK_S_2(117)
THUNK_S_3(117)
THUNK_S_4(117)
THUNK_S_5(117)
THUNK_S_6(117)
THUNK_S_7(117)
THUNK_S_8(117)
THUNK_S_9(117)
THUNK_S_10(117)
THUNK_S_11(117)
THUNK_S_12(117)
THUNK_S_13(117)
THUNK_S_14(117)
THUNK_S_15(117)
THUNK_S_16(117)
THUNK_S_17(117)
THUNK_S_18(117)
THUNK_S_19(117)
THUNK_S_20(117)
THUNK_S_1(118)
THUNK_S_2(118)
THUNK_S_3(118)
THUNK_S_4(118)
THUNK_S_5(118)
THUNK_S_6(118)
THUNK_S_7(118)
THUNK_S_8(118)
THUNK_S_9(118)
THUNK_S_10(118)
THUNK_S_11(118)
THUNK_S_12(118)
THUNK_S_13(118)
THUNK_S_14(118)
THUNK_S_15(118)
THUNK_S_16(118)
THUNK_S_17(118)
THUNK_S_18(118)
THUNK_S_19(118)
THUNK_S_20(118)
THUNK_S_1(119)
THUNK_S_2(119)
THUNK_S_3(119)
THUNK_S_4(119)
THUNK_S_5(119)
THUNK_S_6(119)
THUNK_S_7(119)
THUNK_S_8(119)
THUNK_S_9(119)
THUNK_S_10(119)
THUNK_S_11(119)
THUNK_S_12(119)
THUNK_S_13(119)
THUNK_S_14(119)
THUNK_S_15(119)
THUNK_S_16(119)
THUNK_S_17(119)
THUNK_S_18(119)
THUNK_S_19(119)
THUNK_S_20(119)
THUNK_S_1(120)
THUNK_S_2(120)
THUNK_S_3(120)
THUNK_S_4(120)
THUNK_S_5(120)
THUNK_S_6(120)
THUNK_S_7(120)
THUNK_S_8(120)
THUNK_S_9(120)
THUNK_S_10(120)
THUNK_S_11(120)
THUNK_S_12(120)
THUNK_S_13(120)
THUNK_S_14(120)
THUNK_S_15(120)
THUNK_S_16(120)
THUNK_S_17(120)
THUNK_S_18(120)
THUNK_S_19(120)
THUNK_S_20(120)
THUNK_S_1(121)
THUNK_S_2(121)
THUNK_S_3(121)
THUNK_S_4(121)
THUNK_S_5(121)
THUNK_S_6(121)
THUNK_S_7(121)
THUNK_S_8(121)
THUNK_S_9(121)
THUNK_S_10(121)
THUNK_S_11(121)
THUNK_S_12(121)
THUNK_S_13(121)
THUNK_S_14(121)
THUNK_S_15(121)
THUNK_S_16(121)
THUNK_S_17(121)
THUNK_S_18(121)
THUNK_S_19(121)
THUNK_S_20(121)
THUNK_S_1(122)
THUNK_S_2(122)
THUNK_S_3(122)
THUNK_S_4(122)
THUNK_S_5(122)
THUNK_S_6(122)
THUNK_S_7(122)
THUNK_S_8(122)
THUNK_S_9(122)
THUNK_S_10(122)
THUNK_S_11(122)
THUNK_S_12(122)
THUNK_S_13(122)
THUNK_S_14(122)
THUNK_S_15(122)
THUNK_S_16(122)
THUNK_S_17(122)
THUNK_S_18(122)
THUNK_S_19(122)
THUNK_S_20(122)
THUNK_S_1(123)
THUNK_S_2(123)
THUNK_S_3(123)
THUNK_S_4(123)
THUNK_S_5(123)
THUNK_S_6(123)
THUNK_S_7(123)
THUNK_S_8(123)
THUNK_S_9(123)
THUNK_S_10(123)
THUNK_S_11(123)
THUNK_S_12(123)
THUNK_S_13(123)
THUNK_S_14(123)
THUNK_S_15(123)
THUNK_S_16(123)
THUNK_S_17(123)
THUNK_S_18(123)
THUNK_S_19(123)
THUNK_S_20(123)
THUNK_S_1(124)
THUNK_S_2(124)
THUNK_S_3(124)
THUNK_S_4(124)
THUNK_S_5(124)
THUNK_S_6(124)
THUNK_S_7(124)
THUNK_S_8(124)
THUNK_S_9(124)
THUNK_S_10(124)
THUNK_S_11(124)
THUNK_S_12(124)
THUNK_S_13(124)
THUNK_S_14(124)
THUNK_S_15(124)
THUNK_S_16(124)
THUNK_S_17(124)
THUNK_S_18(124)
THUNK_S_19(124)
THUNK_S_20(124)
THUNK_S_1(125)
THUNK_S_2(125)
THUNK_S_3(125)
THUNK_S_4(125)
THUNK_S_5(125)
THUNK_S_6(125)
THUNK_S_7(125)
THUNK_S_8(125)
THUNK_S_9(125)
THUNK_S_10(125)
THUNK_S_11(125)
THUNK_S_12(125)
THUNK_S_13(125)
THUNK_S_14(125)
THUNK_S_15(125)
THUNK_S_16(125)
THUNK_S_17(125)
THUNK_S_18(125)
THUNK_S_19(125)
THUNK_S_20(125)
THUNK_S_1(126)
THUNK_S_2(126)
THUNK_S_3(126)
THUNK_S_4(126)
THUNK_S_5(126)
THUNK_S_6(126)
THUNK_S_7(126)
THUNK_S_8(126)
THUNK_S_9(126)
THUNK_S_10(126)
THUNK_S_11(126)
THUNK_S_12(126)
THUNK_S_13(126)
THUNK_S_14(126)
THUNK_S_15(126)
THUNK_S_16(126)
THUNK_S_17(126)
THUNK_S_18(126)
THUNK_S_19(126)
THUNK_S_20(126)
THUNK_S_1(127)
THUNK_S_2(127)
THUNK_S_3(127)
THUNK_S_4(127)
THUNK_S_5(127)
THUNK_S_6(127)
THUNK_S_7(127)
THUNK_S_8(127)
THUNK_S_9(127)
THUNK_S_10(127)
THUNK_S_11(127)
THUNK_S_12(127)
THUNK_S_13(127)
THUNK_S_14(127)
THUNK_S_15(127)
THUNK_S_16(127)
THUNK_S_17(127)
THUNK_S_18(127)
THUNK_S_19(127)
THUNK_S_20(127)
THUNK_S_1(128)
THUNK_S_2(128)
THUNK_S_3(128)
THUNK_S_4(128)
THUNK_S_5(128)
THUNK_S_6(128)
THUNK_S_7(128)
THUNK_S_8(128)
THUNK_S_9(128)
THUNK_S_10(128)
THUNK_S_11(128)
THUNK_S_12(128)
THUNK_S_13(128)
THUNK_S_14(128)
THUNK_S_15(128)
THUNK_S_16(128)
THUNK_S_17(128)
THUNK_S_18(128)
THUNK_S_19(128)
THUNK_S_20(128)
THUNK_S_1(129)
THUNK_S_2(129)
THUNK_S_3(129)
THUNK_S_4(129)
THUNK_S_5(129)
THUNK_S_6(129)
THUNK_S_7(129)
THUNK_S_8(129)
THUNK_S_9(129)
THUNK_S_10(129)
THUNK_S_11(129)
THUNK_S_12(129)
THUNK_S_13(129)
THUNK_S_14(129)
THUNK_S_15(129)
THUNK_S_16(129)
THUNK_S_17(129)
THUNK_S_18(129)
THUNK_S_19(129)
THUNK_S_20(129)
THUNK_S_1(130)
THUNK_S_2(130)
THUNK_S_3(130)
THUNK_S_4(130)
THUNK_S_5(130)
THUNK_S_6(130)
THUNK_S_7(130)
THUNK_S_8(130)
THUNK_S_9(130)
THUNK_S_10(130)
THUNK_S_11(130)
THUNK_S_12(130)
THUNK_S_13(130)
THUNK_S_14(130)
THUNK_S_15(130)
THUNK_S_16(130)
THUNK_S_17(130)
THUNK_S_18(130)
THUNK_S_19(130)
THUNK_S_20(130)
THUNK_S_1(131)
THUNK_S_2(131)
THUNK_S_3(131)
THUNK_S_4(131)
THUNK_S_5(131)
THUNK_S_6(131)
THUNK_S_7(131)
THUNK_S_8(131)
THUNK_S_9(131)
THUNK_S_10(131)
THUNK_S_11(131)
THUNK_S_12(131)
THUNK_S_13(131)
THUNK_S_14(131)
THUNK_S_15(131)
THUNK_S_16(131)
THUNK_S_17(131)
THUNK_S_18(131)
THUNK_S_19(131)
THUNK_S_20(131)
THUNK_S_1(132)
THUNK_S_2(132)
THUNK_S_3(132)
THUNK_S_4(132)
THUNK_S_5(132)
THUNK_S_6(132)
THUNK_S_7(132)
THUNK_S_8(132)
THUNK_S_9(132)
THUNK_S_10(132)
THUNK_S_11(132)
THUNK_S_12(132)
THUNK_S_13(132)
THUNK_S_14(132)
THUNK_S_15(132)
THUNK_S_16(132)
THUNK_S_17(132)
THUNK_S_18(132)
THUNK_S_19(132)
THUNK_S_20(132)
THUNK_S_1(133)
THUNK_S_2(133)
THUNK_S_3(133)
THUNK_S_4(133)
THUNK_S_5(133)
THUNK_S_6(133)
THUNK_S_7(133)
THUNK_S_8(133)
THUNK_S_9(133)
THUNK_S_10(133)
THUNK_S_11(133)
THUNK_S_12(133)
THUNK_S_13(133)
THUNK_S_14(133)
THUNK_S_15(133)
THUNK_S_16(133)
THUNK_S_17(133)
THUNK_S_18(133)
THUNK_S_19(133)
THUNK_S_20(133)
THUNK_S_1(134)
THUNK_S_2(134)
THUNK_S_3(134)
THUNK_S_4(134)
THUNK_S_5(134)
THUNK_S_6(134)
THUNK_S_7(134)
THUNK_S_8(134)
THUNK_S_9(134)
THUNK_S_10(134)
THUNK_S_11(134)
THUNK_S_12(134)
THUNK_S_13(134)
THUNK_S_14(134)
THUNK_S_15(134)
THUNK_S_16(134)
THUNK_S_17(134)
THUNK_S_18(134)
THUNK_S_19(134)
THUNK_S_20(134)
THUNK_S_1(135)
THUNK_S_2(135)
THUNK_S_3(135)
THUNK_S_4(135)
THUNK_S_5(135)
THUNK_S_6(135)
THUNK_S_7(135)
THUNK_S_8(135)
THUNK_S_9(135)
THUNK_S_10(135)
THUNK_S_11(135)
THUNK_S_12(135)
THUNK_S_13(135)
THUNK_S_14(135)
THUNK_S_15(135)
THUNK_S_16(135)
THUNK_S_17(135)
THUNK_S_18(135)
THUNK_S_19(135)
THUNK_S_20(135)
THUNK_S_1(136)
THUNK_S_2(136)
THUNK_S_3(136)
THUNK_S_4(136)
THUNK_S_5(136)
THUNK_S_6(136)
THUNK_S_7(136)
THUNK_S_8(136)
THUNK_S_9(136)
THUNK_S_10(136)
THUNK_S_11(136)
THUNK_S_12(136)
THUNK_S_13(136)
THUNK_S_14(136)
THUNK_S_15(136)
THUNK_S_16(136)
THUNK_S_17(136)
THUNK_S_18(136)
THUNK_S_19(136)
THUNK_S_20(136)
THUNK_S_1(137)
THUNK_S_2(137)
THUNK_S_3(137)
THUNK_S_4(137)
THUNK_S_5(137)
THUNK_S_6(137)
THUNK_S_7(137)
THUNK_S_8(137)
THUNK_S_9(137)
THUNK_S_10(137)
THUNK_S_11(137)
THUNK_S_12(137)
THUNK_S_13(137)
THUNK_S_14(137)
THUNK_S_15(137)
THUNK_S_16(137)
THUNK_S_17(137)
THUNK_S_18(137)
THUNK_S_19(137)
THUNK_S_20(137)
THUNK_S_1(138)
THUNK_S_2(138)
THUNK_S_3(138)
THUNK_S_4(138)
THUNK_S_5(138)
THUNK_S_6(138)
THUNK_S_7(138)
THUNK_S_8(138)
THUNK_S_9(138)
THUNK_S_10(138)
THUNK_S_11(138)
THUNK_S_12(138)
THUNK_S_13(138)
THUNK_S_14(138)
THUNK_S_15(138)
THUNK_S_16(138)
THUNK_S_17(138)
THUNK_S_18(138)
THUNK_S_19(138)
THUNK_S_20(138)
THUNK_S_1(139)
THUNK_S_2(139)
THUNK_S_3(139)
THUNK_S_4(139)
THUNK_S_5(139)
THUNK_S_6(139)
THUNK_S_7(139)
THUNK_S_8(139)
THUNK_S_9(139)
THUNK_S_10(139)
THUNK_S_11(139)
THUNK_S_12(139)
THUNK_S_13(139)
THUNK_S_14(139)
THUNK_S_15(139)
THUNK_S_16(139)
THUNK_S_17(139)
THUNK_S_18(139)
THUNK_S_19(139)
THUNK_S_20(139)
THUNK_S_1(140)
THUNK_S_2(140)
THUNK_S_3(140)
THUNK_S_4(140)
THUNK_S_5(140)
THUNK_S_6(140)
THUNK_S_7(140)
THUNK_S_8(140)
THUNK_S_9(140)
THUNK_S_10(140)
THUNK_S_11(140)
THUNK_S_12(140)
THUNK_S_13(140)
THUNK_S_14(140)
THUNK_S_15(140)
THUNK_S_16(140)
THUNK_S_17(140)
THUNK_S_18(140)
THUNK_S_19(140)
THUNK_S_20(140)
THUNK_S_1(141)
THUNK_S_2(141)
THUNK_S_3(141)
THUNK_S_4(141)
THUNK_S_5(141)
THUNK_S_6(141)
THUNK_S_7(141)
THUNK_S_8(141)
THUNK_S_9(141)
THUNK_S_10(141)
THUNK_S_11(141)
THUNK_S_12(141)
THUNK_S_13(141)
THUNK_S_14(141)
THUNK_S_15(141)
THUNK_S_16(141)
THUNK_S_17(141)
THUNK_S_18(141)
THUNK_S_19(141)
THUNK_S_20(141)
THUNK_S_1(142)
THUNK_S_2(142)
THUNK_S_3(142)
THUNK_S_4(142)
THUNK_S_5(142)
THUNK_S_6(142)
THUNK_S_7(142)
THUNK_S_8(142)
THUNK_S_9(142)
THUNK_S_10(142)
THUNK_S_11(142)
THUNK_S_12(142)
THUNK_S_13(142)
THUNK_S_14(142)
THUNK_S_15(142)
THUNK_S_16(142)
THUNK_S_17(142)
THUNK_S_18(142)
THUNK_S_19(142)
THUNK_S_20(142)
THUNK_S_1(143)
THUNK_S_2(143)
THUNK_S_3(143)
THUNK_S_4(143)
THUNK_S_5(143)
THUNK_S_6(143)
THUNK_S_7(143)
THUNK_S_8(143)
THUNK_S_9(143)
THUNK_S_10(143)
THUNK_S_11(143)
THUNK_S_12(143)
THUNK_S_13(143)
THUNK_S_14(143)
THUNK_S_15(143)
THUNK_S_16(143)
THUNK_S_17(143)
THUNK_S_18(143)
THUNK_S_19(143)
THUNK_S_20(143)
THUNK_S_1(144)
THUNK_S_2(144)
THUNK_S_3(144)
THUNK_S_4(144)
THUNK_S_5(144)
THUNK_S_6(144)
THUNK_S_7(144)
THUNK_S_8(144)
THUNK_S_9(144)
THUNK_S_10(144)
THUNK_S_11(144)
THUNK_S_12(144)
THUNK_S_13(144)
THUNK_S_14(144)
THUNK_S_15(144)
THUNK_S_16(144)
THUNK_S_17(144)
THUNK_S_18(144)
THUNK_S_19(144)
THUNK_S_20(144)
THUNK_S_1(145)
THUNK_S_2(145)
THUNK_S_3(145)
THUNK_S_4(145)
THUNK_S_5(145)
THUNK_S_6(145)
THUNK_S_7(145)
THUNK_S_8(145)
THUNK_S_9(145)
THUNK_S_10(145)
THUNK_S_11(145)
THUNK_S_12(145)
THUNK_S_13(145)
THUNK_S_14(145)
THUNK_S_15(145)
THUNK_S_16(145)
THUNK_S_17(145)
THUNK_S_18(145)
THUNK_S_19(145)
THUNK_S_20(145)
THUNK_S_1(146)
THUNK_S_2(146)
THUNK_S_3(146)
THUNK_S_4(146)
THUNK_S_5(146)
THUNK_S_6(146)
THUNK_S_7(146)
THUNK_S_8(146)
THUNK_S_9(146)
THUNK_S_10(146)
THUNK_S_11(146)
THUNK_S_12(146)
THUNK_S_13(146)
THUNK_S_14(146)
THUNK_S_15(146)
THUNK_S_16(146)
THUNK_S_17(146)
THUNK_S_18(146)
THUNK_S_19(146)
THUNK_S_20(146)
THUNK_S_1(147)
THUNK_S_2(147)
THUNK_S_3(147)
THUNK_S_4(147)
THUNK_S_5(147)
THUNK_S_6(147)
THUNK_S_7(147)
THUNK_S_8(147)
THUNK_S_9(147)
THUNK_S_10(147)
THUNK_S_11(147)
THUNK_S_12(147)
THUNK_S_13(147)
THUNK_S_14(147)
THUNK_S_15(147)
THUNK_S_16(147)
THUNK_S_17(147)
THUNK_S_18(147)
THUNK_S_19(147)
THUNK_S_20(147)
THUNK_S_1(148)
THUNK_S_2(148)
THUNK_S_3(148)
THUNK_S_4(148)
THUNK_S_5(148)
THUNK_S_6(148)
THUNK_S_7(148)
THUNK_S_8(148)
THUNK_S_9(148)
THUNK_S_10(148)
THUNK_S_11(148)
THUNK_S_12(148)
THUNK_S_13(148)
THUNK_S_14(148)
THUNK_S_15(148)
THUNK_S_16(148)
THUNK_S_17(148)
THUNK_S_18(148)
THUNK_S_19(148)
THUNK_S_20(148)
THUNK_S_1(149)
THUNK_S_2(149)
THUNK_S_3(149)
THUNK_S_4(149)
THUNK_S_5(149)
THUNK_S_6(149)
THUNK_S_7(149)
THUNK_S_8(149)
THUNK_S_9(149)
THUNK_S_10(149)
THUNK_S_11(149)
THUNK_S_12(149)
THUNK_S_13(149)
THUNK_S_14(149)
THUNK_S_15(149)
THUNK_S_16(149)
THUNK_S_17(149)
THUNK_S_18(149)
THUNK_S_19(149)
THUNK_S_20(149)
THUNK_S_1(150)
THUNK_S_2(150)
THUNK_S_3(150)
THUNK_S_4(150)
THUNK_S_5(150)
THUNK_S_6(150)
THUNK_S_7(150)
THUNK_S_8(150)
THUNK_S_9(150)
THUNK_S_10(150)
THUNK_S_11(150)
THUNK_S_12(150)
THUNK_S_13(150)
THUNK_S_14(150)
THUNK_S_15(150)
THUNK_S_16(150)
THUNK_S_17(150)
THUNK_S_18(150)
THUNK_S_19(150)
THUNK_S_20(150)
THUNK_S_1(151)
THUNK_S_2(151)
THUNK_S_3(151)
THUNK_S_4(151)
THUNK_S_5(151)
THUNK_S_6(151)
THUNK_S_7(151)
THUNK_S_8(151)
THUNK_S_9(151)
THUNK_S_10(151)
THUNK_S_11(151)
THUNK_S_12(151)
THUNK_S_13(151)
THUNK_S_14(151)
THUNK_S_15(151)
THUNK_S_16(151)
THUNK_S_17(151)
THUNK_S_18(151)
THUNK_S_19(151)
THUNK_S_20(151)
THUNK_S_1(152)
THUNK_S_2(152)
THUNK_S_3(152)
THUNK_S_4(152)
THUNK_S_5(152)
THUNK_S_6(152)
THUNK_S_7(152)
THUNK_S_8(152)
THUNK_S_9(152)
THUNK_S_10(152)
THUNK_S_11(152)
THUNK_S_12(152)
THUNK_S_13(152)
THUNK_S_14(152)
THUNK_S_15(152)
THUNK_S_16(152)
THUNK_S_17(152)
THUNK_S_18(152)
THUNK_S_19(152)
THUNK_S_20(152)
THUNK_S_1(153)
THUNK_S_2(153)
THUNK_S_3(153)
THUNK_S_4(153)
THUNK_S_5(153)
THUNK_S_6(153)
THUNK_S_7(153)
THUNK_S_8(153)
THUNK_S_9(153)
THUNK_S_10(153)
THUNK_S_11(153)
THUNK_S_12(153)
THUNK_S_13(153)
THUNK_S_14(153)
THUNK_S_15(153)
THUNK_S_16(153)
THUNK_S_17(153)
THUNK_S_18(153)
THUNK_S_19(153)
THUNK_S_20(153)
THUNK_S_1(154)
THUNK_S_2(154)
THUNK_S_3(154)
THUNK_S_4(154)
THUNK_S_5(154)
THUNK_S_6(154)
THUNK_S_7(154)
THUNK_S_8(154)
THUNK_S_9(154)
THUNK_S_10(154)
THUNK_S_11(154)
THUNK_S_12(154)
THUNK_S_13(154)
THUNK_S_14(154)
THUNK_S_15(154)
THUNK_S_16(154)
THUNK_S_17(154)
THUNK_S_18(154)
THUNK_S_19(154)
THUNK_S_20(154)
THUNK_S_1(155)
THUNK_S_2(155)
THUNK_S_3(155)
THUNK_S_4(155)
THUNK_S_5(155)
THUNK_S_6(155)
THUNK_S_7(155)
THUNK_S_8(155)
THUNK_S_9(155)
THUNK_S_10(155)
THUNK_S_11(155)
THUNK_S_12(155)
THUNK_S_13(155)
THUNK_S_14(155)
THUNK_S_15(155)
THUNK_S_16(155)
THUNK_S_17(155)
THUNK_S_18(155)
THUNK_S_19(155)
THUNK_S_20(155)
THUNK_S_1(156)
THUNK_S_2(156)
THUNK_S_3(156)
THUNK_S_4(156)
THUNK_S_5(156)
THUNK_S_6(156)
THUNK_S_7(156)
THUNK_S_8(156)
THUNK_S_9(156)
THUNK_S_10(156)
THUNK_S_11(156)
THUNK_S_12(156)
THUNK_S_13(156)
THUNK_S_14(156)
THUNK_S_15(156)
THUNK_S_16(156)
THUNK_S_17(156)
THUNK_S_18(156)
THUNK_S_19(156)
THUNK_S_20(156)
THUNK_S_1(157)
THUNK_S_2(157)
THUNK_S_3(157)
THUNK_S_4(157)
THUNK_S_5(157)
THUNK_S_6(157)
THUNK_S_7(157)
THUNK_S_8(157)
THUNK_S_9(157)
THUNK_S_10(157)
THUNK_S_11(157)
THUNK_S_12(157)
THUNK_S_13(157)
THUNK_S_14(157)
THUNK_S_15(157)
THUNK_S_16(157)
THUNK_S_17(157)
THUNK_S_18(157)
THUNK_S_19(157)
THUNK_S_20(157)
THUNK_S_1(158)
THUNK_S_2(158)
THUNK_S_3(158)
THUNK_S_4(158)
THUNK_S_5(158)
THUNK_S_6(158)
THUNK_S_7(158)
THUNK_S_8(158)
THUNK_S_9(158)
THUNK_S_10(158)
THUNK_S_11(158)
THUNK_S_12(158)
THUNK_S_13(158)
THUNK_S_14(158)
THUNK_S_15(158)
THUNK_S_16(158)
THUNK_S_17(158)
THUNK_S_18(158)
THUNK_S_19(158)
THUNK_S_20(158)
THUNK_S_1(159)
THUNK_S_2(159)
THUNK_S_3(159)
THUNK_S_4(159)
THUNK_S_5(159)
THUNK_S_6(159)
THUNK_S_7(159)
THUNK_S_8(159)
THUNK_S_9(159)
THUNK_S_10(159)
THUNK_S_11(159)
THUNK_S_12(159)
THUNK_S_13(159)
THUNK_S_14(159)
THUNK_S_15(159)
THUNK_S_16(159)
THUNK_S_17(159)
THUNK_S_18(159)
THUNK_S_19(159)
THUNK_S_20(159)
THUNK_S_1(160)
THUNK_S_2(160)
THUNK_S_3(160)
THUNK_S_4(160)
THUNK_S_5(160)
THUNK_S_6(160)
THUNK_S_7(160)
THUNK_S_8(160)
THUNK_S_9(160)
THUNK_S_10(160)
THUNK_S_11(160)
THUNK_S_12(160)
THUNK_S_13(160)
THUNK_S_14(160)
THUNK_S_15(160)
THUNK_S_16(160)
THUNK_S_17(160)
THUNK_S_18(160)
THUNK_S_19(160)
THUNK_S_20(160)
THUNK_S_1(161)
THUNK_S_2(161)
THUNK_S_3(161)
THUNK_S_4(161)
THUNK_S_5(161)
THUNK_S_6(161)
THUNK_S_7(161)
THUNK_S_8(161)
THUNK_S_9(161)
THUNK_S_10(161)
THUNK_S_11(161)
THUNK_S_12(161)
THUNK_S_13(161)
THUNK_S_14(161)
THUNK_S_15(161)
THUNK_S_16(161)
THUNK_S_17(161)
THUNK_S_18(161)
THUNK_S_19(161)
THUNK_S_20(161)
THUNK_S_1(162)
THUNK_S_2(162)
THUNK_S_3(162)
THUNK_S_4(162)
THUNK_S_5(162)
THUNK_S_6(162)
THUNK_S_7(162)
THUNK_S_8(162)
THUNK_S_9(162)
THUNK_S_10(162)
THUNK_S_11(162)
THUNK_S_12(162)
THUNK_S_13(162)
THUNK_S_14(162)
THUNK_S_15(162)
THUNK_S_16(162)
THUNK_S_17(162)
THUNK_S_18(162)
THUNK_S_19(162)
THUNK_S_20(162)
THUNK_S_1(163)
THUNK_S_2(163)
THUNK_S_3(163)
THUNK_S_4(163)
THUNK_S_5(163)
THUNK_S_6(163)
THUNK_S_7(163)
THUNK_S_8(163)
THUNK_S_9(163)
THUNK_S_10(163)
THUNK_S_11(163)
THUNK_S_12(163)
THUNK_S_13(163)
THUNK_S_14(163)
THUNK_S_15(163)
THUNK_S_16(163)
THUNK_S_17(163)
THUNK_S_18(163)
THUNK_S_19(163)
THUNK_S_20(163)
THUNK_S_1(164)
THUNK_S_2(164)
THUNK_S_3(164)
THUNK_S_4(164)
THUNK_S_5(164)
THUNK_S_6(164)
THUNK_S_7(164)
THUNK_S_8(164)
THUNK_S_9(164)
THUNK_S_10(164)
THUNK_S_11(164)
THUNK_S_12(164)
THUNK_S_13(164)
THUNK_S_14(164)
THUNK_S_15(164)
THUNK_S_16(164)
THUNK_S_17(164)
THUNK_S_18(164)
THUNK_S_19(164)
THUNK_S_20(164)
THUNK_S_1(165)
THUNK_S_2(165)
THUNK_S_3(165)
THUNK_S_4(165)
THUNK_S_5(165)
THUNK_S_6(165)
THUNK_S_7(165)
THUNK_S_8(165)
THUNK_S_9(165)
THUNK_S_10(165)
THUNK_S_11(165)
THUNK_S_12(165)
THUNK_S_13(165)
THUNK_S_14(165)
THUNK_S_15(165)
THUNK_S_16(165)
THUNK_S_17(165)
THUNK_S_18(165)
THUNK_S_19(165)
THUNK_S_20(165)
THUNK_S_1(166)
THUNK_S_2(166)
THUNK_S_3(166)
THUNK_S_4(166)
THUNK_S_5(166)
THUNK_S_6(166)
THUNK_S_7(166)
THUNK_S_8(166)
THUNK_S_9(166)
THUNK_S_10(166)
THUNK_S_11(166)
THUNK_S_12(166)
THUNK_S_13(166)
THUNK_S_14(166)
THUNK_S_15(166)
THUNK_S_16(166)
THUNK_S_17(166)
THUNK_S_18(166)
THUNK_S_19(166)
THUNK_S_20(166)
THUNK_S_1(167)
THUNK_S_2(167)
THUNK_S_3(167)
THUNK_S_4(167)
THUNK_S_5(167)
THUNK_S_6(167)
THUNK_S_7(167)
THUNK_S_8(167)
THUNK_S_9(167)
THUNK_S_10(167)
THUNK_S_11(167)
THUNK_S_12(167)
THUNK_S_13(167)
THUNK_S_14(167)
THUNK_S_15(167)
THUNK_S_16(167)
THUNK_S_17(167)
THUNK_S_18(167)
THUNK_S_19(167)
THUNK_S_20(167)
THUNK_S_1(168)
THUNK_S_2(168)
THUNK_S_3(168)
THUNK_S_4(168)
THUNK_S_5(168)
THUNK_S_6(168)
THUNK_S_7(168)
THUNK_S_8(168)
THUNK_S_9(168)
THUNK_S_10(168)
THUNK_S_11(168)
THUNK_S_12(168)
THUNK_S_13(168)
THUNK_S_14(168)
THUNK_S_15(168)
THUNK_S_16(168)
THUNK_S_17(168)
THUNK_S_18(168)
THUNK_S_19(168)
THUNK_S_20(168)
THUNK_S_1(169)
THUNK_S_2(169)
THUNK_S_3(169)
THUNK_S_4(169)
THUNK_S_5(169)
THUNK_S_6(169)
THUNK_S_7(169)
THUNK_S_8(169)
THUNK_S_9(169)
THUNK_S_10(169)
THUNK_S_11(169)
THUNK_S_12(169)
THUNK_S_13(169)
THUNK_S_14(169)
THUNK_S_15(169)
THUNK_S_16(169)
THUNK_S_17(169)
THUNK_S_18(169)
THUNK_S_19(169)
THUNK_S_20(169)
THUNK_S_1(170)
THUNK_S_2(170)
THUNK_S_3(170)
THUNK_S_4(170)
THUNK_S_5(170)
THUNK_S_6(170)
THUNK_S_7(170)
THUNK_S_8(170)
THUNK_S_9(170)
THUNK_S_10(170)
THUNK_S_11(170)
THUNK_S_12(170)
THUNK_S_13(170)
THUNK_S_14(170)
THUNK_S_15(170)
THUNK_S_16(170)
THUNK_S_17(170)
THUNK_S_18(170)
THUNK_S_19(170)
THUNK_S_20(170)
THUNK_S_1(171)
THUNK_S_2(171)
THUNK_S_3(171)
THUNK_S_4(171)
THUNK_S_5(171)
THUNK_S_6(171)
THUNK_S_7(171)
THUNK_S_8(171)
THUNK_S_9(171)
THUNK_S_10(171)
THUNK_S_11(171)
THUNK_S_12(171)
THUNK_S_13(171)
THUNK_S_14(171)
THUNK_S_15(171)
THUNK_S_16(171)
THUNK_S_17(171)
THUNK_S_18(171)
THUNK_S_19(171)
THUNK_S_20(171)
THUNK_S_1(172)
THUNK_S_2(172)
THUNK_S_3(172)
THUNK_S_4(172)
THUNK_S_5(172)
THUNK_S_6(172)
THUNK_S_7(172)
THUNK_S_8(172)
THUNK_S_9(172)
THUNK_S_10(172)
THUNK_S_11(172)
THUNK_S_12(172)
THUNK_S_13(172)
THUNK_S_14(172)
THUNK_S_15(172)
THUNK_S_16(172)
THUNK_S_17(172)
THUNK_S_18(172)
THUNK_S_19(172)
THUNK_S_20(172)
THUNK_S_1(173)
THUNK_S_2(173)
THUNK_S_3(173)
THUNK_S_4(173)
THUNK_S_5(173)
THUNK_S_6(173)
THUNK_S_7(173)
THUNK_S_8(173)
THUNK_S_9(173)
THUNK_S_10(173)
THUNK_S_11(173)
THUNK_S_12(173)
THUNK_S_13(173)
THUNK_S_14(173)
THUNK_S_15(173)
THUNK_S_16(173)
THUNK_S_17(173)
THUNK_S_18(173)
THUNK_S_19(173)
THUNK_S_20(173)
THUNK_S_1(174)
THUNK_S_2(174)
THUNK_S_3(174)
THUNK_S_4(174)
THUNK_S_5(174)
THUNK_S_6(174)
THUNK_S_7(174)
THUNK_S_8(174)
THUNK_S_9(174)
THUNK_S_10(174)
THUNK_S_11(174)
THUNK_S_12(174)
THUNK_S_13(174)
THUNK_S_14(174)
THUNK_S_15(174)
THUNK_S_16(174)
THUNK_S_17(174)
THUNK_S_18(174)
THUNK_S_19(174)
THUNK_S_20(174)
THUNK_S_1(175)
THUNK_S_2(175)
THUNK_S_3(175)
THUNK_S_4(175)
THUNK_S_5(175)
THUNK_S_6(175)
THUNK_S_7(175)
THUNK_S_8(175)
THUNK_S_9(175)
THUNK_S_10(175)
THUNK_S_11(175)
THUNK_S_12(175)
THUNK_S_13(175)
THUNK_S_14(175)
THUNK_S_15(175)
THUNK_S_16(175)
THUNK_S_17(175)
THUNK_S_18(175)
THUNK_S_19(175)
THUNK_S_20(175)
THUNK_S_1(176)
THUNK_S_2(176)
THUNK_S_3(176)
THUNK_S_4(176)
THUNK_S_5(176)
THUNK_S_6(176)
THUNK_S_7(176)
THUNK_S_8(176)
THUNK_S_9(176)
THUNK_S_10(176)
THUNK_S_11(176)
THUNK_S_12(176)
THUNK_S_13(176)
THUNK_S_14(176)
THUNK_S_15(176)
THUNK_S_16(176)
THUNK_S_17(176)
THUNK_S_18(176)
THUNK_S_19(176)
THUNK_S_20(176)
THUNK_S_1(177)
THUNK_S_2(177)
THUNK_S_3(177)
THUNK_S_4(177)
THUNK_S_5(177)
THUNK_S_6(177)
THUNK_S_7(177)
THUNK_S_8(177)
THUNK_S_9(177)
THUNK_S_10(177)
THUNK_S_11(177)
THUNK_S_12(177)
THUNK_S_13(177)
THUNK_S_14(177)
THUNK_S_15(177)
THUNK_S_16(177)
THUNK_S_17(177)
THUNK_S_18(177)
THUNK_S_19(177)
THUNK_S_20(177)
THUNK_S_1(178)
THUNK_S_2(178)
THUNK_S_3(178)
THUNK_S_4(178)
THUNK_S_5(178)
THUNK_S_6(178)
THUNK_S_7(178)
THUNK_S_8(178)
THUNK_S_9(178)
THUNK_S_10(178)
THUNK_S_11(178)
THUNK_S_12(178)
THUNK_S_13(178)
THUNK_S_14(178)
THUNK_S_15(178)
THUNK_S_16(178)
THUNK_S_17(178)
THUNK_S_18(178)
THUNK_S_19(178)
THUNK_S_20(178)
THUNK_S_1(179)
THUNK_S_2(179)
THUNK_S_3(179)
THUNK_S_4(179)
THUNK_S_5(179)
THUNK_S_6(179)
THUNK_S_7(179)
THUNK_S_8(179)
THUNK_S_9(179)
THUNK_S_10(179)
THUNK_S_11(179)
THUNK_S_12(179)
THUNK_S_13(179)
THUNK_S_14(179)
THUNK_S_15(179)
THUNK_S_16(179)
THUNK_S_17(179)
THUNK_S_18(179)
THUNK_S_19(179)
THUNK_S_20(179)
THUNK_S_1(180)
THUNK_S_2(180)
THUNK_S_3(180)
THUNK_S_4(180)
THUNK_S_5(180)
THUNK_S_6(180)
THUNK_S_7(180)
THUNK_S_8(180)
THUNK_S_9(180)
THUNK_S_10(180)
THUNK_S_11(180)
THUNK_S_12(180)
THUNK_S_13(180)
THUNK_S_14(180)
THUNK_S_15(180)
THUNK_S_16(180)
THUNK_S_17(180)
THUNK_S_18(180)
THUNK_S_19(180)
THUNK_S_20(180)
THUNK_S_1(181)
THUNK_S_2(181)
THUNK_S_3(181)
THUNK_S_4(181)
THUNK_S_5(181)
THUNK_S_6(181)
THUNK_S_7(181)
THUNK_S_8(181)
THUNK_S_9(181)
THUNK_S_10(181)
THUNK_S_11(181)
THUNK_S_12(181)
THUNK_S_13(181)
THUNK_S_14(181)
THUNK_S_15(181)
THUNK_S_16(181)
THUNK_S_17(181)
THUNK_S_18(181)
THUNK_S_19(181)
THUNK_S_20(181)
THUNK_S_1(182)
THUNK_S_2(182)
THUNK_S_3(182)
THUNK_S_4(182)
THUNK_S_5(182)
THUNK_S_6(182)
THUNK_S_7(182)
THUNK_S_8(182)
THUNK_S_9(182)
THUNK_S_10(182)
THUNK_S_11(182)
THUNK_S_12(182)
THUNK_S_13(182)
THUNK_S_14(182)
THUNK_S_15(182)
THUNK_S_16(182)
THUNK_S_17(182)
THUNK_S_18(182)
THUNK_S_19(182)
THUNK_S_20(182)
THUNK_S_1(183)
THUNK_S_2(183)
THUNK_S_3(183)
THUNK_S_4(183)
THUNK_S_5(183)
THUNK_S_6(183)
THUNK_S_7(183)
THUNK_S_8(183)
THUNK_S_9(183)
THUNK_S_10(183)
THUNK_S_11(183)
THUNK_S_12(183)
THUNK_S_13(183)
THUNK_S_14(183)
THUNK_S_15(183)
THUNK_S_16(183)
THUNK_S_17(183)
THUNK_S_18(183)
THUNK_S_19(183)
THUNK_S_20(183)
THUNK_S_1(184)
THUNK_S_2(184)
THUNK_S_3(184)
THUNK_S_4(184)
THUNK_S_5(184)
THUNK_S_6(184)
THUNK_S_7(184)
THUNK_S_8(184)
THUNK_S_9(184)
THUNK_S_10(184)
THUNK_S_11(184)
THUNK_S_12(184)
THUNK_S_13(184)
THUNK_S_14(184)
THUNK_S_15(184)
THUNK_S_16(184)
THUNK_S_17(184)
THUNK_S_18(184)
THUNK_S_19(184)
THUNK_S_20(184)
THUNK_S_1(185)
THUNK_S_2(185)
THUNK_S_3(185)
THUNK_S_4(185)
THUNK_S_5(185)
THUNK_S_6(185)
THUNK_S_7(185)
THUNK_S_8(185)
THUNK_S_9(185)
THUNK_S_10(185)
THUNK_S_11(185)
THUNK_S_12(185)
THUNK_S_13(185)
THUNK_S_14(185)
THUNK_S_15(185)
THUNK_S_16(185)
THUNK_S_17(185)
THUNK_S_18(185)
THUNK_S_19(185)
THUNK_S_20(185)
THUNK_S_1(186)
THUNK_S_2(186)
THUNK_S_3(186)
THUNK_S_4(186)
THUNK_S_5(186)
THUNK_S_6(186)
THUNK_S_7(186)
THUNK_S_8(186)
THUNK_S_9(186)
THUNK_S_10(186)
THUNK_S_11(186)
THUNK_S_12(186)
THUNK_S_13(186)
THUNK_S_14(186)
THUNK_S_15(186)
THUNK_S_16(186)
THUNK_S_17(186)
THUNK_S_18(186)
THUNK_S_19(186)
THUNK_S_20(186)
THUNK_S_1(187)
THUNK_S_2(187)
THUNK_S_3(187)
THUNK_S_4(187)
THUNK_S_5(187)
THUNK_S_6(187)
THUNK_S_7(187)
THUNK_S_8(187)
THUNK_S_9(187)
THUNK_S_10(187)
THUNK_S_11(187)
THUNK_S_12(187)
THUNK_S_13(187)
THUNK_S_14(187)
THUNK_S_15(187)
THUNK_S_16(187)
THUNK_S_17(187)
THUNK_S_18(187)
THUNK_S_19(187)
THUNK_S_20(187)
THUNK_S_1(188)
THUNK_S_2(188)
THUNK_S_3(188)
THUNK_S_4(188)
THUNK_S_5(188)
THUNK_S_6(188)
THUNK_S_7(188)
THUNK_S_8(188)
THUNK_S_9(188)
THUNK_S_10(188)
THUNK_S_11(188)
THUNK_S_12(188)
THUNK_S_13(188)
THUNK_S_14(188)
THUNK_S_15(188)
THUNK_S_16(188)
THUNK_S_17(188)
THUNK_S_18(188)
THUNK_S_19(188)
THUNK_S_20(188)
THUNK_S_1(189)
THUNK_S_2(189)
THUNK_S_3(189)
THUNK_S_4(189)
THUNK_S_5(189)
THUNK_S_6(189)
THUNK_S_7(189)
THUNK_S_8(189)
THUNK_S_9(189)
THUNK_S_10(189)
THUNK_S_11(189)
THUNK_S_12(189)
THUNK_S_13(189)
THUNK_S_14(189)
THUNK_S_15(189)
THUNK_S_16(189)
THUNK_S_17(189)
THUNK_S_18(189)
THUNK_S_19(189)
THUNK_S_20(189)
THUNK_S_1(190)
THUNK_S_2(190)
THUNK_S_3(190)
THUNK_S_4(190)
THUNK_S_5(190)
THUNK_S_6(190)
THUNK_S_7(190)
THUNK_S_8(190)
THUNK_S_9(190)
THUNK_S_10(190)
THUNK_S_11(190)
THUNK_S_12(190)
THUNK_S_13(190)
THUNK_S_14(190)
THUNK_S_15(190)
THUNK_S_16(190)
THUNK_S_17(190)
THUNK_S_18(190)
THUNK_S_19(190)
THUNK_S_20(190)
THUNK_S_1(191)
THUNK_S_2(191)
THUNK_S_3(191)
THUNK_S_4(191)
THUNK_S_5(191)
THUNK_S_6(191)
THUNK_S_7(191)
THUNK_S_8(191)
THUNK_S_9(191)
THUNK_S_10(191)
THUNK_S_11(191)
THUNK_S_12(191)
THUNK_S_13(191)
THUNK_S_14(191)
THUNK_S_15(191)
THUNK_S_16(191)
THUNK_S_17(191)
THUNK_S_18(191)
THUNK_S_19(191)
THUNK_S_20(191)
THUNK_S_1(192)
THUNK_S_2(192)
THUNK_S_3(192)
THUNK_S_4(192)
THUNK_S_5(192)
THUNK_S_6(192)
THUNK_S_7(192)
THUNK_S_8(192)
THUNK_S_9(192)
THUNK_S_10(192)
THUNK_S_11(192)
THUNK_S_12(192)
THUNK_S_13(192)
THUNK_S_14(192)
THUNK_S_15(192)
THUNK_S_16(192)
THUNK_S_17(192)
THUNK_S_18(192)
THUNK_S_19(192)
THUNK_S_20(192)
THUNK_S_1(193)
THUNK_S_2(193)
THUNK_S_3(193)
THUNK_S_4(193)
THUNK_S_5(193)
THUNK_S_6(193)
THUNK_S_7(193)
THUNK_S_8(193)
THUNK_S_9(193)
THUNK_S_10(193)
THUNK_S_11(193)
THUNK_S_12(193)
THUNK_S_13(193)
THUNK_S_14(193)
THUNK_S_15(193)
THUNK_S_16(193)
THUNK_S_17(193)
THUNK_S_18(193)
THUNK_S_19(193)
THUNK_S_20(193)
THUNK_S_1(194)
THUNK_S_2(194)
THUNK_S_3(194)
THUNK_S_4(194)
THUNK_S_5(194)
THUNK_S_6(194)
THUNK_S_7(194)
THUNK_S_8(194)
THUNK_S_9(194)
THUNK_S_10(194)
THUNK_S_11(194)
THUNK_S_12(194)
THUNK_S_13(194)
THUNK_S_14(194)
THUNK_S_15(194)
THUNK_S_16(194)
THUNK_S_17(194)
THUNK_S_18(194)
THUNK_S_19(194)
THUNK_S_20(194)
THUNK_S_1(195)
THUNK_S_2(195)
THUNK_S_3(195)
THUNK_S_4(195)
THUNK_S_5(195)
THUNK_S_6(195)
THUNK_S_7(195)
THUNK_S_8(195)
THUNK_S_9(195)
THUNK_S_10(195)
THUNK_S_11(195)
THUNK_S_12(195)
THUNK_S_13(195)
THUNK_S_14(195)
THUNK_S_15(195)
THUNK_S_16(195)
THUNK_S_17(195)
THUNK_S_18(195)
THUNK_S_19(195)
THUNK_S_20(195)
THUNK_S_1(196)
THUNK_S_2(196)
THUNK_S_3(196)
THUNK_S_4(196)
THUNK_S_5(196)
THUNK_S_6(196)
THUNK_S_7(196)
THUNK_S_8(196)
THUNK_S_9(196)
THUNK_S_10(196)
THUNK_S_11(196)
THUNK_S_12(196)
THUNK_S_13(196)
THUNK_S_14(196)
THUNK_S_15(196)
THUNK_S_16(196)
THUNK_S_17(196)
THUNK_S_18(196)
THUNK_S_19(196)
THUNK_S_20(196)
THUNK_S_1(197)
THUNK_S_2(197)
THUNK_S_3(197)
THUNK_S_4(197)
THUNK_S_5(197)
THUNK_S_6(197)
THUNK_S_7(197)
THUNK_S_8(197)
THUNK_S_9(197)
THUNK_S_10(197)
THUNK_S_11(197)
THUNK_S_12(197)
THUNK_S_13(197)
THUNK_S_14(197)
THUNK_S_15(197)
THUNK_S_16(197)
THUNK_S_17(197)
THUNK_S_18(197)
THUNK_S_19(197)
THUNK_S_20(197)
THUNK_S_1(198)
THUNK_S_2(198)
THUNK_S_3(198)
THUNK_S_4(198)
THUNK_S_5(198)
THUNK_S_6(198)
THUNK_S_7(198)
THUNK_S_8(198)
THUNK_S_9(198)
THUNK_S_10(198)
THUNK_S_11(198)
THUNK_S_12(198)
THUNK_S_13(198)
THUNK_S_14(198)
THUNK_S_15(198)
THUNK_S_16(198)
THUNK_S_17(198)
THUNK_S_18(198)
THUNK_S_19(198)
THUNK_S_20(198)
THUNK_S_1(199)
THUNK_S_2(199)
THUNK_S_3(199)
THUNK_S_4(199)
THUNK_S_5(199)
THUNK_S_6(199)
THUNK_S_7(199)
THUNK_S_8(199)
THUNK_S_9(199)
THUNK_S_10(199)
THUNK_S_11(199)
THUNK_S_12(199)
THUNK_S_13(199)
THUNK_S_14(199)
THUNK_S_15(199)
THUNK_S_16(199)
THUNK_S_17(199)
THUNK_S_18(199)
THUNK_S_19(199)
THUNK_S_20(199)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\unixtearoff.cxx ===
//+------------------------------------------------------------------------
//
//  File:       utearoff.cxx
//
//  Contents:   Tear off interfaces.
//
//  History:
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include <cdutil.hxx>
#include <tearoff.hxx>

typedef HRESULT (FNQI)(void *pv, REFIID iid, void **ppv);
typedef ULONG   (FNAR)(void *pv);

void TearoffCheck()
{
    AssertSz( 0, "Tearoff table too small" );
}

typedef HRESULT (STDMETHODCALLTYPE *PFNQI)(TEAROFF_THIS, REFIID, void **);

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv);

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk);

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk);

typedef void (*PFNVOID)();

#define THUNK_EXTERN(n) EXTERN_C void TearoffThunk##n(TEAROFF_THIS, ...);

THUNK_EXTERN(0) // QI
THUNK_EXTERN(1) // ADDREF
THUNK_EXTERN(2) // RELEASE

THUNK_ARRAY_3_TO_15(EXTERN)
THUNK_ARRAY_16_AND_UP(EXTERN)

#define TEAROFFCHECK_THUNK NONVIRTUAL_METHOD(TearoffCheck, (TEAROFF_THIS))
#define THUNK_ADDRESS(n) NONVIRTUAL_METHOD(TearoffThunk##n, (TEAROFF_THIS))
#define THUNK_PLAIN_ADDRESS(n) ((PLAINPFNTEAROFF)&TearoffThunk##n),

typedef void (CVoid::*PMETHOD)();
#define VTBL_METHOD(apfnVtbl,i) (((PMETHOD *)apfnVtbl)[i+1])

#if defined(UNIX) && defined(hp700)
PLAINPFNTEAROFF g_unixTearOffThunkTable[] = {
    THUNK_PLAIN_ADDRESS(0)
    THUNK_PLAIN_ADDRESS(1)
    THUNK_PLAIN_ADDRESS(2)
    THUNK_ARRAY_3_TO_15(PLAIN_ADDRESS)
    THUNK_ARRAY_16_AND_UP(PLAIN_ADDRESS)
};
#endif
 
NONVIRTUAL_VTABLE_ENTRY s_unixTearOffVtable[] = {
    NULL_METHOD,
//    THUNK_ADDRESS(0)
    NONVIRTUAL_METHOD(PlainQueryInterface, (TEAROFF_THIS, REFIID, void**))
    NONVIRTUAL_METHOD(PlainAddRef, (TEAROFF_THIS))
    NONVIRTUAL_METHOD(PlainRelease, (TEAROFF_THIS))
    THUNK_ARRAY_3_TO_15(ADDRESS)
    THUNK_ARRAY_16_AND_UP(ADDRESS)
#if DBG==1
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK
#endif
};

static void * s_pvCache1 = NULL;
static void * s_pvCache2 = NULL;

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv)
{
	void *pv;
    const void *apfnVtbl;
    IID const * const * ppIID;

    for (ppIID = pthunk->apIID; *ppIID; ppIID++)
    {
        if (**ppIID == iid)
        {
            *ppv = pthunk;
            pthunk->ulRef += 1;
            return S_OK;
        }
    }

    if (pthunk->dwMask & 1)
    {
        pv = pthunk->pvObject2;
        apfnVtbl = pthunk->apfnVtblObject2;
    }
    else
    {
        pv = pthunk->pvObject1;
        apfnVtbl = pthunk->apfnVtblObject1;
    }

    return CALL_METHOD(pv, VTBL_METHOD(apfnVtbl,METHOD_QI), (iid, ppv));
}

void DeinitTearOffCache()
{
    MemFree(s_pvCache1);
    MemFree(s_pvCache2);
}

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk)
{
    return ++pthunk->ulRef;
}

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk)
{
    WHEN_DBG(static long l = 0; l++;)

    Assert( pthunk->ulRef > 0 );

    if (--pthunk->ulRef == 0)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & METHOD_MASK( METHOD_RELEASE )) == 0)
        {
            CALL_METHOD(pthunk->pvObject1, VTBL_METHOD(pthunk->apfnVtblObject1,METHOD_RELEASE), ());            
        }
        if (pthunk->pvObject2)
        {
            CALL_METHOD(pthunk->pvObject2, VTBL_METHOD(pthunk->apfnVtblObject2,METHOD_RELEASE), ());            
        }

        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1,  pthunk );

        if (pthunk)
        {
            pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2,  pthunk );

            if (pthunk)
            {
                MemFree( pthunk );
            }
        }

        return 0;
    }

    return pthunk->ulRef;
}

//+------------------------------------------------------------------------
//
//  Function:   CreateTearOffTunk
//
//  Synopsis:   Create a tearoff interface thunk. The returned object
//              must be AddRef'ed by the caller.
//
//  Arguments:  pvObject    Delegate to this object using...
//              apfnObject    ...this array of pointers to member functions.
//              pUnkOuter   Delegate IUnknown methods to this object.
//              ppvThunk    The returned thunk.
//              pvObject2   Delegate to this object instead...
//              apfnObject2   ... this array of pointers to functions...
//              dwMask        ... when the index of the method call is
//                            marked in this mask.
//
//  Notes:      The basic implementation here consists of a thunk with
//              a pointer to two different objects.  If the second object
//              is NULL, it is assumed to be the first object.  This
//              is the logic of the thunks:
//
//                  i is the index of the method that is called.
//
//                  if (i < 16)
//                  {
//                      if (dwMask & 2^i)
//                      {
//                          Delegate to pvObject2 using apfnObject2
//                      }
//                  }
//                  Delegate to pvObject1 using apfnObject1
//
//-------------------------------------------------------------------------

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void *apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      pvObject2,
        void *      apfn2,
        DWORD       dwMask,
        const IID * const * apIID,
		void *		appropdescsInVtblOrder)
{
#   define ADD_REL_MASK (METHOD_MASK( METHOD_ADDREF ) || METHOD_MASK( METHOD_RELEASE ))

    TEAROFF_THUNK * pthunk;

    Assert(ppvThunk);
    Assert(apfn1);
    Assert((!pvObject2 && !apfn2) || (pvObject2 && apfn2));
    Assert(!(dwMask & 0xFFFF0000) && "Only 16 overrides allowed");
    Assert(!dwMask || (dwMask && pvObject2));
    Assert(!pUnkOuter || (dwMask == 0 && pvObject2 == 0));
    Assert((dwMask & ADD_REL_MASK) == 0 || ((dwMask & ADD_REL_MASK) == ADD_REL_MASK));

    if (pUnkOuter)
    {
        pvObject2 = pUnkOuter;
        apfn2 = *(void **)pUnkOuter;
        dwMask = METHOD_MASK( METHOD_QI );
    }

    pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, NULL);

    if (!pthunk)
    {
        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, NULL);

        if (!pthunk)
        {
            pthunk = (TEAROFF_THUNK *) _MemAlloc(sizeof(TEAROFF_THUNK));

            MemSetName((pthunk, "Tear-Off Thunk - owner=%08x", pvObject1));
        }
    }

    if (!pthunk)
    {
        *ppvThunk = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    pthunk->papfnVtblThis = s_unixTearOffVtable;
    pthunk->ulRef = 0;
    pthunk->pvObject1 = pvObject1;
    pthunk->apfnVtblObject1 = apfn1;
    pthunk->pvObject2 = pvObject2;
    pthunk->apfnVtblObject2 = apfn2;
    pthunk->dwMask = dwMask;
    pthunk->apIID = apIID ? apIID : (const IID * const *)&g_Zero;
	pthunk->apVtblPropDesc = appropdescsInVtblOrder;

    if (pvObject1 && (dwMask & METHOD_MASK( METHOD_ADDREF )) == 0)
    {
        CALL_METHOD(pthunk->pvObject1, VTBL_METHOD(pthunk->apfnVtblObject1,METHOD_ADDREF), ());
    }
    if (pvObject2)
    {
        CALL_METHOD(pthunk->pvObject2, VTBL_METHOD(pthunk->apfnVtblObject2,METHOD_ADDREF), ());
    }
    *ppvThunk = pthunk;

    return S_OK;
}

// Short argument list version saves space in calling functions.

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
		void *	    appropdescsInVtblOrder)
{
    return CreateTearOffThunk(
            pvObject1, 
            apfn1, 
            pUnkOuter, 
            ppvThunk, 
            NULL, 
            NULL, 
            0, 
            NULL,
			appropdescsInVtblOrder);
}

HRESULT
InstallTearOffObject(void * pvthunk, void * pvObject, void *apfn, DWORD dwMask)
{
    TEAROFF_THUNK *pthunk = (TEAROFF_THUNK*)pvthunk;

    // This assert is for the asm code that decodes the thunk
    // Since TEAROFF_THUNK is only defined in this file, I
    // call this here.  If this changes a lot of stuff needs
    // to be changed with it.  (jbeda)
    Assert(offsetof(TEAROFF_THUNK, pvObject2) == 20);

    Assert(pthunk);
    Assert(!pthunk->pvObject2);
    Assert(!pthunk->apfnVtblObject2);
    Assert(!pthunk->dwMask);

    pthunk->pvObject2 = pvObject;
    pthunk->apfnVtblObject2 = apfn;
    pthunk->dwMask = dwMask;

    if (pvObject)
    {
        CALL_METHOD(pvObject, VTBL_METHOD(apfn,1), ());
    }

    return S_OK;
}

// Add this to improve the Trident performance.
extern "C" MwFastGetCursorPos(POINT *pt);
BOOL GetCursorPos(LPPOINT pt)
{
    MwFastGetCursorPos(pt);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\wraprect.cxx ===
//
// Trident 16 bit source only.
//
// Provides wrappers for some common GID Apis that take long rectangles in 32bit
// world and take small rectangles in 16bit world.

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

void    WINAPI ClientToScreen(HWND hwnd, POINTL FAR* lpp)
{
    ClientToScreen(hwnd, (CPointAutoconvert) lpp);
}

void    WINAPI ScreenToClient(HWND hwnd, POINTL FAR* lpp)
{
    ScreenToClient(hwnd, (CPointAutoconvert) lpp);
}

void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINTL FAR* lppt, UINT cpt)
{
    CPointAutoconvertArray aryPts(lppt, cpt);
    MapWindowPoints(hwndFrom, hwndTo, aryPts, cpt);
}

HWND    WINAPI WindowFromPoint(POINTL ptl)
{
    POINTword pt={ptl.x, ptl.y};
    return WindowFromPoint(pt);
}

HWND    WINAPI ChildWindowFromPoint(HWND hwnd, POINTL ptl)
{
    POINTword pt={ptl.x, ptl.y};
    return ChildWindowFromPoint(hwnd, pt);
}

void    WINAPI GetCursorPos(POINTL FAR* lpp)
{
    // could save stack space and actually use lpp, but I won't!
    POINTword pt;
    GetCursorPos(&pt);
    lpp->x = pt.x;
    lpp->y = pt.y;
}

void    WINAPI GetCaretPos(POINTL FAR* lpp)
{
    POINTword pt;
    GetCaretPos(&pt);
    lpp->x = pt.x;
    lpp->y = pt.y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\amd64\thunks.asm ===
;----------------------------------------------------------------------------
;
; File:     thunks.asm
;
; Contains: Assembly code for the AMD64. Implements the dynamic vtable stuff
;           and the tearoff code.
;
;----------------------------------------------------------------------------

include ksamd64.inc

offsetof_pvObject1 equ 24
offsetof_pvObject2 equ 40
offsetof_apfn equ 32
offsetof_mask equ 56
offsetof_n equ 60

;----------------------------------------------------------------------------
;
;  Function:  GetTearoff
;
;  Synopsis:  This function returns the tearoff thunk pointer stored in
;             the temp register r11. This should be called first thing from
;             the C++ functions that handles calls to torn-off interfaces
;
;  N.B. Warning - This method of passing the tearoff pointer in a volatile
;       register is unreliable. If the callee allocates more than a page of
;       memory, then check stack (__chkstk) will be called. Check stack
;       destroys all volatile registers.
;
;----------------------------------------------------------------------------

        LEAF_ENTRY _GetTearoff, _TEXT$00

        mov     rax, r11                ; set tearoff pointer
        ret                             ; return

        LEAF_END _GetTearoff, _TEXT$00

;----------------------------------------------------------------------------
;
;  Function:  TearOffCompareThunk
;
;  Synopsis:  The "handler" function that handles calls to torn-off interfaces
;
;  Notes:     Delegates to methods in the function pointer array held by
;             the CTearOffThunk class
;
;----------------------------------------------------------------------------

COMPARE_THUNK macro Number

        LEAF_ENTRY TearoffThunk&Number, _TEXT$00

        mov     r11, rcx                ; save tearoff pointer
        mov     eax, offsetof_pvObject1 ; assume first object
        test    dword ptr offsetof_mask[rcx], 1 SHL &Number ; test if mask bit set
        jz      short @f                ; if z, use first object
        mov     eax, offsetof_pvObject2 ; set for second object
@@:     mov     dword ptr offsetof_n[rcx], &Number ; set index of called method
        mov     r10, 8[rcx][rax]        ; get function array address
        mov     rcx, [rcx][rax]         ; set 'this" pointer
        jmp     qword ptr (8 * &Number)[r10] ; jump to function

        LEAF_END TearoffThunk&Number, _TEXT$00

        endm

;
; Generate compare thunks 3 - 15.
;

index = 3

        rept    (15 - 3 + 1)

        COMPARE_THUNK %index

index = index + 1

        endm

;----------------------------------------------------------------------------
;
;  Function:  CallTearOffSimpleThunk
;
;  Synopsis:  The "handler" function that handles calls to torn-off interfaces
;
;  Notes:     Delegates to methods in the function pointer array held by
;             the CTearOffThunk class
;
;----------------------------------------------------------------------------

SIMPLE_THUNK macro Number

        LEAF_ENTRY TearoffThunk&Number, _TEXT$00

        mov     r11, rcx                ; save tearoff pointer
        mov     dword ptr offsetof_n[rcx], &Number ; set index of called method
        mov     rax, offsetof_apfn[rcx] ; get function array address
        mov     rcx, offsetof_pvObject1[rcx] ; get object address
        jmp     qword ptr (8 * &Number)[rax] ; jump to function

        LEAF_END TearoffThunk&Number, _TEXT$00

        endm

;
; Generate simple thunks 16 - 199.
;

index = 16

        rept    (199 - 16 + 1)

        SIMPLE_THUNK %index

index = index + 1

        endm

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\unix\teartest.cxx ===
#include <stdio.h>

#define EMPTY_CVOID
#ifdef EMPTY_CVOID

class CVoid
{
    virtual void _dummy()=0;
};

/*
(/ms/SUNWspro/bin/dbx) examine pd /20
0xefffe040:	 0x000213e0 0x00000001 0x00000002 0x000213b8
0xefffe050:	 0x00000003 0x00010a50 0x00000001 0xefffe0bc
0xefffe060:	 0xefffe0c4 0x00021000 0x00000000 0x00000000
0xefffe070:	 0x00000000 0x00000000 0x00000000 0x00000000
0xefffe080:	 0x00000000 0x00000000 0x00000000 0x00000000
(/ms/SUNWspro/bin/dbx) examine 0x213b8 /40
0x000213b8: __0dECDerG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010b78
0x000213c8: __0dECDerG__vtbl+0x0010:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x000213d8: __0dECDerG__vtbl+0x0020:	 0x00000000 0x00010d38 0x00000000 0x00000000 <-- *this
0x000213e8: __0dECDerG__vtbl+0x0030:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x000213f8: __0dFCBaseG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010e00
0x00021408: __0dFCBaseG__vtbl+0x0010:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x00021418: __0dFCBaseG__vtbl+0x0020:	 0x00000000 0x00021340 0x00000000 0x00000000
0x00021428: __0dFCBaseG__vtbl+0x0030:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x00021438: __0dEIUnkG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00021340
0x00021448: __0dEIUnkG__vtbl+0x0010:	 0x00000000 0x00021340 0x00000000 0x00000000
(/ms/SUNWspro/bin/dbx) examine 0x10b78
0x00010b78: ~CDer       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10cf0
0x00010cf0: a       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10ca8
0x00010ca8: b       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10d38
0x00010d38: c       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10e00
0x00010e00: ~CBase       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx)
*/

#else

class CVoid
{
    virtual void _dummy() {}
};

/*
(/ms/SUNWspro/bin/dbx) examine 0x2142c /40
0x0002142c: __0dECDerG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010ca8
0x0002143c: __0dECDerG__vtbl+0x0010:	 0x00000000 0x00010b78 0x00000000 0x00010d10
0x0002144c: __0dECDerG__vtbl+0x0020:	 0x00000000 0x00010cc8 0x00000000 0x00010d58
0x0002145c: __0dECDerG__vtbl+0x0030:	 0x00000000 0x00000000 0xfffc0000 0x00010d10
0x0002146c: __0dECDerG__vtbl+0x0040:	 0xfffc0000 0x00010cc8 0x00000000 0x00000000
0x0002147c: __0dFCBaseG__vtbl+0x0008:	 0x00000000 0x00010ca8 0x00000000 0x00010e38
0x0002148c: __0dFCBaseG__vtbl+0x0018:	 0x00000000 0x00010d10 0x00000000 0x00010cc8
0x0002149c: __0dFCBaseG__vtbl+0x0028:	 0x00000000 0x000213b0 0x00000000 0x00000000
0x000214ac: __0dFCBaseG__vtbl+0x0038:	 0xfffc0000 0x00010d10 0xfffc0000 0x00010cc8
0x000214bc: __0dFCVoidG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010ca8
(/ms/SUNWspro/bin/dbx) examine 0x10ca8
0x00010ca8: _dummy       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10b78
0x00010b78: ~CDer       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10d10
0x00010d10: a       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10cc8
0x00010cc8: b       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10d58
0x00010d58: c       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) 
*/

#endif

class IUnk
{
public:
    virtual void ia() = 0;
    virtual void ib() = 0;
};

class IPrivUnk
{
public:
    virtual void a() = 0;
    virtual void b() = 0;
};


class CBase : public CVoid, IPrivUnk
{
public:

typedef void (CBase::*PFNTEAROFF)(void);

static PFNTEAROFF s_tearoff[];

public:
    int _a;
    int _b;

    CBase() : _a(1), _b(2) {}
    virtual ~CBase() {}

    virtual void a(){ printf ("%d\n", _a); }
    virtual void b(){ printf ("%d\n", _b); }

    virtual void c() = 0;

private:
    virtual void _dummy(){}
};

class CDer : public CBase
{
public:
    int _c;

    CDer() : _c(3) {}
    virtual ~CDer() {}

    virtual void c(){ printf ("%d\n", _c); }
};

void done(CDer *pd, CVoid *pv, CVoid *pvv, IUnk* pi)
{
    pi->ia();
    ((CBase*)pv)->a();

    printf ("Done\n");
}

CBase::PFNTEAROFF CBase::s_tearoff[] = { (PFNTEAROFF) (void(CVoid::*)())a };

int main()
{
    CDer d;
    done(&d, (CVoid*)&d, (CVoid*)(void*)&d, (IUnk*)&d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\unix\hp700\thunks.s ===
//----------------------------------------------------------------------------
 //
 // File:     thunks.S
 //
 // Contains: Assembly code for the PARISC - hand tuned from a generated .S file
 //
 //----------------------------------------------------------------------------

//#include <tearoff.hxx>



#define this        %r26
#define sp          %r30

#define offset      %r19
#define vtbl        %r20
#define index       %r21
#define dwMask      %r19         // CAREFULL!!! same as offset....
#define pfn         %r22

 //
 // Here's the layout of the 'this' object
 //
 // offset  value
 //
 //     0   don't care
 //     4   don't care
 //     8   don't care
 //     12  pvObject1's this
 //     16  pvObject1's function table
 //     20  pvObject2's this
 //     24  pvObject2's function table
 //     28  mask to decide whether to use Object 1 or 2
 //     32  index of method into vtbl
 //  Note:   Look in unixtearoff.cxx for latest structure definition
 //

#define off_pvObject1           12
#define off_pvObjectVtbl1       16
#define off_pvObject2           20
#define off_dwMask              28
#define off_dwN			32

#define objvtblDelta           (off_pvObjectVtbl1 - off_pvObject1)

 //----------------------------------------------------------------------------
//----------------------------------------------------------------------------

#define COMPLETE_THUNK(n)                                                                           !\
L$CompleteThunk##n                                                                                  !\
    LDH     ((8*(n+1))+0)(vtbl), offset                 /* offset = vtbl[n].offset */               !\
    EXTRS   offset,31,16,offset                                                                     !\
    LDW     ((8*(n+1))+4)(vtbl), pfn                    /* pfn = vtbl[n].pfn */                     !\
    LDH     ((8*(n+1))+2)(vtbl), index                  /* index = vtbl[n].realVtblIndex */         !\
    EXTRS   index,31,16,index                                                                       !\
                                                                                                    !\
    COMB,<= index,0,L$NonVirtual##n                     /* if ( index <= 0 ) goto NonVirtual */     !\
    NOP                                                                                             !\
                                                                                                    !\
/* Virtual */                                                                                       !\
    ADD     this,pfn,this                               /* this += (vtbl_offset)pfn */              !\
    LDW     0(this),vtbl                                /* vtbl = *this */                          !\
    SUB     this,pfn,this                               /* this -= (vtbl_offset)pfn */              !\
                                                                                                    !\
    SH3ADD  index,vtbl,vtbl                             /* vtbl += index * sizeof(VTBLENTRY) */     !\
                                                                                                    !\
    ADD     offset,this,this                            /* this += offset */                        !\
    LDW     4(vtbl), pfn                                /* pfn = vtbl->pfn */                       !\
    LDH     0(vtbl), offset                             /* offset = vtbl->offset */                 !\
                                                                                                    !\
L$NonVirtual##n                                                                                     !\
    ADD     offset,this,this                            /* this += offset; */                       !\
    LDWS    2(pfn), %r19                                                                            !\
    LDWS    -2(pfn),pfn                                                                             !\
    LDSID   (pfn), vtbl                                                                             !\
    MTSP    vtbl, %sr0                                                                              !\
    BE      0(%sr0,pfn)                                 /* func(); */                               !\
    NOP


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define THUNK_IMPLEMENT_SIMPLE(n)                \
! .SPACE $TEXT$                                  \
! .SUBSPA $CODE$                                 \
! .EXPORT TearoffThunk##n                        \
                                                !\
TearoffThunk##n                                 !\
                                                !\
        ADDI    n, %r0, %r28                    !\
        LDO     off_dwN(this), dwMask           !\
        STW     %r28, 0(dwMask)                 !\
        COPY    this, %r28                      !\
                                                !\
        LDW     off_pvObjectVtbl1(this),vtbl    !\
        LDW     off_pvObject1(this),this        !\
                                                !\
        COMPLETE_THUNK(n)                       !\



//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define THUNK_IMPLEMENT_COMPARE(n)               \
! .SPACE $TEXT$                                  \
! .SUBSPA $CODE$                                 \
! .EXPORT TearoffThunk##n                        \
                                                !\
TearoffThunk##n                                 !\
        ADDI    n, %r0, %r28                    !\
        LDO     off_dwN(this), dwMask           !\
        STW     %r28, 0(dwMask)                 !\
        COPY    this, %r28                      !\
                                                !\
        LDW          28(this), dwMask           !\
        EXTRS,>=   dwMask,31-n,1,%r0            !\
        LDO          8(this),this               !\
                                                !\
        LDW     off_pvObjectVtbl1(this),vtbl    !\
        LDW     off_pvObject1(this),this        !\
                                                !\
        COMPLETE_THUNK(n)                       !\

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define THUNK_IMPLEMENT_CRASH(n)                 \
! .SPACE $TEXT$                                  \
! .SUBSPA $CODE$                                 \
! .EXPORT TearoffThunk##n                        \
                                                !\
TearoffThunk##n                                 !\
        ADDI    0, %r0, %r28                    !\
        STW     %r28, 0(%r28)                   

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
        .SPACE  $TEXT$
        .SUBSPA $CODE$,QUAD=0,ALIGN=4,ACCESS=0x2c,CODE_ONLY,SORT=24

        .EXPORT doThunk__12CMethodThunkFv,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkFv

        .EXPORT doThunk__12CMethodThunkFPve,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,ARGW2=GR,ARGW3=GR,RTNVAL=GR
doThunk__12CMethodThunkFPve

        .EXPORT doThunk__12CMethodThunkFie,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,ARGW2=GR,ARGW3=GR,RTNVAL=GR
doThunk__12CMethodThunkFie

        .EXPORT doThunk__12CMethodThunkFR16TextContextEvent,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkFR16TextContextEvent

        .EXPORT doThunk__12CMethodThunkFPFP6HWND__UiT2l_le,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkFPFP6HWND__UiT2l_le

        .EXPORT doThunk__12CMethodThunkF5_GUIDe,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkF5_GUIDe

        STW     %r2,-0x18(%r30)                             /* store the return address */
        LDW     4(this),vtbl                 
        LDW     0(this),this                
        LDO     -8(vtbl),vtbl
        BL      L$CompleteThunk0,%r0
        NOP


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
        .SPACE  $TEXT$
        .SUBSPA $CODE$
        .EXPORT _GetTearoff,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
_GetTearoff
        BV      %r0(%r2)
        NOP


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//
//      Define IUnknown thunks (0 - 2) only used by unixtearoff.cxx (simple)
//      Define the thunks from 3 to 15 (compare thunks)
//      Define the thunks from 16 onwards (simple thunks)
//


THUNK_IMPLEMENT_COMPARE(0)
THUNK_IMPLEMENT_SIMPLE(1)
THUNK_IMPLEMENT_SIMPLE(2)

//THUNK_IMPLEMENT_CRASH(3)
THUNK_IMPLEMENT_COMPARE(3)
THUNK_IMPLEMENT_COMPARE(4)
THUNK_IMPLEMENT_COMPARE(5)
THUNK_IMPLEMENT_COMPARE(6)
THUNK_IMPLEMENT_COMPARE(7)
THUNK_IMPLEMENT_COMPARE(8)
THUNK_IMPLEMENT_COMPARE(9)
THUNK_IMPLEMENT_COMPARE(10)
THUNK_IMPLEMENT_COMPARE(11)
THUNK_IMPLEMENT_COMPARE(12)
THUNK_IMPLEMENT_COMPARE(13)
THUNK_IMPLEMENT_COMPARE(14)
THUNK_IMPLEMENT_COMPARE(15)

THUNK_IMPLEMENT_SIMPLE(16)
THUNK_IMPLEMENT_SIMPLE(17)
THUNK_IMPLEMENT_SIMPLE(18)
THUNK_IMPLEMENT_SIMPLE(19)
THUNK_IMPLEMENT_SIMPLE(20)
THUNK_IMPLEMENT_SIMPLE(21)
THUNK_IMPLEMENT_SIMPLE(22)
THUNK_IMPLEMENT_SIMPLE(23)
THUNK_IMPLEMENT_SIMPLE(24)
THUNK_IMPLEMENT_SIMPLE(25)
THUNK_IMPLEMENT_SIMPLE(26)
THUNK_IMPLEMENT_SIMPLE(27)
THUNK_IMPLEMENT_SIMPLE(28)
THUNK_IMPLEMENT_SIMPLE(29)
THUNK_IMPLEMENT_SIMPLE(30)
THUNK_IMPLEMENT_SIMPLE(31)
THUNK_IMPLEMENT_SIMPLE(32)
THUNK_IMPLEMENT_SIMPLE(33)
THUNK_IMPLEMENT_SIMPLE(34)
THUNK_IMPLEMENT_SIMPLE(35)
THUNK_IMPLEMENT_SIMPLE(36)
THUNK_IMPLEMENT_SIMPLE(37)
THUNK_IMPLEMENT_SIMPLE(38)
THUNK_IMPLEMENT_SIMPLE(39)
THUNK_IMPLEMENT_SIMPLE(40)
THUNK_IMPLEMENT_SIMPLE(41)
THUNK_IMPLEMENT_SIMPLE(42)
THUNK_IMPLEMENT_SIMPLE(43)
THUNK_IMPLEMENT_SIMPLE(44)
THUNK_IMPLEMENT_SIMPLE(45)
THUNK_IMPLEMENT_SIMPLE(46)
THUNK_IMPLEMENT_SIMPLE(47)
THUNK_IMPLEMENT_SIMPLE(48)
THUNK_IMPLEMENT_SIMPLE(49)
THUNK_IMPLEMENT_SIMPLE(50)
THUNK_IMPLEMENT_SIMPLE(51)
THUNK_IMPLEMENT_SIMPLE(52)
THUNK_IMPLEMENT_SIMPLE(53)
THUNK_IMPLEMENT_SIMPLE(54)
THUNK_IMPLEMENT_SIMPLE(55)
THUNK_IMPLEMENT_SIMPLE(56)
THUNK_IMPLEMENT_SIMPLE(57)
THUNK_IMPLEMENT_SIMPLE(58)
THUNK_IMPLEMENT_SIMPLE(59)
THUNK_IMPLEMENT_SIMPLE(60)
THUNK_IMPLEMENT_SIMPLE(61)
THUNK_IMPLEMENT_SIMPLE(62)
THUNK_IMPLEMENT_SIMPLE(63)
THUNK_IMPLEMENT_SIMPLE(64)
THUNK_IMPLEMENT_SIMPLE(65)
THUNK_IMPLEMENT_SIMPLE(66)
THUNK_IMPLEMENT_SIMPLE(67)
THUNK_IMPLEMENT_SIMPLE(68)
THUNK_IMPLEMENT_SIMPLE(69)
THUNK_IMPLEMENT_SIMPLE(70)
THUNK_IMPLEMENT_SIMPLE(71)
THUNK_IMPLEMENT_SIMPLE(72)
THUNK_IMPLEMENT_SIMPLE(73)
THUNK_IMPLEMENT_SIMPLE(74)
THUNK_IMPLEMENT_SIMPLE(75)
THUNK_IMPLEMENT_SIMPLE(76)
THUNK_IMPLEMENT_SIMPLE(77)
THUNK_IMPLEMENT_SIMPLE(78)
THUNK_IMPLEMENT_SIMPLE(79)
THUNK_IMPLEMENT_SIMPLE(80)
THUNK_IMPLEMENT_SIMPLE(81)
THUNK_IMPLEMENT_SIMPLE(82)
THUNK_IMPLEMENT_SIMPLE(83)
THUNK_IMPLEMENT_SIMPLE(84)
THUNK_IMPLEMENT_SIMPLE(85)
THUNK_IMPLEMENT_SIMPLE(86)
THUNK_IMPLEMENT_SIMPLE(87)
THUNK_IMPLEMENT_SIMPLE(88)
THUNK_IMPLEMENT_SIMPLE(89)
THUNK_IMPLEMENT_SIMPLE(90)
THUNK_IMPLEMENT_SIMPLE(91)
THUNK_IMPLEMENT_SIMPLE(92)
THUNK_IMPLEMENT_SIMPLE(93)
THUNK_IMPLEMENT_SIMPLE(94)
THUNK_IMPLEMENT_SIMPLE(95)
THUNK_IMPLEMENT_SIMPLE(96)
THUNK_IMPLEMENT_SIMPLE(97)
THUNK_IMPLEMENT_SIMPLE(98)
THUNK_IMPLEMENT_SIMPLE(99)
THUNK_IMPLEMENT_SIMPLE(100)
THUNK_IMPLEMENT_SIMPLE(101)
THUNK_IMPLEMENT_SIMPLE(102)
THUNK_IMPLEMENT_SIMPLE(103)
THUNK_IMPLEMENT_SIMPLE(104)
THUNK_IMPLEMENT_SIMPLE(105)
THUNK_IMPLEMENT_SIMPLE(106)
THUNK_IMPLEMENT_SIMPLE(107)
THUNK_IMPLEMENT_SIMPLE(108)
THUNK_IMPLEMENT_SIMPLE(109)
THUNK_IMPLEMENT_SIMPLE(110)
THUNK_IMPLEMENT_SIMPLE(111)
THUNK_IMPLEMENT_SIMPLE(112)
THUNK_IMPLEMENT_SIMPLE(113)
THUNK_IMPLEMENT_SIMPLE(114)
THUNK_IMPLEMENT_SIMPLE(115)
THUNK_IMPLEMENT_SIMPLE(116)
THUNK_IMPLEMENT_SIMPLE(117)
THUNK_IMPLEMENT_SIMPLE(118)
THUNK_IMPLEMENT_SIMPLE(119)
THUNK_IMPLEMENT_SIMPLE(120)
THUNK_IMPLEMENT_SIMPLE(121)
THUNK_IMPLEMENT_SIMPLE(122)
THUNK_IMPLEMENT_SIMPLE(123)
THUNK_IMPLEMENT_SIMPLE(124)
THUNK_IMPLEMENT_SIMPLE(125)
THUNK_IMPLEMENT_SIMPLE(126)
THUNK_IMPLEMENT_SIMPLE(127)
THUNK_IMPLEMENT_SIMPLE(128)
THUNK_IMPLEMENT_SIMPLE(129)
THUNK_IMPLEMENT_SIMPLE(130)
THUNK_IMPLEMENT_SIMPLE(131)
THUNK_IMPLEMENT_SIMPLE(132)
THUNK_IMPLEMENT_SIMPLE(133)
THUNK_IMPLEMENT_SIMPLE(134)
THUNK_IMPLEMENT_SIMPLE(135)
THUNK_IMPLEMENT_SIMPLE(136)
THUNK_IMPLEMENT_SIMPLE(137)
THUNK_IMPLEMENT_SIMPLE(138)
THUNK_IMPLEMENT_SIMPLE(139)
THUNK_IMPLEMENT_SIMPLE(140)
THUNK_IMPLEMENT_SIMPLE(141)
THUNK_IMPLEMENT_SIMPLE(142)
THUNK_IMPLEMENT_SIMPLE(143)
THUNK_IMPLEMENT_SIMPLE(144)
THUNK_IMPLEMENT_SIMPLE(145)
THUNK_IMPLEMENT_SIMPLE(146)
THUNK_IMPLEMENT_SIMPLE(147)
THUNK_IMPLEMENT_SIMPLE(148)
THUNK_IMPLEMENT_SIMPLE(149)
THUNK_IMPLEMENT_SIMPLE(150)
THUNK_IMPLEMENT_SIMPLE(151)
THUNK_IMPLEMENT_SIMPLE(152)
THUNK_IMPLEMENT_SIMPLE(153)
THUNK_IMPLEMENT_SIMPLE(154)
THUNK_IMPLEMENT_SIMPLE(155)
THUNK_IMPLEMENT_SIMPLE(156)
THUNK_IMPLEMENT_SIMPLE(157)
THUNK_IMPLEMENT_SIMPLE(158)
THUNK_IMPLEMENT_SIMPLE(159)
THUNK_IMPLEMENT_SIMPLE(160)
THUNK_IMPLEMENT_SIMPLE(161)
THUNK_IMPLEMENT_SIMPLE(162)
THUNK_IMPLEMENT_SIMPLE(163)
THUNK_IMPLEMENT_SIMPLE(164)
THUNK_IMPLEMENT_SIMPLE(165)
THUNK_IMPLEMENT_SIMPLE(166)
THUNK_IMPLEMENT_SIMPLE(167)
THUNK_IMPLEMENT_SIMPLE(168)
THUNK_IMPLEMENT_SIMPLE(169)
THUNK_IMPLEMENT_SIMPLE(170)
THUNK_IMPLEMENT_SIMPLE(171)
THUNK_IMPLEMENT_SIMPLE(172)
THUNK_IMPLEMENT_SIMPLE(173)
THUNK_IMPLEMENT_SIMPLE(174)
THUNK_IMPLEMENT_SIMPLE(175)
THUNK_IMPLEMENT_SIMPLE(176)
THUNK_IMPLEMENT_SIMPLE(177)
THUNK_IMPLEMENT_SIMPLE(178)
THUNK_IMPLEMENT_SIMPLE(179)
THUNK_IMPLEMENT_SIMPLE(180)
THUNK_IMPLEMENT_SIMPLE(181)
THUNK_IMPLEMENT_SIMPLE(182)
THUNK_IMPLEMENT_SIMPLE(183)
THUNK_IMPLEMENT_SIMPLE(184)
THUNK_IMPLEMENT_SIMPLE(185)
THUNK_IMPLEMENT_SIMPLE(186)
THUNK_IMPLEMENT_SIMPLE(187)
THUNK_IMPLEMENT_SIMPLE(188)
THUNK_IMPLEMENT_SIMPLE(189)
THUNK_IMPLEMENT_SIMPLE(190)
THUNK_IMPLEMENT_SIMPLE(191)
THUNK_IMPLEMENT_SIMPLE(192)
THUNK_IMPLEMENT_SIMPLE(193)
THUNK_IMPLEMENT_SIMPLE(194)
THUNK_IMPLEMENT_SIMPLE(195)
THUNK_IMPLEMENT_SIMPLE(196)
THUNK_IMPLEMENT_SIMPLE(197)
THUNK_IMPLEMENT_SIMPLE(198)
THUNK_IMPLEMENT_SIMPLE(199)

.END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\wutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       wutils.cxx
//
//  Contents:   Windows helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

DeclareTagOther(tagCombineRects,    "Combine Rects",        "CombineRects status")

//+----------------------------------------------------------------------------
//
//  Function:   CombineRectsAggressive
//
//  Synopsis:   Given an array of non-overlapping rectangles sorted top-to-bottom,
//              left-to-right combine them agressively, where there may
//              be some extra area create (but not too much).
//
//  Arguments:  pcRects     - Number of RECTs passed
//              arc         - Array of RECTs
//
//  Returns:    pcRects - Count of combined RECTs
//              arc     - Array of combined RECTs
//
//  NOTE: 1) RECTs must be sorted top-to-bottom, left-to-right and cannot be overlapping
//        2) arc is not reduced in size, the unused entries at the end are ignored
//
//-----------------------------------------------------------------------------
void
CombineRectsAggressive(int *pcRects, RECT *arc)
{
    int cRects;
    int iDest, iSrc=0;
    int cTemp=0;
    int aryTemp[MAX_INVAL_RECTS]; // touching rects to the right and bottom of rect iDest
    int aryWhichComb[MAX_INVAL_RECTS];  // index matches arc, value is which 
                                        // combined rect the invalid rect belongs
                                        // to. Zero = not set yet.
    int cCombined, marker, index, index2;
    int areaCombined, aryArea[MAX_INVAL_RECTS];
    RECT arcCombined[MAX_INVAL_RECTS];      // accumulates combined rects from arc
    
    
    Assert(pcRects);
    Assert(arc);
    
    // If there are no RECTs to combine, return immediately
    if (*pcRects <= 1)
        return;
    
#if DBG==1
    int areaOrig=0, areaNew=0;
    if ( IsTagEnabled(tagCombineRects) )
    {
        for (iDest=0; iDest < *pcRects; iDest++)
        {
            areaOrig += (arc[iDest].right - arc[iDest].left) * 
                        (arc[iDest].bottom - arc[iDest].top);
        }
    }
#endif // DBG==1
    
    // Combine rects aggressively. Touching rects are combined together,
    // which may make our final regions include areas that wasn't in 
    // the original list of rects. 
    memset( aryWhichComb, 0, sizeof(aryWhichComb) ); 
    memset( aryArea, 0, sizeof(aryArea) );
    cCombined = 0;
    for (iDest=0, cRects = *pcRects; iDest < cRects; iDest++)
    {
        // Combine abutting rects. Iterate through the array of rects 
        // (arranged from top-to-bottom, left-to-right) and enumerate 
        // those that touch to the right and bottom. Since this misses
        // those touching to the right and upwards we keep a list of 
        // which original rect belongs to which rect that is going to be 
        // passed back. As touching rects are accumulated, we check to 
        // see if any of these already belong to a rect that is going to 
        // be passed back. If it is, we add the ones currently being 
        // accumulated to that one.
        cTemp = 0;
        marker = cCombined + 1;
        aryTemp[cTemp++] = iDest;
        if ( aryWhichComb[iDest] > 0 )
            marker = aryWhichComb[iDest];
        
        for ( iSrc=iDest+1; 
        arc[iDest].bottom > arc[iSrc].top && 
            iSrc < cRects; iSrc++ )
        {
            Assert(arc[iDest].right <= arc[iSrc].left);
            if ( arc[iDest].right == arc[iSrc].left )
            {
                // I don't think this ever happens. but just in case it 
                // does this will do the right thing
                Assert( 0 && "Horizontal abutting invalid rects" );
                if ( aryWhichComb[iSrc] > 0 )
                    marker = aryWhichComb[iSrc];
                aryTemp[cTemp++] = iSrc;
            }
        }
        
        // Check rects below for abuttment. 
        for ( ; arc[iDest].bottom == arc[iSrc].top && 
            arc[iDest].right > arc[iSrc].left && 
            iSrc < cRects; iSrc++ )
        {
            if ( arc[iDest].left < arc[iSrc].right )
            {
                if ( aryWhichComb[iSrc] > 0 )
                    marker = aryWhichComb[iSrc];
                aryTemp[cTemp++] = iSrc;
            }
        }
        
        if ( cCombined + 1 == marker )
        {
            // this group of invalid rects doesn't combine with any 
            // existing rect that is going to be returned. Start a one
            arcCombined[cCombined] = arc[iDest];
            cCombined++;
        }
        
        // Add all rects accumulated on this pass to the rect that will be passed back.
        index = marker - 1;
        while ( --cTemp >= 0 )
        {
            index2 = aryTemp[cTemp];
            if ( aryWhichComb[index2] != marker )
            {
                aryWhichComb[index2] = marker;
                arcCombined[index].left    = min( arcCombined[index].left,   arc[index2].left );
                arcCombined[index].top     = min( arcCombined[index].top,    arc[index2].top );
                arcCombined[index].right   = max( arcCombined[index].right,  arc[index2].right );
                arcCombined[index].bottom  = max( arcCombined[index].bottom, arc[index2].bottom );
                aryArea[index] += (arc[index2].right - arc[index2].left) * 
                                  (arc[index2].bottom - arc[index2].top);
            }
        }
    }
    
    // check to make sure each rect meets the fitness criteria
    // don't want to be creating excessively large non-invalid
    // regions to draw
    cRects = cCombined;
    for ( index=0, marker=1; index<cCombined; index++, marker++ )
    {
        areaCombined = (arcCombined[index].right - arcCombined[index].left) *
                       (arcCombined[index].bottom - arcCombined[index].top);
        if ( areaCombined > 1000 && areaCombined > 3*aryArea[index] )
        {
            // scrap combined rect and fall back on just combining
            // areas that will not create any extra space.
#if DBG==1
            TraceTag((tagCombineRects, "EXTRA AREA TOO BIG! Inval area:%d, Extra Area:%d", 
                     aryArea[index], areaCombined-aryArea[index]));
#endif
            int index3=cRects, count=0;
            for ( index2=0; index2<*pcRects; index2++ )
            {
                if ( marker == aryWhichComb[index2] )
                {
                    arcCombined[index3++] = arc[index2];
                    count++;
                }
            }
#if DBG==1
            TraceTag((tagCombineRects, "Sending in %d rects.", count ));
#endif
            CombineRects( &count, &(arcCombined[cRects]));
#if DBG==1
            TraceTag((tagCombineRects, "Got back %d rects.", count ));
#endif
            cRects += count-1;
            memmove( &arcCombined[index], &arcCombined[index+1], 
                     (cRects-index)*sizeof(arcCombined[0]) );
            memmove( &aryArea[index], &aryArea[index+1], 
                     (cRects-index)*sizeof(aryArea[0]) );
            cCombined--;
            index--;
        }
    }
    
    
    // Weed out rects that may now be totally enclosed by the extra 
    // region gain in combining rects.
    for ( iSrc=cRects-1; iSrc>=0; iSrc-- )
    {   
        for ( iDest=0; iDest<cRects; iDest++ )
        {
            if ( arcCombined[iSrc].left   >= arcCombined[iDest].left  &&
                 arcCombined[iSrc].top    >= arcCombined[iDest].top   &&
                 arcCombined[iSrc].right  <= arcCombined[iDest].right &&
                 arcCombined[iSrc].bottom <= arcCombined[iDest].bottom &&
                 iDest != iSrc )
            {
#if DBG==1
                TraceTag((tagCombineRects, "Weeding out rect %d (total rects=%d)", 
                         iSrc, cRects ));
#endif
                memmove( &(arcCombined[iSrc]), &(arcCombined[iSrc+1]), 
                        (cRects-1-iSrc)*sizeof(arcCombined[0]) );
                cRects--;
                break;
            }
        }
    }
    // set output vars
    memmove( arc, arcCombined, cRects*sizeof(arc[0]) );
    *pcRects = cRects;
    

#if DBG==1
        if ( IsTagEnabled(tagCombineRects) )
        {
            // statistics for combining rects
            for (iDest=0; iDest < cRects; iDest++)
            {
                areaNew += (arc[iDest].right - arc[iDest].left) * (arc[iDest].bottom - arc[iDest].top);
            }
            TraceTag((tagCombineRects, "Previous # rects:%d, New # rects:%d", *pcRects, cRects ));
            TraceTag((tagCombineRects, "Excess drawing area: %d pixels, %d %% growth in the region", 
                                        areaNew-areaOrig, (100*(areaNew-areaOrig))/areaOrig));
            if ( areaNew-areaOrig < 0 )
                TraceTag((tagCombineRects, "Didn't draw something we should have??"));
        }
#endif // DBG==1

    return;
}

//+----------------------------------------------------------------------------
//
//  Function:   CombineRects
//
//  Synopsis:   Given an array of non-overlapping rectangles sorted top-to-bottom,
//              left-to-right combine them such that they create no extra area.
//
//  Arguments:  pcRects     - Number of RECTs passed
//              arc         - Array of RECTs
//
//  Returns:    pcRects - Count of combined RECTs
//              arc     - Array of combined RECTs
//
//  NOTE: 1) RECTs must be sorted top-to-bottom, left-to-right and cannot be overlapping
//        2) arc is not reduced in size, the unused entries at the end are ignored
//
//-----------------------------------------------------------------------------
void
CombineRects(int *pcRects, RECT *arc)
{
    int cRects;
    int iDest, iSrc=0;


    Assert(pcRects);
    Assert(arc);

    // If there are no RECTs to combine, return immediately
    if (*pcRects <= 1)
        return;

    // Combine RECTs of similar shape with adjoining boundaries
    for (iDest=0, cRects=*pcRects-1; iDest < cRects; iDest++)
    {
        // First, combine left-to-right those RECTs with the same top and bottom
        // (Since the array is sorted top-to-bottom, left-to-right, adjoining RECTs
        //  with the same top and bottom will be contiguous in the array. As a result,
        //  the loop only needs to continue looking at elements until one is found whose
        //  top or bottom coordinates do not match, or whose left edge is not adjoining.)
        for (iSrc=iDest+1;
            iSrc <= cRects && arc[iDest].top    == arc[iSrc].top    &&
                              arc[iDest].bottom == arc[iSrc].bottom &&
                              arc[iDest].right  >= arc[iSrc].left;
            iSrc++)
        {
            arc[iDest].right = arc[iSrc].right;
        }

        // If RECTs were combined, shift those remaining downward and adjust the total count
        if ((iSrc-1) > iDest)
        {
            cRects -= iSrc - iDest - 1;
            memmove(&arc[iDest+1], &arc[iSrc], cRects*sizeof(arc[0]));
        }

        // Next, combine top-to-bottom those RECTs whose bottoms and tops meet
        // (Again, since the array is sorted top-to-bottom, left-to-right, RECTs which share
        //  the left and right coordinates and touch bottom-to-top may not be next to one
        //  another in the array. The loop must scan until it founds an element whose top
        //  or left edge exceeds that of the destination RECT. It will skip elements whose
        //  tops occur above the bottom of the destination or which occur left of the
        //  destination. It will combine elements, one at a time, which touch bottom-to-top
        //  and have matching left/right coordinates.)
        for (iSrc=iDest+1; iSrc <= cRects; )
        {
            if (arc[iDest].bottom < arc[iSrc].top)
                break;

            else if (arc[iDest].bottom == arc[iSrc].top)
            {
                if (arc[iDest].left < arc[iSrc].left)
                    break;

                else if (arc[iDest].left  == arc[iSrc].left &&
                         arc[iDest].right == arc[iSrc].right)
                {
                    arc[iDest].bottom = arc[iSrc].bottom;
                    memmove(&arc[iSrc], &arc[iSrc+1], (cRects-iSrc)*sizeof(arc[0]));
                    cRects--;
                    continue;
                }
            }

            iSrc++;
        }
    }

    // Adjust the returned number RECTs
    *pcRects = cRects + 1;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   BoundingRectl
//
//  Synopsis:   Returns a rectangle that bounds the two rectangled.  Unlike UnionRectl,
//              this function correctly computes a bounding rectangle when one of the
//              rectangles is just a point (has 0 width and height).
//
//  Arguments:  [prclDst]   - resulting RECTL
//              [prclSrc1]  - input RECTL
//              [prclSrc2]  - input RECTL
//
//  Returns:    TRUE if the result is not an empty RECTL
//              FALSE if the result is an empty RECTL
//----------------------------------------------------------------------------

BOOL BoundingRectl(RECTL *prclDst, const RECTL *prclSrc1, const RECTL *prclSrc2)
{
    prclDst->left = min(prclSrc1->left, prclSrc2->left);
    prclDst->top = min(prclSrc1->top, prclSrc2->top);
    prclDst->right = max(prclSrc1->right, prclSrc2->right);
    prclDst->bottom = max(prclSrc1->bottom, prclSrc2->bottom);
    return prclDst->right - prclDst->left + prclDst->bottom - prclDst->top;
}

//+---------------------------------------------------------------------------
//
//  Function:   NextEventTime
//
//  Synopsis:   Returns a value which can be use to determine when a given
//              number of milliseconds has passed.
//
//  Arguments:  [ulDelta] -- Number of milliseconds after which IsTimePassed
//                           will return TRUE.
//
//  Returns:    A timer value.  Guaranteed not to be zero.
//
//  Notes:      Due to the algorithm used in IsTimePassed, [ulDelta] cannot
//              be greater than ULONG_MAX/2.
//
//----------------------------------------------------------------------------

ULONG
NextEventTime(ULONG ulDelta)
{
    ULONG ulCur;
    ULONG ulRet;

    Assert(ulDelta < ULONG_MAX/2);

    ulCur = GetTickCount();

    if ((ULONG_MAX - ulCur) < ulDelta)
        ulRet = ulDelta - (ULONG_MAX - ulCur);
    else
        ulRet = ulCur + ulDelta;

    if (ulRet == 0)
        ulRet = 1;

    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsTimePassed
//
//  Synopsis:   Returns TRUE if the current time is later than the given time.
//
//  Arguments:  [ulTime] -- Timer value returned from NextEventTime().
//
//  Returns:    TRUE if the current time is later than the given time.
//
//----------------------------------------------------------------------------

BOOL
IsTimePassed(ULONG ulTime)
{
    ULONG ulCur = GetTickCount();

    if ((ulCur > ulTime) && (ulCur - ulTime < ULONG_MAX/2))
        return TRUE;

    return FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CCurs::CCurs
//
//  Synopsis:   Constructor.  Loads the specified cursor and pushes it
//              on top of the cursor stack.  If the cursor id matches a
//              standard Windows cursor, then the cursor is loaded from
//              the system.  Otherwise, the cursor is loaded from this
//              instance.
//
//  Arguments:  idr - The resource id
//
//-------------------------------------------------------------------------
CCurs::CCurs(LPCTSTR idr)
{
    _hcrsOld = SetCursorIDC(idr);
    _hcrs    = GetCursor();
}



//+------------------------------------------------------------------------
//
//  Member:     CCurs::~CCurs
//
//  Synopsis:   Destructor.  Pops the cursor specified in the constructor
//              off the top of the cursor stack.  If the active cursor has
//              changed in the meantime, through some other mechanism, then
//              the old cursor is not restored.
//
//-------------------------------------------------------------------------
CCurs::~CCurs( )
{
    if (GetCursor() == _hcrs)
    {
        ShowCursor(FALSE);
        SetCursor(_hcrsOld);
        ShowCursor(TRUE);
    }
}



//+------------------------------------------------------------------------
//
//  Function:   SetCursorIDC
//
//  Synopsis:   Set the cursor.  If the cursor id matches a standard
//              Windows cursor, then the cursor is loaded from the system.
//              Otherwise, the cursor is loaded from this instance.
//
//  Arguments:  idr - IDC_xxx from Windows.
//
//-------------------------------------------------------------------------

// This is done to avoid messiness of changing WINVER to 0x0500
#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

HCURSOR
SetCursorIDC(LPCTSTR idr, HCURSOR hCurNew/*=NULL*/ )
{
    HCURSOR hcursor, hcurRet;

    if ( ! hCurNew )
    {
        // No support for loading cursor by string id.
        Assert(IS_INTRESOURCE(idr));

        // If IDC_HYPERLINK is specified, lets use the windows
        // hand cursor in NT5 and memphis (44417)
        if(g_dwPlatformVersion >= 0x050000 &&
           idr == MAKEINTRESOURCE(IDC_HYPERLINK))
        {
            idr = IDC_HAND;
        }

        // We assume that if it's greater than IDC_ARROW,
        // then it's a system cursor.

        hcursor = LoadCursorA(
            // UNIXTODO (DWORD)idr should be changed to remove the high order 
            // WORD as for some unix platforms this may not be 0.
            ((DWORD_PTR)idr >= (DWORD_PTR)IDC_ARROW) ? NULL : g_hInstCore,
            (char *)idr);
        // NOTE (lmollico): cursors are in mshtml.dll

        // NOTE: (jbeda) If we were looking for IDC_HAND and didn't get it, 
        // try for IDC_HYPERLINK.  This shouldn't be necessary once memphis
        // implements the hand cursor but I'm leaving it here as a safety
        // precation

#if DBG == 1
        if ( ! hcursor )
        {
            DWORD err = GetLastError();
            TraceTag((tagError,"Error:%d", err));
        }
#endif
        if(!hcursor && idr == IDC_HAND)
        {
            idr = MAKEINTRESOURCE(IDC_HYPERLINK);
            hcursor = LoadCursorA(g_hInstCore, (char *)idr);
            // NOTE (lmollico): cursors are in mshtml.dll
        }

        Assert(hcursor && "Failed to load cursor");
    }
    else
        hcursor = hCurNew;
        
    hcurRet = GetCursor();
    if (   hcursor
        && hcurRet != hcursor
       )
    {
        // NOTE(sujalp): The windows SetCursor() call here has an *ugly* flash
        // in the incorrect position when the cursor's are changing. (Bug29467).
        // (This might be related to windows first showing the new cursor and then
        // setting its hotspot). To avoid this flash, we hide the cursor just
        // before changing the cursor and we enable it after changing the cursor.
        ShowCursor(FALSE);
        hcurRet = SetCursor(hcursor);
        ShowCursor(TRUE);
    }

    return hcurRet;
}


//  NOTE: This routine will be needed when Win95 fixes their bug
//          which prevents us from using LoadLibraryEx(.....,AS_DATAFILE)
//          to load the resource DLL.

#if NEVER
//+---------------------------------------------------------------
//
//  Function:   FormsCreateDialogParam
//
//  Synopsis:   Wraps the Windows API for CreateDialogParam, accounts for
//              the code/resource DLL split.
//
//
//  Arguments:  [hinst] -- instance of the module with the resource
//              [lpstrId] -- the identifier of the RCDATA resource
//              [hWndParent] -- hwnd of the parent window of the dialog box
//              [lpDialogFunc] -- the dialog proc
//              [dwInitParam] -- the initialization param to be passed to WM_DIALOGINIT
//
//  Returns:    the hwnd of the dialog box if successful, NULL otherwise
//
//  Notes:      This is an experimental implementation, it tosses the global
//              handle to the template immediately.
//
//----------------------------------------------------------------

HWND FormsCreateDialogParam(HINSTANCE hInstResource,
                            LPCTSTR  lpstrId,
                            HWND  hWndParent,
                            DLGPROC  lpDialogFunc,
                            LPARAM  dwInitParam)
{
    LPCDLGTEMPLATE  lpTemplate;
    HWND hwnd;

    lpTemplate = (LPCDLGTEMPLATE)GetResource(hInstResource,lpstrId,RT_DIALOG,NULL);
    hwnd = CreateDialogIndirectParam(g_hInstCore, lpTemplate,hWndParent, lpDialogFunc,  dwInitParam);

    return hwnd;
}


//+---------------------------------------------------------------
//
//  Function:   GetChildWindowRect
//
//  Synopsis:   Gets the rectangle of the child window in
//              its parent window coordinates
//
//  Arguments:  hwndChild   The child window
//              prc         The rectangle to fill with child's coordinates
//
//  Notes:      This function gets the screen coordinates of the child
//              then maps them into the client coordinates of its parent.
//
//----------------------------------------------------------------

void
GetChildWindowRect(HWND hwndChild, LPRECT prc)
{
    HWND hwndParent;

    // get the screen coordinates of the child window
    GetWindowRect(hwndChild, prc);

    // get the parent window of the child
    if ((hwndParent = GetParent(hwndChild)) != NULL)
    {
        ScreenToClient(hwndParent, (POINT *)&prc->left);
        ScreenToClient(hwndParent, (POINT *)&prc->right);
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   VBShiftState
//
//  Synopsis:   Helper function, returns shift state for KeyDown/KeyUp events
//
//  Arguments:  (none)
//
//  Returns:    USHORT
//
//  Notes:      This function maps the keystate supplied by Windows to
//              1, 2 and 4 (which are numbers from VB)
//
//----------------------------------------------------------------------------

short
VBShiftState()
{
    short sKeyState = 0;

    if (GetKeyState(VK_SHIFT) & 0x8000)
        sKeyState |= VB_SHIFT;

    if (GetKeyState(VK_CONTROL) & 0x8000)
        sKeyState |= VB_CONTROL;

    if (GetKeyState(VK_MENU) & 0x8000)
        sKeyState |= VB_ALT;

    return sKeyState;
}

short
VBShiftState(DWORD grfKeyState)
{
    short sKeyState = 0;

    if (grfKeyState & MK_SHIFT)
        sKeyState |= VB_SHIFT;

    if (grfKeyState & MK_CONTROL)
        sKeyState |= VB_CONTROL;

    if (grfKeyState & MK_ALT)
        sKeyState |= VB_ALT;

    return sKeyState;
}

//+---------------------------------------------------------------------------
//
//  Function:   VBButtonState
//
//  Synopsis:   Helper function, returns button state for Mouse events
//
//  Arguments:  w -- word containing mouse ButtonState
//
//  Returns:    short
//
//  Notes:      This function maps the buttonstate supplied by Windows to
//              1, 2 and 4 (which are numbers from VB)
//
//----------------------------------------------------------------------------

short
VBButtonState(WPARAM w)
{
    short sButtonState = 0;

    if (w & MK_LBUTTON)
        sButtonState |= VB_LBUTTON;
    if (w & MK_RBUTTON)
        sButtonState |= VB_RBUTTON;
    if (w & MK_MBUTTON)
        sButtonState |= VB_MBUTTON;

    return sButtonState;
}

//+------------------------------------------------------------------------
//
//  Function:   UpdateChildTree
//
//  Synopsis:   Calls UpdateWindow for a window, then recursively calls
//              UpdateWindow its children.
//
//  Arguments:  [hWnd]      Window to update, along with its children
//
//-------------------------------------------------------------------------
void
UpdateChildTree(HWND hWnd)
{
    //
    // The RedrawWindow call seems to miss the hWnd you actually pass in, or
    // else doesn't validate the update region after it has been redrawn, thus
    // the need for the UpdateWindow() call.
    //
    if (hWnd)
    {
        UpdateWindow(hWnd);
        RedrawWindow(hWnd,
                     (GDIRECT *)NULL,
                     NULL,
                     RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INTERNALPAINT
                    );
    }
}


#ifdef NEVER
//+------------------------------------------------------------------------
//
//  Function:  InClientArea
//
//  Synopsis:   Checks if point is within a hWnd's client area.
//
//  Arguments:  [hWnd]      Window handle
//              [pt]        a point
//
//-------------------------------------------------------------------------

BOOL
InClientArea(POINTL pt, HWND hWnd)
{
    RECT rc;
    ::GetClientRect(hWnd, &rc);

    ClientToScreen(hWnd, (POINT *) &rc.left);
    ClientToScreen(hWnd, (POINT *) &rc.right);

    return ::PtInRect(&rc,  (POINT&) pt);

}


//+----------------------------------------------------------------------------
//
//  Function:   IsWindowActive
//
//  Synopsis:   Determines if an HWND is active or not
//
//              The window is considered active when the following conditions
//              are met:
//                  a) The HWND is the active window for the thread or
//                     is a child of the active window
//                     (If another thread owns the active window, then
//                      GetActiveWindow on this thread will return NULL)
//                  b) The HWND has focus or is a child of the window
//                     which has focus
//                     (Again, if window with focus resides on another thread
//                      this GetFocus will return NULL)
//
//              These conditions are the closest analogy to what occurs when a
//              frame window receives either WM_ACTIVATE or WM_MDIACTIVATE
//
//  Arguments:  [hwnd] - Window handle to check
//
//  Returns:    TRUE if active, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
IsWindowActive(
    HWND    hwnd)
{
    HWND    hwndActive = GetActiveWindow();
    HWND    hwndFocus  = GetFocus();

    return (hwndActive &&
            hwndFocus  &&
            (hwndActive == hwnd || IsChild(hwndActive, hwnd)) &&
            (hwndFocus == hwnd  || IsChild(hwnd, hwndFocus)));
}


//+----------------------------------------------------------------------------
//
//  Function:   IsWindowPopup
//
//  Synopsis:   Returns TRUE if the passed HWND is contained within a window
//              that has WS_POPUP set
//
//  Arguments:  [hwnd] - Window handle to check
//
//  Returns:    TRUE if contained in a popup window, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
IsWindowPopup(
    HWND    hwnd)
{
    while (hwnd && !(GetWindowLong(hwnd, GWL_STYLE) & WS_POPUP))
        hwnd = GetParent(hwnd);

    return hwnd != NULL;
}
#endif // NEVER

//+----------------------------------------------------------------------------
//
//  Function:   GetOwningMDIChild
//
//  Synopsis:   Return the HWND of the MDI child which contains the passed
//              HWND
//
//  Arguments:  [hwnd] - Window handle for which to retrieve owning MDI child
//
//  Returns:    HWND of MDI child (if it exists), NULL otherwise
//
//-----------------------------------------------------------------------------
HWND
GetOwningMDIChild(
    HWND    hwnd)
{
    HWND    hwndMDIChild = hwnd;

    while (hwndMDIChild &&
           !(::GetWindowLong(hwndMDIChild, GWL_EXSTYLE) & WS_EX_MDICHILD))
    {
        hwndMDIChild = ::GetParent(hwndMDIChild);
    }

    return hwndMDIChild;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetOwnerOfParent
//
//  Synopsis:   Return the outer most owner/parent HWND of the given window
//              HWND
//
//  Arguments:  [hwnd] - Window handle for which to retrieve its owner
//
//  Returns:    HWND of its outer most owner/parent, itself otherwise
//
//-----------------------------------------------------------------------------
HWND
GetOwnerOfParent(HWND hwnd)
{
    HWND    hwndOwner = hwnd;
    HWND    hwndParent;

    Assert(hwnd);

    // Get outer most parent
    do
    {
        hwndParent = ::GetParent(hwndOwner);
        if (hwndParent)
        {
            hwndOwner = hwndParent;
        }
    } while (hwndParent);

    Assert(hwndOwner);

    // Get its owner
    hwndParent = ::GetWindow(hwndOwner, GW_OWNER);
    if (hwndParent)
    {
        hwndOwner = hwndParent;
    }

    return hwndOwner;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\ia64\thunks.s ===
//----------------------------------------------------------------------------
 //
 // File:     thunks.s
 //
 // Contains: Assembly code for the Alpha. Implements the dynamic vtable stuff
 //           and the tearoff code.
 //
 // NOTE!!: This file (after preprocessing) is what would normally be passed
 //         to ASAXP.EXE, the Alpha assembler.  Unfortunately that causes the
 //         assembler to GPF.  Instead the preprocessed version is hand-edited
 //         to replace all semicolons with newlines, remove all unnecessary
 //         spaces and replace all macros.
 //
 //----------------------------------------------------------------------------


#include "ksia64.h"


//
// These must be kept in sync with TEAROFF_THUNK structure offsets
//

#define offsetof_papfnVtblThis		0x00
#define offsetof_ulRef				0x08
#define offsetof_apIID				0x10		// pointer is 8 byte aligned
#define offsetof_pvObject1			0x18
#define offsetof_apfnVtblObject1	0x20
#define offsetof_pvObject2			0x28
#define offsetof_apfnVtblObject2	0x30
#define offsetof_dwMask				0x38
#define offsetof_n					0x3C
#define offsetof_apVtblPropDesc		0x40

#define ptr_width                   0x8



 //----------------------------------------------------------------------------
 //
 //  Function:  TearOffCompareThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //  In:		Pointer to TEAROFF_THUNK
 //----------------------------------------------------------------------------


#define THUNK_C_1(n)    LEAF_ENTRY(TearoffThunk##n)
#define THUNK_C_2(n)		add		t3 = offsetof_dwMask, a0		        /* pointer to mask */
#define THUNK_C_3(n)        add     t7 = r0, a0                             /* store the tearoff ptr in t7 */
#define THUNK_C_4(n)        add     t8 = offsetof_n, a0                     /* pointer to vtbl index */
#define THUNK_C_5(n)		;;
#define THUNK_C_6(n)		ld4		t4 = [t3]                               /* get mask */
#define THUNK_C_7(n)		add		t5 = offsetof_pvObject2, a0             /* pointer to pvObject2 */
#define THUNK_C_8(n)		add     t6 = offsetof_pvObject1, a0             /* pointer to pvObject1 */
#define THUNK_C_9(n)		;;
#define THUNK_C_10(n)       mov     t9 = n
#define THUNK_C_11(n)		tbit.nz	pt0, pt1 = t4, n                        /* see if we are using pvObject2 */ 
#define THUNK_C_12(n)       ;;
#define THUNK_C_13(n)       st4     [t8] = t9                               /* save the vtbl index */
#define THUNK_C_14(n) (pt0) mov     t3 = t5                                 /* pvObject2 */
#define THUNK_C_15(n) (pt1) mov     t3 = t6                                 /* pvObject1 */
#define THUNK_C_16(n)       ;;
#define THUNK_C_17(n)       ld8     a0 = [t3], ptr_width                    /* this->_pvObject goes to param 1*/
#define THUNK_C_18(n)       ;;       
#define THUNK_C_19(n)       ld8     t3 = [t3]                               /* ptr to apfnVtblObj */
#define THUNK_C_20(n)       ;;
#define THUNK_C_21(n)       shladd     t5 = t9, 3, t3                       /* increment by index * ptr size */
#define THUNK_C_22(n)       ;;
#define THUNK_C_23(n)       ld8     t4 = [t5]                               /* Get function pointer */
#define THUNK_C_24(n)       ;;
#define THUNK_C_25(n)       ld8     t5 = [t4], ptr_width                    /* Get pointer to code */ 
#define THUNK_C_26(n)       ;;
#define THUNK_C_27(n)       ld8     gp = [t4]                               /* Get GP pointer */    
#define THUNK_C_28(n)       mov     bt0 = t5
#define THUNK_C_29(n)       br.cond.sptk    bt0                             /* jump to the function */
#define THUNK_C_30(n)   LEAF_EXIT(TearoffThunk##n)


 //----------------------------------------------------------------------------
 //
 //  Function:  GetTearoff
 //
 //  Synopsis:  This function returns the tearoff thunk pointer stored in
 //             the temp register t7. This should be called first thing from
 //             the C++ functions that handles calls to torn-off interfaces
 //
 //----------------------------------------------------------------------------

#define THUNK_GT_1		LEAF_ENTRY(_GetTearoff)
#define THUNK_GT_2			add		v0 = r0, t7       /* place tearoff ptr in return reg */
#define THUNK_GT_3			br.ret.sptk b0
#define THUNK_GT_4		LEAF_EXIT(_GetTearoff)
#define THUNK_GT_5
#define THUNK_GT_6
#define THUNK_GT_7
#define THUNK_GT_8
#define THUNK_GT_9


//
//      Define the thunks from 3 to 15 (these are compare thunks)
//

#include "..\thunks_c.h"

 //----------------------------------------------------------------------------
 //
 //  Function:  CallTearOffSimpleThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------



#define THUNK_S_1(n)    LEAF_ENTRY(TearoffThunk##n)
#define THUNK_S_2(n)        mov     t9 = n                                  /* We need n in a register */       
#define THUNK_S_3(n)        add     t4 = offsetof_apfnVtblObject1, a0       /* this->apfnVtblObject */
#define THUNK_S_4(n)        add     t3 = offsetof_pvObject1, a0             /* this->pObject */ 
#define THUNK_S_5(n)        ;;
#define THUNK_S_6(n)        ld8     t3 = [t3]                               /* Get pObject */
#define THUNK_S_7(n)        ld8     t4 = [t4]                               /* apfnVtblObject */
#define THUNK_S_8(n)        add     t5 = offsetof_n, a0                     /* this->n */
#define THUNK_S_9(n)        ;;
#define THUNK_S_10(n)       shladd  t4 = t9, 3, t4                          /* get function ptr address */
#define THUNK_S_11(n)       mov     t7 = a0                                 /* Save tearoff in t7 */
#define THUNK_S_12(n)       st4     [t5] = t9                               /* Save the index */
#define THUNK_S_13(n)       ;;
#define THUNK_S_14(n)       mov     a0 = t3                                 /* pObject goes to param 1 */
#define THUNK_S_15(n)       ld8     t4 = [t4] ;;                            /* Get function pointer. */
#define THUNK_S_16(n)       ld8     t5 = [t4], ptr_width ;;                 /* get code pointer */
#define THUNK_S_17(n)       ld8     gp = [t4]                               /* get GP pointer */
#define THUNK_S_18(n)       mov     bt0 = t5
#define THUNK_S_19(n)      br.cond.sptk    bt0                              /* jump to the function */
#define THUNK_S_20(n)    LEAF_EXIT(TearoffThunk##n)


//
//      Define the thunks from 16 onwards (these are simple thunks)
//

#include "..\thunks_s.h"

// .set macro
// .set reorder
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\unix\sparc\thunks.s ===
/*
 //----------------------------------------------------------------------------
 //
 // File:     thunks.S
 //
 // Contains: Assembly code for the Sparc. Implements the dynamic vtable stuff
 //           and the tearoff code.
 //
 //----------------------------------------------------------------------------
*/

/* //#include <tearoff.hxx> */
#include "thunks_c.h"

#define this        %i0

#define vtbl        %l0
#define offset      %l1
#define pfn         %l2
#define index       %l3
#define dwMask      %l4
#define dwN	    %l5

/*
 //
 // Here's the layout of the 'this' object in $i0
 //
 // offset  value
 //
 //     0   don't care
 //     4   don't care
 //     8   don't care
 //     12  pvObject1's this
 //     16  pvObject1's function table
 //     20  pvObject2's this
 //     24  pvObject2's function table
 //     28  mask to decide whether to use Object 1 or 2
 //     32  index of method into vtbl
 //  Note:   Look in unixtearoff.cxx for latest structure definition
 //
*/

#define off_pvObject1           12
#define off_pvObjectVtbl1       16
#define off_pvObject2           20
#define off_dwMask              28
#define off_dwN			32

#define objvtblDelta           (off_pvObjectVtbl1 - off_pvObject1)
    
/*
 //----------------------------------------------------------------------------
 // Function:  _GetTearoff
 // 
 // Synopsis:  return the value left in global register (the pthunk pointer)
 //
 // Notes:     This pthunk pointer is left by THUNK_IMPLEMENT_COMARE 
 //            or THUNK_IMPLEMENT_SIMPLE
 //
 //----------------------------------------------------------------------------
*/
    .global _GetTearoff 
    .type   _GetTearoff,2

_GetTearoff:
    retl             
    mov %g2, %o0
 
/*
 //----------------------------------------------------------------------------
 //
 //  Function:  CompleteThunk
 //
 //  Synopsis:  Finishes up the complex and simple thunk handlers
 //
 //  Notes:     Modifies the this pointer and jumps to the corresponding virtual
 //             or non-virtual method.
 //
 //----------------------------------------------------------------------------
*/

#define COMPLETE_THUNK(n)                                                                       \
                                                                                                \
    .global cat(CompleteThunk,n);                                                               \
                                                                                                \
cat(CompleteThunk,n):                                                                           \
    ldsh    [vtbl + 8*(n+1)], offset;                   /* offset = vtbl[n].offset */           \
    lduw    [vtbl + 8*(n+1) + 4], pfn;                  /* pfn = vtbl[n].pfn */                 \
    ldsh    [vtbl + 8*(n+1) + 2], index;                /* index = vtbl[n].realVtblIndex */     \
                                                                                                \
    cmp     index,0;                                    /* if ( index == 0 ) */                 \
    beq       cat(NonVirtual,n);                        /*   goto NonVirtual; */                \
    nop;                                                                                        \
                                                                                                \
/* Virtual */                                                                                   \
    add     this,pfn,this;                              /* this += (vtbl_offset)pfn */          \
    lduw    [this],vtbl;                                /* vtbl = *this */                      \
    sub     this,pfn,this;                              /* this -= (vtbl_offset)pfn */          \
                                                                                                \
    sll     index,3,index;                              /* index *= sizeof(VTBLENTRY) */        \
    add     index,vtbl,vtbl;                            /* vtbl += index */                     \
                                                                                                \
    add     offset,this,this;                           /* this += offset */                    \
    lduw    [vtbl + 4], pfn;                            /* pfn = vtbl->pfn */                   \
    ldsh    [vtbl], offset;                             /* offset = vtbl->offset */             \
                                                                                                \
cat(NonVirtual,n):                                                                              \
    add     offset,this,this;                           /* this += offset; */                   \
    jmp     pfn;                                        /* func(); */                           \
    restore;


/*
 //----------------------------------------------------------------------------
 //
 //  Function:  TearOffCompareThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------
*/


#define THUNK_IMPLEMENT_COMPARE(n)                                                                                      \
                                                                                                                        \
    /* No frame */                                                                                                      \
    /* No prologue */                                                                                                   \
                                                                                                                        \
    .global cat(TearoffThunk,n);                                                                                        \
    .type   cat(TearoffThunk,n),2;                                                                                      \
                                                                                                                        \
cat(TearoffThunk,n):                                                                                                    \
    save    %sp,-64,%sp;                                                                                                \
    mov     this, %g2;                                  /* save this -> %g2      */                                     \
    mov     n,  dwN;                                                                                                    \
    stw     dwN, [this+off_dwN];                                                                                        \
    lduw    [this+off_dwMask], dwMask;                  /* dwMask = this->dwMask */                                     \
    srl     dwMask, n, dwMask;                          /* dwMask >>= n; */                                             \
    btst    1, dwMask;                                  /* if (! (dwMask & 1 )) */                                      \
    be        cat(Object1_,n);                          /*   goto Object1_n; */                                         \
    nop;                                                                                                                \
                                                                                                                        \
    add     off_pvObject2-off_pvObject1, this, this;    /* this += &pvObject2 - &pvObject1; */                          \
                                                        /* This boosts the following 2 instructions from pvObject1 */   \
                                                        /* and apfnVtblObject1 to the corresponding 2nd values */       \
cat(Object1_,n):                                                                                                        \
    lduw    [this + off_pvObject1 + objvtblDelta], vtbl;/* vtbl = *(this + offset(TEAROFF_THUNK, apfnVtblObject1) */    \
    lduw    [this + off_pvObject1], this;               /* this += offset(TEAROFF_THUNK, pvObject1 ) */                 \
                                                                                                                        \
    COMPLETE_THUNK(n)

/*
 //----------------------------------------------------------------------------
 //
 //  Function:  CallTearOffSimpleThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------
*/

#define THUNK_IMPLEMENT_SIMPLE(n)                                                               \
                                                                                                \
    /* No frame */                                                                              \
    /* No prologue */                                                                           \
                                                                                                \
    .global cat(TearoffThunk,n);                                                                \
    .type   cat(TearoffThunk,n),2;                                                              \
                                                                                                \
cat(TearoffThunk,n):                                                                            \
    save    %sp,-64,%sp;                                                                        \
    mov     this, %g2;                                                                          \
    mov     n, dwN;                                                                             \
    stw     dwN, [this + off_dwN];                                                              \
    lduw    [this + off_pvObject1 + objvtblDelta], vtbl;/* vtbl = this->apfnVtblObject1 */      \
    lduw    [this + off_pvObject1], this;               /* this = this->pvObject1 */            \
                                                                                                \
    COMPLETE_THUNK(n)


/*
//
//      Define IUnknown thunks (0 - 2) only used by unixtearoff.cxx (simple)
//      Define the thunks from 3 to 15 (compare thunks)
//      Define the thunks from 16 onwards (simple thunks)
//
*/

THUNK_IMPLEMENT_SIMPLE(0)
THUNK_IMPLEMENT_SIMPLE(1)
THUNK_IMPLEMENT_SIMPLE(2)

THUNK_ARRAY_3_TO_15(IMPLEMENT_COMPARE)

THUNK_ARRAY_16_AND_UP(IMPLEMENT_SIMPLE)


/*
 //----------------------------------------------------------------------------
 //
 //  Function:  CMethodThunk::doThunk implementations
 //
 //  Synopsis:  The thunk that calls class method pointers correctly.
 //
 //  Notes:  The CMethodThunk struct has at offsets:
 //
 //                 0 : this
 //                 4 : vtbl method pointer
 //
 //          Also, we call CompleteThunk0 to complete our call.  However,
 //          it always skips 8 bytes to get to the first vtable method so
 //          we substract 8 from the vtbl method poner before calling in.
 //
 //----------------------------------------------------------------------------
*/

    .global doThunk
    .type   doThunk,2
               
    .global __0fMCMethodThunkHdoThunkPve
    .type   __0fMCMethodThunkHdoThunkPve,2

    .global __0fMCMethodThunkHdoThunkie
    .type   __0fMCMethodThunkHdoThunkie,2

    .global __0fMCMethodThunkHdoThunkv
    .type   __0fMCMethodThunkHdoThunkv,2

    .global __0fMCMethodThunkHdoThunk6F_GUIDe
    .type   __0fMCMethodThunkHdoThunk6F_GUIDe,2

    .global __0fMCMethodThunkHdoThunkR6QTextContextEvent
    .type   __0fMCMethodThunkHdoThunkR6QTextContextEvent,2

doThunk:
__0fMCMethodThunkHdoThunkR6QTextContextEvent:
__0fMCMethodThunkHdoThunkie:
__0fMCMethodThunkHdoThunkv:
__0fMCMethodThunkHdoThunk6F_GUIDe:
__0fMCMethodThunkHdoThunkPve:
    save    %sp,-64,%sp
    lduw    [this +4], vtbl    /* vtbl = this->pfnMethod */
    lduw    [this], this       /* this = this->pObject */

    ba      CompleteThunk0
    dec     8, vtbl            /* vtbl = vtbl - sizeof(VTABLE_ENTRY) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdutil\unix\sparc\thunks_c.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       tearoff.hxx
//
//  Contents:   Tearoff Interface Utilities
//
//----------------------------------------------------------------------------


#ifndef _TEAROFF_HXX_
#define _TEAROFF_HXX_

#ifdef __STDC__
#define cat(a,b)        a##b
#else
#define cat(a,b)        a/**/b
#endif

#if defined(UNIX) && defined(_HPUX_SOURCE)
#define THUNK_ARRAY_3_TO_15(x) \
 THUNK_##x(3)   THUNK_##x(4)   THUNK_##x(5)   THUNK_##x(6)   THUNK_##x(7)   THUNK_##x(8)   THUNK_##x(9)   THUNK_##x(10)  THUNK_##x(11)  THUNK_##x(12)  THUNK_##x(13)  \
 THUNK_##x(14)  THUNK_##x(15)
    
#define THUNK_ARRAY_16_AND_UP(x) \
THUNK_##x(16)  THUNK_##x(17)  THUNK_##x(18)  THUNK_##x(19)  THUNK_##x(20)  THUNK_##x(21)  THUNK_##x(22)  THUNK_##x(23)  THUNK_##x(24)  \
THUNK_##x(25)  THUNK_##x(26)  THUNK_##x(27)  THUNK_##x(28)  THUNK_##x(29)  THUNK_##x(30)  THUNK_##x(31)  THUNK_##x(32)  THUNK_##x(33)  THUNK_##x(34)  THUNK_##x(35)  \
THUNK_##x(36)  THUNK_##x(37)  THUNK_##x(38)  THUNK_##x(39)  THUNK_##x(40)  THUNK_##x(41)  THUNK_##x(42)  THUNK_##x(43)  THUNK_##x(44)  THUNK_##x(45)  THUNK_##x(46)  \
THUNK_##x(47)  THUNK_##x(48)  THUNK_##x(49)  THUNK_##x(50)  THUNK_##x(51)  THUNK_##x(52)  THUNK_##x(53)  THUNK_##x(54)  THUNK_##x(55)  THUNK_##x(56)  THUNK_##x(57)  \
THUNK_##x(58)  THUNK_##x(59)  THUNK_##x(60)  THUNK_##x(61)  THUNK_##x(62)  THUNK_##x(63)  THUNK_##x(64)  THUNK_##x(65)  THUNK_##x(66)  THUNK_##x(67)  THUNK_##x(68)  \
THUNK_##x(69)  THUNK_##x(70)  THUNK_##x(71)  THUNK_##x(72)  THUNK_##x(73)  THUNK_##x(74)  THUNK_##x(75)  THUNK_##x(76)  THUNK_##x(77)  THUNK_##x(78)  THUNK_##x(79)  \
THUNK_##x(80)  THUNK_##x(81)  THUNK_##x(82)  THUNK_##x(83)  THUNK_##x(84)  THUNK_##x(85)  THUNK_##x(86)  THUNK_##x(87)  THUNK_##x(88)  THUNK_##x(89)  THUNK_##x(90)  \
THUNK_##x(91)  THUNK_##x(92)  THUNK_##x(93)  THUNK_##x(94)  THUNK_##x(95)  THUNK_##x(96)  THUNK_##x(97)  THUNK_##x(98)  THUNK_##x(99)  THUNK_##x(100) THUNK_##x(101) \
THUNK_##x(102) THUNK_##x(103) THUNK_##x(104) THUNK_##x(105) THUNK_##x(106) THUNK_##x(107) THUNK_##x(108) THUNK_##x(109) THUNK_##x(110) THUNK_##x(111) THUNK_##x(112) \
THUNK_##x(113) THUNK_##x(114) THUNK_##x(115) THUNK_##x(116) THUNK_##x(117) THUNK_##x(118) THUNK_##x(119) THUNK_##x(120) THUNK_##x(121) THUNK_##x(122) THUNK_##x(123) \
THUNK_##x(124) THUNK_##x(125) THUNK_##x(126) THUNK_##x(127) THUNK_##x(128) THUNK_##x(129) THUNK_##x(130) THUNK_##x(131) THUNK_##x(132) THUNK_##x(133) THUNK_##x(134) \
THUNK_##x(135) THUNK_##x(136) THUNK_##x(137) THUNK_##x(138) THUNK_##x(139) THUNK_##x(140) THUNK_##x(141) THUNK_##x(142) THUNK_##x(143) THUNK_##x(144) THUNK_##x(145) \
THUNK_##x(146) THUNK_##x(147) THUNK_##x(148) THUNK_##x(149) THUNK_##x(150) THUNK_##x(151) THUNK_##x(152) THUNK_##x(153) THUNK_##x(154) THUNK_##x(155) THUNK_##x(156) \
THUNK_##x(157) THUNK_##x(158) THUNK_##x(159) THUNK_##x(160) THUNK_##x(161) THUNK_##x(162) THUNK_##x(163) THUNK_##x(164) THUNK_##x(165) THUNK_##x(166) THUNK_##x(167) \
THUNK_##x(168) THUNK_##x(169) THUNK_##x(170) THUNK_##x(171) THUNK_##x(172) THUNK_##x(173) THUNK_##x(174) THUNK_##x(175) THUNK_##x(176) THUNK_##x(177) THUNK_##x(178) \
THUNK_##x(179) THUNK_##x(180) THUNK_##x(181) THUNK_##x(182) THUNK_##x(183) THUNK_##x(184) THUNK_##x(185) THUNK_##x(186) THUNK_##x(187) THUNK_##x(188) THUNK_##x(189) \
THUNK_##x(190) THUNK_##x(191) THUNK_##x(192) THUNK_##x(193) THUNK_##x(194) THUNK_##x(195) THUNK_##x(196) THUNK_##x(197) THUNK_##x(198) THUNK_##x(199)        
#else
#define THUNK_ARRAY_3_TO_15(x) \
 cat(THUNK_,x)(3)   cat(THUNK_,x)(4)   cat(THUNK_,x)(5)   cat(THUNK_,x)(6)   cat(THUNK_,x)(7)   cat(THUNK_,x)(8)   cat(THUNK_,x)(9)   cat(THUNK_,x)(10)  cat(THUNK_,x)(11)  cat(THUNK_,x)(12)  cat(THUNK_,x)(13)  \
 cat(THUNK_,x)(14)  cat(THUNK_,x)(15)
    
#define THUNK_ARRAY_16_AND_UP(x) \
cat(THUNK_,x)(16)  cat(THUNK_,x)(17)  cat(THUNK_,x)(18)  cat(THUNK_,x)(19)  cat(THUNK_,x)(20)  cat(THUNK_,x)(21)  cat(THUNK_,x)(22)  cat(THUNK_,x)(23)  cat(THUNK_,x)(24)  \
cat(THUNK_,x)(25)  cat(THUNK_,x)(26)  cat(THUNK_,x)(27)  cat(THUNK_,x)(28)  cat(THUNK_,x)(29)  cat(THUNK_,x)(30)  cat(THUNK_,x)(31)  cat(THUNK_,x)(32)  cat(THUNK_,x)(33)  cat(THUNK_,x)(34)  cat(THUNK_,x)(35)  \
cat(THUNK_,x)(36)  cat(THUNK_,x)(37)  cat(THUNK_,x)(38)  cat(THUNK_,x)(39)  cat(THUNK_,x)(40)  cat(THUNK_,x)(41)  cat(THUNK_,x)(42)  cat(THUNK_,x)(43)  cat(THUNK_,x)(44)  cat(THUNK_,x)(45)  cat(THUNK_,x)(46)  \
cat(THUNK_,x)(47)  cat(THUNK_,x)(48)  cat(THUNK_,x)(49)  cat(THUNK_,x)(50)  cat(THUNK_,x)(51)  cat(THUNK_,x)(52)  cat(THUNK_,x)(53)  cat(THUNK_,x)(54)  cat(THUNK_,x)(55)  cat(THUNK_,x)(56)  cat(THUNK_,x)(57)  \
cat(THUNK_,x)(58)  cat(THUNK_,x)(59)  cat(THUNK_,x)(60)  cat(THUNK_,x)(61)  cat(THUNK_,x)(62)  cat(THUNK_,x)(63)  cat(THUNK_,x)(64)  cat(THUNK_,x)(65)  cat(THUNK_,x)(66)  cat(THUNK_,x)(67)  cat(THUNK_,x)(68)  \
cat(THUNK_,x)(69)  cat(THUNK_,x)(70)  cat(THUNK_,x)(71)  cat(THUNK_,x)(72)  cat(THUNK_,x)(73)  cat(THUNK_,x)(74)  cat(THUNK_,x)(75)  cat(THUNK_,x)(76)  cat(THUNK_,x)(77)  cat(THUNK_,x)(78)  cat(THUNK_,x)(79)  \
cat(THUNK_,x)(80)  cat(THUNK_,x)(81)  cat(THUNK_,x)(82)  cat(THUNK_,x)(83)  cat(THUNK_,x)(84)  cat(THUNK_,x)(85)  cat(THUNK_,x)(86)  cat(THUNK_,x)(87)  cat(THUNK_,x)(88)  cat(THUNK_,x)(89)  cat(THUNK_,x)(90)  \
cat(THUNK_,x)(91)  cat(THUNK_,x)(92)  cat(THUNK_,x)(93)  cat(THUNK_,x)(94)  cat(THUNK_,x)(95)  cat(THUNK_,x)(96)  cat(THUNK_,x)(97)  cat(THUNK_,x)(98)  cat(THUNK_,x)(99)  cat(THUNK_,x)(100) cat(THUNK_,x)(101) \
cat(THUNK_,x)(102) cat(THUNK_,x)(103) cat(THUNK_,x)(104) cat(THUNK_,x)(105) cat(THUNK_,x)(106) cat(THUNK_,x)(107) cat(THUNK_,x)(108) cat(THUNK_,x)(109) cat(THUNK_,x)(110) cat(THUNK_,x)(111) cat(THUNK_,x)(112) \
cat(THUNK_,x)(113) cat(THUNK_,x)(114) cat(THUNK_,x)(115) cat(THUNK_,x)(116) cat(THUNK_,x)(117) cat(THUNK_,x)(118) cat(THUNK_,x)(119) cat(THUNK_,x)(120) cat(THUNK_,x)(121) cat(THUNK_,x)(122) cat(THUNK_,x)(123) \
cat(THUNK_,x)(124) cat(THUNK_,x)(125) cat(THUNK_,x)(126) cat(THUNK_,x)(127) cat(THUNK_,x)(128) cat(THUNK_,x)(129) cat(THUNK_,x)(130) cat(THUNK_,x)(131) cat(THUNK_,x)(132) cat(THUNK_,x)(133) cat(THUNK_,x)(134) \
cat(THUNK_,x)(135) cat(THUNK_,x)(136) cat(THUNK_,x)(137) cat(THUNK_,x)(138) cat(THUNK_,x)(139) cat(THUNK_,x)(140) cat(THUNK_,x)(141) cat(THUNK_,x)(142) cat(THUNK_,x)(143) cat(THUNK_,x)(144) cat(THUNK_,x)(145) \
cat(THUNK_,x)(146) cat(THUNK_,x)(147) cat(THUNK_,x)(148) cat(THUNK_,x)(149) cat(THUNK_,x)(150) cat(THUNK_,x)(151) cat(THUNK_,x)(152) cat(THUNK_,x)(153) cat(THUNK_,x)(154) cat(THUNK_,x)(155) cat(THUNK_,x)(156) \
cat(THUNK_,x)(157) cat(THUNK_,x)(158) cat(THUNK_,x)(159) cat(THUNK_,x)(160) cat(THUNK_,x)(161) cat(THUNK_,x)(162) cat(THUNK_,x)(163) cat(THUNK_,x)(164) cat(THUNK_,x)(165) cat(THUNK_,x)(166) cat(THUNK_,x)(167) \
cat(THUNK_,x)(168) cat(THUNK_,x)(169) cat(THUNK_,x)(170) cat(THUNK_,x)(171) cat(THUNK_,x)(172) cat(THUNK_,x)(173) cat(THUNK_,x)(174) cat(THUNK_,x)(175) cat(THUNK_,x)(176) cat(THUNK_,x)(177) cat(THUNK_,x)(178) \
cat(THUNK_,x)(179) cat(THUNK_,x)(180) cat(THUNK_,x)(181) cat(THUNK_,x)(182) cat(THUNK_,x)(183) cat(THUNK_,x)(184) cat(THUNK_,x)(185) cat(THUNK_,x)(186) cat(THUNK_,x)(187) cat(THUNK_,x)(188) cat(THUNK_,x)(189) \
cat(THUNK_,x)(190) cat(THUNK_,x)(191) cat(THUNK_,x)(192) cat(THUNK_,x)(193) cat(THUNK_,x)(194) cat(THUNK_,x)(195) cat(THUNK_,x)(196) cat(THUNK_,x)(197) cat(THUNK_,x)(198) cat(THUNK_,x)(199)        

#endif // UNIX
#endif //_TEAROFF_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       assert.cxx
//
//  Contents:   Assertion stuff
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

static LONG g_cAssertThreadDisable = 0;
void SpitSzToDisk(CHAR * sz);


#ifndef _MAC

extern HMODULE g_hModule;

int  DoAssertDialog(MBOT *pmbot);

//+---------------------------------------------------------------------------
//
//  Function:   InitMBOT
//
//  Synopsis:   Initializes some data in the MBOT struct, like module name
//              stacktrace, etc.
//
//  Arguments:  [pmbot]      -- Pointer to struct to initialize
//
//----------------------------------------------------------------------------

void
InitMBOT(MBOT *pmbot)
{
    char   achModuleName[MAX_PATH];
    char * pszModuleName;
    DWORD  dwEip[50];

    memset(pmbot, 0, sizeof(pmbot));

    pmbot->tid = GetCurrentThreadId();
    pmbot->pid = GetCurrentProcessId();

#ifndef _MAC
    if (GetModuleFileNameA(g_hModule, achModuleName, MAX_PATH))
#else
    char  achAppLoc[MAX_PATH];

    if (GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc))
        && !GetFileTitleA(achAppLoc,achModuleName,ARRAY_SIZE(achModuleName)) )
#endif
    {
        pszModuleName = strrchr(achModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = achModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    strcpy(pmbot->achModule, pszModuleName);

    if (!g_cAssertThreadDisable && DbgExIsTagEnabled(tagAssertStacks))
    {
        pmbot->cSym = GetStackBacktrace(3, 50, dwEip, pmbot->asiSym);
    }
    else
    {
        pmbot->cSym = 0;
    }

    GetTopURLForThread(pmbot->tid, pmbot->achTopUrl);

    pmbot->id = IDCANCEL;

    pmbot->szTitle = "Trident/MSHTML Assert";
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromMBOT
//
//  Synopsis:   Fills a string with a textual representation of information
//              in an MBOT struct
//
//  Arguments:  [pmbot]      --  MBOT to represent
//              [pch]        --  Buffer to put text into.
//              [fShortSyms] --  If TRUE, only SHORT_SYM_COUNT symbols are
//                               used.
//
//----------------------------------------------------------------------------

void
StringFromMBOT(MBOT *pmbot, char * pch, BOOL fShortSyms)
{
    int i;
    int cSyms = pmbot->cSym;

    if (fShortSyms && (cSyms > SHORT_SYM_COUNT))
    {
        cSyms = SHORT_SYM_COUNT;
    }

    wsprintfA(pch, "Assert Failed: Process: %s PID:%x TID:%x\r\nFile: %s (%d)\r\nTop Url: %s\r\n%s",
            pmbot->achModule,
            pmbot->pid,
            pmbot->tid,
            pmbot->szFile,
            pmbot->dwLine,
            pmbot->achTopUrl,
            pmbot->szMessage);

    if (cSyms)
    {
        char achSymbol[200];

        strcat(pch, "\r\n\r\nStacktrace:\r\n");

        for (i = 0; i < cSyms; i++)
        {
            wsprintfA(achSymbol, "   %-11s %s\r\n",
                      pmbot->asiSym[i].achModule,
                      pmbot->asiSym[i].achSymbol);
            strcat(pch, achSymbol);
        }
    }
}

//+------------------------------------------------------------
//
// Function:    MessageBoxOnThreadFn
//
// Synopsis:    ThreadMain function for MessageBoxOnThread.
//
//-------------------------------------------------------------

DWORD WINAPI
MessageBoxOnThreadFn(MBOT *pmbot)
{
#if 0
    char ach[MAX_PATH * 3];

    StringFromMBOT(pmbot, ach, TRUE);

    pmbot->id = MessageBoxA(NULL,
                            ach,
                            pmbot->szTitle,
                            pmbot->dwFlags);
#endif

    pmbot->id = DoAssertDialog(pmbot);

    if (pmbot->id == 0)
        pmbot->dwErr = GetLastError();

    return(0);
}

//+------------------------------------------------------------
//
// Function:    MessageBoxOnThread
//
// Synopsis:
//
//-------------------------------------------------------------

int MessageBoxOnThread(MBOT *pmbot)
{
    THREAD_HANDLE  hThread;
    DWORD   dwThread;

    if (g_cAssertThreadDisable)
    {
        // Flush all user input to prevent auto-closing of this message box
        MSG msg;
        for (int n = 0; n < 100; ++n)
            PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

        MessageBoxOnThreadFn(pmbot);
    }
    else
    {
        hThread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)MessageBoxOnThreadFn,
                pmbot,
                0,
                &dwThread);
        if (!hThread)
        {
            // Flush all user input to prevent auto-closing of this message box
            MSG msg;
            for (int n = 0; n < 100; ++n)
                PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

            MessageBoxOnThreadFn(pmbot);
        }
        else
        {
            WaitForSingleObject(hThread, INFINITE);
            CloseThread(hThread);
        }
    }

    if (pmbot->id == 0)
        SetLastError(pmbot->dwErr);

    return(pmbot->id);
}

#endif // !MAC

//
// Bookmark array that can set and retrieve a mark on a (filename, line) pair
// Removing a bookmark is not implemented here
//
#pragma auto_inline(off)
#pragma inline_depth(0)

template <int _cMax>
class CDbgBookmarkArray
{
protected:
    int _cUsed;         // used entries
    int _rgcrc[_cMax];  // the array

    //+------------------------------------------------------------
    //
    // Function:    CrcAddInt
    //
    // Synopsis:    Add an integer to CRC
    //
    //-------------------------------------------------------------
    int CrcAddInt(unsigned int crc, unsigned int i)
    {
        return (crc ^ i) * 16807 % 0x7fffffff;
    }

    //+------------------------------------------------------------
    //
    // Function:    CrcFromSz
    //
    // Synopsis:    Compute CRC for a string.
    //
    //-------------------------------------------------------------
    int CrcFromSz(const char *rgb)
    {
        int crc = 0;
        while (*rgb)
            crc = CrcAddInt(crc, *rgb++);

        return crc;
    }

    //+------------------------------------------------------------
    //
    // Function:    CrcFromFileLine
    //
    // Synopsis:    Compute CRC for (filename, line).
    //
    //-------------------------------------------------------------
    int CrcFromFileLine(const char *szFile, int iLine)
    {
        return CrcAddInt(CrcFromSz(szFile), iLine);
    }

public:
    //+------------------------------------------------------------
    //
    // Function:    IsMarked
    //
    // Synopsis:    returns TRUE if there is a bookmark at (file, line).
    //
    //-------------------------------------------------------------
    BOOL IsMarked(const char *szFile, int iLine)
    {
        int crc = CrcFromFileLine(szFile, iLine);
        for (int i = 0; i < _cUsed; i++)
            {
            if (_rgcrc[i] == crc)
                return TRUE;
            }
        return FALSE;
    }

    //+------------------------------------------------------------
    //
    // Function:    Mark
    //
    // Synopsis:    Set bookmark at (file, line)
    //
    //-------------------------------------------------------------
    BOOL Mark(const char *szFile, int iLine)
    {
        if (_cUsed >= _cMax || IsMarked(szFile, iLine))
            return TRUE;

        _rgcrc[_cUsed++] = CrcFromFileLine(szFile, iLine);

        return FALSE;
    }
};

//
// Array of disabled asserts.
// No, you can't disable more than 1000 asserts.
//
CDbgBookmarkArray<1000> rgbmkDisabledAsserts;
BOOL _fDisableAllAsserts = FALSE;


//+------------------------------------------------------------
//
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      pmbot --  Structure containing assert information
//
// Returns:
//      IDCANCEL --     User selected the BREAK  button
//      IDOK     --     User selected the IGNORE button
//
//-------------------------------------------------------------

int
PopUpError(MBOT *pmbot)
{
    int  id  = IDOK;

#if defined(UNIX)
    printf( "[ Assert failed. Calling DebugBreak ]" );
    DebugBreak();
#else
    id = MessageBoxOnThread(pmbot);
#endif

    if (id == IDOK && (GetAsyncKeyState(VK_CONTROL) & 0x8000))
        {
        if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
            {
            // ctrl+shift+Ignore - disable all asserts
            _fDisableAllAsserts = TRUE;
            }
        else
            {
            // ctrl+Ignore - disable this one assert
            rgbmkDisabledAsserts.Mark(pmbot->szFile, pmbot->dwLine);
            }
        }

    return id;
#if 0
    pmbot->dwFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                     MB_ICONEXCLAMATION | MB_OKCANCEL;

// MACTODO Mac MessageBox function fails with the following message:
//  Scratch DC already in use (wlmdc-1319)
#ifndef _MAC
    id = MessageBoxOnThread(pmbot);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (!id && GetLastError() == ERROR_ACCESS_DENIED)
    {
        //
        // Retry this one with the SERVICE_NOTIFICATION flag on.  That
        // should get us to the right desktop.
        //
        pmbot->dwFlags = MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                         MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL;

        id = MessageBoxOnThread(pmbot);
    }
#endif
    return id;

#endif
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExAssertImpl
//
//  Synopsis:   Function called for all asserts.  Checks value, tracing
//              and/or popping up a message box if the condition is
//              FALSE.
//
//  Arguments:
//              szFile
//              iLine
//              szMessage
//
//-------------------------------------------------------------------------

BOOL WINAPI
DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage)
{
    MBOT  mbot;
    char  ach[2048];
    DWORD cbWrite;

    EnsureThreadState();

    InitMBOT(&mbot);

    mbot.szFile    = szFile;
    mbot.dwLine    = iLine;
    mbot.szMessage = szMessage;

    StringFromMBOT(&mbot, ach, TRUE);

    //  Send the assert text to the debug terminal.

    TraceTag((tagError, "%s", ach));
    SpitSzToDisk(ach);

    //
    // Write to STDOUT. Used by the DRTDaemon process to relay information
    // back to the build machine. We ignore any errors.
    //
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
              ach,
              strlen(ach),
              &cbWrite,
              NULL);

    FlushFileBuffers(GetStdHandle(STD_OUTPUT_HANDLE));

    if (DbgExIsTagEnabled(tagAssertExit))
    {
        g_fAbnormalProcessTermination = TRUE;

        // If not in process attach or detach, then try to
        // shut the process down.

        if (g_cAssertThreadDisable == 0)
        {
            TerminateProcess(GetCurrentProcess(), 1);
        }
        else
        {
            static char *s_pszExitCode = "\nPROCESS_EXIT_CODE=1";

            // Since we can't set our process exit code by calling
            // TerminateProcess, we have to tell the DRTDaemon that we've
            // failed another way.

            WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
                      s_pszExitCode,
                      strlen(s_pszExitCode),
                      &cbWrite,
                      NULL);

            FlushFileBuffers(GetStdHandle(STD_OUTPUT_HANDLE));
        }

        return FALSE;
    }

    // Check if this occurrance has been manually disabled
    if (_fDisableAllAsserts || rgbmkDisabledAsserts.IsMarked(szFile, iLine))
        return FALSE;

    //  If appropriate, pop up an assert dialog for the user.  Note
    //    that we return TRUE (thereby causing an int 3 break) only
    //    if we pop up the dialog and the user hits Cancel.

    return DbgExIsTagEnabled(tagAssertPop) && (PopUpError(&mbot) == IDCANCEL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExAssertThreadDisable
//
//  Synopsis:   Disables or Enables assert message box spinning a thread.
//
//  Arguments:  [fDisable] -- TRUE if assert on thread should be disabled.
//                            FALSE to re-enable it.
//
//  Returns:    void
//
//  Notes:      Multiple calls giving TRUE require the same amount of calls
//              giving FALSE before assert on thread is actually re-enabled.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExAssertThreadDisable(BOOL fDisable)
{
    if (fDisable)
        InterlockedIncrement(&g_cAssertThreadDisable);
    else
        InterlockedDecrement(&g_cAssertThreadDisable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\assertui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       assertui.cxx
//
//  Contents:   Assert Dialog implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------------------
//
// MYDLGTEMPLATE, MYDLGITEMTEMPLATE
//
// Structures containing additional necessary information for the dialog
// template
//
//----------------------------------------------------------------------------

#include "pshpack2.h" // It provides the pack(2) feature.

struct MYDLGTEMPLATE : DLGTEMPLATE
{
    WCHAR wMenu;       // Must be 0
    WCHAR wClass;      // Must be 0
    WCHAR achTitle[2]; // Must be DWORD aligned
};

struct MYDLGITEMTEMPLATE : DLGITEMTEMPLATE
{
    WCHAR wClassLen;   // Must be -1
    WCHAR wClassType;
    WCHAR achInitText[2];
};

#include "poppack.h" // It provides the pack() feature.

//+---------------------------------------------------------------------------
//
//  DLGITEM_ID
//
//  IDs for all the controls in the dialog
//
//----------------------------------------------------------------------------

enum DLGITEM_ID
{
    DI_PROCESSNAME = 0,
    DI_PROCESSID,
    DI_FILE,
    DI_LINE,
    DI_MESSAGE,
    DI_IGNORE,
    DI_BREAK,
    DI_CLIPBOARD,
    DI_ICON,
    DI_STACKMSG,
    DI_MODULEBASE,
    DI_FUNCBASE   = DI_MODULEBASE + SHORT_SYM_COUNT,
    DI_MAX        = DI_FUNCBASE   + SHORT_SYM_COUNT
};

#define STYLE_STATICDEFAULT WS_VISIBLE | SS_LEFTNOWORDWRAP | SS_NOPREFIX | \
                            WS_CHILD


#define DLGITEM_STATIC 0x0082
#define DLGITEM_BUTTON 0x0080

void StringFromMBOT(MBOT *pmbot, char * pch, BOOL fShortSyms);

//+---------------------------------------------------------------------------
//
// Inline function that returns a DWORD aligned pointer to a MYDLGITEMTEMPLATE
// based on the end of the previous one. [pb] should be the achInitText
// pointer, with the string already set. If [fAddExtra] is TRUE, it accounts
// for the "creation data" element by skipping over it (it must already have
// been set to zero).
//
//----------------------------------------------------------------------------

inline MYDLGITEMTEMPLATE *
GetNextItem(BYTE * pb, BOOL fAddExtra = TRUE)
{
    pb = pb + ((wcslen((WCHAR*)pb) + 1) * sizeof(WCHAR)) + ((fAddExtra)
                                                               ? sizeof(WORD)
                                                               : 0);

    // The following DWORD aligns the returned pointer

    return (MYDLGITEMTEMPLATE *)(((ULONG_PTR)pb + 3) & ~(3));
}

//+---------------------------------------------------------------------------
//
// wsprintf function that always returns output in Unicode, even on Win95
//
//----------------------------------------------------------------------------
void __cdecl
my_wsprintf(WCHAR *pchBuf, CHAR *pchFmt, ...)
{
    extern BOOL g_fOSIsNT;

    va_list valMarker;

    va_start(valMarker, pchFmt);

    // wvsprintfW is not implemented on Win95 - blaugh!
    if (g_fOSIsNT)
    {
        WCHAR achFmt[100];

        wsprintfW(achFmt, _T("%hs"), pchFmt);

        wvsprintfW(pchBuf, achFmt, valMarker);
    }
    else
    {
        CHAR achBuf[1024];

        wvsprintfA(achBuf, pchFmt, valMarker);

        MultiByteToWideChar(CP_ACP, 0, achBuf, -1, pchBuf, 256);
    }

    va_end(valMarker);
}
//+---------------------------------------------------------------------------
//
//  Function:   DlgAssert
//
//  Synopsis:   DialogProc for the assert dialog
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DlgAssert(HWND hwndDlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        {
            EnsureThreadState();

            TLS(pmbot) = (MBOT *)lparam;

            HICON hIcon = LoadIconA(NULL, (LPSTR)IDI_EXCLAMATION);
            SendDlgItemMessageA(hwndDlg,
                                DI_ICON,
                                STM_SETICON,
                                (WPARAM)hIcon,
                                (LPARAM)0);

#if 0
            for (int i = DI_PROCESSNAME; i < DI_MESSAGE; i++)
            {
                SendDlgItemMessageA(hwndDlg,
                                    i,
                                    WM_SETFONT,
                                    (WPARAM)GetStockObject(SYSTEM_FIXED_FONT),
                                    (LPARAM)0);
            }
#endif

            // This call to PlaySound is too flaky to use - during DllMain
            // calls it fails to return and in general doesn't always work on
            // NT 4.0.
            // PlaySoundA("SystemExclamation", NULL, SND_ALIAS | SND_NODEFAULT);
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wparam, lparam))
        {
        case DI_CLIPBOARD:
            {
                HGLOBAL hGlobal;
                char    achBuf[4096];

                StringFromMBOT(TLS(pmbot), achBuf, FALSE);
                hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                                      strlen(achBuf) + 2);

                if (hGlobal)
                {
                    char * pch = (char *)GlobalLock(hGlobal);
                    strcpy(pch, achBuf);
                    GlobalUnlock(hGlobal);

                    OpenClipboard(hwndDlg);
                    EmptyClipboard();
                    SetClipboardData(CF_TEXT, hGlobal);
                    CloseClipboard();
                }

            }
            break;

        case DI_IGNORE:
            EndDialog(hwndDlg, IDOK);
            break;

        case DI_BREAK:
        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoAssertDialog
//
//  Synopsis:   Creates an assert dialog (described below)
//
//  Arguments:  [pmbot] -- Pointer to assert information
//
//  Returns:    IDOK if user selected "Ignore", IDCANCEL for "Break"
//
//  The dialog looks like this:
//
//       ------------------------------------------------------------
//       |                                                          |
//       |  ICON    Process: <exename>            <Process ID Info> |
//       |          File: <filename>              Line: <line #>    |
//       |                                                          |
//       |                          <message>                       |
//       |                                                          |
//       |   Stacktrace: (Not displayed if not present)             |
//       |       <module>  <symbol>                                 |
//       |          .         .                                     |
//       |          .         .                                     |
//       |                                                          |
//       |          [Ignore]       [Copy Text]     [Break]          |
//       |                                                          |
//       ------------------------------------------------------------
//
//     Each section of text is a separate static control, whose ID is taken
//     from the DLGITEM_ID enum. Each control has a corresponding
//     MYDLGITEMTEMPLATE structure, which is filled in with the appropriate
//     initial text, position, and style information. The dialog is dynamically
//     sized to fit the message and stacktrace as appropriate. The Copy Text
//     button causes the text of the assert plus an extended stacktrace to
//     be copied to the clipboard.
//
//----------------------------------------------------------------------------

// The following distance and size values are all in "character widths" or
// "character heights", not dialog units, except as noted.

static int CX_LEFT_EDGE = 7; // Left edge to start of 1st two lines
static int CY_TOP      =  1; // Top to first line
static int CY_DELTA    =  1; // Vertical distance between lines
static int CX_BUFFER   =  3; // Minimum Horiz. spacing between two textboxes.
                             //  Also used to space text from the right edge
                             //  of the dialog.
static int CX_BUTTON   = 42; // Width of the buttons  (in dialog units)
static int CY_BUTTON   = 14; // Height of the buttons (in dialog units)

static int CX_MODULE = (CX_LEFT_EDGE + 3); // Left edge to <module> text
static int CX_SYMBOL = (CX_MODULE + 12);   // Left edge to <symbol> text

// The following is the maximum number of characters we allow on a single line
// for the message displayed in the dialog.
#define CX_MAX_WIDTH  100


int
DoAssertDialog(MBOT *pmbot)
{
    BYTE               abBuf[4096];     // Buffer for storing dialog template
    MYDLGTEMPLATE *    pDlgTmplt;
    MYDLGITEMTEMPLATE *pIT[30] = { 0 }; // Max number of controls in dialog=30
    MYDLGITEMTEMPLATE *pITCur;
    DWORD              dwWidth;
    int                i;

    memset(abBuf, 0, sizeof(abBuf));

    // --- Main Dialog Template

    pDlgTmplt = (MYDLGTEMPLATE*)abBuf;

    pDlgTmplt->style = WS_VISIBLE | WS_POPUP | WS_BORDER | WS_CAPTION | WS_POPUP |
                       DS_CENTER | DS_NOFAILCREATE | //DS_FIXEDSYS |
                       DS_SETFOREGROUND;

    my_wsprintf(pDlgTmplt->achTitle, "%hs", pmbot->szTitle);

    // --- Process Name label

    pITCur = pIT[DI_PROCESSNAME] = GetNextItem((BYTE*)(pDlgTmplt->achTitle), FALSE);

    my_wsprintf(pITCur->achInitText, "Process: %hs", pmbot->achModule);

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->x          = (short)CX_LEFT_EDGE;
    pITCur->y          = (short)CY_TOP;
    pITCur->cx         = (short)(wcslen(pITCur->achInitText) + CX_BUFFER);
    pITCur->cy         = 1;
    pITCur->id         = DI_PROCESSNAME;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- Process and Thread ID label

    pITCur = pIT[DI_PROCESSID] = GetNextItem((BYTE*)(pITCur->achInitText));

    if (pmbot->tid < 0xFFFF)
    {
        my_wsprintf(pITCur->achInitText,
                    "PID: %x  TID: %x",
                    pmbot->pid,
                    pmbot->tid);
    }
    else
    {
        my_wsprintf(pITCur->achInitText, "TID: %x", pmbot->tid);
    }

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->y          = (short)CY_TOP;
    pITCur->cx         = (short)wcslen(pITCur->achInitText);
    pITCur->cy         = 1;
    pITCur->id         = DI_PROCESSID;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- File Name label

    pITCur = pIT[DI_FILE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "File: %hs", pmbot->szFile);

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->x          = (short)CX_LEFT_EDGE;
    pITCur->y          = (short)(CY_TOP + CY_DELTA);
    pITCur->cx         = (short)(wcslen(pITCur->achInitText) + CX_BUFFER);
    pITCur->cy         = 1;
    pITCur->id         = DI_FILE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- Line Number label

    pITCur = pIT[DI_LINE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "Line: %u", pmbot->dwLine);

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->y          = (short)(CY_TOP + CY_DELTA);
    pITCur->cx         = (short)wcslen(pITCur->achInitText);
    pITCur->cy         = 1;
    pITCur->id         = DI_LINE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // -- Compute width of dialog. This is done by finding the longest line
    //    of the first three lines in the dialog. The message can never
    //    contribute more than CX_MAX_WIDTH characters to this calculation
    //    because if it's longer than that then we wrap it onto multiple lines.

    dwWidth = max(pIT[DI_PROCESSNAME]->cx, pIT[DI_FILE]->cx) +
              max(pIT[DI_PROCESSID]->cx,   pIT[DI_LINE]->cx);

    // Do signed arithmetic to catch a negative result
    i = strlen(pmbot->szMessage) - CX_LEFT_EDGE;

    if ((i > (int)dwWidth) && (i < CX_MAX_WIDTH))
    {
        dwWidth = min(i, CX_MAX_WIDTH);
    }

    // Make sure the buttons fit.
    if ((dwWidth + CX_LEFT_EDGE) < (DWORD)(4 * (CX_BUTTON/4)))
    {
        dwWidth = 4 * (CX_BUTTON/4) + CX_BUFFER;
    }

    // Set the overall dialog width, and position the two controls in the upper
    // right corner.

    pDlgTmplt->cx = (short)(dwWidth + CX_LEFT_EDGE + CX_BUFFER);
    pIT[DI_PROCESSID]->x = (short)(dwWidth + CX_LEFT_EDGE - pIT[DI_PROCESSID]->cx);
    pIT[DI_LINE]->x = pIT[DI_PROCESSID]->x;

    // --- Message label

    pITCur = pIT[DI_MESSAGE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "%hs", pmbot->szMessage);

    pITCur->style      = WS_VISIBLE | WS_CHILD | SS_CENTER | SS_NOPREFIX;
    pITCur->x          = 1;
    pITCur->y          = (short)(CY_TOP + (CY_DELTA * 3));
    pITCur->cx         = (short)(dwWidth + CX_LEFT_EDGE);
    pITCur->cy         = (short)(wcslen(pITCur->achInitText) / dwWidth + 1);
    pITCur->id         = DI_MESSAGE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- Ignore Button (default)
    //
    // The order of these buttons determines the tab order!

    pITCur = pIT[DI_IGNORE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "&Ignore");

    pITCur->style      = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_CENTER |
                         BS_VCENTER | BS_DEFPUSHBUTTON;
    pITCur->x          = (short)((pDlgTmplt->cx / 2) - (2 * (CX_BUTTON/4)));
    pITCur->cx         = (short)CX_BUTTON;
    pITCur->cy         = (short)CY_BUTTON;
    pITCur->id         = DI_IGNORE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_BUTTON;

    // --- Copy To Clipboard Button

    pITCur = pIT[DI_CLIPBOARD] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "&Copy Text");

    pITCur->style      = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_CENTER |
                         BS_VCENTER | BS_PUSHBUTTON;
    pITCur->x          = (short)((pDlgTmplt->cx / 2) - (CX_BUTTON / 8));
    pITCur->cx         = (short)CX_BUTTON;
    pITCur->cy         = (short)CY_BUTTON;
    pITCur->id         = DI_CLIPBOARD;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_BUTTON;

    // --- Break Button

    pITCur = pIT[DI_BREAK] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "&Break");

    pITCur->style      = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_CENTER |
                         BS_VCENTER | BS_PUSHBUTTON;
    pITCur->x          = (short)((pDlgTmplt->cx / 2) + (CX_BUTTON/4));
    pITCur->cx         = (short)CX_BUTTON;
    pITCur->cy         = (short)CY_BUTTON;
    pITCur->id         = IDCANCEL; // So escape key works
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_BUTTON;

    // --- Icon

    pITCur = pIT[DI_ICON] = GetNextItem((BYTE*)(pITCur->achInitText));

    pITCur->achInitText[0] = L'\0'; // Icon is set in WM_INITDIALOG

    pITCur->style      = WS_VISIBLE | WS_CHILD | SS_ICON;
    pITCur->x          = 2;
    pITCur->y          = 1;
    pITCur->cx         = 0;
    pITCur->cy         = 0;
    pITCur->id         = DI_ICON;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    pDlgTmplt->cdit = 9; // Total of all controls so far

    //
    // --- Add Stacktrace information if available
    //
    if (pmbot->cSym)
    {
        int cSyms, j, ypos, id;

        // --- Stacktrace label

        pITCur = pIT[DI_STACKMSG] = GetNextItem((BYTE*)(pITCur->achInitText));

        my_wsprintf(pITCur->achInitText, "StackTrace:");

        pITCur->style      = STYLE_STATICDEFAULT;
        pITCur->y          = (short)(pIT[DI_MESSAGE]->y + pIT[DI_MESSAGE]->cy + CY_DELTA);
        pITCur->x          = (short)CX_LEFT_EDGE;
        pITCur->cx         = (short)wcslen(pITCur->achInitText);
        pITCur->cy         = 1;
        pITCur->id         = DI_STACKMSG;
        pITCur->wClassLen  = 0xFFFF;
        pITCur->wClassType = DLGITEM_STATIC;

        pDlgTmplt->cdit++;

        cSyms = min(pmbot->cSym, SHORT_SYM_COUNT);
        ypos  = pITCur->y + pITCur->cy;

        // --- Modules and symbols

        for (i=0; i < cSyms; i++)
        {
            for (j=0; j < 2; j++)
            {
                id = (j) ? (DI_MODULEBASE+i) : (DI_FUNCBASE+i);

                pITCur = pIT[id] = GetNextItem((BYTE*)(pITCur->achInitText));

                my_wsprintf(pITCur->achInitText,
                            "%hs",
                            (j)
                              ? pmbot->asiSym[i].achModule
                              : pmbot->asiSym[i].achSymbol);

                pITCur->style      = STYLE_STATICDEFAULT;
                pITCur->x          = (short)((j) ? CX_MODULE : CX_SYMBOL);
                pITCur->y          = (short)ypos;
                pITCur->cx         = (short)wcslen(pITCur->achInitText);
                pITCur->cy         = 1;
                pITCur->id         = (short)id;
                pITCur->wClassLen  = 0xFFFF;
                pITCur->wClassType = DLGITEM_STATIC;

                pDlgTmplt->cdit++;
            }

            ypos += pITCur->cy;
        }
    }

    // --- Convert coordinates from character widths to dialog units (char * 4
    // in X direction, char * 8 in Y direction)

    pDlgTmplt->cx  *= 4;

    for (i = 0; i < DI_MAX; i++)
    {
        pITCur = pIT[i];
        if (pITCur)
        {
            pITCur->x *= 4;
            pITCur->y *= 8;

            if (pITCur->wClassType != DLGITEM_BUTTON)
            {
                // Button cx's and cy's are already in dialog units.
                pITCur->cx *= 4;
                pIT[i]->cy *= 8;
            }
        }
    }

    //
    // Position the buttons vertically now that all text is added
    //
    if (pmbot->cSym)
    {
        i = DI_MODULEBASE + min(pmbot->cSym, SHORT_SYM_COUNT) - 1;
    }
    else
    {
        i = DI_MESSAGE;
    }

    pIT[DI_IGNORE]->y = (short)(pIT[i]->y + pIT[i]->cy + (8*CY_DELTA));
    pIT[DI_BREAK]->y  = (short)(pIT[DI_CLIPBOARD]->y = pIT[DI_IGNORE]->y);

    // Compute the overall height of the dialog
    pDlgTmplt->cy = (short)(pIT[DI_IGNORE]->y + pIT[DI_IGNORE]->cy + (8*CY_DELTA));

    // -- Let's create this thing!
    DLGTEMPLATE *dlgTemplate = (DLGTEMPLATE *)abBuf;

    pmbot->id = DialogBoxIndirectParamA(
                                        g_hinstMain,
                                        dlgTemplate,
                                        NULL,
                                        DlgAssert,
                                        (LPARAM)pmbot);

    return pmbot->id;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       debug.cxx
//
//  Contents:   Shell debugging functionality
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_MAPICODE_H_
#define X_MAPICODE_H_
#include <mapicode.h>
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_DOCOBJ_H_
#define X_DOCOBJ_H_
#include <docobj.h>
#endif

#ifdef UNIX // IEUNIX: it should be in objbase.h. Here to prevent build break.
#ifndef X_URLMON_H_
#define X_URLMON_H_
#include <urlmon.h>
#endif
#endif // UNIX

HRESULT UnLoadPSAPI();

//  Globals

#ifdef _MAC
BOOL    fEnableMacCheckHeap = TRUE;
#endif

typedef BOOL (WINAPI * PFNDLLMAIN)(HANDLE, DWORD, LPVOID);

HMODULE                 g_hModule          = NULL;
HINSTANCE               g_hinstMain        = NULL;
HANDLE                  g_hProcess         = NULL;
HANDLE                  g_rgDllHandle[8];
PFNDLLMAIN              g_rgDllMain[8];

BOOL                    g_fAbnormalProcessTermination = FALSE;
BOOL                    g_fOutputToConsole = FALSE;
BOOL                    g_fDetached        = FALSE;

CRITICAL_SECTION        g_csTrace;
CRITICAL_SECTION        g_csResDlg;
CRITICAL_SECTION        g_csDebug;
CRITICAL_SECTION        g_csHeapHack;
CRITICAL_SECTION        g_csSpy;

DWORD                   g_dwTls = (DWORD) -1;

static DBGTHREADSTATE *    s_pts;

static HANDLE           s_hFileLog         = INVALID_HANDLE_VALUE;

//  TAGS and stuff

/*
 *  Number of TAG's registered so far.
 *
 */
TRACETAG tagMac;


/*
 *  Mapping from TAG's to information about them.  Entries
 *  0...tagMac-1 are valid.
 */
TGRC    mptagtgrc[tagMax];


TRACETAG     tagDefault                  = tagNull;
TRACETAG     tagError                    = tagNull;
TRACETAG     tagWarn                     = tagNull;
TRACETAG     tagAssertPop                = tagNull;
TRACETAG     tagAssertExit               = tagNull;
TRACETAG     tagAssertStacks             = tagNull;
TRACETAG     tagTestFailures             = tagNull;
TRACETAG     tagTestFailuresIgnore       = tagNull;
TRACETAG     tagRRETURN                  = tagNull;
TRACETAG     tagValidate                 = tagNull;
TRACETAG     tagLeaks                    = tagNull;
TRACETAG     tagLeaksExpected            = tagNull;
TRACETAG     tagSymbols                  = tagNull;
TRACETAG     tagSpySymbols               = tagNull;
TRACETAG     tagTrackItf                 = tagNull;
TRACETAG     tagTrackItfVerbose          = tagNull;
TRACETAG     tagThrd                     = tagNull;
TRACETAG     tagMemoryStrict_            = tagNull;
TRACETAG     tagCoMemoryStrict_          = tagNull;
TRACETAG     tagMemoryStrictTail_        = tagNull;
TRACETAG     tagMemoryStrictAlign_       = tagNull;
TRACETAG     tagOLEWatchvar              = tagNull;
TRACETAG     tagMemTrace                 = tagNull;
TRACETAG     tagPerf_                    = tagNull;
TRACETAG     tagTraceCalls               = tagNull;
TRACETAG     tagHexDumpLeaks             = tagNull;
TRACETAG     tagNoLeakAssert             = tagNull;
TRACETAG     tagMagic                    = tagNull;
TRACETAG     tagStackSpew                = tagNull;

#ifndef _MAC
#define SZ_NEWLINE "\r\n"
#else
#define SZ_NEWLINE "\n"
#endif

static CHAR szStateFileExt[]    = ".tag";
static CHAR szDbgOutFileExt[]   = ".log";
static CHAR szStateFileName[]   = "HTMLPad.dbg";
static CHAR szDbgOutFileName[]  = "HTMLPad.log";


CHAR    rgchTraceTagBuffer[1024] = { 0 };

void    DllProcessAttach(HINSTANCE hinstance);
void    DllProcessDetach();
const   LPTSTR GetHResultName(HRESULT r);
TRACETAG TagRegisterSomething(
        TGTY tgty, CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);
BOOL    SendTagToDisk(TRACETAG tag, BOOL fSendToDisk);
VOID    SpitSzToDisk(CHAR * sz);
void    SetSortFirstFlag (TRACETAG tag);


extern void PerfProcessAttach();
extern void PerfProcessDetach();
extern void MeterProcessAttach();
extern void MeterProcessDetach();
extern void ReadFillBytes();

static double FloatPointUsed()
{
    double foo = 10.0 * 20.0;
    return foo;
}

#ifdef UNIX
extern "C"
#endif
BOOL
DllMain(HANDLE hinst, DWORD dwReason, LPVOID lpReason)
{

    DbgExAssertThreadDisable(TRUE);

    // KGallo - This is to ensure we get floating point loaded in to the
    // system so our printf can print doubles.  If you do not reference a
    // floating point operation in your code anywhere then you will
    // not get floating point support.
    // It also cannot be in unreachable code since this will be
    // removed by the compiler

    FloatPointUsed();

#if defined(UNIX)
    // IEUNIX Take out use of threads for the assert dialog
    DbgExAssertThreadDisable(TRUE);
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DllProcessAttach((HINSTANCE)hinst);
        PerfProcessAttach();
        MeterProcessAttach();
        ReadFillBytes();
        break;

    case DLL_THREAD_DETACH:
        DllThreadDetach(DbgGetThreadState());
        break;

    case DLL_PROCESS_DETACH:
        g_fDetached = TRUE;
        DllProcessDetach();
        MeterProcessDetach();
        PerfProcessDetach();
        break;
    }

    DbgExAssertThreadDisable(FALSE);

    return TRUE;
}

HRESULT
DllThreadAttach()
{
    DBGTHREADSTATE *   pts;

    // Allocate directly from the heap, rather than through new, since new
    // requires that the DBGTHREADSTATE is established
    pts = (DBGTHREADSTATE *)LocalAlloc(LMEM_FIXED, sizeof(DBGTHREADSTATE));
    if (!pts)
    {
        Assert("Debug Thread initialization failed");
        return E_OUTOFMEMORY;
    }

    memset(pts, 0, sizeof(DBGTHREADSTATE));

    {
        LOCK_GLOBALS;

        pts->ptsNext = s_pts;
        if (s_pts)
            s_pts->ptsPrev = pts;
        s_pts = pts;
    }

    TlsSetValue(g_dwTls, pts);

    return S_OK;
}

void
DllThreadDetach(DBGTHREADSTATE *pts)
{
    DBGTHREADSTATE **  ppts;

    if (!pts)
        return;

    LOCK_GLOBALS;

    for (ppts = &s_pts; *ppts && *ppts != pts; ppts = &((*ppts)->ptsNext));
    if (*ppts)
    {
        *ppts = pts->ptsNext;
        if (pts->ptsNext)
        {
            pts->ptsNext->ptsPrev = pts->ptsPrev;
        }
    }

   LocalFree(pts);
}

void
DllProcessAttach(HINSTANCE hinst)
{
    static struct
    {
        TRACETAG *  ptag;
        TGTY        tgty;
        LPSTR       pszClass;
        LPSTR       pszDescr;
        BOOL        fEnabled;
    }
    g_ataginfo[] =
    {
        &tagDefault,                tgtyTrace,  "Debug",
            "General debug output",                             TRUE,
        &tagAssertPop,              tgtyOther,  "Assert",
            "Popups on asserts",                                TRUE,
        &tagAssertExit,             tgtyOther,  "Assert",
            "Exit on asserts",                                  FALSE,
        &tagAssertStacks,           tgtyOther,  "Assert",
            "Stacktraces on asserts",                           TRUE,
        &tagValidate,               tgtyOther,  "Memory",
            "Aggressive memory validation",                     FALSE,
        &tagLeaks,                  tgtyTrace,  "Memory",
            "Memory Leaks",                                     TRUE,
        &tagLeaksExpected,          tgtyTrace,  "Memory",
            "Memory Leaks (Expected)",                          FALSE,
        &tagMemoryStrict_,          tgtyOther,  "Memory",
            "Use VMem for MemAlloc",                            FALSE,
        &tagCoMemoryStrict_,        tgtyOther,  "Memory",
            "Use VMem for CoTaskMemAlloc",                      FALSE,
        &tagMemoryStrictTail_,      tgtyOther,  "Memory",
            "VMem strict at end (vs beginning)",                TRUE,
        &tagMemoryStrictAlign_,     tgtyOther,  "Memory",
            "VMem pad to quadword at end",                      FALSE,
        &tagMemTrace,               tgtyOther,  "Memory",
            "Trace Memory Allocations",                         FALSE,
        &tagSymbols,                tgtyTrace,  "Memory",
            "Leaks: Stacktraces & symbols",                     FALSE,
        &tagSpySymbols,             tgtyTrace,  "Memory",
            "Leaks: Stacktraces & symbols for CoTaskMemAlloc",  FALSE,
        &tagHexDumpLeaks,           tgtyTrace,  "Memory",
            "Leaks: Hexdump contents of blocks",                FALSE,
        &tagNoLeakAssert,           tgtyTrace,  "Memory",
            "Leaks: Don't assert on leaks",                     FALSE,
        &tagStackSpew,              tgtyOther,  "Memory",
            "Stack Spew: Fill stack with known value",          TRUE,
        &tagError,                  tgtyTrace,  "Trace",
            "Errors",                                           TRUE,
        &tagWarn,                   tgtyTrace,  "Trace",
            "Warnings",                                         FALSE,
        &tagTestFailures,           tgtyTrace,  "Trace",
            "THR",                                              FALSE,
        &tagTestFailuresIgnore,     tgtyTrace,  "Trace",
            "IGNORE_HR",                                        FALSE,
        &tagRRETURN,                tgtyTrace,  "Trace",
            "RRETURN",                                          FALSE,
        &tagTraceCalls,             tgtyTrace,  "Trace",
            "Trace all THR calls",                              FALSE,
        &tagTrackItf,               tgtyTrace,  "Track",
            "Interface watch",                                  FALSE,
        &tagTrackItfVerbose,        tgtyOther,  "Track",
            "Verbose trace on interface watch",                 FALSE,
        &tagThrd,                   tgtyTrace,  "Thread",
            "Thread related tracing",                           FALSE,
        &tagOLEWatchvar,            tgtyTrace,  "Trace",
            "All calls to OCX interfaces",                      FALSE,
        &tagPerf_,                  tgtyTrace,  "Perf",
            "Perf and size killers",                            FALSE,
        &tagMagic,                  tgtyTrace,  "Magic",
            "Trace imagehlp.dll failures",                      FALSE,
};


    TGRC *  ptgrc;
    char    szLogPath[MAX_PATH];
    int     i;

#ifndef  _MAC
    InitializeCriticalSection(&g_csTrace);
    InitializeCriticalSection(&g_csResDlg);
    InitializeCriticalSection(&g_csDebug);
    InitializeCriticalSection(&g_csHeapHack);
    InitializeCriticalSection(&g_csSpy);
#endif

    g_dwTls = TlsAlloc();
    if (g_dwTls == (DWORD)(-1))
    {
        DbgExAssertThreadDisable(FALSE);
        return;
    }

    EnsureThreadState();

    g_hinstMain = hinst;

    // don't want windows to put up message box on INT 24H errors.
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Initialize simulated failures
    DbgExSetSimFailCounts(0, 1);

    // Initialize TAG array

    tagMac = tagMin;

    // enable tagNull at end of DbgExRestoreDefaultDebugState
    ptgrc = mptagtgrc + tagNull;
    ptgrc->tgty = tgtyNull;
    ptgrc->fEnabled = FALSE;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->szOwner = "dgreene";
    ptgrc->szDescrip = "NULL";

    for (i = 0; i < ARRAY_SIZE(g_ataginfo); i++)
    {
        *g_ataginfo[i].ptag = TagRegisterSomething(
                g_ataginfo[i].tgty,
                g_ataginfo[i].pszClass,
                g_ataginfo[i].pszDescr,
                g_ataginfo[i].fEnabled);

        SetSortFirstFlag(*g_ataginfo[i].ptag);
    }

    g_hProcess = GetCurrentProcess();

    if (GetEnvironmentVariableA("TRIDENT_LOGPATH", szLogPath, MAX_PATH))
    {
        DbgExOpenLogFile(szLogPath);
    }

    MagicInit();
    DbgExRestoreDefaultDebugState();
}

void
DllProcessDetach(void)
{
    TRACETAG    tag;
    TGRC *      ptgrc;
    int         i;

    EnsureThreadState();

    for (i = 0; i < ARRAY_SIZE(g_rgDllHandle); ++i)
    {
        if (g_rgDllHandle[i] != NULL && g_rgDllMain[i] != NULL)
        {
            g_rgDllMain[i](g_rgDllHandle[i], DLL_PROCESS_DETACH, NULL);
        }
    }

    if (!g_fAbnormalProcessTermination)
    {
        DbgExTraceMemoryLeaks();
    }

    // Close the debug output file
    if (s_hFileLog != INVALID_HANDLE_VALUE)
    {
        char achBuf[128];

        wsprintfA(achBuf, "<<<<< End logging" SZ_NEWLINE);
        SpitSzToDisk(achBuf);
        CloseHandle(s_hFileLog);
        s_hFileLog = INVALID_HANDLE_VALUE;
    }

    // Free the tag strings if not already done
    for (tag = tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            GlobalFreePtr(ptgrc->szOwner);
            ptgrc->szOwner = NULL;
            GlobalFreePtr(ptgrc->szDescrip);
            ptgrc->szDescrip = NULL;
        }
    }

    //    Set flags to FALSE.  Need to separate from loop above so that
    //    final memory leak trace tag can work.

    for (tag=tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc->fEnabled = FALSE;
            ptgrc->ClearFlag(TGRC_FLAG_VALID);
        }
    }

    MagicDeinit();

    if (g_dwTls != (DWORD)(-1))
    {
        while (s_pts)
            DllThreadDetach(s_pts);
        TlsFree(g_dwTls);
    }

    // Unload PSAPI.DLL
    UnLoadPSAPI();

#ifndef _MAC
    DeleteCriticalSection(&g_csTrace);
    DeleteCriticalSection(&g_csResDlg);
    DeleteCriticalSection(&g_csDebug);
    DeleteCriticalSection(&g_csHeapHack);
    DeleteCriticalSection(&g_csSpy);
#endif
}


/*
 *  FReadDebugState
 *
 *  Purpose:
 *      Read the debug state information file whose name is given by the
 *      string szDebugFile.  Set up the tag records accordingly.
 *
 *  Parameters:
 *      szDebugFile     Name of debug file to read
 *
 *  Returns:
 *      TRUE if file was successfully read; FALSE otherwise.
 *
 */

BOOL
FReadDebugState( CHAR * szDebugFile )

{
    HANDLE      hfile = NULL;
    TGRC        tgrc;
    TGRC *      ptgrc;
    TRACETAG    tag;
    INT         cchOwner;
    CHAR        rgchOwner[MAX_PATH];
    INT         cchDescrip;
    CHAR        rgchDescrip[MAX_PATH];
    BOOL        fReturn = FALSE;
    DWORD       cRead;

#ifdef UNIX
    CHAR *pszSlash = strrchr(szDebugFile, '/');
    hfile = INVALID_HANDLE_VALUE;

    if ( pszSlash )
    {
        strcpy( szDebugFile, pszSlash+1 );
        hfile = CreateFileA(szDebugFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            (HANDLE) NULL);
    }
#else
    hfile = CreateFileA(szDebugFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
#endif

    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (;;)
        {
            if (!ReadFile(hfile, &tgrc, sizeof(TGRC), &cRead, NULL))
                break;

            if (cRead == 0)
                break;

            if (!ReadFile(hfile, &cchOwner, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchOwner <= sizeof(rgchOwner));
            if (!ReadFile(hfile, rgchOwner, cchOwner, &cRead, NULL))
                goto ErrorReturn;

            if (!ReadFile(hfile, &cchDescrip, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchDescrip <= sizeof(rgchDescrip));
            if (!ReadFile(hfile, rgchDescrip, cchDescrip, &cRead, NULL))
                goto ErrorReturn;

            ptgrc = mptagtgrc + tagMin;
            for (tag = tagMin; tag < tagMac; tag++)
            {
                if (ptgrc->TestFlag(TGRC_FLAG_VALID) &&
                    !strcmp(rgchOwner, ptgrc->szOwner) &&
                    !strcmp(rgchDescrip, ptgrc->szDescrip))
                {
                    if (!ptgrc->TestFlag(TGRC_FLAG_INITED))
                    {
                        Assert(tgrc.TestFlag(TGRC_FLAG_VALID));

                        ptgrc->fEnabled = tgrc.fEnabled;
                        ptgrc->ulBitFlags = tgrc.ulBitFlags;

                        // Only read each tag once
                        ptgrc->SetFlag(TGRC_FLAG_INITED);
                    }
                    break;
                }

                ptgrc++;
            }
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);

Exit:
    return fReturn;
}

/*
 *  FWriteDebugState
 *
 *  Purpose:
 *      Writes the current state of the Debug Module to the file
 *      name given.  The saved state can be restored later by calling
 *      FReadDebugState.
 *
 *  Parameters:
 *      szDebugFile     Name of the file to create and write the debug
 *                      state to.
 *
 *  Returns:
 *      TRUE if file was successfully written; FALSE otherwise.
 */
BOOL
FWriteDebugState( CHAR * szDebugFile )
{
    HANDLE      hfile = NULL;
    TRACETAG    tag;
    UINT        cch;
    TGRC *      ptgrc;
    BOOL        fReturn = FALSE;
    DWORD       cWrite;

#ifdef UNIX
    CHAR *pszSlash = strrchr(szDebugFile, '/');
    hfile = INVALID_HANDLE_VALUE;

    if ( pszSlash )
    {
        strcpy( szDebugFile, pszSlash+1 );
        hfile = CreateFileA(szDebugFile,
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            (HANDLE) NULL);
    }
#else
    hfile = CreateFileA(szDebugFile,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
#endif

    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (tag = tagMin; tag < tagMac; tag++)
        {
            ptgrc = mptagtgrc + tag;

            if (!ptgrc->TestFlag(TGRC_FLAG_VALID))
                continue;

            Assert(ptgrc->szOwner);
            Assert(ptgrc->szDescrip);

            if (!WriteFile(hfile, ptgrc, sizeof(TGRC), &cWrite, NULL))
                goto ErrorReturn;

            // SZ fields will be overwritten when read back

            cch = strlen(ptgrc->szOwner) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szOwner, cch, &cWrite, NULL))
                goto ErrorReturn;

            cch = strlen(ptgrc->szDescrip) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szDescrip, cch, &cWrite, NULL))
                goto ErrorReturn;
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);
    DeleteFileA(szDebugFile);

Exit:
    return fReturn;
}


//+------------------------------------------------------------------------
//
//  Function:   SaveDefaultDebugState
//
//  Synopsis:   Saves the debug state of the executing program to a file
//              of the same name, substituting the ".tag" suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void
SaveDefaultDebugState( void )
{
    CHAR    rgch[MAX_PATH] = "";

    if (g_hinstMain)
    {
#ifndef _MAC
        UINT cch = (UINT) GetModuleFileNameA(g_hModule, rgch, sizeof(rgch));
#ifdef UNIX
        strcat(rgch, szStateFileExt);
#else
        Assert(rgch[cch - 4] == '.');
        strcpy(&rgch[cch - 4], szStateFileExt);
#endif
#else
        CHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitleA(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FWriteDebugState(rgch);
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExRestoreDefaultDebugState
//
//  Synopsis:   Restores the debug state for the executing program from
//              the state file of the same name, substituting the ".tag"
//              suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void WINAPI
DbgExRestoreDefaultDebugState()
{
    CHAR    rgch[MAX_PATH] = "";

    EnsureThreadState();

    if (g_hinstMain)
    {
#if defined(_MAC)
        CHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitleA(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);

#elif defined(UNIX)
        UINT cch = (UINT) GetModuleFileNameA(NULL, rgch, sizeof(rgch));
        strcat(rgch, szStateFileExt);

#else
        UINT cch = (UINT) GetModuleFileNameA(NULL, rgch, sizeof(rgch));
        Assert(rgch[cch - 4] == '.');
        strcpy(&rgch[cch - 4], szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FReadDebugState(rgch);

    mptagtgrc[tagNull].fEnabled = TRUE;
}

TRACETAG WINAPI
DbgExFindTag(char * szTagDesc)
{
    Assert(szTagDesc);
    for (TRACETAG i = tagMin; i < tagMac; i++)
    {
        if (mptagtgrc[i].szDescrip && strlen(mptagtgrc[i].szDescrip))
        {
            if (!_stricmp(mptagtgrc[i].szDescrip, szTagDesc))
            {
                return i;
            }
        }
    }

    return 0;
}

/*
 *  DbgExIsTagEnabled
 *
 *  Purpose:
 *      Returns a boolean value indicating whether the given TAG
 *      has been enabled or disabled by the user.
 *
 *  Parameters:
 *      tag     The TAG to check
 *
 *  Returns:
 *      TRUE    if the TAG has been enabled.
 *      FALSE   if the TAG has been disabled.
 */

BOOL WINAPI
DbgExIsTagEnabled(TRACETAG tag)
{
    return  mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID) &&
            mptagtgrc[tag].fEnabled;
}


/*
 *  DbgExEnableTag
 *
 *  Purpose:
 *      Sets or resets the TAG value given.  Allows code to enable or
 *      disable TAG'd assertions and trace switches.
 *
 *  Parameters:
 *      tag         The TAG to enable or disable
 *      fEnable     TRUE if TAG should be enabled, FALSE if it should
 *                  be disabled.
 *  Returns:
 *      old state of tag (TRUE if tag was enabled, otherwise FALSE)
 *
 */

BOOL WINAPI
DbgExEnableTag(TRACETAG tag, BOOL fEnable)
{
    BOOL    fOld;

    EnsureThreadState();
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].fEnabled;
    mptagtgrc[tag].fEnabled = fEnable;
    mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_INITED;
    return fOld;
}

void SetSortFirstFlag (TRACETAG tag)
{
    EnsureThreadState();

    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));

    mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_SORTFIRST;
}

BOOL WINAPI
DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk)
{
    BOOL fOld;

    EnsureThreadState();
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].ulBitFlags;
    if (fSendToDisk) mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_DISK;
    else mptagtgrc[tag].ulBitFlags &= ~TGRC_FLAG_DISK;
    return fOld;
}

BOOL WINAPI
DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak)
{
    BOOL fOld;

    EnsureThreadState();
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].ulBitFlags;
    if (fBreak) mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_BREAK;
    else mptagtgrc[tag].ulBitFlags &= ~TGRC_FLAG_BREAK;
    return fOld;
}

void
SpitSzToDisk(char *pch)
{
    DWORD cWrite;

    if (s_hFileLog != INVALID_HANDLE_VALUE && pch && *pch)
    {
        WriteFile(s_hFileLog, pch, strlen(pch), &cWrite, NULL);
        FlushFileBuffers(s_hFileLog);
    }
}

/*
 *  TagRegisterSomething
 *
 *  Purpose:
 *      Does actual work of allocating TAG, and initializing TGRC.
 *      The owner and description strings are duplicated from the
 *      arguments passed in.
 *
 *  Parameters:
 *      tgty        Tag type to register.
 *      szOwner     Owner.
 *      szDescrip   Description.
 *
 *  Returns:
 *      New TAG, or tagNull if none is available.
 */

TRACETAG
TagRegisterSomething(
        TGTY    tgty,
        CHAR *  szOwner,
        CHAR *  szDescrip,
        BOOL    fEnabled)
{
    TRACETAG tag;
    TRACETAG tagNew         = tagNull;
    TGRC *  ptgrc;
    CHAR *  szOwnerDup      = NULL;
    CHAR *  szDescripDup    = NULL;
    UINT    cb;
    BOOL    fSortFirst = FALSE;

    if (szOwner[0] == '!')
    {
        fSortFirst = TRUE;
        szOwner++;
    }

    for (tag = tagMin, ptgrc = mptagtgrc + tag; tag < tagMac;
            tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            if(!(strcmp(szOwner, ptgrc->szOwner) ||
                strcmp(szDescrip, ptgrc->szDescrip)))
            {
                return tag;
            }
        }
        else if (tagNew == tagNull)
            tagNew= tag;
    }

    // Make duplicate copies.

    Assert(szOwner);
    Assert(szDescrip);
    cb = strlen(szOwner) + 1;

    // we use LocalAlloc here instead of new so
    // we don't interfere with leak reporting because of the
    // dependency between the debug library and the
    // leak reporting code (i.e., don't touch this --Erik)

    szOwnerDup = (LPSTR) GlobalAllocPtr(GMEM_MOVEABLE, cb);

    if (szOwnerDup == NULL)
    {
        goto Error;
    }

    strcpy(szOwnerDup, szOwner);

    cb = strlen(szDescrip) + 1;
    szDescripDup = (LPSTR) GlobalAllocPtr(GMEM_MOVEABLE, cb);

    if (szDescripDup == NULL)
    {
        goto Error;
    }

    strcpy(szDescripDup, szDescrip);

    if (tagNew == tagNull)
    {
        if (tagMac >= tagMax)
        {
#ifdef  NEVER
            AssertSz(FALSE, "Too many tags registered already!");
#endif
            Assert(FALSE);
            return tagNull;
        }

        tag = tagMac++;
    }
    else
        tag = tagNew;

    ptgrc = mptagtgrc + tag;

    ptgrc->fEnabled = fEnabled;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->tgty = tgty;
    ptgrc->szOwner = szOwnerDup;
    ptgrc->szDescrip = szDescripDup;

    if (fSortFirst)
    {
        ptgrc->ulBitFlags |= TGRC_FLAG_SORTFIRST;
    }

    return tag;

Error:
    if (szOwnerDup)
        GlobalFree((HGLOBAL)szOwnerDup);

    if (szDescripDup)
        GlobalFree((HGLOBAL)szDescripDup);

    return tagNull;
}


/*
 *  DeregisterTag
 *
 *  Purpose:
 *      Deregisters tag, removing it from tag table.
 *
 *  Parameters:
 *      tag     Tag to deregister.
 */

void
DeregisterTag(TRACETAG tag)
{
    //  don't allow deregistering the tagNull entry
    //  but exit gracefully
    if (!tag)
        return;

    Assert(tag < tagMac);
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));

    mptagtgrc[tag].fEnabled = FALSE;
    mptagtgrc[tag].ClearFlag(TGRC_FLAG_VALID);
    GlobalFree((HGLOBAL)mptagtgrc[tag].szOwner);
    mptagtgrc[tag].szOwner = NULL;
    GlobalFree((HGLOBAL)mptagtgrc[tag].szDescrip);
    mptagtgrc[tag].szDescrip = NULL;
}


/*
 *  DbgExTagRegisterTrace
 *
 *  Purpose:
 *      Registers a class of trace points, and returns an identifying
 *      TAG for that class.
 *
 *  Parameters:
 *      szOwner     The email name of the developer writing the code
 *                  that registers the class.
 *      szDescrip   A short description of the class of trace points.
 *                  For instance: "All calls to PvAlloc() and HvFree()"
 *
 *  Returns:
 *      TAG identifying class of trace points, to be used in calls to
 *      the trace routines.
 */

TRACETAG WINAPI
DbgExTagRegisterTrace( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    EnsureThreadState();
    return TagRegisterSomething(tgtyTrace, szOwner, szDescrip, fEnabled);
}



TRACETAG
DbgExTagRegisterOther( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    EnsureThreadState();
    return TagRegisterSomething(tgtyOther, szOwner, szDescrip, fEnabled);
}



TRACETAG WINAPI
DbgExTagError()
{
    EnsureThreadState();
    return tagError;
}

TRACETAG WINAPI
DbgExTagAssertExit()
{
    EnsureThreadState();
    return tagAssertExit;
}

TRACETAG WINAPI
DbgExTagAssertStacks()
{
    EnsureThreadState();
    return tagAssertStacks;
}

TRACETAG WINAPI
DbgExTagWarning()
{
    EnsureThreadState();
    return tagWarn;
}

TRACETAG WINAPI
DbgExTagThread()
{
    EnsureThreadState();
    return tagThrd;
}

TRACETAG WINAPI
DbgExTagMemoryStrict()
{
    EnsureThreadState();
    return tagMemoryStrict_;
}

TRACETAG WINAPI
DbgExTagCoMemoryStrict()
{
    EnsureThreadState();
    return tagCoMemoryStrict_;
}

TRACETAG WINAPI
DbgExTagMemoryStrictTail()
{
    EnsureThreadState();
    return tagMemoryStrictTail_;
}

TRACETAG WINAPI
DbgExTagMemoryStrictAlign()
{
    EnsureThreadState();
    return tagMemoryStrictAlign_;
}

TRACETAG WINAPI
DbgExTagOLEWatch()
{
    EnsureThreadState();
    return tagOLEWatchvar;
}

TRACETAG WINAPI
DbgExTagPerf()
{
    EnsureThreadState();
    return tagPerf_;
}

/*
 *  DbgExTaggedTrace
 *
 *  Purpose:
 *      Uses the given format string and parameters to render a
 *      string into a buffer.  The rendered string is sent to the
 *      destination indicated by the given tag, or sent to the bit
 *      bucket if the tag is disabled.
 *
 *  Arguments:
 *      tag     Identifies the tag group
 *      szFmt   Format string for _snprintf (qqv)
 */

BOOL __cdecl
DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...)
{
    BOOL    f;

    EnsureThreadState();

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = DbgExTaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl
DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    BOOL    f;

    EnsureThreadState();

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = DbgExTaggedTraceListEx(tag, usFlags, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL WINAPI
DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker)
{
    static CHAR szFmtOwner[] = "%s %s: ";
    TGRC *      ptgrc;
    int         cch;
    int         cchCopied;
    int         iIndent;
    DBGTHREADSTATE *pts;
    CHAR        achBuf[4096];

    EnsureThreadState();

    pts = DbgGetThreadState();

    if (tag == tagNull)
        ptgrc = mptagtgrc + tagDefault;
    else
        ptgrc = mptagtgrc + tag;

    if (!ptgrc->fEnabled)
        return FALSE;

    LOCK_TRACE;

    Assert(ptgrc->TestFlag(TGRC_FLAG_VALID));

    // indenting

    cch = 0;

    if (usFlags & TAG_INDENT)
        pts->iIndent++;

    iIndent = min(pts->iIndent, 64);

    if (usFlags & TAG_OUTDENT)
        pts->iIndent--;

    if (iIndent > 0)
    {
        memset(achBuf, ' ', iIndent);
        achBuf[iIndent-1] = (usFlags & TAG_INDENT ? '+' : usFlags & TAG_OUTDENT ? '-' : ' ');
        cch += iIndent;
    }

    // tag name

    if (!(usFlags & TAG_NONAME))
    {
        cch += _snprintf(
                achBuf + cch,
                ARRAY_SIZE(achBuf) - cch,
                szFmtOwner,
                "TRI",
                ptgrc->szOwner);
    }

    cchCopied = hrvsnprintf(
                       achBuf + cch,
                       ARRAY_SIZE(achBuf) - cch,
                       szFmt,
                       valMarker);

    if ( cchCopied == -1 ) {
        cch = ARRAY_SIZE(achBuf) - ARRAY_SIZE(SZ_NEWLINE);
    } else {
        cch += cchCopied;
    }

    if (!(usFlags & TAG_NONEWLINE))
        strcpy(achBuf+cch, SZ_NEWLINE);

    if (ptgrc->TestFlag(TGRC_FLAG_DISK))
    {
        SpitSzToDisk(achBuf);
    }

    if ((usFlags & TAG_USECONSOLE) || g_fOutputToConsole)
    {
       printf(achBuf);
    }

    if (!(usFlags & TAG_USECONSOLE))
    {
        OutputDebugStringA(achBuf);
    }

    if (ptgrc->TestFlag(TGRC_FLAG_BREAK))
    {
        AssertSz(FALSE, ptgrc->szDescrip);
    }

    return FALSE;
}

void WINAPI
DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal)
{
    INET_SYMBOL_INFO      asiSym[32];
    DWORD            dwEip[32];
    int              i;
    int              c;
    CHAR             achSymbol[256];

    EnsureThreadState();

    if (!DbgExIsTagEnabled(tag))
        return;

    if (cTotal > ARRAY_SIZE(dwEip))
        cTotal = ARRAY_SIZE(dwEip);

    c = GetStackBacktrace(iStart + 3, cTotal, dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);
        DbgExTaggedTraceEx(tag, TAG_NONAME, "%s", achSymbol);
    }
}


//+---------------------------------------------------------------
//
//  Function:   GetHResultName
//
//  Synopsis:   Returns a printable string for the given hresult
//
//  Arguments:  [scode] -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

const LPTSTR
GetHResultName(HRESULT r)
{
    LPTSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = _T(#sc); break;

#define CASE_SCODE2(sc,sc2)  \
        case sc: lpstr = _T(#sc) _T("/") _T(#sc2); break;

    switch (r) {
        /* Generic SCODEs */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)

        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_ACCESSDENIED)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_PENDING)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_UNEXPECTED)

        /* SCODEs from all files in alphabetical order */
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(CLASS_E_CLASSNOTAVAILABLE)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(CLASS_E_NOTLICENSED)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE2(CONNECT_E_ADVISELIMIT,SELFREG_E_CLASS)
        CASE_SCODE(CONNECT_E_CANNOTCONNECT)
        CASE_SCODE2(CONNECT_E_NOCONNECTION,PERPROP_E_NOPAGEAVAILABLE/SELFREG_E_TYPELIB)
        CASE_SCODE(CONNECT_E_OVERRIDDEN)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_BAD_PATH)
        CASE_SCODE(CO_E_BAD_SERVER_NAME)
        CASE_SCODE(CO_E_CANT_REMOTE)
        CASE_SCODE(CO_E_CLASS_CREATE_FAILED)
        CASE_SCODE(CO_E_CLSREG_INCONSISTENT)
        CASE_SCODE(CO_E_CREATEPROCESS_FAILURE)
        CASE_SCODE(CO_E_IIDREG_INCONSISTENT)
        CASE_SCODE(CO_E_INIT_CLASS_CACHE)
        CASE_SCODE(CO_E_INIT_MEMORY_ALLOCATOR)
        CASE_SCODE(CO_E_INIT_ONLY_SINGLE_THREADED)
        CASE_SCODE(CO_E_INIT_RPC_CHANNEL)
        CASE_SCODE(CO_E_INIT_SCM_EXEC_FAILURE)
        CASE_SCODE(CO_E_INIT_SCM_FILE_MAPPING_EXISTS)
        CASE_SCODE(CO_E_INIT_SCM_MAP_VIEW_OF_FILE)
        CASE_SCODE(CO_E_INIT_SCM_MUTEX_EXISTS)
        CASE_SCODE(CO_E_INIT_SHARED_ALLOCATOR)
        CASE_SCODE(CO_E_INIT_TLS)
        CASE_SCODE(CO_E_INIT_TLS_CHANNEL_CONTROL)
        CASE_SCODE(CO_E_INIT_TLS_SET_CHANNEL_CONTROL)
        CASE_SCODE(CO_E_INIT_UNACCEPTED_USER_ALLOCATOR)
        CASE_SCODE(CO_E_LAUNCH_PERMSSION_DENIED)
        CASE_SCODE(CO_E_OBJSRV_RPC_FAILURE)
        CASE_SCODE(CO_E_OLE1DDE_DISABLED)
        CASE_SCODE(CO_E_RELEASED)
        CASE_SCODE(CO_E_REMOTE_COMMUNICATION_FAILURE)
        CASE_SCODE(CO_E_RUNAS_CREATEPROCESS_FAILURE)
//        CASE_SCODE(CO_E_RUNAS_INCOMPATIBLE)
        CASE_SCODE(CO_E_RUNAS_LOGON_FAILURE)
        CASE_SCODE(CO_E_RUNAS_SYNTAX)
        CASE_SCODE(CO_E_SCM_ERROR)
        CASE_SCODE(CO_E_SCM_RPC_FAILURE)
        CASE_SCODE(CO_E_SERVER_EXEC_FAILURE)
        CASE_SCODE(CO_E_SERVER_START_TIMEOUT)
        CASE_SCODE(CO_E_SERVER_STOPPING)
        CASE_SCODE(CO_E_START_SERVICE_FAILURE)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_S_NOTALLINTERFACES)
        CASE_SCODE(CTL_E_BADFILEMODE)
        CASE_SCODE(CTL_E_BADFILENAME)
        CASE_SCODE(CTL_E_BADFILENAMEORNUMBER)
        CASE_SCODE(CTL_E_BADRECORDLENGTH)
        CASE_SCODE(CTL_E_BADRECORDNUMBER)
        CASE_SCODE(CTL_E_CANTSAVEFILETOTEMP)
        CASE_SCODE(CTL_E_DEVICEIOERROR)
        CASE_SCODE(CTL_E_DEVICEUNAVAILABLE)
        CASE_SCODE(CTL_E_DISKFULL)
        CASE_SCODE(CTL_E_DISKNOTREADY)
        CASE_SCODE(CTL_E_DIVISIONBYZERO)
        CASE_SCODE(CTL_E_FILEALREADYEXISTS)
        CASE_SCODE(CTL_E_FILEALREADYOPEN)
        CASE_SCODE(CTL_E_FILENOTFOUND)
        CASE_SCODE(CTL_E_GETNOTSUPPORTED)
        CASE_SCODE(CTL_E_GETNOTSUPPORTEDATRUNTIME)
        CASE_SCODE(CTL_E_ILLEGALFUNCTIONCALL)
        CASE_SCODE(CTL_E_INVALIDCLIPBOARDFORMAT)
        CASE_SCODE(CTL_E_INVALIDFILEFORMAT)
        CASE_SCODE(CTL_E_INVALIDPATTERNSTRING)
        CASE_SCODE(CTL_E_INVALIDPICTURE)
        CASE_SCODE(CTL_E_INVALIDPROPERTYARRAYINDEX)
        CASE_SCODE(CTL_E_INVALIDPROPERTYVALUE)
        CASE_SCODE(CTL_E_INVALIDUSEOFNULL)
        CASE_SCODE(CTL_E_NEEDPROPERTYARRAYINDEX)
        CASE_SCODE(CTL_E_OUTOFMEMORY)
        CASE_SCODE(CTL_E_OUTOFSTACKSPACE)
        CASE_SCODE(CTL_E_OUTOFSTRINGSPACE)
        CASE_SCODE(CTL_E_OVERFLOW)
        CASE_SCODE(CTL_E_PATHFILEACCESSERROR)
        CASE_SCODE(CTL_E_PATHNOTFOUND)
        CASE_SCODE(CTL_E_PERMISSIONDENIED)
        CASE_SCODE(CTL_E_PRINTERERROR)
        CASE_SCODE(CTL_E_PROPERTYNOTFOUND)
        CASE_SCODE(CTL_E_REPLACEMENTSTOOLONG)
        CASE_SCODE(CTL_E_SEARCHTEXTNOTFOUND)
        CASE_SCODE(CTL_E_SETNOTPERMITTED)
        CASE_SCODE(CTL_E_SETNOTSUPPORTED)
        CASE_SCODE(CTL_E_SETNOTSUPPORTEDATRUNTIME)
        CASE_SCODE(CTL_E_TOOMANYFILES)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(DISP_E_ARRAYISLOCKED)
        CASE_SCODE(DISP_E_BADCALLEE)
        CASE_SCODE(DISP_E_BADINDEX)
        CASE_SCODE(DISP_E_BADPARAMCOUNT)
        CASE_SCODE(DISP_E_BADVARTYPE)
        CASE_SCODE(DISP_E_EXCEPTION)
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)
        CASE_SCODE(DISP_E_NONAMEDARGS)
        CASE_SCODE(DISP_E_NOTACOLLECTION)
        CASE_SCODE(DISP_E_OVERFLOW)
        CASE_SCODE(DISP_E_PARAMNOTFOUND)
        CASE_SCODE(DISP_E_PARAMNOTOPTIONAL)
        CASE_SCODE(DISP_E_TYPEMISMATCH)
        CASE_SCODE(DISP_E_UNKNOWNINTERFACE)
        CASE_SCODE(DISP_E_UNKNOWNLCID)
        CASE_SCODE(DISP_E_UNKNOWNNAME)
//        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)      // same as OLECMDERR_E_DISABLED
//        CASE_SCODE(DRAGDROP_E_INVALIDHWND)            // same as OLECMDERR_E_NOHELP
//        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)          // same as OLECMDERR_E_NOTSUPPORTED
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE2(DRAGDROP_S_DROP,HLINK_S_DONTHIDE)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_TYMED)
//        CASE_SCODE(HLINK_S_DONTHIDE)                  // same as DRAGDROP_S_DROP
        CASE_SCODE(INET_E_AUTHENTICATION_REQUIRED)
        CASE_SCODE(INET_E_CANNOT_CONNECT)
        CASE_SCODE(INET_E_CANNOT_INSTANTIATE_OBJECT)
        CASE_SCODE(INET_E_CANNOT_LOAD_DATA)
        CASE_SCODE(INET_E_CONNECTION_TIMEOUT)
        CASE_SCODE(INET_E_DATA_NOT_AVAILABLE)
        CASE_SCODE(INET_E_DOWNLOAD_FAILURE)
        CASE_SCODE(INET_E_INVALID_REQUEST)
        CASE_SCODE(INET_E_INVALID_URL)
        CASE_SCODE(INET_E_NO_SESSION)
        CASE_SCODE(INET_E_NO_VALID_MEDIA)
        CASE_SCODE(INET_E_OBJECT_NOT_FOUND)
        CASE_SCODE(INET_E_RESOURCE_NOT_FOUND)
        CASE_SCODE(INET_E_SECURITY_PROBLEM)
        CASE_SCODE(INET_E_UNKNOWN_PROTOCOL)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(MAPI_E_AMBIGUOUS_RECIP)
//        CASE_SCODE(MAPI_E_BAD_CHARWIDTH)
        CASE_SCODE(MAPI_E_BAD_COLUMN)
        CASE_SCODE(MAPI_E_BAD_VALUE)
        CASE_SCODE(MAPI_E_BUSY)
//        CASE_SCODE(MAPI_E_CALL_FAILED)
        CASE_SCODE(MAPI_E_CANCEL)
        CASE_SCODE(MAPI_E_COLLISION)
        CASE_SCODE(MAPI_E_COMPUTED)
        CASE_SCODE(MAPI_E_CORRUPT_DATA)
        CASE_SCODE(MAPI_E_CORRUPT_STORE)
        CASE_SCODE(MAPI_E_DECLINE_COPY)
        CASE_SCODE(MAPI_E_DISK_ERROR)
//        CASE_SCODE(MAPI_E_END_OF_SESSION)
        CASE_SCODE(MAPI_E_EXTENDED_ERROR)
        CASE_SCODE(MAPI_E_FAILONEPROVIDER)
        CASE_SCODE(MAPI_E_FOLDER_CYCLE)
        CASE_SCODE(MAPI_E_HAS_FOLDERS)
        CASE_SCODE(MAPI_E_HAS_MESSAGES)
//        CASE_SCODE(MAPI_E_INTERFACE_NOT_SUPPORTED)
        CASE_SCODE(MAPI_E_INVALID_BOOKMARK)
        CASE_SCODE(MAPI_E_INVALID_ENTRYID)
        CASE_SCODE(MAPI_E_INVALID_OBJECT)
//        CASE_SCODE(MAPI_E_INVALID_PARAMETER)
        CASE_SCODE(MAPI_E_INVALID_TYPE)
//        CASE_SCODE(MAPI_E_LOGON_FAILED)
//        CASE_SCODE(MAPI_E_MISSING_REQUIRED_COLUMN)
        CASE_SCODE(MAPI_E_NETWORK_ERROR)
        CASE_SCODE(MAPI_E_NON_STANDARD)
        CASE_SCODE(MAPI_E_NOT_ENOUGH_DISK)
//        CASE_SCODE(MAPI_E_NOT_ENOUGH_MEMORY)
        CASE_SCODE(MAPI_E_NOT_ENOUGH_RESOURCES)
        CASE_SCODE(MAPI_E_NOT_FOUND)
        CASE_SCODE(MAPI_E_NOT_INITIALIZED)
        CASE_SCODE(MAPI_E_NOT_IN_QUEUE)
        CASE_SCODE(MAPI_E_NOT_ME)
//        CASE_SCODE(MAPI_E_NO_ACCESS)
        CASE_SCODE(MAPI_E_NO_RECIPIENTS)
//        CASE_SCODE(MAPI_E_NO_SUPPORT)
        CASE_SCODE(MAPI_E_NO_SUPPRESS)
        CASE_SCODE(MAPI_E_OBJECT_CHANGED)
        CASE_SCODE(MAPI_E_OBJECT_DELETED)
//        CASE_SCODE(MAPI_E_SESSION_LIMIT)
        CASE_SCODE(MAPI_E_STRING_TOO_LONG)
        CASE_SCODE(MAPI_E_SUBMITTED)
        CASE_SCODE(MAPI_E_TABLE_EMPTY)
        CASE_SCODE(MAPI_E_TABLE_TOO_BIG)
        CASE_SCODE(MAPI_E_TIMEOUT)
        CASE_SCODE(MAPI_E_TOO_BIG)
        CASE_SCODE(MAPI_E_TOO_COMPLEX)
        CASE_SCODE(MAPI_E_TYPE_NO_SUPPORT)
        CASE_SCODE(MAPI_E_UNABLE_TO_ABORT)
        CASE_SCODE(MAPI_E_UNABLE_TO_COMPLETE)
        CASE_SCODE(MAPI_E_UNCONFIGURED)
        CASE_SCODE(MAPI_E_UNEXPECTED_ID)
        CASE_SCODE(MAPI_E_UNEXPECTED_TYPE)
//        CASE_SCODE(MAPI_E_UNKNOWN_ENTRYID)
        CASE_SCODE(MAPI_E_UNKNOWN_FLAGS)
        CASE_SCODE(MAPI_E_USER_CANCEL)
//        CASE_SCODE(MAPI_E_VERSION)
        CASE_SCODE(MAPI_E_WAIT)
        CASE_SCODE(MAPI_W_APPROX_COUNT)
        CASE_SCODE(MAPI_W_CANCEL_MESSAGE)
        CASE_SCODE(MAPI_W_ERRORS_RETURNED)
        CASE_SCODE(MAPI_W_NO_SERVICE)
        CASE_SCODE(MAPI_W_PARTIAL_COMPLETION)
        CASE_SCODE(MAPI_W_POSITION_CHANGED)
        CASE_SCODE(MEM_E_INVALID_LINK)
        CASE_SCODE(MEM_E_INVALID_ROOT)
        CASE_SCODE(MEM_E_INVALID_SIZE)
        CASE_SCODE(MK_E_ENUMERATION_FAILED)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_NOPREFIX)
        CASE_SCODE(MK_E_NOSTORAGE)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(NTE_BAD_ALGID)
        CASE_SCODE(NTE_BAD_DATA)
        CASE_SCODE(NTE_BAD_FLAGS)
        CASE_SCODE(NTE_BAD_HASH)
        CASE_SCODE(NTE_BAD_HASH_STATE)
        CASE_SCODE(NTE_BAD_KEY)
        CASE_SCODE(NTE_BAD_KEYSET)
        CASE_SCODE(NTE_BAD_KEYSET_PARAM)
        CASE_SCODE(NTE_BAD_KEY_STATE)
        CASE_SCODE(NTE_BAD_LEN)
        CASE_SCODE(NTE_BAD_PROVIDER)
        CASE_SCODE(NTE_BAD_PROV_TYPE)
        CASE_SCODE(NTE_BAD_PUBLIC_KEY)
        CASE_SCODE(NTE_BAD_SIGNATURE)
        CASE_SCODE(NTE_BAD_TYPE)
        CASE_SCODE(NTE_BAD_UID)
        CASE_SCODE(NTE_BAD_VER)
        CASE_SCODE(NTE_DOUBLE_ENCRYPT)
        CASE_SCODE(NTE_EXISTS)
        CASE_SCODE(NTE_FAIL)
        CASE_SCODE(NTE_KEYSET_ENTRY_BAD)
        CASE_SCODE(NTE_KEYSET_NOT_DEF)
        CASE_SCODE(NTE_NOT_FOUND)
        CASE_SCODE(NTE_NO_KEY)
        CASE_SCODE(NTE_NO_MEMORY)
//        CASE_SCODE(NTE_OP_OK)                         // same as S_OK
        CASE_SCODE(NTE_PERM)
        CASE_SCODE(NTE_PROVIDER_DLL_FAIL)
        CASE_SCODE(NTE_PROV_DLL_NOT_FOUND)
        CASE_SCODE(NTE_PROV_TYPE_ENTRY_BAD)
        CASE_SCODE(NTE_PROV_TYPE_NOT_DEF)
        CASE_SCODE(NTE_PROV_TYPE_NO_MATCH)
        CASE_SCODE(NTE_SIGNATURE_FILE_BAD)
        CASE_SCODE(NTE_SYS_ERR)
        CASE_SCODE(OLECMDERR_E_CANCELED)
        CASE_SCODE2(OLECMDERR_E_DISABLED,DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE2(OLECMDERR_E_NOHELP,DRAGDROP_E_INVALIDHWND)
        CASE_SCODE2(OLECMDERR_E_NOTSUPPORTED,DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(OLECMDERR_E_UNKNOWNGROUP)
        CASE_SCODE(OLEOBJ_E_INVALIDVERB)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CANTCONVERT)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOSTORAGE)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOT_INPLACEACTIVE)
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_USEREG)
//        CASE_SCODE(PERPROP_E_NOPAGEAVAILABLE)         // same as CONNECT_E_NOCONNECTION
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(RPC_E_ACCESS_DENIED)
        CASE_SCODE(RPC_E_ATTEMPTED_MULTITHREAD)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CALL_COMPLETE)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CANTCALLOUT_AGAIN)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_ININPUTSYNCCALL)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CHANGED_MODE)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
        CASE_SCODE(RPC_E_DISCONNECTED)
        CASE_SCODE(RPC_E_FAULT)
        CASE_SCODE(RPC_E_INVALIDMETHOD)
        CASE_SCODE(RPC_E_INVALID_CALLDATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_INVALID_EXTENSION)
        CASE_SCODE(RPC_E_INVALID_HEADER)
        CASE_SCODE(RPC_E_INVALID_IPID)
        CASE_SCODE(RPC_E_INVALID_OBJECT)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_NOT_REGISTERED)
        CASE_SCODE(RPC_E_NO_GOOD_SECURITY_PACKAGES)
        CASE_SCODE(RPC_E_OUT_OF_RESOURCES)
        CASE_SCODE(RPC_E_REMOTE_DISABLED)
        CASE_SCODE(RPC_E_RETRY)
        CASE_SCODE(RPC_E_SERVERCALL_REJECTED)
        CASE_SCODE(RPC_E_SERVERCALL_RETRYLATER)
        CASE_SCODE(RPC_E_SERVERFAULT)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_DIED)
        CASE_SCODE(RPC_E_SERVER_DIED_DNE)
        CASE_SCODE(RPC_E_SYS_CALL_FAILED)
        CASE_SCODE(RPC_E_THREAD_NOT_INIT)
        CASE_SCODE(RPC_E_TOO_LATE)
        CASE_SCODE(RPC_E_UNEXPECTED)
        CASE_SCODE(RPC_E_UNSECURE_CALL)
        CASE_SCODE(RPC_E_VERSION_MISMATCH)
        CASE_SCODE(RPC_E_WRONG_THREAD)
        CASE_SCODE(RPC_S_CALLPENDING)
        CASE_SCODE(RPC_S_WAITONTIMER)
//        CASE_SCODE(SELFREG_E_CLASS)                   // same as CONNECT_E_ADVISELIMIT
//        CASE_SCODE(SELFREG_E_TYPELIB)                 // same as CONNECT_E_NOCONNECTION
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_BADBASEADDRESS)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_DOCFILECORRUPT)
        CASE_SCODE(STG_E_EXTANTMARSHALLINGS)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_INCOMPLETE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_NOTFILEBASEDSTORAGE)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_PROPSETMISMATCHED)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_SHAREREQUIRED)
        CASE_SCODE(STG_E_SHAREVIOLATION)
        CASE_SCODE(STG_E_TERMINATED)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_S_BLOCK)
        CASE_SCODE(STG_S_CONVERTED)
        CASE_SCODE(STG_S_MONITORING)
        CASE_SCODE(STG_S_RETRYNOW)
        CASE_SCODE(TRUST_E_ACTION_UNKNOWN)
        CASE_SCODE(TRUST_E_PROVIDER_UNKNOWN)
        CASE_SCODE(TRUST_E_SUBJECT_FORM_UNKNOWN)
        CASE_SCODE(TRUST_E_SUBJECT_NOT_TRUSTED)
        CASE_SCODE(TYPE_E_AMBIGUOUSNAME)
        CASE_SCODE(TYPE_E_BADMODULEKIND)
        CASE_SCODE(TYPE_E_BUFFERTOOSMALL)
        CASE_SCODE(TYPE_E_CANTCREATETMPFILE)
        CASE_SCODE(TYPE_E_CANTLOADLIBRARY)
        CASE_SCODE(TYPE_E_CIRCULARTYPE)
        CASE_SCODE(TYPE_E_DLLFUNCTIONNOTFOUND)
        CASE_SCODE(TYPE_E_DUPLICATEID)
        CASE_SCODE(TYPE_E_ELEMENTNOTFOUND)
        CASE_SCODE(TYPE_E_INCONSISTENTPROPFUNCS)
        CASE_SCODE(TYPE_E_INVALIDID)
        CASE_SCODE(TYPE_E_INVALIDSTATE)
        CASE_SCODE(TYPE_E_INVDATAREAD)
        CASE_SCODE(TYPE_E_IOERROR)
        CASE_SCODE(TYPE_E_LIBNOTREGISTERED)
        CASE_SCODE(TYPE_E_NAMECONFLICT)
        CASE_SCODE(TYPE_E_OUTOFBOUNDS)
        CASE_SCODE(TYPE_E_QUALIFIEDNAMEDISALLOWED)
        CASE_SCODE(TYPE_E_REGISTRYACCESS)
        CASE_SCODE(TYPE_E_SIZETOOBIG)
        CASE_SCODE(TYPE_E_TYPEMISMATCH)
        CASE_SCODE(TYPE_E_UNDEFINEDTYPE)
        CASE_SCODE(TYPE_E_UNKNOWNLCID)
        CASE_SCODE(TYPE_E_UNSUPFORMAT)
        CASE_SCODE(TYPE_E_WRONGTYPEKIND)
        CASE_SCODE(VIEW_E_DRAW)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)

        default:
            lpstr = _T("UNKNOWN SCODE");
    }

#undef CASE_SCODE
#undef CASE_SCODE2

    return lpstr;
}



//+---------------------------------------------------------------------------
//
//  Function:   hrvsnprintf
//
//  Synopsis:   Prints a string to a buffer, interpreting %hr as a
//              format string for an HRESULT.
//
//  Arguments:  [achBuf]    -- The buffer to print into.
//              [cchBuf]    -- The size of the buffer.
//              [pstrFmt]   -- The format string.
//              [valMarker] -- List of arguments to format string.
//
//  Returns:    Number of characters printed to the buffer not including
//              the terminating NULL.  In case of buffer overflow, returns
//              -1.
//
//  Modifies:   [achBuf]
//
//----------------------------------------------------------------------------

int
hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker)
{
    static char achFmtHR[] = "<%ls (0x%lx)>";
    static char achHRID[] = "%hr";

    char            achFmt[1024];
    int             cch;
    int             cchTotal;
    char *          lpstr;
    char *          lpstrLast;
    int             cFormat;
    HRESULT         hrVA;

    // We stomp on the string, so copy to writeable memory.

    strcpy(achFmt, pstrFmt);

    //
    // Scan for %hr tokens.  If found, print the corresponding
    // hresult into the buffer.
    //

    cch = 0;
    cchTotal = 0;
    cFormat = 0;
    lpstrLast = achFmt;
    lpstr = achFmt;
    while (*lpstr)
    {
        if (*lpstr != '%')
        {
            lpstr++;
        }
        else if (lpstr[1] == '%')
        {
            lpstr += 2;
        }
        else if (strncmp(lpstr, achHRID, ARRAY_SIZE(achHRID) - 1))
        {
            cFormat++;
            lpstr++;
        }
        else
        {
            //
            // Print format string up to the hresult.
            //

            * lpstr = 0;
            cch = _vsnprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    lpstrLast,
                    valMarker);
            * lpstr = '%';
            if (cch == -1)
                break;

            cchTotal += cch;

            //
            // Advance valMarker for each printed format.
            //

            while (cFormat-- > 0)
            {
                //
                // NOTE (adams): Won't work for floats, as their stack size
                // is not four bytes.
                //

                va_arg(valMarker, void *);
            }

            //
            // Print hresult into buffer.
            //

            hrVA = va_arg(valMarker, HRESULT);
            cch = _snprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    achFmtHR,
                    GetHResultName(hrVA),
                    hrVA);
            if (cch == -1)
                break;

            cchTotal += cch;
            lpstr += ARRAY_SIZE(achHRID) - 1;
            lpstrLast = lpstr;
        }
    }

    if (cch != -1)
    {
        cch = _vsnprintf(
                achBuf + cchTotal,
                cchBuf - cchTotal,
                lpstrLast,
                valMarker);
    }

    return (cch == -1) ? -1 : cchTotal + cch;
}


// This function uses ANSII strings so I use C RTL functions for string manipulation
// instead of the _t... fucntions
void WINAPI
DbgExOpenLogFile(LPCSTR szFName)
{
    char    rgch[MAX_PATH];

#ifdef _MAC
    DWORD dwCt = 0x74747874;  // 'ttxt'
    DWORD dwFtype = 0x54455854; // 'TEXT'
    DWORD dwOldct, dwOldftype;

    dwOldct = SetDefaultCreatorType(dwCt);
    dwOldftype = SetDefaultFileType(dwFtype);
#endif

    if(szFName == NULL || strlen(szFName) == 0)
    {
        // log file name or path is not specified, we must use the default ones
        if (g_hinstMain)
        {
            // Get program path and file name and replace the extension with the
            // log file extension
#ifndef _MAC
            UINT    cch = (UINT) GetModuleFileNameA(g_hModule, rgch, sizeof(rgch));
#ifdef UNIX
            strcat(rgch, szDbgOutFileExt);
#else
            Assert(rgch[cch - 4] == '.');
            strcpy(&rgch[cch - 4], szDbgOutFileExt);
#endif
#else
            CHAR   achAppLoc[MAX_PATH];
            DWORD   dwRet;
            short   iRet;

            dwRet = GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc));
            Assert (dwRet != 0);

            iRet = GetFileTitleA(achAppLoc,rgch,sizeof(rgch));
            Assert(iRet == 0);

            strcat (rgch, szDbgOutFileExt);
#endif
        }
        else
        {
            // Use the dewfault file name in default directory
            strcpy(rgch, szDbgOutFileName);
        }

    }
    else
    {

        // check, and if file name is not specified in the command line append the
        // default log file name to the specified path
        int nLen = strlen(szFName);

        strncpy(rgch, szFName, sizeof(rgch) / sizeof(rgch[0]) - 1);
        rgch[sizeof(rgch) / sizeof(rgch[0]) - 1] = 0;

        if(szFName[nLen - 1] == '\\')
        {
            strcat(rgch, szDbgOutFileName);
        }

    }

    s_hFileLog = CreateFileA(rgch, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
        0, (HANDLE) NULL);

    if (s_hFileLog != INVALID_HANDLE_VALUE)
    {
        wsprintfA(rgch, ">>>>> Start logging" SZ_NEWLINE);
        SetFilePointer(s_hFileLog, 0, NULL, FILE_END);
        SpitSzToDisk(rgch);
    }
    else
    {
        char msg[200];
        _snprintf(msg, sizeof(msg) / sizeof(msg[0]), "Cannot create the log file \"%s\"" SZ_NEWLINE, rgch);
        MessageBoxA(NULL, msg, "Error", MB_OK);
    }

#ifdef _MAC
        SetDefaultCreatorType(dwOldct);
        SetDefaultFileType(dwOldftype);
#endif
}

DWORD WINAPI
DbgExGetVersion()
{
    return(g_fDetached ? 0 : MSHTMDBG_API_VERSION);
}

BOOL WINAPI
DbgExIsFullDebug()
{
    return(TRUE);
}

BOOL WINAPI
DbgExGetChkStkFill(DWORD * pdwFill)
{
    *pdwFill = GetPrivateProfileIntA("chkstk", "fill", 0xCCCCCCCC, "mshtmdbg.ini");
    return(DbgExIsTagEnabled(tagStackSpew));
}

void WINAPI
DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
    int i;

    for (i = 0; i < ARRAY_SIZE(g_rgDllHandle); ++i)
    {
        if (pfnDllMain == NULL)
        {
            if (g_rgDllHandle[i] == hDllHandle)
            {
                g_rgDllHandle[i] = NULL;
                g_rgDllMain[i] = NULL;
                break;
            }
        }
        else
        {
            if (g_rgDllHandle[i] == NULL)
            {
                g_rgDllHandle[i] = hDllHandle;
                g_rgDllMain[i] = pfnDllMain;
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\allocspy.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       allocspy.cxx
//
//  Contents:   IMallocSpy implementation.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_VMEM_HXX_
#define X_VMEM_HXX_
#include "vmem.hxx"
#endif

#include "vmem.cxx"

static PERFMETERTAG g_mtSpy = 0;

class CMallocSpy : public IMallocSpy
{
public:

    CMallocSpy();

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IMallocSpy methods

    STDMETHOD_(SIZE_T, PreAlloc)(SIZE_T cbRequest);
    STDMETHOD_(void *, PostAlloc)(void *pvActual);
    STDMETHOD_(void *, PreFree)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(void,   PostFree)(BOOL fSpyed);
    STDMETHOD_(SIZE_T, PreRealloc)(void *pvRequest, SIZE_T cbRequest, void **ppvActual, BOOL fSpyed);
    STDMETHOD_(void *, PostRealloc)(void *pvActual, BOOL fSpyed);
    STDMETHOD_(void *, PreGetSize)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(SIZE_T, PostGetSize)(SIZE_T cbActual, BOOL fSpyed);
    STDMETHOD_(void *, PreDidAlloc)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(BOOL,   PostDidAlloc)(void *pvRequest, BOOL fSpyed, BOOL fActual);
    STDMETHOD_(void,   PreHeapMinimize)();
    STDMETHOD_(void,   PostHeapMinimize)();

    ULONG               _ulRef;
    BOOL                _fStrict;
    DWORD               _dwFlags;
    BOOL                _fMeter;
};

void EnterSpyAlloc()
{
    EnsureThreadState();
    DBGTHREADSTATE * pts = DbgGetThreadState();
    pts->fSpyAlloc += 1;
    pts->mtSpy = pts->mtSpyUser ? pts->mtSpyUser : g_mtSpy;
}

void LeaveSpyAlloc()
{
    TLS(fSpyAlloc) -= 1;
}

struct SPYBLK
{
    PERFMETERTAG mt;
};

size_t
SpyPreAlloc(size_t cbRequest)
{
    EnsureThreadState();
    TLS(cbRequest) = cbRequest;
    return sizeof(SPYBLK);
}

void *
SpyPostAlloc(void * pvActual, DWORD dwFlags)
{
    EnsureThreadState();
    SPYBLK * psb = (SPYBLK *)pvActual;
    size_t cbRequest = TLS(cbRequest);
    void * pvRequest;

    if (!psb)
        return NULL;

    pvRequest = VMemAlloc(cbRequest, dwFlags, psb);

    if (pvRequest)
    {
        psb->mt = TLS(mtSpy);
        DbgExMtAdd(psb->mt, 1, cbRequest);
    }

    return(pvRequest);
}

void *
SpyPreFree(void * pvRequest)
{
    if (!pvRequest)
        return NULL;

    VMEMINFO * pvmi = VMemIsValid(pvRequest);
    SPYBLK * psb = NULL;

    AssertSz(pvmi, "SpyPreFree - can't find supposedly allocated block");

    if (pvmi)
    {
        psb = (SPYBLK *)pvmi->pvUser;
        DbgExMtAdd(psb->mt, -1, -(LONG_PTR)pvmi->cb);
        VMemFree(pvRequest);
    }

    return(psb);
}

void
SpyPostFree(void)
{
}

size_t
SpyPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    EnsureThreadState();
    size_t          cb;
    DBGTHREADSTATE *pts  = DbgGetThreadState();

    pts->cbRequest = cbRequest;
    pts->pvRequest = pvRequest;

    if (pvRequest == NULL)
    {
        *ppv = NULL;
        cb = sizeof(SPYBLK);
    }
    else if (cbRequest == 0)
    {
        *ppv = SpyPreFree(pvRequest);
        cb = 0;
    }
    else
    {
        VMEMINFO * pvmi = VMemIsValid(pvRequest);

        if (pvmi)
        {
            *ppv = pvmi->pvUser;
            cb = sizeof(SPYBLK);
        }
        else    // Something very, very wrong. just don't crash.
        {
            AssertSz(pvmi, "SpyPreRealloc - can't find supposedly allocated block");
            cb = 0;
        }
    }

    return cb;
}

void *
SpyPostRealloc(void * pvActual, DWORD dwFlags)
{
    EnsureThreadState();
    DBGTHREADSTATE *pts         = DbgGetThreadState();
    void *          pvRequest   = pts->pvRequest;
    size_t          cbRequest   = pts->cbRequest;
    void *          pvReturn    = NULL;

    if (pvRequest == NULL)
    {
        pvReturn = SpyPostAlloc(pvActual, dwFlags);
    }
    else if (pts->cbRequest == 0)
    {
        Assert(pvActual == NULL);
        pvReturn = NULL;
    }
    else if (pvActual)
    {
        VMEMINFO *  pvmi = VMemIsValid(pvRequest);
        LONG        lVal = cbRequest - pvmi->cb;
        SPYBLK *    psb  = (SPYBLK *)pvActual;

        if (VMemRealloc(&pvRequest, cbRequest, dwFlags, psb) == S_OK)
        {
            DbgExMtAdd(psb->mt, 0, lVal);
            pvReturn = pvRequest;
        }
    }

    return pvReturn;
}

void *
SpyPreGetSize(void *pvRequest)
{
    EnsureThreadState();
    TLS(pvRequest) = pvRequest;
    VMEMINFO * pvmi = VMemIsValid(pvRequest);
    return pvmi ? pvmi->pvUser : NULL;
}

size_t
SpyPostGetSize(size_t cb)
{
    EnsureThreadState();
    DBGTHREADSTATE * pts = DbgGetThreadState();
    return pts->pvRequest ? VMemIsValid(pts->pvRequest)->cb : 0;
}

void *
SpyPreDidAlloc(void *pvRequest)
{
    return(VMemIsValid(pvRequest));
}

BOOL
SpyPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

struct MTRBLK
{
    LONG            cb;
    PERFMETERTAG    mt;
};

size_t
MtrPreAlloc(size_t cbRequest)
{
    EnsureThreadState();
    TLS(cbRequest) = cbRequest;
    return(sizeof(MTRBLK) + cbRequest);
}

void *
MtrPostAlloc(void * pvActual)
{
    EnsureThreadState();
    MTRBLK * pmb = (MTRBLK *)pvActual;

    if (!pmb)
        return NULL;

    pmb->cb = TLS(cbRequest);
    pmb->mt = TLS(mtSpy);

    DbgExMtAdd(pmb->mt, 1, pmb->cb);

    return(pmb + 1);
}

void *
MtrPreFree(void * pvRequest)
{
    if (!pvRequest)
        return NULL;

    MTRBLK * pmb = (MTRBLK *)pvRequest - 1;

    DbgExMtAdd(pmb->mt, -1, -(LONG_PTR)pmb->cb);

    return(pmb);
}

void
MtrPostFree(void)
{
}

size_t
MtrPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    EnsureThreadState();
    size_t          cb;
    DBGTHREADSTATE *pts = DbgGetThreadState();

    pts->cbRequest = cbRequest;
    pts->pvRequest = pvRequest;

    if (pvRequest == NULL)
    {
        *ppv = NULL;
        cb   = sizeof(MTRBLK) + cbRequest;
    }
    else if (cbRequest == 0)
    {
        *ppv = MtrPreFree(pvRequest);
        cb   = 0;
    }
    else
    {
        *ppv = (MTRBLK *)pvRequest - 1;
        cb   = sizeof(MTRBLK) + cbRequest;
    }

    return cb;
}

void *
MtrPostRealloc(void * pvActual)
{
    EnsureThreadState();
    void *          pvReturn;
    DBGTHREADSTATE *pts = DbgGetThreadState();
    MTRBLK *        pmb = pvActual ? (MTRBLK *)pvActual : NULL;

    if (pts->pvRequest == NULL)
    {
        pvReturn = MtrPostAlloc(pvActual);
    }
    else if (pts->cbRequest == 0)
    {
        Assert(pvActual == NULL);
        pvReturn = NULL;
    }
    else
    {
        if (pvActual == NULL)
        {
            pvReturn = NULL;
        }
        else
        {
            DbgExMtAdd(pmb->mt, 0, (pts->cbRequest - pmb->cb));

            pmb->cb = pts->cbRequest;

            pvReturn = pmb + 1;
        }
    }

    return pvReturn;
}

void *
MtrPreGetSize(void *pvRequest)
{
    return pvRequest ? (MTRBLK *)pvRequest - 1 : NULL;
}

size_t
MtrPostGetSize(size_t cb)
{
    return(cb ? cb - sizeof(MTRBLK) : 0);
}

void *
MtrPreDidAlloc(void *pvRequest)
{
    return(pvRequest ? (MTRBLK *)pvRequest - 1 : NULL);
}

BOOL
MtrPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

inline
CMallocSpy::CMallocSpy()
{
    _ulRef = 0;
}


STDMETHODIMP
CMallocSpy::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IMallocSpy)
    {
        *ppv = (IMallocSpy *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CMallocSpy::AddRef()
{
    return InterlockedIncrement((LONG *)&_ulRef);
}

STDMETHODIMP_(ULONG)
CMallocSpy::Release()
{
    return InterlockedDecrement((LONG *)&_ulRef);
}

STDMETHODIMP_(SIZE_T)
CMallocSpy::PreAlloc(SIZE_T cbRequest)
{
    ULONG ul;

    EnterSpyAlloc();

    if (_fStrict)
        ul = SpyPreAlloc(cbRequest);
    else if (_fMeter)
        ul = MtrPreAlloc(cbRequest);
    else
        ul = DbgExPreAlloc(cbRequest);

    LeaveSpyAlloc();

    return ul;
}

STDMETHODIMP_(void *)
CMallocSpy::PostAlloc(void *pvActual)
{
    void * pv;

    EnterSpyAlloc();

    if (_fStrict)
        pv = SpyPostAlloc(pvActual, _dwFlags);
    else if (_fMeter)
        pv = MtrPostAlloc(pvActual);
    else
        pv = DbgExPostAlloc(pvActual);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(void *)
CMallocSpy::PreFree(void *pvRequest, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvRequest;
    else if (_fStrict)
        pv = SpyPreFree(pvRequest);
    else if (_fMeter)
        pv = MtrPreFree(pvRequest);
    else
        pv = DbgExPreFree(pvRequest);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(void)
CMallocSpy::PostFree(BOOL fSpyed)
{
    EnterSpyAlloc();

    if (fSpyed)
    {
        if (_fStrict)
            SpyPostFree();
        else if (_fMeter)
            MtrPostFree();
        else
            DbgExPostFree();
    }

    LeaveSpyAlloc();
}

STDMETHODIMP_(SIZE_T)
CMallocSpy::PreRealloc(
    void *pvRequest,
    SIZE_T cbRequest,
    void **ppvActual,
    BOOL fSpyed)
{
    SIZE_T cb;

    EnterSpyAlloc();

    if (!fSpyed)
    {
        *ppvActual = pvRequest;
        cb = cbRequest;
    }
    else if (_fStrict)
        cb = SpyPreRealloc(pvRequest, cbRequest, ppvActual);
    else if (_fMeter)
        cb = MtrPreRealloc(pvRequest, cbRequest, ppvActual);
    else
        cb = DbgExPreRealloc(pvRequest, cbRequest, ppvActual);

    LeaveSpyAlloc();

    return cb;
}

STDMETHODIMP_(void *)
CMallocSpy::PostRealloc(void *pvActual, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvActual;
    else if (_fStrict)
        pv = SpyPostRealloc(pvActual, _dwFlags);
    else if (_fMeter)
        pv = MtrPostRealloc(pvActual);
    else
        pv = DbgExPostRealloc(pvActual);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(void *)
CMallocSpy::PreGetSize(void *pvRequest, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvRequest;
    else if (_fStrict)
        pv = SpyPreGetSize(pvRequest);
    else if (_fMeter)
        pv = MtrPreGetSize(pvRequest);
    else
        pv = DbgExPreGetSize(pvRequest);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(SIZE_T)
CMallocSpy::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
    SIZE_T cb;

    EnterSpyAlloc();

    if (!fSpyed)
        cb = cbActual;
    else if (_fStrict)
        cb = SpyPostGetSize(cbActual);
    else if (_fMeter)
        cb = MtrPostGetSize(cbActual);
    else
        cb = DbgExPostGetSize(cbActual);

    LeaveSpyAlloc();

    return cb;
}

STDMETHODIMP_(void *)
CMallocSpy::PreDidAlloc(void *pvRequest, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvRequest;
    else if (_fStrict)
        pv = SpyPreDidAlloc(pvRequest);
    else if (_fMeter)
        pv = MtrPreDidAlloc(pvRequest);
    else
        pv = DbgExPreDidAlloc(pvRequest);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(BOOL)
CMallocSpy::PostDidAlloc(void *pvRequest, BOOL fSpyed, BOOL fActual)
{
    BOOL f;

    EnterSpyAlloc();

    if (!fSpyed)
        f = fActual;
    else if (_fStrict)
        f = SpyPostDidAlloc(pvRequest, fActual);
    else if (_fMeter)
        f = MtrPostDidAlloc(pvRequest, fActual);
    else
        f = DbgExPostDidAlloc(pvRequest, fActual);

    LeaveSpyAlloc();

    return f;
}

STDMETHODIMP_(void)
CMallocSpy::PreHeapMinimize()
{
}

STDMETHODIMP_(void)
CMallocSpy::PostHeapMinimize()
{
}

static CMallocSpy sSpy;


void * WINAPI
DbgExGetMallocSpy()
{
    EnsureThreadState();
#ifdef PERFMETER
    if (g_mtSpy == 0)
        g_mtSpy = DbgExMtRegister("mtCoTaskMem", "mtWorkingSet", "CoTaskMemAlloc");
#endif
#if defined(RETAILBUILD) && defined(PERFTAGS) && !defined(PERFMETER)
    static int g_tgCoMemoryStrict = DbgExPerfRegister("tgCoMemoryStrict", "!Memory", "Use VMem for CoTaskMemAlloc");
    sSpy._fStrict = IsPerfEnabled(g_tgCoMemoryStrict);
    sSpy._dwFlags = (GetPrivateProfileIntA("perftags", "tgMemoryStrictHead", FALSE, "mshtmdbg.ini") ? 0 : VMEM_BACKSIDESTRICT) |
                    (GetPrivateProfileIntA("perftags", "tgMemoryStrictAlign", FALSE, "mshtmdbg.ini") ? VMEM_BACKSIDEALIGN8 : 0);
#else
    sSpy._fStrict = DbgExIsTagEnabled(tagCoMemoryStrict);
    sSpy._dwFlags = (DbgExIsTagEnabled(tagMemoryStrictTail) ? VMEM_BACKSIDESTRICT : 0) |
                    (DbgExIsTagEnabled(tagMemoryStrictAlign) ? VMEM_BACKSIDEALIGN8 : 0);
#endif
#if defined(RETAILBUILD) && defined(PERFMETER)
    sSpy._fMeter = !sSpy._fStrict;
#else
    sSpy._fMeter = FALSE;
#endif

    return((IMallocSpy *)&sSpy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\dbgstk.cxx ===
#error "@@@ This file is nuked"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\dbglite\dbglite.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       dbglite.c
//
//  Contents:   functions for debug lite version of mshtml.dll
//
//----------------------------------------------------------------------------

#if DBG == 1

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef tagError
#undef tagError
#endif

#ifdef tagAssertExit
#undef tagAssertExit
#endif

#define tagNull     ((TAG) 0)

//
//  Global variables
//
TAG     tagDefault                  = TRUE;
TAG     tagError                    = TRUE;
TAG     tagWarn_                    = FALSE;
TAG     tagAssertExit               = FALSE;
TAG     tagThrd_                    = FALSE;
TAG     tagMemoryStrict_            = FALSE;
TAG     tagMemoryStrictTail_        = FALSE;
TAG     tagMemoryStrictAlign_       = FALSE;
TAG     tagOLEWatchvar_             = FALSE;
TAG     tagPerf_                    = FALSE;

BOOL    g_fBreakOnAssert            = TRUE;


//+------------------------------------------------------------------------
//
//  Function:   AssertImpl
//
//  Synopsis:   Function called for all asserts.  Outputs szMessage to
//              standart output
//
//  Arguments:
//              szFile
//              iLine
//              szMessage
//
//-------------------------------------------------------------------------

BOOL
AssertImpl(char const * szFile, int iLine, char const * szMessage)
{
    OutputDebugStringA("MSHTML: ");
    OutputDebugStringA(szMessage);
    OutputDebugStringA("\n");
    return g_fBreakOnAssert;
}


BOOL
IsFullDebug(void)
{
    return FALSE;
}

void AssertThreadDisable(BOOL fDisable)
{
}

void TaggedTraceCallers(TAG tag, int iStart, int cTotal)
{
}

TAG FindTag(char * szTagDesc)
{
    return 0;
}

size_t DbgPreAlloc(size_t cbRequest)
{
    return cbRequest;
}


void * DbgPostAlloc(void *pv)
{
    return pv;
}

void * DbgPreFree(void *pv)
{
    return pv;
}

void DbgPostFree(void)
{
}

size_t DbgPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    *ppv = pvRequest;
    return cbRequest;
}

void * DbgPostRealloc(void *pv)
{
    return pv;
}

void * DbgPreGetSize(void *pvRequest)
{
    return pvRequest;
}

size_t DbgPostGetSize(size_t cb)
{
    return cb;
}

void * DbgPreDidAlloc(void *pvRequest)
{
    return pvRequest;
}

BOOL DbgPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

void DbgRegisterMallocSpy(void)
{
}

void DbgRevokeMallocSpy(void)
{
}

void DbgMemoryTrackDisable(BOOL fDisable)
{
}

void DbgMemoryBlockTrackDisable(void * pv)
{
}

void TraceMemoryLeaks()
{
}

BOOL ValidateInternalHeap()
{
    return TRUE;
}

int GetTotalAllocated(void)
{
    return 0;
}

void DbgDumpProcessHeaps()
{
}

void * __cdecl DbgMemSetName(void *pvRequest, char * szFmt, ...)
{
    return pvRequest;
}

char * DbgMemGetName(void *pvRequest)
{
    return NULL;
}

void
DbgSetTopUrl(LPWSTR pstrUrl)
{
}

void SetSimFailCounts(int firstFailure, int cInterval)
{
}

void ShowSimFailDlg(void)
{
}

TAG TagError( void )
{
    return tagError;
}

TAG TagAssertExit( void )
{
    return tagAssertExit;
}

TAG TagWarning( void )
{
    return tagWarn_;
}

TAG TagThread( void )
{
    return tagThrd_;
}

TAG TagMemoryStrict( void )
{
    return tagMemoryStrict_;
}

TAG TagMemoryStrictTail( void )
{
    return tagMemoryStrictTail_;
}

TAG TagMemoryStrictAlign( void )
{
    return tagMemoryStrictAlign_;
}

TAG TagOLEWatch( void )
{
    return tagOLEWatchvar_;
}

TAG TagPerf( void )
{
    return tagPerf_;
}

BOOL IsTagEnabled(TAG tag)
{
    return  tag;
}

BOOL SetDiskFlag (TAG tag, BOOL fSendToDisk)
{
    return FALSE;
}

BOOL SetBreakFlag (TAG tag, BOOL fBreak)
{
    return FALSE;
}

BOOL EnableTag( TAG tag, BOOL fEnable )
{
    return FALSE;
}

#undef TraceEnter
void TraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

void TraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

BOOL __cdecl TaggedTrace(TAG tag, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl TaggedTraceEx(TAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL EXPORT WINAPI TaggedTraceListEx(TAG tag,
                                     USHORT usFlags,
                                     CHAR * szFmt,
                                     va_list valMarker)
{
    int         cch;
    CHAR        achBuf[4096];

    if (tag)
    {
        cch = wsprintfA(
                achBuf,
                szFmt,
                valMarker);

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");
    }

    return FALSE;
}

TAG TagRegisterTrace( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    return tagNull;
}

TAG TagRegisterOther( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    return tagNull;
}

void DbgTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv)
{
}

void DoTracePointsDialog( BOOL fWait )
{
}

void RestoreDefaultDebugState( void )
{
}

int GetFailCount( )
{
    return INT_MIN;
}

extern "C" long TraceFailL(long errExpr,
                           long errTest,
                           BOOL fIgnore,
                           LPSTR pstrExpr,
                           LPSTR pstrFile,
                           int line)
{
    return errExpr;
}

extern "C" long TraceWin32L(long errExpr,
                            long errTest,
                            BOOL fIgnore,
                            LPSTR pstrExpr,
                            LPSTR pstrFile,
                            int line)
{
    return errExpr;
}

extern "C" HRESULT TraceHR(HRESULT hrTest,
                           BOOL fIgnore,
                           LPSTR pstrExpr,
                           LPSTR pstrFile,
                           int line)
{
    return hrTest;
}

extern "C" HRESULT TraceOLE(HRESULT hrTest,
                            BOOL fIgnore,
                            LPSTR pstrExpr,
                            LPSTR pstrFile,
                            int line,
                            LPVOID lpsite)
{
    return hrTest;
}

HRESULT EXPORT CDECL CheckAndReturnResult(HRESULT hr,
                                        BOOL    fTrace,
                                        LPSTR   pstrFile,
                                        UINT    line,
                                        int     cHResult,
                                        ...)
{
    return hr;
}

void OpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize)
{
}

void OpenMemoryMonitor()
{
}

void OpenLogFile(LPCSTR szFName)
{
}

HRESULT WsClear(HANDLE hProcess)
{
    return S_OK;
}

HRESULT WsTakeSnapshot(HANDLE hProcess)
{
    return S_OK;
}

BSTR WsGetModule(long row)
{
    return NULL;
}

BSTR WsGetSection(long row)
{
    return NULL;
}

long WsSize(long row)
{
    return 0;
}

long WsCount()
{
    return 0;
}

long WsTotal()
{
    return 0;
}

HRESULT WsStartDelta(HANDLE hProcess)
{
    return S_OK;
}

long WsEndDelta(HANDLE hProcess)
{
    return -1;
}

void WINAPI InitStackSpew(BOOL * pfEnabled, DWORD * pdwSpew)
{
    Assert( pfEnabled && pdwSpew );
    pfEnabled = FALSE;
}

#endif  //  DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\debugui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:       debugui.cxx
//
//  Contents:   User interface for trace tags dialog
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

// private typedefs
typedef int TMC;

// private function prototypes
VOID    EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty);
WORD    TagFromSelection(HWND hwndDlg, TMC tmc);
INT_PTR CALLBACK DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam);

//  Debug UI Globals
//
void    SetRGBValues(void);

extern DWORD       rgbWindowColor;
extern DWORD       rgbHiliteColor;
extern DWORD       rgbWindowText;
extern DWORD       rgbHiliteText;
extern DWORD       rgbGrayText;
extern DWORD       rgbDDWindow;
extern DWORD       rgbDDHilite;

HBITMAP g_hbmpCheck = NULL;
HDC     g_hdcCheck  = NULL;

#define TAG_STRBUF_SIZE  80

//
//  Identifies the type of TAG with which the current modal dialog is
//  dealing.
//

//+-------------------------------------------------------------------------
//
//  Function:   TraceTagDlgThread
//
//  Synopsis:   Thread entry point for trace tag dialog.  Keeps caller
//              of DbgExDoTracePointsDialog from blocking.
//
//--------------------------------------------------------------------------

DWORD
TraceTagDlgThread(void * pv)
{
    int     r;

    EnsureThreadState();

    r = DialogBoxA(g_hinstMain, "TRCAST", NULL, DlgTraceEtc);
    if (r == -1)
    {
        MessageBoxA(NULL, "Couldn't create trace tag dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD) r;
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgExDoTracePointsDialog
//
//  Synopsis:   Brings up and processes trace points dialog.  Any changes
//              made by the user are copied to the current debug state.
//
//  Arguments:  [fWait] -- If TRUE, this function will not return until the
//                         dialog has been closed.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExDoTracePointsDialog( BOOL fWait )
{
    THREAD_HANDLE          hThread = NULL;
#ifndef _MAC
    DWORD           idThread;
#endif

    EnsureThreadState();

    if (fWait)
    {
        TraceTagDlgThread(NULL);
    }
    else
    {
#ifndef _MAC
        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) TraceTagDlgThread, NULL, 0, &idThread);
#else
#pragma message("   DEBUGUI.cxx CreateThread")
Assert (0 && "  DEBUGUI.cxx CreateThread");
#endif
        if (hThread == NULL)
        {
            MessageBoxA(NULL,
                       "Couldn't create trace tag dialog thread",
                       "Error",
                       MB_OK | MB_ICONSTOP);
        }
#ifndef _MAC
        else
        {
            CloseThread(hThread);
        }
#endif
    }
}


/*
 *    FFillDebugListbox
 *
 *    Purpose:
 *        Initializes Windows debug listboxes by adding the correct strings
 *        to the listbox for the current dialog type.  This is only called
 *        once in the Windows interface when the dialog is initialized.
 *
 *    Parameters:
 *        hwndDlg    Handle to parent dialog box.
 *
 *    Returns:
 *        TRUE    if function is successful, FALSE otherwise.
 */
BOOL CALLBACK
FFillDebugListbox(HWND hwndDlg)
{
    TRACETAG tag;
    LRESULT  lresult;
    TGRC *   ptgrc;
    HWND     hwndListbox;

    // Get the listbox handle
    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    // Make sure it's clean
    SendMessageA(hwndListbox, CB_RESETCONTENT, 0, 0);

    // Enter tags into the listbox
    for (tag = tagMin; tag < tagMac; tag++)
    {
        // If tag is of correct type, enter the string for it.
        if (mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc = mptagtgrc + tag;

            lresult = SendMessageA(hwndListbox, CB_ADDSTRING, 0, tag);

            if (lresult == CB_ERR || lresult == CB_ERRSPACE)
                return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   TextFromTag
//
//  Synopsis:   Returns the string that should be displayed in the dialog
//              for a given tag.
//
//----------------------------------------------------------------------------

void
TextFromTag(TGRC *ptgrc, char *psz, int cch)
{
    _snprintf(psz, cch, "%-17.17s  %s", ptgrc->szOwner, ptgrc->szDescrip);
}

//+---------------------------------------------------------------------------
//
//  Function:   DrawTraceItem
//
//  Synopsis:   Draws a list item in the combobox.
//
//----------------------------------------------------------------------------

VOID
DrawTraceItem(LPDRAWITEMSTRUCT pdis)
{
    TGRC *    ptgrc;
    COLORREF  crText = 0, crBack = 0;
    char      achBuf[TAG_STRBUF_SIZE];
    int       size;
    BOOL      fSelected = (pdis->itemState & ODS_SELECTED) != 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if (fSelected)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        ptgrc = mptagtgrc + pdis->itemData;

        TextFromTag(ptgrc, achBuf, sizeof(achBuf));

        size = pdis->rcItem.bottom - pdis->rcItem.top - 1;

        ExtTextOutA(pdis->hDC,
                    pdis->rcItem.left + size,
                    pdis->rcItem.top+1,
                    ETO_OPAQUE|ETO_CLIPPED,
                    &pdis->rcItem,
                    achBuf,
                    lstrlenA(achBuf),
                    NULL);

        if (ptgrc->fEnabled)
        {
            BitBlt(pdis->hDC,
                   pdis->rcItem.left,
                   pdis->rcItem.top+1,
                   size,
                   size,
                   g_hdcCheck,
                   0,
                   0,
                   SRCCOPY);
        }

        // Restore original colors if we changed them above.
        if(fSelected)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}

//+---------------------------------------------------------------------------
//
//  Function:   CompareTraceItem
//
//  Synopsis:   Compare two items in the listbox for sorting.
//
//----------------------------------------------------------------------------

BOOL
CompareTraceItem(LPCOMPAREITEMSTRUCT pcis)
{
    int    retVal = 0;
    TGRC * ptgrc1 = NULL;
    TGRC * ptgrc2 = NULL;
    char * psz1, *psz2;
    char   achBuf[TAG_STRBUF_SIZE];
    int    cch = -1;

    if (pcis->itemID1 != -1)
    {
        Assert((TRACETAG)pcis->itemData1 > tagNull && (TRACETAG)pcis->itemData1 <= tagMac);

        ptgrc1 = mptagtgrc + pcis->itemData1;
        psz1   = ptgrc1->szOwner;
    }
    else
    {
        //
        // This is used when the user types into the textbox.
        //
        GetWindowTextA(pcis->hwndItem, achBuf, sizeof(achBuf));

        psz1 = achBuf;

        cch = lstrlenA(psz1);
    }

    if ((TRACETAG)pcis->itemData2 > tagNull && (TRACETAG)pcis->itemData2 <= tagMac)
    {
        ptgrc2 = mptagtgrc + pcis->itemData2;
        psz2   = ptgrc2->szOwner;
    }
    else
    {
        psz2 = ""; // Shouldn't get here - just don't crash if we do.
    }

    if (   ptgrc1
        && ptgrc2
        && ptgrc1->TestFlag(TGRC_FLAG_SORTFIRST) !=
           ptgrc2->TestFlag(TGRC_FLAG_SORTFIRST))
    {
        retVal = ptgrc1->TestFlag(TGRC_FLAG_SORTFIRST) ? -1 : 1;
    }
    else
    {
        retVal = CompareStringA(LOCALE_USER_DEFAULT,
                                NORM_IGNORECASE,
                                psz1, cch,
                                psz2, cch) - 2;

        if (retVal == 0 && ptgrc1 && ptgrc2)
        {
            retVal = CompareStringA(LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    ptgrc1->szDescrip, -1,
                                    ptgrc2->szDescrip, -1) - 2;

        }
    }

    return (BOOL)retVal;
}

/*
 *    FDlgTraceEtc
 *
 *    Purpose:
 *        Dialog procedure for Trace Points and Asserts dialogs.
 *        Keeps the state of the checkboxes identical to
 *        the state of the currently selected TAG in the listbox.
 *
 *    Parameters:
 *        hwndDlg    Handle to dialog window
 *        wm        SDM dialog message
 *        wparam
 *        lparam    Long parameter
 *
 *    Returns:
 *        TRUE if the function processed this message, FALSE if not.
 */
INT_PTR CALLBACK
DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam)
{
    DBGTHREADSTATE *   pts = DbgGetThreadState();
    TRACETAG        tag;
    TGRC *          ptgrc;
    DWORD           wNew;
    BOOL            fEnable;        // enable all
    TGRC_FLAG       tf;
    BOOL            fTrace;
    HWND            hwndListBox;
    BOOL            fInvalidate = FALSE;

    switch (wm)
    {
    default:
        return FALSE;
        break;

    case WM_INITDIALOG:
        pts->fDirtyDlg = FALSE;

        if (!FFillDebugListbox(hwndDlg))
        {
            MessageBoxA(hwndDlg,
                "Error initializing listbox. Cannot display dialog.",
                "Trace/Assert Dialog", MB_OK);
            EndButton(hwndDlg, 0, FALSE);
            break;
        }

        hwndListBox = GetDlgItem(hwndDlg, tmcListbox);
        Assert(hwndListBox);
        SetRGBValues();
        SendMessageA(hwndListBox, CB_SETCURSEL, 0, 0);
        SendMessageA(
                hwndDlg,
                WM_COMMAND,
                GET_WM_COMMAND_MPS(tmcListbox, hwndListBox, CBN_SELCHANGE));


        SetForegroundWindow(hwndDlg);

        if (!g_hdcCheck)
        {
            HDC hdc = GetDC(NULL);
            g_hdcCheck = CreateCompatibleDC(hdc);
            ReleaseDC(NULL, hdc);
        }

        if (!g_hbmpCheck)
        {
            Assert(g_hdcCheck);

            g_hbmpCheck = (HBITMAP)LoadImageA(NULL,
                                              (LPCSTR)OBM_CHECK,
                                              IMAGE_BITMAP,
                                              0, 0,
                                              LR_LOADTRANSPARENT);

            SelectObject(g_hdcCheck, g_hbmpCheck);
        }

        break;

    case WM_SYSCOLORCHANGE:
        SetRGBValues();
        InvalidateRect(hwndDlg, NULL, FALSE);
        break;

    case WM_DRAWITEM:
        if (GET_WM_COMMAND_ID(wparam, lparam) == tmcListbox)
        {
            DrawTraceItem((DRAWITEMSTRUCT*)lparam);
        }
        return TRUE;

    case WM_COMPAREITEM:
        if (GET_WM_COMMAND_ID(wparam, lparam) == tmcListbox)
        {
            return CompareTraceItem((COMPAREITEMSTRUCT*)lparam);
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wparam, lparam))
        {
        case tmcOk:
        case tmcCancel:
            EndButton(hwndDlg, GET_WM_COMMAND_ID(wparam, lparam), pts->fDirtyDlg);
            break;

        case tmcEnableAll:
        case tmcDisableAll:
            pts->fDirtyDlg = TRUE;

            fEnable = FALSE;
            if (GET_WM_COMMAND_ID(wparam, lparam) == tmcEnableAll)
                fEnable = TRUE;

            for (tag = tagMin; tag < tagMac; tag++)
            {
                    mptagtgrc[tag].fEnabled = fEnable;
            }

            tag = TagFromSelection(hwndDlg, tmcListbox);

            CheckDlgButton(hwndDlg, tmcEnabled, fEnable);

            fInvalidate = TRUE;

            break;

        case tmcListbox:
            // Need to check for CBN_EDITCHANGE also, because this seems to cause
            // the selection in listbox to change - especially when it is made empty.
            if (GET_WM_COMMAND_CMD(wparam, lparam) == CBN_EDITCHANGE)
            {
                // Post the message because the selection change seems to be delayed
                PostMessageA(
                    hwndDlg,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(tmcListbox,
                            GetDlgItem(hwndDlg, tmcListbox),
                            CBN_SELCHANGE));
                break;
            }

            if (GET_WM_COMMAND_CMD(wparam, lparam) != CBN_SELCHANGE
                && GET_WM_COMMAND_CMD(wparam, lparam) != CBN_DBLCLK)
                break;

            tag = TagFromSelection(hwndDlg, tmcListbox);

            if (tag == tagNull) // possible if the editbox is empty
            {
                // disable all checkboxes
                EnableWindow(GetDlgItem(hwndDlg, tmcEnabled),  FALSE);
                EnableWindow(GetDlgItem(hwndDlg, tmcDisk),  FALSE);
                EnableWindow(GetDlgItem(hwndDlg, tmcBreak), FALSE);
                break;
            }

            // re-enable it always just in case we disabled it previously
            EnableWindow(GetDlgItem(hwndDlg, tmcEnabled),  TRUE);

            ptgrc = mptagtgrc + tag;

            {
                char achBuf[TAG_STRBUF_SIZE];

                TextFromTag(ptgrc, achBuf, sizeof(achBuf));

                SetWindowTextA(GetDlgItem(hwndDlg, tmcListbox), achBuf);
            }

            if (GET_WM_COMMAND_CMD(wparam, lparam) == CBN_DBLCLK)
            {
                ptgrc->fEnabled = !ptgrc->fEnabled;
                pts->fDirtyDlg = TRUE;
                fInvalidate = TRUE;
            }

            CheckDlgButton(hwndDlg, tmcEnabled, ptgrc->fEnabled);
            CheckDlgButton(hwndDlg, tmcDisk, ptgrc->TestFlag(TGRC_FLAG_DISK));
            CheckDlgButton(hwndDlg, tmcBreak, ptgrc->TestFlag(TGRC_FLAG_BREAK));
            fTrace = (ptgrc->tgty == tgtyTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcDisk),  fTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcBreak), fTrace);
            break;

        case tmcEnabled:
        case tmcDisk:
        case tmcBreak:
            pts->fDirtyDlg = TRUE;
            fInvalidate = TRUE;

            tag = TagFromSelection(hwndDlg, tmcListbox);
            ptgrc = mptagtgrc + tag;

            wNew = IsDlgButtonChecked(hwndDlg, GET_WM_COMMAND_ID(wparam, lparam));

            if (GET_WM_COMMAND_ID(wparam, lparam) == tmcEnabled)
            {
                ptgrc->fEnabled = wNew;
            }
            else
            {
                switch (GET_WM_COMMAND_ID(wparam, lparam))
                {
            case tmcDisk:
                    tf = TGRC_FLAG_DISK;
                break;

                case tmcBreak:
                    tf = TGRC_FLAG_BREAK;
                    break;

                default:
                    Assert(0 && "Logic error in DlgTraceEtc");
                    tf = (TGRC_FLAG) 0;
                break;
                }

                ptgrc->SetFlagValue(tf, wNew);
            }
        }

        if (fInvalidate)
        {
            InvalidateRect(GetDlgItem(hwndDlg, tmcListbox), NULL, FALSE);
        }

        break;
    }

    return TRUE;
}


/*
 *    EndButton
 *
 *    Purpose:
 *        Does necessary processing when either OK or Cancel is pressed in
 *        any of the debug dialogs.  If OK is pressed, the debug state is
 *        saved if dirty.  If Cancel is hit, the debug state is restored if
 *        dirty.
 *
 *    In Windows, the EndDialog function must also be called.
 *
 *    Parameters:
 *        tmc        tmc of the button pressed, either tmcOk or tmcCancel.
 *        fDirty    indicates if the debug state has been modified.
 */
void
EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty)
{
    if (fDirty)
    {
        if (tmc == tmcOk)
            SaveDefaultDebugState();
        else
            DbgExRestoreDefaultDebugState();
    }

    DeleteDC(g_hdcCheck);
    DeleteObject(g_hbmpCheck);

    g_hdcCheck = NULL;
    g_hbmpCheck = NULL;

    EndDialog(hwndDlg, tmc == tmcOk);

    return;
}


/*
 *    TagFromSelection
 *
 *    Purpose:
 *        Isolation function for dialog procedures to eliminate a bunch of
 *         ifdef's everytime the index of the selection in the current listbox
 *        is requried.
 *
 *     Parameters:
 *        tmc        ID value of the listbox.
 *
 *     Returns:
 *        ctag for the currently selected listbox item.
 */

WORD
TagFromSelection(HWND hwndDlg, TMC tmc)
{
    HWND    hwndListbox;
    LRESULT lresult;

    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    lresult = SendMessageA(hwndListbox, CB_GETCURSEL, 0, 0);

    // the selection can be -ve if the editbox is empty !
    if (lresult == CB_ERR)
        return tagNull;

    Assert(lresult >= 0);
    lresult = SendMessageA(hwndListbox, CB_GETITEMDATA, lresult, 0);
    Assert(tagMin <= lresult && lresult < tagMac);
    return (WORD) lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\dbgalloc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dbgalloc.cxx
//
//  Contents:   Debug allocation routines and leak tracing
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#if !defined(UNIX) || !defined(_HPUX_SOURCE)

#ifndef X_TYPEINFO_H_
#define X_TYPEINFO_H_
#include <typeinfo.h>
#endif

#endif // !UNIX

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

ExternTag(tagLeaksExpected);
ExternTag(tagMemTrace);
ExternTag(tagHexDumpLeaks);
ExternTag(tagNoLeakAssert);

#define HEADFOOTGUARDSIZE 16
static BYTE  FILL_CLEAN;
static BYTE  FILL_DEAD;
static BYTE  FILL_HEAD_GUARD;
static BYTE  FILL_FOOT_GUARD;
static BYTE  g_abHeadGuardFill[HEADFOOTGUARDSIZE];
static BYTE  g_abFootGuardFill[HEADFOOTGUARDSIZE];


extern BOOL g_fOSIsNT;
LONG g_cCoTrackDisable = 0;

// We read from the ini file a block size.  We will then only
// keep stack info for blocks of that size.  -2 means that
// we haven't looked at the ini file yet and -1 means track
// all block sizes -- allowing us to track 0 size allocations.
// (will this ever happen?)
static LONG g_lStackTrackSize = -2;

void ReadFillBytes()
{
    FILL_CLEAN      = (BYTE)GetPrivateProfileIntA("Memory", "FillClean", 0x9D, "mshtmdbg.ini");
    FILL_DEAD       = (BYTE)GetPrivateProfileIntA("Memory", "FillDead",  0xAD, "mshtmdbg.ini");
    FILL_HEAD_GUARD = (BYTE)GetPrivateProfileIntA("Memory", "HeadGuard", 0xBD, "mshtmdbg.ini");
    FILL_FOOT_GUARD = (BYTE)GetPrivateProfileIntA("Memory", "FootGuard", 0xCD, "mshtmdbg.ini");

    memset( g_abHeadGuardFill, FILL_HEAD_GUARD, HEADFOOTGUARDSIZE);
    memset( g_abFootGuardFill, FILL_FOOT_GUARD, HEADFOOTGUARDSIZE);
}

#undef SNDMSG
#define SNDMSG ::SendMessageA

void TraceLeak(TRACETAG tag, HANDLE * phFile, char * pch, BOOL fOpenFile)
{
    TraceTag((tag, "%s", pch));

    if (*phFile == INVALID_HANDLE_VALUE && fOpenFile)
    {
        *phFile = CreateFileA("c:\\leakdump.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (*phFile != INVALID_HANDLE_VALUE)
    {
        _lwrite((HFILE)(DWORD_PTR)*phFile, pch, lstrlenA(pch));
        _lwrite((HFILE)(DWORD_PTR)*phFile, "\r\n", 2);
    }
}

void DumpHex(HANDLE hFile, BYTE *pb, UINT cb, DWORD_PTR dwAddr)
{
        BYTE *  pbRow;
        BYTE    b;
        UINT    cbRow;
        int             i;
    char    ach[256], *pch;

        while (cb > 0)
        {
        pch = ach;
        ach[0] = 0;

        pch += wsprintfA(pch, "   %08lX: ", (DWORD)dwAddr);
                pbRow = pb;
                cbRow = (cb > 16) ? 16 : cb;
                for (i = 0; i < 16; ++i)
                {
                        if (cbRow > 0)
                        {
                                b = *pbRow++;
                                --cbRow;
                                pch += wsprintfA(pch, "%02X ", b);
                        }
                        else
                                pch += wsprintfA(pch, "   ");
                        if (i == 7) pch += wsprintfA(pch, " ");
                }
                pch += wsprintfA(pch, "  ");
                pbRow = pb;
                cbRow = (cb > 16) ? 16 : cb;
                for (i = 0; i < 16; ++i)
                {
                        if (cbRow > 0)
                        {
                                b = *pbRow++;
                                --cbRow;
                        }
                        else
                                b = 32;

                        if (b > 31 && b < 127)
                                pch += wsprintfA(pch, "%c", b);
                        else
                                pch += wsprintfA(pch, ".");

                        if (i == 7) pch += wsprintfA(pch, " ");
                }
                cbRow = (cb > 16) ? 16 : cb;
                pb   += cbRow;
                cb   -= cbRow;
        TraceLeak(tagHexDumpLeaks, &hFile, ach, FALSE);
        dwAddr += cbRow;
        }
}

//+------------------------------------------------------------------------
//
//  Prefix struct stuck at the beginning of every allocated block.
//  Keeps track of all allocated blocks, plus saves a stack trace
//  from the allocation
//
//-------------------------------------------------------------------------


struct DBGALLOCHDR
{
    DBGALLOCHDR *   pdbgahPrev;
    DBGALLOCHDR *   pdbgahNext;
    DWORD           dwEip[STACK_WALK_DEPTH];
    DWORD           iAllocated;
    DWORD           tid;
    size_t          cbRequest;
    BOOL            fSymbols;
    BOOL            fLeaked;
    BOOL            fCoFlag;
    PERFMETERTAG    mt;
    size_t          cbHeader;
    char            szName[64];
    BYTE            adwGuard[HEADFOOTGUARDSIZE];
};


//+------------------------------------------------------------------------
//
//  Suffix struct stuck after the end of every allocated block.  Filled
//  with a known pattern to help detect pointers walking outside their
//  block.
//
//-------------------------------------------------------------------------

struct DBGALLOCFOOT
{
    BYTE           adwGuard[HEADFOOTGUARDSIZE];
};


inline size_t
ActualSizeFromRequestSize(size_t cb, BOOL fSymbols)
{
    return cb + sizeof(DBGALLOCHDR) + sizeof(DBGALLOCFOOT) +
           ((fSymbols) ? STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO) : 0);
}


inline size_t
RequestSizeFromActualSize(size_t cb, BOOL fSymbols)
{
    return cb - sizeof(DBGALLOCHDR) - sizeof(DBGALLOCFOOT) -
           ((fSymbols) ? STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO) : 0);
}


inline void *
RequestFromActual(DBGALLOCHDR * pdbgah)
{
    return pdbgah + 1;
}

inline void *
ClientFromActual(DBGALLOCHDR * pdbgah)
{
    return (BYTE *)RequestFromActual(pdbgah) + pdbgah->cbHeader;
}

inline DBGALLOCHDR *
ActualFromRequest(void * pv)
{
    return ((DBGALLOCHDR *) pv) - 1;
}


inline DBGALLOCFOOT *
FooterFromBlock(DBGALLOCHDR * pdbgah)
{
    return (DBGALLOCFOOT *)
            (((BYTE *) pdbgah) + sizeof(DBGALLOCHDR) + pdbgah->cbRequest);
}

inline INET_SYMBOL_INFO *
SymbolsFromBlock(DBGALLOCHDR *pdbgah)
{
    return (INET_SYMBOL_INFO *)
            (((BYTE *) pdbgah) + sizeof(DBGALLOCHDR) +
                                 sizeof(DBGALLOCFOOT) +
                                 pdbgah->cbRequest);
}

//+------------------------------------------------------------------------
//
//  Globals
//
//-------------------------------------------------------------------------

size_t g_cbTotalAllocated  = 0; // Total bytes current allocated.
size_t g_cbMaxAllocated = 0;    // Peak allocation size.
ULONG g_cAllocated = 0;         // Total number of allocations.

//
// Grep for a DWORD:
// If g_pvMemSearch is found inside a block, it is displayed with a 'F'.
//

void *g_pvMemSearch;


//
//  Allocation list is kept in a doubly-linked ring; this is the root
//  block in the ring.
//

DBGALLOCHDR g_dbgahRoot =
    {
        &g_dbgahRoot,
        &g_dbgahRoot,
        { 0, 0, 0, 0, 0 },
        0,
        (DWORD)-1
    };

//+---------------------------------------------------------------------------
//
//  Function:   DbgTraceAlloc
//
//  Synopsis:   Traces the result of an allocation or free
//
//  Arguments:
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void DbgTraceAlloc(char * szTag, size_t cbAlloc, size_t cbFree)
{
    if (DbgExIsTagEnabled(tagMemTrace) && (cbAlloc || cbFree))
    {
        if (cbAlloc && cbFree)
        {
            TraceTag((tagMemTrace, "%s +%5d -%5d = [%7d]", szTag, cbAlloc,
                cbFree, g_cbTotalAllocated));
        }
        else if (cbAlloc)
        {
            TraceTag((tagMemTrace, "%s +%5d        = [%7d]", szTag, cbAlloc,
                g_cbTotalAllocated));
        }
        else
        {
            TraceTag((tagMemTrace, "%s        -%5d = [%7d]", szTag, cbFree,
                g_cbTotalAllocated));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExMemoryTrackDisable
//
//  Synopsis:   Disables or Enables memory leak tracking. Allocations that
//              occur while tracking is disabled will never be reported as
//              leaks, even if they are.
//
//  Arguments:  [fDisable] -- TRUE if tracking should be disabled. FALSE to
//                            re-enable it.
//
//  Returns:    void
//
//  Notes:      Multiple calls giving TRUE require the same amount of calls
//              giving FALSE before tracking is actually re-enabled.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExMemoryTrackDisable(BOOL fDisable)
{
    EnsureThreadState();
    if (fDisable)
    {
        TLS(cTrackDisable)++;
    }
    else
    {
        Assert(TLS(cTrackDisable) > 0);

        TLS(cTrackDisable)--;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExCoMemoryTrackDisable
//
//  Synopsis:   Disables or Enables Co memory leak tracking. Allocations that
//              occur while tracking is disabled will never be reported as
//              leaks, even if they are.
//
//  Arguments:  [fDisable] -- TRUE if tracking should be disabled. FALSE to
//                            re-enable it.
//
//  Returns:    void
//
//  Notes:      Multiple calls giving TRUE require the same amount of calls
//              giving FALSE before tracking is actually re-enabled.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExCoMemoryTrackDisable(BOOL fDisable)
{
    if (fDisable)
    {
        InterlockedIncrement(&g_cCoTrackDisable);
    }
    else
    {
        InterlockedDecrement(&g_cCoTrackDisable);
    }
}

void WINAPI
DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt)
{
    if (pvRequest)
    {
        DBGALLOCHDR * pdbgah = ActualFromRequest(pvRequest);
        pdbgah->cbHeader = cb;
        pdbgah->mt = mt;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRunTimeType
//
//  Synopsis:   Returns the type of the object stored in the block.  If
//              it cannot be determined, the empty string is returned.
//
//  Arguments:  [fDisable] -- TRUE if tracking should be disabled. FALSE to
//                            re-enable it.
//
//  Returns:    char *
//
//----------------------------------------------------------------------------

#pragma warning(disable: 4541)

class CType
{
    virtual MethodFoo() { return 0; }
};

char *
GetRunTimeType(LPVOID pv)
{
    CType * pType = (CType *)pv;
    char * psz = NULL;
    static char achBuf[256];
   
    //
    // The typeid operator will throw an exception or blow up if the memory
    // doesn't point to an object.
    //
#ifndef NO_RTTI
    __try
    {
        psz = const_cast<char*>(typeid(*pType).name());
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        psz = NULL;
    }
    __endexcept
#else
      psz = NULL; // Added only for this #ifdef
#endif

    if (psz == NULL || IsBadStringPtrA(psz, 1024))
        return("");

    // Remove "class " wherever it occurs
        
    strncpy(achBuf, psz, ARRAY_SIZE(achBuf));
    achBuf[ARRAY_SIZE(achBuf)-1] = NULL;        

    for (;;)
    {
        char * szClass = strstr(achBuf, "class ");

        if (szClass == NULL)
            break;

        memmove(szClass, szClass + 6, lstrlenA(szClass + 6) + 1);
    }

    return(achBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   BlockIsValid
//
//  Synopsis:   Returns TRUE iff the block's guard structures are valid.
//
//  Arguments:  [pdbgah]
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
BlockIsValid(DBGALLOCHDR * pdbgah)
{
    DBGALLOCFOOT *  pdbgft;

    // Put all of this in a __try/__except block as someone might
    // pass us garbage.

    __try
    {
        Assert(sizeof(pdbgah->adwGuard) == sizeof(g_abHeadGuardFill));
        if (memcmp(pdbgah->adwGuard,
                g_abHeadGuardFill,
                sizeof(g_abHeadGuardFill)))
            return FALSE;

        pdbgft = FooterFromBlock(pdbgah);
        Assert(sizeof(pdbgft->adwGuard) == sizeof(g_abFootGuardFill));
        if (memcmp(pdbgft->adwGuard,
                g_abFootGuardFill,
                sizeof(g_abFootGuardFill)))
            return FALSE;
    }
    // Make sure int3s get through
    __except (GetExceptionCode() == STATUS_BREAKPOINT ? EXCEPTION_CONTINUE_SEARCH : EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPreGetSize
//
//  Synopsis:   Hook called before memory get-size function
//
//  Arguments:  pvRequest  Request pointer
//
//  Returns:    Actual pointer.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPreGetSize(void *pvRequest)
{
    EnsureThreadState();
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());
    TLS(pvRequest) = pvRequest;
    return (pvRequest) ? ActualFromRequest(pvRequest) : NULL;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPostGetSize
//
//  Synopsis:   Hook called after memory get-size function
//
//  Arguments:  cb  Actual size.
//
//  Returns:    Request Size.
//
//-------------------------------------------------------------------------

size_t WINAPI
DbgExPostGetSize(size_t cb)
{
    DBGTHREADSTATE *   pts;
    pts = DbgGetThreadState();
    return (pts->pvRequest) ? ActualFromRequest(pts->pvRequest)->cbRequest : 0;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPreAlloc
//
//  Synopsis:   Hook called before memory allocation function.
//
//  Arguments:  cb      Request size.
//
//  Returns:    Actual size to allocate.
//
//-------------------------------------------------------------------------

size_t WINAPI
DbgExPreAlloc(size_t cbRequest)
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());
    EnsureThreadState();
    TLS(cbRequest) = cbRequest;

    if (AreSymbolsEnabled())
    {
        if (g_lStackTrackSize == -2)
        {
            g_lStackTrackSize = GetPrivateProfileIntA("SymbolLeakTrack", "Size", -1, "mshtmdbg.ini");

            if (g_lStackTrackSize != -1)
                g_lStackTrackSize += 8; // sizeof(MTMEMBLK);

            if (g_lStackTrackSize < -1)
                g_lStackTrackSize = -1;
        }

        TLS(fSymbols) = (g_lStackTrackSize == -1 || (size_t)g_lStackTrackSize == cbRequest);
    }
    else
        TLS(fSymbols) = FALSE;

    return ActualSizeFromRequestSize(cbRequest, TLS(fSymbols));
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPostAlloc
//
//  Synopsis:   Hook called after memory allocation function.
//
//  Arguments:  pv      Pointer to actual allocation.
//
//  Returns:    Pointer requested allocation.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPostAlloc(void *pv)
{
    DBGTHREADSTATE *   pts;
    DBGALLOCHDR *   pdbgah;
    DBGALLOCFOOT *  pdbgft;

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    pts = DbgGetThreadState();

    pdbgah = (DBGALLOCHDR *)pv;
    if (!pdbgah)
        return NULL;

    DbgTraceAlloc("A", pts->cbRequest, 0);

    //  Keep track of total amount of memory allocated
    pdbgah->cbRequest = pts->cbRequest;
    pdbgah->cbHeader  = 0;
    pdbgah->fSymbols  = pts->fSymbols;
    pdbgah->fLeaked   = (pts->cTrackDisable > 0) ||
                        (pts->fSpyAlloc && g_cCoTrackDisable > 0);
    pdbgah->fCoFlag   = pts->fSpyAlloc;
    pdbgah->mt        = pdbgah->fCoFlag ? pts->mtSpy : 0;

    if (pdbgah->fCoFlag && pdbgah->mt)
    {
        DbgExMtAdd(pdbgah->mt, +1, pts->cbRequest);
    }

    //  Note the thread which made the allocation
    pdbgah->tid = GetCurrentThreadId();

    if (pdbgah->fSymbols)
    {
        //  Snapshot stack
        GetStackBacktrace(3 + (pts->fSpyAlloc ? 2 : 0),
                          ARRAY_SIZE(pdbgah->dwEip),
                          pdbgah->dwEip,
                          SymbolsFromBlock(pdbgah));
    }
    else
    {
        pdbgah->dwEip[0] = NULL;
    }

    // Default the name to the empty string

    pdbgah->szName[0] = 0;

    //  Fill in guard blocks
    Assert(sizeof(pdbgah->adwGuard) == sizeof(g_abHeadGuardFill));
    memcpy(pdbgah->adwGuard, g_abHeadGuardFill, sizeof(g_abHeadGuardFill));
    pdbgft = FooterFromBlock(pdbgah);
    Assert(sizeof(pdbgft->adwGuard) == sizeof(g_abFootGuardFill));
    memcpy(pdbgft->adwGuard, g_abFootGuardFill, sizeof(g_abFootGuardFill));

    // Update globals.

    {
        LOCK_GLOBALS;

        g_cbTotalAllocated += pts->cbRequest;
        if (g_cbMaxAllocated < g_cbTotalAllocated)
            g_cbMaxAllocated = g_cbTotalAllocated;

        //  Keep track of allocation number.
        pdbgah->iAllocated = g_cAllocated++;

        //  Hook into allocated blocks chain
        pdbgah->pdbgahPrev = &g_dbgahRoot;
        pdbgah->pdbgahNext = g_dbgahRoot.pdbgahNext;
        g_dbgahRoot.pdbgahNext->pdbgahPrev = pdbgah;
        g_dbgahRoot.pdbgahNext = pdbgah;
    }

    pv = RequestFromActual(pdbgah);

    //  TODO we should modify this to a changing, yet predictable pattern.
    //  Fill logical block with clean byte
    memset(pv, FILL_CLEAN, pts->cbRequest);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pv;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPreFree
//
//  Synopsis:   Hook called before memory free function.
//
//  Arguments:  pv  Pointer to request allocation.
//
//  Returns:    Pointer to actual allocation.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPreFree(void *pv)
{
    DBGALLOCHDR *   pdbgah;

    EnsureThreadState();
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    if (!pv)
        return NULL;

    pdbgah = ActualFromRequest(pv);

    Assert(BlockIsValid(pdbgah));

    {
        // Keep scope of locked globals to a minimum.  There's a
        // potential for deadlock if the assert above fires with
        // locked globals.

        LOCK_GLOBALS;

        pdbgah->pdbgahPrev->pdbgahNext = pdbgah->pdbgahNext;
        pdbgah->pdbgahNext->pdbgahPrev = pdbgah->pdbgahPrev;

        g_cbTotalAllocated -= pdbgah->cbRequest;
    }

    DbgTraceAlloc("F", 0, pdbgah->cbRequest);

    if (pdbgah->fCoFlag && pdbgah->mt)
    {
        DbgExMtAdd(pdbgah->mt, -1, -(LONG_PTR)pdbgah->cbRequest);
    }

    //  Fill entire block (including debug additions) with fill dead
    memset(pdbgah,
           FILL_DEAD,
           ActualSizeFromRequestSize(pdbgah->cbRequest, pdbgah->fSymbols));

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pdbgah;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExPostFree
//
//  Synopsis:   Hook called after memory free function.
//
//-------------------------------------------------------------------------

void WINAPI
DbgExPostFree(void)
{
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExPreRealloc
//
//  Synopsis:   Hook called before memory reallocation function.
//
//  Arguments:  pv  Pointer to the request allocation.
//              cb  New requested size.
//              ppv Pointer to the actual allocation.
//
//  Returns:    New actual size.
//
//-------------------------------------------------------------------------

size_t WINAPI
DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    size_t          cb;
    DBGTHREADSTATE *   pts;
    DBGALLOCHDR *   pdbgah = ActualFromRequest(pvRequest);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());
    EnsureThreadState();

    pts = DbgGetThreadState();

    pts->cbRequest = cbRequest;
    pts->pvRequest = pvRequest;

    if (pvRequest == NULL)
    {
        *ppv = NULL;
        cb = ActualSizeFromRequestSize(cbRequest, pdbgah->fSymbols);
    }
    else if (cbRequest == 0)
    {
        *ppv = DbgExPreFree(pvRequest);
        cb = 0;
    }
    else
    {
        Assert(BlockIsValid(pdbgah));

        // copy tail data now; it will be invalid later on a shrinking realloc
        if (pdbgah->fSymbols)
        {
            memcpy(pts->aSymbols, SymbolsFromBlock(pdbgah),
                   STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO));
        }

        {
            LOCK_GLOBALS;

            pdbgah->pdbgahPrev->pdbgahNext = pdbgah->pdbgahNext;
            pdbgah->pdbgahNext->pdbgahPrev = pdbgah->pdbgahPrev;

            g_cbTotalAllocated -= pdbgah->cbRequest;
        }

        *ppv = pdbgah;
        cb = ActualSizeFromRequestSize(cbRequest, pdbgah->fSymbols);
    }

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return cb;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExPostRealloc
//
//  Synopsis:   Hook called after the memory allocation function
//
//  Arguments:  pv  Pointer to the actual allocation.
//
//  Returns:    Pointer to the requested allocation.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPostRealloc(void *pv)
{
    void *          pvReturn;
    DBGTHREADSTATE *   pts;
    DBGALLOCHDR *   pdbgah;
    DBGALLOCFOOT *  pdbgft;

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    pts = DbgGetThreadState();

    if (pts->pvRequest == NULL)
    {
        pvReturn = DbgExPostAlloc(pv);
    }
    else if (pts->cbRequest == 0)
    {
        Assert(pv == NULL);
        pvReturn = NULL;
    }
    else
    {
        LOCK_GLOBALS;

        if (pv == NULL)
        {

            // The realloc failed.  Hook the the block back
            // into the list.

            Assert(pts->pvRequest);
            pdbgah = ActualFromRequest(pts->pvRequest);

            pdbgah->pdbgahPrev = &g_dbgahRoot;
            pdbgah->pdbgahNext = g_dbgahRoot.pdbgahNext;
            g_dbgahRoot.pdbgahNext->pdbgahPrev = pdbgah;
            g_dbgahRoot.pdbgahNext = pdbgah;

            g_cbTotalAllocated += pts->cbRequest;
            if (g_cbMaxAllocated < g_cbTotalAllocated)
                g_cbMaxAllocated = g_cbTotalAllocated;

            pvReturn = NULL;
        }
        else
        {
            pdbgah = (DBGALLOCHDR *)pv;

            DbgTraceAlloc("R", pts->cbRequest, pdbgah->cbRequest);

            if (pdbgah->fCoFlag && pdbgah->mt)
            {
                DbgExMtAdd(pdbgah->mt, 0, (pts->cbRequest - pdbgah->cbRequest));
            }

            //  Keep track of total amount of memory allocated
            pdbgah->cbRequest = pts->cbRequest;
            g_cbTotalAllocated += pts->cbRequest;
            if (g_cbMaxAllocated < g_cbTotalAllocated)
                g_cbMaxAllocated = g_cbTotalAllocated;

            //  Hook into allocated blocks chain
            pdbgah->pdbgahPrev = &g_dbgahRoot;
            pdbgah->pdbgahNext = g_dbgahRoot.pdbgahNext;
            g_dbgahRoot.pdbgahNext->pdbgahPrev = pdbgah;
            g_dbgahRoot.pdbgahNext = pdbgah;

            if (pdbgah->fSymbols)
            {
                // recall saved symbols
                memcpy(SymbolsFromBlock(pdbgah), pts->aSymbols,
                       STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO));
            }

            //  Fill in guard blocks
            pdbgft = FooterFromBlock(pdbgah);
            Assert(sizeof(pdbgft->adwGuard) == sizeof(g_abFootGuardFill));
            memcpy(pdbgft->adwGuard, g_abFootGuardFill, sizeof(g_abFootGuardFill));

            pvReturn = RequestFromActual(pdbgah);
        }
    }

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pvReturn;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgPreDidAlloc
//
//  Synopsis:   Hook called before memory did allocate function.
//
//  Arguments:  pv  Pointer to the requested allocation.
//
//  Returns:    Pointer to the actual allocatino.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPreDidAlloc(void *pvRequest)
{
    return ActualFromRequest(pvRequest);
}

//+------------------------------------------------------------------------
//
//  Function:   DbgPreDidAlloc
//
//  Synopsis:   Hook called after memory did allocate function.
//
//  Arguments:  pvRequest Pointer to the requested allocation.
//              fActual   Actual return value for the block
//
//  Returns:    Did we allocate this block?.
//
//-------------------------------------------------------------------------

BOOL WINAPI
DbgExPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExMemSetName
//
//  Synopsis:   Sets the descriptive name of a memory block
//
//  Arguments:  pv  Pointer to the requested allocation
//
//  Returns:    Pointer to the requested allocation
//
//-------------------------------------------------------------------------
void * __cdecl
DbgExMemSetName(void *pvRequest, char * szFmt, ...)
{
    va_list va;
    void * pv;

    va_start(va, szFmt);
    pv = DbgExMemSetNameList(pvRequest, szFmt, va);
    va_end(va);

    return(pv);
}

void * WINAPI
DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list va)
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    DBGALLOCHDR * pdbgah = ActualFromRequest(pvRequest);

    char szBuf[1024];

    if (!BlockIsValid(pdbgah))
        return pvRequest;

    if (pvRequest)
    {
        wvsprintfA(szBuf, szFmt, va);

        szBuf[ARRAY_SIZE(pdbgah->szName) - 1] = 0;
        lstrcpyA(pdbgah->szName, szBuf);
    }

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pvRequest;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExMemGetName
//
//  Synopsis:   Gets the descriptive name of a memory block
//
//  Arguments:  pv  Pointer to the requested allocation
//
//  Returns:    Pointer to the requested allocation
//
//-------------------------------------------------------------------------

char * WINAPI
DbgExMemGetName(void *pvRequest)
{
    return(ActualFromRequest(pvRequest)->szName);
}

//+------------------------------------------------------------------------
//
//  Function:   DbgSetAutoLeak
//
//  Synopsis:   Tests the contents of the block to determine if it is
//              known to have been leaked.  If so, turns on the fLeaked flag.
//
//  Arguments:  pv  Pointer to the requested allocation
//
//  Returns:    Pointer to the requested allocation
//
//-------------------------------------------------------------------------

void DbgSetAutoLeak(DBGALLOCHDR * pdbgah)
{
    return;

#if 0 // For example ...
    size_t cbClient = pdbgah->cbRequest - pdbgah->cbHeader;

    if (pdbgah->fLeaked || cbClient < 5 || cbClient > 32)
        return;

    if (    memcmp(ClientFromActual(pdbgah), "image/", 6) == 0
        ||  memcmp(ClientFromActual(pdbgah), "text/", 5) == 0
        ||  memcmp(ClientFromActual(pdbgah), "application/", 12) == 0)
    {
        pdbgah->fLeaked = TRUE;
    }
#endif
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExTraceMemoryLeaks
//
//  Synopsis:   Traces all allocated blocks, along with stack backtraces
//              from their allocation, to tagLeaks.
//
//-------------------------------------------------------------------------

void WINAPI
DbgExTraceMemoryLeaks()
{
    DBGALLOCHDR *   pdbgah;
#ifndef _MAC
    int             i;
    INET_SYMBOL_INFO *   psi;
    CHAR            achSymbol[256];
#endif
    int             iPass;
    int             acLeaks[4] = { 0, 0, 0, 0 };
    BOOL            fLeakBanner;
    TRACETAG        tag;
    char            achBuf[512];
    HANDLE          hFile = INVALID_HANDLE_VALUE;

    EnsureThreadState();

    LOCK_GLOBALS;

    for (iPass = 0; iPass < 2; ++iPass)
    {
        fLeakBanner = FALSE;
        tag = iPass == 0 ? tagLeaks : tagLeaksExpected;

        for (pdbgah = g_dbgahRoot.pdbgahNext;
             pdbgah != &g_dbgahRoot;
             pdbgah = pdbgah->pdbgahNext)
        {
            if (iPass == 0)
            {
                DbgSetAutoLeak(pdbgah);
            }

            if (!!pdbgah->fLeaked == (iPass == 0))
                continue;

            if (!fLeakBanner)
            {
                fLeakBanner = TRUE;

                wsprintfA(achBuf, "---------- Leaked Memory Blocks %s----------",
                    iPass == 0 ? "" : "(Expected) ");

                if (DbgExIsTagEnabled(tag))
                {
                    TraceLeak(tag, &hFile, achBuf, TRUE);
                }
            }

            if (DbgExIsTagEnabled(tag))
            {
                wsprintfA(achBuf, "%c%c p=0x%08x  cb=%-4d #=%-4d TID:0x%x %s",
                        pdbgah->fCoFlag ? 'C' : ' ',
                        pdbgah->fLeaked ? 'L' : ' ',
                        ClientFromActual(pdbgah),
                        pdbgah->cbRequest - pdbgah->cbHeader,
                        pdbgah->iAllocated,
                        pdbgah->tid,
                        pdbgah->szName);

                TraceLeak(tag, &hFile, achBuf, TRUE);

                if (pdbgah->mt)
                {
                    wsprintfA(achBuf, "   %s (%s)", DbgExMtGetName(pdbgah->mt), DbgExMtGetDesc(pdbgah->mt));
                    TraceLeak(tag, &hFile, achBuf, TRUE);
                }

                psi = (pdbgah->fSymbols) ? SymbolsFromBlock(pdbgah) : NULL;

                for (i = 0; i < ARRAY_SIZE(pdbgah->dwEip); i++)
                {
                    if (!pdbgah->dwEip[i])
                        break;

                    GetStringFromSymbolInfo(pdbgah->dwEip[i],
                                            (psi) ? psi + i : NULL,
                                            achSymbol);

                    if (achSymbol[0])
                    {
                        wsprintfA(achBuf, " %s", achSymbol);
                        TraceLeak(tag, &hFile, achBuf, TRUE);
                    }
                }

                if (hFile != INVALID_HANDLE_VALUE || DbgExIsTagEnabled(tagHexDumpLeaks))
                {
                    ULONG cb = pdbgah->cbRequest - pdbgah->cbHeader;

                    if (cb > 4096)
                        cb = 4096;

                    DumpHex(hFile, (BYTE *)ClientFromActual(pdbgah), cb, (DWORD_PTR)ClientFromActual(pdbgah));
                }
            }

            if (pdbgah->fCoFlag)
                acLeaks[iPass + 2]++;
            else
                acLeaks[iPass]++;
        }
    }

    wsprintfA(achBuf, "%d+%d leaks (plus %d+%d expected), total size %d, peak size %d",
            acLeaks[0], acLeaks[2], acLeaks[1], acLeaks[3],
            g_cbTotalAllocated, g_cbMaxAllocated);
    TraceLeak(tagNull, &hFile, achBuf, FALSE);


    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    //
    // Don't fire the assert if the exit-on-assert flag is on - calling
    // TerminateProcess when we're already shutting down the process causes
    // Win95 to blow up.
    //
    if (!DbgExIsTagEnabled(tagNoLeakAssert))
    {
        char achMsg[512];

        wsprintfA(achMsg, "Memory Leaked! %d+%d block%s (plus %d+%d expected)\n(Leaks were dumped to c:\\leakdump.txt so there is no excuse to ignore this message!)",
            acLeaks[0], acLeaks[2], (acLeaks[0] + acLeaks[2] == 1) ? "" : "s",
            acLeaks[1], acLeaks[3]);

        AssertSz(acLeaks[0] + acLeaks[2] == 0, achMsg);
    }
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExValidateInternalHeap
//
//  Synopsis:   Cruises through the heap, validating each allocated
//              block.  Any invalid blocks are traced to tagLeaks.
//              Function returns TRUE iff all blocks are valid.
//
//-------------------------------------------------------------------------

BOOL WINAPI
DbgExValidateInternalHeap()
{
    DBGALLOCHDR *   pdbgah;
    int             i;
    BOOL            fHeapValid  = TRUE;
    CHAR            achSymbol[256];
    INET_SYMBOL_INFO    *psi;

    EnsureThreadState();

    LOCK_GLOBALS;

    for (pdbgah = g_dbgahRoot.pdbgahNext;
         pdbgah != &g_dbgahRoot;
         pdbgah = pdbgah->pdbgahNext)
    {
        if (!BlockIsValid(pdbgah))
        {
            if (fHeapValid && !AreSymbolsEnabled())
            {
                TraceTag((tagLeaks, ""));

                TraceTag((tagLeaks, "Symbol loading is not enabled. Turn on the '!Symbols'"));
                TraceTag((tagLeaks, "   tag to enable it and then restart your application. Make sure"));
                TraceTag((tagLeaks, "   imagehlp.dll and mspdb41.dll are on your path."));
                TraceTag((tagLeaks, "See the Forms3 Development Handbook, Tips, Tip04 for details.\n"));
            }

            fHeapValid = FALSE;

            TraceTag((
                    tagLeaks,
                    "Invalid block at 0x%08x  Size:%-4d Alloc #:%-4d TID:0x%x",
                    ClientFromActual(pdbgah),
                    pdbgah->cbRequest - pdbgah->cbHeader,
                    pdbgah->iAllocated,
                    pdbgah->tid));

            if (DbgExIsTagEnabled(tagLeaks))
            {
                psi = (pdbgah->fSymbols) ? SymbolsFromBlock(pdbgah) : NULL;

                for (i = 0; i < ARRAY_SIZE(pdbgah->dwEip); i++)
                {
                    if (!pdbgah->dwEip[i])
                        break;

                    GetStringFromSymbolInfo(pdbgah->dwEip[i],
                                            (psi) ? psi + i : NULL,
                                            achSymbol);

                    TraceTag((tagLeaks, "%s", achSymbol));
                }
            }
        }
    }

#if !defined(_MAC)
    //
    // Then, check the system's process heap.
    //
    if (fHeapValid && g_fOSIsNT)
    {
        //
        // If running under a debugger, this call will generate a breakpoint
        // and print information to the debugger if the heap is corrupt.
        //
        EnterCriticalSection(&g_csHeapHack);
        fHeapValid = HeapValidate(GetProcessHeap(), 0, NULL);
        LeaveCriticalSection(&g_csHeapHack);
    }
#endif

    // check

    return fHeapValid;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExMemoryBlockTrackDisable
//
//  Synopsis:   Disables memory leak tracking for a previously allocated block.
//
//  Arguments:  [pvRequest] -- The allocated memory block
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void WINAPI
DbgExMemoryBlockTrackDisable(void * pv)
{
    DBGALLOCHDR * pdbgah;
    DBGALLOCHDR * pdbgahT;

    EnsureThreadState();

    if (!pv)
        return;

    LOCK_GLOBALS;

    pdbgahT = ActualFromRequest(pv);

    for (pdbgah = g_dbgahRoot.pdbgahNext;
         pdbgah != &g_dbgahRoot;
         pdbgah = pdbgah->pdbgahNext)
    {
        if (pdbgah == pdbgahT)
        {
            pdbgah->fLeaked = TRUE;
            return;
        }
    }

    TraceTag((tagLeaks, "DbgExMemoryBlockTrackDisable: Block not found: %08lX\n", pv));
}

// Heap Monitor ---------------------------------------------------------------

/* We have no bitmaps in our owner-drawn controls, but  */
/* if we did, these constants would need to be updated. */

#define BMWIDTH             0
#define BMHEIGHT            0
#define NUMBMPS             0

typedef DBGALLOCHDR DBGAH, * PDBGAH;

/* Function Prototypes */

/* Heap Monitor Dialog Thread and Dialog Proc */

DWORD WINAPI
HeapMonitorThread(LPVOID lpv);

INT_PTR WINAPI
HeapMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/* Command and Support Routines for the HeapMonDlgProc */

void    BltIcon(HWND hWnd);
void    SetWindowTitle(HWND hWnd, LPSTR lpcText);
void    RefreshHeapView(HWND hWnd);
void    SetSumSelection(void);
void    BlockListNotify(WORD wNotify, HWND  hWnd);

BOOL    FBlockStillValid(PDBGAH pdbgah);

void    MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
int     CompareItem(UINT idCtl, LPCOMPAREITEMSTRUCT pcis);
void    DrawItem(WORD wId, LPDRAWITEMSTRUCT pdis);
void    OutTextFormat(WORD wId, LPDRAWITEMSTRUCT pdis);
void    SetRGBValues(void);

/* Memory Block Editor Dialog Proc and Support Routines */

INT_PTR WINAPI
BlockDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void    FormatBlockRow(LPSTR psz, LPBYTE lpbRow, LPBYTE lpbHead, UINT cb, LPBYTE pbReal);
void    OutBlockRowFormat(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah);
void    DrawBlockRow(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah);
void    SetBlockEditData(HWND hWnd, PDBGAH pdbgah);

//  Global Data

HWND        ghWnd           = NULL;
HWND        ghBlockWnd      = NULL;
HICON       ghIcon          = NULL;
HBRUSH      ghbrBkgnd       = NULL;
UINT        idSort          = IDC_SORTADDRESS;
UINT        idDataType      = IDC_BYTE;
BOOL        fDlgUp          = FALSE;
BOOL        g_fShowMeters   = FALSE;

//  Globals used by the Owner-Draw code.

DWORD       rgbWindowColor  = 0xFF000000;    // variables for the current
DWORD       rgbHiliteColor  = 0xFF000000;    // system color settings.
DWORD       rgbWindowText   = 0xFF000000;    // on a WM_SYSCOLORCHANGE
DWORD       rgbHiliteText   = 0xFF000000;    // we check to see if we need
DWORD       rgbGrayText     = 0xFF000000;    // to reload our bitmap.
DWORD       rgbDDWindow     = 0xFF000000;    //
DWORD       rgbDDHilite     = 0xFF000000;    // 0xFF000000 is an invalid RGB

//  Tabs for the Block List - Address  AllocNum  Size  Description

//  Tabs for Memory Block Edit

//  hdc to hold listbox bitmaps (for speed)

HDC     hdcMemory = 0;

/* Memory browsing threads */
DWORD   WINAPI  DoBrowseThread(LPVOID lpParam);
DWORD   WINAPI  DoMemStats(LPVOID lpParam);


void WINAPI DoMemoryBrowse(HINSTANCE phInst, HWND phWnd, DWORD dwProcess);


void WINAPI
DbgExOpenMemoryMonitor()
{
    if (fDlgUp)
    {
        ShowWindow(ghWnd, SW_RESTORE);
        SetForegroundWindow(ghWnd);
    }
    else
    {
        DWORD dwThreadId;
        THREAD_HANDLE hThread;

        hThread = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0,
            (LPTHREAD_START_ROUTINE)HeapMonitorThread,
            NULL, 0, &dwThreadId);

        CloseThread(hThread);
    }
}

/*
 -  HeapMonitorThread
 -
 *  Purpose:
 *      This thread is here for the sole purpose of putting up a
 *      dialog who gets messages on this threads time slice.
 */

DWORD WINAPI HeapMonitorThread(LPVOID lpv)
{
    ghbrBkgnd = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
    ghIcon = LoadIconA(g_hinstMain, MAKEINTRESOURCEA(IIC_ICONIC));

    DialogBoxA(g_hinstMain, MAKEINTRESOURCEA(IDD_HEAPMON), NULL, HeapMonDlgProc);

    DeleteObject(ghbrBkgnd);

    return 0;
}


/*
 -  FBlockStillValid
 -
 *  Purpose:
 *      Searches for the specified block in the specified heaps.
 *      This must be done before using a pdbgah object since they
 *      are used and added/removed on two different threads.
 */

BOOL FBlockStillValid(PDBGAH pdbgah)
{
    PDBGAH pdbgahT = pdbgah;

    for (pdbgah = g_dbgahRoot.pdbgahNext;
         pdbgah != &g_dbgahRoot;
         pdbgah = pdbgah->pdbgahNext)
    {
        if (pdbgah == pdbgahT)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}


#define PvPlhblkEnd(pdbgah)     ((LPBYTE)RequestFromActual(pdbgah) + (pdbgah)->cbRequest - 1)

/*
 -  RefreshHeapView
 -
 *  Purpose:
 *      This updates our currently displayed heap.  Does all the calculations
 *      and fills in all the edit controls on the HeapMon dialog.
 */

void RefreshHeapView(HWND hWnd)
{
    char    szOutBuff[128];
    ULONG   cLive = 0;
    PDBGAH  pdbgah;
    ULONG   cbLive = 0;
    LONG    idxTop;

    LOCK_GLOBALS;

    idxTop = SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_GETTOPINDEX, 0, 0L);

    SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_RESETCONTENT, 0, 0L);

    pdbgah = g_dbgahRoot.pdbgahNext;

    while (pdbgah != &g_dbgahRoot)
    {
        DbgSetAutoLeak(pdbgah);
        cLive++;
        cbLive += (ULONG)(pdbgah->cbRequest - pdbgah->cbHeader);
        SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_ADDSTRING, 0, (LPARAM)pdbgah);
        pdbgah = pdbgah->pdbgahNext;
    }

    if (idxTop != CB_ERR)
        SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_SETTOPINDEX, (WPARAM)idxTop, 0L);

    wsprintfA(szOutBuff, "%7ld Bytes in %ld Blocks", cbLive, cLive);
    SetDlgItemTextA(hWnd, IDE_LIVEBLOCK, szOutBuff);

    SetSumSelection();
}

/*
 -  BlockListNotify
 -
 *  Purpose:
 *      We capture double click notifications on the block list and
 *      bring up a hex editor (that is read-only) for the memory in
 *      that block.  A nasty side effect of this is that we grab the
 *      critical section on the heap before putting up the dialog and
 *      we don't release it until we return from the dialog.  We have
 *      to do this to prevent the memory from going away out from under
 *      us.
 */

void BlockListNotify(WORD wNotify, HWND  hWnd)
{
    LONG    idx;
    PDBGAH  pdbgah = NULL;
    PDBGAH  pdbgahCopy = NULL;
    ULONG   cb;
    BOOL    fDoDialog = FALSE;

    if (wNotify == LBN_DBLCLK)
    {
        idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);

        if (idx != CB_ERR)
            pdbgah = (PDBGAH)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
        if ((LONG_PTR)pdbgah == (LONG_PTR)CB_ERR)
            goto ret;

        if (!(GetAsyncKeyState(VK_CONTROL) & 0x8000))
        {
            {
                LOCK_GLOBALS;

                if (FBlockStillValid(pdbgah))
                {
                    cb = ActualSizeFromRequestSize(pdbgah->cbRequest, pdbgah->fSymbols);
                    pdbgahCopy = (PDBGAH)LocalAlloc(LPTR, cb);

                    if (pdbgahCopy != NULL)
                    {
                        memcpy(pdbgahCopy, pdbgah, cb);
                        *(DWORD_PTR *)pdbgahCopy->adwGuard = (DWORD_PTR)ClientFromActual(pdbgah);
                        fDoDialog = TRUE;
                    }
                }
            }

            if (fDoDialog)
            {
                DialogBoxParamA(g_hinstMain,
                        MAKEINTRESOURCEA(IDD_BLOCKEDIT),
                        hWnd, BlockDlgProc, (LPARAM)pdbgahCopy);

                LocalFree((HGLOBAL)pdbgahCopy);
            }
        }
        else
        {
            idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);

            if (idx != CB_ERR)
                pdbgah = (PDBGAH)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
            if ((LONG_PTR)pdbgah == (LONG_PTR)CB_ERR)
                goto ret;

            g_pvMemSearch = ClientFromActual(pdbgah);

            RefreshHeapView(ghWnd);
        }
    }
    else if (wNotify == LBN_SELCHANGE)
    {
        SetSumSelection();
    }

ret:
    return;
}


/*
 -  SetWindowTitle
 -
 *  Purpose:
 *      Updates the dialog window title to include the process
 *      on whose behalf we were invoked.
 */

void SetWindowTitle(HWND hWnd, LPSTR lpcText)
{
    LPSTR   pszModule;
    char    szTitle[80];
    char    szModule[MAX_PATH];

    if(!GetModuleFileNameA(NULL, szModule, MAX_PATH))
    {
        Assert(FALSE);
        return;
    }

    pszModule = (LPSTR)(szModule + lstrlenA(szModule));

    while (*pszModule-- != '\\') ;

    pszModule += 2;

    CharUpperBuffA(pszModule, lstrlenA(pszModule));

    wsprintfA(szTitle, lpcText, pszModule);
    SetWindowTextA(hWnd, szTitle);
}


/*
 -  BltIcon
 -
 *  Purpose:
 *      BitBlts a bitmap in the client area of the dialog when the dialog
 *      is minimized (IsIconic).  This is to get around a Windows limitation
 *      of not being able to associate an icon with a dialog.
 */

void BltIcon(HWND hWnd)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT rc;

    hdc = BeginPaint(hWnd, &ps);

    if (hdc)
    {
        GetClientRect(hWnd, &rc);
        FillRect(hdc, &rc, ghbrBkgnd);
        DrawIcon(hdc, 0, 0, ghIcon);
    }

    EndPaint(hWnd, &ps);
}

/*
 -  HeapMonDlgProc
 -
 *  Purpose:
 *      This function (which only executes on Win32 in debug builds) is
 *      used to monitor heap usage on the any heap created by glheap.  We
 *      will attempt to calculate total heap usage, heap fragmentation,
 *      and percentage per heap of total allocations.
 */

INT_PTR WINAPI
HeapMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghWnd = hWnd;
            CheckRadioButton(hWnd, IDC_SORTCFLAG, IDC_SORTSIZE, idSort);
            SetRGBValues();
            SetWindowTitle(hWnd, "Heap Monitor - %s");
            fDlgUp = TRUE;
            RefreshHeapView(hWnd);
            ShowWindow(hWnd, SW_SHOW);
            break;

        case WM_SYSCOLORCHANGE:
            SetRGBValues();
            RefreshHeapView(hWnd);
            break;

        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            DrawItem((WORD)(((LPDRAWITEMSTRUCT)lParam)->CtlID),
                    (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_COMPAREITEM:
            return CompareItem((UINT)wParam, (COMPAREITEMSTRUCT *)lParam);

        case WM_PAINT:
            if (IsIconic(hWnd))
                BltIcon(hWnd);

            return FALSE;

        case WM_ERASEBKGND:
            return IsIconic(hWnd);

        case WM_CLOSE:
            if (ghBlockWnd)
                SendMessageA(ghBlockWnd, WM_CLOSE, 0, 0L);
            fDlgUp = FALSE;
            return EndDialog(hWnd, 0);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_REFRESH:
                    RefreshHeapView(hWnd);
                    break;

                case IDC_VIRTUAL:
                    DoMemoryBrowse(g_hinstMain, hWnd, GetCurrentProcessId());
                    break;

                case IDC_DUMPHEAPS:
                    DbgExDumpProcessHeaps();
                    break;

                case IDC_SORTCFLAG:
                case IDC_SORTTYPE:
                case IDC_SORTNAME:
                case IDC_SORTADDRESS:
                case IDC_SORTALLOC:
                case IDC_SORTSIZE:
                    idSort = GET_WM_COMMAND_ID(wParam, lParam);
                    CheckRadioButton(hWnd, IDC_SORTCFLAG, IDC_SORTSIZE, idSort);
                    RefreshHeapView(hWnd);
                    break;

                case IDC_BLOCKLIST:
                    BlockListNotify(GET_WM_COMMAND_CMD(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam));
                    break;

                case IDC_SHOWMETERS:
                    g_fShowMeters = !!IsDlgButtonChecked(hWnd, IDC_SHOWMETERS);
                    RefreshHeapView(hWnd);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*
 -  MeasureItem
 -
 *  Purpose:
 *      Returns the height of the system font since that's what we draw with.
 *
 *  Parameters:
 *      hwnd        hwnd of dialog
 *      pmis        measureitemstruct from WM_MEASUREITEM call
 */

void MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis)
{
    HDC         hDC = GetDC(hwnd);
    HANDLE      hFont;
    TEXTMETRICA tm;

    if (hDC)
    {
        hFont = GetStockObject(SYSTEM_FONT);

        hFont = SelectObject(hDC, hFont);
        GetTextMetricsA(hDC, &tm);
        SelectObject(hDC, hFont);
        ReleaseDC(hwnd, hDC);

        pmis->itemHeight = tm.tmHeight;
    }
    else
        pmis->itemHeight = 0;
}

/*
 -  CompareItem
 -
 *  Purpose:
 *      Based on the specified sort order, we evaluate the two blocks
 *      handed to us.  We return -1 if the first one goes before the
 *      second one, zero if they are equal (never happens), and 1 if
 *      the first one goes after the second one.  We apply a secondary
 *      sort to the 2 fields that could potentially be equal: Name &
 *      Size.  The secondary sort is on ulAllocNum which is always
 *      unique.  This just in: we now do a desending sort on Size and
 *      AllocNum since the user is most likely interested in seeing the
 *      largest blocks or the most recently allocated blocks at the top.
 */
int CompareItem(UINT idCtl, LPCOMPAREITEMSTRUCT pcis)
{
    INT_PTR iOrder = 0, i1, i2;
    PDBGAH  pdbgah1, pdbgah2;
    char    achType[1024];

    if (idCtl != IDC_BLOCKLIST)
        goto ret;

    {
        LOCK_GLOBALS;

        pdbgah1 = (PDBGAH)pcis->itemData1;
        pdbgah2 = (PDBGAH)pcis->itemData2;

        if (!FBlockStillValid(pdbgah1) || !FBlockStillValid(pdbgah2))
            goto ret;

        switch (idSort)
        {
            case IDC_SORTCFLAG:
                i1 = ((!!pdbgah1->fCoFlag) << 1) + !!pdbgah1->fLeaked;
                i2 = ((!!pdbgah2->fCoFlag) << 1) + !!pdbgah2->fLeaked;
                iOrder = i1 - i2;
                break;

            case IDC_SORTTYPE:
                if (g_fShowMeters)
                    iOrder = lstrcmpA(DbgExMtGetName(pdbgah1->mt), DbgExMtGetName(pdbgah2->mt));
                else
                {
                    lstrcpynA(achType, GetRunTimeType(ClientFromActual(pdbgah1)), ARRAY_SIZE(achType));
                    iOrder = lstrcmpA(achType, GetRunTimeType(ClientFromActual(pdbgah2)));
                }
                break;

            case IDC_SORTNAME:
                if (g_fShowMeters)
                    iOrder = lstrcmpA(DbgExMtGetDesc(pdbgah1->mt), DbgExMtGetDesc(pdbgah2->mt));
                else
                    iOrder = lstrcmpA(pdbgah1->szName, pdbgah2->szName);
                break;

            case IDC_SORTADDRESS:
                iOrder = (INT_PTR)ClientFromActual(pdbgah1) - (INT_PTR)ClientFromActual(pdbgah2);
                break;

            case IDC_SORTSIZE:
                iOrder =    ((int)pdbgah2->cbRequest - (int)pdbgah2->cbHeader)
                         -  ((int)pdbgah1->cbRequest - (int)pdbgah1->cbHeader);
                break;
        }

        if (iOrder == 0)
        {
            iOrder = (int)pdbgah2->iAllocated - (int)pdbgah1->iAllocated;
        }

        if (iOrder < 0)
            iOrder = -1;
        else if (iOrder > 0)
            iOrder = 1;
        else
            iOrder = 0;
    }

ret:
    return (int)iOrder;
}

/*
 -  DrawItem
 -
 *  Purpose:
 *      Handles WM_DRAWITEM for both Heap combo-box and Block List.
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        LPDRAWITEMSTRUCT passed from the WM_DRAWITEM message.
 */

VOID DrawItem(WORD wId, LPDRAWITEMSTRUCT pdis)
{
    COLORREF    crText = 0, crBack = 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if(pdis->itemState & ODS_SELECTED)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        // parse and spit out bmps and text
        OutTextFormat(wId, pdis);

        // Restore original colors if we changed them above.
        if(pdis->itemState & ODS_SELECTED)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}


/*
 -  OutTextFormat
 -
 *  Purpose:
 *      Used to format and 'TextOut' both Heap combo-box items and
 *      Block List items.  Parsing evaluates the string as follows:
 *      otherwise, outtext the line
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        from DrawItem from WM_DRAWITEM msg
 */

void OutTextFormat(WORD wId, LPDRAWITEMSTRUCT pdis)
{
    char szItem[512];

    LOCK_GLOBALS;

    if (wId == IDC_HEAPLIST)
    {
        wsprintfA(szItem, "%s", "Process Heap");
        ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                    ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, szItem, lstrlenA(szItem), NULL);
    }
    else if (wId == IDC_BLOCKLIST)
    {
        PDBGAH  pdbgah  = (PDBGAH)pdis->itemData;
        BOOL    fFound  = FALSE;
        BOOL    fSearch = FALSE;

        if (FBlockStillValid(pdbgah))
        {
            if (g_pvMemSearch)
            {
                int    cb  = pdbgah->cbRequest - pdbgah->cbHeader;
                void **ppv = (void**)ClientFromActual(pdbgah);

                if (ppv == (void**)g_pvMemSearch)
                    fSearch = TRUE;

                while (cb >= sizeof(void*))
                {
                    if (*ppv == g_pvMemSearch)
                    {
                        fFound = TRUE;
                        break;
                    }
                    cb -= sizeof(void*);
                    ppv++;
                }
            }
            wsprintfA(szItem, "%c%c%c%c%7ld %8lX %6ld %-32.32s %s",
                pdbgah->fCoFlag ? 'C' : ' ',
                pdbgah->fLeaked ? 'L' : ' ',
                fFound          ? 'F' : ' ',
                fSearch         ? '>' : ' ',
                pdbgah->iAllocated,
                ClientFromActual(pdbgah),
                pdbgah->cbRequest - pdbgah->cbHeader,
                g_fShowMeters ? DbgExMtGetName(pdbgah->mt) : GetRunTimeType(ClientFromActual(pdbgah)),
                g_fShowMeters ? DbgExMtGetDesc(pdbgah->mt) : pdbgah->szName);

            ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                        ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, szItem, lstrlenA(szItem), NULL);
        }
    }
}


/*
 -  SetRGBValues
 -
 *  Purpose:
 *      To set various system colors in static variables.  Called at
 *      init time and when system colors change.
 */

VOID SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}


/*
 -  SetSumSelection
 -
 *  Purpose:
 *      Calcualtes to total size of the blocks selected in the Block
 *      List list-box (which is a multi-selction listbox).
 */

void SetSumSelection(void)
{
    int     i;
    int     *rgIdx = NULL;
    LONG    cSel;
    size_t  cbTotal = 0;
    char    szBuff[64];
    PDBGAH  pdbgah;

    LOCK_GLOBALS;

    cSel = SendDlgItemMessageA(ghWnd, IDC_BLOCKLIST, LB_GETSELCOUNT, 0, 0L);

    if (cSel > 0)
    {
        rgIdx = (int *)LocalAlloc(LPTR, cSel*sizeof(int));
        cSel = 0;
        if (rgIdx)
            cSel = SendDlgItemMessageA(ghWnd, IDC_BLOCKLIST, LB_GETSELITEMS, cSel, (LPARAM)rgIdx);
    }

    // Note that rgIdx must be non-null if cSel > 0
    for (i = 0; i < cSel; i++)
    {
        pdbgah = (PDBGAH)SendDlgItemMessageA(ghWnd, IDC_BLOCKLIST,
                LB_GETITEMDATA, rgIdx[i], 0L);

        if (FBlockStillValid(pdbgah))
            cbTotal += pdbgah->cbRequest - pdbgah->cbHeader;
    }

    if (cbTotal == 0)
        szBuff[0] = 0;
    else
        wsprintfA(szBuff, "%7ld Bytes Selected", cbTotal);
    SetDlgItemTextA(ghWnd, IDE_SUMSEL, szBuff);

    if (rgIdx)
    {
        LocalFree((HGLOBAL)rgIdx);
    }
}

/*
 -  FormatBlockRow
 -
 *  Purpose:
 *      Converts the 16 bytes following the memory address at lpbRow
 *      as 4 hex DWORDs, or 8 hex WORDs, or 16 hex BYTEs and as 16
 *      printable characters.  A string is than constructed as follows:
 *
 *      ADDRESS \t DWORD1 \t DWORD2 \t DWORD3 \t DWORD4 \t CH1 \t ... \t CH16
 *  or
 *      ADDRESS \t WORD1  \t WORD2  \t ...    \t WORD8  \t CH1 \t ... \t CH16
 *  or
 *      ADDRESS \t BYTE1  \t BYTE2  \t ...    \t BYTE16 \t CH1 \t ... \t CH16
 *
 *      This string is then output to the list box in the BlockEditDlg.
 */

void FormatBlockRow(LPSTR psz, BYTE * pbRow, BYTE * pbBase, UINT cbRequest, BYTE * pbReal)
{
    UINT   cbRow = min((UINT)16, (UINT)(cbRequest - (pbRow - pbBase)));
    UINT   cbLine;
    BYTE * pb;
    UINT   ib, ich;
    int    c;

    psz += wsprintfA(psz, "%08lX [+%04lX] ", pbReal + (pbRow - pbBase), pbRow - pbBase);

    if (idDataType == IDC_DWORD)
        cbLine = (8*4) + 3;
    else if (idDataType == IDC_WORD)
        cbLine = (4*8) + 7;
    else
        cbLine = (2*16) + 15;

    memset(psz, ' ', cbLine);

    for (ib = 0, pb = pbRow; ib < cbRow; ++ib, ++pb)
    {
        if (idDataType == IDC_DWORD)
            ich = 2*(3 - (ib%4)) + 9*(ib/4);
        else if (idDataType == IDC_WORD)
            ich = 2*(1 - (ib%2)) + 5*(ib/2);
        else
            ich = 3*ib;

        c = (*pb & 0xF);
        psz[ich+1] = (char) (c + ((c < 10) ? '0' : ('A' - 10)));
        c = (*pb & 0xF0) >> 4;
        psz[ich] = (char) (c + ((c < 10) ? '0' : ('A' - 10)));
    }

    psz += cbLine;
    memset(psz, ' ', 2 + 16);
    psz += 2;

    psz[16] = 0;

    for (ib = 0, pb = pbRow; ib < cbRow; ++ib, ++pb)
    {
        if (*pb > 31 && *pb < 128)
            *psz++ = *pb;
        else
            *psz++ = '.';
    }
}


/*
 -  OutBlockRowFormat
 -
 *  Purpose:
 *      Used to format and 'TextOut' the items in the Block Memory
 *      Edit list-box.  Parsing evaluates the string as follows:
 *      otherwise, outtext the line
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        from DrawItem from WM_DRAWITEM msg
 *      pdbgah      Pointer to the block we are editing
 */

void OutBlockRowFormat(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah)
{
    char szItem[256];

    if (wId != IDC_BE_MEMORY)
        return;

    FormatBlockRow(szItem, (LPBYTE)pdis->itemData,
            (LPBYTE)(pdbgah + 1) + pdbgah->cbHeader,
            pdbgah->cbRequest - pdbgah->cbHeader,
            (LPBYTE)(*(DWORD_PTR *)pdbgah->adwGuard));

    //  Draw the text
    ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
        ETO_OPAQUE, &pdis->rcItem, szItem, lstrlenA(szItem), NULL);
}


/*
 -  DrawBlockRow
 -
 *  Purpose:
 *      Handles WM_DRAWITEM for a row in the Block Memory Edit list-box.
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        LPDRAWITEMSTRUCT passed from the WM_DRAWITEM message.
 *      pdbgah      Pointer to the block we are editing
 */

void DrawBlockRow(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah)
{
    COLORREF    crText = 0, crBack = 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if(pdis->itemState & ODS_SELECTED)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        // parse and spit out bmps and text
        OutBlockRowFormat(wId, pdis, pdbgah);

        // Restore original colors if we changed them above.
        if(pdis->itemState & ODS_SELECTED)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}


/*
 -  SetBlockEditData
 -
 *  Purpose:
 *      Fills in all the fields on the Block Memory Edit dialog.  Adds
 *      data items to the owner-drawn memory list-box.  Data items are
 *      pointers into every 16 bytes of the memory in the block.  The
 *      owner-draw code then formats each data item in a human readable
 *      format much like a memory window in a debugger.
 *
 *  NOTE:
 *      The initialization of lpb is (pdbgah + 1) instead of
 *      RequestFromActual(pdbgah) because this is not the real block, it is a
 *      copy of the real block and the data is appended to the end of
 *      this copy (see BlockListNotify() function).  THIS IS BY DESIGN!
 */

void SetBlockEditData(HWND hWnd, PDBGAH pdbgah)
{
    UINT    i;
    char    szOutBuff[1024];
    ULONG   cb = pdbgah->cbRequest - pdbgah->cbHeader;
    LPBYTE  lpb = (LPBYTE)(pdbgah + 1) + pdbgah->cbHeader;
    LPBYTE  lpbEnd;
    LPSTR   pszType;

    SendDlgItemMessageA(hWnd, IDC_BE_MEMORY, LB_RESETCONTENT, 0, 0L);
    SendDlgItemMessageA(hWnd, IDC_CALLSTACK, LB_RESETCONTENT, 0, 0L);

    pszType = GetRunTimeType(ClientFromActual(pdbgah));

    if (*pszType == 0 && *pdbgah->szName == 0)
        wsprintfA(szOutBuff, "Memory - 0x%08lX", pdbgah->adwGuard[0]);
    else
        wsprintfA(szOutBuff, "Memory - %s%s%s", pszType, pszType ? " " : "",
            pdbgah->szName);
    SetWindowTextA(hWnd, szOutBuff);

    if (DbgExIsTagEnabled(tagLeaks))
    {
        INET_SYMBOL_INFO * psi = (pdbgah->fSymbols) ? SymbolsFromBlock(pdbgah) : NULL;
        CHAR achSymbol[256];

        for (i = 0; i < ARRAY_SIZE(pdbgah->dwEip); i++)
        {
            if (!pdbgah->dwEip[i])
                break;

            GetStringFromSymbolInfo(pdbgah->dwEip[i],
                                    (psi) ? psi + i : NULL,
                                    achSymbol);

            LPSTR psz = achSymbol;

            while (*psz == ' ')
                ++psz;

            SendDlgItemMessageA(hWnd, IDC_CALLSTACK, LB_ADDSTRING, 0, (LPARAM)psz);
        }
    }

    for (lpbEnd = lpb + cb; lpb < lpbEnd; lpb += 16)
        SendDlgItemMessageA(hWnd, IDC_BE_MEMORY, LB_ADDSTRING, 0, (LPARAM)lpb);
}

/*
 -  BlockDlgProc
 -
 *  Purpose:
 *      This is the dialog procedure for the Block Memory Edit dialog
 *      box.  This dialog displays a block of memory much like a
 *      debugger would.  This is a read-only display of the memory.
 */

INT_PTR WINAPI
BlockDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PDBGAH   pdbgah;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghBlockWnd = hWnd;
            pdbgah = (PDBGAH)lParam;
            CheckRadioButton(hWnd, IDC_DWORD, IDC_BYTE, idDataType);
            SetBlockEditData(hWnd, pdbgah);
            break;

        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            DrawBlockRow((WORD)(((LPDRAWITEMSTRUCT)lParam)->CtlID),
                    (LPDRAWITEMSTRUCT)lParam, pdbgah);
            break;

        case WM_CLOSE:
            ghBlockWnd = NULL;
            EndDialog(hWnd, 0);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_DWORD:
                case IDC_WORD:
                case IDC_BYTE:
                    idDataType = LOWORD(wParam);
                    CheckRadioButton(hWnd, IDC_DWORD, IDC_BYTE, idDataType);
                    SetBlockEditData(hWnd, pdbgah);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


void    ViewBlock(HWND phWnd, LPVOID lpcBlock)
{
    DialogBoxParamA(g_hinstMain,
            MAKEINTRESOURCEA(IDD_BLOCKEDIT),
            phWnd, BlockDlgProc, (LPARAM) lpcBlock);
}

// Virtual Memory Browser -----------------------------------------------------

struct LONGDATA
{
   DWORD dwValue;
   LPCSTR szText;
};

#ifndef MEM_IMAGE
#define SEC_FILE           0x800000
#define SEC_IMAGE         0x1000000
#define SEC_RESERVE       0x4000000
#define SEC_COMMIT        0x8000000
#define SEC_NOCACHE      0x10000000
#define MEM_IMAGE         SEC_IMAGE
#endif

#define TABLEENTRY(Prefix, Value)        Prefix##Value, #Value

LONGDATA PageFlags[] = {
   TABLEENTRY(PAGE_, NOACCESS),
   TABLEENTRY(PAGE_, READONLY),
   TABLEENTRY(PAGE_, READWRITE),
   TABLEENTRY(PAGE_, WRITECOPY),
   TABLEENTRY(PAGE_, EXECUTE),
   TABLEENTRY(PAGE_, EXECUTE_READ),
   TABLEENTRY(PAGE_, EXECUTE_READWRITE),
   TABLEENTRY(PAGE_, EXECUTE_WRITECOPY),
   TABLEENTRY(PAGE_, GUARD),
   TABLEENTRY(PAGE_, NOCACHE),
   TABLEENTRY(0, 0)
};

LONGDATA MemFlags[] = {
   TABLEENTRY(MEM_, COMMIT),
   TABLEENTRY(MEM_, RESERVE),
   TABLEENTRY(MEM_, DECOMMIT),
   TABLEENTRY(MEM_, RELEASE),
   TABLEENTRY(MEM_, FREE),
   TABLEENTRY(MEM_, PRIVATE),
   TABLEENTRY(MEM_, MAPPED),
   TABLEENTRY(MEM_, TOP_DOWN),
   TABLEENTRY(MEM_, IMAGE),
   TABLEENTRY(0, 0)
};

#define COLS        16


extern DWORD   rgbWindowColor;
extern DWORD   rgbHiliteColor;
extern DWORD   rgbWindowText;
extern DWORD   rgbHiliteText;
extern DWORD   rgbGrayText;
extern DWORD   rgbDDWindow;
extern DWORD   rgbDDHilite;

int         tabs[COLS];
HANDLE      hProcess;

void    ViewBlock(HWND phWnd, LPVOID lpcBlock);
extern  void SetRGBValues(VOID);

int         cols[COLS] = {70, 13, 70, 11, 11, 11, 11, 65, 11, 11, 11, 11, 11, 65, 80, 92};

/////////////////////////////////////////////////////////////


LPCSTR GetAllocFlagStr(DWORD dwFlag)
{
    static char sszBuffer[20];

    sszBuffer[0] = '\0';

    if (dwFlag & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE))
        lstrcatA(sszBuffer, "R");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "W");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "X");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "C");
    else
        lstrcatA(sszBuffer, ".");

    return sszBuffer;
}

LPCSTR GetCurrentFlagStr(DWORD dwFlag)
{
    static char sszBuffer[20];

    sszBuffer[0] = '\0';

    if (dwFlag & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE))
        lstrcatA(sszBuffer, "R");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "W");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "X");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "C");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_GUARD))
        lstrcatA(sszBuffer, "G");
    else
        lstrcatA(sszBuffer, ".");

    return sszBuffer;
}


LPCSTR GetStateStr (DWORD dwFlag)
{
   if (dwFlag == MEM_COMMIT) return "C";
   if (dwFlag == MEM_RESERVE) return "R";
   if (dwFlag == MEM_FREE) return "F";

   return "?";
}


LPCSTR  GetFlagStr(DWORD dwFlag)
{
    if (dwFlag == MEM_PRIVATE) return "Private";
    if (dwFlag == MEM_MAPPED) return "Mapped";
    if (dwFlag == MEM_TOP_DOWN) return "Top Down";
    if (dwFlag == MEM_IMAGE) return "Image";

    return "Unknown";
}


/*
 * IsGlobalLocalHeap
 *
 *  Takes a Base Address of a chunk of memory, returns TRUE if this Base
 *  is in a Local or Global heap
 *
 */

UINT IsGlobalLocalHeap(LPVOID   lpBaseAddress)
{
    if (lpBaseAddress == GetProcessHeap())
        return 1;

    return 0;
}

/////////////////////////////////////////////////////////////

void ConstructMemInfoLine (PMEMORY_BASIC_INFORMATION pMBI,
   LPSTR szLine) {

   LPCSTR sz;

   // BaseAddress
   wsprintfA(szLine, "%08X\t", pMBI->BaseAddress);

   // State
   wsprintfA(strchr(szLine, 0), "%s\t", GetStateStr(pMBI->State));

   // AllocationBase
   if ((pMBI->BaseAddress != pMBI->AllocationBase) && pMBI->State != MEM_FREE)
        wsprintfA(strchr(szLine, 0), "%08X\t", pMBI->AllocationBase);
    else
        lstrcatA(szLine, "\t");

   // AllocationProtect
   if (pMBI->State != MEM_FREE)
      sz = GetAllocFlagStr(pMBI->AllocationProtect);
   else
      sz = "\t\t\t";

   wsprintfA(strchr(szLine, 0), "%s\t", sz);

   // RegionSize
   wsprintfA(strchr(szLine, 0), "%05lX\t",
      pMBI->RegionSize / 4096);


   // Protect
   if ((pMBI->State != MEM_FREE) &&
       (pMBI->State != MEM_RESERVE))
   {
      sz = GetCurrentFlagStr(pMBI->Protect);
   }
   else
      sz = "\t\t\t\t";

   wsprintfA(strchr(szLine, 0), "%s\t", sz);

   // Type
   if (pMBI->State != MEM_FREE)
   {
      sz = GetFlagStr(pMBI->Type);
   }
   else
      sz = "";

   wsprintfA(strchr(szLine, 0), "%s", sz);
}

UINT        IsAppBasedOk(PMEMORY_BASIC_INFORMATION pMBI, LPSTR lpText, HANDLE hProc)
{
    UINT                        iRet = 0;
    LPBYTE                      lpBase;
    PIMAGE_DOS_HEADER           dosHeader;
    PIMAGE_NT_HEADERS           pNTHeader;
    PIMAGE_SECTION_HEADER       pSection;
    PIMAGE_SECTION_HEADER       pEData = NULL;
    PIMAGE_EXPORT_DIRECTORY     pExport;
    LPBYTE                      lpMyBase;
    char                        lsDLLName[256];

    lpBase = (LPBYTE)pMBI->AllocationBase;

    lpMyBase = (LPBYTE)VirtualAlloc(NULL, pMBI->RegionSize, MEM_COMMIT, PAGE_READWRITE);
    if (!lpMyBase)
        return 0;

    if (ReadProcessMemory(hProc, lpBase, lpMyBase, pMBI->RegionSize, NULL))
    {
        dosHeader = (PIMAGE_DOS_HEADER) lpMyBase;

        if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE)
        {
            pNTHeader = (PIMAGE_NT_HEADERS) (lpMyBase + dosHeader->e_lfanew);
            if (!IsBadReadPtr(pNTHeader, sizeof(IMAGE_NT_HEADERS)) && (pNTHeader->Signature == IMAGE_NT_SIGNATURE))
            {
                UINT        liI;

                /* Are we at the right base? */
                if (pNTHeader->OptionalHeader.ImageBase != (ULONG_PTR) lpBase)
                    iRet = 2;
                else
                    iRet = 1;

                lstrcatA(lpText, "\t");
                pSection = IMAGE_FIRST_SECTION(pNTHeader);
                for (liI = 0; liI < pNTHeader->FileHeader.NumberOfSections; liI++)
                {
                    if (    lstrlenA((char *)pSection->Name) == 6
                        &&  !lstrcmpA(".edata", (char *)pSection->Name))
                        pEData = pSection;

                    if ((lpBase + pSection->VirtualAddress) == pMBI->BaseAddress)
                    {
                        char        lsTemp[16];

                        wsprintfA(lsTemp, "%-8.8s", pSection->Name);
                        lstrcatA(lpText, lsTemp);
                    }

                    pSection++;
                }


                /* Is this a DLL? */
                if (pEData)
                {

                    pExport = (PIMAGE_EXPORT_DIRECTORY)
                        VirtualAlloc(NULL,
                            sizeof(IMAGE_EXPORT_DIRECTORY),
                            MEM_COMMIT, PAGE_READWRITE);

                    if (pExport != NULL)
                    {
                        ReadProcessMemory(hProc,
                            (lpBase + pEData->VirtualAddress),
                            pExport,
                            sizeof(IMAGE_EXPORT_DIRECTORY),
                            NULL);

                        ReadProcessMemory(hProc,
                            (lpBase + pExport->Name),
                            lsDLLName,
                            256,
                            NULL);

                        lstrcatA(lpText, "\t");
                        lstrcatA(lpText, lsDLLName);

                        if (iRet == 2)
                        {
                            wsprintfA(lsDLLName, "\t(%08lX)", pNTHeader->OptionalHeader.ImageBase);
                            lstrcatA(lpText, lsDLLName);
                        }

                        VirtualFree(pExport, 0, MEM_RELEASE);
                    }

                }



            }

        }
    }

    VirtualFree(lpMyBase, 0, MEM_RELEASE);

    return iRet;
}


void    SetTheColour(LPDRAWITEMSTRUCT lpdis, PMEMORY_BASIC_INFORMATION pMBI, LPSTR  lpText)
{
    UINT        iHeapType;

    if (pMBI->State == MEM_FREE)
    {
        SetTextColor(lpdis->hDC, GetSysColor(COLOR_BTNFACE));
        return;
    }

    if (pMBI->State == MEM_RESERVE)
    {
        PMEMORY_BASIC_INFORMATION   pNext = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lpdis->hwndItem, lpdis->itemID + 1);
        if ((((ULONG_PTR)pNext) != (ULONG_PTR)(-1)) && (pNext->Protect & PAGE_GUARD))
        {
            SetTextColor(lpdis->hDC, RGB(0, 0, 128));   // Stack
            return;
        }
    }

    if (pMBI->State == MEM_COMMIT)
    {
        UINT        iIsApp;

        if (pMBI->Protect & PAGE_GUARD)
        {
            SetTextColor(lpdis->hDC, RGB(0, 0, 128));   // Stack
            return;
        }
        else
        {
            PMEMORY_BASIC_INFORMATION   pPrev = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lpdis->hwndItem, lpdis->itemID - 1);
            if (pPrev->Protect & PAGE_GUARD)
            {
                SetTextColor(lpdis->hDC, RGB(0, 0, 128));   // Stack
                return;
            }
        }

        iIsApp = IsAppBasedOk(pMBI, lpText, hProcess);

        if (iIsApp == 1)
        {
            SetTextColor(lpdis->hDC, RGB(0, 128, 0));   // Image
            return;
        }
        else if (iIsApp == 2)
        {
            SetTextColor(lpdis->hDC, RGB(255, 0, 0));   // Image based badly
            return;
        }
    }

    iHeapType = IsGlobalLocalHeap(pMBI->AllocationBase);
    if (iHeapType == 1)
    {
        SetTextColor(lpdis->hDC, RGB(255, 0, 255)); // Our Heaps - Magenta
        return;
    }
    else if (iHeapType == 2)
    {
        SetTextColor(lpdis->hDC, RGB(0, 255, 255)); // Our Debug Heaps - Cyan
        return;
    }


    SetTextColor(lpdis->hDC, GetSysColor(COLOR_BTNTEXT));
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DrawEntireItem(LPDRAWITEMSTRUCT, int)                      *
 *                                                                          *
 ****************************************************************************/
VOID APIENTRY DrawEntireItem(
        LPDRAWITEMSTRUCT        lpdis,
        INT                     inflate)
{
    char     szLine[300];
    COLORREF crText = 0, crBack = 0;

    /* Draw line here */
    if (lpdis->itemState & ODS_SELECTED)
    {
        // Select the appropriate text colors
        crText = SetTextColor(lpdis->hDC, rgbHiliteText);
        crBack = SetBkColor(lpdis->hDC, rgbHiliteColor);
    }
    memset(szLine, ' ', sizeof(szLine) - 1);
    TextOutA(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, szLine, sizeof(szLine));

    if (lpdis->itemState & ODS_SELECTED)
    {
        SetTextColor(lpdis->hDC, crText);
        SetBkColor(lpdis->hDC,   crBack);
    }

    ConstructMemInfoLine((PMEMORY_BASIC_INFORMATION) lpdis->itemData, szLine);

    SetTheColour(lpdis, (PMEMORY_BASIC_INFORMATION) lpdis->itemData, szLine);
    if (lpdis->itemState & ODS_SELECTED)
    {
        // Select the appropriate text colors
        crText = SetTextColor(lpdis->hDC, rgbHiliteText);
        crBack = SetBkColor(lpdis->hDC, rgbHiliteColor);
    }

    TabbedTextOutA(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, szLine, lstrlenA(szLine), COLS, tabs, 0);

    // Restore original colors if we changed them above.
    if (lpdis->itemState & ODS_SELECTED)
    {
        SetTextColor(lpdis->hDC, crText);
        SetBkColor(lpdis->hDC,   crBack);
    }
}


LPSTR       ReverseString(LPSTR  lpcString)
{
    LPSTR   lpcEnd = lpcString + lstrlenA(lpcString) / 2;
    LPSTR   lpcStart;
    char    lcChar;

    lpcStart = lpcEnd - !(lstrlenA(lpcString) % 2);

    while (*lpcEnd)
    {
        lcChar = *lpcStart;
        *lpcStart = *lpcEnd;
        *lpcEnd = lcChar;

        lpcStart--;
        lpcEnd++;
    }

    return(lpcString);
}


LPSTR       DoCommas(DWORD      dwVal)
{
    static  char    szTemp[20];
    UINT            iDigitCount = 0;
    UINT            iCharCount = 0;

    while (dwVal)
    {
        szTemp[iCharCount++] = (char) ((dwVal % 10) + '0');
        iDigitCount++;
        dwVal /= 10;
        if (dwVal && ((iDigitCount % 3) == 0))
            szTemp[iCharCount++] = ',';
    }

    szTemp[iCharCount] = '\0';
    return ReverseString(szTemp);
}


void            RemoveTabs(LPSTR lpcTabbed, LPSTR lpcNoTab)
{
    UINT        iTabs = 0;
    UINT        iCharsSinceLast = 0;

    while (*lpcTabbed)
    {
        if (*lpcTabbed == '\t')
        {
            UINT        iCharsToTab = (cols[iTabs] / 4);

            if (iCharsToTab > iCharsSinceLast)
                iCharsToTab -= iCharsSinceLast;
            else
                iCharsToTab = 1;

            while (iCharsToTab--)
                *lpcNoTab++ = ' ';

            iTabs++;
            iCharsSinceLast = 0;
        }
        else
        {
            *lpcNoTab++ = *lpcTabbed;
            iCharsSinceLast++;
        }

        lpcTabbed++;
    }
    *lpcNoTab = '\0';
}

void    WINAPI  DumpMemoryList(HWND phList)
{
    OFSTRUCT        ofFile;
    char            szMemLine[300];
    char            szMemLineNoTabs[350];
    HFILE           lhFile;
    UINT            liLines = ListBox_GetCount(phList);
    UINT            liI;
    DWORD_PTR       itemData;

    lhFile = OpenFile("c:\\virtual.dmp", &ofFile, OF_CREATE);

    AssertSz(lhFile != NULL, "Failed to open file.");
    if (lhFile != NULL)
    {
        for (liI = 0; liI < liLines; liI++)
        {
            itemData = ListBox_GetItemData(phList, liI);

            ConstructMemInfoLine((PMEMORY_BASIC_INFORMATION) itemData, szMemLine);
            IsAppBasedOk((PMEMORY_BASIC_INFORMATION) itemData, szMemLine, hProcess);

            RemoveTabs(szMemLine, szMemLineNoTabs);

            _lwrite((HFILE) lhFile, szMemLineNoTabs, lstrlenA(szMemLineNoTabs));
            _lwrite((HFILE) lhFile, "\r\n", 2);
        }

        _lclose(lhFile);
    }
}


INT_PTR CALLBACK MemBrowseProc(HWND phDlg, UINT puMessage, WPARAM pwParam, LPARAM plParam)
{
    static DWORD    dwProcessID;

    switch (puMessage)
    {

        case WM_INITDIALOG:
            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                                    TRUE, plParam);

            SetWindowTitle(phDlg, "Virtual Memory Viewer - %s");
            SendMessageA(phDlg, WM_COMMAND, GET_WM_COMMAND_MPS(0, 0, ID_REFRESH));
            break;

        case WM_DRAWITEM:
            {
                LPDRAWITEMSTRUCT    lpdis;

                /* Get pointer to the DRAWITEMSTRUCT */
                lpdis = (LPDRAWITEMSTRUCT) plParam;

                if ((ODA_FOCUS & lpdis->itemAction) || (ODS_FOCUS & lpdis->itemState))
                    DrawFocusRect(lpdis->hDC, &lpdis->rcItem);
                else
                    DrawEntireItem(lpdis, -2);

                /* Return TRUE meaning that we processed this message. */
                return(TRUE);
            }
            break;

        case WM_MEASUREITEM:
            {
                LPMEASUREITEMSTRUCT lpmis;
                lpmis = (LPMEASUREITEMSTRUCT) plParam;

                /* All the items are the same height since the list box style is
                 * LBS_OWNERDRAWFIXED
                 */
                lpmis->itemHeight = 16;
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(pwParam, plParam))
            {
                case ID_REFRESH:
                    {
                        ULONG ulTotalMem = 0, ulCodeMem = 0, ulDataMem = 0;
                        ULONG ulReserveMem = 0, ulReadOnly = 0, ulReadWrite = 0;

                        dwProcessID = plParam;

                        {
                           MEMORY_BASIC_INFORMATION     MemoryBasicInfo;
                           PMEMORY_BASIC_INFORMATION    lpMem;
                           PVOID lpAddress = 0;
                           char szLine[200];
                           int          cols[COLS] = {70, 13, 70, 11, 11, 11, 11, 65, 11, 11, 11, 11, 11, 65, 80, 92};
                           HWND         lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);
                           UINT         i, j, nCol = 0;

                            for (i = 0; i < COLS; i++)
                            {
                                tabs[i] = 5 + nCol + cols[i];
                                nCol += cols[i] + 5;
                            }

                            /* Free up the list memory */
                            i = ListBox_GetCount(lhList);
                            for (j = 0; j < i; j++)
                            {
                                lpMem = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, j);
                                LocalFree(lpMem);
                            }

                            ListBox_ResetContent(lhList);

                            ListBox_SetTabStops(lhList, 6, &tabs);

                           // Walk the virtual address space, adding
                           // entries to the list box.

                           do {
                              int x = VirtualQueryEx(hProcess, lpAddress, &MemoryBasicInfo,
                                 sizeof(MemoryBasicInfo));

                              if (x != sizeof(MemoryBasicInfo)) {
                                 // Attempt to walk beyond the range
                                 // that Windows NT allows.
                                 break;
                              }

                              szLine[0] = '\0';
                              lpMem = (PMEMORY_BASIC_INFORMATION)LocalAlloc(LMEM_FIXED, sizeof(MEMORY_BASIC_INFORMATION));
                              if (lpMem == NULL)
                              {
                                  AssertSz (0, "Insufficient memory for debugging.");
                                  continue;
                              }

                              *lpMem = MemoryBasicInfo;

                              // Construct the line to be displayed, and
                              // add it to the list box.

                              if (MemoryBasicInfo.State != MEM_FREE)
                              {
                                  if (MemoryBasicInfo.State == MEM_RESERVE)
                                      ulReserveMem += (ULONG)MemoryBasicInfo.RegionSize;
                                  else
                                  {
                                      if (IsAppBasedOk(lpMem, szLine, hProcess))
                                          ulCodeMem += (ULONG)MemoryBasicInfo.RegionSize;
                                      else
                                          ulDataMem += (ULONG)MemoryBasicInfo.RegionSize;

                                      ulTotalMem += (ULONG)MemoryBasicInfo.RegionSize;
                                  }

                                  if (MemoryBasicInfo.Protect & (PAGE_READONLY | PAGE_EXECUTE_READ))
                                      ulReadOnly += (ULONG)MemoryBasicInfo.RegionSize;
                                  else
                                      if (MemoryBasicInfo.Protect & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
                                          ulReadWrite += (ULONG)MemoryBasicInfo.RegionSize;
                              }

                              ListBox_AddString(lhList, (ULONG_PTR)lpMem);

                              // Get the address of the next region to test.
                              lpAddress = ((BYTE *) MemoryBasicInfo.BaseAddress) +
                                 MemoryBasicInfo.RegionSize;

                           } while (MemoryBasicInfo.RegionSize >= (4 * 1024));

                           wsprintfA(szLine, "%s", DoCommas(ulTotalMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_TOTALMEM), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulCodeMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_CODEMEM), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulDataMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_DATAMEM), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulReserveMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_RESERVEMEM), szLine);

                           wsprintfA(szLine, "%s", DoCommas(ulReadOnly));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_READONLY), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulReadWrite));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_READWRITE), szLine);
                        }
                    }
                    break;

                case ID_ADD:
                    {
                        int     liItemList[700];
                        HWND    lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);
                        int     liItems = ListBox_GetSelCount(lhList);
                        int     liI;
                        ULONG   ulSize = 0;
                        char    szText[150];

                        if (liItems)
                        {
                            ListBox_GetSelItems(lhList, liItems < 700 ? liItems : 700, liItemList);

                            for (liI = 0; liI < (liItems < 700 ? liItems : 700); liI++)
                            {
                                PMEMORY_BASIC_INFORMATION   pInfo;

                                pInfo = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, liItemList[liI]);
                                ulSize += (ULONG)pInfo->RegionSize;
                            }

                            wsprintfA(szText, "%ld (%08lX) bytes", ulSize, ulSize);
                            MessageBoxA(phDlg, szText, "Add Memory", MB_OK);
                        }
                    }
                    break;

                case ID_VIEW:
                    {
                        int     liItemList[1];
                        HWND    lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);
                        int     liItems = ListBox_GetSelCount(lhList);

                        if (liItems && (liItems == 1))
                        {
                            PMEMORY_BASIC_INFORMATION   pInfo;
                            ListBox_GetSelItems(lhList, 1, liItemList);

                            pInfo = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, liItemList[0]);

                            if (pInfo->State == MEM_COMMIT)
                            {
                                PDBGAH  pdbgahCopy;
                                ULONG   cb;

                                /* Construct a 4K pseudo Local block to pass to memory viewer */
                                cb = ActualSizeFromRequestSize(4000, FALSE);
                                pdbgahCopy = (PDBGAH) LocalAlloc(LPTR, cb);

                                if (pdbgahCopy != NULL)
                                {
                                    memset(pdbgahCopy, 0, cb);
                                    lstrcpyA(pdbgahCopy->szName, "Virtual Page");
                                    pdbgahCopy->cbRequest = 4000;

                                    ReadProcessMemory(hProcess,
                                        pInfo->BaseAddress,
                                        RequestFromActual(pdbgahCopy),
                                        4000,
                                        NULL);

                                    ViewBlock(phDlg, pdbgahCopy);
                                    LocalFree(pdbgahCopy);
                                }
                                else
                                    AssertSz(0, "Insufficient memory to debug.");
                            }
                            else
                                MessageBoxA(phDlg, "Only commited memory may be viewed", "View Memory", MB_OK);
                        }
                        else
                            MessageBoxA(phDlg, "Only one memory block may be viewed at a time", "View Memory", MB_OK);

                    }
                    break;

                case ID_DUMP:
                    DumpMemoryList(GetDlgItem(phDlg, IDC_TRACE_LIST));
                    MessageBoxA(phDlg, "Virtual Memory list dumped to 'C:\\VIRTUAL.DMP'", "Dump Memory", MB_OK);
                    break;

                case IDOK:
                case IDCANCEL:
                {
                    PMEMORY_BASIC_INFORMATION   lpMem;
                    UINT                        i, j;
                    HWND                        lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);

                    /* Free up the list memory */
                    i = ListBox_GetCount(lhList);
                    for (j = 0; j < i; j++)
                    {
                        lpMem = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, j);
                        LocalFree(lpMem);
                    }

                    EndDialog(phDlg, 0);
                    break;
                }
            }
            break;

        default: return FALSE; break;
    }
    return TRUE;
}


void WINAPI DoMemoryBrowse(HINSTANCE phInst, HWND phWnd, DWORD dwProcess)
{
    static BOOL     fInDialog = FALSE;

    if (!fInDialog)
    {
        fInDialog = TRUE;
        SetRGBValues();
        DialogBoxParamA(phInst, MAKEINTRESOURCEA(BROWSE_DLG), phWnd, MemBrowseProc, dwProcess);
        fInDialog = FALSE;
    }
}


DWORD   WINAPI  DoBrowseThread(LPVOID lpParam)
{
    Sleep(2000);
    DoMemoryBrowse(NULL, NULL, GetCurrentProcessId());
    return 0;
}


void        GetMemStats(LPSTR   lpcLine, HANDLE hProc)
{
    ULONG                       ulTotalMem = 0, ulCodeMem = 0, ulDataMem = 0;
    ULONG                       ulReserveMem = 0;
    MEMORY_BASIC_INFORMATION    MemoryBasicInfo;
    PVOID                       lpAddress = 0;
    char                        szTemp[250];

    // Walk the virtual address space, adding
    // entries to the list box.

    do
    {

        int x = VirtualQueryEx(hProc, lpAddress, &MemoryBasicInfo,
             sizeof(MemoryBasicInfo));

        szTemp[0] = '\0';
        if (x != sizeof(MemoryBasicInfo))
        {
             // Attempt to walk beyond the range
             // that Windows NT allows.
             break;
        }

        // Construct the line to be displayed, and
        // add it to the list box.

        if (MemoryBasicInfo.State != MEM_FREE)
        {
            if (MemoryBasicInfo.State == MEM_RESERVE)
                ulReserveMem += (ULONG)MemoryBasicInfo.RegionSize;
            else
            {
                if (IsAppBasedOk(&MemoryBasicInfo, szTemp, hProc))
                    ulCodeMem += (ULONG)MemoryBasicInfo.RegionSize;
                else
                    ulDataMem += (ULONG)MemoryBasicInfo.RegionSize;

                ulTotalMem += (ULONG)MemoryBasicInfo.RegionSize;
            }
        }

        // Get the address of the next region to test.
        lpAddress = ((BYTE *) MemoryBasicInfo.BaseAddress) +
             MemoryBasicInfo.RegionSize;

    } while (lpAddress != 0);

    wsprintfA(lpcLine, "%lu, %lu, %lu, %lu", ulTotalMem, ulCodeMem, ulDataMem, ulReserveMem);
}

#pragma warning(disable:4702)   //  Unreachable code below
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD   WINAPI  DoMemStats(LPVOID lpParam)
{
    char        szLogFile[256];
    OFSTRUCT        ofFile;
    char            szMemLine[300];
    HFILE           lhFile;
    HANDLE          lhHFile;
    HANDLE      hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                                    TRUE, GetCurrentProcessId());


    wsprintfA(szLogFile, "c:\\%08lX.MEM", GetCurrentProcessId());

    lhFile = OpenFile(szLogFile, &ofFile, OF_CREATE);
    AssertSz(lhFile != NULL, "Failed to open log file.");
    _lwrite(lhFile, "Total,Code,Data,Reserve\r\n", 25);
    _lclose(lhFile);

    for (;;)
    {
        GetMemStats(szMemLine, hProc);

        lhHFile = CreateFileA(szLogFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
        AssertSz(lhHFile != NULL, "Failed to open log file.");
        SetFilePointer(lhHFile, 0, NULL, FILE_END);
        _lwrite((HFILE) (DWORD_PTR)lhHFile, szMemLine, lstrlenA(szMemLine));
        _lwrite((HFILE) (DWORD_PTR)lhHFile, "\r\n", 2);

        CloseHandle(lhHFile);
        Sleep(10000);       // 10 second pause
    }
    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

#pragma warning(default:4702)   // re-enable

// ----------------------------------------------------------------------------

void __cdecl hprintf(HANDLE hfile, char * pchFmt, ...)
{
    char    ach[2048];
    UINT    cb;
    DWORD   dw;
    va_list vl;

    va_start(vl, pchFmt);
    cb = wvsprintfA(ach, pchFmt, vl);
    va_end(vl);

    WriteFile(hfile, ach, cb, &dw, NULL);
}

void  WINAPI
DbgExDumpProcessHeaps()
{
    HANDLE hfile;
    HANDLE ah[256];
    DWORD i, cHeaps, dwBusyTotal = 0, dwFreeTotal = 0;

#ifdef UNIX
    CHAR szHeapDumpFile[] = "heapdump.txt";
#else
    CHAR szHeapDumpFile[] = "\\heapdump.txt";
#endif

    cHeaps = GetProcessHeaps(ARRAY_SIZE(ah), ah);

    hfile = CreateFileA(szHeapDumpFile, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        return;

    for (i = 0; i < cHeaps; ++i)
    {
        PROCESS_HEAP_ENTRY he;
        DWORD dwFree = 0, dwBusy = 0;

        memset(&he, 0, sizeof(he));

        hprintf(hfile, "+++ Heap %08lX %s\r\n\r\n", ah[i],
            ah[i] == GetProcessHeap() ? "(Process Heap)" : "");

        while (HeapWalk(ah[i], &he))
        {
            if (he.wFlags & PROCESS_HEAP_REGION)
            {
                hprintf(hfile, "R %08lX [%ld] (cb=%ld+%ld, c/r=%ld/%ld, "
                    "f/l=%08lX/%08lX)\r\n", he.lpData, he.iRegionIndex,
                    he.cbData, he.cbOverhead, he.Region.dwCommittedSize,
                    he.Region.dwUnCommittedSize, he.Region.lpFirstBlock,
                    he.Region.lpLastBlock);
            }
            else if (he.wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE)
            {
                hprintf(hfile, "U %08lX [%ld] (cb=%ld+%ld)\r\n",
                    he.lpData, he.iRegionIndex, he.cbData, he.cbOverhead);
            }
            else
            {
                hprintf(hfile, "%c %08lX %6ld (+%ld) [%ld]",
                    (he.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE) ? 'M' :
                    (he.wFlags & PROCESS_HEAP_ENTRY_DDESHARE) ? 'S' :
                    (he.wFlags & PROCESS_HEAP_ENTRY_BUSY) ? ' ' : 'F',
                    he.lpData, he.cbData, he.cbOverhead, he.iRegionIndex);

                if (he.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE)
                    hprintf(hfile, " (hMem=%08lX)", he.Block.hMem);

                if (he.wFlags & PROCESS_HEAP_ENTRY_BUSY)
                    dwBusy += he.cbData;
                else
                    dwFree += he.cbData;

                hprintf(hfile, "\r\n");
            }
        }

        hprintf(hfile, "\r\nTotal of %ld bytes allocated (%ld free)\r\n\r\n",
            dwBusy, dwFree);

        dwBusyTotal += dwBusy;
        dwFreeTotal += dwFree;
    }

    hprintf(hfile, "Grand total of %ld bytes allocated (%ld free)\r\n",
        dwBusyTotal, dwFreeTotal);

    CloseHandle(hfile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\meter.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:       meter.cxx
//
//  Contents:   Performance metering
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#include <stddef.h>
#endif

void __cdecl hprintf(HANDLE hfile, char * pchFmt, ...);

CRITICAL_SECTION    g_csMeter;
static BOOL         g_fBringToFront = FALSE;
static HWND         ghWnd           = NULL;
static HBRUSH       ghbrBkgnd       = NULL;
static HANDLE       ghThread        = NULL;
static BOOL         fDlgUp          = FALSE;
static DWORD        rgbWindowColor  = 0xFF000000;    // variables for the current
static DWORD        rgbHiliteColor  = 0xFF000000;    // system color settings.
static DWORD        rgbWindowText   = 0xFF000000;    // on a WM_SYSCOLORCHANGE
static DWORD        rgbHiliteText   = 0xFF000000;    // we check to see if we need
static DWORD        rgbGrayText     = 0xFF000000;    // to reload our bitmap.
static DWORD        rgbDDWindow     = 0xFF000000;    //
static DWORD        rgbDDHilite     = 0xFF000000;    // 0xFF000000 is an invalid RGB
static BOOL         g_fEnabled      = FALSE;
static BOOL         g_fAutoDump     = FALSE;
static BOOL         g_fAutoOpen     = FALSE;
static BOOL         g_fAutoDelete   = TRUE;
static BOOL         g_fSimpleDump   = TRUE;
static DWORD        g_dwItemCount   = 0;
static DWORD        g_cRefresh      = 0;
static BOOL         g_fLogging      = FALSE;
static LONG         g_lMtAddTrap    = 0;
static BOOL         g_fIntervalOOM  = FALSE;
static BOOL         g_fAllOOM       = TRUE;
static BOOL         g_fBreakOnOOM   = FALSE;
static DWORD        g_dwOOMCount    = 0;
static DWORD        g_dwOOMCycle    = 0;

struct MTAG
{
    MTAG *  pmtagNext;
    MTAG *  pmtagParent;
    char *  pchTag;
    char *  pchOwner;
    char *  pchDesc;
    LONG    lCntExc;
    LONG_PTR lValExc;
    LONG    lCntInc;
    LONG_PTR lValInc;
    DWORD   dwFlags;
    char    ach[1];
};

struct LENT
{
    FILETIME    ft;
    LONG        lCnt;
    LONG        lVal;
    MTAG *      pmtag;
};

#define LBLKENT     8192

struct LBLK
{
    LBLK *  plblkNext;
    LONG    cEnt;
    LENT    rglent[LBLKENT];
};

#define MTF_HASCHILDREN         0x00000001
#define MTF_VALUESDIRTY         0x00000002
#define MTF_EXCLVALUESDIRTY     0x00000004
#define MTF_COLLAPSED           0x00000008
#define MTF_BREAKPOINTEXCL      0x00000010
#define MTF_BREAKPOINTINCL      0x00000020
#define MTF_SIMOUTOFMEMEXCL     0x00000040
#define MTF_SIMOUTOFMEMINCL     0x00000080

#define MTAG_MAXDESCSIZE        40

MTAG *  g_pmtagHead;
LBLK *  g_plblkHead;
LBLK *  g_plblkTail;
LONG    g_cLogEntry;
LONG    g_cMTagByName;
MTAG ** g_aMTagByName;
LONG    g_cMTagOrphanByParent;
MTAG ** g_aMTagOrphanByParent;

int
MTagCompareName(void * pv1, void *pv2)
{
    return(lstrcmpA(((MTAG *)pv1)->pchTag, (char *)pv2));
}

int
MTagCompareOwner(void * pv1, void * pv2)
{
    return(lstrcmpA(((MTAG *)pv1)->pchOwner, (char *)pv2));
}

BOOL
FindPtrArray(LONG * pcCount, void * pAry, int (*pfnCmp)(void *, void *), void * pvArg, int * piLocFind)
{
    int     iEntLow, iEntHigh, iEntMid, c;
    void ** ppvAry = *(void ***)pAry;
    void *  pvMid;
    BOOL    fResult;

    iEntLow  = 0;
    fResult  = FALSE;
    iEntHigh = *pcCount - 1;

    while (iEntLow <= iEntHigh)
    {
        iEntMid = (iEntLow + iEntHigh) >> 1;
        pvMid  = ppvAry[iEntMid];
        c = pfnCmp(pvMid, pvArg);
        if (c == 0)
        {
            iEntLow = iEntMid;
            fResult = TRUE;
            break;
        }
        else if (c < 0)
            iEntLow = iEntMid + 1;
        else
            iEntHigh = iEntMid - 1;
    }

    *piLocFind = iEntLow;
    return(fResult);
}

void
InsPtrArray(LONG * pcCount, void * ppvAry, int iIns, void * pvIns)
{
    if ((*pcCount & 255) == 0 && (*pcCount || *(void **)ppvAry == NULL))
    {
        void * pvNew = (void *)LocalAlloc(LMEM_FIXED, (*pcCount + 256) * sizeof(void *));

        if (pvNew == NULL)
            return;

        memcpy(pvNew, *(void **)ppvAry, *pcCount * sizeof(void *));

        if (*(void **)ppvAry)
            LocalFree(*(void **)ppvAry);

        *(void **)ppvAry = pvNew;
    }

    void ** ppvIns = *(void ***)ppvAry + iIns;

    memmove(ppvIns + 1, ppvIns, (*pcCount - iIns) * sizeof(void *));
    *ppvIns = pvIns;
    *pcCount += 1;
}

void
DelPtrArray(LONG * pcCount, void * ppvAry, int iDel, int cDel)
{
    void ** ppvDel = *(void ***)ppvAry + iDel;
    memmove(ppvDel, ppvDel + cDel, (*pcCount - (iDel + cDel)) * sizeof(void *));
    *pcCount -= cDel;
}

BOOL
FindMTagByName(char * pchName, int * piLoc)
{
    return(FindPtrArray(&g_cMTagByName, &g_aMTagByName, MTagCompareName, pchName, piLoc));
}

void
InsMTagByName(int iLocIns, MTAG * pmtagIns)
{
    InsPtrArray(&g_cMTagByName, &g_aMTagByName, iLocIns, pmtagIns);
}

BOOL
FindMTagOrphanByParent(char * pchOwner, BOOL fFirst, int * piLoc)
{
    BOOL fFound = FindPtrArray(&g_cMTagOrphanByParent, &g_aMTagOrphanByParent, MTagCompareOwner, pchOwner, piLoc);

    if (fFound && fFirst)
    {
        while (*piLoc > 0)
        {
            MTAG * pmtag = g_aMTagOrphanByParent[*piLoc - 1];

            if (lstrcmpA(pchOwner, pmtag->pchOwner) != 0)
                break;

            *piLoc -= 1;
        }
    }

    return(fFound);
}

void
InsMTagOrphan(MTAG * pmtagIns)
{
    int iLocIns;
    FindMTagOrphanByParent(pmtagIns->pchOwner, FALSE, &iLocIns);
    InsPtrArray(&g_cMTagOrphanByParent, &g_aMTagOrphanByParent, iLocIns, pmtagIns);
}

void
DelMTagOrphanRange(int iLocDel, int cLocDel)
{
    DelPtrArray(&g_cMTagOrphanByParent, &g_aMTagOrphanByParent, iLocDel, cLocDel);
}

LENT *
GetLogEntry()
{
    LBLK * plblk = g_plblkTail;

    if (!plblk || plblk->cEnt == LBLKENT)
    {
        plblk = (LBLK *)LocalAlloc(LMEM_FIXED, sizeof(LBLK));

        if (plblk == NULL)
        {
            return(NULL);
        }

        plblk->plblkNext = NULL;
        plblk->cEnt      = 0;

        if (g_plblkTail)
            g_plblkTail->plblkNext = plblk;
        if (g_plblkHead == NULL)
            g_plblkHead = plblk;

        g_plblkTail = plblk;
    }

    g_cLogEntry += 1;

    return(&plblk->rglent[plblk->cEnt++]);
}

PERFMETERTAG WINAPI
DbgExMtRegister(char * szTag, char * szOwner, char * szDesc)
{
    int cbTag   = lstrlenA(szTag) + 1;
    int cbOwner = lstrlenA(szOwner) + 1;
    int cbDesc  = lstrlenA(szDesc) + 1;
    MTAG * pmtag = NULL, * pmtagT, * pmtagP;
    int iLoc, cLoc;

    EnterCriticalSection(&g_csMeter);

    if (!FindMTagByName(szTag, &iLoc))
    {
        pmtag = (MTAG *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, offsetof(MTAG, ach) + cbTag + cbOwner + cbDesc);
        if (pmtag == NULL)
        {
            AssertSz(0, "Insufficient memory to debug.");
            LeaveCriticalSection(&g_csMeter);
            return (PERFMETERTAG)pmtag;
        }

        pmtag->pmtagNext    = g_pmtagHead;
        g_pmtagHead         = pmtag;
        pmtag->pchTag       = pmtag->ach;
        pmtag->pchOwner     = pmtag->ach + cbTag;
        pmtag->pchDesc      = pmtag->pchOwner + cbOwner;

        lstrcpyA(pmtag->pchTag, szTag);
        lstrcpyA(pmtag->pchOwner, szOwner);
        lstrcpyA(pmtag->pchDesc, szDesc);

        InsMTagByName(iLoc, pmtag);

        if (FindMTagByName(szOwner, &iLoc))
        {
            pmtagT = g_aMTagByName[iLoc];

            AssertSz(pmtag != pmtagT, "Infinite loop in Meters");
            pmtag->pmtagParent = pmtagT;

            if (!(pmtagT->dwFlags & MTF_HASCHILDREN))
            {
                pmtagT->dwFlags |= MTF_HASCHILDREN|MTF_COLLAPSED;
            }
        }
        else
        {
            InsMTagOrphan(pmtag);
        }

        if (FindMTagOrphanByParent(szTag, TRUE, &iLoc))
        {
            for (cLoc = 0; iLoc < g_cMTagOrphanByParent; ++iLoc, ++cLoc)
            {
                pmtagT = g_aMTagOrphanByParent[iLoc];

                if (lstrcmpA(pmtagT->pchOwner, szTag) == 0)
                {
                    AssertSz(pmtagT != pmtag, "Infinite loop in Meters");

                    pmtagT->pmtagParent = pmtag;
                    pmtag->dwFlags |= MTF_HASCHILDREN|MTF_COLLAPSED;

                    if (pmtagT->lCntInc || pmtagT->lValInc)
                    {
                        for (pmtagP = pmtag; pmtagP; pmtagP = pmtagP->pmtagParent)
                        {
                            pmtagP->lCntInc += pmtagT->lCntInc;
                            pmtagP->lValInc += pmtagT->lValInc;
                            pmtagP->dwFlags |= MTF_VALUESDIRTY;
                        }
                    }
                }
                else
                {
                    break;
                }
            }

            DelMTagOrphanRange(iLoc - cLoc, cLoc);
        }
    }
    else
    {
        pmtag = g_aMTagByName[iLoc];
    }

    if (ghWnd)
    {
        g_cRefresh = 3;
    }

    LeaveCriticalSection(&g_csMeter);

    return((PERFMETERTAG)pmtag);
}

void WINAPI
DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
    BOOL fBreak = FALSE;

    if (    (g_lMtAddTrap > 0 && lVal > g_lMtAddTrap)
        ||  (g_lMtAddTrap < 0 && lVal < g_lMtAddTrap))
    {
        fBreak = TRUE;
    }

    if (mt)
    {
        EnterCriticalSection(&g_csMeter);

        MTAG * pmtag = (MTAG *)mt;
        LENT * plent = g_fLogging ? GetLogEntry() : NULL;

        if (plent)
        {
            FILETIME ft;

            GetSystemTimeAsFileTime(&ft);
            FileTimeToLocalFileTime(&ft, &plent->ft);

            plent->pmtag = pmtag;
            plent->lCnt  = lCnt;
            plent->lVal  = lVal;
        }

        if (pmtag->dwFlags & MTF_BREAKPOINTEXCL)
        {
            fBreak = TRUE;
        }

        pmtag->lCntExc += lCnt;
        pmtag->lValExc += lVal;
        pmtag->dwFlags |= MTF_EXCLVALUESDIRTY;

        for (; pmtag; pmtag = pmtag->pmtagParent)
        {
            if (pmtag->dwFlags & MTF_BREAKPOINTINCL)
            {
                fBreak = TRUE;
            }

            pmtag->lCntInc += lCnt;
            pmtag->lValInc += lVal;
            pmtag->dwFlags |= MTF_VALUESDIRTY;
        }

        LeaveCriticalSection(&g_csMeter);
    }

    if (fBreak && !(GetAsyncKeyState(VK_CONTROL) & 0x8000))
    {
        DebugBreak();
    }
}

void WINAPI
DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
    if (mt)
    {
        EnterCriticalSection(&g_csMeter);

        MTAG * pmtag = (MTAG *)mt;

        lVal = lVal < 0 ? 0 : lVal - pmtag->lValExc;
        lCnt = lCnt < 0 ? 0 : lCnt - pmtag->lCntExc;

        DbgExMtAdd(mt, lCnt, lVal);

        LeaveCriticalSection(&g_csMeter);
    }
}

BOOL WINAPI
DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue)
{
    BOOL fResult = FALSE;
    BOOL fTagged = FALSE;

    if (mt)
    {
        EnterCriticalSection(&g_csMeter);

        MTAG *pmtag = (MTAG *)mt;

        if (pmtag->dwFlags & MTF_SIMOUTOFMEMEXCL)
        {
            fTagged = TRUE;
        }

        for (; pmtag && !fTagged; pmtag = pmtag->pmtagParent)
        {
            if (pmtag->dwFlags & MTF_SIMOUTOFMEMINCL)
                fTagged = TRUE;
        }

        if (    g_fIntervalOOM && g_fAllOOM && ++g_dwOOMCount % g_dwOOMCycle == 0
            ||  g_fIntervalOOM && !g_fAllOOM && fTagged && ++g_dwOOMCount % g_dwOOMCycle == 0
            ||  !g_fIntervalOOM && fTagged)
        {
            char ach[512];
            wsprintfA(ach, "MSHTMDBG: Failing memory allocation for %s (%s)\r\n",
                      ((MTAG *)mt)->pchTag, ((MTAG *)mt)->pchDesc);
            OutputDebugStringA(ach);
            fResult = TRUE;
        }

        LeaveCriticalSection(&g_csMeter);
    }

    if (g_fBreakOnOOM && fResult)
        DebugBreak();

    return fResult;
}

char * WINAPI
DbgExMtGetName(PERFMETERTAG mt)
{
    return(mt ? ((MTAG *)mt)->pchTag : "");
}

char * WINAPI
DbgExMtGetDesc(PERFMETERTAG mt)
{
    return(mt ? ((MTAG *)mt)->pchDesc : "");
}

PERFMETERTAG WINAPI
DbgExMtLookupMeter(char * szTag)
{
    MTAG * pmtag = NULL;
    int iLoc;

    EnterCriticalSection(&g_csMeter);

    if (FindMTagByName(szTag, &iLoc))
    {
        pmtag = g_aMTagByName[iLoc];
    }

    LeaveCriticalSection(&g_csMeter);

    return((PERFMETERTAG)pmtag);
}

long WINAPI
DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive)
{
    if (mt)
    {
        return fExclusive ? ((MTAG *)mt)->lCntExc : ((MTAG *)mt)->lCntInc;
    }

    return 0;
}

long WINAPI
DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive)
{
    if (mt)
    {
        return fExclusive ? ((MTAG *)mt)->lValExc : ((MTAG *)mt)->lValInc;
    }

    return 0;
}

// Meter Monitor Window -------------------------------------------------------

DWORD WINAPI    MeterMonitorThread(LPVOID lpv);

INT_PTR WINAPI  MeterMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void            SetWindowTitle(HWND hWnd, LPSTR lpcText);
static void     RefreshView(HWND hWnd);
static void     MeterListNotify(WORD wNotify, HWND  hWnd);

void            MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
static void     DrawItem(LPDRAWITEMSTRUCT pdis);
static void     OutTextFormat(LPDRAWITEMSTRUCT pdis);
static void     SetRGBValues(void);

void
MtDoOpenMonitor(BOOL fBringToFront)
{
    if (!ghThread)
    {
        EnterCriticalSection(&g_csMeter);

        if (!ghThread)
        {
            DWORD dwThreadId=NULL;

            fDlgUp = TRUE;
            g_fBringToFront = fBringToFront;

            ghThread = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0,
                (LPTHREAD_START_ROUTINE)MeterMonitorThread,
                NULL, 0, &dwThreadId);
            AssertSz(dwThreadId, "Failed to create debug thread.");
        }

        LeaveCriticalSection(&g_csMeter);
    }
    else if (fBringToFront && ghWnd)
    {
        ShowWindow(ghWnd, SW_SHOWNORMAL);
        BringWindowToTop(ghWnd);
    }
}

void WINAPI
DbgExMtOpenMonitor()
{
    MtDoOpenMonitor(TRUE);
}

DWORD WINAPI
MeterMonitorThread(LPVOID)
{
    ghbrBkgnd = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));

    DialogBoxA(g_hinstMain, MAKEINTRESOURCEA(IDD_PERFMETER), NULL, MeterMonDlgProc);

    DeleteObject(ghbrBkgnd);
    CloseHandle(ghThread);
    ghThread = NULL;

    return 0;
}

int __cdecl MTagCompareDesc(const void * pv1, const void * pv2)
{
    MTAG * pmt1 = *(MTAG **)pv1;
    MTAG * pmt2 = *(MTAG **)pv2;
    return(lstrcmpA(pmt1->pchDesc, pmt2->pchDesc));
}

int __cdecl MTagCompareTag(const void * pv1, const void * pv2)
{
    MTAG * pmt1 = *(MTAG **)pv1;
    MTAG * pmt2 = *(MTAG **)pv2;
    return(lstrcmpA(pmt1->pchTag, pmt2->pchTag));
}

void
PopulateList(HWND hWnd, MTAG * pmtagPar)
{
    MTAG * apmtag[512], *pmtag, ** ppmtag;
    UINT   cpmtag = 0;

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        if (    pmtag->pmtagParent == pmtagPar
            &&  cpmtag < ARRAY_SIZE(apmtag))
        {
            apmtag[cpmtag++] = pmtag;
        }
    }

    if (cpmtag > 0)
    {
        qsort(apmtag, cpmtag, sizeof(MTAG *), MTagCompareDesc);

        for (ppmtag = apmtag; cpmtag > 0; --cpmtag, ++ppmtag)
        {
            g_dwItemCount += 1;
            SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_ADDSTRING, 0, (LPARAM)*ppmtag);

            if (g_dwItemCount != (DWORD)SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_GETCOUNT, 0, 0))
            {
                g_dwItemCount -= 1;
            }

            if (((*ppmtag)->dwFlags & (MTF_HASCHILDREN|MTF_COLLAPSED)) == MTF_HASCHILDREN)
            {
                g_dwItemCount += 1;
                SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_ADDSTRING, 0, (LPARAM)*ppmtag | 1L);
                PopulateList(hWnd, *ppmtag);
            }
        }
    }
}

void
DumpTag(HANDLE hfile, MTAG * pmtag, BOOL fExcl)
{
    LONG lCnt = fExcl ? pmtag->lCntExc : pmtag->lCntInc;
    LONG lVal = fExcl ? pmtag->lValExc : pmtag->lValInc;

    hprintf(hfile, "%s%s\t%s\t\"%s%s\"\t%ld\t%ld\r\n",
        pmtag->pchTag, fExcl ? "_excl" : "",
        fExcl ? pmtag->pchTag : pmtag->pchOwner,
        pmtag->pchDesc, fExcl ? " (Excl)" : "",
        lCnt, lVal);
}

void
DumpList(HANDLE hfile, MTAG * pmtagPar)
{
    MTAG *  apmtag[512], *pmtag, ** ppmtag;
    UINT    cpmtag = 0;

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        if (    pmtag->pmtagParent == pmtagPar
            &&  cpmtag < ARRAY_SIZE(apmtag))
        {
            apmtag[cpmtag++] = pmtag;
        }
    }

    if (cpmtag > 0)
    {
        qsort(apmtag, cpmtag, sizeof(MTAG *), MTagCompareTag);

        for (ppmtag = apmtag; cpmtag > 0; --cpmtag, ++ppmtag)
        {
            if ((*ppmtag)->lCntInc == 0 && (*ppmtag)->lValInc == 0)
                continue;

            DumpTag(hfile, *ppmtag, FALSE);

            if ((*ppmtag)->dwFlags & MTF_HASCHILDREN)
            {
                if ((*ppmtag)->lCntExc || (*ppmtag)->lValExc)
                {
                    DumpTag(hfile, *ppmtag, TRUE);
                }

                DumpList(hfile, *ppmtag);
            }
        }
    }
}

void WINAPI
MtLogClear()
{
    EnterCriticalSection(&g_csMeter);

    LBLK *  plblk = g_plblkHead;
    LBLK *  plblkNext;

    for (; plblk; plblk = plblkNext)
    {
        plblkNext = plblk->plblkNext;
        LocalFree(plblk);
    }

    g_plblkHead = NULL;
    g_plblkTail = NULL;
    g_cLogEntry = 0;

    LeaveCriticalSection(&g_csMeter);
}

void
DumpLog(HANDLE hfile)
{
    LBLK *  plblk = g_plblkHead;
    LENT *  plent;
    LONG    cEnt;
    LONG    lValSum = 0;

    for (; plblk; plblk = plblk->plblkNext)
    {
        for (cEnt = plblk->cEnt, plent = plblk->rglent; cEnt > 0; --cEnt, ++plent)
        {
            MTAG *      pmtag = plent->pmtag;
            SYSTEMTIME  st;

            FileTimeToSystemTime(&plent->ft, &st);

            lValSum += plent->lVal;

            hprintf(hfile, "%02d:%02d:%02d.%03d\t%s\t\"%s\"\t%ld\t%ld\t%ld\r\n",
                st.wHour, st.wMinute, st.wSecond, st.wMilliseconds,
                pmtag->pchTag, pmtag->pchDesc, plent->lCnt, plent->lVal, lValSum);
        }
    }
}

void WINAPI
DbgExMtLogDump(LPSTR pchFile)
{
    FILETIME ft1, ft2;
    SYSTEMTIME st;

    EnterCriticalSection(&g_csMeter);

    HANDLE hfile = INVALID_HANDLE_VALUE;

    hfile = CreateFileA(pchFile, GENERIC_WRITE,
                FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        goto ret;

    SetFilePointer(hfile, 0, NULL, FILE_BEGIN);
    SetEndOfFile(hfile);
    GetSystemTimeAsFileTime(&ft1);
    FileTimeToLocalFileTime(&ft1, &ft2);
    FileTimeToSystemTime(&ft2, &st);
    hprintf(hfile, "PerfMeters Snapshot (%02d/%02d/%02d %02d:%02d:%02d)\r\n\r\n",
        st.wMonth, st.wDay, st.wYear % 100, st.wHour, st.wMinute, st.wSecond);
    DumpList(hfile, NULL);
    hprintf(hfile, "\r\n\r\nPerfMeters Log\r\n\r\n");
    DumpLog(hfile);

ret:
    if (hfile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hfile);
    }

    LeaveCriticalSection(&g_csMeter);
}

static void
RefreshView(HWND hWnd)
{
    EnterCriticalSection(&g_csMeter);
    SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_RESETCONTENT, 0, 0L);
    g_dwItemCount = 0;
    PopulateList(hWnd, NULL);
    LeaveCriticalSection(&g_csMeter);
}

static
void MtSetOOM( HWND hWndList )
{
    LONG    idx;
    MTAG *  pmtag;
    BOOL    fExcl;
    RECT    rc;

    idx = SendMessageA(hWndList, LB_GETCURSEL, 0, 0L);
    if (idx == CB_ERR)
        return;

    pmtag = (MTAG *)SendMessageA(hWndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
    if (!pmtag || pmtag == (MTAG *)CB_ERR)
        return;

    fExcl = !!(((DWORD_PTR)pmtag) & 1L);
    pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

    EnterCriticalSection(&g_csMeter);

    pmtag->dwFlags ^= (fExcl ? MTF_SIMOUTOFMEMEXCL : MTF_SIMOUTOFMEMINCL);

    LeaveCriticalSection(&g_csMeter);

    if (SendMessageA(hWndList, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        RedrawWindow(hWndList, &rc, NULL, RDW_INVALIDATE);
}

static
void MtClearAllOOM()
{
    MTAG  *pmtag;
    HWND   hWndList = GetDlgItem(ghWnd, IDC_TAGLIST);

    EnterCriticalSection(&g_csMeter);

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        pmtag->dwFlags &= ~(MTF_SIMOUTOFMEMEXCL | MTF_SIMOUTOFMEMINCL);
    }

    LeaveCriticalSection(&g_csMeter);

    LONG idxTop = SendMessageA(hWndList, LB_GETTOPINDEX, 0, 0);
    LONG idxSel = SendMessageA(hWndList, LB_GETCURSEL, 0, 0);
    RefreshView(ghWnd);
    SendMessageA(hWndList, LB_SETTOPINDEX, (WPARAM)idxTop, 0);
    SendMessageA(hWndList, LB_SETCURSEL, (WPARAM)idxSel, 0);
}

static
void PushOOMState()
{
    CheckDlgButton( ghWnd, IDC_USEINTERVALOOM, g_fIntervalOOM ? BST_CHECKED : BST_UNCHECKED );
    CheckDlgButton( ghWnd, g_fAllOOM ? IDC_ALLMEM : IDC_MARKEDMEM , BST_CHECKED );

    {
        TCHAR   ach[16];

        ach[ARRAY_SIZE(ach) - 1] = '\0';
        _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_dwOOMCycle);
        Edit_SetText(GetDlgItem(ghWnd, IDC_OOMINTERVAL), ach);
    }
}

static
void MtSetBreak( HWND hWndList )
{
    LONG    idx;
    MTAG *  pmtag;
    BOOL    fExcl;
    RECT    rc;

    idx = SendMessageA(hWndList, LB_GETCURSEL, 0, 0L);
    if (idx == CB_ERR)
        return;

    pmtag = (MTAG *)SendMessageA(hWndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
    if (!pmtag || pmtag == (MTAG *)CB_ERR)
        return;

    fExcl = !!(((DWORD_PTR)pmtag) & 1L);
    pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

    pmtag->dwFlags ^= (fExcl ? MTF_BREAKPOINTEXCL : MTF_BREAKPOINTINCL);

    if (SendMessageA(hWndList, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        RedrawWindow(hWndList, &rc, NULL, RDW_INVALIDATE);
}

static
void MtClearAllBreaks()
{
    MTAG  *pmtag;
    HWND   hWndList = GetDlgItem(ghWnd, IDC_TAGLIST);

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        pmtag->dwFlags &= ~(MTF_BREAKPOINTEXCL | MTF_BREAKPOINTINCL);
    }

    LONG idxTop = SendMessageA(hWndList, LB_GETTOPINDEX, 0, 0);
    LONG idxSel = SendMessageA(hWndList, LB_GETCURSEL, 0, 0);
    RefreshView(ghWnd);
    SendMessageA(hWndList, LB_SETTOPINDEX, (WPARAM)idxTop, 0);
    SendMessageA(hWndList, LB_SETCURSEL, (WPARAM)idxSel, 0);
}

static
void TagListNotify(WORD wNotify, HWND hWnd)
{
    LONG    idx;
    MTAG *  pmtag;
    BOOL    fExcl;

    if (wNotify == LBN_DBLCLK)
    {
        idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);
        if (idx == CB_ERR)
            return;

        pmtag = (MTAG *)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
        if (!pmtag || pmtag == (MTAG *)CB_ERR)
            return;

        fExcl = !!(((DWORD_PTR)pmtag) & 1L);
        pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

        if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
        {
            MtSetBreak( hWnd );
        }
        else if (!fExcl && (pmtag->dwFlags & MTF_HASCHILDREN))
        {
            LONG idxTop = SendMessageA(hWnd, LB_GETTOPINDEX, 0, 0);
            pmtag->dwFlags ^= MTF_COLLAPSED;
            RefreshView(ghWnd);
            SendMessageA(hWnd, LB_SETTOPINDEX, (WPARAM)idxTop, 0);
        }
    }
}

static
void MtMeterClearChildren(MTAG * pmtag)
{
    for (MTAG * pmtagT = g_pmtagHead; pmtagT; pmtagT = pmtagT->pmtagNext)
    {
        if (pmtagT->pmtagParent == pmtag)
        {
            DWORD dwFlags = pmtagT->dwFlags & (MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
            pmtagT->dwFlags &= ~(MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
            DbgExMtAdd((PERFMETERTAG)pmtagT, -pmtagT->lCntExc, -pmtagT->lValExc);
            pmtagT->dwFlags |= dwFlags;

            if (pmtagT->lCntInc || pmtag->lValInc)
            {
                MtMeterClearChildren(pmtagT);
            }
        }
    }
}

static
void MtMeterClear()
{
    HWND    hwndList = GetDlgItem(ghWnd, IDC_TAGLIST);
    LONG    idx;
    MTAG *  pmtag;

    idx = SendMessageA(hwndList, LB_GETCURSEL, 0, 0L);
    if (idx == CB_ERR)
        return;

    pmtag = (MTAG *)SendMessageA(hwndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
    if (!pmtag || pmtag == (MTAG *)CB_ERR)
        return;

    pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

    DWORD dwFlags = pmtag->dwFlags & (MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
    pmtag->dwFlags &= ~(MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
    DbgExMtAdd((PERFMETERTAG)pmtag, -pmtag->lCntExc, -pmtag->lValExc);
    pmtag->dwFlags |= dwFlags;

    if (pmtag->lCntInc || pmtag->lValInc)
    {
        MtMeterClearChildren(pmtag);
    }
}

static
void OnTimer(HWND hwnd)
{
    EnterCriticalSection(&g_csMeter);

    HWND hwndList = GetDlgItem(hwnd, IDC_TAGLIST);
    LONG idx = SendMessageA(hwndList, LB_GETTOPINDEX, 0, 0);
    LONG idxBase = idx;
    RECT rc;

    if (g_cRefresh > 0 && --g_cRefresh == 0)
    {
        RefreshView(hwnd);
    }
    else
    {
        while (SendMessageA(hwndList, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        {
            MTAG *      pmtag;
            BOOL        fExcl;
            DWORD_PTR   dwItemData = SendMessageA(hwndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
            DWORD       dwDirtyFlag;

            pmtag = (MTAG *)(dwItemData & ~1L);
            fExcl = !!(dwItemData & 1L);
            dwDirtyFlag = fExcl ? MTF_EXCLVALUESDIRTY : MTF_VALUESDIRTY;

            if (pmtag && pmtag != (MTAG *)CB_ERR)
            {
                if (pmtag->dwFlags & dwDirtyFlag)
                {
                    pmtag->dwFlags &= ~dwDirtyFlag;
                    RedrawWindow(hwndList, &rc, NULL, RDW_INVALIDATE);
                }
            }
            idx += 1;

            if ((idx-idxBase) > 50)
            {
                break;
            }
        }

        {
            TCHAR   ach[16];

            ach[ARRAY_SIZE(ach) - 1] = '\0';
            _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_dwOOMCount);
            Static_SetText(GetDlgItem(ghWnd, IDC_OOMCOUNT), ach);
        }
    }

    LeaveCriticalSection(&g_csMeter);
}

static
void ExpandCollapseAll(BOOL fExpand )
{
    MTAG  *pmtag;

    EnterCriticalSection(&g_csMeter);

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        if (pmtag->dwFlags & MTF_HASCHILDREN)
        {
            if (fExpand)
                pmtag->dwFlags &= ~MTF_COLLAPSED;
            else
                pmtag->dwFlags |= MTF_COLLAPSED;
        }
    }

    LeaveCriticalSection(&g_csMeter);

    RefreshView(ghWnd);
}

INT_PTR WINAPI
MeterMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghWnd = hWnd;
            RefreshView(ghWnd);
            SetRGBValues();
            SetWindowTitle(hWnd, "PerfMeters - %s");
            SetWindowTitle(GetDlgItem(hWnd, IDC_STARTSTOP), g_fLogging ? "&Stop Log" : "&Start Log");
            ShowWindow(hWnd, g_fBringToFront ? SW_SHOWNORMAL : SW_SHOWMINNOACTIVE);
            SetTimer(hWnd, 1001, 1000, NULL);

            PushOOMState();
            break;

        case WM_SYSCOLORCHANGE:
            SetRGBValues();
            g_cRefresh = 3;
            break;

        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            DrawItem((LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_PAINT:
            return FALSE;

        case WM_ERASEBKGND:
            return IsIconic(hWnd);

        case WM_QUERYENDSESSION:
            PostMessageA(hWnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            fDlgUp = FALSE;
            KillTimer(ghWnd, 1001);
            return EndDialog(hWnd, 0);

        case WM_TIMER:
            OnTimer(ghWnd);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_TAGLIST:
                    TagListNotify(HIWORD(wParam), (HWND)lParam);
                    break;

                case IDC_CLEARLOG:
                    MtLogClear();
                    break;

                case IDC_STARTSTOP:
                    SetWindowTitle((HWND)lParam, g_fLogging ? "&Start Log" : "&Stop Log");
                    g_fLogging = !g_fLogging;
                    break;

                case IDC_REFRESH:
                    g_cRefresh = 3;
                    break;

                case IDC_DUMPLOG:
                    DbgExMtLogDump("\\perfmetr.log");
                    break;

                case IDC_CLEARMETER:
                    MtMeterClear();
                    break;

                case IDC_BREAKMETER:
                    MtSetBreak( GetDlgItem(ghWnd, IDC_TAGLIST) );
                    break;

                case IDC_CLEARBREAK:
                    MtClearAllBreaks();
                    break;

                case IDC_OOMMETER:
                    MtSetOOM( GetDlgItem(ghWnd, IDC_TAGLIST) );
                    break;

                case IDC_CLEAROOM:
                    MtClearAllOOM();
                    break;

                case IDC_ALLMEM:
                    g_fAllOOM = IsDlgButtonChecked( ghWnd, IDC_ALLMEM ) == BST_CHECKED;
                    break;

                case IDC_MARKEDMEM:
                    g_fAllOOM = IsDlgButtonChecked( ghWnd, IDC_MARKEDMEM ) != BST_CHECKED;
                    break;

                case IDC_USEINTERVALOOM:
                    g_fIntervalOOM = IsDlgButtonChecked( ghWnd, IDC_USEINTERVALOOM ) == BST_CHECKED;
                    break;

                case IDC_BREAKOOM:
                    g_fBreakOnOOM = IsDlgButtonChecked( ghWnd, IDC_BREAKOOM ) == BST_CHECKED;
                    break;

                case IDC_OOMINTERVAL:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        TCHAR   ach[16];

                        EnterCriticalSection(&g_csMeter);

                        Edit_GetText(GetDlgItem(ghWnd, IDC_OOMINTERVAL), ach, ARRAY_SIZE(ach));
                        g_dwOOMCycle = _ttoi(ach);

                        if (g_dwOOMCycle == 0)
                            g_dwOOMCycle = 1;

                        LeaveCriticalSection(&g_csMeter);
                    }
                    break;

                case IDC_EXPANDALL:
                    ExpandCollapseAll( TRUE );
                    break;

                case IDC_COLLAPSEALL:
                    ExpandCollapseAll( FALSE );
                    break;

                default:
                    return FALSE;
            }
            break;
        default:
            return FALSE;
    }

    return TRUE;
}

static char achSpaces[] = "                                                                ";

char *
GetSpaces(int n)
{
    return(&achSpaces[sizeof(achSpaces) - n]);
}

COLORREF
BkColorFromLevel(int cLevel, HDC hdc)
{
    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        static COLORREF rgcr_pal[] = {
            0x20FFFFFF,
            0x2000FFFF,
            0x20F0CAA6,
            0x2000FF00,
            0x20C0C0C0
        };

        cLevel /= 2;
        cLevel %= 5;

        return(rgcr_pal[cLevel]);
    }
    else
    {
        static COLORREF rgcr_nopal[] = {
            0x20FFFFFF,
            0x20FFE0E0,
            0x20E0FFFF,
            0x20FFE0FF,
            0x20E0FFE0,
            0x20E0E0FF,
            0x20FFFFE0,
            0x20FFFF40,
            0x20E0E0E0
        };

        cLevel /= 2;
        cLevel %= 9;

        return(rgcr_nopal[cLevel]);
    }
}

char * CommaIze(LONG lVal, char * pszBuf)
{
    char ach[32];
    char * pszSrc = ach;
    char * pszDst = pszBuf;
    int c;

    wsprintfA(ach, "%ld", lVal);

    if (*pszSrc == '-')
    {
        *pszDst++ = *pszSrc++;
    }

    c = lstrlenA(pszSrc);

    while (*pszSrc)
    {
        *pszDst++ = *pszSrc++;
        c--;

        if (c && (c % 3) == 0)
        {
            *pszDst++ = ',';
        }
    }

    *pszDst = 0;

    return(pszBuf);
}

void DrawItem(LPDRAWITEMSTRUCT pdis)
{
    char ach[256];
    char achDesc[256];
    int cchDesc;
    COLORREF crText = 0, crBack = 0;
    int cLevel = 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        MTAG * pmtag = (MTAG *)(pdis->itemData & ~1L);
        BOOL fChildren  = !!(pmtag->dwFlags & MTF_HASCHILDREN);
        BOOL fForceExcl = !!(pdis->itemData & 1L);

        for (MTAG * pmtagT = pmtag->pmtagParent; pmtagT; pmtagT = pmtagT->pmtagParent)
        {
            cLevel += 2;
        }

        if (fForceExcl)
        {
            cLevel += 2;
        }

        cchDesc = lstrlenA(pmtag->pchDesc);

        if (cchDesc > sizeof(achDesc) - 1 - sizeof(" (Excl)"))
            cchDesc = sizeof(achDesc) - 1 - sizeof(" (Excl)");
        memcpy(achDesc, pmtag->pchDesc, cchDesc);

        if (fForceExcl)
            memcpy(achDesc + cchDesc, " (Excl)", 8);
        else
            achDesc[cchDesc] = 0;

        wsprintfA(ach, "%c%c %s%c%-54s",
            (pmtag->dwFlags & (fForceExcl ? MTF_BREAKPOINTEXCL : MTF_BREAKPOINTINCL)) ? 'B' : ' ',
            (pmtag->dwFlags & (fForceExcl ? MTF_SIMOUTOFMEMEXCL : MTF_SIMOUTOFMEMINCL)) ? 'O' : ' ',
            GetSpaces(cLevel),
            (fForceExcl || !fChildren) ? ' ' : (pmtag->dwFlags & MTF_COLLAPSED) ? '+' : '-',
            achDesc);

        LONG lCnt = (fForceExcl || !fChildren) ? pmtag->lCntExc : pmtag->lCntInc;
        LONG lVal = (fForceExcl || !fChildren) ? pmtag->lValExc : pmtag->lValInc;

        char achBuf1[32];
        char achBuf2[32];
        char achBuf3[32];

        wsprintfA(&ach[56], " %11s [%6s] %11s", CommaIze(lCnt, achBuf1),
            CommaIze(lCnt == 0 ? 0 : lVal / lCnt, achBuf2), CommaIze(lVal, achBuf3));

        if (pdis->itemState & ODS_SELECTED)
        {
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
            ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, ach, lstrlenA(ach), NULL);
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC, crBack);
        }
        else
        {
            crBack = SetBkColor(pdis->hDC, BkColorFromLevel(cLevel, pdis->hDC));
            ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, ach, lstrlenA(ach), NULL);
            SetBkColor(pdis->hDC, crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}

static void SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}

void
MeterProcessAttach()
{
    InitializeCriticalSection(&g_csMeter);

#if defined(RETAILBUILD) && defined(PERFMETER)
    g_fAutoOpen = TRUE;
#endif

    g_fAutoOpen = GetPrivateProfileIntA("perfmeter", "AutoOpen", g_fAutoOpen, "mshtmdbg.ini");
    g_fLogging = GetPrivateProfileIntA("perfmeter", "AutoLog", FALSE, "mshtmdbg.ini");
    g_fAutoDump = GetPrivateProfileIntA("perfmeter", "AutoDump", FALSE, "mshtmdbg.ini");

    g_fIntervalOOM = GetPrivateProfileIntA("perfmeter", "OutOfMemory", FALSE, "mshtmdbg.ini");
    g_dwOOMCycle = GetPrivateProfileIntA("perfmeter", "OutOfMemoryCycle", 500, "mshtmdbg.ini");

    if (g_dwOOMCycle == 0)
        g_dwOOMCycle = 1;

    if (g_fAutoOpen)
    {
        MtDoOpenMonitor(FALSE);
    }
}

void
MeterProcessDetach()
{
    if (g_fAutoDump)
        DbgExMtLogDump("\\perfmetr.log");
    if (ghWnd)
        SendMessageA(ghWnd, WM_CLOSE, 0, 0);
    DWORD dwTickEnd = GetTickCount() + 5000;
    while (ghThread && GetTickCount() < dwTickEnd)
        Sleep(50);
    DeleteCriticalSection(&g_csMeter);

    for (MTAG * pmtag = g_pmtagHead; pmtag; pmtag = g_pmtagHead)
    {
        g_pmtagHead = pmtag->pmtagNext;
        LocalFree(pmtag);
    }

    for (LBLK * plblk = g_plblkHead; plblk; plblk = g_plblkHead)
    {
        g_plblkHead = plblk->plblkNext;
        LocalFree(plblk);
    }

    if (g_aMTagByName)
    {
        LocalFree(g_aMTagByName);
    }

    if (g_aMTagOrphanByParent)
    {
        LocalFree(g_aMTagOrphanByParent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\othrthrd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       othrthrd.cxx
//
//  Contents:   Contains utilities that utilize the THREADSTATE data inside
//              MSHTML.DLL.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

void WINAPI
DbgExSetTopUrl(LPWSTR pstrUrl)
{
    WideCharToMultiByte(CP_ACP,
                        0,
                        pstrUrl,
                        -1,
                        TLS(achTopUrl),
                        TOPURL_LENGTH,
                        NULL,
                        NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTopURLForThread
//
//  Synopsis:   Returns the URL of the document in the given thread. For
//              multiple document threads (like a frameset) the topmost one
//              is returned.
//
//  Arguments:  [tid] -- Thread ID desired
//              [psz] -- Pre-allocated buffer to put URL into.
//
//  Returns:    HRESULT, S_FALSE if url cannot be obtained.
//
//  Notes:      Will put "<not available>" in the output string if it cannot
//              be obtained. On an error, [psz] will be empty. Assumes
//              that psz is a buffer of size TOPURL_LENGTH
//
//----------------------------------------------------------------------------

char * szNotAvail = "<not available>";

HRESULT
GetTopURLForThread(DWORD tid, char * psz)
{
    char * pszTop = TLS(achTopUrl);

    if (*pszTop == '\0')
    {
        strcpy(psz, szNotAvail);
        return S_FALSE;
    }
    else
    {
        strcpy(psz, pszTop);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\perftags.cxx ===
//+------------------------------------------------------------------------
//
//  File:       perftags.cxx
//
//  Contents:   Utilities for measuring perf
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#include <stddef.h>
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

struct LOGENTRY
{
    LOGENTRY *  pleNext;
    __int64     t;
    void *      pvObject;
    DWORD       dwThread;
    char        ach[1024];
};

struct LOGBLOCK
{
    LOGBLOCK *  plbNext;
    char        ach[8192];
};

struct LTAG
{
    BOOL    fEnabled;       // This must be first!
    LTAG *   ptagNext;
    char *  pchTag;
    char *  pchOwner;
    char *  pchDesc;
    char    ach[1];
};

extern HINSTANCE  g_hinstMain;
static LTAG *      g_ptagHead = NULL;
static LOGBLOCK * g_plbHead = NULL;
static LOGBLOCK * g_plbTail = NULL;
static LOGENTRY * g_plePrev = NULL;
static LOGENTRY * g_pleNext = NULL;
static UINT       g_cbLeft  = 0;
static UINT       g_nRuntimeAllocations = 0;
CRITICAL_SECTION  g_csLog;
static HWND     ghWnd           = NULL;
static HBRUSH   ghbrBkgnd       = NULL;
static HANDLE   ghThread        = NULL;
static BOOL     fDlgUp          = FALSE;
static DWORD    rgbWindowColor  = 0xFF000000;    // variables for the current
static DWORD    rgbHiliteColor  = 0xFF000000;    // system color settings.
static DWORD    rgbWindowText   = 0xFF000000;    // on a WM_SYSCOLORCHANGE
static DWORD    rgbHiliteText   = 0xFF000000;    // we check to see if we need
static DWORD    rgbGrayText     = 0xFF000000;    // to reload our bitmap.
static DWORD    rgbDDWindow     = 0xFF000000;    //
static DWORD    rgbDDHilite     = 0xFF000000;    // 0xFF000000 is an invalid RGB
static BOOL     g_fEnabled      = FALSE;
static BOOL     g_fAutoDump     = FALSE;
static BOOL     g_fAutoOpen     = FALSE;
static BOOL     g_fAutoDelete   = TRUE;
static BOOL     g_fSimpleDump   = TRUE;
static BOOL     g_fOverwriteDump= FALSE;
static char     g_achDumpFile[MAX_PATH]   = "";

void __cdecl hprintf(HANDLE hfile, char * pchFmt, ...);
#undef MemAlloc
#define MemAlloc(cb)    LocalAlloc(LMEM_FIXED, (cb))
#undef MemFree
#define MemFree(pv)     LocalFree(pv)
void DbgExPerfEnable(BOOL fEnable);


PERFTAG WINAPI
DbgExPerfRegister(char * szTag, char * szOwner, char * szDesc)
{
    EnterCriticalSection(&g_csLog);

    int cbTag   = lstrlenA(szTag) + 1;
    int cbOwner = lstrlenA(szOwner) + 1;
    int cbDesc  = lstrlenA(szDesc) + 1;
    LTAG * ptag  = (LTAG *)MemAlloc(offsetof(LTAG, ach) + cbTag + cbOwner + cbDesc);
    char * pch  = ptag->ach;

    if (!ptag)
        return NULL;

    ptag->ptagNext = g_ptagHead;
    ptag->fEnabled = (BYTE)!!GetPrivateProfileIntA("perftags", szTag, FALSE, "mshtmdbg.ini");

    ptag->pchTag = pch;
    lstrcpyA(pch, szTag);
    pch += cbTag;
    
    ptag->pchOwner = pch;
    lstrcpyA(pch, szOwner);
    pch += cbOwner;

    ptag->pchDesc = pch;
    lstrcpyA(pch, szDesc);

    g_ptagHead = ptag;

    LeaveCriticalSection(&g_csLog);

    if (ghWnd)
    {
        PostMessageA(ghWnd, WM_COMMAND, IDC_REFRESH, 0);
    }

    return((PERFTAG)ptag);
}

void WINAPI
DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list va)
{
    LOGENTRY    le;
    UINT        cb;

    if (!tag || !((LTAG *)tag)->fEnabled || !g_fEnabled)
        return;

    le.pleNext = NULL;
    le.pvObject = pvObj;
    le.dwThread = GetCurrentThreadId();

    cb = wvsprintfA(le.ach, pchFmt, va);
 
    cb = (cb + offsetof(LOGENTRY, ach) + 1);
    cb = (cb + 7) & ~7;

    EnterCriticalSection(&g_csLog);

    QueryPerformanceCounter((LARGE_INTEGER *)&le.t);

    if (cb > g_cbLeft)
    {
        LOGBLOCK * plb = (LOGBLOCK *)MemAlloc(sizeof(LOGBLOCK));

        if (plb == NULL)
            goto ret;

        plb->plbNext = NULL;

        if (g_plbTail)
        {
            g_plbTail->plbNext = plb;
            g_plbTail = plb;
        }
        else
        {
            g_plbHead = g_plbTail = plb;
        }

        g_pleNext = (LOGENTRY *)plb->ach;
        g_cbLeft  = sizeof(plb->ach);
        g_nRuntimeAllocations++;
    }

    if (g_plePrev)
        g_plePrev->pleNext = g_pleNext;

    g_plePrev = g_pleNext;
    g_pleNext = (LOGENTRY *)((BYTE *)g_plePrev + cb);
    g_cbLeft -= cb;
    memcpy(g_plePrev, &le, cb);

ret:
    LeaveCriticalSection(&g_csLog);
}

void __cdecl
DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...)
{
    va_list va;
    va_start(va, pchFmt);
    DbgExPerfLogFnList(tag, pvObj, pchFmt, va);
    va_end(va);
}

int __cdecl PerfLogCompareTime(const void * pv1, const void * pv2)
{
    __int64 t1 = (*(LOGENTRY **)pv1)->t;
    __int64 t2 = (*(LOGENTRY **)pv2)->t;
    return((t1 < t2) ? -1 : (t1 > t2) ? 1 : 0);
}

int __cdecl PerfLogCompareThread(const void * pv1, const void * pv2)
{
    DWORD dw1 = (*(LOGENTRY **)pv1)->dwThread;
    DWORD dw2 = (*(LOGENTRY **)pv2)->dwThread;
    return((dw1 < dw2) ? -1 : (dw1 > dw2) ? 1 : PerfLogCompareTime(pv1, pv2));
}

int __cdecl PerfLogCompareObject(const void * pv1, const void * pv2)
{
    DWORD_PTR dw1 = (DWORD_PTR)(*(LOGENTRY **)pv1)->pvObject;
    DWORD_PTR dw2 = (DWORD_PTR)(*(LOGENTRY **)pv2)->pvObject;
    return((dw1 < dw2) ? -1 : (dw1 > dw2) ? 1 : PerfLogCompareTime(pv1, pv2));
}

static void PerfLogDumpRange(HANDLE hfile, LOGENTRY ** pple, UINT cle)
{
    __int64 tmin = (*pple)->t, tfrq, tnext;
    LOGENTRY * ple;
    int cLevel = 0;
    int cbLog = 0, cbDelta;
    
    QueryPerformanceFrequency((LARGE_INTEGER *)&tfrq);

    hprintf(hfile, " TID         Time       Len      Object\r\n");

    for (; cle > 0; --cle, ++pple)
    {
        ple = *pple;
        tnext = (cle > 1) ? (*(pple + 1))->t : ple->t;

        hprintf(hfile, "%8lX %7ld.%02ld (%6ld.%02ld) %8lX ",
            ple->dwThread,
            (LONG)((ple->t - tmin) * 1000 / tfrq),
            (LONG)((ple->t - tmin) * 100000 / tfrq) % 100,
            (LONG)((tnext - ple->t) * 1000 / tfrq),
            (LONG)((tnext - ple->t) * 100000 / tfrq) % 100,
            ple->pvObject);

        if (ple->ach[0] == '-' && cLevel > 0)
            cLevel -= 1;

        for (int i = 0; i < cLevel; ++i)
            hprintf(hfile, "  ");

        hprintf(hfile, "%s\r\n", ple->ach);

        if (ple->ach[0] == '+')
            cLevel += 1;

        cbDelta = offsetof(LOGENTRY, ach) + lstrlenA(ple->ach) + 1; 
        cbDelta = (cbDelta + 7) & ~7;
        cbLog += cbDelta;
    }

    hprintf(hfile, "Log took %d bytes in %d runtime allocations\r\n\r\n", cbLog, g_nRuntimeAllocations);
}

char * GetPerfLogPath(char * pch)
{
    return lstrcpyA( pch, g_achDumpFile );
}

void WINAPI
DbgExPerfDump()
{
    EnterCriticalSection(&g_csLog);

    LOGENTRY *  pleHead = g_plbHead ? (LOGENTRY *)g_plbHead->ach : NULL;
    LOGENTRY *  ple, **pple;
    int         cle = 0;
    LOGENTRY ** rgple;
    char        achLog[MAX_PATH];
    HANDLE      hfile = CreateFileA(GetPerfLogPath(achLog), GENERIC_WRITE,
        FILE_SHARE_READ, NULL, g_fOverwriteDump ? CREATE_ALWAYS : OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        goto ret;

    SetFilePointer(hfile, 0, NULL, FILE_END);

    for (ple = pleHead; ple; ple = ple->pleNext)
    {
        cle += 1;
    }

    if (cle == 0)
    {
        CloseHandle(hfile);
        goto ret;
    }

    rgple = (LOGENTRY **)MemAlloc(cle * sizeof(LOGENTRY *));
    if (!rgple)
    {
        CloseHandle(hfile);
        goto ret;
    }

    for (ple = pleHead, pple = rgple; ple; ple = ple->pleNext, ++pple)
    {
        *pple = ple;
    }

    if (g_fSimpleDump)
    {
        hprintf(hfile, "+++ All Entries (as captured)\r\n\r\n");
        PerfLogDumpRange(hfile, rgple, cle);
    }
    else
    {
        int i;

        qsort(rgple, cle, sizeof(LOGENTRY *), PerfLogCompareTime);

        hprintf(hfile, "+++ All Entries\r\n\r\n");

        PerfLogDumpRange(hfile, rgple, cle);

        qsort(rgple, cle, sizeof(LOGENTRY *), PerfLogCompareThread);

        for (i = 0, pple = rgple; i < cle; ++i, ++pple)
        {
            LOGENTRY ** ppleBeg = pple;
            ple = *pple;

            for (++pple, ++i; i < cle; ++i, ++pple)
            {
                if ((*pple)->dwThread != ple->dwThread)
                    break;
            }

            if (pple - ppleBeg != cle)
            {
                hprintf(hfile, "+++ Entries On Thread %lX\r\n\r\n", ple->dwThread);

                PerfLogDumpRange(hfile, ppleBeg, pple - ppleBeg);
            }

            i -= 1;
            pple -= 1;
        }

        qsort(rgple, cle, sizeof(LOGENTRY *), PerfLogCompareObject);

        for (i = 0, pple = rgple; i < cle; ++i, ++pple)
        {
            LOGENTRY ** ppleBeg = pple;
            ple = *pple;

            for (++pple, ++i; i < cle; ++i, ++pple)
            {
                if ((*pple)->pvObject != ple->pvObject)
                    break;
            }

            if (pple - ppleBeg != cle)
            {
                hprintf(hfile, "+++ Entries On Object %lX\r\n\r\n", ple->pvObject);
                PerfLogDumpRange(hfile, ppleBeg, pple - ppleBeg);
            }

            i -= 1;
            pple -= 1;
        }
    }

    hprintf(hfile, "------------------------------------------------------------------------------\r\n\r\n");

    CloseHandle(hfile);

    MemFree(rgple);

    DbgExPerfClear();

ret:
    LeaveCriticalSection(&g_csLog);
}

void WINAPI
DbgExPerfClear()
{
    LOGBLOCK * plb, * plbNext;

    EnterCriticalSection(&g_csLog);

    for (plb = g_plbHead, plbNext = NULL; plb; plb = plbNext)
    {
        plbNext = plb->plbNext;
        MemFree(plb);
    }

    g_plbHead = NULL;
    g_plbTail = NULL;
    g_plePrev = NULL;
    g_pleNext = NULL;
    g_cbLeft  = 0;

    LeaveCriticalSection(&g_csLog);
}

//+---------------------------------------------------------------------------
//  Perf Monitor
//----------------------------------------------------------------------------

DWORD WINAPI
PerfMonitorThread(LPVOID lpv);

INT_PTR WINAPI
PerfMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void    SetWindowTitle(HWND hWnd, LPSTR lpcText);
void    RefreshView(HWND hWnd);
void    SetSumSelection(void);
void    TagListNotify(WORD wNotify, HWND  hWnd);

void    MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
int     CompareItem(LPCOMPAREITEMSTRUCT pcis);
void    DrawItem(LPDRAWITEMSTRUCT pdis);
void    OutTextFormat(LPDRAWITEMSTRUCT pdis);
static void SetRGBValues(void);

//  Global Data

void WINAPI
DbgExPerfTags()
{
    EnterCriticalSection(&g_csLog);

    if (!ghThread)
    {
        DWORD dwThreadId;

        fDlgUp = TRUE;

        ghThread = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0,
            (LPTHREAD_START_ROUTINE)PerfMonitorThread,
            NULL, 0, &dwThreadId);
    }

    LeaveCriticalSection(&g_csLog);
}

DWORD WINAPI PerfMonitorThread(LPVOID)
{
    ghbrBkgnd = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));

    DialogBoxA(g_hinstMain, MAKEINTRESOURCEA(IDD_PERFTAGS), NULL, PerfMonDlgProc);

    DeleteObject(ghbrBkgnd);
	ghThread = NULL;
    
    return 0;
}

void RefreshView(HWND hWnd)
{
    SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_RESETCONTENT, 0, 0L);

    for (LTAG * ptag = g_ptagHead; ptag; ptag = ptag->ptagNext)
    {
        SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_ADDSTRING, 0, (LPARAM)ptag);
    }

    SetWindowTitle(GetDlgItem(hWnd, IDC_STARTSTOP), g_fEnabled ? "Start" : "Stop");
}

void TagListNotify(WORD wNotify, HWND hWnd)
{
    LONG    idx;
    LTAG *   ptag;
    RECT    rc;
    
    if (wNotify == LBN_DBLCLK)
    {
        idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);
        if (idx == CB_ERR)
            return;

        ptag = (LTAG *)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
        if (ptag == (LTAG *)CB_ERR)
            return;
        
        ptag->fEnabled = !ptag->fEnabled;

        WritePrivateProfileStringA("perftags", ptag->pchTag,
            ptag->fEnabled ? "1" : "0", "mshtmdbg.ini");

        if (SendMessageA(hWnd, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        {
            RedrawWindow(hWnd, &rc, NULL, RDW_INVALIDATE);
        }
    }
}

INT_PTR WINAPI
PerfMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    char    achLog[MAX_PATH];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghWnd = hWnd;
            SetRGBValues();
            SetWindowTitle(hWnd, "PerfTags - %s");
            RefreshView(hWnd);
            ShowWindow(hWnd, SW_SHOWMINNOACTIVE);
            break;

        case WM_SYSCOLORCHANGE:
            SetRGBValues();
            RefreshView(hWnd);
            break;
            
        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;
            
        case WM_DRAWITEM:
            DrawItem((LPDRAWITEMSTRUCT)lParam);
            break;
            
        case WM_COMPAREITEM:
            return CompareItem((COMPAREITEMSTRUCT *)lParam);
            
        case WM_PAINT:
            return FALSE;

        case WM_ERASEBKGND:
            return IsIconic(hWnd);

        case WM_QUERYENDSESSION:
            PostMessageA(hWnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            fDlgUp = FALSE;
            return EndDialog(hWnd, 0);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {                       
                case IDC_TAGLIST:
                    TagListNotify(HIWORD(wParam), (HWND)lParam);
                    break;

                case IDC_ENABLEALL:
                case IDC_DISABLEALL:
                {
                    for (LTAG * ptag = g_ptagHead; ptag; ptag = ptag->ptagNext)
                    {
                        if (ptag->fEnabled != !!(LOWORD(wParam) == IDC_ENABLEALL))
                        {
                            ptag->fEnabled = !ptag->fEnabled;
                            WritePrivateProfileStringA("perftags", ptag->pchTag,
                                ptag->fEnabled ? "1" : "0", "mshtmdbg.ini");
                        }
                    }

                    RefreshView(ghWnd);
                    break;
                }

                case IDC_CLEARLOG:
                    DbgExPerfClear();
                    break;

                case IDC_DUMPLOG:
                    DbgExPerfDump();
                    break;

                case IDC_DELETELOG:
                    DeleteFileA(GetPerfLogPath(achLog));
                    break;

                case IDC_REFRESH:
                    RefreshView(ghWnd);
                    break;

                case IDC_STARTSTOP:
                    DbgExPerfEnable( !g_fEnabled );
                    break;

                default:
                    return FALSE;
            }
            break;
        default:
            return FALSE;
    }
    
    return TRUE;
}

int CompareItem(LPCOMPAREITEMSTRUCT pcis)
{
    LTAG * ptag1 = (LTAG *)pcis->itemData1;
    LTAG * ptag2 = (LTAG *)pcis->itemData2;
    int iCmp;
    
    iCmp = lstrcmpA(ptag1->pchOwner, ptag2->pchOwner);

    if (iCmp == 0)
        iCmp = lstrcmpA(ptag1->pchDesc, ptag2->pchDesc);

    if (iCmp < 0)
        iCmp = -1;
    else if (iCmp > 0)
        iCmp = 1;

    return(iCmp);
}

void DrawItem(LPDRAWITEMSTRUCT pdis)
{
    char ach[1024];
    COLORREF crText = 0, crBack = 0;
    LTAG * ptag = (LTAG *)pdis->itemData;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if(pdis->itemState & ODS_SELECTED)
        {
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        wsprintfA(ach, " %s %-14s %s", ptag->fEnabled ? "[X]" : "[ ]",
            ptag->pchOwner, ptag->pchDesc);

        ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
            ETO_OPAQUE | ETO_CLIPPED, &pdis->rcItem, ach, lstrlenA(ach), NULL);

        // Restore original colors if we changed them above.
        if(pdis->itemState & ODS_SELECTED)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}

static void SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}

void
PerfProcessAttach()
{
    InitializeCriticalSection(&g_csLog);
    g_fAutoDump   = GetPrivateProfileIntA("perftags", "AutoDump", FALSE, "mshtmdbg.ini");
    g_fAutoOpen   = GetPrivateProfileIntA("perftags", "AutoOpen", FALSE, "mshtmdbg.ini");
    g_fAutoDelete = GetPrivateProfileIntA("perftags", "AutoDelete", TRUE, "mshtmdbg.ini");
    g_fSimpleDump = GetPrivateProfileIntA("perftags", "SimpleDump", TRUE, "mshtmdbg.ini");
    g_fOverwriteDump = GetPrivateProfileIntA("perftags", "OverwriteDump", FALSE, "mshtmdbg.ini");
    GetPrivateProfileStringA("perftags", "DumpFile", "", g_achDumpFile, MAX_PATH, "mshtmdbg.ini");

    if (g_achDumpFile[0] == '\0')
    {
        char    szModule[MAX_PATH];
        char *  pszModule;

        GetModuleFileNameA(NULL, szModule, MAX_PATH);
    
        pszModule = (LPSTR)(szModule + lstrlenA(szModule));
    
        while (*pszModule-- != '\\') ;

        pszModule += 2;
    
        CharUpperBuffA(pszModule, lstrlenA(pszModule));
    
        wsprintfA(g_achDumpFile, "\\%s-%lX.log", pszModule, GetCurrentProcessId());
    }

    {
        int cbPreAllocLog = GetPrivateProfileIntA("perftags", "PreAllocLog", 0, "mshtmdbg.ini");
        if (cbPreAllocLog)
        {
            LOGBLOCK * plb = (LOGBLOCK *)MemAlloc(offsetof(LOGBLOCK, ach) + cbPreAllocLog);

            if (plb)
            {
                plb->plbNext = NULL;

                g_plbHead = g_plbTail = plb;

                g_pleNext = (LOGENTRY *)plb->ach;
                g_cbLeft  = cbPreAllocLog;
            }
        }
    }

    if (g_fAutoDump)
        g_fEnabled = TRUE;
    if (g_fAutoOpen)
        DbgExPerfTags();
}

void
PerfProcessDetach()
{
    if (g_fAutoDump)
    {
        if (g_fAutoDelete)
        {
            char achLog[MAX_PATH];
            DeleteFileA(GetPerfLogPath(achLog));
        }

        DbgExPerfDump();
    }
    if (ghWnd)
        SendMessageA(ghWnd, WM_CLOSE, 0, 0);
    DWORD dwTickEnd = GetTickCount() + 5000;
    while (ghThread && GetTickCount() < dwTickEnd)
		Sleep(50);

    DbgExPerfClear();
    
    for (LTAG * ptag = g_ptagHead; ptag; ptag = g_ptagHead)
    {
        g_ptagHead = ptag->ptagNext;
        MemFree(ptag);
    }

    DeleteCriticalSection(&g_csLog);
}

char * WINAPI
DbgExDecodeMessage(UINT msg)
{
    static char szBuf[12];

    *szBuf = '\0';
    
    switch (msg)
    {
        case WM_NULL:               return(" WM_NULL");
        case WM_CREATE:             return(" WM_CREATE");
        case WM_DESTROY:            return(" WM_DESTROY");
        case WM_MOVE:               return(" WM_MOVE");
        case WM_SIZE:               return(" WM_SIZE");
        case WM_ACTIVATE:           return(" WM_ACTIVATE");
        case WM_SETFOCUS:           return(" WM_SETFOCUS");
        case WM_KILLFOCUS:          return(" WM_KILLFOCUS");
        case WM_ENABLE:             return(" WM_ENABLE");
        case WM_SETREDRAW:          return(" WM_SETREDRAW");
        case WM_SETTEXT:            return(" WM_SETTEXT");
        case WM_GETTEXT:            return(" WM_GETTEXT");
        case WM_GETTEXTLENGTH:      return(" WM_GETTEXTLENGTH");
        case WM_PAINT:              return(" WM_PAINT");
        case WM_CLOSE:              return(" WM_CLOSE");
        case WM_QUERYENDSESSION:    return(" WM_QUERYENDSESSION");
        case WM_QUERYOPEN:          return(" WM_QUERYOPEN");
        case WM_ENDSESSION:         return(" WM_ENDSESSION");
        case WM_QUIT:               return(" WM_QUIT");
        case WM_ERASEBKGND:         return(" WM_ERASEBKGND");
        case WM_SYSCOLORCHANGE:     return(" WM_SYSCOLORCHANGE");
        case WM_SHOWWINDOW:         return(" WM_SHOWWINDOW");
        case WM_WININICHANGE:       return(" WM_WININICHANGE");
        case WM_DEVMODECHANGE:      return(" WM_DEVMODECHANGE");
        case WM_ACTIVATEAPP:        return(" WM_ACTIVATEAPP");
        case WM_FONTCHANGE:         return(" WM_FONTCHANGE");
        case WM_TIMECHANGE:         return(" WM_TIMECHANGE");
        case WM_CANCELMODE:         return(" WM_CANCELMODE");
        case WM_SETCURSOR:          return(" WM_SETCURSOR");
        case WM_MOUSEACTIVATE:      return(" WM_MOUSEACTIVATE");
        case WM_CHILDACTIVATE:      return(" WM_CHILDACTIVATE");
        case WM_QUEUESYNC:          return(" WM_QUEUESYNC");
        case WM_GETMINMAXINFO:      return(" WM_GETMINMAXINFO");
        case WM_PAINTICON:          return(" WM_PAINTICON");
        case WM_ICONERASEBKGND:     return(" WM_ICONERASEBKGND");
        case WM_NEXTDLGCTL:         return(" WM_NEXTDLGCTL");
        case WM_SPOOLERSTATUS:      return(" WM_SPOOLERSTATUS");
        case WM_DRAWITEM:           return(" WM_DRAWITEM");
        case WM_MEASUREITEM:        return(" WM_MEASUREITEM");
        case WM_DELETEITEM:         return(" WM_DELETEITEM");
        case WM_VKEYTOITEM:         return(" WM_VKEYTOITEM");
        case WM_CHARTOITEM:         return(" WM_CHARTOITEM");
        case WM_SETFONT:            return(" WM_SETFONT");
        case WM_GETFONT:            return(" WM_GETFONT");
        case WM_SETHOTKEY:          return(" WM_SETHOTKEY");
        case WM_GETHOTKEY:          return(" WM_GETHOTKEY");
        case WM_QUERYDRAGICON:      return(" WM_QUERYDRAGICON");
        case WM_COMPAREITEM:        return(" WM_COMPAREITEM");
        case WM_COMPACTING:         return(" WM_COMPACTING");
        case WM_COMMNOTIFY:         return(" WM_COMMNOTIFY");
        case WM_WINDOWPOSCHANGING:  return(" WM_WINDOWPOSCHANGING");
        case WM_WINDOWPOSCHANGED:   return(" WM_WINDOWPOSCHANGED");
        case WM_POWER:              return(" WM_POWER");
        case WM_COPYDATA:           return(" WM_COPYDATA");
        case WM_CANCELJOURNAL:      return(" WM_CANCELJOURNAL");
        case WM_NOTIFY:             return(" WM_NOTIFY");
        case WM_INPUTLANGCHANGEREQUEST: return(" WM_INPUTLANGCHANGEREQUEST");
        case WM_INPUTLANGCHANGE:    return(" WM_INPUTLANGCHANGE");
        case WM_TCARD:              return(" WM_TCARD");
        case WM_HELP:               return(" WM_HELP");
        case WM_USERCHANGED:        return(" WM_USERCHANGED");
        case WM_NOTIFYFORMAT:       return(" WM_NOTIFYFORMAT");
        case WM_CONTEXTMENU:        return(" WM_CONTEXTMENU");
        case WM_STYLECHANGING:      return(" WM_STYLECHANGING");
        case WM_STYLECHANGED:       return(" WM_STYLECHANGED");
        case WM_DISPLAYCHANGE:      return(" WM_DISPLAYCHANGE");
        case WM_GETICON:            return(" WM_GETICON");
        case WM_SETICON:            return(" WM_SETICON");
        case WM_NCCREATE:           return(" WM_NCCREATE");
        case WM_NCDESTROY:          return(" WM_NCDESTROY");
        case WM_NCCALCSIZE:         return(" WM_NCCALCSIZE");
        case WM_NCHITTEST:          return(" WM_NCHITTEST");
        case WM_NCPAINT:            return(" WM_NCPAINT");
        case WM_NCACTIVATE:         return(" WM_NCACTIVATE");
        case WM_GETDLGCODE:         return(" WM_GETDLGCODE");
        case WM_SYNCPAINT:          return(" WM_SYNCPAINT");
        case WM_NCMOUSEMOVE:        return(" WM_NCMOUSEMOVE");
        case WM_NCLBUTTONDOWN:      return(" WM_NCLBUTTONDOWN");
        case WM_NCLBUTTONUP:        return(" WM_NCLBUTTONUP");
        case WM_NCLBUTTONDBLCLK:    return(" WM_NCLBUTTONDBLCLK");
        case WM_NCRBUTTONDOWN:      return(" WM_NCRBUTTONDOWN");
        case WM_NCRBUTTONUP:        return(" WM_NCRBUTTONUP");
        case WM_NCRBUTTONDBLCLK:    return(" WM_NCRBUTTONDBLCLK");
        case WM_NCMBUTTONDOWN:      return(" WM_NCMBUTTONDOWN");
        case WM_NCMBUTTONUP:        return(" WM_NCMBUTTONUP");
        case WM_NCMBUTTONDBLCLK:    return(" WM_NCMBUTTONDBLCLK");
        case WM_KEYDOWN:            return(" WM_KEYDOWN");
        case WM_KEYUP:              return(" WM_KEYUP");
        case WM_CHAR:               return(" WM_CHAR");
        case WM_DEADCHAR:           return(" WM_DEADCHAR");
        case WM_SYSKEYDOWN:         return(" WM_SYSKEYDOWN");
        case WM_SYSKEYUP:           return(" WM_SYSKEYUP");
        case WM_SYSCHAR:            return(" WM_SYSCHAR");
        case WM_SYSDEADCHAR:        return(" WM_SYSDEADCHAR");
        case WM_IME_STARTCOMPOSITION:   return(" WM_IME_STARTCOMPOSITION");
        case WM_IME_ENDCOMPOSITION: return(" WM_IME_ENDCOMPOSITION");
        case WM_IME_COMPOSITION:    return(" WM_IME_COMPOSITION");
        case WM_INITDIALOG:         return(" WM_INITDIALOG");
        case WM_COMMAND:            return(" WM_COMMAND");
        case WM_SYSCOMMAND:         return(" WM_SYSCOMMAND");
        case WM_TIMER:              return(" WM_TIMER");
        case WM_HSCROLL:            return(" WM_HSCROLL");
        case WM_VSCROLL:            return(" WM_VSCROLL");
        case WM_INITMENU:           return(" WM_INITMENU");
        case WM_INITMENUPOPUP:      return(" WM_INITMENUPOPUP");
        case WM_MENUSELECT:         return(" WM_MENUSELECT");
        case WM_MENUCHAR:           return(" WM_MENUCHAR");
        case WM_ENTERIDLE:          return(" WM_ENTERIDLE");
        case WM_CTLCOLORMSGBOX:     return(" WM_CTLCOLORMSGBOX");
        case WM_CTLCOLOREDIT:       return(" WM_CTLCOLOREDIT");
        case WM_CTLCOLORLISTBOX:    return(" WM_CTLCOLORLISTBOX");
        case WM_CTLCOLORBTN:        return(" WM_CTLCOLORBTN");
        case WM_CTLCOLORDLG:        return(" WM_CTLCOLORDLG");
        case WM_CTLCOLORSCROLLBAR:  return(" WM_CTLCOLORSCROLLBAR");
        case WM_CTLCOLORSTATIC:     return(" WM_CTLCOLORSTATIC");
        case WM_MOUSEMOVE:          return(" WM_MOUSEMOVE");
        case WM_LBUTTONDOWN:        return(" WM_LBUTTONDOWN");
        case WM_LBUTTONUP:          return(" WM_LBUTTONUP");
        case WM_LBUTTONDBLCLK:      return(" WM_LBUTTONDBLCLK");
        case WM_RBUTTONDOWN:        return(" WM_RBUTTONDOWN");
        case WM_RBUTTONUP:          return(" WM_RBUTTONUP");
        case WM_RBUTTONDBLCLK:      return(" WM_RBUTTONDBLCLK");
        case WM_MBUTTONDOWN:        return(" WM_MBUTTONDOWN");
        case WM_MBUTTONUP:          return(" WM_MBUTTONUP");
        case WM_MBUTTONDBLCLK:      return(" WM_MBUTTONDBLCLK");
        case WM_MOUSEWHEEL:         return(" WM_MOUSEWHEEL");
        case WM_PARENTNOTIFY:       return(" WM_PARENTNOTIFY");
        case WM_ENTERMENULOOP:      return(" WM_ENTERMENULOOP");
        case WM_EXITMENULOOP:       return(" WM_EXITMENULOOP");
        case WM_NEXTMENU:           return(" WM_NEXTMENU");
        case WM_SIZING:             return(" WM_SIZING");
        case WM_CAPTURECHANGED:     return(" WM_CAPTURECHANGED");
        case WM_MOVING:             return(" WM_MOVING");
        case WM_POWERBROADCAST:     return(" WM_POWERBROADCAST");
        case WM_DEVICECHANGE:       return(" WM_DEVICECHANGE");
        case WM_MDICREATE:          return(" WM_MDICREATE");
        case WM_MDIDESTROY:         return(" WM_MDIDESTROY");
        case WM_MDIACTIVATE:        return(" WM_MDIACTIVATE");
        case WM_MDIRESTORE:         return(" WM_MDIRESTORE");
        case WM_MDINEXT:            return(" WM_MDINEXT");
        case WM_MDIMAXIMIZE:        return(" WM_MDIMAXIMIZE");
        case WM_MDITILE:            return(" WM_MDITILE");
        case WM_MDICASCADE:         return(" WM_MDICASCADE");
        case WM_MDIICONARRANGE:     return(" WM_MDIICONARRANGE");
        case WM_MDIGETACTIVE:       return(" WM_MDIGETACTIVE");
        case WM_MDISETMENU:         return(" WM_MDISETMENU");
        case WM_ENTERSIZEMOVE:      return(" WM_ENTERSIZEMOVE");
        case WM_EXITSIZEMOVE:       return(" WM_EXITSIZEMOVE");
        case WM_DROPFILES:          return(" WM_DROPFILES");
        case WM_MDIREFRESHMENU:     return(" WM_MDIREFRESHMENU");
        case WM_IME_SETCONTEXT:     return(" WM_IME_SETCONTEXT");
        case WM_IME_NOTIFY:         return(" WM_IME_NOTIFY");
        case WM_IME_CONTROL:        return(" WM_IME_CONTROL");
        case WM_IME_COMPOSITIONFULL:    return(" WM_IME_COMPOSITIONFULL");
        case WM_IME_SELECT:         return(" WM_IME_SELECT");
        case WM_IME_CHAR:           return(" WM_IME_CHAR");
        case WM_IME_KEYDOWN:        return(" WM_IME_KEYDOWN");
        case WM_IME_KEYUP:          return(" WM_IME_KEYUP");
        case WM_MOUSEHOVER:         return(" WM_MOUSEHOVER");
        case WM_MOUSELEAVE:         return(" WM_MOUSELEAVE");
        case WM_CUT:                return(" WM_CUT");
        case WM_COPY:               return(" WM_COPY");
        case WM_PASTE:              return(" WM_PASTE");
        case WM_CLEAR:              return(" WM_CLEAR");
        case WM_UNDO:               return(" WM_UNDO");
        case WM_RENDERFORMAT:       return(" WM_RENDERFORMAT");
        case WM_RENDERALLFORMATS:   return(" WM_RENDERALLFORMATS");
        case WM_DESTROYCLIPBOARD:   return(" WM_DESTROYCLIPBOARD");
        case WM_DRAWCLIPBOARD:      return(" WM_DRAWCLIPBOARD");
        case WM_PAINTCLIPBOARD:     return(" WM_PAINTCLIPBOARD");
        case WM_VSCROLLCLIPBOARD:   return(" WM_VSCROLLCLIPBOARD");
        case WM_SIZECLIPBOARD:      return(" WM_SIZECLIPBOARD");
        case WM_ASKCBFORMATNAME:    return(" WM_ASKCBFORMATNAME");
        case WM_CHANGECBCHAIN:      return(" WM_CHANGECBCHAIN");
        case WM_HSCROLLCLIPBOARD:   return(" WM_HSCROLLCLIPBOARD");
        case WM_QUERYNEWPALETTE:    return(" WM_QUERYNEWPALETTE");
        case WM_PALETTEISCHANGING:  return(" WM_PALETTEISCHANGING");
        case WM_PALETTECHANGED:     return(" WM_PALETTECHANGED");
        case WM_HOTKEY:             return(" WM_HOTKEY");
        case WM_PRINT:              return(" WM_PRINT");
        case WM_PRINTCLIENT:        return(" WM_PRINTCLIENT");
        case WM_USER:               return(" WM_USER");
        case WM_USER+1:             return(" WM_USER+1");
        case WM_USER+2:             return(" WM_USER+2");
        case WM_USER+3:             return(" WM_USER+3");
        case WM_USER+4:             return(" WM_USER+4");
        default:
            wsprintfA(szBuf, "0x%x", msg);
            break;
    }

    return(szBuf);
}

void 
DbgExPerfEnable( BOOL fEnable )
{
    EnterCriticalSection(&g_csLog);

    g_fEnabled = !g_fEnabled;
    if (ghWnd)
    {
        PostMessageA(ghWnd, WM_COMMAND, IDC_REFRESH, 0);
    }

    LeaveCriticalSection(&g_csLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\ffail.cxx ===
//+---------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//  
//  File:       ffail.cxx
//  
//  Contents:   Debug functions that you don't want to step into in
//              the debugger.  This module is compiled without the /Zi flag.
//  
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

BOOL g_fJustFailed;

//+---------------------------------------------------------------------------
//  
//  Function:   DbgExFFail
//  
//  Synopsis:   Fails if count of fails is positive and evenly divides
//              interval count.
//  
//----------------------------------------------------------------------------


BOOL WINAPI
DbgExFFail()
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    // NOTE (garybu) Fail count should be per thread. Turn off crit sect for speed.
    // LOCK_GLOBALS;

    g_fJustFailed = (++g_cFFailCalled < 0) ? FALSE : ! (g_cFFailCalled % g_cInterval);
    return g_fJustFailed;
}



//+---------------------------------------------------------------------------
//  
//  Function:   JustFailed
//  
//  Synopsis:   Returns result of last call to FFail
//  
//----------------------------------------------------------------------------

BOOL
JustFailed()
{
    return g_fJustFailed;
}



//+------------------------------------------------------------------------
//  
//  Function:   DbgExGetFailCount
//  
//  Synopsis:   Returns the number of failure points that have been
//              passed since the last failure count reset
//  
//  Returns:    int
//  
//-------------------------------------------------------------------------

int WINAPI
DbgExGetFailCount()
{
    // NOTE (garybu) Fail count should be per thread. Turn off crit sect for speed.
    // LOCK_GLOBALS;

    Assert(g_firstFailure >= 0);
    return g_cFFailCalled + ((g_firstFailure != 0) ? g_firstFailure : INT_MIN);
}

// used for assert to fool the compiler

DWORD g_dwFALSE = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\magic.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       magic.cxx
//
//  Contents:   Stack backtracing functions
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_IMAGEHLP_H_
#define X_IMAGEHLP_H_
#include <imagehlp.h>
#endif

//$ WIN64: Needs to use 64-bit APIs for ImageHelp

BOOL       g_fLoadedImageHlp = FALSE;
HINSTANCE  g_hinstImageHlp   = NULL;
BOOL       g_fOSIsNT         = FALSE;

ExternTag(tagMagic);

//
// Critical Section used to serialize access to imagehlp.dll
//
void TestStackTrace(void);

// Function Pointers to APIs in IMAGEHLP.DLL. Loaded dynamically.
//
typedef LPAPI_VERSION (__stdcall *pfnImgHlp_ImagehlpApiVersionEx)(
    LPAPI_VERSION AppVersion
    );

typedef BOOL (__stdcall *pfnImgHlp_StackWalk)(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetModuleInfo)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE    ModuleInfo
    );

typedef LPVOID (__stdcall *pfnImgHlp_SymFunctionTableAccess)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetSymFromAddr)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PDWORD              pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    );

typedef BOOL (__stdcall *pfnImgHlp_SymInitialize)(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     fInvadeProcess
    );

typedef BOOL (__stdcall *pfnImgHlp_SymLoadModule)(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );

typedef DWORD (__stdcall *pfnImgHlp_SymSetOptions)(
    IN  DWORD           SymOptions
    );

pfnImgHlp_ImagehlpApiVersionEx    _ImagehlpApiVersionEx;
pfnImgHlp_StackWalk               _StackWalk;
pfnImgHlp_SymGetModuleInfo        _SymGetModuleInfo;
pfnImgHlp_SymFunctionTableAccess  _SymFunctionTableAccess;
pfnImgHlp_SymGetSymFromAddr       _SymGetSymFromAddr;
pfnImgHlp_SymInitialize           _SymInitialize;
pfnImgHlp_SymLoadModule           _SymLoadModule;
pfnImgHlp_SymSetOptions           _SymSetOptions;


struct IMGHLPFN_LOAD
{
    LPSTR   pszFnName;
    LPVOID * ppvfn;
};

IMGHLPFN_LOAD ailFuncList[] =
{
    { "ImagehlpApiVersionEx",   (LPVOID*)&_ImagehlpApiVersionEx },
    { "StackWalk",              (LPVOID*)&_StackWalk },
    { "SymGetModuleInfo",       (LPVOID*)&_SymGetModuleInfo },
    { "SymFunctionTableAccess", (LPVOID*)&_SymFunctionTableAccess },
    { "SymGetSymFromAddr",      (LPVOID*)&_SymGetSymFromAddr },
    { "SymInitialize",          (LPVOID*)&_SymInitialize },
    { "SymLoadModule",          (LPVOID*)&_SymLoadModule },
    { "SymSetOptions",          (LPVOID*)&_SymSetOptions },
};


//+---------------------------------------------------------------------------
//
//  Function:   MagicInit
//
//  Synopsis:   Initializes the symbol loading code.
//
//----------------------------------------------------------------------------

void
MagicInit(void)
{
    OSVERSIONINFOA ovi;
    API_VERSION    AppVersion = { 4, 0, API_VERSION_NUMBER, 0 };
    PSTR           pszModPath;
    char           achBuf[MAX_PATH*3];
    char           achBuf2[MAX_PATH];
    char        *  pch;

    int i;

    TraceTag((tagMagic, "MagicInit: Starting."));

    //
    // Get what operating system we're on.
    //
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    Verify(GetVersionExA(&ovi));

    g_fOSIsNT = (ovi.dwPlatformId == VER_PLATFORM_WIN32_NT);

    //
    // Try to load imagehlp.dll
    //
    g_hinstImageHlp = LoadLibraryA("imagehlp.dll");

    if (!g_hinstImageHlp)
    {
        TraceTag((tagWarning, "IMAGEHLP.DLL could not be loaded."));

        return;
    }

    //
    // Try to get the API entrypoints in imagehlp.dll
    //
    for (i=0; i < ARRAY_SIZE(ailFuncList); i++)
    {
        *(ailFuncList[i].ppvfn) = GetProcAddress(g_hinstImageHlp,
                                                 ailFuncList[i].pszFnName);
        if (!*(ailFuncList[i].ppvfn))
        {
            return;
        }
    }

    LPAPI_VERSION papiver = _ImagehlpApiVersionEx(&AppVersion);

    //
    // Verify that imagehlp.dll is a version we're compatible with.
    //
    // (jbeda) It looks like Millinium is returning NULL here (?)
    if (!papiver || (papiver->Revision < 6) || (papiver->Revision > 9))
    {
        TraceTag((tagError, "IMAGEHLP.DLL version mismatch or NULL returned from _ImagehlpApiVersionEx"));
        return;
    }

    g_fLoadedImageHlp = TRUE;


    //
    // ImageHlp doesn't look it very good places for the symbols by default,
    // so here we construct two paths based on where this DLL is located. We
    // set the symbol search path to:
    //
    //       "<dllpath>;<dllpath>\symbols\retail\dll;<windir>\symbols\dll"
    //
    pszModPath = NULL;
    achBuf[0] = 0;

    if (GetModuleFileNameA(g_hinstMain, achBuf, sizeof(achBuf)))
    {
        pch = strrchr(achBuf, '\\');
        if (pch)
        {
            *pch = '\0';
        }

        strcat(achBuf, ";");

        strncat(achBuf, achBuf, strlen(achBuf)-1);

        strcat(achBuf, "\\symbols\\retail\\dll");

        pszModPath = achBuf;
    }

    if (GetWindowsDirectoryA(achBuf2, MAX_PATH))
    {
        strcat(achBuf, ";");
        strcat(achBuf, achBuf2);
        strcat(achBuf, "\\symbols\\dll");
        pszModPath = achBuf;
    }

    _SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);

    //
    // Initialize imagehlp.dll
    //
    TraceTag((tagMagic, "Symbol search path is %s", pszModPath));
    if (!_SymInitialize(g_hProcess, pszModPath, FALSE))
    {
        g_fLoadedImageHlp = FALSE;
    }

    // TestStackTrace();

    TraceTag((tagMagic, "MagicInit: Returning."));

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   MagicDeinit
//
//  Synopsis:   Cleans up for the symbol loading code.
//
//----------------------------------------------------------------------------

void
MagicDeinit(void)
{
    if (g_hinstImageHlp)
    {
        FreeLibrary(g_hinstImageHlp);

        g_hinstImageHlp   = NULL;
        g_fLoadedImageHlp = FALSE;
    }
}

//
// WARNING -- All the functions between here and GetStackBactrace should
// not be called from outside this file! Otherwise this code will not be
// reentrant!
//

//+---------------------------------------------------------------------------
//
//  Function:   AreSymbolsEnabled
//
//  Synopsis:   Returns TRUE if symbols are enabled.
//
//----------------------------------------------------------------------------

BOOL
AreSymbolsEnabled(void)
{
    return (    g_fLoadedImageHlp
            &&  (   DbgExIsTagEnabled(tagSymbols)
                ||  (   DbgExIsTagEnabled(tagSpySymbols)
                    &&  DbgGetThreadState()
                    &&  TLS(fSpyAlloc))));
}

DWORD
LoadModuleFromVMemData(HANDLE hProcess, DWORD dwAddr)
{
    MEMORY_BASIC_INFORMATION mbi;
    char                     achFile[MAX_PATH] = {0};
    DWORD                    cch = 0;

    if (VirtualQueryEx(hProcess, (LPVOID)(DWORD_PTR)dwAddr, &mbi, sizeof(mbi)))
    {
        if (!g_fOSIsNT || (mbi.Type & MEM_IMAGE))
        {
            cch = GetModuleFileNameA((HINSTANCE)mbi.AllocationBase,
                                     achFile,
                                     MAX_PATH);

            TraceTag((tagMagic, "Module Filename is %s", achFile));

            // Ignore the return code since we can't do anything with it.
            if (!_SymLoadModule(hProcess,
                           NULL,
                           ((cch) ? achFile : NULL),
                           NULL,
                           (DWORD)(DWORD_PTR)mbi.AllocationBase,
                           0))
            {
                TraceTag((tagMagic, "SymLoadModule failed with %d", GetLastError()));
            }
            else
            {
                TraceTag((tagMagic, "SymLoadModule succeeded"));
            }

            return (DWORD)(DWORD_PTR)mbi.AllocationBase;
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FillSymbolInfo
//
//  Synopsis:   Fills in a INET_SYMBOL_INFO struct
//
//  Arguments:  [psi]    -- INET_SYMBOL_INFO to fill
//              [dwAddr] -- Address to get symbols of.
//
//----------------------------------------------------------------------------

void
FillSymbolInfo(INET_SYMBOL_INFO *psi, DWORD dwAddr)
{
    union {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };
    CHAR * pszSymbol = NULL;
    IMAGEHLP_MODULE  mi;
    BOOL             fFoundModule = TRUE;

    Assert(psi);

    memset(psi, 0, sizeof(INET_SYMBOL_INFO));

    if (!g_fLoadedImageHlp)
    {
        TraceTag((tagMagic, "ImageHlp not loaded! Bailing out of FillSymbolInfo"));
        return;
    }

    memset(&mi, 0, sizeof(mi));
    mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (!_SymGetModuleInfo(g_hProcess, dwAddr, &mi))
    {
        TraceTag((tagMagic, "SymGetModuleInfo failed with %d", GetLastError()));
        //
        // Attempt to load the module here if it hasn't been loaded yet.
        //
        // We do it twice because SymGetModuleInfo seems to not always get it
        // the first time! - WHY? (lylec)
        //
        LoadModuleFromVMemData(g_hProcess, dwAddr);
        LoadModuleFromVMemData(g_hProcess, dwAddr);

        if (!_SymGetModuleInfo(g_hProcess, dwAddr, &mi))
        {
            TraceTag((tagMagic, "SymGetModuleInfo failed AGAIN with %d", GetLastError()));

            strncpy(psi->achModule, "<no module>", sizeof(psi->achModule)-1);

            fFoundModule = FALSE;
        }
    }

    if (fFoundModule)
    {
        psi->achModule[0] = '[';
        strncpy(&psi->achModule[1], mi.ModuleName, sizeof(psi->achModule)-3);
        strcat(psi->achModule, "]");

        TraceTag((tagMagic, "SymGetModuleInfo returned module %s", psi->achModule));
    }

    sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    sym.MaxNameLength = 255;

    if (_SymGetSymFromAddr(g_hProcess, dwAddr, &psi->dwOffset, &sym))
    {
        pszSymbol = sym.Name;
    }
    else
    {
        TraceTag((tagMagic, "SymGetSymFromAddr failed with %d", GetLastError()));
        pszSymbol = "<no symbol>";
    }

    strncpy(psi->achSymbol, pszSymbol, ARRAY_SIZE(psi->achSymbol)-1);
}

//+---------------------------------------------------------------------------
//
//  Helpers for imagehlp's StackWalk API.
//
//----------------------------------------------------------------------------

LPVOID
FormsFunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddr)
{
    return _SymFunctionTableAccess( hProcess, dwPCAddr );
}


//+---------------------------------------------------------------------------
//
//  Function:   FormsGetModuleBase
//
//  Synopsis:   Retrieves the base address of the module containing the given
//              virtual address.
//
//  Arguments:  [hProcess]      -- Process
//              [ReturnAddress] -- Virtual address to get base of.
//
//  Notes:      If the module information for the given module has not yet
//              been loaded, then it is loaded.
//
//----------------------------------------------------------------------------

DWORD_PTR
FormsGetModuleBase(HANDLE hProcess, DWORD_PTR ReturnAddress)
{
    IMAGEHLP_MODULE ModuleInfo;
    DWORD           dwBaseAddr;

    memset(&ModuleInfo, 0, sizeof(IMAGEHLP_MODULE));
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (_SymGetModuleInfo(hProcess, ReturnAddress, &ModuleInfo))
    {
        dwBaseAddr = ModuleInfo.BaseOfImage;
    }
    else
    {
        dwBaseAddr = LoadModuleFromVMemData(hProcess, ReturnAddress);
    }

    return dwBaseAddr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStackBacktrace
//
//  Synopsis:   Gets a stacktrace of the current stack, including symbols.
//
//  Arguments:  [ifrStart] -- How many stack elements to skip before starting.
//              [cfrTotal] -- How many elements to trace after starting
//              [pdwEip]   -- Array to be filled with stack addresses.
//              [psiSym]   -- This array is filled with symbol information.
//                             It should be big enough to hold cfrTotal elts.
//                             If NULL, no symbol information is stored.
//
//  Returns:    Number of elements actually retrieved.
//
//----------------------------------------------------------------------------

int
GetStackBacktrace(int             ifrStart,
                  int             cfrTotal,
                  DWORD *         pdwEip,
                  INET_SYMBOL_INFO *   psiSymbols)
{
    HANDLE        hThread;
    CONTEXT       context;
    STACKFRAME    stkfrm;
    DWORD         dwMachType;
    int           i;
    DWORD       * pdw        = pdwEip;
    INET_SYMBOL_INFO * psi        = psiSymbols;
    BOOL          fNeedLeave = TRUE;

    EnsureThreadState();

    TraceTag((tagMagic, "Entering GetStackBacktrace"));

    memset(pdwEip, 0, cfrTotal * sizeof(DWORD));

    if (psiSymbols)
    {
        memset(psiSymbols, 0, cfrTotal * sizeof(INET_SYMBOL_INFO));
    }

    if (!g_fLoadedImageHlp)
    {
        TraceTag((tagMagic, "ImageHlp not loaded! Bailing out of GetStackBacktrace!"));

        return 0;
    }

    hThread  = GetCurrentThread();

#if !defined(UNIX) && !defined(_M_IA64)                    // UNIXTODO will something similar be needed ?
    context.ContextFlags = CONTEXT_FULL;
#endif

    // Officially, GetThreadContext can't be called on the running thread.
    if (GetThreadContext(hThread, &context))
    {
        memset(&stkfrm, 0, sizeof(STACKFRAME));

#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter
        stkfrm.AddrPC.Mode      = AddrModeFlat;
        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;

#elif defined(_M_AMD64)
        dwMachType              = IMAGE_FILE_MACHINE_AMD64;
        stkfrm.AddrPC.Offset    = context.Rip;
        stkfrm.AddrPC.Mode      = AddrModeFlat;
        stkfrm.AddrStack.Offset = context.Rsp;
        stkfrm.AddrStack.Mode   = AddrModeFlat;

#elif defined(_M_IA64)
        dwMachType              = IMAGE_FILE_MACHINE_IA64;
        stkfrm.AddrPC.Offset    = context.StIIP;
        stkfrm.AddrPC.Mode      = AddrModeFlat;
        stkfrm.AddrStack.Offset = context.IntSp;
        stkfrm.AddrStack.Mode   = AddrModeFlat;

#elif defined(UNIX)
        dwMachType              = (DWORD) -1; // IEUNIX fill in correctly

#else
#error("Unknown Target Machine");
#endif

        //
        // We have to use a critical section because MSPDB50.DLL (and
        // maybe imagehlp.dll) is not reentrant and simultaneous calls
        // to StackWalk cause it to tromp on its own memory.
        //
        EnterCriticalSection(&g_csHeapHack);

        // Check this again just in case another thread failed and caused
        // imagehlp.dll to be unloaded.

        if (!g_fLoadedImageHlp)
        {
            return 0;
        }

        __try
        {
            for (i = 0; i < ifrStart + cfrTotal; i++)
            {
                if (!_StackWalk(dwMachType,
                                g_hProcess,
                                hThread,
                                &stkfrm,
                                &context,
                                NULL,
                                FormsFunctionTableAccess,
                                FormsGetModuleBase,
                                NULL))
                {
                    break;
                }

                if (i >= ifrStart)
                {
                    *pdw++ = stkfrm.AddrPC.Offset;

                    if (psi)
                    {
                        FillSymbolInfo(psi++, stkfrm.AddrPC.Offset);
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Something blew up. This can happen if someone asserts during
            // process cleanup or just because things are hosed. In this case
            // we empty our return data, unload imagehlp.dll so we don't try
            // any of this again, and return 0.
            //
            memset(pdwEip, 0, cfrTotal * sizeof(DWORD));

            if (psiSymbols)
            {
                memset(psiSymbols, 0, cfrTotal * sizeof(INET_SYMBOL_INFO));
            }

            // Block anyone else from using imagehlp.

            g_fLoadedImageHlp = FALSE;

            LeaveCriticalSection(&g_csHeapHack);

            fNeedLeave = FALSE;

            // This deletes the critical section
            MagicDeinit();

            pdw = pdwEip; // Will cause us to return 0
        }
        __endexcept
    }

    if (fNeedLeave)
    {
        LeaveCriticalSection(&g_csHeapHack);
    }

    return pdw - pdwEip;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromSymbolInfo
//
//  Synopsis:   Returns a string from an INET_SYMBOL_INFO
//
//  Arguments:  [dwAddr]    -- Memory Address corresponding to [psi]
//              [psi]       -- Pointer to INET_SYMBOL_INFO. Can be NULL.
//              [pszString] -- Place to put string
//
//----------------------------------------------------------------------------

void
GetStringFromSymbolInfo(DWORD dwAddr, INET_SYMBOL_INFO *psi, CHAR *pszString)
{
    if (psi)
    {

        wsprintfA(pszString,
                 "  %08x  %-11hs %hs + 0x%x",
                 dwAddr,
                 (psi->achModule[0]) ? psi->achModule : "<no module>",
                 (psi->achSymbol[0]) ? psi->achSymbol : "<no symbol>",
                 psi->dwOffset);
    }
    else
    {
        wsprintfA(pszString, "  %08x <symbols not available>", dwAddr);
    }
}

void WINAPI
DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf)
{
    INET_SYMBOL_INFO     si;
    char            ach[512];

    ach[0] = 0;

    FillSymbolInfo(&si, (DWORD)(DWORD_PTR)pvAddr);
    GetStringFromSymbolInfo((DWORD)(DWORD_PTR)pvAddr, &si, ach);
    strncpy(pszBuf, ach, cchBuf - 1);
    pszBuf[cchBuf - 1] = 0;
}

//
// Get stack trace, starting from frame iStart, and at most cTotal frames
//
// Results are returned in pvBuffer as array of
//      { DWORD dwAddress, char achModule[cchModule + 1], char achSymbol[cchSymbol + 1] }
//
// Stack trace depth is arbitrary limited at 100
//
int WINAPI
DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol)
{
    INET_SYMBOL_INFO asiSym[100];
    DWORD            dwEip[100];
    int              i;
    int              c = 0;
    int              cchMaxCopyModule = min(ARRAY_SIZE(asiSym[i].achModule), cchModule);
    int              cchMaxCopySymbol = min(ARRAY_SIZE(asiSym[i].achSymbol), cchSymbol);

    EnsureThreadState();

    // limit symbol lengths
    if (cTotal > ARRAY_SIZE(dwEip))
        cTotal = ARRAY_SIZE(dwEip);

    if (cTotal > (int) (cbBuffer / (sizeof(DWORD) + sizeof(char) * (cchModule + 1 + cchSymbol + 1)))) 
        cTotal = (int) (cbBuffer / (sizeof(DWORD) + sizeof(char) * (cchModule + 1 + cchSymbol + 1)));

    memset(pbBuffer, 0, cbBuffer);

    //
    // get the stack
    //
    c = GetStackBacktrace(iStart + 3, cTotal, dwEip, asiSym);

    // Copy stack to caller's buffer
    for (i = 0; i < c; i++)
    {
        *((DWORD *)pbBuffer) = dwEip[i];
        pbBuffer += sizeof(DWORD);

        // GetStackBacktrace puts square brackets around module name. Remove.
        char * pchModuleName     = asiSym[i].achModule + 1;
        char * pchModuleNameLim  = strchr(pchModuleName, ']');
        int    cchCopyModuleName = pchModuleNameLim
                                 ? min(pchModuleNameLim - pchModuleName, cchMaxCopyModule)
                                 : cchMaxCopyModule;
        
        strncpy((char *)pbBuffer, pchModuleName, cchCopyModuleName);
        pbBuffer += cchModule + 1;
        
        strncpy((char *)pbBuffer, asiSym[i].achSymbol, cchMaxCopySymbol);
        pbBuffer += cchSymbol + 1;
    }

    return c;
}


// -----------------
//
// Stacktrace Testing Code
//
// -----------------

int
Alpha(int n, int cdw, DWORD * pdw, INET_SYMBOL_INFO *psi)
{
    int     c;

    if (n > 0)
    {
        c = Alpha(n - 1, cdw, pdw, psi);
    }
    else
    {
        c = GetStackBacktrace(1, cdw, pdw, psi);
    }

    return c;
}


class CBeta
{
public:
    void        Foo(void);
    STDMETHOD(Bar) (int x, int y);
};

void
CBeta::Foo( )
{
    Bar(1, 2);
}

STDMETHODIMP
CBeta::Bar(int x, int y)
{
    int              i;
    int              c;
    DWORD            dwEip[8];
    INET_SYMBOL_INFO      asiSym[8];
    CHAR             achSymbol[256];

    TraceTag((0, "CBeta::Bar"));

    c = GetStackBacktrace(1, ARRAY_SIZE(dwEip), dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);

        TraceTag((0, "%s", achSymbol));
    }

    return S_OK;
}


void
TestStackTrace( )
{
    int              i;
    int              c;
    DWORD            dwEip[8];
    INET_SYMBOL_INFO      asiSym[8];
    CBeta            Beta;
    CHAR             achSymbol[256];

    static BOOL  fRepeat = FALSE;

    if (fRepeat)
    {
        return;
    }

    fRepeat = TRUE;

    TraceTag((0, "GetStackBacktrace"));

    c = GetStackBacktrace(1, ARRAY_SIZE(dwEip), dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);

        TraceTag((0, "%s", achSymbol));
    }

    TraceTag((0, "Alpha(3)"));

    c = Alpha(3, ARRAY_SIZE(dwEip), dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);

        TraceTag((0, "%s", achSymbol));
    }

    Beta.Foo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       resource.h
//
//  History:    10-06-93   ErikGav   Created
//
//----------------------------------------------------------------------------


#define tmcOk                   IDOK
#define tmcCancel               IDCANCEL
#define tmcStatic               -1
#define tmcListbox              101
#define tmcEnabled              102
#define tmcDisk                 103
#define tmcBreak                105
#define tmcEnableAll            107
#define tmcDisableAll           108

// Simulate failure dialog resources
#define IDD_SIMFAIL                 200
#define ID_LBLFAIL                  201
#define ID_TXTFAIL                  202
#define ID_LBLINTERVAL              203
#define ID_TXTINTERVAL              204
#define ID_LBLCOUNT                 205
#define ID_TXTCOUNT                 206
#define ID_BTNRESET                 207
#define ID_BTNNEVER                 208
#define ID_BTNUPDATE                209

/* Control Ids for the two dialogs - HeapMon & BlockEdit */
 
#define IDD_HEAPMON                 1000
#define IDG_HEADER                  1010
#define IDT_ALLOCNUM                1020
#define IDT_LIVEBLOCK               1030
#define IDT_FRAGIDX                 1040
#define IDE_ALLOCNUM                1050
#define IDE_LIVEBLOCK               1060
#define IDE_FRAGIDX                 1070
#define IDT_VIRTUAL                 1080
#define IDT_FILL                    1090
#define IDE_BLOCKS                  1100
#define IDT_BLOCKS                  1110
#define IDC_REFRESH                 1120
#define IDC_CLOSE                   1130
#define IDC_FILEDUMP                1140
#define IDE_FILEDUMP                1150
#define IDC_BLOCKLIST               1160
#define IDE_LIVEMEMORY              1200
#define IDG_SORTBY                  1210
#define IDC_SORTCFLAG               1220
#define IDC_SORTTYPE                1221
#define IDC_SORTNAME                1222
#define IDC_SORTADDRESS             1230
#define IDC_SORTALLOC               1240
#define IDC_SORTSIZE                1250
#define IDT_LIVEMEMORY              1260
#define IDT_RANGELOW                1280
#define IDE_RANGELOW                1270
#define IDT_RANGEHIGH               1310
#define IDE_RANGEHIGH               1290
#define IDT_RANGEEXTENT             1330
#define IDE_RANGEEXTENT             1300
#define IDC_SUMSEL                  1190
#define IDE_SUMSEL                  1320
#define IDC_HEAPLIST                1170
#define IDT_HEAPNAME                1180
#define IDC_VIRTUAL					1400
#define IDC_LOAD_SYMBOLS			1410
#define IDC_DUMPHEAPS               1411

#define IDD_BLOCKEDIT               2000
#define IDT_BE_ADDRESS              2010
#define IDT_BE_ALLOCNUM             2030
#define IDT_BE_SIZE                 2040
#define IDE_BE_ADDRESS              2050
#define IDE_BE_ALLOCNUM             2070
#define IDE_BE_SIZE                 2080
#define IDC_BE_MEMORY               2100
#define IDG_DATATYPE                2090
#define IDC_DWORD                   2110
#define IDC_WORD                    2120
#define IDC_BYTE                    2130
#define IDT_CALLSTACK               2170
#define IDC_CALLSTACK               2180

#define IDB_ICONIC					3000
#define IIC_ICONIC					3010

#define BROWSE_DLG					3000
#define IDC_TRACE_LIST				3001
#define ID_ADD						3002
#define ID_VIEW						3003
#define ID_REFRESH					3004
#define IDC_TOTALMEM                1000
#define IDC_CODEMEM                 1001
#define IDC_DATAMEM                 1002
#define IDC_RESERVEMEM              1003
#define IDC_READONLY                1004
#define IDC_READWRITE               1005
#define IDC_STATIC                  -1
#define ID_DUMP						3005

/* Perftags */

#define IDD_PERFTAGS                9700
#define IDC_TAGLIST                 9702
#define IDC_ENABLEALL               9703
#define IDC_DISABLEALL              9704
#define IDC_CLEARLOG                9705
#define IDC_DUMPLOG                 9706
#define IDC_DELETELOG               9707
//was:  IDC_REFRESH                 9708
#define IDC_STARTSTOP               9709
#define IDC_CLEARMETER              9710
#define IDC_BREAKMETER              9711
#define IDC_OOMMETER                9712
#define IDC_USEINTERVALOOM          9713
#define IDC_OOMINTERVAL             9714
#define IDC_ALLMEM                  9715
#define IDC_MARKEDMEM               9716
#define IDC_OOMCOUNT                9717
#define IDC_BREAKOOM                9718
#define IDC_EXPANDALL               9719
#define IDC_COLLAPSEALL             9720
#define IDC_CLEAROOM                9721
#define IDC_CLEARBREAK              9722

#define IDD_PERFMETER               9800

#define IDC_SHOWMETERS              9802
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\iwatch.cxx ===
//+---------------------------------------------------------------------
//
//  File:       iwatch.cxx
//
//  Contents:   Interface wrapper for method invocation traces
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include <hlink.h>
#endif

#ifndef X_DOCOBJ_H_
#define X_DOCOBJ_H_
#include <docobj.h>
#endif

static ULONG g_ulSSN;
static ULONG g_ulNestingLevel = 0;
static TCHAR g_szNULL[] = _T("(null)");     // string output for null string ptr

#define OUTPUTSTR(s)(s ? (s) : g_szNULL)	// wsprintf chokes on null string ptrs

#define INDENT_NESTING \
    TraceTagEx((tagTrackItfVerbose, TAG_NONEWLINE, "%*s", g_ulNestingLevel*4, "")); \
    InterlockedIncrement((LONG *)&g_ulNestingLevel)

#define INDENT_NESTING2 \
    TraceTagEx((tagTrackItfVerbose, TAG_NONEWLINE, "%*s", g_ulNestingLevel*4, ""));

#undef TRETURN
#define TRETURN(hr) \
    {                                                    \
        HRESULT hr2 = hr;                                \
        InterlockedDecrement((LONG *)&g_ulNestingLevel); \
        INDENT_NESTING2;                                 \
        TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%hr", hr2)); \
        SRETURN(hr2);                                    \
    }

typedef void (*PFNVOID)();

#define TAG_FLAGS  (TAG_NONAME | TAG_NONEWLINE)


//+---------------------------------------------------------------
//
//  Function:   GetIIDName
//
//----------------------------------------------------------------


EXTERN_C const GUID IID_IDispatchEx;
EXTERN_C const GUID IID_IInternetHostSecurityManager;
EXTERN_C const GUID IID_IPersistHistory;
EXTERN_C const GUID IID_ITargetContainer;

static const char *
GetIIDName(REFIID iid)
{

#define CASE_IID(itf) if (IID_##itf == iid) return #itf;

    CASE_IID(IDispatchEx)
    CASE_IID(IInternetHostSecurityManager)
    CASE_IID(IPersistHistory)
    CASE_IID(ITargetContainer)
    CASE_IID(IAdviseSink)
    CASE_IID(IAdviseSink2)
    CASE_IID(IBindCtx)
    CASE_IID(IClassFactory)
    CASE_IID(IOleParentUndoUnit)
    CASE_IID(IConnectionPoint)
    CASE_IID(IConnectionPointContainer)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IDataObject)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IDispatch)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IEnumCallback)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumString)
    CASE_IID(IEnumUnknown)
    CASE_IID(IExternalConnection)
    CASE_IID(ILockBytes)
    CASE_IID(IMarshal)
    CASE_IID(IOleCommandTarget)
    CASE_IID(IOleDocument)
    CASE_IID(IOleDocumentView)
    CASE_IID(IOleDocumentSite)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IOleCache)
    CASE_IID(IOleCache2)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleContainer)
    CASE_IID(IOleControl)
    CASE_IID(IOleControlSite)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IOleInPlaceObjectWindowless)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IOleInPlaceSiteWindowless)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleLink)
    CASE_IID(IOleManager)
    CASE_IID(IOleObject)
    CASE_IID(IOlePresObj)
    CASE_IID(IOleWindow)
    CASE_IID(IParseDisplayName)
    CASE_IID(IPerPropertyBrowsing)
    CASE_IID(IPersist)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistStream)
    CASE_IID(IPersistStreamInit)
    CASE_IID(IPersistPropertyBag)
    CASE_IID(IProvideClassInfo)
    CASE_IID(IQuickActivate)
    CASE_IID(IRunnableObject)
    CASE_IID(IServiceProvider)
    CASE_IID(ISpecifyPropertyPages)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    CASE_IID(IUnknown)
    CASE_IID(IOleUndoUnit)
    CASE_IID(IOleUndoManager)
    CASE_IID(IViewObject)
    CASE_IID(IViewObject2)
    CASE_IID(IViewObjectEx)
#undef CASE_IID

    // The following is not thread safe.  The only bad thing that can
    // happen is that we get bogus debug output. It's not worth fixing.

    static char ach[32];
    wsprintfA(ach, "%08x", iid.Data1);
    return ach;
}

//---------------------------------------------------------------
//
//  Class:      CTrack
//
//---------------------------------------------------------------

class CTrack
{
public:

    void * __cdecl operator new(size_t cb);
    void __cdecl operator delete(void *pv);

    CTrack(IUnknown *pUnk, REFIID iid, char *pch, BOOL fTrackOnQI);

    virtual ~CTrack();

    ULONG STDMETHODCALLTYPE AddRef();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppv);

    ULONG       _ulRefs;
    ULONG       _ulSSN;
    char *      _pch;
    BOOL        _fTrackOnQI;
    IUnknown *  _pUnk;          // ASM code below relies on this being the last member in the class!
};


inline void * __cdecl 
CTrack::operator new(size_t cb)
{
    return DbgExPostAlloc(malloc(DbgExPreAlloc(cb))); 
}

inline void __cdecl 
CTrack::operator delete(void *pv)
{
    free(DbgExPreFree(pv)); 
    DbgExPostFree(); 
}

CTrack::CTrack(IUnknown *pUnk, REFIID iid, char *pch, BOOL fTrackOnQI)
{
    _ulRefs = 1;
    _pUnk = pUnk;
    _ulSSN = g_ulSSN++;
    _pch = pch;
    _fTrackOnQI = fTrackOnQI;

    DbgExMemSetName(this, "TI %s p=%08x ssn=%d id=%s", pch, _pUnk, _ulSSN, GetIIDName(iid));
}

CTrack::~CTrack()
{ 
	_pUnk->Release(); 
}

ULONG STDMETHODCALLTYPE 
CTrack::Release()
{
    if (InterlockedDecrement((long *)&_ulRefs) == 0)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

ULONG STDMETHODCALLTYPE 
CTrack::AddRef()
{ 
    return InterlockedIncrement((long *)&_ulRefs); 
}

HRESULT STDMETHODCALLTYPE 
CTrack::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr;
    
    hr = _pUnk->QueryInterface(iid, ppv);
    if (_fTrackOnQI)
    {
        DbgExTrackItf(iid, _pch, TRUE, ppv);
    }
    return hr;
}

#define BEGIN_TRACK(itf)\
class C##itf : public CTrack, public I##itf {\
public:\
    static IUnknown * Create(IUnknown *pUnk, char *pch, BOOL fTrackOnQI) { return new C##itf(pUnk, pch, fTrackOnQI); } \
    I##itf *_p; \
    C##itf(IUnknown *pUnk, char *pch, BOOL fTrackOnQI) : CTrack(pUnk, IID_I##itf, pch, fTrackOnQI), _p((I##itf *)pUnk) { } \
    ULONG STDMETHODCALLTYPE AddRef() { return CTrack::AddRef(); } \
    ULONG STDMETHODCALLTYPE Release() { return CTrack::Release(); } \
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppv) { return CTrack::QueryInterface(iid, ppv); } \

#define END_TRACK() };

//---------------------------------------------------------------
//
//  Class:      CWrapArg
//
//---------------------------------------------------------------

class CWrapArg
{
public:
    CWrapArg(CTrack *pTrack, REFIID iid, void **ppv);
    ~CWrapArg();
    IUnknown ** _ppUnk;
};

CWrapArg::CWrapArg(CTrack *pTrack, REFIID iid, void **ppv)
{
    _ppUnk = (IUnknown **)ppv;
    if (*_ppUnk)
    {
        (*_ppUnk)->AddRef();
        DbgExTrackItf(iid, pTrack->_pch, TRUE, ppv);
    }
}

CWrapArg::~CWrapArg()
{
    if (*_ppUnk)
    {
        (*_ppUnk)->Release();
    }
}

//---------------------------------------------------------------
//
//  IOleObject
//
//---------------------------------------------------------------

BEGIN_TRACK(OleObject)

HRESULT STDMETHODCALLTYPE
SetClientSite(LPOLECLIENTSITE pClientSite)
{
    //CWrapArg arg(this, IID_IOleClientSite, (void **)&pClientSite);

    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetClientSite\n", _pch));
    TRETURN(_p->SetClientSite(pClientSite));
}

HRESULT STDMETHODCALLTYPE
GetClientSite(LPOLECLIENTSITE FAR* ppClientSite)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClientSite\n", _pch));
    TRETURN(_p->GetClientSite(ppClientSite));
}

HRESULT STDMETHODCALLTYPE
SetHostNames(LPCOLESTR szCntrApp, LPCOLESTR szCntrObj)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetHostNames(%ls,%ls)\n",
            _pch,
            OUTPUTSTR(szCntrApp),
            OUTPUTSTR(szCntrObj)));

    TRETURN(_p->SetHostNames(szCntrApp, szCntrObj));
}

HRESULT STDMETHODCALLTYPE
Close(DWORD reserved)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Close(%lu)\n", _pch, reserved));
    TRETURN(_p->Close(reserved));
}

HRESULT STDMETHODCALLTYPE
SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetMoniker\n", _pch));
    TRETURN(_p->SetMoniker(dwWhichMoniker, pmk));
}

HRESULT STDMETHODCALLTYPE
GetMoniker(DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER FAR* ppmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMoniker\n", _pch));
    TRETURN(_p->GetMoniker(dwAssign, dwWhichMoniker, ppmk));
}

HRESULT STDMETHODCALLTYPE
InitFromData(LPDATAOBJECT pDataObject,
        BOOL fCreation,
        DWORD dwReserved)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitFromData\n", _pch));
    TRETURN(_p->InitFromData(pDataObject, fCreation, dwReserved));
}

HRESULT STDMETHODCALLTYPE
GetClipboardData(DWORD dwReserved,
        LPDATAOBJECT FAR* ppDataObject)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClipboardData\n", _pch));
    TRETURN(_p->GetClipboardData(dwReserved, ppDataObject));
}

HRESULT STDMETHODCALLTYPE
DoVerb(LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPos)
{

    static char * apszVerbs[] = {
                                  "OLEIVERB_PRIMARY", //            (0L)
                                  "OLEIVERB_SHOW",    //            (-1L)
                                  "OLEIVERB_OPEN",    //            (-2L)
                                  "OLEIVERB_HIDE",    //            (-3L)
                                  "OLEIVERB_UIACTIVATE", //         (-4L)
                                  "OLEIVERB_INPLACEACTIVATE", //    (-5L)
                                  "OLEIVERB_DISCARDUNDOSTATE" //    (-6L)
                                };
    RECT rc = { 0 };

    INDENT_NESTING;

    if (lprcPos)
        rc = *lprcPos;

    if ((iVerb > 0) || (-iVerb > ARRAY_SIZE(apszVerbs)))
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DoVerb(%ld,,,,,%s), pPos=(%d,%d,%d,%d)\n",
                    _pch, iVerb, ((lprcPos) ? "pPos" : "(null)"),
                    rc.left, rc.top, rc.right, rc.bottom
                    ));
    }
    else
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DoVerb(%s,,,,,%s), pPos=(%d,%d,%d,%d)\n",
                    _pch, apszVerbs[-iVerb], ((lprcPos) ? "pPos" : NULL),
                    rc.left, rc.top, rc.right, rc.bottom
                    ));
    }

    TRETURN(_p->DoVerb(iVerb,
            lpmsg,
            pActiveSite,
            lindex,
            hwndParent,
            lprcPos));
}

HRESULT STDMETHODCALLTYPE
EnumVerbs(LPENUMOLEVERB FAR* ppenum)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumVerbs\n", _pch));
    TRETURN(_p->EnumVerbs(ppenum));
}

HRESULT STDMETHODCALLTYPE
Update()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Update\n", _pch));
    TRETURN(_p->Update());
}

HRESULT STDMETHODCALLTYPE
IsUpToDate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsUpToDate\n", _pch));
    TRETURN(_p->IsUpToDate());
}

HRESULT STDMETHODCALLTYPE
GetUserClassID(CLSID FAR* pClsid)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetUserClassID\n", _pch));
    TRETURN(_p->GetUserClassID(pClsid));
}

HRESULT STDMETHODCALLTYPE
GetUserType(DWORD dwFormOfType, LPOLESTR FAR* ppch)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetUserType\n", _pch));
    TRETURN(_p->GetUserType(dwFormOfType, ppch));
}

HRESULT STDMETHODCALLTYPE
SetExtent(DWORD dwDrawAspect, SIZEL * lpsizel)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetExtent(%d, (cx=%d,cy=%d))\n",
                _pch, dwDrawAspect, lpsizel->cx, lpsizel->cy));
    TRETURN(_p->SetExtent(dwDrawAspect, lpsizel));
}

HRESULT STDMETHODCALLTYPE
GetExtent(DWORD dwDrawAspect, SIZEL * lpsizel)
{
    HRESULT hr;

    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetExtent\n", _pch));

    hr = _p->GetExtent(dwDrawAspect, lpsizel);

    InterlockedDecrement((LONG *)&g_ulNestingLevel);
    INDENT_NESTING2;
    TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%s::GetExtent Returning cx=%d,cy=%d, %hr.",
                _pch, lpsizel->cx, lpsizel->cy, hr));
    SRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
Advise(IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Advise\n", _pch));
    TRETURN(_p->Advise(pAdvSink, pdwConnection));
}

HRESULT STDMETHODCALLTYPE
Unadvise(DWORD dwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Unadvise\n", _pch));
    TRETURN(_p->Unadvise(dwConnection));
}

HRESULT STDMETHODCALLTYPE
EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumAdvise\n", _pch));
    TRETURN(_p->EnumAdvise(ppenumAdvise));
}

HRESULT STDMETHODCALLTYPE
GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMiscStatus\n", _pch));
    TRETURN(_p->GetMiscStatus(dwAspect, pdwStatus));
}

HRESULT STDMETHODCALLTYPE
SetColorScheme(LPLOGPALETTE lpLogpal)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetColorScheme\n", _pch));
    TRETURN(_p->SetColorScheme(lpLogpal));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleClientSite
//
//---------------------------------------------------------------

BEGIN_TRACK(OleClientSite)

HRESULT STDMETHODCALLTYPE
SaveObject()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SaveObject\n", _pch));
    TRETURN(_p->SaveObject());
}

HRESULT STDMETHODCALLTYPE
GetMoniker(DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER FAR* ppmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMoniker\n", _pch));
    TRETURN(_p->GetMoniker(dwAssign, dwWhichMoniker, ppmk));
}

HRESULT STDMETHODCALLTYPE
GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    INDENT_NESTING;
    Trac